
_timerapp：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <drawNumberToContent>:

RGB * numbers[10];
RGB * separator;

void drawNumberToContent(int minute, int second)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	81 ec 98 00 00 00    	sub    $0x98,%esp
    static int beforefirst = 0;
    static int beforesecond = 0;
    static int beforethird = 0;
    static int beforefourth = 0;

    int nowfirst = second % 10;
       9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
       c:	ba 67 66 66 66       	mov    $0x66666667,%edx
      11:	89 c8                	mov    %ecx,%eax
      13:	f7 ea                	imul   %edx
      15:	c1 fa 02             	sar    $0x2,%edx
      18:	89 c8                	mov    %ecx,%eax
      1a:	c1 f8 1f             	sar    $0x1f,%eax
      1d:	29 c2                	sub    %eax,%edx
      1f:	89 d0                	mov    %edx,%eax
      21:	c1 e0 02             	shl    $0x2,%eax
      24:	01 d0                	add    %edx,%eax
      26:	01 c0                	add    %eax,%eax
      28:	29 c1                	sub    %eax,%ecx
      2a:	89 c8                	mov    %ecx,%eax
      2c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int nowsecond = second / 10;
      2f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
      32:	ba 67 66 66 66       	mov    $0x66666667,%edx
      37:	89 c8                	mov    %ecx,%eax
      39:	f7 ea                	imul   %edx
      3b:	c1 fa 02             	sar    $0x2,%edx
      3e:	89 c8                	mov    %ecx,%eax
      40:	c1 f8 1f             	sar    $0x1f,%eax
      43:	29 c2                	sub    %eax,%edx
      45:	89 d0                	mov    %edx,%eax
      47:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int nowthird = minute % 10;
      4a:	8b 4d 08             	mov    0x8(%ebp),%ecx
      4d:	ba 67 66 66 66       	mov    $0x66666667,%edx
      52:	89 c8                	mov    %ecx,%eax
      54:	f7 ea                	imul   %edx
      56:	c1 fa 02             	sar    $0x2,%edx
      59:	89 c8                	mov    %ecx,%eax
      5b:	c1 f8 1f             	sar    $0x1f,%eax
      5e:	29 c2                	sub    %eax,%edx
      60:	89 d0                	mov    %edx,%eax
      62:	c1 e0 02             	shl    $0x2,%eax
      65:	01 d0                	add    %edx,%eax
      67:	01 c0                	add    %eax,%eax
      69:	29 c1                	sub    %eax,%ecx
      6b:	89 c8                	mov    %ecx,%eax
      6d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    int nowfourth = minute / 10;
      70:	8b 4d 08             	mov    0x8(%ebp),%ecx
      73:	ba 67 66 66 66       	mov    $0x66666667,%edx
      78:	89 c8                	mov    %ecx,%eax
      7a:	f7 ea                	imul   %edx
      7c:	c1 fa 02             	sar    $0x2,%edx
      7f:	89 c8                	mov    %ecx,%eax
      81:	c1 f8 1f             	sar    $0x1f,%eax
      84:	29 c2                	sub    %eax,%edx
      86:	89 d0                	mov    %edx,%eax
      88:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if (beforefirst != nowfirst)
      8b:	a1 a4 ec 01 00       	mov    0x1eca4,%eax
      90:	3b 45 f4             	cmp    -0xc(%ebp),%eax
      93:	0f 84 97 00 00 00    	je     130 <drawNumberToContent+0x130>
    {
        api_paint24BitmapToContent(&wnd, numbers[nowfirst], (Point){185,35}, (Point){0,0},
                                   (Size){55, 40}, (Size){55, 40});
      99:	c7 85 68 ff ff ff 37 	movl   $0x37,-0x98(%ebp)
      a0:	00 00 00 
      a3:	c7 85 6c ff ff ff 28 	movl   $0x28,-0x94(%ebp)
      aa:	00 00 00 
      ad:	c7 85 70 ff ff ff 37 	movl   $0x37,-0x90(%ebp)
      b4:	00 00 00 
      b7:	c7 85 74 ff ff ff 28 	movl   $0x28,-0x8c(%ebp)
      be:	00 00 00 
    int nowthird = minute % 10;
    int nowfourth = minute / 10;

    if (beforefirst != nowfirst)
    {
        api_paint24BitmapToContent(&wnd, numbers[nowfirst], (Point){185,35}, (Point){0,0},
      c1:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
      c8:	00 00 00 
      cb:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
      d2:	00 00 00 
      d5:	c7 45 80 b9 00 00 00 	movl   $0xb9,-0x80(%ebp)
      dc:	c7 45 84 23 00 00 00 	movl   $0x23,-0x7c(%ebp)
      e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
      e6:	8b 04 85 40 ed 01 00 	mov    0x1ed40(,%eax,4),%eax
      ed:	83 ec 08             	sub    $0x8,%esp
      f0:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
      f6:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
      fc:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
     102:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
     108:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
     10e:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
     114:	ff 75 84             	pushl  -0x7c(%ebp)
     117:	ff 75 80             	pushl  -0x80(%ebp)
     11a:	50                   	push   %eax
     11b:	68 00 ed 01 00       	push   $0x1ed00
     120:	e8 84 18 00 00       	call   19a9 <api_paint24BitmapToContent>
     125:	83 c4 30             	add    $0x30,%esp
                                   (Size){55, 40}, (Size){55, 40});
        beforefirst = nowfirst;
     128:	8b 45 f4             	mov    -0xc(%ebp),%eax
     12b:	a3 a4 ec 01 00       	mov    %eax,0x1eca4
    }
    if (beforesecond != nowsecond)
     130:	a1 a8 ec 01 00       	mov    0x1eca8,%eax
     135:	3b 45 f0             	cmp    -0x10(%ebp),%eax
     138:	74 73                	je     1ad <drawNumberToContent+0x1ad>
    {
        api_paint24BitmapToContent(&wnd, numbers[nowsecond], (Point){145,35}, (Point){0,0},
                                   (Size){55, 40}, (Size){55, 40});
     13a:	c7 45 88 37 00 00 00 	movl   $0x37,-0x78(%ebp)
     141:	c7 45 8c 28 00 00 00 	movl   $0x28,-0x74(%ebp)
     148:	c7 45 90 37 00 00 00 	movl   $0x37,-0x70(%ebp)
     14f:	c7 45 94 28 00 00 00 	movl   $0x28,-0x6c(%ebp)
                                   (Size){55, 40}, (Size){55, 40});
        beforefirst = nowfirst;
    }
    if (beforesecond != nowsecond)
    {
        api_paint24BitmapToContent(&wnd, numbers[nowsecond], (Point){145,35}, (Point){0,0},
     156:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
     15d:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
     164:	c7 45 a0 91 00 00 00 	movl   $0x91,-0x60(%ebp)
     16b:	c7 45 a4 23 00 00 00 	movl   $0x23,-0x5c(%ebp)
     172:	8b 45 f0             	mov    -0x10(%ebp),%eax
     175:	8b 04 85 40 ed 01 00 	mov    0x1ed40(,%eax,4),%eax
     17c:	83 ec 08             	sub    $0x8,%esp
     17f:	ff 75 8c             	pushl  -0x74(%ebp)
     182:	ff 75 88             	pushl  -0x78(%ebp)
     185:	ff 75 94             	pushl  -0x6c(%ebp)
     188:	ff 75 90             	pushl  -0x70(%ebp)
     18b:	ff 75 9c             	pushl  -0x64(%ebp)
     18e:	ff 75 98             	pushl  -0x68(%ebp)
     191:	ff 75 a4             	pushl  -0x5c(%ebp)
     194:	ff 75 a0             	pushl  -0x60(%ebp)
     197:	50                   	push   %eax
     198:	68 00 ed 01 00       	push   $0x1ed00
     19d:	e8 07 18 00 00       	call   19a9 <api_paint24BitmapToContent>
     1a2:	83 c4 30             	add    $0x30,%esp
                                   (Size){55, 40}, (Size){55, 40});
        beforesecond = nowsecond;
     1a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
     1a8:	a3 a8 ec 01 00       	mov    %eax,0x1eca8
    }
    if (beforethird != nowthird)
     1ad:	a1 ac ec 01 00       	mov    0x1ecac,%eax
     1b2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     1b5:	74 73                	je     22a <drawNumberToContent+0x22a>
    {
        api_paint24BitmapToContent(&wnd, numbers[nowthird], (Point){65,35}, (Point){0,0},
                                   (Size){55, 40}, (Size){55, 40});
     1b7:	c7 45 a8 37 00 00 00 	movl   $0x37,-0x58(%ebp)
     1be:	c7 45 ac 28 00 00 00 	movl   $0x28,-0x54(%ebp)
     1c5:	c7 45 b0 37 00 00 00 	movl   $0x37,-0x50(%ebp)
     1cc:	c7 45 b4 28 00 00 00 	movl   $0x28,-0x4c(%ebp)
                                   (Size){55, 40}, (Size){55, 40});
        beforesecond = nowsecond;
    }
    if (beforethird != nowthird)
    {
        api_paint24BitmapToContent(&wnd, numbers[nowthird], (Point){65,35}, (Point){0,0},
     1d3:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
     1da:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
     1e1:	c7 45 c0 41 00 00 00 	movl   $0x41,-0x40(%ebp)
     1e8:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%ebp)
     1ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
     1f2:	8b 04 85 40 ed 01 00 	mov    0x1ed40(,%eax,4),%eax
     1f9:	83 ec 08             	sub    $0x8,%esp
     1fc:	ff 75 ac             	pushl  -0x54(%ebp)
     1ff:	ff 75 a8             	pushl  -0x58(%ebp)
     202:	ff 75 b4             	pushl  -0x4c(%ebp)
     205:	ff 75 b0             	pushl  -0x50(%ebp)
     208:	ff 75 bc             	pushl  -0x44(%ebp)
     20b:	ff 75 b8             	pushl  -0x48(%ebp)
     20e:	ff 75 c4             	pushl  -0x3c(%ebp)
     211:	ff 75 c0             	pushl  -0x40(%ebp)
     214:	50                   	push   %eax
     215:	68 00 ed 01 00       	push   $0x1ed00
     21a:	e8 8a 17 00 00       	call   19a9 <api_paint24BitmapToContent>
     21f:	83 c4 30             	add    $0x30,%esp
                                   (Size){55, 40}, (Size){55, 40});
        beforethird = nowthird;
     222:	8b 45 ec             	mov    -0x14(%ebp),%eax
     225:	a3 ac ec 01 00       	mov    %eax,0x1ecac
    }
    if (beforefourth != nowfourth)
     22a:	a1 b0 ec 01 00       	mov    0x1ecb0,%eax
     22f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     232:	74 73                	je     2a7 <drawNumberToContent+0x2a7>
    {
        api_paint24BitmapToContent(&wnd, numbers[nowfourth], (Point){25,35}, (Point){0,0},
                                   (Size){55, 40}, (Size){55, 40});
     234:	c7 45 c8 37 00 00 00 	movl   $0x37,-0x38(%ebp)
     23b:	c7 45 cc 28 00 00 00 	movl   $0x28,-0x34(%ebp)
     242:	c7 45 d0 37 00 00 00 	movl   $0x37,-0x30(%ebp)
     249:	c7 45 d4 28 00 00 00 	movl   $0x28,-0x2c(%ebp)
                                   (Size){55, 40}, (Size){55, 40});
        beforethird = nowthird;
    }
    if (beforefourth != nowfourth)
    {
        api_paint24BitmapToContent(&wnd, numbers[nowfourth], (Point){25,35}, (Point){0,0},
     250:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
     257:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
     25e:	c7 45 e0 19 00 00 00 	movl   $0x19,-0x20(%ebp)
     265:	c7 45 e4 23 00 00 00 	movl   $0x23,-0x1c(%ebp)
     26c:	8b 45 e8             	mov    -0x18(%ebp),%eax
     26f:	8b 04 85 40 ed 01 00 	mov    0x1ed40(,%eax,4),%eax
     276:	83 ec 08             	sub    $0x8,%esp
     279:	ff 75 cc             	pushl  -0x34(%ebp)
     27c:	ff 75 c8             	pushl  -0x38(%ebp)
     27f:	ff 75 d4             	pushl  -0x2c(%ebp)
     282:	ff 75 d0             	pushl  -0x30(%ebp)
     285:	ff 75 dc             	pushl  -0x24(%ebp)
     288:	ff 75 d8             	pushl  -0x28(%ebp)
     28b:	ff 75 e4             	pushl  -0x1c(%ebp)
     28e:	ff 75 e0             	pushl  -0x20(%ebp)
     291:	50                   	push   %eax
     292:	68 00 ed 01 00       	push   $0x1ed00
     297:	e8 0d 17 00 00       	call   19a9 <api_paint24BitmapToContent>
     29c:	83 c4 30             	add    $0x30,%esp
                                   (Size){55, 40}, (Size){55, 40});
        beforefourth = nowfourth;
     29f:	8b 45 e8             	mov    -0x18(%ebp),%eax
     2a2:	a3 b0 ec 01 00       	mov    %eax,0x1ecb0
    }
}
     2a7:	90                   	nop
     2a8:	c9                   	leave  
     2a9:	c3                   	ret    

000002aa <MsgProc>:

int flag = 0;
void MsgProc(struct message * msg)
{
     2aa:	55                   	push   %ebp
     2ab:	89 e5                	mov    %esp,%ebp
     2ad:	83 ec 18             	sub    $0x18,%esp
    static int second = 0;
    static int minute = 0;
    int i;
    switch (msg->msg_type)
     2b0:	8b 45 08             	mov    0x8(%ebp),%eax
     2b3:	8b 00                	mov    (%eax),%eax
     2b5:	83 f8 09             	cmp    $0x9,%eax
     2b8:	74 0a                	je     2c4 <MsgProc+0x1a>
     2ba:	83 f8 0a             	cmp    $0xa,%eax
     2bd:	74 5f                	je     31e <MsgProc+0x74>
               free(numbers[i]);
            }
            api_destroywindow(&wnd);
            break;
    }
}
     2bf:	e9 a5 00 00 00       	jmp    369 <MsgProc+0xbf>
    static int minute = 0;
    int i;
    switch (msg->msg_type)
    {
        case M_TIMER:
            if (second < 59)
     2c4:	a1 b4 ec 01 00       	mov    0x1ecb4,%eax
     2c9:	83 f8 3a             	cmp    $0x3a,%eax
     2cc:	7f 0f                	jg     2dd <MsgProc+0x33>
            {
                second++;
     2ce:	a1 b4 ec 01 00       	mov    0x1ecb4,%eax
     2d3:	83 c0 01             	add    $0x1,%eax
     2d6:	a3 b4 ec 01 00       	mov    %eax,0x1ecb4
     2db:	eb 17                	jmp    2f4 <MsgProc+0x4a>
            }
            else
            {
                second = 0;
     2dd:	c7 05 b4 ec 01 00 00 	movl   $0x0,0x1ecb4
     2e4:	00 00 00 
                minute++;
     2e7:	a1 b8 ec 01 00       	mov    0x1ecb8,%eax
     2ec:	83 c0 01             	add    $0x1,%eax
     2ef:	a3 b8 ec 01 00       	mov    %eax,0x1ecb8
            }
            drawNumberToContent(minute, second);
     2f4:	8b 15 b4 ec 01 00    	mov    0x1ecb4,%edx
     2fa:	a1 b8 ec 01 00       	mov    0x1ecb8,%eax
     2ff:	83 ec 08             	sub    $0x8,%esp
     302:	52                   	push   %edx
     303:	50                   	push   %eax
     304:	e8 f7 fc ff ff       	call   0 <drawNumberToContent>
     309:	83 c4 10             	add    $0x10,%esp
            api_repaint(&wnd);
     30c:	83 ec 0c             	sub    $0xc,%esp
     30f:	68 00 ed 01 00       	push   $0x1ed00
     314:	e8 10 17 00 00       	call   1a29 <api_repaint>
     319:	83 c4 10             	add    $0x10,%esp
            break;
     31c:	eb 4b                	jmp    369 <MsgProc+0xbf>
        case M_CLOSE_WINDOW:
            free(separator);
     31e:	a1 e4 ec 01 00       	mov    0x1ece4,%eax
     323:	83 ec 0c             	sub    $0xc,%esp
     326:	50                   	push   %eax
     327:	e8 ef 09 00 00       	call   d1b <free>
     32c:	83 c4 10             	add    $0x10,%esp
            for (i = 0; i < 10; i++)
     32f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     336:	eb 1a                	jmp    352 <MsgProc+0xa8>
            {
               free(numbers[i]);
     338:	8b 45 f4             	mov    -0xc(%ebp),%eax
     33b:	8b 04 85 40 ed 01 00 	mov    0x1ed40(,%eax,4),%eax
     342:	83 ec 0c             	sub    $0xc,%esp
     345:	50                   	push   %eax
     346:	e8 d0 09 00 00       	call   d1b <free>
     34b:	83 c4 10             	add    $0x10,%esp
            drawNumberToContent(minute, second);
            api_repaint(&wnd);
            break;
        case M_CLOSE_WINDOW:
            free(separator);
            for (i = 0; i < 10; i++)
     34e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     352:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
     356:	7e e0                	jle    338 <MsgProc+0x8e>
            {
               free(numbers[i]);
            }
            api_destroywindow(&wnd);
     358:	83 ec 0c             	sub    $0xc,%esp
     35b:	68 00 ed 01 00       	push   $0x1ed00
     360:	e8 67 19 00 00       	call   1ccc <api_destroywindow>
     365:	83 c4 10             	add    $0x10,%esp
            break;
     368:	90                   	nop
    }
}
     369:	90                   	nop
     36a:	c9                   	leave  
     36b:	c3                   	ret    

0000036c <main>:

int
main(void)
{
     36c:	8d 4c 24 04          	lea    0x4(%esp),%ecx
     370:	83 e4 f0             	and    $0xfffffff0,%esp
     373:	ff 71 fc             	pushl  -0x4(%ecx)
     376:	55                   	push   %ebp
     377:	89 e5                	mov    %esp,%ebp
     379:	51                   	push   %ecx
     37a:	81 ec f4 00 00 00    	sub    $0xf4,%esp
    wnd.pos.x = 100;
     380:	c7 05 04 ed 01 00 64 	movl   $0x64,0x1ed04
     387:	00 00 00 
    wnd.pos.y = 100;
     38a:	c7 05 08 ed 01 00 64 	movl   $0x64,0x1ed08
     391:	00 00 00 
    wnd.size.w = 250;
     394:	c7 05 10 ed 01 00 fa 	movl   $0xfa,0x1ed10
     39b:	00 00 00 
    wnd.size.h = 100;
     39e:	c7 05 0c ed 01 00 64 	movl   $0x64,0x1ed0c
     3a5:	00 00 00 
    wnd.title = "TimerApp";
     3a8:	c7 05 14 ed 01 00 e0 	movl   $0x164e0,0x1ed14
     3af:	64 01 00 

    char* numberFilename[10] = {"0.bmp", "1.bmp", "2.bmp", "3.bmp", "4.bmp", "5.bmp", "6.bmp", "7.bmp", "8.bmp", "9.bmp"};
     3b2:	c7 85 2c ff ff ff e9 	movl   $0x164e9,-0xd4(%ebp)
     3b9:	64 01 00 
     3bc:	c7 85 30 ff ff ff ef 	movl   $0x164ef,-0xd0(%ebp)
     3c3:	64 01 00 
     3c6:	c7 85 34 ff ff ff f5 	movl   $0x164f5,-0xcc(%ebp)
     3cd:	64 01 00 
     3d0:	c7 85 38 ff ff ff fb 	movl   $0x164fb,-0xc8(%ebp)
     3d7:	64 01 00 
     3da:	c7 85 3c ff ff ff 01 	movl   $0x16501,-0xc4(%ebp)
     3e1:	65 01 00 
     3e4:	c7 85 40 ff ff ff 07 	movl   $0x16507,-0xc0(%ebp)
     3eb:	65 01 00 
     3ee:	c7 85 44 ff ff ff 0d 	movl   $0x1650d,-0xbc(%ebp)
     3f5:	65 01 00 
     3f8:	c7 85 48 ff ff ff 13 	movl   $0x16513,-0xb8(%ebp)
     3ff:	65 01 00 
     402:	c7 85 4c ff ff ff 19 	movl   $0x16519,-0xb4(%ebp)
     409:	65 01 00 
     40c:	c7 85 50 ff ff ff 1f 	movl   $0x1651f,-0xb0(%ebp)
     413:	65 01 00 
    char  separatorFilename[] = "separator.bmp";
     416:	c7 85 1e ff ff ff 73 	movl   $0x61706573,-0xe2(%ebp)
     41d:	65 70 61 
     420:	c7 85 22 ff ff ff 72 	movl   $0x6f746172,-0xde(%ebp)
     427:	61 74 6f 
     42a:	c7 85 26 ff ff ff 72 	movl   $0x6d622e72,-0xda(%ebp)
     431:	2e 62 6d 
     434:	66 c7 85 2a ff ff ff 	movw   $0x70,-0xd6(%ebp)
     43b:	70 00 

    int i;

    for (i = 0; i < 10; i++)
     43d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     444:	eb 20                	jmp    466 <main+0xfa>
    {
        numbers[i] = malloc(55 * 40 * 3);
     446:	83 ec 0c             	sub    $0xc,%esp
     449:	68 c8 19 00 00       	push   $0x19c8
     44e:	e8 0a 0a 00 00       	call   e5d <malloc>
     453:	83 c4 10             	add    $0x10,%esp
     456:	89 c2                	mov    %eax,%edx
     458:	8b 45 f4             	mov    -0xc(%ebp),%eax
     45b:	89 14 85 40 ed 01 00 	mov    %edx,0x1ed40(,%eax,4)
    char* numberFilename[10] = {"0.bmp", "1.bmp", "2.bmp", "3.bmp", "4.bmp", "5.bmp", "6.bmp", "7.bmp", "8.bmp", "9.bmp"};
    char  separatorFilename[] = "separator.bmp";

    int i;

    for (i = 0; i < 10; i++)
     462:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     466:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
     46a:	7e da                	jle    446 <main+0xda>
    {
        numbers[i] = malloc(55 * 40 * 3);
    }
    separator = malloc(55 * 40 * 3);
     46c:	83 ec 0c             	sub    $0xc,%esp
     46f:	68 c8 19 00 00       	push   $0x19c8
     474:	e8 e4 09 00 00       	call   e5d <malloc>
     479:	83 c4 10             	add    $0x10,%esp
     47c:	a3 e4 ec 01 00       	mov    %eax,0x1ece4

    api_createwindow(&wnd);
     481:	83 ec 0c             	sub    $0xc,%esp
     484:	68 00 ed 01 00       	push   $0x1ed00
     489:	e8 09 14 00 00       	call   1897 <api_createwindow>
     48e:	83 c4 10             	add    $0x10,%esp

    int h, w;
    for (i = 0; i < 10; i++)
     491:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     498:	eb 30                	jmp    4ca <main+0x15e>
    {
        read24BitmapFile(numberFilename[i], numbers[i], &h, &w);
     49a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     49d:	8b 14 85 40 ed 01 00 	mov    0x1ed40(,%eax,4),%edx
     4a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
     4a7:	8b 84 85 2c ff ff ff 	mov    -0xd4(%ebp,%eax,4),%eax
     4ae:	8d 8d 14 ff ff ff    	lea    -0xec(%ebp),%ecx
     4b4:	51                   	push   %ecx
     4b5:	8d 8d 18 ff ff ff    	lea    -0xe8(%ebp),%ecx
     4bb:	51                   	push   %ecx
     4bc:	52                   	push   %edx
     4bd:	50                   	push   %eax
     4be:	e8 a9 10 00 00       	call   156c <read24BitmapFile>
     4c3:	83 c4 10             	add    $0x10,%esp
    separator = malloc(55 * 40 * 3);

    api_createwindow(&wnd);

    int h, w;
    for (i = 0; i < 10; i++)
     4c6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     4ca:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
     4ce:	7e ca                	jle    49a <main+0x12e>
    {
        read24BitmapFile(numberFilename[i], numbers[i], &h, &w);
    }

    read24BitmapFile(separatorFilename, separator, &h, &w);
     4d0:	a1 e4 ec 01 00       	mov    0x1ece4,%eax
     4d5:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
     4db:	52                   	push   %edx
     4dc:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
     4e2:	52                   	push   %edx
     4e3:	50                   	push   %eax
     4e4:	8d 85 1e ff ff ff    	lea    -0xe2(%ebp),%eax
     4ea:	50                   	push   %eax
     4eb:	e8 7c 10 00 00       	call   156c <read24BitmapFile>
     4f0:	83 c4 10             	add    $0x10,%esp

    

    api_paint24BitmapToContent(&wnd, numbers[0], (Point){185,35}, (Point){0,0},
                               (Size){55, 40}, (Size){55, 40});
     4f3:	c7 85 54 ff ff ff 37 	movl   $0x37,-0xac(%ebp)
     4fa:	00 00 00 
     4fd:	c7 85 58 ff ff ff 28 	movl   $0x28,-0xa8(%ebp)
     504:	00 00 00 
     507:	c7 85 5c ff ff ff 37 	movl   $0x37,-0xa4(%ebp)
     50e:	00 00 00 
     511:	c7 85 60 ff ff ff 28 	movl   $0x28,-0xa0(%ebp)
     518:	00 00 00 

    read24BitmapFile(separatorFilename, separator, &h, &w);

    

    api_paint24BitmapToContent(&wnd, numbers[0], (Point){185,35}, (Point){0,0},
     51b:	c7 85 64 ff ff ff 00 	movl   $0x0,-0x9c(%ebp)
     522:	00 00 00 
     525:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%ebp)
     52c:	00 00 00 
     52f:	c7 85 6c ff ff ff b9 	movl   $0xb9,-0x94(%ebp)
     536:	00 00 00 
     539:	c7 85 70 ff ff ff 23 	movl   $0x23,-0x90(%ebp)
     540:	00 00 00 
     543:	a1 40 ed 01 00       	mov    0x1ed40,%eax
     548:	83 ec 08             	sub    $0x8,%esp
     54b:	ff b5 58 ff ff ff    	pushl  -0xa8(%ebp)
     551:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
     557:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
     55d:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
     563:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
     569:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
     56f:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
     575:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
     57b:	50                   	push   %eax
     57c:	68 00 ed 01 00       	push   $0x1ed00
     581:	e8 23 14 00 00       	call   19a9 <api_paint24BitmapToContent>
     586:	83 c4 30             	add    $0x30,%esp
                               (Size){55, 40}, (Size){55, 40});
    api_paint24BitmapToContent(&wnd, numbers[0], (Point){145,35}, (Point){0,0},
                               (Size){55, 40}, (Size){55, 40});
     589:	c7 85 74 ff ff ff 37 	movl   $0x37,-0x8c(%ebp)
     590:	00 00 00 
     593:	c7 85 78 ff ff ff 28 	movl   $0x28,-0x88(%ebp)
     59a:	00 00 00 
     59d:	c7 85 7c ff ff ff 37 	movl   $0x37,-0x84(%ebp)
     5a4:	00 00 00 
     5a7:	c7 45 80 28 00 00 00 	movl   $0x28,-0x80(%ebp)

    

    api_paint24BitmapToContent(&wnd, numbers[0], (Point){185,35}, (Point){0,0},
                               (Size){55, 40}, (Size){55, 40});
    api_paint24BitmapToContent(&wnd, numbers[0], (Point){145,35}, (Point){0,0},
     5ae:	c7 45 84 00 00 00 00 	movl   $0x0,-0x7c(%ebp)
     5b5:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%ebp)
     5bc:	c7 45 8c 91 00 00 00 	movl   $0x91,-0x74(%ebp)
     5c3:	c7 45 90 23 00 00 00 	movl   $0x23,-0x70(%ebp)
     5ca:	a1 40 ed 01 00       	mov    0x1ed40,%eax
     5cf:	83 ec 08             	sub    $0x8,%esp
     5d2:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
     5d8:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
     5de:	ff 75 80             	pushl  -0x80(%ebp)
     5e1:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
     5e7:	ff 75 88             	pushl  -0x78(%ebp)
     5ea:	ff 75 84             	pushl  -0x7c(%ebp)
     5ed:	ff 75 90             	pushl  -0x70(%ebp)
     5f0:	ff 75 8c             	pushl  -0x74(%ebp)
     5f3:	50                   	push   %eax
     5f4:	68 00 ed 01 00       	push   $0x1ed00
     5f9:	e8 ab 13 00 00       	call   19a9 <api_paint24BitmapToContent>
     5fe:	83 c4 30             	add    $0x30,%esp
                               (Size){55, 40}, (Size){55, 40});
    api_paint24BitmapToContent(&wnd, separator, (Point){105,35}, (Point){0,0},
                               (Size){55, 40}, (Size){55, 40});
     601:	c7 45 94 37 00 00 00 	movl   $0x37,-0x6c(%ebp)
     608:	c7 45 98 28 00 00 00 	movl   $0x28,-0x68(%ebp)
     60f:	c7 45 9c 37 00 00 00 	movl   $0x37,-0x64(%ebp)
     616:	c7 45 a0 28 00 00 00 	movl   $0x28,-0x60(%ebp)

    api_paint24BitmapToContent(&wnd, numbers[0], (Point){185,35}, (Point){0,0},
                               (Size){55, 40}, (Size){55, 40});
    api_paint24BitmapToContent(&wnd, numbers[0], (Point){145,35}, (Point){0,0},
                               (Size){55, 40}, (Size){55, 40});
    api_paint24BitmapToContent(&wnd, separator, (Point){105,35}, (Point){0,0},
     61d:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
     624:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
     62b:	c7 45 ac 69 00 00 00 	movl   $0x69,-0x54(%ebp)
     632:	c7 45 b0 23 00 00 00 	movl   $0x23,-0x50(%ebp)
     639:	a1 e4 ec 01 00       	mov    0x1ece4,%eax
     63e:	83 ec 08             	sub    $0x8,%esp
     641:	ff 75 98             	pushl  -0x68(%ebp)
     644:	ff 75 94             	pushl  -0x6c(%ebp)
     647:	ff 75 a0             	pushl  -0x60(%ebp)
     64a:	ff 75 9c             	pushl  -0x64(%ebp)
     64d:	ff 75 a8             	pushl  -0x58(%ebp)
     650:	ff 75 a4             	pushl  -0x5c(%ebp)
     653:	ff 75 b0             	pushl  -0x50(%ebp)
     656:	ff 75 ac             	pushl  -0x54(%ebp)
     659:	50                   	push   %eax
     65a:	68 00 ed 01 00       	push   $0x1ed00
     65f:	e8 45 13 00 00       	call   19a9 <api_paint24BitmapToContent>
     664:	83 c4 30             	add    $0x30,%esp
                               (Size){55, 40}, (Size){55, 40});
    api_paint24BitmapToContent(&wnd, numbers[0], (Point){65,35}, (Point){0,0},
                               (Size){55, 40}, (Size){55, 40});
     667:	c7 45 b4 37 00 00 00 	movl   $0x37,-0x4c(%ebp)
     66e:	c7 45 b8 28 00 00 00 	movl   $0x28,-0x48(%ebp)
     675:	c7 45 bc 37 00 00 00 	movl   $0x37,-0x44(%ebp)
     67c:	c7 45 c0 28 00 00 00 	movl   $0x28,-0x40(%ebp)
                               (Size){55, 40}, (Size){55, 40});
    api_paint24BitmapToContent(&wnd, numbers[0], (Point){145,35}, (Point){0,0},
                               (Size){55, 40}, (Size){55, 40});
    api_paint24BitmapToContent(&wnd, separator, (Point){105,35}, (Point){0,0},
                               (Size){55, 40}, (Size){55, 40});
    api_paint24BitmapToContent(&wnd, numbers[0], (Point){65,35}, (Point){0,0},
     683:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
     68a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
     691:	c7 45 cc 41 00 00 00 	movl   $0x41,-0x34(%ebp)
     698:	c7 45 d0 23 00 00 00 	movl   $0x23,-0x30(%ebp)
     69f:	a1 40 ed 01 00       	mov    0x1ed40,%eax
     6a4:	83 ec 08             	sub    $0x8,%esp
     6a7:	ff 75 b8             	pushl  -0x48(%ebp)
     6aa:	ff 75 b4             	pushl  -0x4c(%ebp)
     6ad:	ff 75 c0             	pushl  -0x40(%ebp)
     6b0:	ff 75 bc             	pushl  -0x44(%ebp)
     6b3:	ff 75 c8             	pushl  -0x38(%ebp)
     6b6:	ff 75 c4             	pushl  -0x3c(%ebp)
     6b9:	ff 75 d0             	pushl  -0x30(%ebp)
     6bc:	ff 75 cc             	pushl  -0x34(%ebp)
     6bf:	50                   	push   %eax
     6c0:	68 00 ed 01 00       	push   $0x1ed00
     6c5:	e8 df 12 00 00       	call   19a9 <api_paint24BitmapToContent>
     6ca:	83 c4 30             	add    $0x30,%esp
                               (Size){55, 40}, (Size){55, 40});
    api_paint24BitmapToContent(&wnd, numbers[0], (Point){25,35}, (Point){0,0},
                               (Size){55, 40}, (Size){55, 40});
     6cd:	c7 45 d4 37 00 00 00 	movl   $0x37,-0x2c(%ebp)
     6d4:	c7 45 d8 28 00 00 00 	movl   $0x28,-0x28(%ebp)
     6db:	c7 45 dc 37 00 00 00 	movl   $0x37,-0x24(%ebp)
     6e2:	c7 45 e0 28 00 00 00 	movl   $0x28,-0x20(%ebp)
                               (Size){55, 40}, (Size){55, 40});
    api_paint24BitmapToContent(&wnd, separator, (Point){105,35}, (Point){0,0},
                               (Size){55, 40}, (Size){55, 40});
    api_paint24BitmapToContent(&wnd, numbers[0], (Point){65,35}, (Point){0,0},
                               (Size){55, 40}, (Size){55, 40});
    api_paint24BitmapToContent(&wnd, numbers[0], (Point){25,35}, (Point){0,0},
     6e9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
     6f0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
     6f7:	c7 45 ec 19 00 00 00 	movl   $0x19,-0x14(%ebp)
     6fe:	c7 45 f0 23 00 00 00 	movl   $0x23,-0x10(%ebp)
     705:	a1 40 ed 01 00       	mov    0x1ed40,%eax
     70a:	83 ec 08             	sub    $0x8,%esp
     70d:	ff 75 d8             	pushl  -0x28(%ebp)
     710:	ff 75 d4             	pushl  -0x2c(%ebp)
     713:	ff 75 e0             	pushl  -0x20(%ebp)
     716:	ff 75 dc             	pushl  -0x24(%ebp)
     719:	ff 75 e8             	pushl  -0x18(%ebp)
     71c:	ff 75 e4             	pushl  -0x1c(%ebp)
     71f:	ff 75 f0             	pushl  -0x10(%ebp)
     722:	ff 75 ec             	pushl  -0x14(%ebp)
     725:	50                   	push   %eax
     726:	68 00 ed 01 00       	push   $0x1ed00
     72b:	e8 79 12 00 00       	call   19a9 <api_paint24BitmapToContent>
     730:	83 c4 30             	add    $0x30,%esp
                               (Size){55, 40}, (Size){55, 40});

    api_settimer(&wnd, 1000);
     733:	83 ec 08             	sub    $0x8,%esp
     736:	68 e8 03 00 00       	push   $0x3e8
     73b:	68 00 ed 01 00       	push   $0x1ed00
     740:	e8 70 13 00 00       	call   1ab5 <api_settimer>
     745:	83 c4 10             	add    $0x10,%esp
    api_repaint(&wnd);
     748:	83 ec 0c             	sub    $0xc,%esp
     74b:	68 00 ed 01 00       	push   $0x1ed00
     750:	e8 d4 12 00 00       	call   1a29 <api_repaint>
     755:	83 c4 10             	add    $0x10,%esp
    printf(1, "safe here\n");
     758:	83 ec 08             	sub    $0x8,%esp
     75b:	68 25 65 01 00       	push   $0x16525
     760:	6a 01                	push   $0x1
     762:	e8 23 04 00 00       	call   b8a <printf>
     767:	83 c4 10             	add    $0x10,%esp
    api_exec(&wnd, &MsgProc);
     76a:	83 ec 08             	sub    $0x8,%esp
     76d:	68 aa 02 00 00       	push   $0x2aa
     772:	68 00 ed 01 00       	push   $0x1ed00
     777:	e8 fd 12 00 00       	call   1a79 <api_exec>
     77c:	83 c4 10             	add    $0x10,%esp
    return 0;
     77f:	b8 00 00 00 00       	mov    $0x0,%eax
}
     784:	8b 4d fc             	mov    -0x4(%ebp),%ecx
     787:	c9                   	leave  
     788:	8d 61 fc             	lea    -0x4(%ecx),%esp
     78b:	c3                   	ret    

0000078c <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
     78c:	55                   	push   %ebp
     78d:	89 e5                	mov    %esp,%ebp
     78f:	57                   	push   %edi
     790:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
     791:	8b 4d 08             	mov    0x8(%ebp),%ecx
     794:	8b 55 10             	mov    0x10(%ebp),%edx
     797:	8b 45 0c             	mov    0xc(%ebp),%eax
     79a:	89 cb                	mov    %ecx,%ebx
     79c:	89 df                	mov    %ebx,%edi
     79e:	89 d1                	mov    %edx,%ecx
     7a0:	fc                   	cld    
     7a1:	f3 aa                	rep stos %al,%es:(%edi)
     7a3:	89 ca                	mov    %ecx,%edx
     7a5:	89 fb                	mov    %edi,%ebx
     7a7:	89 5d 08             	mov    %ebx,0x8(%ebp)
     7aa:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
     7ad:	90                   	nop
     7ae:	5b                   	pop    %ebx
     7af:	5f                   	pop    %edi
     7b0:	5d                   	pop    %ebp
     7b1:	c3                   	ret    

000007b2 <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
     7b2:	55                   	push   %ebp
     7b3:	89 e5                	mov    %esp,%ebp
     7b5:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
     7b8:	8b 45 08             	mov    0x8(%ebp),%eax
     7bb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
     7be:	90                   	nop
     7bf:	8b 45 08             	mov    0x8(%ebp),%eax
     7c2:	8d 50 01             	lea    0x1(%eax),%edx
     7c5:	89 55 08             	mov    %edx,0x8(%ebp)
     7c8:	8b 55 0c             	mov    0xc(%ebp),%edx
     7cb:	8d 4a 01             	lea    0x1(%edx),%ecx
     7ce:	89 4d 0c             	mov    %ecx,0xc(%ebp)
     7d1:	0f b6 12             	movzbl (%edx),%edx
     7d4:	88 10                	mov    %dl,(%eax)
     7d6:	0f b6 00             	movzbl (%eax),%eax
     7d9:	84 c0                	test   %al,%al
     7db:	75 e2                	jne    7bf <strcpy+0xd>
    ;
  return os;
     7dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     7e0:	c9                   	leave  
     7e1:	c3                   	ret    

000007e2 <strcmp>:

int
strcmp(const char *p, const char *q)
{
     7e2:	55                   	push   %ebp
     7e3:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
     7e5:	eb 08                	jmp    7ef <strcmp+0xd>
    p++, q++;
     7e7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     7eb:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
     7ef:	8b 45 08             	mov    0x8(%ebp),%eax
     7f2:	0f b6 00             	movzbl (%eax),%eax
     7f5:	84 c0                	test   %al,%al
     7f7:	74 10                	je     809 <strcmp+0x27>
     7f9:	8b 45 08             	mov    0x8(%ebp),%eax
     7fc:	0f b6 10             	movzbl (%eax),%edx
     7ff:	8b 45 0c             	mov    0xc(%ebp),%eax
     802:	0f b6 00             	movzbl (%eax),%eax
     805:	38 c2                	cmp    %al,%dl
     807:	74 de                	je     7e7 <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
     809:	8b 45 08             	mov    0x8(%ebp),%eax
     80c:	0f b6 00             	movzbl (%eax),%eax
     80f:	0f b6 d0             	movzbl %al,%edx
     812:	8b 45 0c             	mov    0xc(%ebp),%eax
     815:	0f b6 00             	movzbl (%eax),%eax
     818:	0f b6 c0             	movzbl %al,%eax
     81b:	29 c2                	sub    %eax,%edx
     81d:	89 d0                	mov    %edx,%eax
}
     81f:	5d                   	pop    %ebp
     820:	c3                   	ret    

00000821 <strlen>:

uint
strlen(char *s)
{
     821:	55                   	push   %ebp
     822:	89 e5                	mov    %esp,%ebp
     824:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     827:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     82e:	eb 04                	jmp    834 <strlen+0x13>
     830:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     834:	8b 55 fc             	mov    -0x4(%ebp),%edx
     837:	8b 45 08             	mov    0x8(%ebp),%eax
     83a:	01 d0                	add    %edx,%eax
     83c:	0f b6 00             	movzbl (%eax),%eax
     83f:	84 c0                	test   %al,%al
     841:	75 ed                	jne    830 <strlen+0xf>
    ;
  return n;
     843:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     846:	c9                   	leave  
     847:	c3                   	ret    

00000848 <memset>:

void*
memset(void *dst, int c, uint n)
{
     848:	55                   	push   %ebp
     849:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     84b:	8b 45 10             	mov    0x10(%ebp),%eax
     84e:	50                   	push   %eax
     84f:	ff 75 0c             	pushl  0xc(%ebp)
     852:	ff 75 08             	pushl  0x8(%ebp)
     855:	e8 32 ff ff ff       	call   78c <stosb>
     85a:	83 c4 0c             	add    $0xc,%esp
  return dst;
     85d:	8b 45 08             	mov    0x8(%ebp),%eax
}
     860:	c9                   	leave  
     861:	c3                   	ret    

00000862 <strchr>:

char*
strchr(const char *s, char c)
{
     862:	55                   	push   %ebp
     863:	89 e5                	mov    %esp,%ebp
     865:	83 ec 04             	sub    $0x4,%esp
     868:	8b 45 0c             	mov    0xc(%ebp),%eax
     86b:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     86e:	eb 14                	jmp    884 <strchr+0x22>
    if(*s == c)
     870:	8b 45 08             	mov    0x8(%ebp),%eax
     873:	0f b6 00             	movzbl (%eax),%eax
     876:	3a 45 fc             	cmp    -0x4(%ebp),%al
     879:	75 05                	jne    880 <strchr+0x1e>
      return (char*)s;
     87b:	8b 45 08             	mov    0x8(%ebp),%eax
     87e:	eb 13                	jmp    893 <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     880:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     884:	8b 45 08             	mov    0x8(%ebp),%eax
     887:	0f b6 00             	movzbl (%eax),%eax
     88a:	84 c0                	test   %al,%al
     88c:	75 e2                	jne    870 <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     88e:	b8 00 00 00 00       	mov    $0x0,%eax
}
     893:	c9                   	leave  
     894:	c3                   	ret    

00000895 <gets>:

char*
gets(char *buf, int max)
{
     895:	55                   	push   %ebp
     896:	89 e5                	mov    %esp,%ebp
     898:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     89b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     8a2:	eb 42                	jmp    8e6 <gets+0x51>
    cc = read(0, &c, 1);
     8a4:	83 ec 04             	sub    $0x4,%esp
     8a7:	6a 01                	push   $0x1
     8a9:	8d 45 ef             	lea    -0x11(%ebp),%eax
     8ac:	50                   	push   %eax
     8ad:	6a 00                	push   $0x0
     8af:	e8 47 01 00 00       	call   9fb <read>
     8b4:	83 c4 10             	add    $0x10,%esp
     8b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     8ba:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     8be:	7e 33                	jle    8f3 <gets+0x5e>
      break;
    buf[i++] = c;
     8c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8c3:	8d 50 01             	lea    0x1(%eax),%edx
     8c6:	89 55 f4             	mov    %edx,-0xc(%ebp)
     8c9:	89 c2                	mov    %eax,%edx
     8cb:	8b 45 08             	mov    0x8(%ebp),%eax
     8ce:	01 c2                	add    %eax,%edx
     8d0:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     8d4:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     8d6:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     8da:	3c 0a                	cmp    $0xa,%al
     8dc:	74 16                	je     8f4 <gets+0x5f>
     8de:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     8e2:	3c 0d                	cmp    $0xd,%al
     8e4:	74 0e                	je     8f4 <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     8e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8e9:	83 c0 01             	add    $0x1,%eax
     8ec:	3b 45 0c             	cmp    0xc(%ebp),%eax
     8ef:	7c b3                	jl     8a4 <gets+0xf>
     8f1:	eb 01                	jmp    8f4 <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     8f3:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     8f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
     8f7:	8b 45 08             	mov    0x8(%ebp),%eax
     8fa:	01 d0                	add    %edx,%eax
     8fc:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     8ff:	8b 45 08             	mov    0x8(%ebp),%eax
}
     902:	c9                   	leave  
     903:	c3                   	ret    

00000904 <stat>:

int
stat(char *n, struct stat *st)
{
     904:	55                   	push   %ebp
     905:	89 e5                	mov    %esp,%ebp
     907:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     90a:	83 ec 08             	sub    $0x8,%esp
     90d:	6a 00                	push   $0x0
     90f:	ff 75 08             	pushl  0x8(%ebp)
     912:	e8 0c 01 00 00       	call   a23 <open>
     917:	83 c4 10             	add    $0x10,%esp
     91a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     91d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     921:	79 07                	jns    92a <stat+0x26>
    return -1;
     923:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     928:	eb 25                	jmp    94f <stat+0x4b>
  r = fstat(fd, st);
     92a:	83 ec 08             	sub    $0x8,%esp
     92d:	ff 75 0c             	pushl  0xc(%ebp)
     930:	ff 75 f4             	pushl  -0xc(%ebp)
     933:	e8 03 01 00 00       	call   a3b <fstat>
     938:	83 c4 10             	add    $0x10,%esp
     93b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     93e:	83 ec 0c             	sub    $0xc,%esp
     941:	ff 75 f4             	pushl  -0xc(%ebp)
     944:	e8 c2 00 00 00       	call   a0b <close>
     949:	83 c4 10             	add    $0x10,%esp
  return r;
     94c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     94f:	c9                   	leave  
     950:	c3                   	ret    

00000951 <atoi>:

int
atoi(const char *s)
{
     951:	55                   	push   %ebp
     952:	89 e5                	mov    %esp,%ebp
     954:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     957:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     95e:	eb 25                	jmp    985 <atoi+0x34>
    n = n*10 + *s++ - '0';
     960:	8b 55 fc             	mov    -0x4(%ebp),%edx
     963:	89 d0                	mov    %edx,%eax
     965:	c1 e0 02             	shl    $0x2,%eax
     968:	01 d0                	add    %edx,%eax
     96a:	01 c0                	add    %eax,%eax
     96c:	89 c1                	mov    %eax,%ecx
     96e:	8b 45 08             	mov    0x8(%ebp),%eax
     971:	8d 50 01             	lea    0x1(%eax),%edx
     974:	89 55 08             	mov    %edx,0x8(%ebp)
     977:	0f b6 00             	movzbl (%eax),%eax
     97a:	0f be c0             	movsbl %al,%eax
     97d:	01 c8                	add    %ecx,%eax
     97f:	83 e8 30             	sub    $0x30,%eax
     982:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     985:	8b 45 08             	mov    0x8(%ebp),%eax
     988:	0f b6 00             	movzbl (%eax),%eax
     98b:	3c 2f                	cmp    $0x2f,%al
     98d:	7e 0a                	jle    999 <atoi+0x48>
     98f:	8b 45 08             	mov    0x8(%ebp),%eax
     992:	0f b6 00             	movzbl (%eax),%eax
     995:	3c 39                	cmp    $0x39,%al
     997:	7e c7                	jle    960 <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     999:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     99c:	c9                   	leave  
     99d:	c3                   	ret    

0000099e <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     99e:	55                   	push   %ebp
     99f:	89 e5                	mov    %esp,%ebp
     9a1:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     9a4:	8b 45 08             	mov    0x8(%ebp),%eax
     9a7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     9aa:	8b 45 0c             	mov    0xc(%ebp),%eax
     9ad:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     9b0:	eb 17                	jmp    9c9 <memmove+0x2b>
    *dst++ = *src++;
     9b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
     9b5:	8d 50 01             	lea    0x1(%eax),%edx
     9b8:	89 55 fc             	mov    %edx,-0x4(%ebp)
     9bb:	8b 55 f8             	mov    -0x8(%ebp),%edx
     9be:	8d 4a 01             	lea    0x1(%edx),%ecx
     9c1:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     9c4:	0f b6 12             	movzbl (%edx),%edx
     9c7:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     9c9:	8b 45 10             	mov    0x10(%ebp),%eax
     9cc:	8d 50 ff             	lea    -0x1(%eax),%edx
     9cf:	89 55 10             	mov    %edx,0x10(%ebp)
     9d2:	85 c0                	test   %eax,%eax
     9d4:	7f dc                	jg     9b2 <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     9d6:	8b 45 08             	mov    0x8(%ebp),%eax
}
     9d9:	c9                   	leave  
     9da:	c3                   	ret    

000009db <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     9db:	b8 01 00 00 00       	mov    $0x1,%eax
     9e0:	cd 40                	int    $0x40
     9e2:	c3                   	ret    

000009e3 <exit>:
SYSCALL(exit)
     9e3:	b8 02 00 00 00       	mov    $0x2,%eax
     9e8:	cd 40                	int    $0x40
     9ea:	c3                   	ret    

000009eb <wait>:
SYSCALL(wait)
     9eb:	b8 03 00 00 00       	mov    $0x3,%eax
     9f0:	cd 40                	int    $0x40
     9f2:	c3                   	ret    

000009f3 <pipe>:
SYSCALL(pipe)
     9f3:	b8 04 00 00 00       	mov    $0x4,%eax
     9f8:	cd 40                	int    $0x40
     9fa:	c3                   	ret    

000009fb <read>:
SYSCALL(read)
     9fb:	b8 05 00 00 00       	mov    $0x5,%eax
     a00:	cd 40                	int    $0x40
     a02:	c3                   	ret    

00000a03 <write>:
SYSCALL(write)
     a03:	b8 10 00 00 00       	mov    $0x10,%eax
     a08:	cd 40                	int    $0x40
     a0a:	c3                   	ret    

00000a0b <close>:
SYSCALL(close)
     a0b:	b8 15 00 00 00       	mov    $0x15,%eax
     a10:	cd 40                	int    $0x40
     a12:	c3                   	ret    

00000a13 <kill>:
SYSCALL(kill)
     a13:	b8 06 00 00 00       	mov    $0x6,%eax
     a18:	cd 40                	int    $0x40
     a1a:	c3                   	ret    

00000a1b <exec>:
SYSCALL(exec)
     a1b:	b8 07 00 00 00       	mov    $0x7,%eax
     a20:	cd 40                	int    $0x40
     a22:	c3                   	ret    

00000a23 <open>:
SYSCALL(open)
     a23:	b8 0f 00 00 00       	mov    $0xf,%eax
     a28:	cd 40                	int    $0x40
     a2a:	c3                   	ret    

00000a2b <mknod>:
SYSCALL(mknod)
     a2b:	b8 11 00 00 00       	mov    $0x11,%eax
     a30:	cd 40                	int    $0x40
     a32:	c3                   	ret    

00000a33 <unlink>:
SYSCALL(unlink)
     a33:	b8 12 00 00 00       	mov    $0x12,%eax
     a38:	cd 40                	int    $0x40
     a3a:	c3                   	ret    

00000a3b <fstat>:
SYSCALL(fstat)
     a3b:	b8 08 00 00 00       	mov    $0x8,%eax
     a40:	cd 40                	int    $0x40
     a42:	c3                   	ret    

00000a43 <link>:
SYSCALL(link)
     a43:	b8 13 00 00 00       	mov    $0x13,%eax
     a48:	cd 40                	int    $0x40
     a4a:	c3                   	ret    

00000a4b <mkdir>:
SYSCALL(mkdir)
     a4b:	b8 14 00 00 00       	mov    $0x14,%eax
     a50:	cd 40                	int    $0x40
     a52:	c3                   	ret    

00000a53 <chdir>:
SYSCALL(chdir)
     a53:	b8 09 00 00 00       	mov    $0x9,%eax
     a58:	cd 40                	int    $0x40
     a5a:	c3                   	ret    

00000a5b <dup>:
SYSCALL(dup)
     a5b:	b8 0a 00 00 00       	mov    $0xa,%eax
     a60:	cd 40                	int    $0x40
     a62:	c3                   	ret    

00000a63 <getpid>:
SYSCALL(getpid)
     a63:	b8 0b 00 00 00       	mov    $0xb,%eax
     a68:	cd 40                	int    $0x40
     a6a:	c3                   	ret    

00000a6b <sbrk>:
SYSCALL(sbrk)
     a6b:	b8 0c 00 00 00       	mov    $0xc,%eax
     a70:	cd 40                	int    $0x40
     a72:	c3                   	ret    

00000a73 <sleep>:
SYSCALL(sleep)
     a73:	b8 0d 00 00 00       	mov    $0xd,%eax
     a78:	cd 40                	int    $0x40
     a7a:	c3                   	ret    

00000a7b <uptime>:
SYSCALL(uptime)
     a7b:	b8 0e 00 00 00       	mov    $0xe,%eax
     a80:	cd 40                	int    $0x40
     a82:	c3                   	ret    

00000a83 <createwindow>:
SYSCALL(createwindow)
     a83:	b8 16 00 00 00       	mov    $0x16,%eax
     a88:	cd 40                	int    $0x40
     a8a:	c3                   	ret    

00000a8b <repaintwindow>:
SYSCALL(repaintwindow)
     a8b:	b8 17 00 00 00       	mov    $0x17,%eax
     a90:	cd 40                	int    $0x40
     a92:	c3                   	ret    

00000a93 <getmessage>:
SYSCALL(getmessage)
     a93:	b8 18 00 00 00       	mov    $0x18,%eax
     a98:	cd 40                	int    $0x40
     a9a:	c3                   	ret    

00000a9b <settimer>:
SYSCALL(settimer)
     a9b:	b8 19 00 00 00       	mov    $0x19,%eax
     aa0:	cd 40                	int    $0x40
     aa2:	c3                   	ret    

00000aa3 <updatewindow>:
SYSCALL(updatewindow)
     aa3:	b8 1a 00 00 00       	mov    $0x1a,%eax
     aa8:	cd 40                	int    $0x40
     aaa:	c3                   	ret    

00000aab <destroywindow>:
SYSCALL(destroywindow)
     aab:	b8 1b 00 00 00       	mov    $0x1b,%eax
     ab0:	cd 40                	int    $0x40
     ab2:	c3                   	ret    

00000ab3 <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     ab3:	55                   	push   %ebp
     ab4:	89 e5                	mov    %esp,%ebp
     ab6:	83 ec 18             	sub    $0x18,%esp
     ab9:	8b 45 0c             	mov    0xc(%ebp),%eax
     abc:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     abf:	83 ec 04             	sub    $0x4,%esp
     ac2:	6a 01                	push   $0x1
     ac4:	8d 45 f4             	lea    -0xc(%ebp),%eax
     ac7:	50                   	push   %eax
     ac8:	ff 75 08             	pushl  0x8(%ebp)
     acb:	e8 33 ff ff ff       	call   a03 <write>
     ad0:	83 c4 10             	add    $0x10,%esp
}
     ad3:	90                   	nop
     ad4:	c9                   	leave  
     ad5:	c3                   	ret    

00000ad6 <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     ad6:	55                   	push   %ebp
     ad7:	89 e5                	mov    %esp,%ebp
     ad9:	53                   	push   %ebx
     ada:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     add:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     ae4:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     ae8:	74 17                	je     b01 <printint+0x2b>
     aea:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     aee:	79 11                	jns    b01 <printint+0x2b>
    neg = 1;
     af0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     af7:	8b 45 0c             	mov    0xc(%ebp),%eax
     afa:	f7 d8                	neg    %eax
     afc:	89 45 ec             	mov    %eax,-0x14(%ebp)
     aff:	eb 06                	jmp    b07 <printint+0x31>
  } else {
    x = xx;
     b01:	8b 45 0c             	mov    0xc(%ebp),%eax
     b04:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     b07:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     b0e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     b11:	8d 41 01             	lea    0x1(%ecx),%eax
     b14:	89 45 f4             	mov    %eax,-0xc(%ebp)
     b17:	8b 5d 10             	mov    0x10(%ebp),%ebx
     b1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
     b1d:	ba 00 00 00 00       	mov    $0x0,%edx
     b22:	f7 f3                	div    %ebx
     b24:	89 d0                	mov    %edx,%eax
     b26:	0f b6 80 60 e8 01 00 	movzbl 0x1e860(%eax),%eax
     b2d:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     b31:	8b 5d 10             	mov    0x10(%ebp),%ebx
     b34:	8b 45 ec             	mov    -0x14(%ebp),%eax
     b37:	ba 00 00 00 00       	mov    $0x0,%edx
     b3c:	f7 f3                	div    %ebx
     b3e:	89 45 ec             	mov    %eax,-0x14(%ebp)
     b41:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     b45:	75 c7                	jne    b0e <printint+0x38>
  if(neg)
     b47:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     b4b:	74 2d                	je     b7a <printint+0xa4>
    buf[i++] = '-';
     b4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
     b50:	8d 50 01             	lea    0x1(%eax),%edx
     b53:	89 55 f4             	mov    %edx,-0xc(%ebp)
     b56:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     b5b:	eb 1d                	jmp    b7a <printint+0xa4>
    putc(fd, buf[i]);
     b5d:	8d 55 dc             	lea    -0x24(%ebp),%edx
     b60:	8b 45 f4             	mov    -0xc(%ebp),%eax
     b63:	01 d0                	add    %edx,%eax
     b65:	0f b6 00             	movzbl (%eax),%eax
     b68:	0f be c0             	movsbl %al,%eax
     b6b:	83 ec 08             	sub    $0x8,%esp
     b6e:	50                   	push   %eax
     b6f:	ff 75 08             	pushl  0x8(%ebp)
     b72:	e8 3c ff ff ff       	call   ab3 <putc>
     b77:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     b7a:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     b7e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     b82:	79 d9                	jns    b5d <printint+0x87>
    putc(fd, buf[i]);
}
     b84:	90                   	nop
     b85:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     b88:	c9                   	leave  
     b89:	c3                   	ret    

00000b8a <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     b8a:	55                   	push   %ebp
     b8b:	89 e5                	mov    %esp,%ebp
     b8d:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     b90:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     b97:	8d 45 0c             	lea    0xc(%ebp),%eax
     b9a:	83 c0 04             	add    $0x4,%eax
     b9d:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     ba0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     ba7:	e9 59 01 00 00       	jmp    d05 <printf+0x17b>
    c = fmt[i] & 0xff;
     bac:	8b 55 0c             	mov    0xc(%ebp),%edx
     baf:	8b 45 f0             	mov    -0x10(%ebp),%eax
     bb2:	01 d0                	add    %edx,%eax
     bb4:	0f b6 00             	movzbl (%eax),%eax
     bb7:	0f be c0             	movsbl %al,%eax
     bba:	25 ff 00 00 00       	and    $0xff,%eax
     bbf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     bc2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     bc6:	75 2c                	jne    bf4 <printf+0x6a>
      if(c == '%'){
     bc8:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     bcc:	75 0c                	jne    bda <printf+0x50>
        state = '%';
     bce:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     bd5:	e9 27 01 00 00       	jmp    d01 <printf+0x177>
      } else {
        putc(fd, c);
     bda:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     bdd:	0f be c0             	movsbl %al,%eax
     be0:	83 ec 08             	sub    $0x8,%esp
     be3:	50                   	push   %eax
     be4:	ff 75 08             	pushl  0x8(%ebp)
     be7:	e8 c7 fe ff ff       	call   ab3 <putc>
     bec:	83 c4 10             	add    $0x10,%esp
     bef:	e9 0d 01 00 00       	jmp    d01 <printf+0x177>
      }
    } else if(state == '%'){
     bf4:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     bf8:	0f 85 03 01 00 00    	jne    d01 <printf+0x177>
      if(c == 'd'){
     bfe:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     c02:	75 1e                	jne    c22 <printf+0x98>
        printint(fd, *ap, 10, 1);
     c04:	8b 45 e8             	mov    -0x18(%ebp),%eax
     c07:	8b 00                	mov    (%eax),%eax
     c09:	6a 01                	push   $0x1
     c0b:	6a 0a                	push   $0xa
     c0d:	50                   	push   %eax
     c0e:	ff 75 08             	pushl  0x8(%ebp)
     c11:	e8 c0 fe ff ff       	call   ad6 <printint>
     c16:	83 c4 10             	add    $0x10,%esp
        ap++;
     c19:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     c1d:	e9 d8 00 00 00       	jmp    cfa <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     c22:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     c26:	74 06                	je     c2e <printf+0xa4>
     c28:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     c2c:	75 1e                	jne    c4c <printf+0xc2>
        printint(fd, *ap, 16, 0);
     c2e:	8b 45 e8             	mov    -0x18(%ebp),%eax
     c31:	8b 00                	mov    (%eax),%eax
     c33:	6a 00                	push   $0x0
     c35:	6a 10                	push   $0x10
     c37:	50                   	push   %eax
     c38:	ff 75 08             	pushl  0x8(%ebp)
     c3b:	e8 96 fe ff ff       	call   ad6 <printint>
     c40:	83 c4 10             	add    $0x10,%esp
        ap++;
     c43:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     c47:	e9 ae 00 00 00       	jmp    cfa <printf+0x170>
      } else if(c == 's'){
     c4c:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     c50:	75 43                	jne    c95 <printf+0x10b>
        s = (char*)*ap;
     c52:	8b 45 e8             	mov    -0x18(%ebp),%eax
     c55:	8b 00                	mov    (%eax),%eax
     c57:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     c5a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     c5e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     c62:	75 25                	jne    c89 <printf+0xff>
          s = "(null)";
     c64:	c7 45 f4 30 65 01 00 	movl   $0x16530,-0xc(%ebp)
        while(*s != 0){
     c6b:	eb 1c                	jmp    c89 <printf+0xff>
          putc(fd, *s);
     c6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
     c70:	0f b6 00             	movzbl (%eax),%eax
     c73:	0f be c0             	movsbl %al,%eax
     c76:	83 ec 08             	sub    $0x8,%esp
     c79:	50                   	push   %eax
     c7a:	ff 75 08             	pushl  0x8(%ebp)
     c7d:	e8 31 fe ff ff       	call   ab3 <putc>
     c82:	83 c4 10             	add    $0x10,%esp
          s++;
     c85:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     c89:	8b 45 f4             	mov    -0xc(%ebp),%eax
     c8c:	0f b6 00             	movzbl (%eax),%eax
     c8f:	84 c0                	test   %al,%al
     c91:	75 da                	jne    c6d <printf+0xe3>
     c93:	eb 65                	jmp    cfa <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     c95:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     c99:	75 1d                	jne    cb8 <printf+0x12e>
        putc(fd, *ap);
     c9b:	8b 45 e8             	mov    -0x18(%ebp),%eax
     c9e:	8b 00                	mov    (%eax),%eax
     ca0:	0f be c0             	movsbl %al,%eax
     ca3:	83 ec 08             	sub    $0x8,%esp
     ca6:	50                   	push   %eax
     ca7:	ff 75 08             	pushl  0x8(%ebp)
     caa:	e8 04 fe ff ff       	call   ab3 <putc>
     caf:	83 c4 10             	add    $0x10,%esp
        ap++;
     cb2:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     cb6:	eb 42                	jmp    cfa <printf+0x170>
      } else if(c == '%'){
     cb8:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     cbc:	75 17                	jne    cd5 <printf+0x14b>
        putc(fd, c);
     cbe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     cc1:	0f be c0             	movsbl %al,%eax
     cc4:	83 ec 08             	sub    $0x8,%esp
     cc7:	50                   	push   %eax
     cc8:	ff 75 08             	pushl  0x8(%ebp)
     ccb:	e8 e3 fd ff ff       	call   ab3 <putc>
     cd0:	83 c4 10             	add    $0x10,%esp
     cd3:	eb 25                	jmp    cfa <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     cd5:	83 ec 08             	sub    $0x8,%esp
     cd8:	6a 25                	push   $0x25
     cda:	ff 75 08             	pushl  0x8(%ebp)
     cdd:	e8 d1 fd ff ff       	call   ab3 <putc>
     ce2:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     ce5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     ce8:	0f be c0             	movsbl %al,%eax
     ceb:	83 ec 08             	sub    $0x8,%esp
     cee:	50                   	push   %eax
     cef:	ff 75 08             	pushl  0x8(%ebp)
     cf2:	e8 bc fd ff ff       	call   ab3 <putc>
     cf7:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     cfa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     d01:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     d05:	8b 55 0c             	mov    0xc(%ebp),%edx
     d08:	8b 45 f0             	mov    -0x10(%ebp),%eax
     d0b:	01 d0                	add    %edx,%eax
     d0d:	0f b6 00             	movzbl (%eax),%eax
     d10:	84 c0                	test   %al,%al
     d12:	0f 85 94 fe ff ff    	jne    bac <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     d18:	90                   	nop
     d19:	c9                   	leave  
     d1a:	c3                   	ret    

00000d1b <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     d1b:	55                   	push   %ebp
     d1c:	89 e5                	mov    %esp,%ebp
     d1e:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     d21:	8b 45 08             	mov    0x8(%ebp),%eax
     d24:	83 e8 08             	sub    $0x8,%eax
     d27:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     d2a:	a1 c4 ec 01 00       	mov    0x1ecc4,%eax
     d2f:	89 45 fc             	mov    %eax,-0x4(%ebp)
     d32:	eb 24                	jmp    d58 <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     d34:	8b 45 fc             	mov    -0x4(%ebp),%eax
     d37:	8b 00                	mov    (%eax),%eax
     d39:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     d3c:	77 12                	ja     d50 <free+0x35>
     d3e:	8b 45 f8             	mov    -0x8(%ebp),%eax
     d41:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     d44:	77 24                	ja     d6a <free+0x4f>
     d46:	8b 45 fc             	mov    -0x4(%ebp),%eax
     d49:	8b 00                	mov    (%eax),%eax
     d4b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     d4e:	77 1a                	ja     d6a <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     d50:	8b 45 fc             	mov    -0x4(%ebp),%eax
     d53:	8b 00                	mov    (%eax),%eax
     d55:	89 45 fc             	mov    %eax,-0x4(%ebp)
     d58:	8b 45 f8             	mov    -0x8(%ebp),%eax
     d5b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     d5e:	76 d4                	jbe    d34 <free+0x19>
     d60:	8b 45 fc             	mov    -0x4(%ebp),%eax
     d63:	8b 00                	mov    (%eax),%eax
     d65:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     d68:	76 ca                	jbe    d34 <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     d6a:	8b 45 f8             	mov    -0x8(%ebp),%eax
     d6d:	8b 40 04             	mov    0x4(%eax),%eax
     d70:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     d77:	8b 45 f8             	mov    -0x8(%ebp),%eax
     d7a:	01 c2                	add    %eax,%edx
     d7c:	8b 45 fc             	mov    -0x4(%ebp),%eax
     d7f:	8b 00                	mov    (%eax),%eax
     d81:	39 c2                	cmp    %eax,%edx
     d83:	75 24                	jne    da9 <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     d85:	8b 45 f8             	mov    -0x8(%ebp),%eax
     d88:	8b 50 04             	mov    0x4(%eax),%edx
     d8b:	8b 45 fc             	mov    -0x4(%ebp),%eax
     d8e:	8b 00                	mov    (%eax),%eax
     d90:	8b 40 04             	mov    0x4(%eax),%eax
     d93:	01 c2                	add    %eax,%edx
     d95:	8b 45 f8             	mov    -0x8(%ebp),%eax
     d98:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     d9b:	8b 45 fc             	mov    -0x4(%ebp),%eax
     d9e:	8b 00                	mov    (%eax),%eax
     da0:	8b 10                	mov    (%eax),%edx
     da2:	8b 45 f8             	mov    -0x8(%ebp),%eax
     da5:	89 10                	mov    %edx,(%eax)
     da7:	eb 0a                	jmp    db3 <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     da9:	8b 45 fc             	mov    -0x4(%ebp),%eax
     dac:	8b 10                	mov    (%eax),%edx
     dae:	8b 45 f8             	mov    -0x8(%ebp),%eax
     db1:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     db3:	8b 45 fc             	mov    -0x4(%ebp),%eax
     db6:	8b 40 04             	mov    0x4(%eax),%eax
     db9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     dc0:	8b 45 fc             	mov    -0x4(%ebp),%eax
     dc3:	01 d0                	add    %edx,%eax
     dc5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     dc8:	75 20                	jne    dea <free+0xcf>
    p->s.size += bp->s.size;
     dca:	8b 45 fc             	mov    -0x4(%ebp),%eax
     dcd:	8b 50 04             	mov    0x4(%eax),%edx
     dd0:	8b 45 f8             	mov    -0x8(%ebp),%eax
     dd3:	8b 40 04             	mov    0x4(%eax),%eax
     dd6:	01 c2                	add    %eax,%edx
     dd8:	8b 45 fc             	mov    -0x4(%ebp),%eax
     ddb:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     dde:	8b 45 f8             	mov    -0x8(%ebp),%eax
     de1:	8b 10                	mov    (%eax),%edx
     de3:	8b 45 fc             	mov    -0x4(%ebp),%eax
     de6:	89 10                	mov    %edx,(%eax)
     de8:	eb 08                	jmp    df2 <free+0xd7>
  } else
    p->s.ptr = bp;
     dea:	8b 45 fc             	mov    -0x4(%ebp),%eax
     ded:	8b 55 f8             	mov    -0x8(%ebp),%edx
     df0:	89 10                	mov    %edx,(%eax)
  freep = p;
     df2:	8b 45 fc             	mov    -0x4(%ebp),%eax
     df5:	a3 c4 ec 01 00       	mov    %eax,0x1ecc4
}
     dfa:	90                   	nop
     dfb:	c9                   	leave  
     dfc:	c3                   	ret    

00000dfd <morecore>:

static Header*
morecore(uint nu)
{
     dfd:	55                   	push   %ebp
     dfe:	89 e5                	mov    %esp,%ebp
     e00:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     e03:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     e0a:	77 07                	ja     e13 <morecore+0x16>
    nu = 4096;
     e0c:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     e13:	8b 45 08             	mov    0x8(%ebp),%eax
     e16:	c1 e0 03             	shl    $0x3,%eax
     e19:	83 ec 0c             	sub    $0xc,%esp
     e1c:	50                   	push   %eax
     e1d:	e8 49 fc ff ff       	call   a6b <sbrk>
     e22:	83 c4 10             	add    $0x10,%esp
     e25:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     e28:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     e2c:	75 07                	jne    e35 <morecore+0x38>
    return 0;
     e2e:	b8 00 00 00 00       	mov    $0x0,%eax
     e33:	eb 26                	jmp    e5b <morecore+0x5e>
  hp = (Header*)p;
     e35:	8b 45 f4             	mov    -0xc(%ebp),%eax
     e38:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     e3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e3e:	8b 55 08             	mov    0x8(%ebp),%edx
     e41:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     e44:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e47:	83 c0 08             	add    $0x8,%eax
     e4a:	83 ec 0c             	sub    $0xc,%esp
     e4d:	50                   	push   %eax
     e4e:	e8 c8 fe ff ff       	call   d1b <free>
     e53:	83 c4 10             	add    $0x10,%esp
  return freep;
     e56:	a1 c4 ec 01 00       	mov    0x1ecc4,%eax
}
     e5b:	c9                   	leave  
     e5c:	c3                   	ret    

00000e5d <malloc>:

void*
malloc(uint nbytes)
{
     e5d:	55                   	push   %ebp
     e5e:	89 e5                	mov    %esp,%ebp
     e60:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     e63:	8b 45 08             	mov    0x8(%ebp),%eax
     e66:	83 c0 07             	add    $0x7,%eax
     e69:	c1 e8 03             	shr    $0x3,%eax
     e6c:	83 c0 01             	add    $0x1,%eax
     e6f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     e72:	a1 c4 ec 01 00       	mov    0x1ecc4,%eax
     e77:	89 45 f0             	mov    %eax,-0x10(%ebp)
     e7a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     e7e:	75 23                	jne    ea3 <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     e80:	c7 45 f0 bc ec 01 00 	movl   $0x1ecbc,-0x10(%ebp)
     e87:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e8a:	a3 c4 ec 01 00       	mov    %eax,0x1ecc4
     e8f:	a1 c4 ec 01 00       	mov    0x1ecc4,%eax
     e94:	a3 bc ec 01 00       	mov    %eax,0x1ecbc
    base.s.size = 0;
     e99:	c7 05 c0 ec 01 00 00 	movl   $0x0,0x1ecc0
     ea0:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     ea3:	8b 45 f0             	mov    -0x10(%ebp),%eax
     ea6:	8b 00                	mov    (%eax),%eax
     ea8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     eab:	8b 45 f4             	mov    -0xc(%ebp),%eax
     eae:	8b 40 04             	mov    0x4(%eax),%eax
     eb1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     eb4:	72 4d                	jb     f03 <malloc+0xa6>
      if(p->s.size == nunits)
     eb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
     eb9:	8b 40 04             	mov    0x4(%eax),%eax
     ebc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     ebf:	75 0c                	jne    ecd <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     ec1:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ec4:	8b 10                	mov    (%eax),%edx
     ec6:	8b 45 f0             	mov    -0x10(%ebp),%eax
     ec9:	89 10                	mov    %edx,(%eax)
     ecb:	eb 26                	jmp    ef3 <malloc+0x96>
      else {
        p->s.size -= nunits;
     ecd:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ed0:	8b 40 04             	mov    0x4(%eax),%eax
     ed3:	2b 45 ec             	sub    -0x14(%ebp),%eax
     ed6:	89 c2                	mov    %eax,%edx
     ed8:	8b 45 f4             	mov    -0xc(%ebp),%eax
     edb:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ee1:	8b 40 04             	mov    0x4(%eax),%eax
     ee4:	c1 e0 03             	shl    $0x3,%eax
     ee7:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     eea:	8b 45 f4             	mov    -0xc(%ebp),%eax
     eed:	8b 55 ec             	mov    -0x14(%ebp),%edx
     ef0:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     ef3:	8b 45 f0             	mov    -0x10(%ebp),%eax
     ef6:	a3 c4 ec 01 00       	mov    %eax,0x1ecc4
      return (void*)(p + 1);
     efb:	8b 45 f4             	mov    -0xc(%ebp),%eax
     efe:	83 c0 08             	add    $0x8,%eax
     f01:	eb 3b                	jmp    f3e <malloc+0xe1>
    }
    if(p == freep)
     f03:	a1 c4 ec 01 00       	mov    0x1ecc4,%eax
     f08:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     f0b:	75 1e                	jne    f2b <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     f0d:	83 ec 0c             	sub    $0xc,%esp
     f10:	ff 75 ec             	pushl  -0x14(%ebp)
     f13:	e8 e5 fe ff ff       	call   dfd <morecore>
     f18:	83 c4 10             	add    $0x10,%esp
     f1b:	89 45 f4             	mov    %eax,-0xc(%ebp)
     f1e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     f22:	75 07                	jne    f2b <malloc+0xce>
        return 0;
     f24:	b8 00 00 00 00       	mov    $0x0,%eax
     f29:	eb 13                	jmp    f3e <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     f2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     f2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
     f31:	8b 45 f4             	mov    -0xc(%ebp),%eax
     f34:	8b 00                	mov    (%eax),%eax
     f36:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     f39:	e9 6d ff ff ff       	jmp    eab <malloc+0x4e>
}
     f3e:	c9                   	leave  
     f3f:	c3                   	ret    

00000f40 <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     f40:	55                   	push   %ebp
     f41:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     f43:	a1 c8 ec 01 00       	mov    0x1ecc8,%eax
     f48:	83 c0 01             	add    $0x1,%eax
     f4b:	a3 c8 ec 01 00       	mov    %eax,0x1ecc8
    g_seed = (214013*g_seed+2531011);
     f50:	a1 c8 ec 01 00       	mov    0x1ecc8,%eax
     f55:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     f5b:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     f60:	a3 c8 ec 01 00       	mov    %eax,0x1ecc8
    return (g_seed>>16)&0x7FFF;
     f65:	a1 c8 ec 01 00       	mov    0x1ecc8,%eax
     f6a:	c1 e8 10             	shr    $0x10,%eax
     f6d:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     f72:	5d                   	pop    %ebp
     f73:	c3                   	ret    

00000f74 <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     f74:	55                   	push   %ebp
     f75:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     f77:	d9 45 08             	flds   0x8(%ebp)
     f7a:	d9 ee                	fldz   
     f7c:	d9 c9                	fxch   %st(1)
     f7e:	df e9                	fucomip %st(1),%st
     f80:	dd d8                	fstp   %st(0)
     f82:	76 05                	jbe    f89 <abs+0x15>
     f84:	d9 45 08             	flds   0x8(%ebp)
     f87:	eb 05                	jmp    f8e <abs+0x1a>
	return -x;
     f89:	d9 45 08             	flds   0x8(%ebp)
     f8c:	d9 e0                	fchs   
}
     f8e:	5d                   	pop    %ebp
     f8f:	c3                   	ret    

00000f90 <pow>:

float pow(float a, int b)
{
     f90:	55                   	push   %ebp
     f91:	89 e5                	mov    %esp,%ebp
     f93:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     f96:	d9 45 08             	flds   0x8(%ebp)
     f99:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     f9c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     fa0:	7e 17                	jle    fb9 <pow+0x29>
		while (--b)
     fa2:	eb 09                	jmp    fad <pow+0x1d>
			r *= a;
     fa4:	d9 45 fc             	flds   -0x4(%ebp)
     fa7:	d8 4d 08             	fmuls  0x8(%ebp)
     faa:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     fad:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     fb1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     fb5:	75 ed                	jne    fa4 <pow+0x14>
     fb7:	eb 2a                	jmp    fe3 <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     fb9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     fbd:	79 1f                	jns    fde <pow+0x4e>
		while (++b)
     fbf:	eb 09                	jmp    fca <pow+0x3a>
			r *= a;
     fc1:	d9 45 fc             	flds   -0x4(%ebp)
     fc4:	d8 4d 08             	fmuls  0x8(%ebp)
     fc7:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     fca:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     fce:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     fd2:	75 ed                	jne    fc1 <pow+0x31>
			r *= a;
		r = 1.0 / r;
     fd4:	d9 e8                	fld1   
     fd6:	d8 75 fc             	fdivs  -0x4(%ebp)
     fd9:	d9 5d fc             	fstps  -0x4(%ebp)
     fdc:	eb 05                	jmp    fe3 <pow+0x53>
	}
	else r = 0;
     fde:	d9 ee                	fldz   
     fe0:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     fe3:	d9 45 fc             	flds   -0x4(%ebp)
}
     fe6:	c9                   	leave  
     fe7:	c3                   	ret    

00000fe8 <sqrt>:

float sqrt(float number) {
     fe8:	55                   	push   %ebp
     fe9:	89 e5                	mov    %esp,%ebp
     feb:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     fee:	d9 ee                	fldz   
     ff0:	d9 45 08             	flds   0x8(%ebp)
     ff3:	d9 c9                	fxch   %st(1)
     ff5:	df e9                	fucomip %st(1),%st
     ff7:	dd d8                	fstp   %st(0)
     ff9:	76 06                	jbe    1001 <sqrt+0x19>
		return -1;
     ffb:	d9 e8                	fld1   
     ffd:	d9 e0                	fchs   
     fff:	eb 3a                	jmp    103b <sqrt+0x53>
	}

	new_guess = 1;
    1001:	d9 e8                	fld1   
    1003:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
    1006:	d9 45 fc             	flds   -0x4(%ebp)
    1009:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
    100c:	d9 45 08             	flds   0x8(%ebp)
    100f:	d8 75 f8             	fdivs  -0x8(%ebp)
    1012:	d8 45 f8             	fadds  -0x8(%ebp)
    1015:	d9 05 38 65 01 00    	flds   0x16538
    101b:	de f9                	fdivrp %st,%st(1)
    101d:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
    1020:	d9 45 fc             	flds   -0x4(%ebp)
    1023:	d9 45 f8             	flds   -0x8(%ebp)
    1026:	df e9                	fucomip %st(1),%st
    1028:	dd d8                	fstp   %st(0)
    102a:	7a da                	jp     1006 <sqrt+0x1e>
    102c:	d9 45 fc             	flds   -0x4(%ebp)
    102f:	d9 45 f8             	flds   -0x8(%ebp)
    1032:	df e9                	fucomip %st(1),%st
    1034:	dd d8                	fstp   %st(0)
    1036:	75 ce                	jne    1006 <sqrt+0x1e>

	return new_guess;
    1038:	d9 45 fc             	flds   -0x4(%ebp)
}
    103b:	c9                   	leave  
    103c:	c3                   	ret    

0000103d <cos>:

float cos(float x)
{
    103d:	55                   	push   %ebp
    103e:	89 e5                	mov    %esp,%ebp
    1040:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
    1043:	d9 e8                	fld1   
    1045:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
    1048:	d9 45 08             	flds   0x8(%ebp)
    104b:	dd 05 40 65 01 00    	fldl   0x16540
    1051:	d9 c9                	fxch   %st(1)
    1053:	df e9                	fucomip %st(1),%st
    1055:	dd d8                	fstp   %st(0)
    1057:	77 0f                	ja     1068 <cos+0x2b>
    1059:	d9 45 08             	flds   0x8(%ebp)
    105c:	dd 05 48 65 01 00    	fldl   0x16548
    1062:	df e9                	fucomip %st(1),%st
    1064:	dd d8                	fstp   %st(0)
    1066:	76 3c                	jbe    10a4 <cos+0x67>
    1068:	d9 45 08             	flds   0x8(%ebp)
    106b:	d9 45 08             	flds   0x8(%ebp)
    106e:	dd 05 40 65 01 00    	fldl   0x16540
    1074:	de f9                	fdivrp %st,%st(1)
    1076:	d9 7d e2             	fnstcw -0x1e(%ebp)
    1079:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
    107d:	b4 0c                	mov    $0xc,%ah
    107f:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    1083:	d9 6d e0             	fldcw  -0x20(%ebp)
    1086:	db 5d dc             	fistpl -0x24(%ebp)
    1089:	d9 6d e2             	fldcw  -0x1e(%ebp)
    108c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    108f:	01 c0                	add    %eax,%eax
    1091:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1094:	db 45 d8             	fildl  -0x28(%ebp)
    1097:	dd 05 50 65 01 00    	fldl   0x16550
    109d:	de c9                	fmulp  %st,%st(1)
    109f:	de e9                	fsubrp %st,%st(1)
    10a1:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
    10a4:	d9 45 08             	flds   0x8(%ebp)
    10a7:	dd 05 50 65 01 00    	fldl   0x16550
    10ad:	d9 c9                	fxch   %st(1)
    10af:	df e9                	fucomip %st(1),%st
    10b1:	dd d8                	fstp   %st(0)
    10b3:	76 0e                	jbe    10c3 <cos+0x86>
    10b5:	d9 45 08             	flds   0x8(%ebp)
    10b8:	dd 05 40 65 01 00    	fldl   0x16540
    10be:	de e9                	fsubrp %st,%st(1)
    10c0:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
    10c3:	d9 45 08             	flds   0x8(%ebp)
    10c6:	dd 05 58 65 01 00    	fldl   0x16558
    10cc:	df e9                	fucomip %st(1),%st
    10ce:	dd d8                	fstp   %st(0)
    10d0:	76 0e                	jbe    10e0 <cos+0xa3>
    10d2:	d9 45 08             	flds   0x8(%ebp)
    10d5:	dd 05 40 65 01 00    	fldl   0x16540
    10db:	de c1                	faddp  %st,%st(1)
    10dd:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
    10e0:	d9 45 08             	flds   0x8(%ebp)
    10e3:	dd 05 60 65 01 00    	fldl   0x16560
    10e9:	d9 c9                	fxch   %st(1)
    10eb:	df e9                	fucomip %st(1),%st
    10ed:	dd d8                	fstp   %st(0)
    10ef:	76 16                	jbe    1107 <cos+0xca>
    {
        x -= PI;
    10f1:	d9 45 08             	flds   0x8(%ebp)
    10f4:	dd 05 50 65 01 00    	fldl   0x16550
    10fa:	de e9                	fsubrp %st,%st(1)
    10fc:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    10ff:	d9 45 f4             	flds   -0xc(%ebp)
    1102:	d9 e0                	fchs   
    1104:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
    1107:	d9 45 08             	flds   0x8(%ebp)
    110a:	dd 05 68 65 01 00    	fldl   0x16568
    1110:	df e9                	fucomip %st(1),%st
    1112:	dd d8                	fstp   %st(0)
    1114:	76 16                	jbe    112c <cos+0xef>
    {
        x += PI;
    1116:	d9 45 08             	flds   0x8(%ebp)
    1119:	dd 05 50 65 01 00    	fldl   0x16550
    111f:	de c1                	faddp  %st,%st(1)
    1121:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    1124:	d9 45 f4             	flds   -0xc(%ebp)
    1127:	d9 e0                	fchs   
    1129:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
    112c:	d9 45 08             	flds   0x8(%ebp)
    112f:	dd 05 70 65 01 00    	fldl   0x16570
    1135:	d9 c9                	fxch   %st(1)
    1137:	df e9                	fucomip %st(1),%st
    1139:	dd d8                	fstp   %st(0)
    113b:	76 28                	jbe    1165 <cos+0x128>
    113d:	d9 45 08             	flds   0x8(%ebp)
    1140:	dd 05 60 65 01 00    	fldl   0x16560
    1146:	de e1                	fsubp  %st,%st(1)
    1148:	d9 5d e4             	fstps  -0x1c(%ebp)
    114b:	d9 45 e4             	flds   -0x1c(%ebp)
    114e:	83 ec 0c             	sub    $0xc,%esp
    1151:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    1155:	d9 1c 24             	fstps  (%esp)
    1158:	e8 83 00 00 00       	call   11e0 <sin>
    115d:	83 c4 10             	add    $0x10,%esp
    1160:	d8 4d f4             	fmuls  -0xc(%ebp)
    1163:	eb 79                	jmp    11de <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
    1165:	83 ec 08             	sub    $0x8,%esp
    1168:	6a 02                	push   $0x2
    116a:	ff 75 08             	pushl  0x8(%ebp)
    116d:	e8 1e fe ff ff       	call   f90 <pow>
    1172:	83 c4 10             	add    $0x10,%esp
    1175:	d9 05 38 65 01 00    	flds   0x16538
    117b:	de f9                	fdivrp %st,%st(1)
    117d:	d9 e8                	fld1   
    117f:	de e1                	fsubp  %st,%st(1)
    1181:	d9 5d d8             	fstps  -0x28(%ebp)
    1184:	83 ec 08             	sub    $0x8,%esp
    1187:	6a 04                	push   $0x4
    1189:	ff 75 08             	pushl  0x8(%ebp)
    118c:	e8 ff fd ff ff       	call   f90 <pow>
    1191:	83 c4 10             	add    $0x10,%esp
    1194:	d9 05 78 65 01 00    	flds   0x16578
    119a:	de f9                	fdivrp %st,%st(1)
    119c:	d8 45 d8             	fadds  -0x28(%ebp)
    119f:	d9 5d d8             	fstps  -0x28(%ebp)
    11a2:	83 ec 08             	sub    $0x8,%esp
    11a5:	6a 06                	push   $0x6
    11a7:	ff 75 08             	pushl  0x8(%ebp)
    11aa:	e8 e1 fd ff ff       	call   f90 <pow>
    11af:	83 c4 10             	add    $0x10,%esp
    11b2:	d9 05 7c 65 01 00    	flds   0x1657c
    11b8:	de f9                	fdivrp %st,%st(1)
    11ba:	d8 6d d8             	fsubrs -0x28(%ebp)
    11bd:	d9 5d d8             	fstps  -0x28(%ebp)
    11c0:	83 ec 08             	sub    $0x8,%esp
    11c3:	6a 08                	push   $0x8
    11c5:	ff 75 08             	pushl  0x8(%ebp)
    11c8:	e8 c3 fd ff ff       	call   f90 <pow>
    11cd:	83 c4 10             	add    $0x10,%esp
    11d0:	d9 05 80 65 01 00    	flds   0x16580
    11d6:	de f9                	fdivrp %st,%st(1)
    11d8:	d8 45 d8             	fadds  -0x28(%ebp)
    11db:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    11de:	c9                   	leave  
    11df:	c3                   	ret    

000011e0 <sin>:

float sin(float x)
{
    11e0:	55                   	push   %ebp
    11e1:	89 e5                	mov    %esp,%ebp
    11e3:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
    11e6:	d9 e8                	fld1   
    11e8:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
    11eb:	d9 45 08             	flds   0x8(%ebp)
    11ee:	dd 05 40 65 01 00    	fldl   0x16540
    11f4:	d9 c9                	fxch   %st(1)
    11f6:	df e9                	fucomip %st(1),%st
    11f8:	dd d8                	fstp   %st(0)
    11fa:	77 0f                	ja     120b <sin+0x2b>
    11fc:	d9 45 08             	flds   0x8(%ebp)
    11ff:	dd 05 48 65 01 00    	fldl   0x16548
    1205:	df e9                	fucomip %st(1),%st
    1207:	dd d8                	fstp   %st(0)
    1209:	76 3c                	jbe    1247 <sin+0x67>
    120b:	d9 45 08             	flds   0x8(%ebp)
    120e:	d9 45 08             	flds   0x8(%ebp)
    1211:	dd 05 40 65 01 00    	fldl   0x16540
    1217:	de f9                	fdivrp %st,%st(1)
    1219:	d9 7d e2             	fnstcw -0x1e(%ebp)
    121c:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
    1220:	b4 0c                	mov    $0xc,%ah
    1222:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    1226:	d9 6d e0             	fldcw  -0x20(%ebp)
    1229:	db 5d dc             	fistpl -0x24(%ebp)
    122c:	d9 6d e2             	fldcw  -0x1e(%ebp)
    122f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1232:	01 c0                	add    %eax,%eax
    1234:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1237:	db 45 d8             	fildl  -0x28(%ebp)
    123a:	dd 05 50 65 01 00    	fldl   0x16550
    1240:	de c9                	fmulp  %st,%st(1)
    1242:	de e9                	fsubrp %st,%st(1)
    1244:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
    1247:	d9 45 08             	flds   0x8(%ebp)
    124a:	dd 05 50 65 01 00    	fldl   0x16550
    1250:	d9 c9                	fxch   %st(1)
    1252:	df e9                	fucomip %st(1),%st
    1254:	dd d8                	fstp   %st(0)
    1256:	76 0e                	jbe    1266 <sin+0x86>
    1258:	d9 45 08             	flds   0x8(%ebp)
    125b:	dd 05 40 65 01 00    	fldl   0x16540
    1261:	de e9                	fsubrp %st,%st(1)
    1263:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
    1266:	d9 45 08             	flds   0x8(%ebp)
    1269:	dd 05 58 65 01 00    	fldl   0x16558
    126f:	df e9                	fucomip %st(1),%st
    1271:	dd d8                	fstp   %st(0)
    1273:	76 0e                	jbe    1283 <sin+0xa3>
    1275:	d9 45 08             	flds   0x8(%ebp)
    1278:	dd 05 40 65 01 00    	fldl   0x16540
    127e:	de c1                	faddp  %st,%st(1)
    1280:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
    1283:	d9 45 08             	flds   0x8(%ebp)
    1286:	dd 05 60 65 01 00    	fldl   0x16560
    128c:	d9 c9                	fxch   %st(1)
    128e:	df e9                	fucomip %st(1),%st
    1290:	dd d8                	fstp   %st(0)
    1292:	76 16                	jbe    12aa <sin+0xca>
    {
        x -= PI;
    1294:	d9 45 08             	flds   0x8(%ebp)
    1297:	dd 05 50 65 01 00    	fldl   0x16550
    129d:	de e9                	fsubrp %st,%st(1)
    129f:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    12a2:	d9 45 f4             	flds   -0xc(%ebp)
    12a5:	d9 e0                	fchs   
    12a7:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
    12aa:	d9 45 08             	flds   0x8(%ebp)
    12ad:	dd 05 68 65 01 00    	fldl   0x16568
    12b3:	df e9                	fucomip %st(1),%st
    12b5:	dd d8                	fstp   %st(0)
    12b7:	76 16                	jbe    12cf <sin+0xef>
    {
        x += PI;
    12b9:	d9 45 08             	flds   0x8(%ebp)
    12bc:	dd 05 50 65 01 00    	fldl   0x16550
    12c2:	de c1                	faddp  %st,%st(1)
    12c4:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    12c7:	d9 45 f4             	flds   -0xc(%ebp)
    12ca:	d9 e0                	fchs   
    12cc:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
    12cf:	d9 ee                	fldz   
    12d1:	d9 45 08             	flds   0x8(%ebp)
    12d4:	d9 c9                	fxch   %st(1)
    12d6:	df e9                	fucomip %st(1),%st
    12d8:	dd d8                	fstp   %st(0)
    12da:	76 10                	jbe    12ec <sin+0x10c>
    {
        x *= -1;
    12dc:	d9 45 08             	flds   0x8(%ebp)
    12df:	d9 e0                	fchs   
    12e1:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    12e4:	d9 45 f4             	flds   -0xc(%ebp)
    12e7:	d9 e0                	fchs   
    12e9:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
    12ec:	d9 45 08             	flds   0x8(%ebp)
    12ef:	dd 05 70 65 01 00    	fldl   0x16570
    12f5:	d9 c9                	fxch   %st(1)
    12f7:	df e9                	fucomip %st(1),%st
    12f9:	dd d8                	fstp   %st(0)
    12fb:	76 28                	jbe    1325 <sin+0x145>
    12fd:	d9 45 08             	flds   0x8(%ebp)
    1300:	dd 05 60 65 01 00    	fldl   0x16560
    1306:	de e1                	fsubp  %st,%st(1)
    1308:	d9 5d e4             	fstps  -0x1c(%ebp)
    130b:	d9 45 e4             	flds   -0x1c(%ebp)
    130e:	83 ec 0c             	sub    $0xc,%esp
    1311:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    1315:	d9 1c 24             	fstps  (%esp)
    1318:	e8 20 fd ff ff       	call   103d <cos>
    131d:	83 c4 10             	add    $0x10,%esp
    1320:	d8 4d f4             	fmuls  -0xc(%ebp)
    1323:	eb 7a                	jmp    139f <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
    1325:	83 ec 08             	sub    $0x8,%esp
    1328:	6a 03                	push   $0x3
    132a:	ff 75 08             	pushl  0x8(%ebp)
    132d:	e8 5e fc ff ff       	call   f90 <pow>
    1332:	83 c4 10             	add    $0x10,%esp
    1335:	d9 05 84 65 01 00    	flds   0x16584
    133b:	de f9                	fdivrp %st,%st(1)
    133d:	d9 45 08             	flds   0x8(%ebp)
    1340:	de e1                	fsubp  %st,%st(1)
    1342:	d9 5d d8             	fstps  -0x28(%ebp)
    1345:	83 ec 08             	sub    $0x8,%esp
    1348:	6a 05                	push   $0x5
    134a:	ff 75 08             	pushl  0x8(%ebp)
    134d:	e8 3e fc ff ff       	call   f90 <pow>
    1352:	83 c4 10             	add    $0x10,%esp
    1355:	d9 05 88 65 01 00    	flds   0x16588
    135b:	de f9                	fdivrp %st,%st(1)
    135d:	d8 45 d8             	fadds  -0x28(%ebp)
    1360:	d9 5d d8             	fstps  -0x28(%ebp)
    1363:	83 ec 08             	sub    $0x8,%esp
    1366:	6a 07                	push   $0x7
    1368:	ff 75 08             	pushl  0x8(%ebp)
    136b:	e8 20 fc ff ff       	call   f90 <pow>
    1370:	83 c4 10             	add    $0x10,%esp
    1373:	d9 05 8c 65 01 00    	flds   0x1658c
    1379:	de f9                	fdivrp %st,%st(1)
    137b:	d8 6d d8             	fsubrs -0x28(%ebp)
    137e:	d9 5d d8             	fstps  -0x28(%ebp)
    1381:	83 ec 08             	sub    $0x8,%esp
    1384:	6a 09                	push   $0x9
    1386:	ff 75 08             	pushl  0x8(%ebp)
    1389:	e8 02 fc ff ff       	call   f90 <pow>
    138e:	83 c4 10             	add    $0x10,%esp
    1391:	d9 05 90 65 01 00    	flds   0x16590
    1397:	de f9                	fdivrp %st,%st(1)
    1399:	d8 45 d8             	fadds  -0x28(%ebp)
    139c:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    139f:	c9                   	leave  
    13a0:	c3                   	ret    

000013a1 <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
    13a1:	55                   	push   %ebp
    13a2:	89 e5                	mov    %esp,%ebp
    13a4:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    13a7:	83 ec 04             	sub    $0x4,%esp
    13aa:	6a 0e                	push   $0xe
    13ac:	ff 75 0c             	pushl  0xc(%ebp)
    13af:	ff 75 08             	pushl  0x8(%ebp)
    13b2:	e8 44 f6 ff ff       	call   9fb <read>
    13b7:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    13ba:	83 ec 04             	sub    $0x4,%esp
    13bd:	6a 28                	push   $0x28
    13bf:	ff 75 10             	pushl  0x10(%ebp)
    13c2:	ff 75 08             	pushl  0x8(%ebp)
    13c5:	e8 31 f6 ff ff       	call   9fb <read>
    13ca:	83 c4 10             	add    $0x10,%esp
}
    13cd:	90                   	nop
    13ce:	c9                   	leave  
    13cf:	c3                   	ret    

000013d0 <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
    13d0:	55                   	push   %ebp
    13d1:	89 e5                	mov    %esp,%ebp
    13d3:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    13d9:	83 ec 08             	sub    $0x8,%esp
    13dc:	6a 00                	push   $0x0
    13de:	ff 75 08             	pushl  0x8(%ebp)
    13e1:	e8 3d f6 ff ff       	call   a23 <open>
    13e6:	83 c4 10             	add    $0x10,%esp
    13e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    13ec:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    13f0:	79 0a                	jns    13fc <readBitmapFile+0x2c>
        return -1;
    13f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    13f7:	e9 6e 01 00 00       	jmp    156a <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    13fc:	83 ec 04             	sub    $0x4,%esp
    13ff:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    1402:	50                   	push   %eax
    1403:	8d 45 ca             	lea    -0x36(%ebp),%eax
    1406:	50                   	push   %eax
    1407:	ff 75 ec             	pushl  -0x14(%ebp)
    140a:	e8 92 ff ff ff       	call   13a1 <readBitmapHeader>
    140f:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    1412:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    1415:	83 e8 36             	sub    $0x36,%eax
    1418:	83 ec 04             	sub    $0x4,%esp
    141b:	50                   	push   %eax
    141c:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    1422:	50                   	push   %eax
    1423:	ff 75 ec             	pushl  -0x14(%ebp)
    1426:	e8 d0 f5 ff ff       	call   9fb <read>
    142b:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    142e:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    1431:	8b 45 14             	mov    0x14(%ebp),%eax
    1434:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    1436:	8b 55 aa             	mov    -0x56(%ebp),%edx
    1439:	8b 45 10             	mov    0x10(%ebp),%eax
    143c:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    143e:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    1441:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    1444:	8b 45 aa             	mov    -0x56(%ebp),%eax
    1447:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    144a:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    144e:	0f b7 c0             	movzwl %ax,%eax
    1451:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    1454:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1457:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    145b:	8d 50 07             	lea    0x7(%eax),%edx
    145e:	85 c0                	test   %eax,%eax
    1460:	0f 48 c2             	cmovs  %edx,%eax
    1463:	c1 f8 03             	sar    $0x3,%eax
    1466:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    1469:	8b 45 0c             	mov    0xc(%ebp),%eax
    146c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    146f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1472:	83 e8 01             	sub    $0x1,%eax
    1475:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1478:	e9 d0 00 00 00       	jmp    154d <readBitmapFile+0x17d>
        if (bits == 32) {
    147d:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
    1481:	75 22                	jne    14a5 <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    1483:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1486:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    148a:	89 c2                	mov    %eax,%edx
    148c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    148f:	01 d0                	add    %edx,%eax
    1491:	83 ec 04             	sub    $0x4,%esp
    1494:	ff 75 dc             	pushl  -0x24(%ebp)
    1497:	50                   	push   %eax
    1498:	ff 75 ec             	pushl  -0x14(%ebp)
    149b:	e8 5b f5 ff ff       	call   9fb <read>
    14a0:	83 c4 10             	add    $0x10,%esp
    14a3:	eb 65                	jmp    150a <readBitmapFile+0x13a>
        } else {
            int j = 0;
    14a5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    14ac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    14b3:	eb 4d                	jmp    1502 <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
    14b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    14b8:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    14bc:	c1 e0 02             	shl    $0x2,%eax
    14bf:	89 c2                	mov    %eax,%edx
    14c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    14c4:	c1 e0 02             	shl    $0x2,%eax
    14c7:	01 c2                	add    %eax,%edx
    14c9:	8b 45 d8             	mov    -0x28(%ebp),%eax
    14cc:	01 d0                	add    %edx,%eax
    14ce:	83 ec 04             	sub    $0x4,%esp
    14d1:	6a 03                	push   $0x3
    14d3:	50                   	push   %eax
    14d4:	ff 75 ec             	pushl  -0x14(%ebp)
    14d7:	e8 1f f5 ff ff       	call   9fb <read>
    14dc:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
    14df:	8b 45 f4             	mov    -0xc(%ebp),%eax
    14e2:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    14e6:	c1 e0 02             	shl    $0x2,%eax
    14e9:	89 c2                	mov    %eax,%edx
    14eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    14ee:	c1 e0 02             	shl    $0x2,%eax
    14f1:	01 d0                	add    %edx,%eax
    14f3:	8d 50 03             	lea    0x3(%eax),%edx
    14f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
    14f9:	01 d0                	add    %edx,%eax
    14fb:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    14fe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1502:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1505:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    1508:	7c ab                	jl     14b5 <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
    150a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    150d:	99                   	cltd   
    150e:	c1 ea 1e             	shr    $0x1e,%edx
    1511:	01 d0                	add    %edx,%eax
    1513:	83 e0 03             	and    $0x3,%eax
    1516:	29 d0                	sub    %edx,%eax
    1518:	85 c0                	test   %eax,%eax
    151a:	7e 2d                	jle    1549 <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    151c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    151f:	99                   	cltd   
    1520:	c1 ea 1e             	shr    $0x1e,%edx
    1523:	01 d0                	add    %edx,%eax
    1525:	83 e0 03             	and    $0x3,%eax
    1528:	29 d0                	sub    %edx,%eax
    152a:	ba 04 00 00 00       	mov    $0x4,%edx
    152f:	29 c2                	sub    %eax,%edx
    1531:	89 d0                	mov    %edx,%eax
    1533:	83 ec 04             	sub    $0x4,%esp
    1536:	50                   	push   %eax
    1537:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    153d:	50                   	push   %eax
    153e:	ff 75 ec             	pushl  -0x14(%ebp)
    1541:	e8 b5 f4 ff ff       	call   9fb <read>
    1546:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    1549:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    154d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1551:	0f 89 26 ff ff ff    	jns    147d <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1557:	83 ec 0c             	sub    $0xc,%esp
    155a:	ff 75 ec             	pushl  -0x14(%ebp)
    155d:	e8 a9 f4 ff ff       	call   a0b <close>
    1562:	83 c4 10             	add    $0x10,%esp
    return 0;
    1565:	b8 00 00 00 00       	mov    $0x0,%eax
}
    156a:	c9                   	leave  
    156b:	c3                   	ret    

0000156c <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
    156c:	55                   	push   %ebp
    156d:	89 e5                	mov    %esp,%ebp
    156f:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    1575:	83 ec 08             	sub    $0x8,%esp
    1578:	6a 00                	push   $0x0
    157a:	ff 75 08             	pushl  0x8(%ebp)
    157d:	e8 a1 f4 ff ff       	call   a23 <open>
    1582:	83 c4 10             	add    $0x10,%esp
    1585:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    1588:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    158c:	79 0a                	jns    1598 <read24BitmapFile+0x2c>
        return -1;
    158e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    1593:	e9 66 01 00 00       	jmp    16fe <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    1598:	83 ec 04             	sub    $0x4,%esp
    159b:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    159e:	50                   	push   %eax
    159f:	8d 45 ca             	lea    -0x36(%ebp),%eax
    15a2:	50                   	push   %eax
    15a3:	ff 75 ec             	pushl  -0x14(%ebp)
    15a6:	e8 f6 fd ff ff       	call   13a1 <readBitmapHeader>
    15ab:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    15ae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    15b1:	83 e8 36             	sub    $0x36,%eax
    15b4:	83 ec 04             	sub    $0x4,%esp
    15b7:	50                   	push   %eax
    15b8:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    15be:	50                   	push   %eax
    15bf:	ff 75 ec             	pushl  -0x14(%ebp)
    15c2:	e8 34 f4 ff ff       	call   9fb <read>
    15c7:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    15ca:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    15cd:	8b 45 14             	mov    0x14(%ebp),%eax
    15d0:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    15d2:	8b 55 aa             	mov    -0x56(%ebp),%edx
    15d5:	8b 45 10             	mov    0x10(%ebp),%eax
    15d8:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    15da:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    15dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    15e0:	8b 45 aa             	mov    -0x56(%ebp),%eax
    15e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    15e6:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    15ea:	0f b7 c0             	movzwl %ax,%eax
    15ed:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
    15f0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    15f3:	89 d0                	mov    %edx,%eax
    15f5:	01 c0                	add    %eax,%eax
    15f7:	01 d0                	add    %edx,%eax
    15f9:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    15fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    15ff:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    1602:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1605:	83 e8 01             	sub    $0x1,%eax
    1608:	89 45 f4             	mov    %eax,-0xc(%ebp)
    160b:	e9 d1 00 00 00       	jmp    16e1 <read24BitmapFile+0x175>
        if (bits == 24) {
    1610:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
    1614:	75 22                	jne    1638 <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    1616:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1619:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    161d:	89 c2                	mov    %eax,%edx
    161f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1622:	01 d0                	add    %edx,%eax
    1624:	83 ec 04             	sub    $0x4,%esp
    1627:	ff 75 dc             	pushl  -0x24(%ebp)
    162a:	50                   	push   %eax
    162b:	ff 75 ec             	pushl  -0x14(%ebp)
    162e:	e8 c8 f3 ff ff       	call   9fb <read>
    1633:	83 c4 10             	add    $0x10,%esp
    1636:	eb 66                	jmp    169e <read24BitmapFile+0x132>
        } else {
            int j = 0;
    1638:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    163f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1646:	eb 4e                	jmp    1696 <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
    1648:	8b 45 f4             	mov    -0xc(%ebp),%eax
    164b:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    164f:	89 c2                	mov    %eax,%edx
    1651:	89 d0                	mov    %edx,%eax
    1653:	01 c0                	add    %eax,%eax
    1655:	01 d0                	add    %edx,%eax
    1657:	89 c1                	mov    %eax,%ecx
    1659:	8b 55 f0             	mov    -0x10(%ebp),%edx
    165c:	89 d0                	mov    %edx,%eax
    165e:	01 c0                	add    %eax,%eax
    1660:	01 d0                	add    %edx,%eax
    1662:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    1665:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1668:	01 d0                	add    %edx,%eax
    166a:	83 ec 04             	sub    $0x4,%esp
    166d:	6a 03                	push   $0x3
    166f:	50                   	push   %eax
    1670:	ff 75 ec             	pushl  -0x14(%ebp)
    1673:	e8 83 f3 ff ff       	call   9fb <read>
    1678:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
    167b:	83 ec 04             	sub    $0x4,%esp
    167e:	6a 01                	push   $0x1
    1680:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    1686:	50                   	push   %eax
    1687:	ff 75 ec             	pushl  -0x14(%ebp)
    168a:	e8 6c f3 ff ff       	call   9fb <read>
    168f:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    1692:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1696:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1699:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    169c:	7c aa                	jl     1648 <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    169e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    16a1:	99                   	cltd   
    16a2:	c1 ea 1e             	shr    $0x1e,%edx
    16a5:	01 d0                	add    %edx,%eax
    16a7:	83 e0 03             	and    $0x3,%eax
    16aa:	29 d0                	sub    %edx,%eax
    16ac:	85 c0                	test   %eax,%eax
    16ae:	7e 2d                	jle    16dd <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    16b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    16b3:	99                   	cltd   
    16b4:	c1 ea 1e             	shr    $0x1e,%edx
    16b7:	01 d0                	add    %edx,%eax
    16b9:	83 e0 03             	and    $0x3,%eax
    16bc:	29 d0                	sub    %edx,%eax
    16be:	ba 04 00 00 00       	mov    $0x4,%edx
    16c3:	29 c2                	sub    %eax,%edx
    16c5:	89 d0                	mov    %edx,%eax
    16c7:	83 ec 04             	sub    $0x4,%esp
    16ca:	50                   	push   %eax
    16cb:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    16d1:	50                   	push   %eax
    16d2:	ff 75 ec             	pushl  -0x14(%ebp)
    16d5:	e8 21 f3 ff ff       	call   9fb <read>
    16da:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    16dd:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    16e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    16e5:	0f 89 25 ff ff ff    	jns    1610 <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    16eb:	83 ec 0c             	sub    $0xc,%esp
    16ee:	ff 75 ec             	pushl  -0x14(%ebp)
    16f1:	e8 15 f3 ff ff       	call   a0b <close>
    16f6:	83 c4 10             	add    $0x10,%esp
    return 0;
    16f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    16fe:	c9                   	leave  
    16ff:	c3                   	ret    

00001700 <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    1700:	55                   	push   %ebp
    1701:	89 e5                	mov    %esp,%ebp
    1703:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    1706:	8b 55 10             	mov    0x10(%ebp),%edx
    1709:	89 d0                	mov    %edx,%eax
    170b:	01 c0                	add    %eax,%eax
    170d:	01 d0                	add    %edx,%eax
    170f:	c1 e0 03             	shl    $0x3,%eax
    1712:	83 c0 1f             	add    $0x1f,%eax
    1715:	8d 50 1f             	lea    0x1f(%eax),%edx
    1718:	85 c0                	test   %eax,%eax
    171a:	0f 48 c2             	cmovs  %edx,%eax
    171d:	c1 f8 05             	sar    $0x5,%eax
    1720:	c1 e0 02             	shl    $0x2,%eax
    1723:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    1726:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    172c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    172f:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1733:	83 c0 36             	add    $0x36,%eax
    1736:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    1739:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    173f:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    1745:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    174c:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    1753:	8b 45 10             	mov    0x10(%ebp),%eax
    1756:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    1759:	8b 45 0c             	mov    0xc(%ebp),%eax
    175c:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    175f:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    1765:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    176b:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    1772:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1775:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1779:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    177c:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    1783:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    178a:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    1791:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    1798:	83 ec 04             	sub    $0x4,%esp
    179b:	6a 0e                	push   $0xe
    179d:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    17a0:	50                   	push   %eax
    17a1:	ff 75 08             	pushl  0x8(%ebp)
    17a4:	e8 5a f2 ff ff       	call   a03 <write>
    17a9:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    17ac:	83 ec 04             	sub    $0x4,%esp
    17af:	6a 28                	push   $0x28
    17b1:	8d 45 be             	lea    -0x42(%ebp),%eax
    17b4:	50                   	push   %eax
    17b5:	ff 75 08             	pushl  0x8(%ebp)
    17b8:	e8 46 f2 ff ff       	call   a03 <write>
    17bd:	83 c4 10             	add    $0x10,%esp
}
    17c0:	90                   	nop
    17c1:	c9                   	leave  
    17c2:	c3                   	ret    

000017c3 <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    17c3:	55                   	push   %ebp
    17c4:	89 e5                	mov    %esp,%ebp
    17c6:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    17c9:	83 ec 08             	sub    $0x8,%esp
    17cc:	68 02 02 00 00       	push   $0x202
    17d1:	ff 75 08             	pushl  0x8(%ebp)
    17d4:	e8 4a f2 ff ff       	call   a23 <open>
    17d9:	83 c4 10             	add    $0x10,%esp
    17dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    17df:	8b 55 14             	mov    0x14(%ebp),%edx
    17e2:	89 d0                	mov    %edx,%eax
    17e4:	01 c0                	add    %eax,%eax
    17e6:	01 d0                	add    %edx,%eax
    17e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    17eb:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    17ef:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    17f3:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    17f7:	83 ec 04             	sub    $0x4,%esp
    17fa:	ff 75 14             	pushl  0x14(%ebp)
    17fd:	ff 75 10             	pushl  0x10(%ebp)
    1800:	ff 75 f0             	pushl  -0x10(%ebp)
    1803:	e8 f8 fe ff ff       	call   1700 <write24BitmapFileHeader>
    1808:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    180b:	8b 45 10             	mov    0x10(%ebp),%eax
    180e:	83 e8 01             	sub    $0x1,%eax
    1811:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1814:	eb 66                	jmp    187c <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    1816:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1819:	0f af 45 14          	imul   0x14(%ebp),%eax
    181d:	89 c2                	mov    %eax,%edx
    181f:	89 d0                	mov    %edx,%eax
    1821:	01 c0                	add    %eax,%eax
    1823:	01 c2                	add    %eax,%edx
    1825:	8b 45 0c             	mov    0xc(%ebp),%eax
    1828:	01 d0                	add    %edx,%eax
    182a:	83 ec 04             	sub    $0x4,%esp
    182d:	ff 75 ec             	pushl  -0x14(%ebp)
    1830:	50                   	push   %eax
    1831:	ff 75 f0             	pushl  -0x10(%ebp)
    1834:	e8 ca f1 ff ff       	call   a03 <write>
    1839:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    183c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    183f:	99                   	cltd   
    1840:	c1 ea 1e             	shr    $0x1e,%edx
    1843:	01 d0                	add    %edx,%eax
    1845:	83 e0 03             	and    $0x3,%eax
    1848:	29 d0                	sub    %edx,%eax
    184a:	85 c0                	test   %eax,%eax
    184c:	7e 2a                	jle    1878 <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    184e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1851:	99                   	cltd   
    1852:	c1 ea 1e             	shr    $0x1e,%edx
    1855:	01 d0                	add    %edx,%eax
    1857:	83 e0 03             	and    $0x3,%eax
    185a:	29 d0                	sub    %edx,%eax
    185c:	ba 04 00 00 00       	mov    $0x4,%edx
    1861:	29 c2                	sub    %eax,%edx
    1863:	89 d0                	mov    %edx,%eax
    1865:	83 ec 04             	sub    $0x4,%esp
    1868:	50                   	push   %eax
    1869:	8d 45 e9             	lea    -0x17(%ebp),%eax
    186c:	50                   	push   %eax
    186d:	ff 75 f0             	pushl  -0x10(%ebp)
    1870:	e8 8e f1 ff ff       	call   a03 <write>
    1875:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    1878:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    187c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1880:	79 94                	jns    1816 <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1882:	83 ec 0c             	sub    $0xc,%esp
    1885:	ff 75 f0             	pushl  -0x10(%ebp)
    1888:	e8 7e f1 ff ff       	call   a0b <close>
    188d:	83 c4 10             	add    $0x10,%esp
    return 0;
    1890:	b8 00 00 00 00       	mov    $0x0,%eax
    1895:	c9                   	leave  
    1896:	c3                   	ret    

00001897 <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    1897:	55                   	push   %ebp
    1898:	89 e5                	mov    %esp,%ebp
    189a:	57                   	push   %edi
    189b:	56                   	push   %esi
    189c:	53                   	push   %ebx
    189d:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    18a0:	8b 45 08             	mov    0x8(%ebp),%eax
    18a3:	8b 50 10             	mov    0x10(%eax),%edx
    18a6:	8b 40 0c             	mov    0xc(%eax),%eax
    18a9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    18ac:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    18af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    18b2:	8b 55 e0             	mov    -0x20(%ebp),%edx
    18b5:	83 c2 1e             	add    $0x1e,%edx
    18b8:	0f af d0             	imul   %eax,%edx
    18bb:	89 d0                	mov    %edx,%eax
    18bd:	01 c0                	add    %eax,%eax
    18bf:	01 d0                	add    %edx,%eax
    18c1:	83 ec 0c             	sub    $0xc,%esp
    18c4:	50                   	push   %eax
    18c5:	e8 93 f5 ff ff       	call   e5d <malloc>
    18ca:	83 c4 10             	add    $0x10,%esp
    18cd:	89 c2                	mov    %eax,%edx
    18cf:	8b 45 08             	mov    0x8(%ebp),%eax
    18d2:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    18d5:	8b 45 08             	mov    0x8(%ebp),%eax
    18d8:	8b 40 1c             	mov    0x1c(%eax),%eax
    18db:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    18de:	6b d2 5a             	imul   $0x5a,%edx,%edx
    18e1:	01 c2                	add    %eax,%edx
    18e3:	8b 45 08             	mov    0x8(%ebp),%eax
    18e6:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    18e9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    18ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
    18ef:	0f af d0             	imul   %eax,%edx
    18f2:	89 d0                	mov    %edx,%eax
    18f4:	01 c0                	add    %eax,%eax
    18f6:	01 d0                	add    %edx,%eax
    18f8:	89 c2                	mov    %eax,%edx
    18fa:	8b 45 08             	mov    0x8(%ebp),%eax
    18fd:	8b 40 18             	mov    0x18(%eax),%eax
    1900:	83 ec 04             	sub    $0x4,%esp
    1903:	52                   	push   %edx
    1904:	68 ff 00 00 00       	push   $0xff
    1909:	50                   	push   %eax
    190a:	e8 39 ef ff ff       	call   848 <memset>
    190f:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    1912:	8b 45 08             	mov    0x8(%ebp),%eax
    1915:	8b 78 1c             	mov    0x1c(%eax),%edi
    1918:	8b 45 08             	mov    0x8(%ebp),%eax
    191b:	8b 70 14             	mov    0x14(%eax),%esi
    191e:	8b 45 08             	mov    0x8(%ebp),%eax
    1921:	8b 58 0c             	mov    0xc(%eax),%ebx
    1924:	8b 45 08             	mov    0x8(%ebp),%eax
    1927:	8b 48 10             	mov    0x10(%eax),%ecx
    192a:	8b 45 08             	mov    0x8(%ebp),%eax
    192d:	8b 50 08             	mov    0x8(%eax),%edx
    1930:	8b 45 08             	mov    0x8(%ebp),%eax
    1933:	8b 40 04             	mov    0x4(%eax),%eax
    1936:	83 ec 08             	sub    $0x8,%esp
    1939:	57                   	push   %edi
    193a:	56                   	push   %esi
    193b:	53                   	push   %ebx
    193c:	51                   	push   %ecx
    193d:	52                   	push   %edx
    193e:	50                   	push   %eax
    193f:	e8 3f f1 ff ff       	call   a83 <createwindow>
    1944:	83 c4 20             	add    $0x20,%esp
    1947:	89 c2                	mov    %eax,%edx
    1949:	8b 45 08             	mov    0x8(%ebp),%eax
    194c:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    194e:	8b 45 08             	mov    0x8(%ebp),%eax
    1951:	8b 00                	mov    (%eax),%eax
}
    1953:	8d 65 f4             	lea    -0xc(%ebp),%esp
    1956:	5b                   	pop    %ebx
    1957:	5e                   	pop    %esi
    1958:	5f                   	pop    %edi
    1959:	5d                   	pop    %ebp
    195a:	c3                   	ret    

0000195b <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    195b:	55                   	push   %ebp
    195c:	89 e5                	mov    %esp,%ebp
    195e:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    1961:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1968:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    196f:	8b 45 08             	mov    0x8(%ebp),%eax
    1972:	8b 40 18             	mov    0x18(%eax),%eax
    1975:	ff 75 1c             	pushl  0x1c(%ebp)
    1978:	ff 75 18             	pushl  0x18(%ebp)
    197b:	ff 75 1c             	pushl  0x1c(%ebp)
    197e:	ff 75 18             	pushl  0x18(%ebp)
    1981:	8b 55 08             	mov    0x8(%ebp),%edx
    1984:	ff 72 10             	pushl  0x10(%edx)
    1987:	ff 72 0c             	pushl  0xc(%edx)
    198a:	ff 75 f4             	pushl  -0xc(%ebp)
    198d:	ff 75 f0             	pushl  -0x10(%ebp)
    1990:	ff 75 14             	pushl  0x14(%ebp)
    1993:	ff 75 10             	pushl  0x10(%ebp)
    1996:	ff 75 0c             	pushl  0xc(%ebp)
    1999:	50                   	push   %eax
    199a:	e8 d5 07 00 00       	call   2174 <drawBitmap>
    199f:	83 c4 30             	add    $0x30,%esp
    return 0;
    19a2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    19a7:	c9                   	leave  
    19a8:	c3                   	ret    

000019a9 <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    19a9:	55                   	push   %ebp
    19aa:	89 e5                	mov    %esp,%ebp
    19ac:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    19af:	8b 45 08             	mov    0x8(%ebp),%eax
    19b2:	8b 40 18             	mov    0x18(%eax),%eax
    19b5:	ff 75 2c             	pushl  0x2c(%ebp)
    19b8:	ff 75 28             	pushl  0x28(%ebp)
    19bb:	ff 75 24             	pushl  0x24(%ebp)
    19be:	ff 75 20             	pushl  0x20(%ebp)
    19c1:	8b 55 08             	mov    0x8(%ebp),%edx
    19c4:	ff 72 10             	pushl  0x10(%edx)
    19c7:	ff 72 0c             	pushl  0xc(%edx)
    19ca:	ff 75 1c             	pushl  0x1c(%ebp)
    19cd:	ff 75 18             	pushl  0x18(%ebp)
    19d0:	ff 75 14             	pushl  0x14(%ebp)
    19d3:	ff 75 10             	pushl  0x10(%ebp)
    19d6:	ff 75 0c             	pushl  0xc(%ebp)
    19d9:	50                   	push   %eax
    19da:	e8 95 07 00 00       	call   2174 <drawBitmap>
    19df:	83 c4 30             	add    $0x30,%esp
    return 0;
    19e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    19e7:	c9                   	leave  
    19e8:	c3                   	ret    

000019e9 <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    19e9:	55                   	push   %ebp
    19ea:	89 e5                	mov    %esp,%ebp
    19ec:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    19ef:	8b 45 08             	mov    0x8(%ebp),%eax
    19f2:	8b 40 18             	mov    0x18(%eax),%eax
    19f5:	ff 75 2c             	pushl  0x2c(%ebp)
    19f8:	ff 75 28             	pushl  0x28(%ebp)
    19fb:	ff 75 24             	pushl  0x24(%ebp)
    19fe:	ff 75 20             	pushl  0x20(%ebp)
    1a01:	8b 55 08             	mov    0x8(%ebp),%edx
    1a04:	ff 72 10             	pushl  0x10(%edx)
    1a07:	ff 72 0c             	pushl  0xc(%edx)
    1a0a:	ff 75 1c             	pushl  0x1c(%ebp)
    1a0d:	ff 75 18             	pushl  0x18(%ebp)
    1a10:	ff 75 14             	pushl  0x14(%ebp)
    1a13:	ff 75 10             	pushl  0x10(%ebp)
    1a16:	ff 75 0c             	pushl  0xc(%ebp)
    1a19:	50                   	push   %eax
    1a1a:	e8 75 08 00 00       	call   2294 <drawTransparentBitmap>
    1a1f:	83 c4 30             	add    $0x30,%esp
    return 0;
    1a22:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1a27:	c9                   	leave  
    1a28:	c3                   	ret    

00001a29 <api_repaint>:

int api_repaint(Window* wnd)
{
    1a29:	55                   	push   %ebp
    1a2a:	89 e5                	mov    %esp,%ebp
    1a2c:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    1a2f:	8b 45 08             	mov    0x8(%ebp),%eax
    1a32:	8b 00                	mov    (%eax),%eax
    1a34:	83 ec 0c             	sub    $0xc,%esp
    1a37:	50                   	push   %eax
    1a38:	e8 4e f0 ff ff       	call   a8b <repaintwindow>
    1a3d:	83 c4 10             	add    $0x10,%esp
    return 0;
    1a40:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1a45:	c9                   	leave  
    1a46:	c3                   	ret    

00001a47 <api_update>:

int api_update(Window* wnd, Rect rect)
{
    1a47:	55                   	push   %ebp
    1a48:	89 e5                	mov    %esp,%ebp
    1a4a:	56                   	push   %esi
    1a4b:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    1a4c:	8b 75 18             	mov    0x18(%ebp),%esi
    1a4f:	8b 5d 14             	mov    0x14(%ebp),%ebx
    1a52:	8b 4d 10             	mov    0x10(%ebp),%ecx
    1a55:	8b 55 0c             	mov    0xc(%ebp),%edx
    1a58:	8b 45 08             	mov    0x8(%ebp),%eax
    1a5b:	8b 00                	mov    (%eax),%eax
    1a5d:	83 ec 0c             	sub    $0xc,%esp
    1a60:	56                   	push   %esi
    1a61:	53                   	push   %ebx
    1a62:	51                   	push   %ecx
    1a63:	52                   	push   %edx
    1a64:	50                   	push   %eax
    1a65:	e8 39 f0 ff ff       	call   aa3 <updatewindow>
    1a6a:	83 c4 20             	add    $0x20,%esp
    return 0;
    1a6d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1a72:	8d 65 f8             	lea    -0x8(%ebp),%esp
    1a75:	5b                   	pop    %ebx
    1a76:	5e                   	pop    %esi
    1a77:	5d                   	pop    %ebp
    1a78:	c3                   	ret    

00001a79 <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    1a79:	55                   	push   %ebp
    1a7a:	89 e5                	mov    %esp,%ebp
    1a7c:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    1a7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    1a86:	8b 45 08             	mov    0x8(%ebp),%eax
    1a89:	8b 00                	mov    (%eax),%eax
    1a8b:	83 ec 08             	sub    $0x8,%esp
    1a8e:	8d 55 c8             	lea    -0x38(%ebp),%edx
    1a91:	52                   	push   %edx
    1a92:	50                   	push   %eax
    1a93:	e8 fb ef ff ff       	call   a93 <getmessage>
    1a98:	83 c4 10             	add    $0x10,%esp
    1a9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    1a9e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1aa2:	74 e2                	je     1a86 <api_exec+0xd>
        {
            pf(&msg);
    1aa4:	83 ec 0c             	sub    $0xc,%esp
    1aa7:	8d 45 c8             	lea    -0x38(%ebp),%eax
    1aaa:	50                   	push   %eax
    1aab:	8b 45 0c             	mov    0xc(%ebp),%eax
    1aae:	ff d0                	call   *%eax
    1ab0:	83 c4 10             	add    $0x10,%esp
        }
    }
    1ab3:	eb d1                	jmp    1a86 <api_exec+0xd>

00001ab5 <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    1ab5:	55                   	push   %ebp
    1ab6:	89 e5                	mov    %esp,%ebp
    1ab8:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    1abb:	8b 45 08             	mov    0x8(%ebp),%eax
    1abe:	8b 00                	mov    (%eax),%eax
    1ac0:	83 ec 08             	sub    $0x8,%esp
    1ac3:	ff 75 0c             	pushl  0xc(%ebp)
    1ac6:	50                   	push   %eax
    1ac7:	e8 cf ef ff ff       	call   a9b <settimer>
    1acc:	83 c4 10             	add    $0x10,%esp
    return 0;
    1acf:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1ad4:	c9                   	leave  
    1ad5:	c3                   	ret    

00001ad6 <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    1ad6:	55                   	push   %ebp
    1ad7:	89 e5                	mov    %esp,%ebp
    1ad9:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    1adc:	8b 45 08             	mov    0x8(%ebp),%eax
    1adf:	8b 50 18             	mov    0x18(%eax),%edx
    1ae2:	ff 75 18             	pushl  0x18(%ebp)
    1ae5:	ff 75 14             	pushl  0x14(%ebp)
    1ae8:	83 ec 04             	sub    $0x4,%esp
    1aeb:	89 e0                	mov    %esp,%eax
    1aed:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    1af1:	66 89 08             	mov    %cx,(%eax)
    1af4:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    1af8:	88 48 02             	mov    %cl,0x2(%eax)
    1afb:	8b 45 08             	mov    0x8(%ebp),%eax
    1afe:	ff 70 10             	pushl  0x10(%eax)
    1b01:	ff 70 0c             	pushl  0xc(%eax)
    1b04:	ff 75 10             	pushl  0x10(%ebp)
    1b07:	ff 75 0c             	pushl  0xc(%ebp)
    1b0a:	52                   	push   %edx
    1b0b:	e8 6f 04 00 00       	call   1f7f <drawRect>
    1b10:	83 c4 20             	add    $0x20,%esp
    return 0;
    1b13:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1b18:	c9                   	leave  
    1b19:	c3                   	ret    

00001b1a <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    1b1a:	55                   	push   %ebp
    1b1b:	89 e5                	mov    %esp,%ebp
    1b1d:	83 ec 28             	sub    $0x28,%esp
    1b20:	8b 45 14             	mov    0x14(%ebp),%eax
    1b23:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    1b26:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    1b2a:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b2d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1b30:	8b 45 10             	mov    0x10(%ebp),%eax
    1b33:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1b36:	8b 45 08             	mov    0x8(%ebp),%eax
    1b39:	8b 40 18             	mov    0x18(%eax),%eax
    1b3c:	83 ec 04             	sub    $0x4,%esp
    1b3f:	ff 75 18             	pushl  0x18(%ebp)
    1b42:	52                   	push   %edx
    1b43:	8b 55 08             	mov    0x8(%ebp),%edx
    1b46:	ff 72 10             	pushl  0x10(%edx)
    1b49:	ff 72 0c             	pushl  0xc(%edx)
    1b4c:	ff 75 f4             	pushl  -0xc(%ebp)
    1b4f:	ff 75 f0             	pushl  -0x10(%ebp)
    1b52:	50                   	push   %eax
    1b53:	e8 d4 02 00 00       	call   1e2c <drawCharacter>
    1b58:	83 c4 20             	add    $0x20,%esp
    return 0;
    1b5b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1b60:	c9                   	leave  
    1b61:	c3                   	ret    

00001b62 <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    1b62:	55                   	push   %ebp
    1b63:	89 e5                	mov    %esp,%ebp
    1b65:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    1b68:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b6b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1b6e:	8b 45 10             	mov    0x10(%ebp),%eax
    1b71:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1b74:	8b 45 08             	mov    0x8(%ebp),%eax
    1b77:	8b 40 18             	mov    0x18(%eax),%eax
    1b7a:	83 ec 04             	sub    $0x4,%esp
    1b7d:	ff 75 18             	pushl  0x18(%ebp)
    1b80:	ff 75 14             	pushl  0x14(%ebp)
    1b83:	8b 55 08             	mov    0x8(%ebp),%edx
    1b86:	ff 72 10             	pushl  0x10(%edx)
    1b89:	ff 72 0c             	pushl  0xc(%edx)
    1b8c:	ff 75 f4             	pushl  -0xc(%ebp)
    1b8f:	ff 75 f0             	pushl  -0x10(%ebp)
    1b92:	50                   	push   %eax
    1b93:	e8 8e 03 00 00       	call   1f26 <drawString>
    1b98:	83 c4 20             	add    $0x20,%esp
    return 0;
    1b9b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1ba0:	c9                   	leave  
    1ba1:	c3                   	ret    

00001ba2 <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    1ba2:	55                   	push   %ebp
    1ba3:	89 e5                	mov    %esp,%ebp
    1ba5:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    1ba8:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    1bac:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    1bb0:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    1bb4:	83 ec 08             	sub    $0x8,%esp
    1bb7:	83 ec 04             	sub    $0x4,%esp
    1bba:	89 e0                	mov    %esp,%eax
    1bbc:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    1bc0:	66 89 10             	mov    %dx,(%eax)
    1bc3:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    1bc7:	88 50 02             	mov    %dl,0x2(%eax)
    1bca:	ff 75 18             	pushl  0x18(%ebp)
    1bcd:	ff 75 14             	pushl  0x14(%ebp)
    1bd0:	ff 75 10             	pushl  0x10(%ebp)
    1bd3:	ff 75 0c             	pushl  0xc(%ebp)
    1bd6:	ff 75 08             	pushl  0x8(%ebp)
    1bd9:	e8 f8 fe ff ff       	call   1ad6 <api_drawRect>
    1bde:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    1be1:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    1be5:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    1be9:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    1bed:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    1bf1:	8b 45 10             	mov    0x10(%ebp),%eax
    1bf4:	8d 50 0a             	lea    0xa(%eax),%edx
    1bf7:	8b 45 0c             	mov    0xc(%ebp),%eax
    1bfa:	83 c0 0a             	add    $0xa,%eax
    1bfd:	83 ec 0c             	sub    $0xc,%esp
    1c00:	ff 75 f4             	pushl  -0xc(%ebp)
    1c03:	ff 75 1c             	pushl  0x1c(%ebp)
    1c06:	52                   	push   %edx
    1c07:	50                   	push   %eax
    1c08:	ff 75 08             	pushl  0x8(%ebp)
    1c0b:	e8 52 ff ff ff       	call   1b62 <api_drawString>
    1c10:	83 c4 20             	add    $0x20,%esp
    return 0;
    1c13:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1c18:	c9                   	leave  
    1c19:	c3                   	ret    

00001c1a <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    1c1a:	55                   	push   %ebp
    1c1b:	89 e5                	mov    %esp,%ebp
    1c1d:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    1c20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1c27:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1c2e:	8b 45 08             	mov    0x8(%ebp),%eax
    1c31:	8b 40 18             	mov    0x18(%eax),%eax
    1c34:	ff 75 1c             	pushl  0x1c(%ebp)
    1c37:	ff 75 18             	pushl  0x18(%ebp)
    1c3a:	ff 75 1c             	pushl  0x1c(%ebp)
    1c3d:	ff 75 18             	pushl  0x18(%ebp)
    1c40:	8b 55 08             	mov    0x8(%ebp),%edx
    1c43:	ff 72 10             	pushl  0x10(%edx)
    1c46:	ff 72 0c             	pushl  0xc(%edx)
    1c49:	ff 75 f4             	pushl  -0xc(%ebp)
    1c4c:	ff 75 f0             	pushl  -0x10(%ebp)
    1c4f:	ff 75 14             	pushl  0x14(%ebp)
    1c52:	ff 75 10             	pushl  0x10(%ebp)
    1c55:	ff 75 0c             	pushl  0xc(%ebp)
    1c58:	50                   	push   %eax
    1c59:	e8 16 05 00 00       	call   2174 <drawBitmap>
    1c5e:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    1c61:	8b 45 08             	mov    0x8(%ebp),%eax
    1c64:	8b 40 18             	mov    0x18(%eax),%eax
    1c67:	ff 75 28             	pushl  0x28(%ebp)
    1c6a:	ff 75 1c             	pushl  0x1c(%ebp)
    1c6d:	ff 75 18             	pushl  0x18(%ebp)
    1c70:	8b 55 08             	mov    0x8(%ebp),%edx
    1c73:	ff 72 10             	pushl  0x10(%edx)
    1c76:	ff 72 0c             	pushl  0xc(%edx)
    1c79:	ff 75 14             	pushl  0x14(%ebp)
    1c7c:	ff 75 10             	pushl  0x10(%ebp)
    1c7f:	50                   	push   %eax
    1c80:	e8 99 07 00 00       	call   241e <colorShift>
    1c85:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    1c88:	8b 45 08             	mov    0x8(%ebp),%eax
    1c8b:	8b 50 18             	mov    0x18(%eax),%edx
    1c8e:	83 ec 0c             	sub    $0xc,%esp
    1c91:	ff 75 20             	pushl  0x20(%ebp)
    1c94:	ff 75 1c             	pushl  0x1c(%ebp)
    1c97:	ff 75 18             	pushl  0x18(%ebp)
    1c9a:	83 ec 04             	sub    $0x4,%esp
    1c9d:	89 e0                	mov    %esp,%eax
    1c9f:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    1ca3:	66 89 08             	mov    %cx,(%eax)
    1ca6:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    1caa:	88 48 02             	mov    %cl,0x2(%eax)
    1cad:	8b 45 08             	mov    0x8(%ebp),%eax
    1cb0:	ff 70 10             	pushl  0x10(%eax)
    1cb3:	ff 70 0c             	pushl  0xc(%eax)
    1cb6:	ff 75 14             	pushl  0x14(%ebp)
    1cb9:	ff 75 10             	pushl  0x10(%ebp)
    1cbc:	52                   	push   %edx
    1cbd:	e8 6d 03 00 00       	call   202f <drawBorder>
    1cc2:	83 c4 30             	add    $0x30,%esp
    return 0;
    1cc5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1cca:	c9                   	leave  
    1ccb:	c3                   	ret    

00001ccc <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    1ccc:	55                   	push   %ebp
    1ccd:	89 e5                	mov    %esp,%ebp
    1ccf:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    1cd2:	8b 45 08             	mov    0x8(%ebp),%eax
    1cd5:	8b 00                	mov    (%eax),%eax
    1cd7:	83 ec 0c             	sub    $0xc,%esp
    1cda:	50                   	push   %eax
    1cdb:	e8 cb ed ff ff       	call   aab <destroywindow>
    1ce0:	83 c4 10             	add    $0x10,%esp
    return 0;
    1ce3:	b8 00 00 00 00       	mov    $0x0,%eax
    1ce8:	c9                   	leave  
    1ce9:	c3                   	ret    

00001cea <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    1cea:	55                   	push   %ebp
    1ceb:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    1ced:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    1cf1:	8b 45 08             	mov    0x8(%ebp),%eax
    1cf4:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    1cf7:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    1cfb:	8b 45 08             	mov    0x8(%ebp),%eax
    1cfe:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    1d01:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    1d05:	8b 45 08             	mov    0x8(%ebp),%eax
    1d08:	88 10                	mov    %dl,(%eax)
}
    1d0a:	90                   	nop
    1d0b:	5d                   	pop    %ebp
    1d0c:	c3                   	ret    

00001d0d <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    1d0d:	55                   	push   %ebp
    1d0e:	89 e5                	mov    %esp,%ebp
    1d10:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    1d13:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1d17:	3c ff                	cmp    $0xff,%al
    1d19:	75 22                	jne    1d3d <drawPointAlpha+0x30>
        color->R = origin.R;
    1d1b:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    1d1f:	8b 45 08             	mov    0x8(%ebp),%eax
    1d22:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    1d25:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    1d29:	8b 45 08             	mov    0x8(%ebp),%eax
    1d2c:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    1d2f:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    1d33:	8b 45 08             	mov    0x8(%ebp),%eax
    1d36:	88 10                	mov    %dl,(%eax)
        return;
    1d38:	e9 ed 00 00 00       	jmp    1e2a <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    1d3d:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1d41:	84 c0                	test   %al,%al
    1d43:	0f 84 e0 00 00 00    	je     1e29 <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    1d49:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1d4d:	0f b6 c0             	movzbl %al,%eax
    1d50:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    1d54:	df 45 e4             	fild   -0x1c(%ebp)
    1d57:	d9 05 e0 a3 01 00    	flds   0x1a3e0
    1d5d:	de f9                	fdivrp %st,%st(1)
    1d5f:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    1d62:	8b 45 08             	mov    0x8(%ebp),%eax
    1d65:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1d69:	0f b6 c0             	movzbl %al,%eax
    1d6c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1d6f:	db 45 e4             	fildl  -0x1c(%ebp)
    1d72:	d9 e8                	fld1   
    1d74:	d8 65 fc             	fsubs  -0x4(%ebp)
    1d77:	de c9                	fmulp  %st,%st(1)
    1d79:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    1d7d:	0f b6 c0             	movzbl %al,%eax
    1d80:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1d83:	db 45 e4             	fildl  -0x1c(%ebp)
    1d86:	d8 4d fc             	fmuls  -0x4(%ebp)
    1d89:	de c1                	faddp  %st,%st(1)
    1d8b:	d9 7d ee             	fnstcw -0x12(%ebp)
    1d8e:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    1d92:	b4 0c                	mov    $0xc,%ah
    1d94:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    1d98:	d9 6d ec             	fldcw  -0x14(%ebp)
    1d9b:	df 5d ea             	fistp  -0x16(%ebp)
    1d9e:	d9 6d ee             	fldcw  -0x12(%ebp)
    1da1:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1da5:	89 c2                	mov    %eax,%edx
    1da7:	8b 45 08             	mov    0x8(%ebp),%eax
    1daa:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    1dad:	8b 45 08             	mov    0x8(%ebp),%eax
    1db0:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1db4:	0f b6 c0             	movzbl %al,%eax
    1db7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1dba:	db 45 e4             	fildl  -0x1c(%ebp)
    1dbd:	d9 e8                	fld1   
    1dbf:	d8 65 fc             	fsubs  -0x4(%ebp)
    1dc2:	de c9                	fmulp  %st,%st(1)
    1dc4:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    1dc8:	0f b6 c0             	movzbl %al,%eax
    1dcb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1dce:	db 45 e4             	fildl  -0x1c(%ebp)
    1dd1:	d8 4d fc             	fmuls  -0x4(%ebp)
    1dd4:	de c1                	faddp  %st,%st(1)
    1dd6:	d9 6d ec             	fldcw  -0x14(%ebp)
    1dd9:	df 5d ea             	fistp  -0x16(%ebp)
    1ddc:	d9 6d ee             	fldcw  -0x12(%ebp)
    1ddf:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1de3:	89 c2                	mov    %eax,%edx
    1de5:	8b 45 08             	mov    0x8(%ebp),%eax
    1de8:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    1deb:	8b 45 08             	mov    0x8(%ebp),%eax
    1dee:	0f b6 00             	movzbl (%eax),%eax
    1df1:	0f b6 c0             	movzbl %al,%eax
    1df4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1df7:	db 45 e4             	fildl  -0x1c(%ebp)
    1dfa:	d9 e8                	fld1   
    1dfc:	d8 65 fc             	fsubs  -0x4(%ebp)
    1dff:	de c9                	fmulp  %st,%st(1)
    1e01:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    1e05:	0f b6 c0             	movzbl %al,%eax
    1e08:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1e0b:	db 45 e4             	fildl  -0x1c(%ebp)
    1e0e:	d8 4d fc             	fmuls  -0x4(%ebp)
    1e11:	de c1                	faddp  %st,%st(1)
    1e13:	d9 6d ec             	fldcw  -0x14(%ebp)
    1e16:	df 5d ea             	fistp  -0x16(%ebp)
    1e19:	d9 6d ee             	fldcw  -0x12(%ebp)
    1e1c:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1e20:	89 c2                	mov    %eax,%edx
    1e22:	8b 45 08             	mov    0x8(%ebp),%eax
    1e25:	88 10                	mov    %dl,(%eax)
    1e27:	eb 01                	jmp    1e2a <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    1e29:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    1e2a:	c9                   	leave  
    1e2b:	c3                   	ret    

00001e2c <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    1e2c:	55                   	push   %ebp
    1e2d:	89 e5                	mov    %esp,%ebp
    1e2f:	83 ec 14             	sub    $0x14,%esp
    1e32:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1e35:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    1e38:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    1e3c:	83 e8 20             	sub    $0x20,%eax
    1e3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    1e42:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1e46:	0f 88 d7 00 00 00    	js     1f23 <drawCharacter+0xf7>
    1e4c:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    1e50:	0f 8f cd 00 00 00    	jg     1f23 <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1e56:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1e5d:	e9 b5 00 00 00       	jmp    1f17 <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    1e62:	8b 55 10             	mov    0x10(%ebp),%edx
    1e65:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1e68:	01 c2                	add    %eax,%edx
    1e6a:	8b 45 14             	mov    0x14(%ebp),%eax
    1e6d:	39 c2                	cmp    %eax,%edx
    1e6f:	0f 8f af 00 00 00    	jg     1f24 <drawCharacter+0xf8>
    1e75:	8b 55 10             	mov    0x10(%ebp),%edx
    1e78:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1e7b:	01 d0                	add    %edx,%eax
    1e7d:	85 c0                	test   %eax,%eax
    1e7f:	0f 88 9f 00 00 00    	js     1f24 <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1e85:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1e8c:	eb 7b                	jmp    1f09 <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    1e8e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1e91:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    1e94:	89 d0                	mov    %edx,%eax
    1e96:	c1 e0 03             	shl    $0x3,%eax
    1e99:	01 d0                	add    %edx,%eax
    1e9b:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    1ea1:	01 c2                	add    %eax,%edx
    1ea3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1ea6:	01 d0                	add    %edx,%eax
    1ea8:	05 c0 67 01 00       	add    $0x167c0,%eax
    1ead:	0f b6 00             	movzbl (%eax),%eax
    1eb0:	3c 01                	cmp    $0x1,%al
    1eb2:	75 51                	jne    1f05 <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    1eb4:	8b 55 0c             	mov    0xc(%ebp),%edx
    1eb7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1eba:	01 c2                	add    %eax,%edx
    1ebc:	8b 45 18             	mov    0x18(%ebp),%eax
    1ebf:	39 c2                	cmp    %eax,%edx
    1ec1:	7f 50                	jg     1f13 <drawCharacter+0xe7>
    1ec3:	8b 55 0c             	mov    0xc(%ebp),%edx
    1ec6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1ec9:	01 d0                	add    %edx,%eax
    1ecb:	85 c0                	test   %eax,%eax
    1ecd:	78 44                	js     1f13 <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    1ecf:	8b 55 10             	mov    0x10(%ebp),%edx
    1ed2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1ed5:	01 c2                	add    %eax,%edx
    1ed7:	8b 45 18             	mov    0x18(%ebp),%eax
    1eda:	0f af c2             	imul   %edx,%eax
    1edd:	89 c2                	mov    %eax,%edx
    1edf:	8b 45 0c             	mov    0xc(%ebp),%eax
    1ee2:	01 c2                	add    %eax,%edx
    1ee4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1ee7:	01 c2                	add    %eax,%edx
    1ee9:	89 d0                	mov    %edx,%eax
    1eeb:	01 c0                	add    %eax,%eax
    1eed:	01 c2                	add    %eax,%edx
    1eef:	8b 45 08             	mov    0x8(%ebp),%eax
    1ef2:	01 d0                	add    %edx,%eax
    1ef4:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    1ef7:	ff 75 20             	pushl  0x20(%ebp)
    1efa:	ff 75 f0             	pushl  -0x10(%ebp)
    1efd:	e8 0b fe ff ff       	call   1d0d <drawPointAlpha>
    1f02:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1f05:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    1f09:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    1f0d:	0f 8e 7b ff ff ff    	jle    1e8e <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1f13:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    1f17:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    1f1b:	0f 8e 41 ff ff ff    	jle    1e62 <drawCharacter+0x36>
    1f21:	eb 01                	jmp    1f24 <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    1f23:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    1f24:	c9                   	leave  
    1f25:	c3                   	ret    

00001f26 <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    1f26:	55                   	push   %ebp
    1f27:	89 e5                	mov    %esp,%ebp
    1f29:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    1f2c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    1f33:	eb 3d                	jmp    1f72 <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    1f35:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1f38:	0f b6 00             	movzbl (%eax),%eax
    1f3b:	0f be c0             	movsbl %al,%eax
    1f3e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1f41:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1f44:	01 ca                	add    %ecx,%edx
    1f46:	89 55 f4             	mov    %edx,-0xc(%ebp)
    1f49:	8b 55 10             	mov    0x10(%ebp),%edx
    1f4c:	89 55 f8             	mov    %edx,-0x8(%ebp)
    1f4f:	ff 75 20             	pushl  0x20(%ebp)
    1f52:	50                   	push   %eax
    1f53:	ff 75 18             	pushl  0x18(%ebp)
    1f56:	ff 75 14             	pushl  0x14(%ebp)
    1f59:	ff 75 f8             	pushl  -0x8(%ebp)
    1f5c:	ff 75 f4             	pushl  -0xc(%ebp)
    1f5f:	ff 75 08             	pushl  0x8(%ebp)
    1f62:	e8 c5 fe ff ff       	call   1e2c <drawCharacter>
    1f67:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    1f6a:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    1f6e:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    1f72:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1f75:	0f b6 00             	movzbl (%eax),%eax
    1f78:	84 c0                	test   %al,%al
    1f7a:	75 b9                	jne    1f35 <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    1f7c:	90                   	nop
    1f7d:	c9                   	leave  
    1f7e:	c3                   	ret    

00001f7f <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    1f7f:	55                   	push   %ebp
    1f80:	89 e5                	mov    %esp,%ebp
    1f82:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1f85:	8b 45 20             	mov    0x20(%ebp),%eax
    1f88:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1f8b:	8b 45 24             	mov    0x24(%ebp),%eax
    1f8e:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1f91:	8b 55 14             	mov    0x14(%ebp),%edx
    1f94:	8b 45 10             	mov    0x10(%ebp),%eax
    1f97:	29 c2                	sub    %eax,%edx
    1f99:	89 d0                	mov    %edx,%eax
    1f9b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1f9e:	7d 0d                	jge    1fad <drawRect+0x2e>
        draw_h = s.h - p.y;
    1fa0:	8b 55 14             	mov    0x14(%ebp),%edx
    1fa3:	8b 45 10             	mov    0x10(%ebp),%eax
    1fa6:	29 c2                	sub    %eax,%edx
    1fa8:	89 d0                	mov    %edx,%eax
    1faa:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1fad:	8b 55 18             	mov    0x18(%ebp),%edx
    1fb0:	8b 45 0c             	mov    0xc(%ebp),%eax
    1fb3:	29 c2                	sub    %eax,%edx
    1fb5:	89 d0                	mov    %edx,%eax
    1fb7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1fba:	7d 0d                	jge    1fc9 <drawRect+0x4a>
        draw_w = s.w - p.x;
    1fbc:	8b 55 18             	mov    0x18(%ebp),%edx
    1fbf:	8b 45 0c             	mov    0xc(%ebp),%eax
    1fc2:	29 c2                	sub    %eax,%edx
    1fc4:	89 d0                	mov    %edx,%eax
    1fc6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1fc9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1fd0:	eb 52                	jmp    2024 <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    1fd2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1fd9:	eb 3d                	jmp    2018 <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    1fdb:	8b 55 10             	mov    0x10(%ebp),%edx
    1fde:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1fe1:	01 c2                	add    %eax,%edx
    1fe3:	8b 45 18             	mov    0x18(%ebp),%eax
    1fe6:	0f af c2             	imul   %edx,%eax
    1fe9:	89 c2                	mov    %eax,%edx
    1feb:	8b 45 0c             	mov    0xc(%ebp),%eax
    1fee:	01 c2                	add    %eax,%edx
    1ff0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1ff3:	01 c2                	add    %eax,%edx
    1ff5:	89 d0                	mov    %edx,%eax
    1ff7:	01 c0                	add    %eax,%eax
    1ff9:	01 c2                	add    %eax,%edx
    1ffb:	8b 45 08             	mov    0x8(%ebp),%eax
    1ffe:	01 d0                	add    %edx,%eax
    2000:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    2003:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2006:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    200a:	66 89 10             	mov    %dx,(%eax)
    200d:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    2011:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    2014:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2018:	8b 45 f0             	mov    -0x10(%ebp),%eax
    201b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    201e:	7c bb                	jl     1fdb <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    2020:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2024:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2027:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    202a:	7c a6                	jl     1fd2 <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    202c:	90                   	nop
    202d:	c9                   	leave  
    202e:	c3                   	ret    

0000202f <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    202f:	55                   	push   %ebp
    2030:	89 e5                	mov    %esp,%ebp
    2032:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    2035:	8b 45 28             	mov    0x28(%ebp),%eax
    2038:	89 45 c8             	mov    %eax,-0x38(%ebp)
    203b:	8b 45 24             	mov    0x24(%ebp),%eax
    203e:	89 45 cc             	mov    %eax,-0x34(%ebp)
    2041:	ff 75 cc             	pushl  -0x34(%ebp)
    2044:	ff 75 c8             	pushl  -0x38(%ebp)
    2047:	83 ec 04             	sub    $0x4,%esp
    204a:	89 e0                	mov    %esp,%eax
    204c:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    2050:	66 89 10             	mov    %dx,(%eax)
    2053:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    2057:	88 50 02             	mov    %dl,0x2(%eax)
    205a:	ff 75 18             	pushl  0x18(%ebp)
    205d:	ff 75 14             	pushl  0x14(%ebp)
    2060:	ff 75 10             	pushl  0x10(%ebp)
    2063:	ff 75 0c             	pushl  0xc(%ebp)
    2066:	ff 75 08             	pushl  0x8(%ebp)
    2069:	e8 11 ff ff ff       	call   1f7f <drawRect>
    206e:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    2071:	8b 45 28             	mov    0x28(%ebp),%eax
    2074:	89 45 d0             	mov    %eax,-0x30(%ebp)
    2077:	8b 45 24             	mov    0x24(%ebp),%eax
    207a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    207d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2080:	89 45 d8             	mov    %eax,-0x28(%ebp)
    2083:	8b 55 10             	mov    0x10(%ebp),%edx
    2086:	8b 45 20             	mov    0x20(%ebp),%eax
    2089:	01 d0                	add    %edx,%eax
    208b:	2b 45 28             	sub    0x28(%ebp),%eax
    208e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2091:	ff 75 d4             	pushl  -0x2c(%ebp)
    2094:	ff 75 d0             	pushl  -0x30(%ebp)
    2097:	83 ec 04             	sub    $0x4,%esp
    209a:	89 e0                	mov    %esp,%eax
    209c:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    20a0:	66 89 10             	mov    %dx,(%eax)
    20a3:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    20a7:	88 50 02             	mov    %dl,0x2(%eax)
    20aa:	ff 75 18             	pushl  0x18(%ebp)
    20ad:	ff 75 14             	pushl  0x14(%ebp)
    20b0:	ff 75 dc             	pushl  -0x24(%ebp)
    20b3:	ff 75 d8             	pushl  -0x28(%ebp)
    20b6:	ff 75 08             	pushl  0x8(%ebp)
    20b9:	e8 c1 fe ff ff       	call   1f7f <drawRect>
    20be:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    20c1:	8b 45 20             	mov    0x20(%ebp),%eax
    20c4:	8b 55 28             	mov    0x28(%ebp),%edx
    20c7:	01 d2                	add    %edx,%edx
    20c9:	29 d0                	sub    %edx,%eax
    20cb:	89 45 e0             	mov    %eax,-0x20(%ebp)
    20ce:	8b 45 28             	mov    0x28(%ebp),%eax
    20d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    20d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    20d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    20da:	8b 55 10             	mov    0x10(%ebp),%edx
    20dd:	8b 45 28             	mov    0x28(%ebp),%eax
    20e0:	01 d0                	add    %edx,%eax
    20e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    20e5:	ff 75 e4             	pushl  -0x1c(%ebp)
    20e8:	ff 75 e0             	pushl  -0x20(%ebp)
    20eb:	83 ec 04             	sub    $0x4,%esp
    20ee:	89 e0                	mov    %esp,%eax
    20f0:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    20f4:	66 89 10             	mov    %dx,(%eax)
    20f7:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    20fb:	88 50 02             	mov    %dl,0x2(%eax)
    20fe:	ff 75 18             	pushl  0x18(%ebp)
    2101:	ff 75 14             	pushl  0x14(%ebp)
    2104:	ff 75 ec             	pushl  -0x14(%ebp)
    2107:	ff 75 e8             	pushl  -0x18(%ebp)
    210a:	ff 75 08             	pushl  0x8(%ebp)
    210d:	e8 6d fe ff ff       	call   1f7f <drawRect>
    2112:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    2115:	8b 45 20             	mov    0x20(%ebp),%eax
    2118:	8b 55 28             	mov    0x28(%ebp),%edx
    211b:	01 d2                	add    %edx,%edx
    211d:	29 d0                	sub    %edx,%eax
    211f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    2122:	8b 45 28             	mov    0x28(%ebp),%eax
    2125:	89 45 f4             	mov    %eax,-0xc(%ebp)
    2128:	8b 55 0c             	mov    0xc(%ebp),%edx
    212b:	8b 45 24             	mov    0x24(%ebp),%eax
    212e:	01 d0                	add    %edx,%eax
    2130:	2b 45 28             	sub    0x28(%ebp),%eax
    2133:	89 45 f8             	mov    %eax,-0x8(%ebp)
    2136:	8b 55 10             	mov    0x10(%ebp),%edx
    2139:	8b 45 28             	mov    0x28(%ebp),%eax
    213c:	01 d0                	add    %edx,%eax
    213e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    2141:	ff 75 f4             	pushl  -0xc(%ebp)
    2144:	ff 75 f0             	pushl  -0x10(%ebp)
    2147:	83 ec 04             	sub    $0x4,%esp
    214a:	89 e0                	mov    %esp,%eax
    214c:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    2150:	66 89 10             	mov    %dx,(%eax)
    2153:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    2157:	88 50 02             	mov    %dl,0x2(%eax)
    215a:	ff 75 18             	pushl  0x18(%ebp)
    215d:	ff 75 14             	pushl  0x14(%ebp)
    2160:	ff 75 fc             	pushl  -0x4(%ebp)
    2163:	ff 75 f8             	pushl  -0x8(%ebp)
    2166:	ff 75 08             	pushl  0x8(%ebp)
    2169:	e8 11 fe ff ff       	call   1f7f <drawRect>
    216e:	83 c4 20             	add    $0x20,%esp
}
    2171:	90                   	nop
    2172:	c9                   	leave  
    2173:	c3                   	ret    

00002174 <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    2174:	55                   	push   %ebp
    2175:	89 e5                	mov    %esp,%ebp
    2177:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    217a:	8b 45 30             	mov    0x30(%ebp),%eax
    217d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    2180:	8b 45 34             	mov    0x34(%ebp),%eax
    2183:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    2186:	8b 55 20             	mov    0x20(%ebp),%edx
    2189:	8b 45 14             	mov    0x14(%ebp),%eax
    218c:	29 c2                	sub    %eax,%edx
    218e:	89 d0                	mov    %edx,%eax
    2190:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2193:	7d 0d                	jge    21a2 <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    2195:	8b 55 20             	mov    0x20(%ebp),%edx
    2198:	8b 45 14             	mov    0x14(%ebp),%eax
    219b:	29 c2                	sub    %eax,%edx
    219d:	89 d0                	mov    %edx,%eax
    219f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    21a2:	8b 55 28             	mov    0x28(%ebp),%edx
    21a5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    21a8:	29 c2                	sub    %eax,%edx
    21aa:	89 d0                	mov    %edx,%eax
    21ac:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    21af:	7d 0d                	jge    21be <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    21b1:	8b 55 28             	mov    0x28(%ebp),%edx
    21b4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    21b7:	29 c2                	sub    %eax,%edx
    21b9:	89 d0                	mov    %edx,%eax
    21bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    21be:	8b 55 24             	mov    0x24(%ebp),%edx
    21c1:	8b 45 10             	mov    0x10(%ebp),%eax
    21c4:	29 c2                	sub    %eax,%edx
    21c6:	89 d0                	mov    %edx,%eax
    21c8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    21cb:	7d 0d                	jge    21da <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    21cd:	8b 55 24             	mov    0x24(%ebp),%edx
    21d0:	8b 45 10             	mov    0x10(%ebp),%eax
    21d3:	29 c2                	sub    %eax,%edx
    21d5:	89 d0                	mov    %edx,%eax
    21d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    21da:	8b 55 2c             	mov    0x2c(%ebp),%edx
    21dd:	8b 45 18             	mov    0x18(%ebp),%eax
    21e0:	29 c2                	sub    %eax,%edx
    21e2:	89 d0                	mov    %edx,%eax
    21e4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    21e7:	7d 0d                	jge    21f6 <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    21e9:	8b 55 2c             	mov    0x2c(%ebp),%edx
    21ec:	8b 45 18             	mov    0x18(%ebp),%eax
    21ef:	29 c2                	sub    %eax,%edx
    21f1:	89 d0                	mov    %edx,%eax
    21f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    21f6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    21fd:	e9 83 00 00 00       	jmp    2285 <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    2202:	8b 55 14             	mov    0x14(%ebp),%edx
    2205:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2208:	01 d0                	add    %edx,%eax
    220a:	85 c0                	test   %eax,%eax
    220c:	78 72                	js     2280 <drawBitmap+0x10c>
    220e:	8b 55 14             	mov    0x14(%ebp),%edx
    2211:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2214:	01 c2                	add    %eax,%edx
    2216:	8b 45 20             	mov    0x20(%ebp),%eax
    2219:	39 c2                	cmp    %eax,%edx
    221b:	7d 63                	jge    2280 <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    221d:	8b 55 14             	mov    0x14(%ebp),%edx
    2220:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2223:	01 c2                	add    %eax,%edx
    2225:	8b 45 24             	mov    0x24(%ebp),%eax
    2228:	0f af c2             	imul   %edx,%eax
    222b:	89 c2                	mov    %eax,%edx
    222d:	8b 45 10             	mov    0x10(%ebp),%eax
    2230:	01 c2                	add    %eax,%edx
    2232:	89 d0                	mov    %edx,%eax
    2234:	01 c0                	add    %eax,%eax
    2236:	01 c2                	add    %eax,%edx
    2238:	8b 45 08             	mov    0x8(%ebp),%eax
    223b:	01 d0                	add    %edx,%eax
    223d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    2240:	8b 55 1c             	mov    0x1c(%ebp),%edx
    2243:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2246:	01 c2                	add    %eax,%edx
    2248:	8b 45 2c             	mov    0x2c(%ebp),%eax
    224b:	0f af c2             	imul   %edx,%eax
    224e:	89 c2                	mov    %eax,%edx
    2250:	8b 45 18             	mov    0x18(%ebp),%eax
    2253:	01 c2                	add    %eax,%edx
    2255:	89 d0                	mov    %edx,%eax
    2257:	01 c0                	add    %eax,%eax
    2259:	01 c2                	add    %eax,%edx
    225b:	8b 45 0c             	mov    0xc(%ebp),%eax
    225e:	01 d0                	add    %edx,%eax
    2260:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    2263:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2266:	89 d0                	mov    %edx,%eax
    2268:	01 c0                	add    %eax,%eax
    226a:	01 d0                	add    %edx,%eax
    226c:	83 ec 04             	sub    $0x4,%esp
    226f:	50                   	push   %eax
    2270:	ff 75 e4             	pushl  -0x1c(%ebp)
    2273:	ff 75 e8             	pushl  -0x18(%ebp)
    2276:	e8 23 e7 ff ff       	call   99e <memmove>
    227b:	83 c4 10             	add    $0x10,%esp
    227e:	eb 01                	jmp    2281 <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    2280:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    2281:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    2285:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2288:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    228b:	0f 8c 71 ff ff ff    	jl     2202 <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    2291:	90                   	nop
    2292:	c9                   	leave  
    2293:	c3                   	ret    

00002294 <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    2294:	55                   	push   %ebp
    2295:	89 e5                	mov    %esp,%ebp
    2297:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    229a:	8b 45 30             	mov    0x30(%ebp),%eax
    229d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    22a0:	8b 45 34             	mov    0x34(%ebp),%eax
    22a3:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    22a6:	8b 55 20             	mov    0x20(%ebp),%edx
    22a9:	8b 45 14             	mov    0x14(%ebp),%eax
    22ac:	29 c2                	sub    %eax,%edx
    22ae:	89 d0                	mov    %edx,%eax
    22b0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    22b3:	7d 0d                	jge    22c2 <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    22b5:	8b 55 20             	mov    0x20(%ebp),%edx
    22b8:	8b 45 14             	mov    0x14(%ebp),%eax
    22bb:	29 c2                	sub    %eax,%edx
    22bd:	89 d0                	mov    %edx,%eax
    22bf:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    22c2:	8b 55 28             	mov    0x28(%ebp),%edx
    22c5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    22c8:	29 c2                	sub    %eax,%edx
    22ca:	89 d0                	mov    %edx,%eax
    22cc:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    22cf:	7d 0d                	jge    22de <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    22d1:	8b 55 28             	mov    0x28(%ebp),%edx
    22d4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    22d7:	29 c2                	sub    %eax,%edx
    22d9:	89 d0                	mov    %edx,%eax
    22db:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    22de:	8b 55 24             	mov    0x24(%ebp),%edx
    22e1:	8b 45 10             	mov    0x10(%ebp),%eax
    22e4:	29 c2                	sub    %eax,%edx
    22e6:	89 d0                	mov    %edx,%eax
    22e8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    22eb:	7d 0d                	jge    22fa <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    22ed:	8b 55 24             	mov    0x24(%ebp),%edx
    22f0:	8b 45 10             	mov    0x10(%ebp),%eax
    22f3:	29 c2                	sub    %eax,%edx
    22f5:	89 d0                	mov    %edx,%eax
    22f7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    22fa:	8b 55 2c             	mov    0x2c(%ebp),%edx
    22fd:	8b 45 18             	mov    0x18(%ebp),%eax
    2300:	29 c2                	sub    %eax,%edx
    2302:	89 d0                	mov    %edx,%eax
    2304:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2307:	7d 0d                	jge    2316 <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    2309:	8b 55 2c             	mov    0x2c(%ebp),%edx
    230c:	8b 45 18             	mov    0x18(%ebp),%eax
    230f:	29 c2                	sub    %eax,%edx
    2311:	89 d0                	mov    %edx,%eax
    2313:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    2316:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    231d:	e9 b8 00 00 00       	jmp    23da <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    2322:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2329:	e9 9c 00 00 00       	jmp    23ca <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    232e:	8b 55 14             	mov    0x14(%ebp),%edx
    2331:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2334:	01 c2                	add    %eax,%edx
    2336:	8b 45 24             	mov    0x24(%ebp),%eax
    2339:	0f af c2             	imul   %edx,%eax
    233c:	89 c2                	mov    %eax,%edx
    233e:	8b 45 10             	mov    0x10(%ebp),%eax
    2341:	01 c2                	add    %eax,%edx
    2343:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2346:	01 c2                	add    %eax,%edx
    2348:	89 d0                	mov    %edx,%eax
    234a:	01 c0                	add    %eax,%eax
    234c:	01 c2                	add    %eax,%edx
    234e:	8b 45 08             	mov    0x8(%ebp),%eax
    2351:	01 d0                	add    %edx,%eax
    2353:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    2356:	8b 55 1c             	mov    0x1c(%ebp),%edx
    2359:	8b 45 f4             	mov    -0xc(%ebp),%eax
    235c:	01 c2                	add    %eax,%edx
    235e:	8b 45 2c             	mov    0x2c(%ebp),%eax
    2361:	0f af c2             	imul   %edx,%eax
    2364:	89 c2                	mov    %eax,%edx
    2366:	8b 45 18             	mov    0x18(%ebp),%eax
    2369:	01 c2                	add    %eax,%edx
    236b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    236e:	01 c2                	add    %eax,%edx
    2370:	89 d0                	mov    %edx,%eax
    2372:	01 c0                	add    %eax,%eax
    2374:	01 c2                	add    %eax,%edx
    2376:	8b 45 0c             	mov    0xc(%ebp),%eax
    2379:	01 d0                	add    %edx,%eax
    237b:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    237e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2381:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2385:	3c ff                	cmp    $0xff,%al
    2387:	75 15                	jne    239e <drawTransparentBitmap+0x10a>
    2389:	8b 45 e8             	mov    -0x18(%ebp),%eax
    238c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2390:	3c ff                	cmp    $0xff,%al
    2392:	75 0a                	jne    239e <drawTransparentBitmap+0x10a>
    2394:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2397:	0f b6 00             	movzbl (%eax),%eax
    239a:	3c ff                	cmp    $0xff,%al
    239c:	74 27                	je     23c5 <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    239e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    23a1:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    23a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    23a8:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    23ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    23ae:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    23b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    23b5:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    23b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    23bb:	0f b6 10             	movzbl (%eax),%edx
    23be:	8b 45 ec             	mov    -0x14(%ebp),%eax
    23c1:	88 10                	mov    %dl,(%eax)
    23c3:	eb 01                	jmp    23c6 <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    23c5:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    23c6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    23ca:	8b 45 34             	mov    0x34(%ebp),%eax
    23cd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    23d0:	0f 8f 58 ff ff ff    	jg     232e <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    23d6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    23da:	8b 45 30             	mov    0x30(%ebp),%eax
    23dd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    23e0:	0f 8f 3c ff ff ff    	jg     2322 <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    23e6:	90                   	nop
    23e7:	c9                   	leave  
    23e8:	c3                   	ret    

000023e9 <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    23e9:	55                   	push   %ebp
    23ea:	89 e5                	mov    %esp,%ebp
    23ec:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    23ef:	ff 75 24             	pushl  0x24(%ebp)
    23f2:	ff 75 20             	pushl  0x20(%ebp)
    23f5:	ff 75 1c             	pushl  0x1c(%ebp)
    23f8:	ff 75 18             	pushl  0x18(%ebp)
    23fb:	ff 75 1c             	pushl  0x1c(%ebp)
    23fe:	ff 75 18             	pushl  0x18(%ebp)
    2401:	ff 75 14             	pushl  0x14(%ebp)
    2404:	ff 75 10             	pushl  0x10(%ebp)
    2407:	ff 75 14             	pushl  0x14(%ebp)
    240a:	ff 75 10             	pushl  0x10(%ebp)
    240d:	ff 75 0c             	pushl  0xc(%ebp)
    2410:	ff 75 08             	pushl  0x8(%ebp)
    2413:	e8 5c fd ff ff       	call   2174 <drawBitmap>
    2418:	83 c4 30             	add    $0x30,%esp
}
    241b:	90                   	nop
    241c:	c9                   	leave  
    241d:	c3                   	ret    

0000241e <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    241e:	55                   	push   %ebp
    241f:	89 e5                	mov    %esp,%ebp
    2421:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    2424:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2427:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    242a:	8b 45 20             	mov    0x20(%ebp),%eax
    242d:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    2430:	8b 55 14             	mov    0x14(%ebp),%edx
    2433:	8b 45 10             	mov    0x10(%ebp),%eax
    2436:	29 c2                	sub    %eax,%edx
    2438:	89 d0                	mov    %edx,%eax
    243a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    243d:	7d 0d                	jge    244c <colorShift+0x2e>
        draw_h = s.h - p.y;
    243f:	8b 55 14             	mov    0x14(%ebp),%edx
    2442:	8b 45 10             	mov    0x10(%ebp),%eax
    2445:	29 c2                	sub    %eax,%edx
    2447:	89 d0                	mov    %edx,%eax
    2449:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    244c:	8b 55 18             	mov    0x18(%ebp),%edx
    244f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2452:	29 c2                	sub    %eax,%edx
    2454:	89 d0                	mov    %edx,%eax
    2456:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2459:	7d 0d                	jge    2468 <colorShift+0x4a>
        draw_w = s.w - p.x;
    245b:	8b 55 18             	mov    0x18(%ebp),%edx
    245e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2461:	29 c2                	sub    %eax,%edx
    2463:	89 d0                	mov    %edx,%eax
    2465:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    2468:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    246f:	e9 fc 00 00 00       	jmp    2570 <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    2474:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    247b:	e9 e0 00 00 00       	jmp    2560 <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    2480:	8b 55 10             	mov    0x10(%ebp),%edx
    2483:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2486:	01 c2                	add    %eax,%edx
    2488:	8b 45 18             	mov    0x18(%ebp),%eax
    248b:	0f af c2             	imul   %edx,%eax
    248e:	89 c2                	mov    %eax,%edx
    2490:	8b 45 0c             	mov    0xc(%ebp),%eax
    2493:	01 c2                	add    %eax,%edx
    2495:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2498:	01 c2                	add    %eax,%edx
    249a:	89 d0                	mov    %edx,%eax
    249c:	01 c0                	add    %eax,%eax
    249e:	01 c2                	add    %eax,%edx
    24a0:	8b 45 08             	mov    0x8(%ebp),%eax
    24a3:	01 d0                	add    %edx,%eax
    24a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    24a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24ab:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    24af:	3c c8                	cmp    $0xc8,%al
    24b1:	0f 86 a5 00 00 00    	jbe    255c <colorShift+0x13e>
    24b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24ba:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    24be:	3c c8                	cmp    $0xc8,%al
    24c0:	0f 86 96 00 00 00    	jbe    255c <colorShift+0x13e>
    24c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24c9:	0f b6 00             	movzbl (%eax),%eax
    24cc:	3c c8                	cmp    $0xc8,%al
    24ce:	0f 86 88 00 00 00    	jbe    255c <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    24d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24d7:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    24db:	0f b6 d0             	movzbl %al,%edx
    24de:	8b 45 24             	mov    0x24(%ebp),%eax
    24e1:	01 d0                	add    %edx,%eax
    24e3:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    24e9:	89 d0                	mov    %edx,%eax
    24eb:	c1 f8 1f             	sar    $0x1f,%eax
    24ee:	c1 e8 18             	shr    $0x18,%eax
    24f1:	01 c2                	add    %eax,%edx
    24f3:	0f b6 d2             	movzbl %dl,%edx
    24f6:	29 c2                	sub    %eax,%edx
    24f8:	89 d0                	mov    %edx,%eax
    24fa:	89 c2                	mov    %eax,%edx
    24fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24ff:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    2502:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2505:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2509:	0f b6 d0             	movzbl %al,%edx
    250c:	8b 45 24             	mov    0x24(%ebp),%eax
    250f:	01 d0                	add    %edx,%eax
    2511:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    2517:	89 d0                	mov    %edx,%eax
    2519:	c1 f8 1f             	sar    $0x1f,%eax
    251c:	c1 e8 18             	shr    $0x18,%eax
    251f:	01 c2                	add    %eax,%edx
    2521:	0f b6 d2             	movzbl %dl,%edx
    2524:	29 c2                	sub    %eax,%edx
    2526:	89 d0                	mov    %edx,%eax
    2528:	89 c2                	mov    %eax,%edx
    252a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    252d:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    2530:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2533:	0f b6 00             	movzbl (%eax),%eax
    2536:	0f b6 d0             	movzbl %al,%edx
    2539:	8b 45 24             	mov    0x24(%ebp),%eax
    253c:	01 d0                	add    %edx,%eax
    253e:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    2544:	89 d0                	mov    %edx,%eax
    2546:	c1 f8 1f             	sar    $0x1f,%eax
    2549:	c1 e8 18             	shr    $0x18,%eax
    254c:	01 c2                	add    %eax,%edx
    254e:	0f b6 d2             	movzbl %dl,%edx
    2551:	29 c2                	sub    %eax,%edx
    2553:	89 d0                	mov    %edx,%eax
    2555:	89 c2                	mov    %eax,%edx
    2557:	8b 45 ec             	mov    -0x14(%ebp),%eax
    255a:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    255c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2560:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2563:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2566:	0f 8c 14 ff ff ff    	jl     2480 <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    256c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2570:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2573:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2576:	0f 8c f8 fe ff ff    	jl     2474 <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    257c:	90                   	nop
    257d:	c9                   	leave  
    257e:	c3                   	ret    

0000257f <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    257f:	55                   	push   %ebp
    2580:	89 e5                	mov    %esp,%ebp
    2582:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    2585:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    258c:	e9 fb 00 00 00       	jmp    268c <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    2591:	8b 55 14             	mov    0x14(%ebp),%edx
    2594:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2597:	01 c2                	add    %eax,%edx
    2599:	0f b7 05 e2 ec 01 00 	movzwl 0x1ece2,%eax
    25a0:	0f b7 c0             	movzwl %ax,%eax
    25a3:	39 c2                	cmp    %eax,%edx
    25a5:	0f 8f eb 00 00 00    	jg     2696 <drawMouse+0x117>
    25ab:	8b 55 14             	mov    0x14(%ebp),%edx
    25ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
    25b1:	01 d0                	add    %edx,%eax
    25b3:	85 c0                	test   %eax,%eax
    25b5:	0f 88 db 00 00 00    	js     2696 <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    25bb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    25c2:	e9 b7 00 00 00       	jmp    267e <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    25c7:	8b 55 10             	mov    0x10(%ebp),%edx
    25ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    25cd:	01 c2                	add    %eax,%edx
    25cf:	0f b7 05 e0 ec 01 00 	movzwl 0x1ece0,%eax
    25d6:	0f b7 c0             	movzwl %ax,%eax
    25d9:	39 c2                	cmp    %eax,%edx
    25db:	0f 8f a7 00 00 00    	jg     2688 <drawMouse+0x109>
    25e1:	8b 55 10             	mov    0x10(%ebp),%edx
    25e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    25e7:	01 d0                	add    %edx,%eax
    25e9:	85 c0                	test   %eax,%eax
    25eb:	0f 88 97 00 00 00    	js     2688 <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    25f1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    25f4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    25f7:	89 d0                	mov    %edx,%eax
    25f9:	c1 e0 04             	shl    $0x4,%eax
    25fc:	29 d0                	sub    %edx,%eax
    25fe:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    2604:	01 c2                	add    %eax,%edx
    2606:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2609:	01 d0                	add    %edx,%eax
    260b:	05 a0 65 01 00       	add    $0x165a0,%eax
    2610:	0f b6 00             	movzbl (%eax),%eax
    2613:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    2616:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    261a:	74 5e                	je     267a <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    261c:	8b 55 14             	mov    0x14(%ebp),%edx
    261f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2622:	01 c2                	add    %eax,%edx
    2624:	0f b7 05 e0 ec 01 00 	movzwl 0x1ece0,%eax
    262b:	0f b7 c0             	movzwl %ax,%eax
    262e:	0f af c2             	imul   %edx,%eax
    2631:	89 c2                	mov    %eax,%edx
    2633:	8b 45 10             	mov    0x10(%ebp),%eax
    2636:	01 c2                	add    %eax,%edx
    2638:	8b 45 f8             	mov    -0x8(%ebp),%eax
    263b:	01 c2                	add    %eax,%edx
    263d:	89 d0                	mov    %edx,%eax
    263f:	01 c0                	add    %eax,%eax
    2641:	01 c2                	add    %eax,%edx
    2643:	8b 45 08             	mov    0x8(%ebp),%eax
    2646:	01 d0                	add    %edx,%eax
    2648:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    264b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    264f:	8d 50 ff             	lea    -0x1(%eax),%edx
    2652:	89 d0                	mov    %edx,%eax
    2654:	01 c0                	add    %eax,%eax
    2656:	01 d0                	add    %edx,%eax
    2658:	05 68 ed 01 00       	add    $0x1ed68,%eax
    265d:	83 ec 04             	sub    $0x4,%esp
    2660:	89 e2                	mov    %esp,%edx
    2662:	0f b7 08             	movzwl (%eax),%ecx
    2665:	66 89 0a             	mov    %cx,(%edx)
    2668:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    266c:	88 42 02             	mov    %al,0x2(%edx)
    266f:	ff 75 f0             	pushl  -0x10(%ebp)
    2672:	e8 73 f6 ff ff       	call   1cea <drawPoint>
    2677:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    267a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    267e:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    2682:	0f 8e 3f ff ff ff    	jle    25c7 <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    2688:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    268c:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    2690:	0f 8e fb fe ff ff    	jle    2591 <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    2696:	90                   	nop
    2697:	c9                   	leave  
    2698:	c3                   	ret    

00002699 <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    2699:	55                   	push   %ebp
    269a:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    269c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    26a0:	78 1b                	js     26bd <getColor+0x24>
    26a2:	8b 45 08             	mov    0x8(%ebp),%eax
    26a5:	8b 40 04             	mov    0x4(%eax),%eax
    26a8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    26ab:	7c 10                	jl     26bd <getColor+0x24>
    26ad:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    26b1:	78 0a                	js     26bd <getColor+0x24>
    26b3:	8b 45 08             	mov    0x8(%ebp),%eax
    26b6:	8b 00                	mov    (%eax),%eax
    26b8:	3b 45 10             	cmp    0x10(%ebp),%eax
    26bb:	7d 10                	jge    26cd <getColor+0x34>
    {
        *isInPic = 1;
    26bd:	8b 45 14             	mov    0x14(%ebp),%eax
    26c0:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    26c6:	b8 71 e8 01 00       	mov    $0x1e871,%eax
    26cb:	eb 44                	jmp    2711 <getColor+0x78>
    }

    if (y == pic->height)
    26cd:	8b 45 08             	mov    0x8(%ebp),%eax
    26d0:	8b 40 04             	mov    0x4(%eax),%eax
    26d3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    26d6:	75 04                	jne    26dc <getColor+0x43>
        y--;
    26d8:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    26dc:	8b 45 08             	mov    0x8(%ebp),%eax
    26df:	8b 00                	mov    (%eax),%eax
    26e1:	3b 45 10             	cmp    0x10(%ebp),%eax
    26e4:	75 04                	jne    26ea <getColor+0x51>
        x--;
    26e6:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    26ea:	8b 45 14             	mov    0x14(%ebp),%eax
    26ed:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    26f3:	8b 45 08             	mov    0x8(%ebp),%eax
    26f6:	8b 48 08             	mov    0x8(%eax),%ecx
    26f9:	8b 45 08             	mov    0x8(%ebp),%eax
    26fc:	8b 00                	mov    (%eax),%eax
    26fe:	0f af 45 0c          	imul   0xc(%ebp),%eax
    2702:	89 c2                	mov    %eax,%edx
    2704:	8b 45 10             	mov    0x10(%ebp),%eax
    2707:	01 c2                	add    %eax,%edx
    2709:	89 d0                	mov    %edx,%eax
    270b:	01 c0                	add    %eax,%eax
    270d:	01 d0                	add    %edx,%eax
    270f:	01 c8                	add    %ecx,%eax
}
    2711:	5d                   	pop    %ebp
    2712:	c3                   	ret    

00002713 <setColor>:

int setColor(RGB *src, RGB *dst)
{
    2713:	55                   	push   %ebp
    2714:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    2716:	8b 45 08             	mov    0x8(%ebp),%eax
    2719:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    271d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2720:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    2723:	8b 45 08             	mov    0x8(%ebp),%eax
    2726:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    272a:	8b 45 0c             	mov    0xc(%ebp),%eax
    272d:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    2730:	8b 45 08             	mov    0x8(%ebp),%eax
    2733:	0f b6 10             	movzbl (%eax),%edx
    2736:	8b 45 0c             	mov    0xc(%ebp),%eax
    2739:	88 10                	mov    %dl,(%eax)

    return 1;
    273b:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2740:	5d                   	pop    %ebp
    2741:	c3                   	ret    

00002742 <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    2742:	55                   	push   %ebp
    2743:	89 e5                	mov    %esp,%ebp
    2745:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    2748:	d9 45 10             	flds   0x10(%ebp)
    274b:	d9 7d be             	fnstcw -0x42(%ebp)
    274e:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    2752:	b4 0c                	mov    $0xc,%ah
    2754:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    2758:	d9 6d bc             	fldcw  -0x44(%ebp)
    275b:	db 5d fc             	fistpl -0x4(%ebp)
    275e:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    2761:	d9 45 0c             	flds   0xc(%ebp)
    2764:	d9 6d bc             	fldcw  -0x44(%ebp)
    2767:	db 5d f8             	fistpl -0x8(%ebp)
    276a:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    276d:	db 45 fc             	fildl  -0x4(%ebp)
    2770:	d9 45 10             	flds   0x10(%ebp)
    2773:	d9 c9                	fxch   %st(1)
    2775:	df e9                	fucomip %st(1),%st
    2777:	dd d8                	fstp   %st(0)
    2779:	76 04                	jbe    277f <mixColor+0x3d>
        x--;
    277b:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    277f:	db 45 f8             	fildl  -0x8(%ebp)
    2782:	d9 45 0c             	flds   0xc(%ebp)
    2785:	d9 c9                	fxch   %st(1)
    2787:	df e9                	fucomip %st(1),%st
    2789:	dd d8                	fstp   %st(0)
    278b:	76 04                	jbe    2791 <mixColor+0x4f>
        y--;
    278d:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2791:	8d 45 c0             	lea    -0x40(%ebp),%eax
    2794:	50                   	push   %eax
    2795:	ff 75 fc             	pushl  -0x4(%ebp)
    2798:	ff 75 f8             	pushl  -0x8(%ebp)
    279b:	ff 75 08             	pushl  0x8(%ebp)
    279e:	e8 f6 fe ff ff       	call   2699 <getColor>
    27a3:	83 c4 10             	add    $0x10,%esp
    27a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    27a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    27ac:	83 c0 01             	add    $0x1,%eax
    27af:	8d 55 c0             	lea    -0x40(%ebp),%edx
    27b2:	83 c2 04             	add    $0x4,%edx
    27b5:	52                   	push   %edx
    27b6:	ff 75 fc             	pushl  -0x4(%ebp)
    27b9:	50                   	push   %eax
    27ba:	ff 75 08             	pushl  0x8(%ebp)
    27bd:	e8 d7 fe ff ff       	call   2699 <getColor>
    27c2:	83 c4 10             	add    $0x10,%esp
    27c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    27c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    27cb:	83 c0 01             	add    $0x1,%eax
    27ce:	8d 55 c0             	lea    -0x40(%ebp),%edx
    27d1:	83 c2 08             	add    $0x8,%edx
    27d4:	52                   	push   %edx
    27d5:	50                   	push   %eax
    27d6:	ff 75 f8             	pushl  -0x8(%ebp)
    27d9:	ff 75 08             	pushl  0x8(%ebp)
    27dc:	e8 b8 fe ff ff       	call   2699 <getColor>
    27e1:	83 c4 10             	add    $0x10,%esp
    27e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    27e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    27ea:	8d 50 01             	lea    0x1(%eax),%edx
    27ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
    27f0:	83 c0 01             	add    $0x1,%eax
    27f3:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    27f6:	83 c1 0c             	add    $0xc,%ecx
    27f9:	51                   	push   %ecx
    27fa:	52                   	push   %edx
    27fb:	50                   	push   %eax
    27fc:	ff 75 08             	pushl  0x8(%ebp)
    27ff:	e8 95 fe ff ff       	call   2699 <getColor>
    2804:	83 c4 10             	add    $0x10,%esp
    2807:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    280a:	db 45 fc             	fildl  -0x4(%ebp)
    280d:	d9 45 10             	flds   0x10(%ebp)
    2810:	de e1                	fsubp  %st,%st(1)
    2812:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    2815:	db 45 f8             	fildl  -0x8(%ebp)
    2818:	d9 45 0c             	flds   0xc(%ebp)
    281b:	de e1                	fsubp  %st,%st(1)
    281d:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    2820:	d9 45 e4             	flds   -0x1c(%ebp)
    2823:	d8 4d e0             	fmuls  -0x20(%ebp)
    2826:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    2829:	d9 e8                	fld1   
    282b:	d8 65 e0             	fsubs  -0x20(%ebp)
    282e:	d8 4d e4             	fmuls  -0x1c(%ebp)
    2831:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    2834:	d9 e8                	fld1   
    2836:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2839:	d8 4d e0             	fmuls  -0x20(%ebp)
    283c:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    283f:	d9 e8                	fld1   
    2841:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2844:	d9 e8                	fld1   
    2846:	d8 65 e0             	fsubs  -0x20(%ebp)
    2849:	de c9                	fmulp  %st,%st(1)
    284b:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    284e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2851:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2855:	0f b6 c0             	movzbl %al,%eax
    2858:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    285b:	db 45 b4             	fildl  -0x4c(%ebp)
    285e:	d8 4d d0             	fmuls  -0x30(%ebp)
    2861:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2864:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2867:	db 45 b4             	fildl  -0x4c(%ebp)
    286a:	de c9                	fmulp  %st,%st(1)
    286c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    286f:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2873:	0f b6 c0             	movzbl %al,%eax
    2876:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2879:	db 45 b4             	fildl  -0x4c(%ebp)
    287c:	d8 4d d4             	fmuls  -0x2c(%ebp)
    287f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2882:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2885:	db 45 b4             	fildl  -0x4c(%ebp)
    2888:	de c9                	fmulp  %st,%st(1)
    288a:	de c1                	faddp  %st,%st(1)
    288c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    288f:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2893:	0f b6 c0             	movzbl %al,%eax
    2896:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2899:	db 45 b4             	fildl  -0x4c(%ebp)
    289c:	d8 4d d8             	fmuls  -0x28(%ebp)
    289f:	8b 45 c8             	mov    -0x38(%ebp),%eax
    28a2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    28a5:	db 45 b4             	fildl  -0x4c(%ebp)
    28a8:	de c9                	fmulp  %st,%st(1)
    28aa:	de c1                	faddp  %st,%st(1)
    28ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
    28af:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    28b3:	0f b6 c0             	movzbl %al,%eax
    28b6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    28b9:	db 45 b4             	fildl  -0x4c(%ebp)
    28bc:	d8 4d dc             	fmuls  -0x24(%ebp)
    28bf:	8b 45 cc             	mov    -0x34(%ebp),%eax
    28c2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    28c5:	db 45 b4             	fildl  -0x4c(%ebp)
    28c8:	de c9                	fmulp  %st,%st(1)
    28ca:	de c1                	faddp  %st,%st(1)
    28cc:	d9 7d be             	fnstcw -0x42(%ebp)
    28cf:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    28d3:	b4 0c                	mov    $0xc,%ah
    28d5:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    28d9:	d9 6d bc             	fldcw  -0x44(%ebp)
    28dc:	db 5d b8             	fistpl -0x48(%ebp)
    28df:	d9 6d be             	fldcw  -0x42(%ebp)
    28e2:	8b 45 b8             	mov    -0x48(%ebp),%eax
    28e5:	89 c2                	mov    %eax,%edx
    28e7:	8b 45 14             	mov    0x14(%ebp),%eax
    28ea:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    28ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    28f0:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    28f4:	0f b6 c0             	movzbl %al,%eax
    28f7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    28fa:	db 45 b4             	fildl  -0x4c(%ebp)
    28fd:	d8 4d d0             	fmuls  -0x30(%ebp)
    2900:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2903:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2906:	db 45 b4             	fildl  -0x4c(%ebp)
    2909:	de c9                	fmulp  %st,%st(1)
    290b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    290e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2912:	0f b6 c0             	movzbl %al,%eax
    2915:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2918:	db 45 b4             	fildl  -0x4c(%ebp)
    291b:	d8 4d d4             	fmuls  -0x2c(%ebp)
    291e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2921:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2924:	db 45 b4             	fildl  -0x4c(%ebp)
    2927:	de c9                	fmulp  %st,%st(1)
    2929:	de c1                	faddp  %st,%st(1)
    292b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    292e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2932:	0f b6 c0             	movzbl %al,%eax
    2935:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2938:	db 45 b4             	fildl  -0x4c(%ebp)
    293b:	d8 4d d8             	fmuls  -0x28(%ebp)
    293e:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2941:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2944:	db 45 b4             	fildl  -0x4c(%ebp)
    2947:	de c9                	fmulp  %st,%st(1)
    2949:	de c1                	faddp  %st,%st(1)
    294b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    294e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2952:	0f b6 c0             	movzbl %al,%eax
    2955:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2958:	db 45 b4             	fildl  -0x4c(%ebp)
    295b:	d8 4d dc             	fmuls  -0x24(%ebp)
    295e:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2961:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2964:	db 45 b4             	fildl  -0x4c(%ebp)
    2967:	de c9                	fmulp  %st,%st(1)
    2969:	de c1                	faddp  %st,%st(1)
    296b:	d9 6d bc             	fldcw  -0x44(%ebp)
    296e:	db 5d b8             	fistpl -0x48(%ebp)
    2971:	d9 6d be             	fldcw  -0x42(%ebp)
    2974:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2977:	89 c2                	mov    %eax,%edx
    2979:	8b 45 14             	mov    0x14(%ebp),%eax
    297c:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    297f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2982:	0f b6 00             	movzbl (%eax),%eax
    2985:	0f b6 c0             	movzbl %al,%eax
    2988:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    298b:	db 45 b4             	fildl  -0x4c(%ebp)
    298e:	d8 4d d0             	fmuls  -0x30(%ebp)
    2991:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2994:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2997:	db 45 b4             	fildl  -0x4c(%ebp)
    299a:	de c9                	fmulp  %st,%st(1)
    299c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    299f:	0f b6 00             	movzbl (%eax),%eax
    29a2:	0f b6 c0             	movzbl %al,%eax
    29a5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    29a8:	db 45 b4             	fildl  -0x4c(%ebp)
    29ab:	d8 4d d4             	fmuls  -0x2c(%ebp)
    29ae:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    29b1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    29b4:	db 45 b4             	fildl  -0x4c(%ebp)
    29b7:	de c9                	fmulp  %st,%st(1)
    29b9:	de c1                	faddp  %st,%st(1)
    29bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    29be:	0f b6 00             	movzbl (%eax),%eax
    29c1:	0f b6 c0             	movzbl %al,%eax
    29c4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    29c7:	db 45 b4             	fildl  -0x4c(%ebp)
    29ca:	d8 4d d8             	fmuls  -0x28(%ebp)
    29cd:	8b 45 c8             	mov    -0x38(%ebp),%eax
    29d0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    29d3:	db 45 b4             	fildl  -0x4c(%ebp)
    29d6:	de c9                	fmulp  %st,%st(1)
    29d8:	de c1                	faddp  %st,%st(1)
    29da:	8b 45 e8             	mov    -0x18(%ebp),%eax
    29dd:	0f b6 00             	movzbl (%eax),%eax
    29e0:	0f b6 c0             	movzbl %al,%eax
    29e3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    29e6:	db 45 b4             	fildl  -0x4c(%ebp)
    29e9:	d8 4d dc             	fmuls  -0x24(%ebp)
    29ec:	8b 45 cc             	mov    -0x34(%ebp),%eax
    29ef:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    29f2:	db 45 b4             	fildl  -0x4c(%ebp)
    29f5:	de c9                	fmulp  %st,%st(1)
    29f7:	de c1                	faddp  %st,%st(1)
    29f9:	d9 6d bc             	fldcw  -0x44(%ebp)
    29fc:	db 5d b8             	fistpl -0x48(%ebp)
    29ff:	d9 6d be             	fldcw  -0x42(%ebp)
    2a02:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2a05:	89 c2                	mov    %eax,%edx
    2a07:	8b 45 14             	mov    0x14(%ebp),%eax
    2a0a:	88 10                	mov    %dl,(%eax)

    return 1;
    2a0c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2a11:	c9                   	leave  
    2a12:	c3                   	ret    

00002a13 <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    2a13:	55                   	push   %ebp
    2a14:	89 e5                	mov    %esp,%ebp
    2a16:	53                   	push   %ebx
    2a17:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    2a1a:	8b 45 10             	mov    0x10(%ebp),%eax
    2a1d:	c1 f8 10             	sar    $0x10,%eax
    2a20:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    2a23:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a26:	c1 f8 10             	sar    $0x10,%eax
    2a29:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2a2c:	8d 45 bc             	lea    -0x44(%ebp),%eax
    2a2f:	50                   	push   %eax
    2a30:	ff 75 f8             	pushl  -0x8(%ebp)
    2a33:	ff 75 f4             	pushl  -0xc(%ebp)
    2a36:	ff 75 08             	pushl  0x8(%ebp)
    2a39:	e8 5b fc ff ff       	call   2699 <getColor>
    2a3e:	83 c4 10             	add    $0x10,%esp
    2a41:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    2a44:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a47:	83 c0 01             	add    $0x1,%eax
    2a4a:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2a4d:	83 c2 04             	add    $0x4,%edx
    2a50:	52                   	push   %edx
    2a51:	ff 75 f8             	pushl  -0x8(%ebp)
    2a54:	50                   	push   %eax
    2a55:	ff 75 08             	pushl  0x8(%ebp)
    2a58:	e8 3c fc ff ff       	call   2699 <getColor>
    2a5d:	83 c4 10             	add    $0x10,%esp
    2a60:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    2a63:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a66:	83 c0 01             	add    $0x1,%eax
    2a69:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2a6c:	83 c2 08             	add    $0x8,%edx
    2a6f:	52                   	push   %edx
    2a70:	50                   	push   %eax
    2a71:	ff 75 f4             	pushl  -0xc(%ebp)
    2a74:	ff 75 08             	pushl  0x8(%ebp)
    2a77:	e8 1d fc ff ff       	call   2699 <getColor>
    2a7c:	83 c4 10             	add    $0x10,%esp
    2a7f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    2a82:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a85:	8d 50 01             	lea    0x1(%eax),%edx
    2a88:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a8b:	83 c0 01             	add    $0x1,%eax
    2a8e:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    2a91:	83 c1 0c             	add    $0xc,%ecx
    2a94:	51                   	push   %ecx
    2a95:	52                   	push   %edx
    2a96:	50                   	push   %eax
    2a97:	ff 75 08             	pushl  0x8(%ebp)
    2a9a:	e8 fa fb ff ff       	call   2699 <getColor>
    2a9f:	83 c4 10             	add    $0x10,%esp
    2aa2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    2aa5:	8b 45 10             	mov    0x10(%ebp),%eax
    2aa8:	0f b7 c0             	movzwl %ax,%eax
    2aab:	c1 f8 08             	sar    $0x8,%eax
    2aae:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    2ab1:	8b 45 0c             	mov    0xc(%ebp),%eax
    2ab4:	0f b7 c0             	movzwl %ax,%eax
    2ab7:	c1 f8 08             	sar    $0x8,%eax
    2aba:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    2abd:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2ac0:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    2ac4:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    2ac7:	b8 ff 00 00 00       	mov    $0xff,%eax
    2acc:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2acf:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    2ad3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    2ad6:	b8 ff 00 00 00       	mov    $0xff,%eax
    2adb:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2ade:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    2ae2:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    2ae5:	b8 ff 00 00 00       	mov    $0xff,%eax
    2aea:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2aed:	89 c2                	mov    %eax,%edx
    2aef:	b8 ff 00 00 00       	mov    $0xff,%eax
    2af4:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2af7:	0f af c2             	imul   %edx,%eax
    2afa:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    2afd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2b00:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2b04:	0f b6 c0             	movzbl %al,%eax
    2b07:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2b0b:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2b0e:	0f af d0             	imul   %eax,%edx
    2b11:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2b14:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2b18:	0f b6 c0             	movzbl %al,%eax
    2b1b:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2b1f:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2b22:	0f af c1             	imul   %ecx,%eax
    2b25:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2b28:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2b2b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2b2f:	0f b6 c0             	movzbl %al,%eax
    2b32:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2b36:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2b39:	0f af d0             	imul   %eax,%edx
    2b3c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2b3f:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2b43:	0f b6 c0             	movzbl %al,%eax
    2b46:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2b4a:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2b4d:	0f af c1             	imul   %ecx,%eax
    2b50:	01 d0                	add    %edx,%eax
    2b52:	01 d8                	add    %ebx,%eax
    2b54:	c1 e8 10             	shr    $0x10,%eax
    2b57:	89 c2                	mov    %eax,%edx
    2b59:	8b 45 14             	mov    0x14(%ebp),%eax
    2b5c:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    2b5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2b62:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2b66:	0f b6 c0             	movzbl %al,%eax
    2b69:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2b6d:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2b70:	0f af d0             	imul   %eax,%edx
    2b73:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2b76:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2b7a:	0f b6 c0             	movzbl %al,%eax
    2b7d:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2b81:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2b84:	0f af c1             	imul   %ecx,%eax
    2b87:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2b8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2b8d:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2b91:	0f b6 c0             	movzbl %al,%eax
    2b94:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2b98:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2b9b:	0f af d0             	imul   %eax,%edx
    2b9e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2ba1:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2ba5:	0f b6 c0             	movzbl %al,%eax
    2ba8:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2bac:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2baf:	0f af c1             	imul   %ecx,%eax
    2bb2:	01 d0                	add    %edx,%eax
    2bb4:	01 d8                	add    %ebx,%eax
    2bb6:	c1 e8 10             	shr    $0x10,%eax
    2bb9:	89 c2                	mov    %eax,%edx
    2bbb:	8b 45 14             	mov    0x14(%ebp),%eax
    2bbe:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    2bc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2bc4:	0f b6 00             	movzbl (%eax),%eax
    2bc7:	0f b6 c0             	movzbl %al,%eax
    2bca:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2bce:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2bd1:	0f af d0             	imul   %eax,%edx
    2bd4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2bd7:	0f b6 00             	movzbl (%eax),%eax
    2bda:	0f b6 c0             	movzbl %al,%eax
    2bdd:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2be1:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2be4:	0f af c1             	imul   %ecx,%eax
    2be7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2bea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2bed:	0f b6 00             	movzbl (%eax),%eax
    2bf0:	0f b6 c0             	movzbl %al,%eax
    2bf3:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2bf7:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2bfa:	0f af d0             	imul   %eax,%edx
    2bfd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2c00:	0f b6 00             	movzbl (%eax),%eax
    2c03:	0f b6 c0             	movzbl %al,%eax
    2c06:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2c0a:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2c0d:	0f af c1             	imul   %ecx,%eax
    2c10:	01 d0                	add    %edx,%eax
    2c12:	01 d8                	add    %ebx,%eax
    2c14:	c1 e8 10             	shr    $0x10,%eax
    2c17:	89 c2                	mov    %eax,%edx
    2c19:	8b 45 14             	mov    0x14(%ebp),%eax
    2c1c:	88 10                	mov    %dl,(%eax)
}
    2c1e:	90                   	nop
    2c1f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2c22:	c9                   	leave  
    2c23:	c3                   	ret    

00002c24 <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    2c24:	55                   	push   %ebp
    2c25:	89 e5                	mov    %esp,%ebp
    2c27:	53                   	push   %ebx
    2c28:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    2c2b:	8b 45 08             	mov    0x8(%ebp),%eax
    2c2e:	8b 00                	mov    (%eax),%eax
    2c30:	c1 e0 10             	shl    $0x10,%eax
    2c33:	89 c1                	mov    %eax,%ecx
    2c35:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c38:	8b 18                	mov    (%eax),%ebx
    2c3a:	89 c8                	mov    %ecx,%eax
    2c3c:	99                   	cltd   
    2c3d:	f7 fb                	idiv   %ebx
    2c3f:	83 c0 01             	add    $0x1,%eax
    2c42:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    2c45:	8b 45 08             	mov    0x8(%ebp),%eax
    2c48:	8b 40 04             	mov    0x4(%eax),%eax
    2c4b:	c1 e0 10             	shl    $0x10,%eax
    2c4e:	89 c1                	mov    %eax,%ecx
    2c50:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c53:	8b 58 04             	mov    0x4(%eax),%ebx
    2c56:	89 c8                	mov    %ecx,%eax
    2c58:	99                   	cltd   
    2c59:	f7 fb                	idiv   %ebx
    2c5b:	83 c0 01             	add    $0x1,%eax
    2c5e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    2c61:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2c64:	d1 f8                	sar    %eax
    2c66:	2d 00 80 00 00       	sub    $0x8000,%eax
    2c6b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    2c6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2c71:	d1 f8                	sar    %eax
    2c73:	2d 00 80 00 00       	sub    $0x8000,%eax
    2c78:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    2c7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2c7e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    2c81:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2c88:	eb 5d                	jmp    2ce7 <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    2c8a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2c8d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    2c90:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    2c97:	eb 3a                	jmp    2cd3 <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    2c99:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c9c:	8b 48 08             	mov    0x8(%eax),%ecx
    2c9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2ca2:	8b 00                	mov    (%eax),%eax
    2ca4:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2ca8:	89 c2                	mov    %eax,%edx
    2caa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2cad:	01 c2                	add    %eax,%edx
    2caf:	89 d0                	mov    %edx,%eax
    2cb1:	01 c0                	add    %eax,%eax
    2cb3:	01 d0                	add    %edx,%eax
    2cb5:	01 c8                	add    %ecx,%eax
    2cb7:	50                   	push   %eax
    2cb8:	ff 75 f0             	pushl  -0x10(%ebp)
    2cbb:	ff 75 f8             	pushl  -0x8(%ebp)
    2cbe:	ff 75 08             	pushl  0x8(%ebp)
    2cc1:	e8 4d fd ff ff       	call   2a13 <mixColorInt>
    2cc6:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    2cc9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2ccc:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    2ccf:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    2cd3:	8b 45 0c             	mov    0xc(%ebp),%eax
    2cd6:	8b 00                	mov    (%eax),%eax
    2cd8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2cdb:	7f bc                	jg     2c99 <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    2cdd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2ce0:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    2ce3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2ce7:	8b 45 0c             	mov    0xc(%ebp),%eax
    2cea:	8b 40 04             	mov    0x4(%eax),%eax
    2ced:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2cf0:	7f 98                	jg     2c8a <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    2cf2:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2cf7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2cfa:	c9                   	leave  
    2cfb:	c3                   	ret    

00002cfc <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    2cfc:	55                   	push   %ebp
    2cfd:	89 e5                	mov    %esp,%ebp
    2cff:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    2d02:	8b 45 08             	mov    0x8(%ebp),%eax
    2d05:	8b 00                	mov    (%eax),%eax
    2d07:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2d0a:	db 45 e4             	fildl  -0x1c(%ebp)
    2d0d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d10:	8b 00                	mov    (%eax),%eax
    2d12:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2d15:	db 45 e4             	fildl  -0x1c(%ebp)
    2d18:	de f9                	fdivrp %st,%st(1)
    2d1a:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    2d1d:	8b 45 08             	mov    0x8(%ebp),%eax
    2d20:	8b 40 04             	mov    0x4(%eax),%eax
    2d23:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2d26:	db 45 e4             	fildl  -0x1c(%ebp)
    2d29:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d2c:	8b 40 04             	mov    0x4(%eax),%eax
    2d2f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2d32:	db 45 e4             	fildl  -0x1c(%ebp)
    2d35:	de f9                	fdivrp %st,%st(1)
    2d37:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    2d3a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    2d41:	eb 5e                	jmp    2da1 <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    2d43:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2d4a:	eb 47                	jmp    2d93 <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    2d4c:	db 45 f8             	fildl  -0x8(%ebp)
    2d4f:	d8 4d f4             	fmuls  -0xc(%ebp)
    2d52:	d9 7d ee             	fnstcw -0x12(%ebp)
    2d55:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    2d59:	b4 0c                	mov    $0xc,%ah
    2d5b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    2d5f:	d9 6d ec             	fldcw  -0x14(%ebp)
    2d62:	db 5d e8             	fistpl -0x18(%ebp)
    2d65:	d9 6d ee             	fldcw  -0x12(%ebp)
    2d68:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2d6b:	db 45 fc             	fildl  -0x4(%ebp)
    2d6e:	d8 4d f0             	fmuls  -0x10(%ebp)
    2d71:	d9 6d ec             	fldcw  -0x14(%ebp)
    2d74:	db 5d e8             	fistpl -0x18(%ebp)
    2d77:	d9 6d ee             	fldcw  -0x12(%ebp)
    2d7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2d7d:	6a 00                	push   $0x0
    2d7f:	52                   	push   %edx
    2d80:	50                   	push   %eax
    2d81:	ff 75 08             	pushl  0x8(%ebp)
    2d84:	e8 10 f9 ff ff       	call   2699 <getColor>
    2d89:	83 c4 10             	add    $0x10,%esp
    2d8c:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    2d8f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2d93:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d96:	8b 00                	mov    (%eax),%eax
    2d98:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2d9b:	7f af                	jg     2d4c <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    2d9d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2da1:	8b 45 0c             	mov    0xc(%ebp),%eax
    2da4:	8b 40 04             	mov    0x4(%eax),%eax
    2da7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2daa:	7f 97                	jg     2d43 <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    2dac:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2db1:	c9                   	leave  
    2db2:	c3                   	ret    

00002db3 <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    2db3:	55                   	push   %ebp
    2db4:	89 e5                	mov    %esp,%ebp
    2db6:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    2db9:	8b 45 08             	mov    0x8(%ebp),%eax
    2dbc:	8b 00                	mov    (%eax),%eax
    2dbe:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2dc1:	db 45 e0             	fildl  -0x20(%ebp)
    2dc4:	d9 5d e0             	fstps  -0x20(%ebp)
    2dc7:	83 ec 0c             	sub    $0xc,%esp
    2dca:	ff 75 10             	pushl  0x10(%ebp)
    2dcd:	e8 6b e2 ff ff       	call   103d <cos>
    2dd2:	83 c4 10             	add    $0x10,%esp
    2dd5:	d9 5d dc             	fstps  -0x24(%ebp)
    2dd8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2ddb:	83 ec 0c             	sub    $0xc,%esp
    2dde:	50                   	push   %eax
    2ddf:	e8 90 e1 ff ff       	call   f74 <abs>
    2de4:	83 c4 10             	add    $0x10,%esp
    2de7:	d8 4d e0             	fmuls  -0x20(%ebp)
    2dea:	d9 5d e0             	fstps  -0x20(%ebp)
    2ded:	8b 45 0c             	mov    0xc(%ebp),%eax
    2df0:	8b 00                	mov    (%eax),%eax
    2df2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2df5:	db 45 dc             	fildl  -0x24(%ebp)
    2df8:	d9 5d dc             	fstps  -0x24(%ebp)
    2dfb:	83 ec 0c             	sub    $0xc,%esp
    2dfe:	ff 75 10             	pushl  0x10(%ebp)
    2e01:	e8 da e3 ff ff       	call   11e0 <sin>
    2e06:	83 c4 10             	add    $0x10,%esp
    2e09:	d9 5d d8             	fstps  -0x28(%ebp)
    2e0c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2e0f:	83 ec 0c             	sub    $0xc,%esp
    2e12:	50                   	push   %eax
    2e13:	e8 5c e1 ff ff       	call   f74 <abs>
    2e18:	83 c4 10             	add    $0x10,%esp
    2e1b:	d8 4d dc             	fmuls  -0x24(%ebp)
    2e1e:	d8 45 e0             	fadds  -0x20(%ebp)
    2e21:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2e24:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    2e28:	b4 0c                	mov    $0xc,%ah
    2e2a:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2e2e:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2e31:	db 5d f4             	fistpl -0xc(%ebp)
    2e34:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    2e37:	8b 45 08             	mov    0x8(%ebp),%eax
    2e3a:	8b 00                	mov    (%eax),%eax
    2e3c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2e3f:	db 45 e0             	fildl  -0x20(%ebp)
    2e42:	d9 5d e0             	fstps  -0x20(%ebp)
    2e45:	83 ec 0c             	sub    $0xc,%esp
    2e48:	ff 75 10             	pushl  0x10(%ebp)
    2e4b:	e8 90 e3 ff ff       	call   11e0 <sin>
    2e50:	83 c4 10             	add    $0x10,%esp
    2e53:	d9 5d dc             	fstps  -0x24(%ebp)
    2e56:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2e59:	83 ec 0c             	sub    $0xc,%esp
    2e5c:	50                   	push   %eax
    2e5d:	e8 12 e1 ff ff       	call   f74 <abs>
    2e62:	83 c4 10             	add    $0x10,%esp
    2e65:	d8 4d e0             	fmuls  -0x20(%ebp)
    2e68:	d9 5d e0             	fstps  -0x20(%ebp)
    2e6b:	8b 45 0c             	mov    0xc(%ebp),%eax
    2e6e:	8b 00                	mov    (%eax),%eax
    2e70:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2e73:	db 45 dc             	fildl  -0x24(%ebp)
    2e76:	d9 5d dc             	fstps  -0x24(%ebp)
    2e79:	83 ec 0c             	sub    $0xc,%esp
    2e7c:	ff 75 10             	pushl  0x10(%ebp)
    2e7f:	e8 b9 e1 ff ff       	call   103d <cos>
    2e84:	83 c4 10             	add    $0x10,%esp
    2e87:	d9 5d d8             	fstps  -0x28(%ebp)
    2e8a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2e8d:	83 ec 0c             	sub    $0xc,%esp
    2e90:	50                   	push   %eax
    2e91:	e8 de e0 ff ff       	call   f74 <abs>
    2e96:	83 c4 10             	add    $0x10,%esp
    2e99:	d8 4d dc             	fmuls  -0x24(%ebp)
    2e9c:	d8 45 e0             	fadds  -0x20(%ebp)
    2e9f:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2ea2:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    2ea6:	b4 0c                	mov    $0xc,%ah
    2ea8:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2eac:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2eaf:	db 5d f0             	fistpl -0x10(%ebp)
    2eb2:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    2eb5:	8b 45 0c             	mov    0xc(%ebp),%eax
    2eb8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2ebb:	89 10                	mov    %edx,(%eax)
    *width = w;
    2ebd:	8b 45 08             	mov    0x8(%ebp),%eax
    2ec0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    2ec3:	89 10                	mov    %edx,(%eax)
    return 1;
    2ec5:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2eca:	c9                   	leave  
    2ecb:	c3                   	ret    

00002ecc <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    2ecc:	55                   	push   %ebp
    2ecd:	89 e5                	mov    %esp,%ebp
    2ecf:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    2ed2:	8b 45 08             	mov    0x8(%ebp),%eax
    2ed5:	8b 40 04             	mov    0x4(%eax),%eax
    2ed8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2edb:	db 45 c4             	fildl  -0x3c(%ebp)
    2ede:	d9 05 e4 a3 01 00    	flds   0x1a3e4
    2ee4:	de f9                	fdivrp %st,%st(1)
    2ee6:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    2ee9:	8b 45 08             	mov    0x8(%ebp),%eax
    2eec:	8b 00                	mov    (%eax),%eax
    2eee:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2ef1:	db 45 c4             	fildl  -0x3c(%ebp)
    2ef4:	d9 05 e4 a3 01 00    	flds   0x1a3e4
    2efa:	de f9                	fdivrp %st,%st(1)
    2efc:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    2eff:	8b 45 0c             	mov    0xc(%ebp),%eax
    2f02:	8b 50 04             	mov    0x4(%eax),%edx
    2f05:	8b 45 08             	mov    0x8(%ebp),%eax
    2f08:	8b 40 04             	mov    0x4(%eax),%eax
    2f0b:	29 c2                	sub    %eax,%edx
    2f0d:	89 d0                	mov    %edx,%eax
    2f0f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2f12:	db 45 c4             	fildl  -0x3c(%ebp)
    2f15:	d9 05 e4 a3 01 00    	flds   0x1a3e4
    2f1b:	de f9                	fdivrp %st,%st(1)
    2f1d:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    2f20:	8b 45 0c             	mov    0xc(%ebp),%eax
    2f23:	8b 10                	mov    (%eax),%edx
    2f25:	8b 45 08             	mov    0x8(%ebp),%eax
    2f28:	8b 00                	mov    (%eax),%eax
    2f2a:	29 c2                	sub    %eax,%edx
    2f2c:	89 d0                	mov    %edx,%eax
    2f2e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2f31:	db 45 c4             	fildl  -0x3c(%ebp)
    2f34:	d9 05 e4 a3 01 00    	flds   0x1a3e4
    2f3a:	de f9                	fdivrp %st,%st(1)
    2f3c:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    2f3f:	d9 45 10             	flds   0x10(%ebp)
    2f42:	d9 e0                	fchs   
    2f44:	83 ec 0c             	sub    $0xc,%esp
    2f47:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2f4b:	d9 1c 24             	fstps  (%esp)
    2f4e:	e8 ea e0 ff ff       	call   103d <cos>
    2f53:	83 c4 10             	add    $0x10,%esp
    2f56:	d9 5d c4             	fstps  -0x3c(%ebp)
    2f59:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2f5c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    2f5f:	d9 45 10             	flds   0x10(%ebp)
    2f62:	d9 e0                	fchs   
    2f64:	83 ec 0c             	sub    $0xc,%esp
    2f67:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2f6b:	d9 1c 24             	fstps  (%esp)
    2f6e:	e8 6d e2 ff ff       	call   11e0 <sin>
    2f73:	83 c4 10             	add    $0x10,%esp
    2f76:	d9 5d c4             	fstps  -0x3c(%ebp)
    2f79:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2f7c:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    2f7f:	d9 ee                	fldz   
    2f81:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    2f84:	d9 ee                	fldz   
    2f86:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    2f89:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2f90:	e9 28 01 00 00       	jmp    30bd <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    2f95:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2f9c:	e9 0a 01 00 00       	jmp    30ab <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    2fa1:	db 45 f4             	fildl  -0xc(%ebp)
    2fa4:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2fa7:	d8 65 ec             	fsubs  -0x14(%ebp)
    2faa:	d8 4d dc             	fmuls  -0x24(%ebp)
    2fad:	db 45 f0             	fildl  -0x10(%ebp)
    2fb0:	d8 65 e0             	fsubs  -0x20(%ebp)
    2fb3:	d8 65 e8             	fsubs  -0x18(%ebp)
    2fb6:	d8 4d d8             	fmuls  -0x28(%ebp)
    2fb9:	de c1                	faddp  %st,%st(1)
    2fbb:	d8 45 ec             	fadds  -0x14(%ebp)
    2fbe:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    2fc1:	db 45 f0             	fildl  -0x10(%ebp)
    2fc4:	d8 65 e0             	fsubs  -0x20(%ebp)
    2fc7:	d8 65 e8             	fsubs  -0x18(%ebp)
    2fca:	d8 4d dc             	fmuls  -0x24(%ebp)
    2fcd:	db 45 f4             	fildl  -0xc(%ebp)
    2fd0:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2fd3:	d8 65 ec             	fsubs  -0x14(%ebp)
    2fd6:	d8 4d d8             	fmuls  -0x28(%ebp)
    2fd9:	de e9                	fsubrp %st,%st(1)
    2fdb:	d8 45 e8             	fadds  -0x18(%ebp)
    2fde:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    2fe1:	d9 45 d4             	flds   -0x2c(%ebp)
    2fe4:	d9 ee                	fldz   
    2fe6:	d9 c9                	fxch   %st(1)
    2fe8:	df e9                	fucomip %st(1),%st
    2fea:	dd d8                	fstp   %st(0)
    2fec:	0f 93 c0             	setae  %al
    2fef:	83 f0 01             	xor    $0x1,%eax
    2ff2:	84 c0                	test   %al,%al
    2ff4:	75 52                	jne    3048 <picTurn+0x17c>
    2ff6:	8b 45 08             	mov    0x8(%ebp),%eax
    2ff9:	8b 40 04             	mov    0x4(%eax),%eax
    2ffc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2fff:	db 45 c4             	fildl  -0x3c(%ebp)
    3002:	d9 45 d4             	flds   -0x2c(%ebp)
    3005:	d9 c9                	fxch   %st(1)
    3007:	df e9                	fucomip %st(1),%st
    3009:	dd d8                	fstp   %st(0)
    300b:	0f 97 c0             	seta   %al
    300e:	83 f0 01             	xor    $0x1,%eax
    3011:	84 c0                	test   %al,%al
    3013:	75 33                	jne    3048 <picTurn+0x17c>
    3015:	d9 45 d0             	flds   -0x30(%ebp)
    3018:	d9 ee                	fldz   
    301a:	d9 c9                	fxch   %st(1)
    301c:	df e9                	fucomip %st(1),%st
    301e:	dd d8                	fstp   %st(0)
    3020:	0f 93 c0             	setae  %al
    3023:	83 f0 01             	xor    $0x1,%eax
    3026:	84 c0                	test   %al,%al
    3028:	75 1e                	jne    3048 <picTurn+0x17c>
    302a:	8b 45 08             	mov    0x8(%ebp),%eax
    302d:	8b 00                	mov    (%eax),%eax
    302f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    3032:	db 45 c4             	fildl  -0x3c(%ebp)
    3035:	d9 45 d0             	flds   -0x30(%ebp)
    3038:	d9 c9                	fxch   %st(1)
    303a:	df e9                	fucomip %st(1),%st
    303c:	dd d8                	fstp   %st(0)
    303e:	0f 97 c0             	seta   %al
    3041:	83 f0 01             	xor    $0x1,%eax
    3044:	84 c0                	test   %al,%al
    3046:	74 2f                	je     3077 <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    3048:	8b 45 0c             	mov    0xc(%ebp),%eax
    304b:	8b 48 08             	mov    0x8(%eax),%ecx
    304e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3051:	8b 00                	mov    (%eax),%eax
    3053:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    3057:	89 c2                	mov    %eax,%edx
    3059:	8b 45 f0             	mov    -0x10(%ebp),%eax
    305c:	01 c2                	add    %eax,%edx
    305e:	89 d0                	mov    %edx,%eax
    3060:	01 c0                	add    %eax,%eax
    3062:	01 d0                	add    %edx,%eax
    3064:	01 c8                	add    %ecx,%eax
    3066:	83 ec 08             	sub    $0x8,%esp
    3069:	50                   	push   %eax
    306a:	68 71 e8 01 00       	push   $0x1e871
    306f:	e8 9f f6 ff ff       	call   2713 <setColor>
    3074:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    3077:	8b 45 0c             	mov    0xc(%ebp),%eax
    307a:	8b 48 08             	mov    0x8(%eax),%ecx
    307d:	8b 45 0c             	mov    0xc(%ebp),%eax
    3080:	8b 00                	mov    (%eax),%eax
    3082:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    3086:	89 c2                	mov    %eax,%edx
    3088:	8b 45 f0             	mov    -0x10(%ebp),%eax
    308b:	01 c2                	add    %eax,%edx
    308d:	89 d0                	mov    %edx,%eax
    308f:	01 c0                	add    %eax,%eax
    3091:	01 d0                	add    %edx,%eax
    3093:	01 c8                	add    %ecx,%eax
    3095:	50                   	push   %eax
    3096:	ff 75 d0             	pushl  -0x30(%ebp)
    3099:	ff 75 d4             	pushl  -0x2c(%ebp)
    309c:	ff 75 08             	pushl  0x8(%ebp)
    309f:	e8 9e f6 ff ff       	call   2742 <mixColor>
    30a4:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    30a7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    30ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    30ae:	8b 00                	mov    (%eax),%eax
    30b0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    30b3:	0f 8f e8 fe ff ff    	jg     2fa1 <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    30b9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    30bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    30c0:	8b 40 04             	mov    0x4(%eax),%eax
    30c3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    30c6:	0f 8f c9 fe ff ff    	jg     2f95 <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    30cc:	b8 01 00 00 00       	mov    $0x1,%eax
}
    30d1:	c9                   	leave  
    30d2:	c3                   	ret    

000030d3 <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    30d3:	55                   	push   %ebp
    30d4:	89 e5                	mov    %esp,%ebp
    30d6:	53                   	push   %ebx
    30d7:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    30da:	8b 45 08             	mov    0x8(%ebp),%eax
    30dd:	8b 10                	mov    (%eax),%edx
    30df:	8b 45 0c             	mov    0xc(%ebp),%eax
    30e2:	8b 00                	mov    (%eax),%eax
    30e4:	39 c2                	cmp    %eax,%edx
    30e6:	75 10                	jne    30f8 <picRollingOver+0x25>
    30e8:	8b 45 08             	mov    0x8(%ebp),%eax
    30eb:	8b 50 04             	mov    0x4(%eax),%edx
    30ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    30f1:	8b 40 04             	mov    0x4(%eax),%eax
    30f4:	39 c2                	cmp    %eax,%edx
    30f6:	74 0a                	je     3102 <picRollingOver+0x2f>
        return 0;
    30f8:	b8 00 00 00 00       	mov    $0x0,%eax
    30fd:	e9 88 00 00 00       	jmp    318a <picRollingOver+0xb7>

    int h = src->height;
    3102:	8b 45 08             	mov    0x8(%ebp),%eax
    3105:	8b 40 04             	mov    0x4(%eax),%eax
    3108:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    310b:	8b 45 08             	mov    0x8(%ebp),%eax
    310e:	8b 00                	mov    (%eax),%eax
    3110:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    3113:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    311a:	eb 61                	jmp    317d <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    311c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3123:	eb 4c                	jmp    3171 <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    3125:	8b 45 0c             	mov    0xc(%ebp),%eax
    3128:	8b 48 08             	mov    0x8(%eax),%ecx
    312b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    312e:	2b 45 f8             	sub    -0x8(%ebp),%eax
    3131:	83 e8 01             	sub    $0x1,%eax
    3134:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    3138:	89 c2                	mov    %eax,%edx
    313a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    313d:	01 c2                	add    %eax,%edx
    313f:	89 d0                	mov    %edx,%eax
    3141:	01 c0                	add    %eax,%eax
    3143:	01 d0                	add    %edx,%eax
    3145:	01 c1                	add    %eax,%ecx
    3147:	8b 45 08             	mov    0x8(%ebp),%eax
    314a:	8b 58 08             	mov    0x8(%eax),%ebx
    314d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3150:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    3154:	89 c2                	mov    %eax,%edx
    3156:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3159:	01 c2                	add    %eax,%edx
    315b:	89 d0                	mov    %edx,%eax
    315d:	01 c0                	add    %eax,%eax
    315f:	01 d0                	add    %edx,%eax
    3161:	01 d8                	add    %ebx,%eax
    3163:	51                   	push   %ecx
    3164:	50                   	push   %eax
    3165:	e8 a9 f5 ff ff       	call   2713 <setColor>
    316a:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    316d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3171:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3174:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    3177:	7c ac                	jl     3125 <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    3179:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    317d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3180:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3183:	7c 97                	jl     311c <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    3185:	b8 01 00 00 00       	mov    $0x1,%eax
}
    318a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    318d:	c9                   	leave  
    318e:	c3                   	ret    

0000318f <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    318f:	55                   	push   %ebp
    3190:	89 e5                	mov    %esp,%ebp
    3192:	53                   	push   %ebx
    3193:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    3196:	8b 45 08             	mov    0x8(%ebp),%eax
    3199:	8b 10                	mov    (%eax),%edx
    319b:	8b 45 0c             	mov    0xc(%ebp),%eax
    319e:	8b 00                	mov    (%eax),%eax
    31a0:	39 c2                	cmp    %eax,%edx
    31a2:	75 10                	jne    31b4 <picTurnAround+0x25>
    31a4:	8b 45 08             	mov    0x8(%ebp),%eax
    31a7:	8b 50 04             	mov    0x4(%eax),%edx
    31aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    31ad:	8b 40 04             	mov    0x4(%eax),%eax
    31b0:	39 c2                	cmp    %eax,%edx
    31b2:	74 0a                	je     31be <picTurnAround+0x2f>
        return 0;
    31b4:	b8 00 00 00 00       	mov    $0x0,%eax
    31b9:	e9 88 00 00 00       	jmp    3246 <picTurnAround+0xb7>

    int h = src->height;
    31be:	8b 45 08             	mov    0x8(%ebp),%eax
    31c1:	8b 40 04             	mov    0x4(%eax),%eax
    31c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    31c7:	8b 45 08             	mov    0x8(%ebp),%eax
    31ca:	8b 00                	mov    (%eax),%eax
    31cc:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    31cf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    31d6:	eb 61                	jmp    3239 <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    31d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    31df:	eb 4c                	jmp    322d <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    31e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    31e4:	8b 48 08             	mov    0x8(%eax),%ecx
    31e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    31ea:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    31ee:	89 c2                	mov    %eax,%edx
    31f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    31f3:	2b 45 f4             	sub    -0xc(%ebp),%eax
    31f6:	01 c2                	add    %eax,%edx
    31f8:	89 d0                	mov    %edx,%eax
    31fa:	01 c0                	add    %eax,%eax
    31fc:	01 d0                	add    %edx,%eax
    31fe:	83 e8 03             	sub    $0x3,%eax
    3201:	01 c1                	add    %eax,%ecx
    3203:	8b 45 08             	mov    0x8(%ebp),%eax
    3206:	8b 58 08             	mov    0x8(%eax),%ebx
    3209:	8b 45 f8             	mov    -0x8(%ebp),%eax
    320c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    3210:	89 c2                	mov    %eax,%edx
    3212:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3215:	01 c2                	add    %eax,%edx
    3217:	89 d0                	mov    %edx,%eax
    3219:	01 c0                	add    %eax,%eax
    321b:	01 d0                	add    %edx,%eax
    321d:	01 d8                	add    %ebx,%eax
    321f:	51                   	push   %ecx
    3220:	50                   	push   %eax
    3221:	e8 ed f4 ff ff       	call   2713 <setColor>
    3226:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    3229:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    322d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3230:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    3233:	7c ac                	jl     31e1 <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    3235:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    3239:	8b 45 f8             	mov    -0x8(%ebp),%eax
    323c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    323f:	7c 97                	jl     31d8 <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    3241:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3246:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3249:	c9                   	leave  
    324a:	c3                   	ret    

0000324b <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    324b:	55                   	push   %ebp
    324c:	89 e5                	mov    %esp,%ebp
    324e:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    3251:	83 ec 0c             	sub    $0xc,%esp
    3254:	ff 75 08             	pushl  0x8(%ebp)
    3257:	e8 c5 d5 ff ff       	call   821 <strlen>
    325c:	83 c4 10             	add    $0x10,%esp
    325f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    3262:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3265:	8d 50 ff             	lea    -0x1(%eax),%edx
    3268:	8b 45 08             	mov    0x8(%ebp),%eax
    326b:	01 d0                	add    %edx,%eax
    326d:	0f b6 00             	movzbl (%eax),%eax
    3270:	3c 67                	cmp    $0x67,%al
    3272:	75 2b                	jne    329f <type+0x54>
    3274:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3277:	8d 50 fe             	lea    -0x2(%eax),%edx
    327a:	8b 45 08             	mov    0x8(%ebp),%eax
    327d:	01 d0                	add    %edx,%eax
    327f:	0f b6 00             	movzbl (%eax),%eax
    3282:	3c 70                	cmp    $0x70,%al
    3284:	75 19                	jne    329f <type+0x54>
    3286:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3289:	8d 50 fd             	lea    -0x3(%eax),%edx
    328c:	8b 45 08             	mov    0x8(%ebp),%eax
    328f:	01 d0                	add    %edx,%eax
    3291:	0f b6 00             	movzbl (%eax),%eax
    3294:	3c 6a                	cmp    $0x6a,%al
    3296:	75 07                	jne    329f <type+0x54>
    3298:	b8 00 00 00 00       	mov    $0x0,%eax
    329d:	eb 7f                	jmp    331e <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    329f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    32a2:	8d 50 ff             	lea    -0x1(%eax),%edx
    32a5:	8b 45 08             	mov    0x8(%ebp),%eax
    32a8:	01 d0                	add    %edx,%eax
    32aa:	0f b6 00             	movzbl (%eax),%eax
    32ad:	3c 70                	cmp    $0x70,%al
    32af:	75 2b                	jne    32dc <type+0x91>
    32b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    32b4:	8d 50 fe             	lea    -0x2(%eax),%edx
    32b7:	8b 45 08             	mov    0x8(%ebp),%eax
    32ba:	01 d0                	add    %edx,%eax
    32bc:	0f b6 00             	movzbl (%eax),%eax
    32bf:	3c 6d                	cmp    $0x6d,%al
    32c1:	75 19                	jne    32dc <type+0x91>
    32c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    32c6:	8d 50 fd             	lea    -0x3(%eax),%edx
    32c9:	8b 45 08             	mov    0x8(%ebp),%eax
    32cc:	01 d0                	add    %edx,%eax
    32ce:	0f b6 00             	movzbl (%eax),%eax
    32d1:	3c 62                	cmp    $0x62,%al
    32d3:	75 07                	jne    32dc <type+0x91>
    32d5:	b8 01 00 00 00       	mov    $0x1,%eax
    32da:	eb 42                	jmp    331e <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    32dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    32df:	8d 50 ff             	lea    -0x1(%eax),%edx
    32e2:	8b 45 08             	mov    0x8(%ebp),%eax
    32e5:	01 d0                	add    %edx,%eax
    32e7:	0f b6 00             	movzbl (%eax),%eax
    32ea:	3c 67                	cmp    $0x67,%al
    32ec:	75 2b                	jne    3319 <type+0xce>
    32ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    32f1:	8d 50 fe             	lea    -0x2(%eax),%edx
    32f4:	8b 45 08             	mov    0x8(%ebp),%eax
    32f7:	01 d0                	add    %edx,%eax
    32f9:	0f b6 00             	movzbl (%eax),%eax
    32fc:	3c 6e                	cmp    $0x6e,%al
    32fe:	75 19                	jne    3319 <type+0xce>
    3300:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3303:	8d 50 fd             	lea    -0x3(%eax),%edx
    3306:	8b 45 08             	mov    0x8(%ebp),%eax
    3309:	01 d0                	add    %edx,%eax
    330b:	0f b6 00             	movzbl (%eax),%eax
    330e:	3c 70                	cmp    $0x70,%al
    3310:	75 07                	jne    3319 <type+0xce>
    3312:	b8 02 00 00 00       	mov    $0x2,%eax
    3317:	eb 05                	jmp    331e <type+0xd3>
    else return NONE;
    3319:	b8 03 00 00 00       	mov    $0x3,%eax
}
    331e:	c9                   	leave  
    331f:	c3                   	ret    

00003320 <LoadBmp>:

PBitmap LoadBmp(char* filename){
    3320:	55                   	push   %ebp
    3321:	89 e5                	mov    %esp,%ebp
    3323:	56                   	push   %esi
    3324:	53                   	push   %ebx
    3325:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    3328:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    332f:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    3336:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    333d:	83 ec 08             	sub    $0x8,%esp
    3340:	6a 00                	push   $0x0
    3342:	ff 75 0c             	pushl  0xc(%ebp)
    3345:	e8 d9 d6 ff ff       	call   a23 <open>
    334a:	83 c4 10             	add    $0x10,%esp
    334d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    3350:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    3354:	79 2c                	jns    3382 <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    3356:	83 ec 08             	sub    $0x8,%esp
    3359:	ff 75 0c             	pushl  0xc(%ebp)
    335c:	68 e8 a3 01 00       	push   $0x1a3e8
    3361:	e8 24 d8 ff ff       	call   b8a <printf>
    3366:	83 c4 10             	add    $0x10,%esp
        return bmp;
    3369:	8b 45 08             	mov    0x8(%ebp),%eax
    336c:	8b 55 b8             	mov    -0x48(%ebp),%edx
    336f:	89 10                	mov    %edx,(%eax)
    3371:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3374:	89 50 04             	mov    %edx,0x4(%eax)
    3377:	8b 55 c0             	mov    -0x40(%ebp),%edx
    337a:	89 50 08             	mov    %edx,0x8(%eax)
    337d:	e9 2d 02 00 00       	jmp    35af <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    3382:	83 ec 04             	sub    $0x4,%esp
    3385:	6a 0e                	push   $0xe
    3387:	8d 45 aa             	lea    -0x56(%ebp),%eax
    338a:	50                   	push   %eax
    338b:	ff 75 ec             	pushl  -0x14(%ebp)
    338e:	e8 68 d6 ff ff       	call   9fb <read>
    3393:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    3396:	83 ec 04             	sub    $0x4,%esp
    3399:	6a 28                	push   $0x28
    339b:	8d 45 82             	lea    -0x7e(%ebp),%eax
    339e:	50                   	push   %eax
    339f:	ff 75 ec             	pushl  -0x14(%ebp)
    33a2:	e8 54 d6 ff ff       	call   9fb <read>
    33a7:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    33aa:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    33ae:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    33b1:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    33b5:	0f b7 d8             	movzwl %ax,%ebx
    33b8:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    33bb:	8b 55 ac             	mov    -0x54(%ebp),%edx
    33be:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    33c2:	0f b7 c0             	movzwl %ax,%eax
    33c5:	83 ec 04             	sub    $0x4,%esp
    33c8:	6a 36                	push   $0x36
    33ca:	56                   	push   %esi
    33cb:	53                   	push   %ebx
    33cc:	51                   	push   %ecx
    33cd:	52                   	push   %edx
    33ce:	50                   	push   %eax
    33cf:	68 f8 a3 01 00       	push   $0x1a3f8
    33d4:	e8 b1 d7 ff ff       	call   b8a <printf>
    33d9:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    33dc:	8b 45 86             	mov    -0x7a(%ebp),%eax
    33df:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    33e2:	8b 45 8a             	mov    -0x76(%ebp),%eax
    33e5:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    33e8:	8b 55 b8             	mov    -0x48(%ebp),%edx
    33eb:	8b 45 bc             	mov    -0x44(%ebp),%eax
    33ee:	0f af c2             	imul   %edx,%eax
    33f1:	89 c2                	mov    %eax,%edx
    33f3:	89 d0                	mov    %edx,%eax
    33f5:	01 c0                	add    %eax,%eax
    33f7:	01 d0                	add    %edx,%eax
    33f9:	83 ec 0c             	sub    $0xc,%esp
    33fc:	50                   	push   %eax
    33fd:	e8 5b da ff ff       	call   e5d <malloc>
    3402:	83 c4 10             	add    $0x10,%esp
    3405:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    3408:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    340c:	0f b7 c0             	movzwl %ax,%eax
    340f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    3412:	8b 45 b8             	mov    -0x48(%ebp),%eax
    3415:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    3419:	83 c0 1f             	add    $0x1f,%eax
    341c:	c1 f8 05             	sar    $0x5,%eax
    341f:	c1 e0 02             	shl    $0x2,%eax
    3422:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    3425:	8b 45 bc             	mov    -0x44(%ebp),%eax
    3428:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    342c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    342f:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3432:	8b 45 b8             	mov    -0x48(%ebp),%eax
    3435:	83 ec 08             	sub    $0x8,%esp
    3438:	52                   	push   %edx
    3439:	50                   	push   %eax
    343a:	ff 75 e8             	pushl  -0x18(%ebp)
    343d:	ff 75 e0             	pushl  -0x20(%ebp)
    3440:	ff 75 e4             	pushl  -0x1c(%ebp)
    3443:	68 20 a4 01 00       	push   $0x1a420
    3448:	e8 3d d7 ff ff       	call   b8a <printf>
    344d:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    3450:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    3453:	83 e8 36             	sub    $0x36,%eax
    3456:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    3459:	8b 45 dc             	mov    -0x24(%ebp),%eax
    345c:	83 ec 0c             	sub    $0xc,%esp
    345f:	50                   	push   %eax
    3460:	e8 f8 d9 ff ff       	call   e5d <malloc>
    3465:	83 c4 10             	add    $0x10,%esp
    3468:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    346b:	83 ec 04             	sub    $0x4,%esp
    346e:	ff 75 dc             	pushl  -0x24(%ebp)
    3471:	ff 75 d8             	pushl  -0x28(%ebp)
    3474:	ff 75 ec             	pushl  -0x14(%ebp)
    3477:	e8 7f d5 ff ff       	call   9fb <read>
    347c:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    347f:	8b 45 ac             	mov    -0x54(%ebp),%eax
    3482:	83 ec 0c             	sub    $0xc,%esp
    3485:	50                   	push   %eax
    3486:	e8 d2 d9 ff ff       	call   e5d <malloc>
    348b:	83 c4 10             	add    $0x10,%esp
    348e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    3491:	8b 45 ac             	mov    -0x54(%ebp),%eax
    3494:	83 ec 04             	sub    $0x4,%esp
    3497:	50                   	push   %eax
    3498:	ff 75 d4             	pushl  -0x2c(%ebp)
    349b:	ff 75 ec             	pushl  -0x14(%ebp)
    349e:	e8 58 d5 ff ff       	call   9fb <read>
    34a3:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    34a6:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    34aa:	66 c1 e8 03          	shr    $0x3,%ax
    34ae:	0f b7 c0             	movzwl %ax,%eax
    34b1:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    34b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    34bb:	e9 c1 00 00 00       	jmp    3581 <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    34c0:	8b 45 bc             	mov    -0x44(%ebp),%eax
    34c3:	2b 45 f4             	sub    -0xc(%ebp),%eax
    34c6:	8d 50 ff             	lea    -0x1(%eax),%edx
    34c9:	8b 45 b8             	mov    -0x48(%ebp),%eax
    34cc:	0f af c2             	imul   %edx,%eax
    34cf:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    34d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    34d5:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    34d9:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    34dc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    34e3:	e9 89 00 00 00       	jmp    3571 <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    34e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    34eb:	83 c0 01             	add    $0x1,%eax
    34ee:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    34f2:	89 c2                	mov    %eax,%edx
    34f4:	8b 45 c8             	mov    -0x38(%ebp),%eax
    34f7:	01 d0                	add    %edx,%eax
    34f9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    34fc:	8b 55 c0             	mov    -0x40(%ebp),%edx
    34ff:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    3502:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3505:	01 c8                	add    %ecx,%eax
    3507:	89 c1                	mov    %eax,%ecx
    3509:	89 c8                	mov    %ecx,%eax
    350b:	01 c0                	add    %eax,%eax
    350d:	01 c8                	add    %ecx,%eax
    350f:	01 c2                	add    %eax,%edx
    3511:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    3514:	8d 48 ff             	lea    -0x1(%eax),%ecx
    3517:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    351a:	01 c8                	add    %ecx,%eax
    351c:	0f b6 00             	movzbl (%eax),%eax
    351f:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    3522:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3525:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    3528:	8b 45 f0             	mov    -0x10(%ebp),%eax
    352b:	01 c8                	add    %ecx,%eax
    352d:	89 c1                	mov    %eax,%ecx
    352f:	89 c8                	mov    %ecx,%eax
    3531:	01 c0                	add    %eax,%eax
    3533:	01 c8                	add    %ecx,%eax
    3535:	01 c2                	add    %eax,%edx
    3537:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    353a:	8d 48 fe             	lea    -0x2(%eax),%ecx
    353d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    3540:	01 c8                	add    %ecx,%eax
    3542:	0f b6 00             	movzbl (%eax),%eax
    3545:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    3548:	8b 55 c0             	mov    -0x40(%ebp),%edx
    354b:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    354e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3551:	01 c8                	add    %ecx,%eax
    3553:	89 c1                	mov    %eax,%ecx
    3555:	89 c8                	mov    %ecx,%eax
    3557:	01 c0                	add    %eax,%eax
    3559:	01 c8                	add    %ecx,%eax
    355b:	01 c2                	add    %eax,%edx
    355d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    3560:	8d 48 fd             	lea    -0x3(%eax),%ecx
    3563:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    3566:	01 c8                	add    %ecx,%eax
    3568:	0f b6 00             	movzbl (%eax),%eax
    356b:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    356d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    3571:	8b 45 b8             	mov    -0x48(%ebp),%eax
    3574:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3577:	0f 8f 6b ff ff ff    	jg     34e8 <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    357d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3581:	8b 45 bc             	mov    -0x44(%ebp),%eax
    3584:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    3587:	0f 8f 33 ff ff ff    	jg     34c0 <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    358d:	83 ec 0c             	sub    $0xc,%esp
    3590:	ff 75 ec             	pushl  -0x14(%ebp)
    3593:	e8 73 d4 ff ff       	call   a0b <close>
    3598:	83 c4 10             	add    $0x10,%esp
    return bmp;
    359b:	8b 45 08             	mov    0x8(%ebp),%eax
    359e:	8b 55 b8             	mov    -0x48(%ebp),%edx
    35a1:	89 10                	mov    %edx,(%eax)
    35a3:	8b 55 bc             	mov    -0x44(%ebp),%edx
    35a6:	89 50 04             	mov    %edx,0x4(%eax)
    35a9:	8b 55 c0             	mov    -0x40(%ebp),%edx
    35ac:	89 50 08             	mov    %edx,0x8(%eax)
}
    35af:	8b 45 08             	mov    0x8(%ebp),%eax
    35b2:	8d 65 f8             	lea    -0x8(%ebp),%esp
    35b5:	5b                   	pop    %ebx
    35b6:	5e                   	pop    %esi
    35b7:	5d                   	pop    %ebp
    35b8:	c2 04 00             	ret    $0x4

000035bb <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    35bb:	55                   	push   %ebp
    35bc:	89 e5                	mov    %esp,%ebp
    35be:	53                   	push   %ebx
    35bf:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    35c2:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    35c6:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    35ca:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    35ce:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    35d2:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    35d6:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    35da:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    35de:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    35e2:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    35e6:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    35ea:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    35ee:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    35f2:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    35f6:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    35fa:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    35fe:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    3602:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    3606:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    360a:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    360e:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    3612:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    3616:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    361a:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    361e:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    3622:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    3626:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    362a:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    362e:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    3632:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    3636:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    363a:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    363e:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    3642:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    3646:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    364a:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    364e:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    3652:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    3656:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    365a:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    365e:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    3662:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    3666:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    366a:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    366e:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    3672:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    3676:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    367a:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    367e:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    3682:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    3686:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    368a:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    368e:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    3692:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    3696:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    369a:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    369e:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    36a2:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    36a6:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    36aa:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    36ae:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    36b2:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    36b6:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    36ba:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    36be:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    36c2:	83 ec 0c             	sub    $0xc,%esp
    36c5:	68 c8 02 08 00       	push   $0x802c8
    36ca:	e8 8e d7 ff ff       	call   e5d <malloc>
    36cf:	83 c4 10             	add    $0x10,%esp
    36d2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    36d5:	83 ec 04             	sub    $0x4,%esp
    36d8:	68 c8 02 08 00       	push   $0x802c8
    36dd:	6a 00                	push   $0x0
    36df:	ff 75 f0             	pushl  -0x10(%ebp)
    36e2:	e8 61 d1 ff ff       	call   848 <memset>
    36e7:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    36ea:	83 ec 08             	sub    $0x8,%esp
    36ed:	6a 00                	push   $0x0
    36ef:	ff 75 0c             	pushl  0xc(%ebp)
    36f2:	e8 2c d3 ff ff       	call   a23 <open>
    36f7:	83 c4 10             	add    $0x10,%esp
    36fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    36fd:	83 ec 0c             	sub    $0xc,%esp
    3700:	68 40 42 0f 00       	push   $0xf4240
    3705:	e8 53 d7 ff ff       	call   e5d <malloc>
    370a:	83 c4 10             	add    $0x10,%esp
    370d:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    3710:	83 ec 04             	sub    $0x4,%esp
    3713:	68 40 42 0f 00       	push   $0xf4240
    3718:	ff 75 e8             	pushl  -0x18(%ebp)
    371b:	ff 75 ec             	pushl  -0x14(%ebp)
    371e:	e8 d8 d2 ff ff       	call   9fb <read>
    3723:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    3726:	83 ec 0c             	sub    $0xc,%esp
    3729:	ff 75 ec             	pushl  -0x14(%ebp)
    372c:	e8 da d2 ff ff       	call   a0b <close>
    3731:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    3734:	68 40 42 0f 00       	push   $0xf4240
    3739:	ff 75 e8             	pushl  -0x18(%ebp)
    373c:	8d 45 9c             	lea    -0x64(%ebp),%eax
    373f:	50                   	push   %eax
    3740:	ff 75 f0             	pushl  -0x10(%ebp)
    3743:	e8 5e 0c 01 00       	call   143a6 <_DecodeJPEG>
    3748:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    374b:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    3752:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    3759:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    3760:	83 ec 0c             	sub    $0xc,%esp
    3763:	ff 75 f0             	pushl  -0x10(%ebp)
    3766:	e8 29 0b 01 00       	call   14294 <GetImageSize>
    376b:	83 c4 10             	add    $0x10,%esp
    376e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    3771:	83 ec 0c             	sub    $0xc,%esp
    3774:	ff 75 f0             	pushl  -0x10(%ebp)
    3777:	e8 e1 0a 01 00       	call   1425d <GetImage>
    377c:	83 c4 10             	add    $0x10,%esp
    377f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    3782:	83 ec 0c             	sub    $0xc,%esp
    3785:	ff 75 f0             	pushl  -0x10(%ebp)
    3788:	e8 f1 0a 01 00       	call   1427e <GetWidth>
    378d:	83 c4 10             	add    $0x10,%esp
    3790:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    3793:	83 ec 0c             	sub    $0xc,%esp
    3796:	ff 75 f0             	pushl  -0x10(%ebp)
    3799:	e8 eb 0a 01 00       	call   14289 <GetHeight>
    379e:	83 c4 10             	add    $0x10,%esp
    37a1:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    37a4:	8b 55 90             	mov    -0x70(%ebp),%edx
    37a7:	8b 45 94             	mov    -0x6c(%ebp),%eax
    37aa:	0f af c2             	imul   %edx,%eax
    37ad:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    37b0:	8b 55 dc             	mov    -0x24(%ebp),%edx
    37b3:	89 d0                	mov    %edx,%eax
    37b5:	01 c0                	add    %eax,%eax
    37b7:	01 d0                	add    %edx,%eax
    37b9:	83 ec 0c             	sub    $0xc,%esp
    37bc:	50                   	push   %eax
    37bd:	e8 9b d6 ff ff       	call   e5d <malloc>
    37c2:	83 c4 10             	add    $0x10,%esp
    37c5:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    37c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    37cf:	e9 9c 00 00 00       	jmp    3870 <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    37d4:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    37d7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    37da:	ba 56 55 55 55       	mov    $0x55555556,%edx
    37df:	89 c8                	mov    %ecx,%eax
    37e1:	f7 ea                	imul   %edx
    37e3:	89 c8                	mov    %ecx,%eax
    37e5:	c1 f8 1f             	sar    $0x1f,%eax
    37e8:	29 c2                	sub    %eax,%edx
    37ea:	89 d0                	mov    %edx,%eax
    37ec:	89 c2                	mov    %eax,%edx
    37ee:	89 d0                	mov    %edx,%eax
    37f0:	01 c0                	add    %eax,%eax
    37f2:	01 d0                	add    %edx,%eax
    37f4:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    37f7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    37fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
    37fd:	01 c8                	add    %ecx,%eax
    37ff:	0f b6 00             	movzbl (%eax),%eax
    3802:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    3805:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3808:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    380b:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3810:	89 c8                	mov    %ecx,%eax
    3812:	f7 ea                	imul   %edx
    3814:	89 c8                	mov    %ecx,%eax
    3816:	c1 f8 1f             	sar    $0x1f,%eax
    3819:	29 c2                	sub    %eax,%edx
    381b:	89 d0                	mov    %edx,%eax
    381d:	89 c2                	mov    %eax,%edx
    381f:	89 d0                	mov    %edx,%eax
    3821:	01 c0                	add    %eax,%eax
    3823:	01 d0                	add    %edx,%eax
    3825:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3828:	8b 45 f4             	mov    -0xc(%ebp),%eax
    382b:	8d 48 01             	lea    0x1(%eax),%ecx
    382e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3831:	01 c8                	add    %ecx,%eax
    3833:	0f b6 00             	movzbl (%eax),%eax
    3836:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    3839:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    383c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    383f:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3844:	89 c8                	mov    %ecx,%eax
    3846:	f7 ea                	imul   %edx
    3848:	89 c8                	mov    %ecx,%eax
    384a:	c1 f8 1f             	sar    $0x1f,%eax
    384d:	29 c2                	sub    %eax,%edx
    384f:	89 d0                	mov    %edx,%eax
    3851:	89 c2                	mov    %eax,%edx
    3853:	89 d0                	mov    %edx,%eax
    3855:	01 c0                	add    %eax,%eax
    3857:	01 d0                	add    %edx,%eax
    3859:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    385c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    385f:	8d 48 02             	lea    0x2(%eax),%ecx
    3862:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3865:	01 c8                	add    %ecx,%eax
    3867:	0f b6 00             	movzbl (%eax),%eax
    386a:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    386c:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    3870:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3873:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    3876:	0f 8c 58 ff ff ff    	jl     37d4 <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    387c:	8b 45 08             	mov    0x8(%ebp),%eax
    387f:	8b 55 90             	mov    -0x70(%ebp),%edx
    3882:	89 10                	mov    %edx,(%eax)
    3884:	8b 55 94             	mov    -0x6c(%ebp),%edx
    3887:	89 50 04             	mov    %edx,0x4(%eax)
    388a:	8b 55 98             	mov    -0x68(%ebp),%edx
    388d:	89 50 08             	mov    %edx,0x8(%eax)
}
    3890:	8b 45 08             	mov    0x8(%ebp),%eax
    3893:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3896:	c9                   	leave  
    3897:	c2 04 00             	ret    $0x4

0000389a <LoadPng>:

PBitmap LoadPng(char* filename){
    389a:	55                   	push   %ebp
    389b:	89 e5                	mov    %esp,%ebp
    389d:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    38a0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    38a7:	ff 75 0c             	pushl  0xc(%ebp)
    38aa:	8d 45 e0             	lea    -0x20(%ebp),%eax
    38ad:	50                   	push   %eax
    38ae:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    38b1:	50                   	push   %eax
    38b2:	8d 45 e8             	lea    -0x18(%ebp),%eax
    38b5:	50                   	push   %eax
    38b6:	e8 d3 d3 00 00       	call   10c8e <lodepng_decode24_file>
    38bb:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    38be:	8b 45 e0             	mov    -0x20(%ebp),%eax
    38c1:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    38c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    38c7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    38ca:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    38d1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    38d4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    38d7:	0f af c2             	imul   %edx,%eax
    38da:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    38dd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    38e0:	89 d0                	mov    %edx,%eax
    38e2:	01 c0                	add    %eax,%eax
    38e4:	01 d0                	add    %edx,%eax
    38e6:	83 ec 0c             	sub    $0xc,%esp
    38e9:	50                   	push   %eax
    38ea:	e8 6e d5 ff ff       	call   e5d <malloc>
    38ef:	83 c4 10             	add    $0x10,%esp
    38f2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    38f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    38fc:	e9 87 00 00 00       	jmp    3988 <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    3901:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3904:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3907:	89 d0                	mov    %edx,%eax
    3909:	01 c0                	add    %eax,%eax
    390b:	01 d0                	add    %edx,%eax
    390d:	01 c8                	add    %ecx,%eax
    390f:	0f b6 00             	movzbl (%eax),%eax
    3912:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    3915:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3918:	8b 55 f4             	mov    -0xc(%ebp),%edx
    391b:	89 d0                	mov    %edx,%eax
    391d:	01 c0                	add    %eax,%eax
    391f:	01 d0                	add    %edx,%eax
    3921:	83 c0 01             	add    $0x1,%eax
    3924:	01 c8                	add    %ecx,%eax
    3926:	0f b6 00             	movzbl (%eax),%eax
    3929:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    392c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    392f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3932:	89 d0                	mov    %edx,%eax
    3934:	01 c0                	add    %eax,%eax
    3936:	01 d0                	add    %edx,%eax
    3938:	83 c0 02             	add    $0x2,%eax
    393b:	01 c8                	add    %ecx,%eax
    393d:	0f b6 00             	movzbl (%eax),%eax
    3940:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    3943:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3946:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3949:	89 d0                	mov    %edx,%eax
    394b:	01 c0                	add    %eax,%eax
    394d:	01 d0                	add    %edx,%eax
    394f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3952:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    3956:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    3959:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    395c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    395f:	89 d0                	mov    %edx,%eax
    3961:	01 c0                	add    %eax,%eax
    3963:	01 d0                	add    %edx,%eax
    3965:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3968:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    396c:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    396f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3972:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3975:	89 d0                	mov    %edx,%eax
    3977:	01 c0                	add    %eax,%eax
    3979:	01 d0                	add    %edx,%eax
    397b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    397e:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    3982:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    3984:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3988:	8b 45 f4             	mov    -0xc(%ebp),%eax
    398b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    398e:	0f 8c 6d ff ff ff    	jl     3901 <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    3994:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3997:	83 ec 0c             	sub    $0xc,%esp
    399a:	50                   	push   %eax
    399b:	e8 7b d3 ff ff       	call   d1b <free>
    39a0:	83 c4 10             	add    $0x10,%esp
    return bmp;
    39a3:	8b 45 08             	mov    0x8(%ebp),%eax
    39a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    39a9:	89 10                	mov    %edx,(%eax)
    39ab:	8b 55 d8             	mov    -0x28(%ebp),%edx
    39ae:	89 50 04             	mov    %edx,0x4(%eax)
    39b1:	8b 55 dc             	mov    -0x24(%ebp),%edx
    39b4:	89 50 08             	mov    %edx,0x8(%eax)

}
    39b7:	8b 45 08             	mov    0x8(%ebp),%eax
    39ba:	c9                   	leave  
    39bb:	c2 04 00             	ret    $0x4

000039be <LoadImg>:

PBitmap LoadImg(char* filename){
    39be:	55                   	push   %ebp
    39bf:	89 e5                	mov    %esp,%ebp
    39c1:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    39c4:	83 ec 0c             	sub    $0xc,%esp
    39c7:	ff 75 0c             	pushl  0xc(%ebp)
    39ca:	e8 7c f8 ff ff       	call   324b <type>
    39cf:	83 c4 10             	add    $0x10,%esp
    39d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    39d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    39d8:	83 f8 01             	cmp    $0x1,%eax
    39db:	74 1d                	je     39fa <LoadImg+0x3c>
    39dd:	83 f8 02             	cmp    $0x2,%eax
    39e0:	74 2c                	je     3a0e <LoadImg+0x50>
    39e2:	85 c0                	test   %eax,%eax
    39e4:	75 3c                	jne    3a22 <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    39e6:	8b 45 08             	mov    0x8(%ebp),%eax
    39e9:	83 ec 08             	sub    $0x8,%esp
    39ec:	ff 75 0c             	pushl  0xc(%ebp)
    39ef:	50                   	push   %eax
    39f0:	e8 c6 fb ff ff       	call   35bb <LoadJpeg>
    39f5:	83 c4 0c             	add    $0xc,%esp
    39f8:	eb 3c                	jmp    3a36 <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    39fa:	8b 45 08             	mov    0x8(%ebp),%eax
    39fd:	83 ec 08             	sub    $0x8,%esp
    3a00:	ff 75 0c             	pushl  0xc(%ebp)
    3a03:	50                   	push   %eax
    3a04:	e8 17 f9 ff ff       	call   3320 <LoadBmp>
    3a09:	83 c4 0c             	add    $0xc,%esp
    3a0c:	eb 28                	jmp    3a36 <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    3a0e:	8b 45 08             	mov    0x8(%ebp),%eax
    3a11:	83 ec 08             	sub    $0x8,%esp
    3a14:	ff 75 0c             	pushl  0xc(%ebp)
    3a17:	50                   	push   %eax
    3a18:	e8 7d fe ff ff       	call   389a <LoadPng>
    3a1d:	83 c4 0c             	add    $0xc,%esp
    3a20:	eb 14                	jmp    3a36 <LoadImg+0x78>

        default: return bmp;
    3a22:	8b 45 08             	mov    0x8(%ebp),%eax
    3a25:	8b 55 e8             	mov    -0x18(%ebp),%edx
    3a28:	89 10                	mov    %edx,(%eax)
    3a2a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3a2d:	89 50 04             	mov    %edx,0x4(%eax)
    3a30:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3a33:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    3a36:	8b 45 08             	mov    0x8(%ebp),%eax
    3a39:	c9                   	leave  
    3a3a:	c2 04 00             	ret    $0x4

00003a3d <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    3a3d:	55                   	push   %ebp
    3a3e:	89 e5                	mov    %esp,%ebp
    3a40:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    3a43:	8b 45 08             	mov    0x8(%ebp),%eax
    3a46:	83 ec 0c             	sub    $0xc,%esp
    3a49:	50                   	push   %eax
    3a4a:	e8 0e d4 ff ff       	call   e5d <malloc>
    3a4f:	83 c4 10             	add    $0x10,%esp
}
    3a52:	c9                   	leave  
    3a53:	c3                   	ret    

00003a54 <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    3a54:	55                   	push   %ebp
    3a55:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    3a57:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3a5c:	5d                   	pop    %ebp
    3a5d:	c3                   	ret    

00003a5e <lodepng_free>:

static void lodepng_free(void* ptr) {
    3a5e:	55                   	push   %ebp
    3a5f:	89 e5                	mov    %esp,%ebp
    3a61:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    3a64:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    3a68:	74 0e                	je     3a78 <lodepng_free+0x1a>
    free(ptr);
    3a6a:	83 ec 0c             	sub    $0xc,%esp
    3a6d:	ff 75 08             	pushl  0x8(%ebp)
    3a70:	e8 a6 d2 ff ff       	call   d1b <free>
    3a75:	83 c4 10             	add    $0x10,%esp
}
    3a78:	90                   	nop
    3a79:	c9                   	leave  
    3a7a:	c3                   	ret    

00003a7b <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    3a7b:	55                   	push   %ebp
    3a7c:	89 e5                	mov    %esp,%ebp
    3a7e:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    3a81:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3a88:	eb 19                	jmp    3aa3 <lodepng_memcpy+0x28>
    3a8a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3a8d:	8b 45 08             	mov    0x8(%ebp),%eax
    3a90:	01 c2                	add    %eax,%edx
    3a92:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3a95:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a98:	01 c8                	add    %ecx,%eax
    3a9a:	0f b6 00             	movzbl (%eax),%eax
    3a9d:	88 02                	mov    %al,(%edx)
    3a9f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3aa3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3aa6:	3b 45 10             	cmp    0x10(%ebp),%eax
    3aa9:	7c df                	jl     3a8a <lodepng_memcpy+0xf>
}
    3aab:	90                   	nop
    3aac:	c9                   	leave  
    3aad:	c3                   	ret    

00003aae <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    3aae:	55                   	push   %ebp
    3aaf:	89 e5                	mov    %esp,%ebp
    3ab1:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    3ab4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3abb:	eb 11                	jmp    3ace <lodepng_memset+0x20>
    3abd:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3ac0:	8b 45 08             	mov    0x8(%ebp),%eax
    3ac3:	01 d0                	add    %edx,%eax
    3ac5:	8b 55 0c             	mov    0xc(%ebp),%edx
    3ac8:	88 10                	mov    %dl,(%eax)
    3aca:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3ace:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ad1:	3b 45 10             	cmp    0x10(%ebp),%eax
    3ad4:	7c e7                	jl     3abd <lodepng_memset+0xf>
}
    3ad6:	90                   	nop
    3ad7:	c9                   	leave  
    3ad8:	c3                   	ret    

00003ad9 <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    3ad9:	55                   	push   %ebp
    3ada:	89 e5                	mov    %esp,%ebp
    3adc:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    3adf:	8b 45 08             	mov    0x8(%ebp),%eax
    3ae2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    3ae5:	eb 04                	jmp    3aeb <lodepng_strlen+0x12>
    3ae7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    3aeb:	8b 45 08             	mov    0x8(%ebp),%eax
    3aee:	0f b6 00             	movzbl (%eax),%eax
    3af1:	84 c0                	test   %al,%al
    3af3:	75 f2                	jne    3ae7 <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    3af5:	8b 55 08             	mov    0x8(%ebp),%edx
    3af8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3afb:	29 c2                	sub    %eax,%edx
    3afd:	89 d0                	mov    %edx,%eax
}
    3aff:	c9                   	leave  
    3b00:	c3                   	ret    

00003b01 <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    3b01:	55                   	push   %ebp
    3b02:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    3b04:	8b 55 08             	mov    0x8(%ebp),%edx
    3b07:	8b 45 0c             	mov    0xc(%ebp),%eax
    3b0a:	01 c2                	add    %eax,%edx
    3b0c:	8b 45 10             	mov    0x10(%ebp),%eax
    3b0f:	89 10                	mov    %edx,(%eax)
  return *result < a;
    3b11:	8b 45 10             	mov    0x10(%ebp),%eax
    3b14:	8b 00                	mov    (%eax),%eax
    3b16:	3b 45 08             	cmp    0x8(%ebp),%eax
    3b19:	0f 9c c0             	setl   %al
    3b1c:	0f b6 c0             	movzbl %al,%eax
}
    3b1f:	5d                   	pop    %ebp
    3b20:	c3                   	ret    

00003b21 <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    3b21:	55                   	push   %ebp
    3b22:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    3b24:	8b 45 08             	mov    0x8(%ebp),%eax
    3b27:	0f af 45 0c          	imul   0xc(%ebp),%eax
    3b2b:	89 c2                	mov    %eax,%edx
    3b2d:	8b 45 10             	mov    0x10(%ebp),%eax
    3b30:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    3b32:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    3b36:	74 15                	je     3b4d <lodepng_mulofl+0x2c>
    3b38:	8b 45 10             	mov    0x10(%ebp),%eax
    3b3b:	8b 00                	mov    (%eax),%eax
    3b3d:	99                   	cltd   
    3b3e:	f7 7d 08             	idivl  0x8(%ebp)
    3b41:	3b 45 0c             	cmp    0xc(%ebp),%eax
    3b44:	74 07                	je     3b4d <lodepng_mulofl+0x2c>
    3b46:	b8 01 00 00 00       	mov    $0x1,%eax
    3b4b:	eb 05                	jmp    3b52 <lodepng_mulofl+0x31>
    3b4d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3b52:	5d                   	pop    %ebp
    3b53:	c3                   	ret    

00003b54 <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    3b54:	55                   	push   %ebp
    3b55:	89 e5                	mov    %esp,%ebp
    3b57:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    3b5a:	8d 45 fc             	lea    -0x4(%ebp),%eax
    3b5d:	50                   	push   %eax
    3b5e:	ff 75 0c             	pushl  0xc(%ebp)
    3b61:	ff 75 08             	pushl  0x8(%ebp)
    3b64:	e8 98 ff ff ff       	call   3b01 <lodepng_addofl>
    3b69:	83 c4 0c             	add    $0xc,%esp
    3b6c:	85 c0                	test   %eax,%eax
    3b6e:	74 07                	je     3b77 <lodepng_gtofl+0x23>
    3b70:	b8 01 00 00 00       	mov    $0x1,%eax
    3b75:	eb 0c                	jmp    3b83 <lodepng_gtofl+0x2f>
  return d > c;
    3b77:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3b7a:	3b 45 10             	cmp    0x10(%ebp),%eax
    3b7d:	0f 9f c0             	setg   %al
    3b80:	0f b6 c0             	movzbl %al,%eax
}
    3b83:	c9                   	leave  
    3b84:	c3                   	ret    

00003b85 <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    3b85:	55                   	push   %ebp
    3b86:	89 e5                	mov    %esp,%ebp
    3b88:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    3b8b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b8e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    3b95:	8b 45 08             	mov    0x8(%ebp),%eax
    3b98:	8b 50 08             	mov    0x8(%eax),%edx
    3b9b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b9e:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    3ba1:	8b 45 08             	mov    0x8(%ebp),%eax
    3ba4:	8b 00                	mov    (%eax),%eax
    3ba6:	83 ec 0c             	sub    $0xc,%esp
    3ba9:	50                   	push   %eax
    3baa:	e8 af fe ff ff       	call   3a5e <lodepng_free>
    3baf:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    3bb2:	8b 45 08             	mov    0x8(%ebp),%eax
    3bb5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3bbb:	90                   	nop
    3bbc:	c9                   	leave  
    3bbd:	c3                   	ret    

00003bbe <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    3bbe:	55                   	push   %ebp
    3bbf:	89 e5                	mov    %esp,%ebp
    3bc1:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    3bc4:	8b 45 0c             	mov    0xc(%ebp),%eax
    3bc7:	c1 e0 02             	shl    $0x2,%eax
    3bca:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    3bcd:	8b 45 08             	mov    0x8(%ebp),%eax
    3bd0:	8b 40 08             	mov    0x8(%eax),%eax
    3bd3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    3bd6:	7d 46                	jge    3c1e <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    3bd8:	8b 45 08             	mov    0x8(%ebp),%eax
    3bdb:	8b 40 08             	mov    0x8(%eax),%eax
    3bde:	d1 f8                	sar    %eax
    3be0:	89 c2                	mov    %eax,%edx
    3be2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3be5:	01 d0                	add    %edx,%eax
    3be7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    3bea:	8b 45 08             	mov    0x8(%ebp),%eax
    3bed:	8b 00                	mov    (%eax),%eax
    3bef:	ff 75 f8             	pushl  -0x8(%ebp)
    3bf2:	50                   	push   %eax
    3bf3:	e8 5c fe ff ff       	call   3a54 <lodepng_realloc>
    3bf8:	83 c4 08             	add    $0x8,%esp
    3bfb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    3bfe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3c02:	74 13                	je     3c17 <uivector_resize+0x59>
      p->allocsize = newsize;
    3c04:	8b 45 08             	mov    0x8(%ebp),%eax
    3c07:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3c0a:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    3c0d:	8b 45 08             	mov    0x8(%ebp),%eax
    3c10:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3c13:	89 10                	mov    %edx,(%eax)
    3c15:	eb 07                	jmp    3c1e <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    3c17:	b8 00 00 00 00       	mov    $0x0,%eax
    3c1c:	eb 0e                	jmp    3c2c <uivector_resize+0x6e>
  }
  p->size = size;
    3c1e:	8b 45 08             	mov    0x8(%ebp),%eax
    3c21:	8b 55 0c             	mov    0xc(%ebp),%edx
    3c24:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    3c27:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3c2c:	c9                   	leave  
    3c2d:	c3                   	ret    

00003c2e <uivector_init>:

static void uivector_init(uivector* p) {
    3c2e:	55                   	push   %ebp
    3c2f:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    3c31:	8b 45 08             	mov    0x8(%ebp),%eax
    3c34:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    3c3a:	8b 45 08             	mov    0x8(%ebp),%eax
    3c3d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    3c44:	8b 45 08             	mov    0x8(%ebp),%eax
    3c47:	8b 50 08             	mov    0x8(%eax),%edx
    3c4a:	8b 45 08             	mov    0x8(%ebp),%eax
    3c4d:	89 50 04             	mov    %edx,0x4(%eax)
}
    3c50:	90                   	nop
    3c51:	5d                   	pop    %ebp
    3c52:	c3                   	ret    

00003c53 <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    3c53:	55                   	push   %ebp
    3c54:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    3c56:	8b 45 08             	mov    0x8(%ebp),%eax
    3c59:	8b 40 04             	mov    0x4(%eax),%eax
    3c5c:	83 c0 01             	add    $0x1,%eax
    3c5f:	50                   	push   %eax
    3c60:	ff 75 08             	pushl  0x8(%ebp)
    3c63:	e8 56 ff ff ff       	call   3bbe <uivector_resize>
    3c68:	83 c4 08             	add    $0x8,%esp
    3c6b:	85 c0                	test   %eax,%eax
    3c6d:	75 07                	jne    3c76 <uivector_push_back+0x23>
    3c6f:	b8 00 00 00 00       	mov    $0x0,%eax
    3c74:	eb 1f                	jmp    3c95 <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    3c76:	8b 45 08             	mov    0x8(%ebp),%eax
    3c79:	8b 10                	mov    (%eax),%edx
    3c7b:	8b 45 08             	mov    0x8(%ebp),%eax
    3c7e:	8b 40 04             	mov    0x4(%eax),%eax
    3c81:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    3c86:	c1 e0 02             	shl    $0x2,%eax
    3c89:	01 c2                	add    %eax,%edx
    3c8b:	8b 45 0c             	mov    0xc(%ebp),%eax
    3c8e:	89 02                	mov    %eax,(%edx)
  return 1;
    3c90:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3c95:	c9                   	leave  
    3c96:	c3                   	ret    

00003c97 <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    3c97:	55                   	push   %ebp
    3c98:	89 e5                	mov    %esp,%ebp
    3c9a:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    3c9d:	8b 45 08             	mov    0x8(%ebp),%eax
    3ca0:	8b 40 08             	mov    0x8(%eax),%eax
    3ca3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    3ca6:	7d 46                	jge    3cee <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    3ca8:	8b 45 08             	mov    0x8(%ebp),%eax
    3cab:	8b 40 08             	mov    0x8(%eax),%eax
    3cae:	d1 f8                	sar    %eax
    3cb0:	89 c2                	mov    %eax,%edx
    3cb2:	8b 45 0c             	mov    0xc(%ebp),%eax
    3cb5:	01 d0                	add    %edx,%eax
    3cb7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    3cba:	8b 45 08             	mov    0x8(%ebp),%eax
    3cbd:	8b 00                	mov    (%eax),%eax
    3cbf:	ff 75 fc             	pushl  -0x4(%ebp)
    3cc2:	50                   	push   %eax
    3cc3:	e8 8c fd ff ff       	call   3a54 <lodepng_realloc>
    3cc8:	83 c4 08             	add    $0x8,%esp
    3ccb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    3cce:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    3cd2:	74 13                	je     3ce7 <ucvector_resize+0x50>
      p->allocsize = newsize;
    3cd4:	8b 45 08             	mov    0x8(%ebp),%eax
    3cd7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3cda:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    3cdd:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3ce3:	89 10                	mov    %edx,(%eax)
    3ce5:	eb 07                	jmp    3cee <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    3ce7:	b8 00 00 00 00       	mov    $0x0,%eax
    3cec:	eb 0e                	jmp    3cfc <ucvector_resize+0x65>
  }
  p->size = size;
    3cee:	8b 45 08             	mov    0x8(%ebp),%eax
    3cf1:	8b 55 0c             	mov    0xc(%ebp),%edx
    3cf4:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    3cf7:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3cfc:	c9                   	leave  
    3cfd:	c3                   	ret    

00003cfe <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    3cfe:	55                   	push   %ebp
    3cff:	89 e5                	mov    %esp,%ebp
    3d01:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    3d04:	8b 45 0c             	mov    0xc(%ebp),%eax
    3d07:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    3d0a:	8b 45 10             	mov    0x10(%ebp),%eax
    3d0d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    3d10:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3d13:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    3d16:	8b 45 08             	mov    0x8(%ebp),%eax
    3d19:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3d1c:	89 10                	mov    %edx,(%eax)
    3d1e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3d21:	89 50 04             	mov    %edx,0x4(%eax)
    3d24:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d27:	89 50 08             	mov    %edx,0x8(%eax)
}
    3d2a:	8b 45 08             	mov    0x8(%ebp),%eax
    3d2d:	c9                   	leave  
    3d2e:	c2 04 00             	ret    $0x4

00003d31 <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    3d31:	55                   	push   %ebp
    3d32:	89 e5                	mov    %esp,%ebp
    3d34:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    3d37:	8b 45 08             	mov    0x8(%ebp),%eax
    3d3a:	8b 00                	mov    (%eax),%eax
    3d3c:	83 ec 0c             	sub    $0xc,%esp
    3d3f:	50                   	push   %eax
    3d40:	e8 19 fd ff ff       	call   3a5e <lodepng_free>
    3d45:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    3d48:	8b 45 08             	mov    0x8(%ebp),%eax
    3d4b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3d51:	90                   	nop
    3d52:	c9                   	leave  
    3d53:	c3                   	ret    

00003d54 <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    3d54:	55                   	push   %ebp
    3d55:	89 e5                	mov    %esp,%ebp
    3d57:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    3d5a:	8b 45 0c             	mov    0xc(%ebp),%eax
    3d5d:	83 c0 01             	add    $0x1,%eax
    3d60:	83 ec 0c             	sub    $0xc,%esp
    3d63:	50                   	push   %eax
    3d64:	e8 d4 fc ff ff       	call   3a3d <lodepng_malloc>
    3d69:	83 c4 10             	add    $0x10,%esp
    3d6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    3d6f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3d73:	74 1f                	je     3d94 <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    3d75:	83 ec 04             	sub    $0x4,%esp
    3d78:	ff 75 0c             	pushl  0xc(%ebp)
    3d7b:	ff 75 08             	pushl  0x8(%ebp)
    3d7e:	ff 75 f4             	pushl  -0xc(%ebp)
    3d81:	e8 f5 fc ff ff       	call   3a7b <lodepng_memcpy>
    3d86:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    3d89:	8b 55 0c             	mov    0xc(%ebp),%edx
    3d8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3d8f:	01 d0                	add    %edx,%eax
    3d91:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    3d94:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3d97:	c9                   	leave  
    3d98:	c3                   	ret    

00003d99 <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    3d99:	55                   	push   %ebp
    3d9a:	89 e5                	mov    %esp,%ebp
    3d9c:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    3d9f:	ff 75 08             	pushl  0x8(%ebp)
    3da2:	e8 32 fd ff ff       	call   3ad9 <lodepng_strlen>
    3da7:	83 c4 04             	add    $0x4,%esp
    3daa:	83 ec 08             	sub    $0x8,%esp
    3dad:	50                   	push   %eax
    3dae:	ff 75 08             	pushl  0x8(%ebp)
    3db1:	e8 9e ff ff ff       	call   3d54 <alloc_string_sized>
    3db6:	83 c4 10             	add    $0x10,%esp
}
    3db9:	c9                   	leave  
    3dba:	c3                   	ret    

00003dbb <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    3dbb:	55                   	push   %ebp
    3dbc:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3dbe:	8b 45 08             	mov    0x8(%ebp),%eax
    3dc1:	0f b6 00             	movzbl (%eax),%eax
    3dc4:	0f b6 c0             	movzbl %al,%eax
    3dc7:	c1 e0 18             	shl    $0x18,%eax
    3dca:	89 c2                	mov    %eax,%edx
    3dcc:	8b 45 08             	mov    0x8(%ebp),%eax
    3dcf:	83 c0 01             	add    $0x1,%eax
    3dd2:	0f b6 00             	movzbl (%eax),%eax
    3dd5:	0f b6 c0             	movzbl %al,%eax
    3dd8:	c1 e0 10             	shl    $0x10,%eax
    3ddb:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    3ddd:	8b 45 08             	mov    0x8(%ebp),%eax
    3de0:	83 c0 02             	add    $0x2,%eax
    3de3:	0f b6 00             	movzbl (%eax),%eax
    3de6:	0f b6 c0             	movzbl %al,%eax
    3de9:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3dec:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    3dee:	8b 45 08             	mov    0x8(%ebp),%eax
    3df1:	83 c0 03             	add    $0x3,%eax
    3df4:	0f b6 00             	movzbl (%eax),%eax
    3df7:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3dfa:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    3dfc:	5d                   	pop    %ebp
    3dfd:	c3                   	ret    

00003dfe <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    3dfe:	55                   	push   %ebp
    3dff:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    3e01:	8b 45 0c             	mov    0xc(%ebp),%eax
    3e04:	c1 e8 18             	shr    $0x18,%eax
    3e07:	89 c2                	mov    %eax,%edx
    3e09:	8b 45 08             	mov    0x8(%ebp),%eax
    3e0c:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    3e0e:	8b 45 08             	mov    0x8(%ebp),%eax
    3e11:	83 c0 01             	add    $0x1,%eax
    3e14:	8b 55 0c             	mov    0xc(%ebp),%edx
    3e17:	c1 ea 10             	shr    $0x10,%edx
    3e1a:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    3e1c:	8b 45 08             	mov    0x8(%ebp),%eax
    3e1f:	83 c0 02             	add    $0x2,%eax
    3e22:	8b 55 0c             	mov    0xc(%ebp),%edx
    3e25:	c1 ea 08             	shr    $0x8,%edx
    3e28:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    3e2a:	8b 45 08             	mov    0x8(%ebp),%eax
    3e2d:	83 c0 03             	add    $0x3,%eax
    3e30:	8b 55 0c             	mov    0xc(%ebp),%edx
    3e33:	88 10                	mov    %dl,(%eax)
}
    3e35:	90                   	nop
    3e36:	5d                   	pop    %ebp
    3e37:	c3                   	ret    

00003e38 <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    3e38:	55                   	push   %ebp
    3e39:	89 e5                	mov    %esp,%ebp
    3e3b:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    3e3e:	83 ec 08             	sub    $0x8,%esp
    3e41:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    3e44:	50                   	push   %eax
    3e45:	ff 75 08             	pushl  0x8(%ebp)
    3e48:	e8 b7 ca ff ff       	call   904 <stat>
    3e4d:	83 c4 10             	add    $0x10,%esp
  return s.size;
    3e50:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3e53:	c9                   	leave  
    3e54:	c3                   	ret    

00003e55 <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    3e55:	55                   	push   %ebp
    3e56:	89 e5                	mov    %esp,%ebp
    3e58:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    3e5b:	83 ec 08             	sub    $0x8,%esp
    3e5e:	6a 00                	push   $0x0
    3e60:	ff 75 10             	pushl  0x10(%ebp)
    3e63:	e8 bb cb ff ff       	call   a23 <open>
    3e68:	83 c4 10             	add    $0x10,%esp
    3e6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    3e6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3e72:	79 07                	jns    3e7b <lodepng_buffer_file+0x26>
  {
      return -1;
    3e74:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    3e79:	eb 19                	jmp    3e94 <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    3e7b:	83 ec 04             	sub    $0x4,%esp
    3e7e:	ff 75 0c             	pushl  0xc(%ebp)
    3e81:	ff 75 08             	pushl  0x8(%ebp)
    3e84:	ff 75 f4             	pushl  -0xc(%ebp)
    3e87:	e8 6f cb ff ff       	call   9fb <read>
    3e8c:	83 c4 10             	add    $0x10,%esp
  return 0;
    3e8f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3e94:	c9                   	leave  
    3e95:	c3                   	ret    

00003e96 <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    3e96:	55                   	push   %ebp
    3e97:	89 e5                	mov    %esp,%ebp
    3e99:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    3e9c:	83 ec 0c             	sub    $0xc,%esp
    3e9f:	ff 75 10             	pushl  0x10(%ebp)
    3ea2:	e8 91 ff ff ff       	call   3e38 <lodepng_filesize>
    3ea7:	83 c4 10             	add    $0x10,%esp
    3eaa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    3ead:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3eb1:	79 07                	jns    3eba <lodepng_load_file+0x24>
    3eb3:	b8 4e 00 00 00       	mov    $0x4e,%eax
    3eb8:	eb 4a                	jmp    3f04 <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    3eba:	8b 45 0c             	mov    0xc(%ebp),%eax
    3ebd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3ec0:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    3ec2:	83 ec 0c             	sub    $0xc,%esp
    3ec5:	ff 75 f4             	pushl  -0xc(%ebp)
    3ec8:	e8 70 fb ff ff       	call   3a3d <lodepng_malloc>
    3ecd:	83 c4 10             	add    $0x10,%esp
    3ed0:	89 c2                	mov    %eax,%edx
    3ed2:	8b 45 08             	mov    0x8(%ebp),%eax
    3ed5:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    3ed7:	8b 45 08             	mov    0x8(%ebp),%eax
    3eda:	8b 00                	mov    (%eax),%eax
    3edc:	85 c0                	test   %eax,%eax
    3ede:	75 0d                	jne    3eed <lodepng_load_file+0x57>
    3ee0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3ee4:	7e 07                	jle    3eed <lodepng_load_file+0x57>
    3ee6:	b8 53 00 00 00       	mov    $0x53,%eax
    3eeb:	eb 17                	jmp    3f04 <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    3eed:	8b 45 08             	mov    0x8(%ebp),%eax
    3ef0:	8b 00                	mov    (%eax),%eax
    3ef2:	83 ec 04             	sub    $0x4,%esp
    3ef5:	ff 75 10             	pushl  0x10(%ebp)
    3ef8:	ff 75 f4             	pushl  -0xc(%ebp)
    3efb:	50                   	push   %eax
    3efc:	e8 54 ff ff ff       	call   3e55 <lodepng_buffer_file>
    3f01:	83 c4 10             	add    $0x10,%esp
}
    3f04:	c9                   	leave  
    3f05:	c3                   	ret    

00003f06 <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    3f06:	55                   	push   %ebp
    3f07:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    3f09:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3f0e:	5d                   	pop    %ebp
    3f0f:	c3                   	ret    

00003f10 <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    3f10:	55                   	push   %ebp
    3f11:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    3f13:	8b 45 08             	mov    0x8(%ebp),%eax
    3f16:	8b 55 0c             	mov    0xc(%ebp),%edx
    3f19:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    3f1b:	8b 45 08             	mov    0x8(%ebp),%eax
    3f1e:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    3f22:	90                   	nop
    3f23:	5d                   	pop    %ebp
    3f24:	c3                   	ret    

00003f25 <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3f25:	55                   	push   %ebp
    3f26:	89 e5                	mov    %esp,%ebp
    3f28:	56                   	push   %esi
    3f29:	53                   	push   %ebx
    3f2a:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    3f2d:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    3f31:	0f 85 aa 00 00 00    	jne    3fe1 <writeBits+0xbc>
    WRITEBIT(writer, value);
    3f37:	8b 45 08             	mov    0x8(%ebp),%eax
    3f3a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3f3e:	0f b6 c0             	movzbl %al,%eax
    3f41:	83 e0 07             	and    $0x7,%eax
    3f44:	85 c0                	test   %eax,%eax
    3f46:	75 39                	jne    3f81 <writeBits+0x5c>
    3f48:	8b 45 08             	mov    0x8(%ebp),%eax
    3f4b:	8b 00                	mov    (%eax),%eax
    3f4d:	8b 40 04             	mov    0x4(%eax),%eax
    3f50:	8d 50 01             	lea    0x1(%eax),%edx
    3f53:	8b 45 08             	mov    0x8(%ebp),%eax
    3f56:	8b 00                	mov    (%eax),%eax
    3f58:	52                   	push   %edx
    3f59:	50                   	push   %eax
    3f5a:	e8 38 fd ff ff       	call   3c97 <ucvector_resize>
    3f5f:	83 c4 08             	add    $0x8,%esp
    3f62:	85 c0                	test   %eax,%eax
    3f64:	0f 84 44 01 00 00    	je     40ae <writeBits+0x189>
    3f6a:	8b 45 08             	mov    0x8(%ebp),%eax
    3f6d:	8b 00                	mov    (%eax),%eax
    3f6f:	8b 10                	mov    (%eax),%edx
    3f71:	8b 45 08             	mov    0x8(%ebp),%eax
    3f74:	8b 00                	mov    (%eax),%eax
    3f76:	8b 40 04             	mov    0x4(%eax),%eax
    3f79:	83 e8 01             	sub    $0x1,%eax
    3f7c:	01 d0                	add    %edx,%eax
    3f7e:	c6 00 00             	movb   $0x0,(%eax)
    3f81:	8b 45 08             	mov    0x8(%ebp),%eax
    3f84:	8b 00                	mov    (%eax),%eax
    3f86:	8b 10                	mov    (%eax),%edx
    3f88:	8b 45 08             	mov    0x8(%ebp),%eax
    3f8b:	8b 00                	mov    (%eax),%eax
    3f8d:	8b 40 04             	mov    0x4(%eax),%eax
    3f90:	83 e8 01             	sub    $0x1,%eax
    3f93:	01 c2                	add    %eax,%edx
    3f95:	8b 45 08             	mov    0x8(%ebp),%eax
    3f98:	8b 00                	mov    (%eax),%eax
    3f9a:	8b 08                	mov    (%eax),%ecx
    3f9c:	8b 45 08             	mov    0x8(%ebp),%eax
    3f9f:	8b 00                	mov    (%eax),%eax
    3fa1:	8b 40 04             	mov    0x4(%eax),%eax
    3fa4:	83 e8 01             	sub    $0x1,%eax
    3fa7:	01 c8                	add    %ecx,%eax
    3fa9:	0f b6 00             	movzbl (%eax),%eax
    3fac:	88 45 e7             	mov    %al,-0x19(%ebp)
    3faf:	8b 45 08             	mov    0x8(%ebp),%eax
    3fb2:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3fb6:	0f b6 c0             	movzbl %al,%eax
    3fb9:	83 e0 07             	and    $0x7,%eax
    3fbc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3fbf:	89 de                	mov    %ebx,%esi
    3fc1:	89 c1                	mov    %eax,%ecx
    3fc3:	d3 e6                	shl    %cl,%esi
    3fc5:	89 f0                	mov    %esi,%eax
    3fc7:	0a 45 e7             	or     -0x19(%ebp),%al
    3fca:	88 02                	mov    %al,(%edx)
    3fcc:	8b 45 08             	mov    0x8(%ebp),%eax
    3fcf:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3fd3:	8d 50 01             	lea    0x1(%eax),%edx
    3fd6:	8b 45 08             	mov    0x8(%ebp),%eax
    3fd9:	88 50 04             	mov    %dl,0x4(%eax)
    3fdc:	e9 d1 00 00 00       	jmp    40b2 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3fe1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3fe8:	e9 b3 00 00 00       	jmp    40a0 <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3fed:	8b 45 08             	mov    0x8(%ebp),%eax
    3ff0:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3ff4:	0f b6 c0             	movzbl %al,%eax
    3ff7:	83 e0 07             	and    $0x7,%eax
    3ffa:	85 c0                	test   %eax,%eax
    3ffc:	75 39                	jne    4037 <writeBits+0x112>
    3ffe:	8b 45 08             	mov    0x8(%ebp),%eax
    4001:	8b 00                	mov    (%eax),%eax
    4003:	8b 40 04             	mov    0x4(%eax),%eax
    4006:	8d 50 01             	lea    0x1(%eax),%edx
    4009:	8b 45 08             	mov    0x8(%ebp),%eax
    400c:	8b 00                	mov    (%eax),%eax
    400e:	52                   	push   %edx
    400f:	50                   	push   %eax
    4010:	e8 82 fc ff ff       	call   3c97 <ucvector_resize>
    4015:	83 c4 08             	add    $0x8,%esp
    4018:	85 c0                	test   %eax,%eax
    401a:	0f 84 91 00 00 00    	je     40b1 <writeBits+0x18c>
    4020:	8b 45 08             	mov    0x8(%ebp),%eax
    4023:	8b 00                	mov    (%eax),%eax
    4025:	8b 10                	mov    (%eax),%edx
    4027:	8b 45 08             	mov    0x8(%ebp),%eax
    402a:	8b 00                	mov    (%eax),%eax
    402c:	8b 40 04             	mov    0x4(%eax),%eax
    402f:	83 e8 01             	sub    $0x1,%eax
    4032:	01 d0                	add    %edx,%eax
    4034:	c6 00 00             	movb   $0x0,(%eax)
    4037:	8b 45 08             	mov    0x8(%ebp),%eax
    403a:	8b 00                	mov    (%eax),%eax
    403c:	8b 10                	mov    (%eax),%edx
    403e:	8b 45 08             	mov    0x8(%ebp),%eax
    4041:	8b 00                	mov    (%eax),%eax
    4043:	8b 40 04             	mov    0x4(%eax),%eax
    4046:	83 e8 01             	sub    $0x1,%eax
    4049:	01 c2                	add    %eax,%edx
    404b:	8b 45 08             	mov    0x8(%ebp),%eax
    404e:	8b 00                	mov    (%eax),%eax
    4050:	8b 08                	mov    (%eax),%ecx
    4052:	8b 45 08             	mov    0x8(%ebp),%eax
    4055:	8b 00                	mov    (%eax),%eax
    4057:	8b 40 04             	mov    0x4(%eax),%eax
    405a:	83 e8 01             	sub    $0x1,%eax
    405d:	01 c8                	add    %ecx,%eax
    405f:	0f b6 00             	movzbl (%eax),%eax
    4062:	89 c6                	mov    %eax,%esi
    4064:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4067:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    406a:	89 c1                	mov    %eax,%ecx
    406c:	d3 eb                	shr    %cl,%ebx
    406e:	89 d8                	mov    %ebx,%eax
    4070:	83 e0 01             	and    $0x1,%eax
    4073:	89 c3                	mov    %eax,%ebx
    4075:	8b 45 08             	mov    0x8(%ebp),%eax
    4078:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    407c:	0f b6 c0             	movzbl %al,%eax
    407f:	83 e0 07             	and    $0x7,%eax
    4082:	89 c1                	mov    %eax,%ecx
    4084:	d3 e3                	shl    %cl,%ebx
    4086:	89 d8                	mov    %ebx,%eax
    4088:	09 f0                	or     %esi,%eax
    408a:	88 02                	mov    %al,(%edx)
    408c:	8b 45 08             	mov    0x8(%ebp),%eax
    408f:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4093:	8d 50 01             	lea    0x1(%eax),%edx
    4096:	8b 45 08             	mov    0x8(%ebp),%eax
    4099:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    409c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    40a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    40a3:	3b 45 10             	cmp    0x10(%ebp),%eax
    40a6:	0f 85 41 ff ff ff    	jne    3fed <writeBits+0xc8>
    40ac:	eb 04                	jmp    40b2 <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    40ae:	90                   	nop
    40af:	eb 01                	jmp    40b2 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    40b1:	90                   	nop
    }
  }
}
    40b2:	8d 65 f8             	lea    -0x8(%ebp),%esp
    40b5:	5b                   	pop    %ebx
    40b6:	5e                   	pop    %esi
    40b7:	5d                   	pop    %ebp
    40b8:	c3                   	ret    

000040b9 <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    40b9:	55                   	push   %ebp
    40ba:	89 e5                	mov    %esp,%ebp
    40bc:	56                   	push   %esi
    40bd:	53                   	push   %ebx
    40be:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    40c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    40c8:	e9 bd 00 00 00       	jmp    418a <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    40cd:	8b 45 08             	mov    0x8(%ebp),%eax
    40d0:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    40d4:	0f b6 c0             	movzbl %al,%eax
    40d7:	83 e0 07             	and    $0x7,%eax
    40da:	85 c0                	test   %eax,%eax
    40dc:	75 39                	jne    4117 <writeBitsReversed+0x5e>
    40de:	8b 45 08             	mov    0x8(%ebp),%eax
    40e1:	8b 00                	mov    (%eax),%eax
    40e3:	8b 40 04             	mov    0x4(%eax),%eax
    40e6:	8d 50 01             	lea    0x1(%eax),%edx
    40e9:	8b 45 08             	mov    0x8(%ebp),%eax
    40ec:	8b 00                	mov    (%eax),%eax
    40ee:	52                   	push   %edx
    40ef:	50                   	push   %eax
    40f0:	e8 a2 fb ff ff       	call   3c97 <ucvector_resize>
    40f5:	83 c4 08             	add    $0x8,%esp
    40f8:	85 c0                	test   %eax,%eax
    40fa:	0f 84 98 00 00 00    	je     4198 <writeBitsReversed+0xdf>
    4100:	8b 45 08             	mov    0x8(%ebp),%eax
    4103:	8b 00                	mov    (%eax),%eax
    4105:	8b 10                	mov    (%eax),%edx
    4107:	8b 45 08             	mov    0x8(%ebp),%eax
    410a:	8b 00                	mov    (%eax),%eax
    410c:	8b 40 04             	mov    0x4(%eax),%eax
    410f:	83 e8 01             	sub    $0x1,%eax
    4112:	01 d0                	add    %edx,%eax
    4114:	c6 00 00             	movb   $0x0,(%eax)
    4117:	8b 45 08             	mov    0x8(%ebp),%eax
    411a:	8b 00                	mov    (%eax),%eax
    411c:	8b 10                	mov    (%eax),%edx
    411e:	8b 45 08             	mov    0x8(%ebp),%eax
    4121:	8b 00                	mov    (%eax),%eax
    4123:	8b 40 04             	mov    0x4(%eax),%eax
    4126:	83 e8 01             	sub    $0x1,%eax
    4129:	01 c2                	add    %eax,%edx
    412b:	8b 45 08             	mov    0x8(%ebp),%eax
    412e:	8b 00                	mov    (%eax),%eax
    4130:	8b 08                	mov    (%eax),%ecx
    4132:	8b 45 08             	mov    0x8(%ebp),%eax
    4135:	8b 00                	mov    (%eax),%eax
    4137:	8b 40 04             	mov    0x4(%eax),%eax
    413a:	83 e8 01             	sub    $0x1,%eax
    413d:	01 c8                	add    %ecx,%eax
    413f:	0f b6 00             	movzbl (%eax),%eax
    4142:	89 c6                	mov    %eax,%esi
    4144:	8b 4d 10             	mov    0x10(%ebp),%ecx
    4147:	8b 45 f4             	mov    -0xc(%ebp),%eax
    414a:	29 c1                	sub    %eax,%ecx
    414c:	89 c8                	mov    %ecx,%eax
    414e:	83 e8 01             	sub    $0x1,%eax
    4151:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    4154:	89 c1                	mov    %eax,%ecx
    4156:	d3 eb                	shr    %cl,%ebx
    4158:	89 d8                	mov    %ebx,%eax
    415a:	83 e0 01             	and    $0x1,%eax
    415d:	89 c3                	mov    %eax,%ebx
    415f:	8b 45 08             	mov    0x8(%ebp),%eax
    4162:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4166:	0f b6 c0             	movzbl %al,%eax
    4169:	83 e0 07             	and    $0x7,%eax
    416c:	89 c1                	mov    %eax,%ecx
    416e:	d3 e3                	shl    %cl,%ebx
    4170:	89 d8                	mov    %ebx,%eax
    4172:	09 f0                	or     %esi,%eax
    4174:	88 02                	mov    %al,(%edx)
    4176:	8b 45 08             	mov    0x8(%ebp),%eax
    4179:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    417d:	8d 50 01             	lea    0x1(%eax),%edx
    4180:	8b 45 08             	mov    0x8(%ebp),%eax
    4183:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    4186:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    418a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    418d:	3b 45 10             	cmp    0x10(%ebp),%eax
    4190:	0f 85 37 ff ff ff    	jne    40cd <writeBitsReversed+0x14>
    4196:	eb 01                	jmp    4199 <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    4198:	90                   	nop
  }
}
    4199:	8d 65 f8             	lea    -0x8(%ebp),%esp
    419c:	5b                   	pop    %ebx
    419d:	5e                   	pop    %esi
    419e:	5d                   	pop    %ebp
    419f:	c3                   	ret    

000041a0 <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    41a0:	55                   	push   %ebp
    41a1:	89 e5                	mov    %esp,%ebp
    41a3:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    41a6:	8b 45 08             	mov    0x8(%ebp),%eax
    41a9:	8b 55 0c             	mov    0xc(%ebp),%edx
    41ac:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    41ae:	8b 45 08             	mov    0x8(%ebp),%eax
    41b1:	8b 55 10             	mov    0x10(%ebp),%edx
    41b4:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    41b7:	8b 45 08             	mov    0x8(%ebp),%eax
    41ba:	83 c0 08             	add    $0x8,%eax
    41bd:	50                   	push   %eax
    41be:	6a 08                	push   $0x8
    41c0:	ff 75 10             	pushl  0x10(%ebp)
    41c3:	e8 59 f9 ff ff       	call   3b21 <lodepng_mulofl>
    41c8:	83 c4 0c             	add    $0xc,%esp
    41cb:	85 c0                	test   %eax,%eax
    41cd:	74 07                	je     41d6 <LodePNGBitReader_init+0x36>
    41cf:	b8 69 00 00 00       	mov    $0x69,%eax
    41d4:	eb 39                	jmp    420f <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    41d6:	8b 45 08             	mov    0x8(%ebp),%eax
    41d9:	8b 40 08             	mov    0x8(%eax),%eax
    41dc:	8d 55 fc             	lea    -0x4(%ebp),%edx
    41df:	52                   	push   %edx
    41e0:	6a 40                	push   $0x40
    41e2:	50                   	push   %eax
    41e3:	e8 19 f9 ff ff       	call   3b01 <lodepng_addofl>
    41e8:	83 c4 0c             	add    $0xc,%esp
    41eb:	85 c0                	test   %eax,%eax
    41ed:	74 07                	je     41f6 <LodePNGBitReader_init+0x56>
    41ef:	b8 69 00 00 00       	mov    $0x69,%eax
    41f4:	eb 19                	jmp    420f <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    41f6:	8b 45 08             	mov    0x8(%ebp),%eax
    41f9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    4200:	8b 45 08             	mov    0x8(%ebp),%eax
    4203:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    420a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    420f:	c9                   	leave  
    4210:	c3                   	ret    

00004211 <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    4211:	55                   	push   %ebp
    4212:	89 e5                	mov    %esp,%ebp
    4214:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4217:	8b 45 08             	mov    0x8(%ebp),%eax
    421a:	8b 40 0c             	mov    0xc(%eax),%eax
    421d:	c1 f8 03             	sar    $0x3,%eax
    4220:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    4223:	8b 45 08             	mov    0x8(%ebp),%eax
    4226:	8b 40 04             	mov    0x4(%eax),%eax
    4229:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    422c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    422f:	8d 50 01             	lea    0x1(%eax),%edx
    4232:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4235:	39 c2                	cmp    %eax,%edx
    4237:	73 4e                	jae    4287 <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    4239:	8b 45 08             	mov    0x8(%ebp),%eax
    423c:	8b 10                	mov    (%eax),%edx
    423e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4241:	01 d0                	add    %edx,%eax
    4243:	0f b6 00             	movzbl (%eax),%eax
    4246:	0f b6 d0             	movzbl %al,%edx
    4249:	8b 45 08             	mov    0x8(%ebp),%eax
    424c:	8b 00                	mov    (%eax),%eax
    424e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4251:	83 c1 01             	add    $0x1,%ecx
    4254:	01 c8                	add    %ecx,%eax
    4256:	0f b6 00             	movzbl (%eax),%eax
    4259:	0f b6 c0             	movzbl %al,%eax
    425c:	c1 e0 08             	shl    $0x8,%eax
    425f:	09 c2                	or     %eax,%edx
    4261:	8b 45 08             	mov    0x8(%ebp),%eax
    4264:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4267:	8b 45 08             	mov    0x8(%ebp),%eax
    426a:	8b 50 10             	mov    0x10(%eax),%edx
    426d:	8b 45 08             	mov    0x8(%ebp),%eax
    4270:	8b 40 0c             	mov    0xc(%eax),%eax
    4273:	83 e0 07             	and    $0x7,%eax
    4276:	89 c1                	mov    %eax,%ecx
    4278:	d3 ea                	shr    %cl,%edx
    427a:	8b 45 08             	mov    0x8(%ebp),%eax
    427d:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    4280:	b8 01 00 00 00       	mov    $0x1,%eax
    4285:	eb 64                	jmp    42eb <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    4287:	8b 45 08             	mov    0x8(%ebp),%eax
    428a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    4291:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4294:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4297:	39 c2                	cmp    %eax,%edx
    4299:	73 1e                	jae    42b9 <ensureBits9+0xa8>
    429b:	8b 45 08             	mov    0x8(%ebp),%eax
    429e:	8b 50 10             	mov    0x10(%eax),%edx
    42a1:	8b 45 08             	mov    0x8(%ebp),%eax
    42a4:	8b 08                	mov    (%eax),%ecx
    42a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    42a9:	01 c8                	add    %ecx,%eax
    42ab:	0f b6 00             	movzbl (%eax),%eax
    42ae:	0f b6 c0             	movzbl %al,%eax
    42b1:	09 c2                	or     %eax,%edx
    42b3:	8b 45 08             	mov    0x8(%ebp),%eax
    42b6:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    42b9:	8b 45 08             	mov    0x8(%ebp),%eax
    42bc:	8b 50 10             	mov    0x10(%eax),%edx
    42bf:	8b 45 08             	mov    0x8(%ebp),%eax
    42c2:	8b 40 0c             	mov    0xc(%eax),%eax
    42c5:	83 e0 07             	and    $0x7,%eax
    42c8:	89 c1                	mov    %eax,%ecx
    42ca:	d3 ea                	shr    %cl,%edx
    42cc:	8b 45 08             	mov    0x8(%ebp),%eax
    42cf:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    42d2:	8b 45 08             	mov    0x8(%ebp),%eax
    42d5:	8b 50 0c             	mov    0xc(%eax),%edx
    42d8:	8b 45 0c             	mov    0xc(%ebp),%eax
    42db:	01 c2                	add    %eax,%edx
    42dd:	8b 45 08             	mov    0x8(%ebp),%eax
    42e0:	8b 40 08             	mov    0x8(%eax),%eax
    42e3:	39 c2                	cmp    %eax,%edx
    42e5:	0f 9e c0             	setle  %al
    42e8:	0f b6 c0             	movzbl %al,%eax
  }
}
    42eb:	c9                   	leave  
    42ec:	c3                   	ret    

000042ed <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    42ed:	55                   	push   %ebp
    42ee:	89 e5                	mov    %esp,%ebp
    42f0:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    42f3:	8b 45 08             	mov    0x8(%ebp),%eax
    42f6:	8b 40 0c             	mov    0xc(%eax),%eax
    42f9:	c1 f8 03             	sar    $0x3,%eax
    42fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    42ff:	8b 45 08             	mov    0x8(%ebp),%eax
    4302:	8b 40 04             	mov    0x4(%eax),%eax
    4305:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    4308:	8b 45 fc             	mov    -0x4(%ebp),%eax
    430b:	8d 50 02             	lea    0x2(%eax),%edx
    430e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4311:	39 c2                	cmp    %eax,%edx
    4313:	73 6d                	jae    4382 <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4315:	8b 45 08             	mov    0x8(%ebp),%eax
    4318:	8b 10                	mov    (%eax),%edx
    431a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    431d:	01 d0                	add    %edx,%eax
    431f:	0f b6 00             	movzbl (%eax),%eax
    4322:	0f b6 d0             	movzbl %al,%edx
    4325:	8b 45 08             	mov    0x8(%ebp),%eax
    4328:	8b 00                	mov    (%eax),%eax
    432a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    432d:	83 c1 01             	add    $0x1,%ecx
    4330:	01 c8                	add    %ecx,%eax
    4332:	0f b6 00             	movzbl (%eax),%eax
    4335:	0f b6 c0             	movzbl %al,%eax
    4338:	c1 e0 08             	shl    $0x8,%eax
    433b:	89 d1                	mov    %edx,%ecx
    433d:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    433f:	8b 45 08             	mov    0x8(%ebp),%eax
    4342:	8b 00                	mov    (%eax),%eax
    4344:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4347:	83 c2 02             	add    $0x2,%edx
    434a:	01 d0                	add    %edx,%eax
    434c:	0f b6 00             	movzbl (%eax),%eax
    434f:	0f b6 c0             	movzbl %al,%eax
    4352:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4355:	09 c1                	or     %eax,%ecx
    4357:	89 ca                	mov    %ecx,%edx
    4359:	8b 45 08             	mov    0x8(%ebp),%eax
    435c:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    435f:	8b 45 08             	mov    0x8(%ebp),%eax
    4362:	8b 50 10             	mov    0x10(%eax),%edx
    4365:	8b 45 08             	mov    0x8(%ebp),%eax
    4368:	8b 40 0c             	mov    0xc(%eax),%eax
    436b:	83 e0 07             	and    $0x7,%eax
    436e:	89 c1                	mov    %eax,%ecx
    4370:	d3 ea                	shr    %cl,%edx
    4372:	8b 45 08             	mov    0x8(%ebp),%eax
    4375:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    4378:	b8 01 00 00 00       	mov    $0x1,%eax
    437d:	e9 95 00 00 00       	jmp    4417 <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    4382:	8b 45 08             	mov    0x8(%ebp),%eax
    4385:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    438c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    438f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4392:	39 c2                	cmp    %eax,%edx
    4394:	73 1e                	jae    43b4 <ensureBits17+0xc7>
    4396:	8b 45 08             	mov    0x8(%ebp),%eax
    4399:	8b 50 10             	mov    0x10(%eax),%edx
    439c:	8b 45 08             	mov    0x8(%ebp),%eax
    439f:	8b 08                	mov    (%eax),%ecx
    43a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    43a4:	01 c8                	add    %ecx,%eax
    43a6:	0f b6 00             	movzbl (%eax),%eax
    43a9:	0f b6 c0             	movzbl %al,%eax
    43ac:	09 c2                	or     %eax,%edx
    43ae:	8b 45 08             	mov    0x8(%ebp),%eax
    43b1:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    43b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    43b7:	8d 50 01             	lea    0x1(%eax),%edx
    43ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
    43bd:	39 c2                	cmp    %eax,%edx
    43bf:	73 24                	jae    43e5 <ensureBits17+0xf8>
    43c1:	8b 45 08             	mov    0x8(%ebp),%eax
    43c4:	8b 50 10             	mov    0x10(%eax),%edx
    43c7:	8b 45 08             	mov    0x8(%ebp),%eax
    43ca:	8b 00                	mov    (%eax),%eax
    43cc:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    43cf:	83 c1 01             	add    $0x1,%ecx
    43d2:	01 c8                	add    %ecx,%eax
    43d4:	0f b6 00             	movzbl (%eax),%eax
    43d7:	0f b6 c0             	movzbl %al,%eax
    43da:	c1 e0 08             	shl    $0x8,%eax
    43dd:	09 c2                	or     %eax,%edx
    43df:	8b 45 08             	mov    0x8(%ebp),%eax
    43e2:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    43e5:	8b 45 08             	mov    0x8(%ebp),%eax
    43e8:	8b 50 10             	mov    0x10(%eax),%edx
    43eb:	8b 45 08             	mov    0x8(%ebp),%eax
    43ee:	8b 40 0c             	mov    0xc(%eax),%eax
    43f1:	83 e0 07             	and    $0x7,%eax
    43f4:	89 c1                	mov    %eax,%ecx
    43f6:	d3 ea                	shr    %cl,%edx
    43f8:	8b 45 08             	mov    0x8(%ebp),%eax
    43fb:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    43fe:	8b 45 08             	mov    0x8(%ebp),%eax
    4401:	8b 50 0c             	mov    0xc(%eax),%edx
    4404:	8b 45 0c             	mov    0xc(%ebp),%eax
    4407:	01 c2                	add    %eax,%edx
    4409:	8b 45 08             	mov    0x8(%ebp),%eax
    440c:	8b 40 08             	mov    0x8(%eax),%eax
    440f:	39 c2                	cmp    %eax,%edx
    4411:	0f 9e c0             	setle  %al
    4414:	0f b6 c0             	movzbl %al,%eax
  }
}
    4417:	c9                   	leave  
    4418:	c3                   	ret    

00004419 <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    4419:	55                   	push   %ebp
    441a:	89 e5                	mov    %esp,%ebp
    441c:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    441f:	8b 45 08             	mov    0x8(%ebp),%eax
    4422:	8b 40 0c             	mov    0xc(%eax),%eax
    4425:	c1 f8 03             	sar    $0x3,%eax
    4428:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    442b:	8b 45 08             	mov    0x8(%ebp),%eax
    442e:	8b 40 04             	mov    0x4(%eax),%eax
    4431:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    4434:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4437:	8d 50 03             	lea    0x3(%eax),%edx
    443a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    443d:	39 c2                	cmp    %eax,%edx
    443f:	0f 83 85 00 00 00    	jae    44ca <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4445:	8b 45 08             	mov    0x8(%ebp),%eax
    4448:	8b 10                	mov    (%eax),%edx
    444a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    444d:	01 d0                	add    %edx,%eax
    444f:	0f b6 00             	movzbl (%eax),%eax
    4452:	0f b6 d0             	movzbl %al,%edx
    4455:	8b 45 08             	mov    0x8(%ebp),%eax
    4458:	8b 00                	mov    (%eax),%eax
    445a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    445d:	83 c1 01             	add    $0x1,%ecx
    4460:	01 c8                	add    %ecx,%eax
    4462:	0f b6 00             	movzbl (%eax),%eax
    4465:	0f b6 c0             	movzbl %al,%eax
    4468:	c1 e0 08             	shl    $0x8,%eax
    446b:	89 d1                	mov    %edx,%ecx
    446d:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    446f:	8b 45 08             	mov    0x8(%ebp),%eax
    4472:	8b 00                	mov    (%eax),%eax
    4474:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4477:	83 c2 02             	add    $0x2,%edx
    447a:	01 d0                	add    %edx,%eax
    447c:	0f b6 00             	movzbl (%eax),%eax
    447f:	0f b6 c0             	movzbl %al,%eax
    4482:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4485:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4487:	8b 45 08             	mov    0x8(%ebp),%eax
    448a:	8b 00                	mov    (%eax),%eax
    448c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    448f:	83 c2 03             	add    $0x3,%edx
    4492:	01 d0                	add    %edx,%eax
    4494:	0f b6 00             	movzbl (%eax),%eax
    4497:	0f b6 c0             	movzbl %al,%eax
    449a:	c1 e0 18             	shl    $0x18,%eax
    449d:	09 c1                	or     %eax,%ecx
    449f:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    44a1:	8b 45 08             	mov    0x8(%ebp),%eax
    44a4:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    44a7:	8b 45 08             	mov    0x8(%ebp),%eax
    44aa:	8b 50 10             	mov    0x10(%eax),%edx
    44ad:	8b 45 08             	mov    0x8(%ebp),%eax
    44b0:	8b 40 0c             	mov    0xc(%eax),%eax
    44b3:	83 e0 07             	and    $0x7,%eax
    44b6:	89 c1                	mov    %eax,%ecx
    44b8:	d3 ea                	shr    %cl,%edx
    44ba:	8b 45 08             	mov    0x8(%ebp),%eax
    44bd:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    44c0:	b8 01 00 00 00       	mov    $0x1,%eax
    44c5:	e9 c6 00 00 00       	jmp    4590 <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    44ca:	8b 45 08             	mov    0x8(%ebp),%eax
    44cd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    44d4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    44d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    44da:	39 c2                	cmp    %eax,%edx
    44dc:	73 1e                	jae    44fc <ensureBits25+0xe3>
    44de:	8b 45 08             	mov    0x8(%ebp),%eax
    44e1:	8b 50 10             	mov    0x10(%eax),%edx
    44e4:	8b 45 08             	mov    0x8(%ebp),%eax
    44e7:	8b 08                	mov    (%eax),%ecx
    44e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    44ec:	01 c8                	add    %ecx,%eax
    44ee:	0f b6 00             	movzbl (%eax),%eax
    44f1:	0f b6 c0             	movzbl %al,%eax
    44f4:	09 c2                	or     %eax,%edx
    44f6:	8b 45 08             	mov    0x8(%ebp),%eax
    44f9:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    44fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    44ff:	8d 50 01             	lea    0x1(%eax),%edx
    4502:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4505:	39 c2                	cmp    %eax,%edx
    4507:	73 24                	jae    452d <ensureBits25+0x114>
    4509:	8b 45 08             	mov    0x8(%ebp),%eax
    450c:	8b 50 10             	mov    0x10(%eax),%edx
    450f:	8b 45 08             	mov    0x8(%ebp),%eax
    4512:	8b 00                	mov    (%eax),%eax
    4514:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4517:	83 c1 01             	add    $0x1,%ecx
    451a:	01 c8                	add    %ecx,%eax
    451c:	0f b6 00             	movzbl (%eax),%eax
    451f:	0f b6 c0             	movzbl %al,%eax
    4522:	c1 e0 08             	shl    $0x8,%eax
    4525:	09 c2                	or     %eax,%edx
    4527:	8b 45 08             	mov    0x8(%ebp),%eax
    452a:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    452d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4530:	8d 50 02             	lea    0x2(%eax),%edx
    4533:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4536:	39 c2                	cmp    %eax,%edx
    4538:	73 24                	jae    455e <ensureBits25+0x145>
    453a:	8b 45 08             	mov    0x8(%ebp),%eax
    453d:	8b 50 10             	mov    0x10(%eax),%edx
    4540:	8b 45 08             	mov    0x8(%ebp),%eax
    4543:	8b 00                	mov    (%eax),%eax
    4545:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4548:	83 c1 02             	add    $0x2,%ecx
    454b:	01 c8                	add    %ecx,%eax
    454d:	0f b6 00             	movzbl (%eax),%eax
    4550:	0f b6 c0             	movzbl %al,%eax
    4553:	c1 e0 10             	shl    $0x10,%eax
    4556:	09 c2                	or     %eax,%edx
    4558:	8b 45 08             	mov    0x8(%ebp),%eax
    455b:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    455e:	8b 45 08             	mov    0x8(%ebp),%eax
    4561:	8b 50 10             	mov    0x10(%eax),%edx
    4564:	8b 45 08             	mov    0x8(%ebp),%eax
    4567:	8b 40 0c             	mov    0xc(%eax),%eax
    456a:	83 e0 07             	and    $0x7,%eax
    456d:	89 c1                	mov    %eax,%ecx
    456f:	d3 ea                	shr    %cl,%edx
    4571:	8b 45 08             	mov    0x8(%ebp),%eax
    4574:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4577:	8b 45 08             	mov    0x8(%ebp),%eax
    457a:	8b 50 0c             	mov    0xc(%eax),%edx
    457d:	8b 45 0c             	mov    0xc(%ebp),%eax
    4580:	01 c2                	add    %eax,%edx
    4582:	8b 45 08             	mov    0x8(%ebp),%eax
    4585:	8b 40 08             	mov    0x8(%eax),%eax
    4588:	39 c2                	cmp    %eax,%edx
    458a:	0f 9e c0             	setle  %al
    458d:	0f b6 c0             	movzbl %al,%eax
  }
}
    4590:	c9                   	leave  
    4591:	c3                   	ret    

00004592 <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    4592:	55                   	push   %ebp
    4593:	89 e5                	mov    %esp,%ebp
    4595:	53                   	push   %ebx
    4596:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4599:	8b 45 08             	mov    0x8(%ebp),%eax
    459c:	8b 40 0c             	mov    0xc(%eax),%eax
    459f:	c1 f8 03             	sar    $0x3,%eax
    45a2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    45a5:	8b 45 08             	mov    0x8(%ebp),%eax
    45a8:	8b 40 04             	mov    0x4(%eax),%eax
    45ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    45ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    45b1:	8d 50 04             	lea    0x4(%eax),%edx
    45b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    45b7:	39 c2                	cmp    %eax,%edx
    45b9:	0f 83 c3 00 00 00    	jae    4682 <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    45bf:	8b 45 08             	mov    0x8(%ebp),%eax
    45c2:	8b 10                	mov    (%eax),%edx
    45c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    45c7:	01 d0                	add    %edx,%eax
    45c9:	0f b6 00             	movzbl (%eax),%eax
    45cc:	0f b6 d0             	movzbl %al,%edx
    45cf:	8b 45 08             	mov    0x8(%ebp),%eax
    45d2:	8b 00                	mov    (%eax),%eax
    45d4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    45d7:	83 c1 01             	add    $0x1,%ecx
    45da:	01 c8                	add    %ecx,%eax
    45dc:	0f b6 00             	movzbl (%eax),%eax
    45df:	0f b6 c0             	movzbl %al,%eax
    45e2:	c1 e0 08             	shl    $0x8,%eax
    45e5:	89 d1                	mov    %edx,%ecx
    45e7:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    45e9:	8b 45 08             	mov    0x8(%ebp),%eax
    45ec:	8b 00                	mov    (%eax),%eax
    45ee:	8b 55 f8             	mov    -0x8(%ebp),%edx
    45f1:	83 c2 02             	add    $0x2,%edx
    45f4:	01 d0                	add    %edx,%eax
    45f6:	0f b6 00             	movzbl (%eax),%eax
    45f9:	0f b6 c0             	movzbl %al,%eax
    45fc:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    45ff:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4601:	8b 45 08             	mov    0x8(%ebp),%eax
    4604:	8b 00                	mov    (%eax),%eax
    4606:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4609:	83 c2 03             	add    $0x3,%edx
    460c:	01 d0                	add    %edx,%eax
    460e:	0f b6 00             	movzbl (%eax),%eax
    4611:	0f b6 c0             	movzbl %al,%eax
    4614:	c1 e0 18             	shl    $0x18,%eax
    4617:	09 c1                	or     %eax,%ecx
    4619:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    461b:	8b 45 08             	mov    0x8(%ebp),%eax
    461e:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    4621:	8b 45 08             	mov    0x8(%ebp),%eax
    4624:	8b 50 10             	mov    0x10(%eax),%edx
    4627:	8b 45 08             	mov    0x8(%ebp),%eax
    462a:	8b 40 0c             	mov    0xc(%eax),%eax
    462d:	83 e0 07             	and    $0x7,%eax
    4630:	89 c1                	mov    %eax,%ecx
    4632:	d3 ea                	shr    %cl,%edx
    4634:	8b 45 08             	mov    0x8(%ebp),%eax
    4637:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    463a:	8b 45 08             	mov    0x8(%ebp),%eax
    463d:	8b 50 10             	mov    0x10(%eax),%edx
    4640:	8b 45 08             	mov    0x8(%ebp),%eax
    4643:	8b 00                	mov    (%eax),%eax
    4645:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4648:	83 c1 04             	add    $0x4,%ecx
    464b:	01 c8                	add    %ecx,%eax
    464d:	0f b6 00             	movzbl (%eax),%eax
    4650:	0f b6 c0             	movzbl %al,%eax
    4653:	c1 e0 18             	shl    $0x18,%eax
    4656:	89 c3                	mov    %eax,%ebx
    4658:	8b 45 08             	mov    0x8(%ebp),%eax
    465b:	8b 40 0c             	mov    0xc(%eax),%eax
    465e:	83 e0 07             	and    $0x7,%eax
    4661:	b9 08 00 00 00       	mov    $0x8,%ecx
    4666:	29 c1                	sub    %eax,%ecx
    4668:	89 c8                	mov    %ecx,%eax
    466a:	89 c1                	mov    %eax,%ecx
    466c:	d3 e3                	shl    %cl,%ebx
    466e:	89 d8                	mov    %ebx,%eax
    4670:	09 c2                	or     %eax,%edx
    4672:	8b 45 08             	mov    0x8(%ebp),%eax
    4675:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    4678:	b8 01 00 00 00       	mov    $0x1,%eax
    467d:	e9 f7 00 00 00       	jmp    4779 <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    4682:	8b 45 08             	mov    0x8(%ebp),%eax
    4685:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    468c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    468f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4692:	39 c2                	cmp    %eax,%edx
    4694:	73 1e                	jae    46b4 <ensureBits32+0x122>
    4696:	8b 45 08             	mov    0x8(%ebp),%eax
    4699:	8b 50 10             	mov    0x10(%eax),%edx
    469c:	8b 45 08             	mov    0x8(%ebp),%eax
    469f:	8b 08                	mov    (%eax),%ecx
    46a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    46a4:	01 c8                	add    %ecx,%eax
    46a6:	0f b6 00             	movzbl (%eax),%eax
    46a9:	0f b6 c0             	movzbl %al,%eax
    46ac:	09 c2                	or     %eax,%edx
    46ae:	8b 45 08             	mov    0x8(%ebp),%eax
    46b1:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    46b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    46b7:	8d 50 01             	lea    0x1(%eax),%edx
    46ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46bd:	39 c2                	cmp    %eax,%edx
    46bf:	73 24                	jae    46e5 <ensureBits32+0x153>
    46c1:	8b 45 08             	mov    0x8(%ebp),%eax
    46c4:	8b 50 10             	mov    0x10(%eax),%edx
    46c7:	8b 45 08             	mov    0x8(%ebp),%eax
    46ca:	8b 00                	mov    (%eax),%eax
    46cc:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    46cf:	83 c1 01             	add    $0x1,%ecx
    46d2:	01 c8                	add    %ecx,%eax
    46d4:	0f b6 00             	movzbl (%eax),%eax
    46d7:	0f b6 c0             	movzbl %al,%eax
    46da:	c1 e0 08             	shl    $0x8,%eax
    46dd:	09 c2                	or     %eax,%edx
    46df:	8b 45 08             	mov    0x8(%ebp),%eax
    46e2:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    46e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    46e8:	8d 50 02             	lea    0x2(%eax),%edx
    46eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46ee:	39 c2                	cmp    %eax,%edx
    46f0:	73 24                	jae    4716 <ensureBits32+0x184>
    46f2:	8b 45 08             	mov    0x8(%ebp),%eax
    46f5:	8b 50 10             	mov    0x10(%eax),%edx
    46f8:	8b 45 08             	mov    0x8(%ebp),%eax
    46fb:	8b 00                	mov    (%eax),%eax
    46fd:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4700:	83 c1 02             	add    $0x2,%ecx
    4703:	01 c8                	add    %ecx,%eax
    4705:	0f b6 00             	movzbl (%eax),%eax
    4708:	0f b6 c0             	movzbl %al,%eax
    470b:	c1 e0 10             	shl    $0x10,%eax
    470e:	09 c2                	or     %eax,%edx
    4710:	8b 45 08             	mov    0x8(%ebp),%eax
    4713:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    4716:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4719:	8d 50 03             	lea    0x3(%eax),%edx
    471c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    471f:	39 c2                	cmp    %eax,%edx
    4721:	73 24                	jae    4747 <ensureBits32+0x1b5>
    4723:	8b 45 08             	mov    0x8(%ebp),%eax
    4726:	8b 50 10             	mov    0x10(%eax),%edx
    4729:	8b 45 08             	mov    0x8(%ebp),%eax
    472c:	8b 00                	mov    (%eax),%eax
    472e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4731:	83 c1 03             	add    $0x3,%ecx
    4734:	01 c8                	add    %ecx,%eax
    4736:	0f b6 00             	movzbl (%eax),%eax
    4739:	0f b6 c0             	movzbl %al,%eax
    473c:	c1 e0 18             	shl    $0x18,%eax
    473f:	09 c2                	or     %eax,%edx
    4741:	8b 45 08             	mov    0x8(%ebp),%eax
    4744:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4747:	8b 45 08             	mov    0x8(%ebp),%eax
    474a:	8b 50 10             	mov    0x10(%eax),%edx
    474d:	8b 45 08             	mov    0x8(%ebp),%eax
    4750:	8b 40 0c             	mov    0xc(%eax),%eax
    4753:	83 e0 07             	and    $0x7,%eax
    4756:	89 c1                	mov    %eax,%ecx
    4758:	d3 ea                	shr    %cl,%edx
    475a:	8b 45 08             	mov    0x8(%ebp),%eax
    475d:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4760:	8b 45 08             	mov    0x8(%ebp),%eax
    4763:	8b 50 0c             	mov    0xc(%eax),%edx
    4766:	8b 45 0c             	mov    0xc(%ebp),%eax
    4769:	01 c2                	add    %eax,%edx
    476b:	8b 45 08             	mov    0x8(%ebp),%eax
    476e:	8b 40 08             	mov    0x8(%eax),%eax
    4771:	39 c2                	cmp    %eax,%edx
    4773:	0f 9e c0             	setle  %al
    4776:	0f b6 c0             	movzbl %al,%eax
  }
}
    4779:	83 c4 10             	add    $0x10,%esp
    477c:	5b                   	pop    %ebx
    477d:	5d                   	pop    %ebp
    477e:	c3                   	ret    

0000477f <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    477f:	55                   	push   %ebp
    4780:	89 e5                	mov    %esp,%ebp
    4782:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    4783:	8b 45 08             	mov    0x8(%ebp),%eax
    4786:	8b 50 10             	mov    0x10(%eax),%edx
    4789:	8b 45 0c             	mov    0xc(%ebp),%eax
    478c:	bb 01 00 00 00       	mov    $0x1,%ebx
    4791:	89 c1                	mov    %eax,%ecx
    4793:	d3 e3                	shl    %cl,%ebx
    4795:	89 d8                	mov    %ebx,%eax
    4797:	83 e8 01             	sub    $0x1,%eax
    479a:	21 d0                	and    %edx,%eax
}
    479c:	5b                   	pop    %ebx
    479d:	5d                   	pop    %ebp
    479e:	c3                   	ret    

0000479f <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    479f:	55                   	push   %ebp
    47a0:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    47a2:	8b 45 08             	mov    0x8(%ebp),%eax
    47a5:	8b 50 10             	mov    0x10(%eax),%edx
    47a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    47ab:	89 c1                	mov    %eax,%ecx
    47ad:	d3 ea                	shr    %cl,%edx
    47af:	8b 45 08             	mov    0x8(%ebp),%eax
    47b2:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    47b5:	8b 45 08             	mov    0x8(%ebp),%eax
    47b8:	8b 50 0c             	mov    0xc(%eax),%edx
    47bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    47be:	01 c2                	add    %eax,%edx
    47c0:	8b 45 08             	mov    0x8(%ebp),%eax
    47c3:	89 50 0c             	mov    %edx,0xc(%eax)
}
    47c6:	90                   	nop
    47c7:	5d                   	pop    %ebp
    47c8:	c3                   	ret    

000047c9 <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    47c9:	55                   	push   %ebp
    47ca:	89 e5                	mov    %esp,%ebp
    47cc:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    47cf:	ff 75 0c             	pushl  0xc(%ebp)
    47d2:	ff 75 08             	pushl  0x8(%ebp)
    47d5:	e8 a5 ff ff ff       	call   477f <peekBits>
    47da:	83 c4 08             	add    $0x8,%esp
    47dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    47e0:	ff 75 0c             	pushl  0xc(%ebp)
    47e3:	ff 75 08             	pushl  0x8(%ebp)
    47e6:	e8 b4 ff ff ff       	call   479f <advanceBits>
    47eb:	83 c4 08             	add    $0x8,%esp
  return result;
    47ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    47f1:	c9                   	leave  
    47f2:	c3                   	ret    

000047f3 <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    47f3:	55                   	push   %ebp
    47f4:	89 e5                	mov    %esp,%ebp
    47f6:	53                   	push   %ebx
    47f7:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    47fa:	ff 75 0c             	pushl  0xc(%ebp)
    47fd:	ff 75 08             	pushl  0x8(%ebp)
    4800:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4803:	50                   	push   %eax
    4804:	e8 97 f9 ff ff       	call   41a0 <LodePNGBitReader_init>
    4809:	83 c4 0c             	add    $0xc,%esp
    480c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    480f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    4813:	74 0a                	je     481f <lode_png_test_bitreader+0x2c>
    4815:	b8 00 00 00 00       	mov    $0x0,%eax
    481a:	e9 c3 00 00 00       	jmp    48e2 <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    481f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4826:	e9 a6 00 00 00       	jmp    48d1 <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    482b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    482e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4835:	8b 45 14             	mov    0x14(%ebp),%eax
    4838:	01 d0                	add    %edx,%eax
    483a:	8b 00                	mov    (%eax),%eax
    483c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    483f:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    4843:	7e 14                	jle    4859 <lode_png_test_bitreader+0x66>
    4845:	ff 75 ec             	pushl  -0x14(%ebp)
    4848:	8d 45 d8             	lea    -0x28(%ebp),%eax
    484b:	50                   	push   %eax
    484c:	e8 41 fd ff ff       	call   4592 <ensureBits32>
    4851:	83 c4 08             	add    $0x8,%esp
    4854:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4857:	eb 46                	jmp    489f <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    4859:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    485d:	7e 14                	jle    4873 <lode_png_test_bitreader+0x80>
    485f:	ff 75 ec             	pushl  -0x14(%ebp)
    4862:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4865:	50                   	push   %eax
    4866:	e8 ae fb ff ff       	call   4419 <ensureBits25>
    486b:	83 c4 08             	add    $0x8,%esp
    486e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4871:	eb 2c                	jmp    489f <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    4873:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    4877:	7e 14                	jle    488d <lode_png_test_bitreader+0x9a>
    4879:	ff 75 ec             	pushl  -0x14(%ebp)
    487c:	8d 45 d8             	lea    -0x28(%ebp),%eax
    487f:	50                   	push   %eax
    4880:	e8 68 fa ff ff       	call   42ed <ensureBits17>
    4885:	83 c4 08             	add    $0x8,%esp
    4888:	89 45 f4             	mov    %eax,-0xc(%ebp)
    488b:	eb 12                	jmp    489f <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    488d:	ff 75 ec             	pushl  -0x14(%ebp)
    4890:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4893:	50                   	push   %eax
    4894:	e8 78 f9 ff ff       	call   4211 <ensureBits9>
    4899:	83 c4 08             	add    $0x8,%esp
    489c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    489f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    48a3:	75 07                	jne    48ac <lode_png_test_bitreader+0xb9>
    48a5:	b8 00 00 00 00       	mov    $0x0,%eax
    48aa:	eb 36                	jmp    48e2 <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    48ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
    48af:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    48b6:	8b 45 18             	mov    0x18(%ebp),%eax
    48b9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    48bc:	ff 75 ec             	pushl  -0x14(%ebp)
    48bf:	8d 45 d8             	lea    -0x28(%ebp),%eax
    48c2:	50                   	push   %eax
    48c3:	e8 01 ff ff ff       	call   47c9 <readBits>
    48c8:	83 c4 08             	add    $0x8,%esp
    48cb:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    48cd:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    48d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    48d4:	3b 45 10             	cmp    0x10(%ebp),%eax
    48d7:	0f 8c 4e ff ff ff    	jl     482b <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    48dd:	b8 01 00 00 00       	mov    $0x1,%eax
}
    48e2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    48e5:	c9                   	leave  
    48e6:	c3                   	ret    

000048e7 <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    48e7:	55                   	push   %ebp
    48e8:	89 e5                	mov    %esp,%ebp
    48ea:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    48ed:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    48f4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    48fb:	eb 27                	jmp    4924 <reverseBits+0x3d>
    48fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    4900:	2b 45 fc             	sub    -0x4(%ebp),%eax
    4903:	83 e8 01             	sub    $0x1,%eax
    4906:	8b 55 08             	mov    0x8(%ebp),%edx
    4909:	89 c1                	mov    %eax,%ecx
    490b:	d3 ea                	shr    %cl,%edx
    490d:	89 d0                	mov    %edx,%eax
    490f:	83 e0 01             	and    $0x1,%eax
    4912:	89 c2                	mov    %eax,%edx
    4914:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4917:	89 c1                	mov    %eax,%ecx
    4919:	d3 e2                	shl    %cl,%edx
    491b:	89 d0                	mov    %edx,%eax
    491d:	09 45 f8             	or     %eax,-0x8(%ebp)
    4920:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    4924:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4927:	3b 45 0c             	cmp    0xc(%ebp),%eax
    492a:	72 d1                	jb     48fd <reverseBits+0x16>
  return result;
    492c:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    492f:	c9                   	leave  
    4930:	c3                   	ret    

00004931 <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    4931:	55                   	push   %ebp
    4932:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    4934:	8b 45 08             	mov    0x8(%ebp),%eax
    4937:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    493d:	8b 45 08             	mov    0x8(%ebp),%eax
    4940:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    4947:	8b 45 08             	mov    0x8(%ebp),%eax
    494a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    4951:	8b 45 08             	mov    0x8(%ebp),%eax
    4954:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    495b:	90                   	nop
    495c:	5d                   	pop    %ebp
    495d:	c3                   	ret    

0000495e <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    495e:	55                   	push   %ebp
    495f:	89 e5                	mov    %esp,%ebp
    4961:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    4964:	8b 45 08             	mov    0x8(%ebp),%eax
    4967:	8b 00                	mov    (%eax),%eax
    4969:	83 ec 0c             	sub    $0xc,%esp
    496c:	50                   	push   %eax
    496d:	e8 ec f0 ff ff       	call   3a5e <lodepng_free>
    4972:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    4975:	8b 45 08             	mov    0x8(%ebp),%eax
    4978:	8b 40 04             	mov    0x4(%eax),%eax
    497b:	83 ec 0c             	sub    $0xc,%esp
    497e:	50                   	push   %eax
    497f:	e8 da f0 ff ff       	call   3a5e <lodepng_free>
    4984:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    4987:	8b 45 08             	mov    0x8(%ebp),%eax
    498a:	8b 40 10             	mov    0x10(%eax),%eax
    498d:	83 ec 0c             	sub    $0xc,%esp
    4990:	50                   	push   %eax
    4991:	e8 c8 f0 ff ff       	call   3a5e <lodepng_free>
    4996:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    4999:	8b 45 08             	mov    0x8(%ebp),%eax
    499c:	8b 40 14             	mov    0x14(%eax),%eax
    499f:	83 ec 0c             	sub    $0xc,%esp
    49a2:	50                   	push   %eax
    49a3:	e8 b6 f0 ff ff       	call   3a5e <lodepng_free>
    49a8:	83 c4 10             	add    $0x10,%esp
}
    49ab:	90                   	nop
    49ac:	c9                   	leave  
    49ad:	c3                   	ret    

000049ae <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    49ae:	55                   	push   %ebp
    49af:	89 e5                	mov    %esp,%ebp
    49b1:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    49b4:	a1 08 bd 01 00       	mov    0x1bd08,%eax
    49b9:	c1 e0 02             	shl    $0x2,%eax
    49bc:	83 ec 0c             	sub    $0xc,%esp
    49bf:	50                   	push   %eax
    49c0:	e8 78 f0 ff ff       	call   3a3d <lodepng_malloc>
    49c5:	83 c4 10             	add    $0x10,%esp
    49c8:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    49cb:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    49cf:	75 0a                	jne    49db <HuffmanTree_makeTable+0x2d>
    49d1:	b8 53 00 00 00       	mov    $0x53,%eax
    49d6:	e9 61 04 00 00       	jmp    4e3c <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    49db:	a1 08 bd 01 00       	mov    0x1bd08,%eax
    49e0:	c1 e0 02             	shl    $0x2,%eax
    49e3:	83 ec 04             	sub    $0x4,%esp
    49e6:	50                   	push   %eax
    49e7:	6a 00                	push   $0x0
    49e9:	ff 75 dc             	pushl  -0x24(%ebp)
    49ec:	e8 bd f0 ff ff       	call   3aae <lodepng_memset>
    49f1:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    49f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    49fb:	eb 7d                	jmp    4a7a <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    49fd:	8b 45 08             	mov    0x8(%ebp),%eax
    4a00:	8b 00                	mov    (%eax),%eax
    4a02:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4a05:	c1 e2 02             	shl    $0x2,%edx
    4a08:	01 d0                	add    %edx,%eax
    4a0a:	8b 00                	mov    (%eax),%eax
    4a0c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    4a0f:	8b 45 08             	mov    0x8(%ebp),%eax
    4a12:	8b 40 04             	mov    0x4(%eax),%eax
    4a15:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4a18:	c1 e2 02             	shl    $0x2,%edx
    4a1b:	01 d0                	add    %edx,%eax
    4a1d:	8b 00                	mov    (%eax),%eax
    4a1f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    4a22:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    4a26:	76 4d                	jbe    4a75 <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    4a28:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4a2b:	83 e8 09             	sub    $0x9,%eax
    4a2e:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4a31:	89 c1                	mov    %eax,%ecx
    4a33:	d3 ea                	shr    %cl,%edx
    4a35:	89 d0                	mov    %edx,%eax
    4a37:	83 ec 08             	sub    $0x8,%esp
    4a3a:	6a 09                	push   $0x9
    4a3c:	50                   	push   %eax
    4a3d:	e8 a5 fe ff ff       	call   48e7 <reverseBits>
    4a42:	83 c4 10             	add    $0x10,%esp
    4a45:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    4a48:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4a4b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4a52:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4a55:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    4a58:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4a5b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4a62:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4a65:	01 d0                	add    %edx,%eax
    4a67:	8b 10                	mov    (%eax),%edx
    4a69:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4a6c:	39 c2                	cmp    %eax,%edx
    4a6e:	0f 43 c2             	cmovae %edx,%eax
    4a71:	89 01                	mov    %eax,(%ecx)
    4a73:	eb 01                	jmp    4a76 <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    4a75:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    4a76:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4a7a:	8b 45 08             	mov    0x8(%ebp),%eax
    4a7d:	8b 50 0c             	mov    0xc(%eax),%edx
    4a80:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a83:	39 c2                	cmp    %eax,%edx
    4a85:	0f 87 72 ff ff ff    	ja     49fd <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    4a8b:	a1 08 bd 01 00       	mov    0x1bd08,%eax
    4a90:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    4a93:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4a9a:	eb 35                	jmp    4ad1 <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    4a9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a9f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4aa6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4aa9:	01 d0                	add    %edx,%eax
    4aab:	8b 00                	mov    (%eax),%eax
    4aad:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    4ab0:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    4ab4:	76 17                	jbe    4acd <HuffmanTree_makeTable+0x11f>
    4ab6:	8b 45 cc             	mov    -0x34(%ebp),%eax
    4ab9:	83 e8 09             	sub    $0x9,%eax
    4abc:	ba 01 00 00 00       	mov    $0x1,%edx
    4ac1:	89 c1                	mov    %eax,%ecx
    4ac3:	d3 e2                	shl    %cl,%edx
    4ac5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4ac8:	01 d0                	add    %edx,%eax
    4aca:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    4acd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4ad1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4ad4:	a1 08 bd 01 00       	mov    0x1bd08,%eax
    4ad9:	39 c2                	cmp    %eax,%edx
    4adb:	72 bf                	jb     4a9c <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    4add:	83 ec 0c             	sub    $0xc,%esp
    4ae0:	ff 75 e8             	pushl  -0x18(%ebp)
    4ae3:	e8 55 ef ff ff       	call   3a3d <lodepng_malloc>
    4ae8:	83 c4 10             	add    $0x10,%esp
    4aeb:	89 c2                	mov    %eax,%edx
    4aed:	8b 45 08             	mov    0x8(%ebp),%eax
    4af0:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    4af3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4af6:	01 c0                	add    %eax,%eax
    4af8:	83 ec 0c             	sub    $0xc,%esp
    4afb:	50                   	push   %eax
    4afc:	e8 3c ef ff ff       	call   3a3d <lodepng_malloc>
    4b01:	83 c4 10             	add    $0x10,%esp
    4b04:	89 c2                	mov    %eax,%edx
    4b06:	8b 45 08             	mov    0x8(%ebp),%eax
    4b09:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    4b0c:	8b 45 08             	mov    0x8(%ebp),%eax
    4b0f:	8b 40 10             	mov    0x10(%eax),%eax
    4b12:	85 c0                	test   %eax,%eax
    4b14:	74 0a                	je     4b20 <HuffmanTree_makeTable+0x172>
    4b16:	8b 45 08             	mov    0x8(%ebp),%eax
    4b19:	8b 40 14             	mov    0x14(%eax),%eax
    4b1c:	85 c0                	test   %eax,%eax
    4b1e:	75 18                	jne    4b38 <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    4b20:	83 ec 0c             	sub    $0xc,%esp
    4b23:	ff 75 dc             	pushl  -0x24(%ebp)
    4b26:	e8 33 ef ff ff       	call   3a5e <lodepng_free>
    4b2b:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    4b2e:	b8 53 00 00 00       	mov    $0x53,%eax
    4b33:	e9 04 03 00 00       	jmp    4e3c <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    4b38:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4b3f:	eb 12                	jmp    4b53 <HuffmanTree_makeTable+0x1a5>
    4b41:	8b 45 08             	mov    0x8(%ebp),%eax
    4b44:	8b 50 10             	mov    0x10(%eax),%edx
    4b47:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b4a:	01 d0                	add    %edx,%eax
    4b4c:	c6 00 10             	movb   $0x10,(%eax)
    4b4f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4b53:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b56:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4b59:	7c e6                	jl     4b41 <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    4b5b:	a1 08 bd 01 00       	mov    0x1bd08,%eax
    4b60:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    4b63:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4b6a:	eb 5b                	jmp    4bc7 <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    4b6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b6f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4b76:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4b79:	01 d0                	add    %edx,%eax
    4b7b:	8b 00                	mov    (%eax),%eax
    4b7d:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    4b80:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    4b84:	76 3c                	jbe    4bc2 <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    4b86:	8b 45 08             	mov    0x8(%ebp),%eax
    4b89:	8b 50 10             	mov    0x10(%eax),%edx
    4b8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b8f:	01 d0                	add    %edx,%eax
    4b91:	8b 55 c8             	mov    -0x38(%ebp),%edx
    4b94:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    4b96:	8b 45 08             	mov    0x8(%ebp),%eax
    4b99:	8b 40 14             	mov    0x14(%eax),%eax
    4b9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4b9f:	01 d2                	add    %edx,%edx
    4ba1:	01 d0                	add    %edx,%eax
    4ba3:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4ba6:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    4ba9:	8b 45 c8             	mov    -0x38(%ebp),%eax
    4bac:	83 e8 09             	sub    $0x9,%eax
    4baf:	ba 01 00 00 00       	mov    $0x1,%edx
    4bb4:	89 c1                	mov    %eax,%ecx
    4bb6:	d3 e2                	shl    %cl,%edx
    4bb8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4bbb:	01 d0                	add    %edx,%eax
    4bbd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    4bc0:	eb 01                	jmp    4bc3 <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    4bc2:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    4bc3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4bc7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4bca:	a1 08 bd 01 00       	mov    0x1bd08,%eax
    4bcf:	39 c2                	cmp    %eax,%edx
    4bd1:	72 99                	jb     4b6c <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    4bd3:	83 ec 0c             	sub    $0xc,%esp
    4bd6:	ff 75 dc             	pushl  -0x24(%ebp)
    4bd9:	e8 80 ee ff ff       	call   3a5e <lodepng_free>
    4bde:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    4be1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    4be8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4bef:	e9 9d 01 00 00       	jmp    4d91 <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    4bf4:	8b 45 08             	mov    0x8(%ebp),%eax
    4bf7:	8b 40 04             	mov    0x4(%eax),%eax
    4bfa:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4bfd:	c1 e2 02             	shl    $0x2,%edx
    4c00:	01 d0                	add    %edx,%eax
    4c02:	8b 00                	mov    (%eax),%eax
    4c04:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    4c07:	8b 45 08             	mov    0x8(%ebp),%eax
    4c0a:	8b 00                	mov    (%eax),%eax
    4c0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4c0f:	c1 e2 02             	shl    $0x2,%edx
    4c12:	01 d0                	add    %edx,%eax
    4c14:	8b 00                	mov    (%eax),%eax
    4c16:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    4c19:	83 ec 08             	sub    $0x8,%esp
    4c1c:	ff 75 c4             	pushl  -0x3c(%ebp)
    4c1f:	ff 75 c0             	pushl  -0x40(%ebp)
    4c22:	e8 c0 fc ff ff       	call   48e7 <reverseBits>
    4c27:	83 c4 10             	add    $0x10,%esp
    4c2a:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    4c2d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    4c31:	0f 84 55 01 00 00    	je     4d8c <HuffmanTree_makeTable+0x3de>
    numpresent++;
    4c37:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    4c3b:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    4c3f:	0f 87 81 00 00 00    	ja     4cc6 <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    4c45:	b8 09 00 00 00       	mov    $0x9,%eax
    4c4a:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    4c4d:	ba 01 00 00 00       	mov    $0x1,%edx
    4c52:	89 c1                	mov    %eax,%ecx
    4c54:	d3 e2                	shl    %cl,%edx
    4c56:	89 d0                	mov    %edx,%eax
    4c58:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    4c5b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    4c62:	eb 55                	jmp    4cb9 <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    4c64:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4c67:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4c6a:	89 c1                	mov    %eax,%ecx
    4c6c:	d3 e2                	shl    %cl,%edx
    4c6e:	89 d0                	mov    %edx,%eax
    4c70:	0b 45 bc             	or     -0x44(%ebp),%eax
    4c73:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    4c76:	8b 45 08             	mov    0x8(%ebp),%eax
    4c79:	8b 50 10             	mov    0x10(%eax),%edx
    4c7c:	8b 45 98             	mov    -0x68(%ebp),%eax
    4c7f:	01 d0                	add    %edx,%eax
    4c81:	0f b6 00             	movzbl (%eax),%eax
    4c84:	3c 10                	cmp    $0x10,%al
    4c86:	74 0a                	je     4c92 <HuffmanTree_makeTable+0x2e4>
    4c88:	b8 37 00 00 00       	mov    $0x37,%eax
    4c8d:	e9 aa 01 00 00       	jmp    4e3c <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    4c92:	8b 45 08             	mov    0x8(%ebp),%eax
    4c95:	8b 50 10             	mov    0x10(%eax),%edx
    4c98:	8b 45 98             	mov    -0x68(%ebp),%eax
    4c9b:	01 d0                	add    %edx,%eax
    4c9d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4ca0:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    4ca2:	8b 45 08             	mov    0x8(%ebp),%eax
    4ca5:	8b 40 14             	mov    0x14(%eax),%eax
    4ca8:	8b 55 98             	mov    -0x68(%ebp),%edx
    4cab:	01 d2                	add    %edx,%edx
    4cad:	01 d0                	add    %edx,%eax
    4caf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4cb2:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    4cb5:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    4cb9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4cbc:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    4cbf:	72 a3                	jb     4c64 <HuffmanTree_makeTable+0x2b6>
    4cc1:	e9 c7 00 00 00       	jmp    4d8d <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    4cc6:	a1 0c bd 01 00       	mov    0x1bd0c,%eax
    4ccb:	23 45 bc             	and    -0x44(%ebp),%eax
    4cce:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    4cd1:	8b 45 08             	mov    0x8(%ebp),%eax
    4cd4:	8b 50 10             	mov    0x10(%eax),%edx
    4cd7:	8b 45 b8             	mov    -0x48(%ebp),%eax
    4cda:	01 d0                	add    %edx,%eax
    4cdc:	0f b6 00             	movzbl (%eax),%eax
    4cdf:	0f b6 c0             	movzbl %al,%eax
    4ce2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    4ce5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    4ce8:	83 e8 09             	sub    $0x9,%eax
    4ceb:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    4cee:	8b 45 08             	mov    0x8(%ebp),%eax
    4cf1:	8b 40 14             	mov    0x14(%eax),%eax
    4cf4:	8b 55 b8             	mov    -0x48(%ebp),%edx
    4cf7:	01 d2                	add    %edx,%edx
    4cf9:	01 d0                	add    %edx,%eax
    4cfb:	0f b7 00             	movzwl (%eax),%eax
    4cfe:	0f b7 c0             	movzwl %ax,%eax
    4d01:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    4d04:	8b 45 b0             	mov    -0x50(%ebp),%eax
    4d07:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    4d0a:	83 c0 09             	add    $0x9,%eax
    4d0d:	ba 01 00 00 00       	mov    $0x1,%edx
    4d12:	89 c1                	mov    %eax,%ecx
    4d14:	d3 e2                	shl    %cl,%edx
    4d16:	89 d0                	mov    %edx,%eax
    4d18:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    4d1b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    4d1e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    4d21:	73 0a                	jae    4d2d <HuffmanTree_makeTable+0x37f>
    4d23:	b8 37 00 00 00       	mov    $0x37,%eax
    4d28:	e9 0f 01 00 00       	jmp    4e3c <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    4d2d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    4d34:	eb 4c                	jmp    4d82 <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    4d36:	8b 45 bc             	mov    -0x44(%ebp),%eax
    4d39:	c1 e8 09             	shr    $0x9,%eax
    4d3c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    4d3f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4d42:	83 e8 09             	sub    $0x9,%eax
    4d45:	8b 55 e0             	mov    -0x20(%ebp),%edx
    4d48:	89 c1                	mov    %eax,%ecx
    4d4a:	d3 e2                	shl    %cl,%edx
    4d4c:	89 d0                	mov    %edx,%eax
    4d4e:	0b 45 a4             	or     -0x5c(%ebp),%eax
    4d51:	89 c2                	mov    %eax,%edx
    4d53:	8b 45 ac             	mov    -0x54(%ebp),%eax
    4d56:	01 d0                	add    %edx,%eax
    4d58:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    4d5b:	8b 45 08             	mov    0x8(%ebp),%eax
    4d5e:	8b 50 10             	mov    0x10(%eax),%edx
    4d61:	8b 45 a0             	mov    -0x60(%ebp),%eax
    4d64:	01 d0                	add    %edx,%eax
    4d66:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4d69:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    4d6b:	8b 45 08             	mov    0x8(%ebp),%eax
    4d6e:	8b 40 14             	mov    0x14(%eax),%eax
    4d71:	8b 55 a0             	mov    -0x60(%ebp),%edx
    4d74:	01 d2                	add    %edx,%edx
    4d76:	01 d0                	add    %edx,%eax
    4d78:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4d7b:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    4d7e:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4d82:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4d85:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    4d88:	72 ac                	jb     4d36 <HuffmanTree_makeTable+0x388>
    4d8a:	eb 01                	jmp    4d8d <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    4d8c:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    4d8d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4d91:	8b 45 08             	mov    0x8(%ebp),%eax
    4d94:	8b 50 0c             	mov    0xc(%eax),%edx
    4d97:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d9a:	39 c2                	cmp    %eax,%edx
    4d9c:	0f 87 52 fe ff ff    	ja     4bf4 <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    4da2:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    4da6:	7f 61                	jg     4e09 <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    4da8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4daf:	eb 4e                	jmp    4dff <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    4db1:	8b 45 08             	mov    0x8(%ebp),%eax
    4db4:	8b 50 10             	mov    0x10(%eax),%edx
    4db7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4dba:	01 d0                	add    %edx,%eax
    4dbc:	0f b6 00             	movzbl (%eax),%eax
    4dbf:	3c 10                	cmp    $0x10,%al
    4dc1:	75 38                	jne    4dfb <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    4dc3:	8b 45 08             	mov    0x8(%ebp),%eax
    4dc6:	8b 50 10             	mov    0x10(%eax),%edx
    4dc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4dcc:	01 d0                	add    %edx,%eax
    4dce:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    4dd1:	8b 15 08 bd 01 00    	mov    0x1bd08,%edx
    4dd7:	39 d1                	cmp    %edx,%ecx
    4dd9:	73 07                	jae    4de2 <HuffmanTree_makeTable+0x434>
    4ddb:	ba 01 00 00 00       	mov    $0x1,%edx
    4de0:	eb 05                	jmp    4de7 <HuffmanTree_makeTable+0x439>
    4de2:	ba 0a 00 00 00       	mov    $0xa,%edx
    4de7:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    4de9:	8b 45 08             	mov    0x8(%ebp),%eax
    4dec:	8b 40 14             	mov    0x14(%eax),%eax
    4def:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4df2:	01 d2                	add    %edx,%edx
    4df4:	01 d0                	add    %edx,%eax
    4df6:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    4dfb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4dff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e02:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4e05:	7c aa                	jl     4db1 <HuffmanTree_makeTable+0x403>
    4e07:	eb 2e                	jmp    4e37 <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    4e09:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4e10:	eb 1d                	jmp    4e2f <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    4e12:	8b 45 08             	mov    0x8(%ebp),%eax
    4e15:	8b 50 10             	mov    0x10(%eax),%edx
    4e18:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e1b:	01 d0                	add    %edx,%eax
    4e1d:	0f b6 00             	movzbl (%eax),%eax
    4e20:	3c 10                	cmp    $0x10,%al
    4e22:	75 07                	jne    4e2b <HuffmanTree_makeTable+0x47d>
    4e24:	b8 37 00 00 00       	mov    $0x37,%eax
    4e29:	eb 11                	jmp    4e3c <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    4e2b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4e2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e32:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4e35:	7c db                	jl     4e12 <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    4e37:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4e3c:	c9                   	leave  
    4e3d:	c3                   	ret    

00004e3e <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    4e3e:	55                   	push   %ebp
    4e3f:	89 e5                	mov    %esp,%ebp
    4e41:	56                   	push   %esi
    4e42:	53                   	push   %ebx
    4e43:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    4e46:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    4e4d:	8b 45 08             	mov    0x8(%ebp),%eax
    4e50:	8b 40 0c             	mov    0xc(%eax),%eax
    4e53:	c1 e0 02             	shl    $0x2,%eax
    4e56:	83 ec 0c             	sub    $0xc,%esp
    4e59:	50                   	push   %eax
    4e5a:	e8 de eb ff ff       	call   3a3d <lodepng_malloc>
    4e5f:	83 c4 10             	add    $0x10,%esp
    4e62:	89 c2                	mov    %eax,%edx
    4e64:	8b 45 08             	mov    0x8(%ebp),%eax
    4e67:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4e69:	8b 45 08             	mov    0x8(%ebp),%eax
    4e6c:	8b 40 08             	mov    0x8(%eax),%eax
    4e6f:	83 c0 01             	add    $0x1,%eax
    4e72:	c1 e0 02             	shl    $0x2,%eax
    4e75:	83 ec 0c             	sub    $0xc,%esp
    4e78:	50                   	push   %eax
    4e79:	e8 bf eb ff ff       	call   3a3d <lodepng_malloc>
    4e7e:	83 c4 10             	add    $0x10,%esp
    4e81:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4e84:	8b 45 08             	mov    0x8(%ebp),%eax
    4e87:	8b 40 08             	mov    0x8(%eax),%eax
    4e8a:	83 c0 01             	add    $0x1,%eax
    4e8d:	c1 e0 02             	shl    $0x2,%eax
    4e90:	83 ec 0c             	sub    $0xc,%esp
    4e93:	50                   	push   %eax
    4e94:	e8 a4 eb ff ff       	call   3a3d <lodepng_malloc>
    4e99:	83 c4 10             	add    $0x10,%esp
    4e9c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    4e9f:	8b 45 08             	mov    0x8(%ebp),%eax
    4ea2:	8b 00                	mov    (%eax),%eax
    4ea4:	85 c0                	test   %eax,%eax
    4ea6:	74 0c                	je     4eb4 <HuffmanTree_makeFromLengths2+0x76>
    4ea8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    4eac:	74 06                	je     4eb4 <HuffmanTree_makeFromLengths2+0x76>
    4eae:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4eb2:	75 07                	jne    4ebb <HuffmanTree_makeFromLengths2+0x7d>
    4eb4:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    4ebb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4ebf:	0f 85 7d 01 00 00    	jne    5042 <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    4ec5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4ecc:	eb 2c                	jmp    4efa <HuffmanTree_makeFromLengths2+0xbc>
    4ece:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4ed1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4ed8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4edb:	01 c2                	add    %eax,%edx
    4edd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4ee0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4ee7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4eea:	01 c8                	add    %ecx,%eax
    4eec:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    4ef2:	8b 00                	mov    (%eax),%eax
    4ef4:	89 02                	mov    %eax,(%edx)
    4ef6:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    4efa:	8b 45 08             	mov    0x8(%ebp),%eax
    4efd:	8b 40 08             	mov    0x8(%eax),%eax
    4f00:	83 c0 01             	add    $0x1,%eax
    4f03:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4f06:	75 c6                	jne    4ece <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    4f08:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4f0f:	eb 27                	jmp    4f38 <HuffmanTree_makeFromLengths2+0xfa>
    4f11:	8b 45 08             	mov    0x8(%ebp),%eax
    4f14:	8b 40 04             	mov    0x4(%eax),%eax
    4f17:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4f1a:	c1 e2 02             	shl    $0x2,%edx
    4f1d:	01 d0                	add    %edx,%eax
    4f1f:	8b 00                	mov    (%eax),%eax
    4f21:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4f28:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4f2b:	01 d0                	add    %edx,%eax
    4f2d:	8b 10                	mov    (%eax),%edx
    4f2f:	83 c2 01             	add    $0x1,%edx
    4f32:	89 10                	mov    %edx,(%eax)
    4f34:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4f38:	8b 45 08             	mov    0x8(%ebp),%eax
    4f3b:	8b 40 0c             	mov    0xc(%eax),%eax
    4f3e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4f41:	75 ce                	jne    4f11 <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4f43:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    4f4a:	eb 47                	jmp    4f93 <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    4f4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f4f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4f56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4f59:	01 d0                	add    %edx,%eax
    4f5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4f5e:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4f64:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4f6b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4f6e:	01 ca                	add    %ecx,%edx
    4f70:	8b 0a                	mov    (%edx),%ecx
    4f72:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4f75:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4f7b:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    4f82:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4f85:	01 da                	add    %ebx,%edx
    4f87:	8b 12                	mov    (%edx),%edx
    4f89:	01 ca                	add    %ecx,%edx
    4f8b:	01 d2                	add    %edx,%edx
    4f8d:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4f8f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4f93:	8b 45 08             	mov    0x8(%ebp),%eax
    4f96:	8b 40 08             	mov    0x8(%eax),%eax
    4f99:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4f9c:	73 ae                	jae    4f4c <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4f9e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4fa5:	e9 89 00 00 00       	jmp    5033 <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    4faa:	8b 45 08             	mov    0x8(%ebp),%eax
    4fad:	8b 40 04             	mov    0x4(%eax),%eax
    4fb0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4fb3:	c1 e2 02             	shl    $0x2,%edx
    4fb6:	01 d0                	add    %edx,%eax
    4fb8:	8b 00                	mov    (%eax),%eax
    4fba:	85 c0                	test   %eax,%eax
    4fbc:	74 71                	je     502f <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    4fbe:	8b 45 08             	mov    0x8(%ebp),%eax
    4fc1:	8b 00                	mov    (%eax),%eax
    4fc3:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4fc6:	c1 e2 02             	shl    $0x2,%edx
    4fc9:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4fcc:	8b 45 08             	mov    0x8(%ebp),%eax
    4fcf:	8b 40 04             	mov    0x4(%eax),%eax
    4fd2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4fd5:	c1 e2 02             	shl    $0x2,%edx
    4fd8:	01 d0                	add    %edx,%eax
    4fda:	8b 00                	mov    (%eax),%eax
    4fdc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4fe3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4fe6:	01 c2                	add    %eax,%edx
    4fe8:	8b 02                	mov    (%edx),%eax
    4fea:	8d 48 01             	lea    0x1(%eax),%ecx
    4fed:	89 0a                	mov    %ecx,(%edx)
    4fef:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    4ff1:	8b 45 08             	mov    0x8(%ebp),%eax
    4ff4:	8b 00                	mov    (%eax),%eax
    4ff6:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4ff9:	c1 e2 02             	shl    $0x2,%edx
    4ffc:	01 c2                	add    %eax,%edx
    4ffe:	8b 45 08             	mov    0x8(%ebp),%eax
    5001:	8b 00                	mov    (%eax),%eax
    5003:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    5006:	c1 e1 02             	shl    $0x2,%ecx
    5009:	01 c8                	add    %ecx,%eax
    500b:	8b 18                	mov    (%eax),%ebx
    500d:	8b 45 08             	mov    0x8(%ebp),%eax
    5010:	8b 40 04             	mov    0x4(%eax),%eax
    5013:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    5016:	c1 e1 02             	shl    $0x2,%ecx
    5019:	01 c8                	add    %ecx,%eax
    501b:	8b 00                	mov    (%eax),%eax
    501d:	be 01 00 00 00       	mov    $0x1,%esi
    5022:	89 c1                	mov    %eax,%ecx
    5024:	d3 e6                	shl    %cl,%esi
    5026:	89 f0                	mov    %esi,%eax
    5028:	83 e8 01             	sub    $0x1,%eax
    502b:	21 d8                	and    %ebx,%eax
    502d:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    502f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5033:	8b 45 08             	mov    0x8(%ebp),%eax
    5036:	8b 40 0c             	mov    0xc(%eax),%eax
    5039:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    503c:	0f 85 68 ff ff ff    	jne    4faa <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    5042:	83 ec 0c             	sub    $0xc,%esp
    5045:	ff 75 e8             	pushl  -0x18(%ebp)
    5048:	e8 11 ea ff ff       	call   3a5e <lodepng_free>
    504d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    5050:	83 ec 0c             	sub    $0xc,%esp
    5053:	ff 75 e4             	pushl  -0x1c(%ebp)
    5056:	e8 03 ea ff ff       	call   3a5e <lodepng_free>
    505b:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    505e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5062:	75 11                	jne    5075 <HuffmanTree_makeFromLengths2+0x237>
    5064:	83 ec 0c             	sub    $0xc,%esp
    5067:	ff 75 08             	pushl  0x8(%ebp)
    506a:	e8 3f f9 ff ff       	call   49ae <HuffmanTree_makeTable>
    506f:	83 c4 10             	add    $0x10,%esp
    5072:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    5075:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5078:	8d 65 f8             	lea    -0x8(%ebp),%esp
    507b:	5b                   	pop    %ebx
    507c:	5e                   	pop    %esi
    507d:	5d                   	pop    %ebp
    507e:	c3                   	ret    

0000507f <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    507f:	55                   	push   %ebp
    5080:	89 e5                	mov    %esp,%ebp
    5082:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    5085:	8b 45 10             	mov    0x10(%ebp),%eax
    5088:	c1 e0 02             	shl    $0x2,%eax
    508b:	83 ec 0c             	sub    $0xc,%esp
    508e:	50                   	push   %eax
    508f:	e8 a9 e9 ff ff       	call   3a3d <lodepng_malloc>
    5094:	83 c4 10             	add    $0x10,%esp
    5097:	89 c2                	mov    %eax,%edx
    5099:	8b 45 08             	mov    0x8(%ebp),%eax
    509c:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    509f:	8b 45 08             	mov    0x8(%ebp),%eax
    50a2:	8b 40 04             	mov    0x4(%eax),%eax
    50a5:	85 c0                	test   %eax,%eax
    50a7:	75 07                	jne    50b0 <HuffmanTree_makeFromLengths+0x31>
    50a9:	b8 53 00 00 00       	mov    $0x53,%eax
    50ae:	eb 56                	jmp    5106 <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    50b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    50b7:	eb 25                	jmp    50de <HuffmanTree_makeFromLengths+0x5f>
    50b9:	8b 45 08             	mov    0x8(%ebp),%eax
    50bc:	8b 40 04             	mov    0x4(%eax),%eax
    50bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    50c2:	c1 e2 02             	shl    $0x2,%edx
    50c5:	01 c2                	add    %eax,%edx
    50c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    50ca:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    50d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    50d4:	01 c8                	add    %ecx,%eax
    50d6:	8b 00                	mov    (%eax),%eax
    50d8:	89 02                	mov    %eax,(%edx)
    50da:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    50de:	8b 45 10             	mov    0x10(%ebp),%eax
    50e1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    50e4:	75 d3                	jne    50b9 <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    50e6:	8b 55 10             	mov    0x10(%ebp),%edx
    50e9:	8b 45 08             	mov    0x8(%ebp),%eax
    50ec:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    50ef:	8b 45 08             	mov    0x8(%ebp),%eax
    50f2:	8b 55 14             	mov    0x14(%ebp),%edx
    50f5:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    50f8:	83 ec 0c             	sub    $0xc,%esp
    50fb:	ff 75 08             	pushl  0x8(%ebp)
    50fe:	e8 3b fd ff ff       	call   4e3e <HuffmanTree_makeFromLengths2>
    5103:	83 c4 10             	add    $0x10,%esp
}
    5106:	c9                   	leave  
    5107:	c3                   	ret    

00005108 <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    5108:	55                   	push   %ebp
    5109:	89 e5                	mov    %esp,%ebp
    510b:	53                   	push   %ebx
    510c:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    510f:	8b 45 08             	mov    0x8(%ebp),%eax
    5112:	8b 50 0c             	mov    0xc(%eax),%edx
    5115:	8b 45 08             	mov    0x8(%ebp),%eax
    5118:	8b 40 08             	mov    0x8(%eax),%eax
    511b:	39 c2                	cmp    %eax,%edx
    511d:	0f 82 0b 01 00 00    	jb     522e <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    5123:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    512a:	eb 19                	jmp    5145 <bpmnode_create+0x3d>
    512c:	8b 45 08             	mov    0x8(%ebp),%eax
    512f:	8b 40 04             	mov    0x4(%eax),%eax
    5132:	8b 55 f8             	mov    -0x8(%ebp),%edx
    5135:	c1 e2 04             	shl    $0x4,%edx
    5138:	01 d0                	add    %edx,%eax
    513a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    5141:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    5145:	8b 45 08             	mov    0x8(%ebp),%eax
    5148:	8b 00                	mov    (%eax),%eax
    514a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    514d:	75 dd                	jne    512c <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    514f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    5156:	eb 60                	jmp    51b8 <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    5158:	8b 45 08             	mov    0x8(%ebp),%eax
    515b:	8b 40 18             	mov    0x18(%eax),%eax
    515e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    5161:	c1 e2 02             	shl    $0x2,%edx
    5164:	01 d0                	add    %edx,%eax
    5166:	8b 00                	mov    (%eax),%eax
    5168:	89 45 f4             	mov    %eax,-0xc(%ebp)
    516b:	eb 13                	jmp    5180 <bpmnode_create+0x78>
    516d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5170:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    5177:	8b 45 f4             	mov    -0xc(%ebp),%eax
    517a:	8b 40 08             	mov    0x8(%eax),%eax
    517d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5180:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5184:	75 e7                	jne    516d <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    5186:	8b 45 08             	mov    0x8(%ebp),%eax
    5189:	8b 40 1c             	mov    0x1c(%eax),%eax
    518c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    518f:	c1 e2 02             	shl    $0x2,%edx
    5192:	01 d0                	add    %edx,%eax
    5194:	8b 00                	mov    (%eax),%eax
    5196:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5199:	eb 13                	jmp    51ae <bpmnode_create+0xa6>
    519b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    519e:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    51a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    51a8:	8b 40 08             	mov    0x8(%eax),%eax
    51ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
    51ae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    51b2:	75 e7                	jne    519b <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    51b4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    51b8:	8b 45 08             	mov    0x8(%ebp),%eax
    51bb:	8b 40 14             	mov    0x14(%eax),%eax
    51be:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    51c1:	75 95                	jne    5158 <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    51c3:	8b 45 08             	mov    0x8(%ebp),%eax
    51c6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    51cd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    51d4:	eb 44                	jmp    521a <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    51d6:	8b 45 08             	mov    0x8(%ebp),%eax
    51d9:	8b 40 04             	mov    0x4(%eax),%eax
    51dc:	8b 55 f8             	mov    -0x8(%ebp),%edx
    51df:	c1 e2 04             	shl    $0x4,%edx
    51e2:	01 d0                	add    %edx,%eax
    51e4:	8b 40 0c             	mov    0xc(%eax),%eax
    51e7:	85 c0                	test   %eax,%eax
    51e9:	75 2b                	jne    5216 <bpmnode_create+0x10e>
    51eb:	8b 45 08             	mov    0x8(%ebp),%eax
    51ee:	8b 58 10             	mov    0x10(%eax),%ebx
    51f1:	8b 45 08             	mov    0x8(%ebp),%eax
    51f4:	8b 40 08             	mov    0x8(%eax),%eax
    51f7:	8d 48 01             	lea    0x1(%eax),%ecx
    51fa:	8b 55 08             	mov    0x8(%ebp),%edx
    51fd:	89 4a 08             	mov    %ecx,0x8(%edx)
    5200:	c1 e0 02             	shl    $0x2,%eax
    5203:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    5206:	8b 45 08             	mov    0x8(%ebp),%eax
    5209:	8b 40 04             	mov    0x4(%eax),%eax
    520c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    520f:	c1 e1 04             	shl    $0x4,%ecx
    5212:	01 c8                	add    %ecx,%eax
    5214:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    5216:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    521a:	8b 45 08             	mov    0x8(%ebp),%eax
    521d:	8b 00                	mov    (%eax),%eax
    521f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5222:	75 b2                	jne    51d6 <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    5224:	8b 45 08             	mov    0x8(%ebp),%eax
    5227:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    522e:	8b 45 08             	mov    0x8(%ebp),%eax
    5231:	8b 58 10             	mov    0x10(%eax),%ebx
    5234:	8b 45 08             	mov    0x8(%ebp),%eax
    5237:	8b 40 0c             	mov    0xc(%eax),%eax
    523a:	8d 48 01             	lea    0x1(%eax),%ecx
    523d:	8b 55 08             	mov    0x8(%ebp),%edx
    5240:	89 4a 0c             	mov    %ecx,0xc(%edx)
    5243:	c1 e0 02             	shl    $0x2,%eax
    5246:	01 d8                	add    %ebx,%eax
    5248:	8b 00                	mov    (%eax),%eax
    524a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    524d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5250:	8b 55 0c             	mov    0xc(%ebp),%edx
    5253:	89 10                	mov    %edx,(%eax)
  result->index = index;
    5255:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5258:	8b 55 10             	mov    0x10(%ebp),%edx
    525b:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    525e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5261:	8b 55 14             	mov    0x14(%ebp),%edx
    5264:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    5267:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    526a:	83 c4 10             	add    $0x10,%esp
    526d:	5b                   	pop    %ebx
    526e:	5d                   	pop    %ebp
    526f:	c3                   	ret    

00005270 <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    5270:	55                   	push   %ebp
    5271:	89 e5                	mov    %esp,%ebp
    5273:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    5276:	8b 45 0c             	mov    0xc(%ebp),%eax
    5279:	c1 e0 04             	shl    $0x4,%eax
    527c:	83 ec 0c             	sub    $0xc,%esp
    527f:	50                   	push   %eax
    5280:	e8 b8 e7 ff ff       	call   3a3d <lodepng_malloc>
    5285:	83 c4 10             	add    $0x10,%esp
    5288:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    528b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    5292:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    5299:	e9 41 01 00 00       	jmp    53df <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    529e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    52a1:	83 e0 01             	and    $0x1,%eax
    52a4:	85 c0                	test   %eax,%eax
    52a6:	74 05                	je     52ad <bpmnode_sort+0x3d>
    52a8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    52ab:	eb 03                	jmp    52b0 <bpmnode_sort+0x40>
    52ad:	8b 45 08             	mov    0x8(%ebp),%eax
    52b0:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    52b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    52b6:	83 e0 01             	and    $0x1,%eax
    52b9:	85 c0                	test   %eax,%eax
    52bb:	74 05                	je     52c2 <bpmnode_sort+0x52>
    52bd:	8b 45 08             	mov    0x8(%ebp),%eax
    52c0:	eb 03                	jmp    52c5 <bpmnode_sort+0x55>
    52c2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    52c5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    52c8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    52cf:	e9 f8 00 00 00       	jmp    53cc <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    52d4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    52d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    52da:	01 c2                	add    %eax,%edx
    52dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    52df:	39 c2                	cmp    %eax,%edx
    52e1:	0f 4e c2             	cmovle %edx,%eax
    52e4:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    52e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    52ea:	8d 14 00             	lea    (%eax,%eax,1),%edx
    52ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
    52f0:	01 c2                	add    %eax,%edx
    52f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    52f5:	39 c2                	cmp    %eax,%edx
    52f7:	0f 4e c2             	cmovle %edx,%eax
    52fa:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    52fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5300:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5303:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5306:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    5309:	8b 45 ec             	mov    -0x14(%ebp),%eax
    530c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    530f:	e9 a4 00 00 00       	jmp    53b8 <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    5314:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5317:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    531a:	7d 62                	jge    537e <bpmnode_sort+0x10e>
    531c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    531f:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    5322:	7d 22                	jge    5346 <bpmnode_sort+0xd6>
    5324:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5327:	c1 e0 04             	shl    $0x4,%eax
    532a:	89 c2                	mov    %eax,%edx
    532c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    532f:	01 d0                	add    %edx,%eax
    5331:	8b 10                	mov    (%eax),%edx
    5333:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5336:	c1 e0 04             	shl    $0x4,%eax
    5339:	89 c1                	mov    %eax,%ecx
    533b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    533e:	01 c8                	add    %ecx,%eax
    5340:	8b 00                	mov    (%eax),%eax
    5342:	39 c2                	cmp    %eax,%edx
    5344:	7f 38                	jg     537e <bpmnode_sort+0x10e>
    5346:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5349:	c1 e0 04             	shl    $0x4,%eax
    534c:	89 c2                	mov    %eax,%edx
    534e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5351:	01 d0                	add    %edx,%eax
    5353:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5356:	8d 4a 01             	lea    0x1(%edx),%ecx
    5359:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    535c:	89 d1                	mov    %edx,%ecx
    535e:	c1 e1 04             	shl    $0x4,%ecx
    5361:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5364:	01 ca                	add    %ecx,%edx
    5366:	8b 0a                	mov    (%edx),%ecx
    5368:	89 08                	mov    %ecx,(%eax)
    536a:	8b 4a 04             	mov    0x4(%edx),%ecx
    536d:	89 48 04             	mov    %ecx,0x4(%eax)
    5370:	8b 4a 08             	mov    0x8(%edx),%ecx
    5373:	89 48 08             	mov    %ecx,0x8(%eax)
    5376:	8b 52 0c             	mov    0xc(%edx),%edx
    5379:	89 50 0c             	mov    %edx,0xc(%eax)
    537c:	eb 36                	jmp    53b4 <bpmnode_sort+0x144>
        else b[k] = a[j++];
    537e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5381:	c1 e0 04             	shl    $0x4,%eax
    5384:	89 c2                	mov    %eax,%edx
    5386:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5389:	01 d0                	add    %edx,%eax
    538b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    538e:	8d 4a 01             	lea    0x1(%edx),%ecx
    5391:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    5394:	89 d1                	mov    %edx,%ecx
    5396:	c1 e1 04             	shl    $0x4,%ecx
    5399:	8b 55 d8             	mov    -0x28(%ebp),%edx
    539c:	01 ca                	add    %ecx,%edx
    539e:	8b 0a                	mov    (%edx),%ecx
    53a0:	89 08                	mov    %ecx,(%eax)
    53a2:	8b 4a 04             	mov    0x4(%edx),%ecx
    53a5:	89 48 04             	mov    %ecx,0x4(%eax)
    53a8:	8b 4a 08             	mov    0x8(%edx),%ecx
    53ab:	89 48 08             	mov    %ecx,0x8(%eax)
    53ae:	8b 52 0c             	mov    0xc(%edx),%edx
    53b1:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    53b4:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    53b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    53bb:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    53be:	0f 8c 50 ff ff ff    	jl     5314 <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    53c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53c7:	01 c0                	add    %eax,%eax
    53c9:	01 45 ec             	add    %eax,-0x14(%ebp)
    53cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    53cf:	3b 45 0c             	cmp    0xc(%ebp),%eax
    53d2:	0f 8c fc fe ff ff    	jl     52d4 <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    53d8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    53dc:	d1 65 f4             	shll   -0xc(%ebp)
    53df:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53e2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    53e5:	0f 8c b3 fe ff ff    	jl     529e <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    53eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    53ee:	83 e0 01             	and    $0x1,%eax
    53f1:	85 c0                	test   %eax,%eax
    53f3:	74 18                	je     540d <bpmnode_sort+0x19d>
    53f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    53f8:	c1 e0 04             	shl    $0x4,%eax
    53fb:	83 ec 04             	sub    $0x4,%esp
    53fe:	50                   	push   %eax
    53ff:	ff 75 dc             	pushl  -0x24(%ebp)
    5402:	ff 75 08             	pushl  0x8(%ebp)
    5405:	e8 71 e6 ff ff       	call   3a7b <lodepng_memcpy>
    540a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    540d:	83 ec 0c             	sub    $0xc,%esp
    5410:	ff 75 dc             	pushl  -0x24(%ebp)
    5413:	e8 46 e6 ff ff       	call   3a5e <lodepng_free>
    5418:	83 c4 10             	add    $0x10,%esp
}
    541b:	90                   	nop
    541c:	c9                   	leave  
    541d:	c3                   	ret    

0000541e <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    541e:	55                   	push   %ebp
    541f:	89 e5                	mov    %esp,%ebp
    5421:	56                   	push   %esi
    5422:	53                   	push   %ebx
    5423:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    5426:	8b 45 08             	mov    0x8(%ebp),%eax
    5429:	8b 40 1c             	mov    0x1c(%eax),%eax
    542c:	8b 55 14             	mov    0x14(%ebp),%edx
    542f:	c1 e2 02             	shl    $0x2,%edx
    5432:	01 d0                	add    %edx,%eax
    5434:	8b 00                	mov    (%eax),%eax
    5436:	8b 40 04             	mov    0x4(%eax),%eax
    5439:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    543c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    5440:	75 66                	jne    54a8 <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    5442:	8b 45 10             	mov    0x10(%ebp),%eax
    5445:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    5448:	0f 83 a0 01 00 00    	jae    55ee <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    544e:	8b 45 08             	mov    0x8(%ebp),%eax
    5451:	8b 40 18             	mov    0x18(%eax),%eax
    5454:	8b 55 14             	mov    0x14(%ebp),%edx
    5457:	c1 e2 02             	shl    $0x2,%edx
    545a:	01 c2                	add    %eax,%edx
    545c:	8b 45 08             	mov    0x8(%ebp),%eax
    545f:	8b 40 1c             	mov    0x1c(%eax),%eax
    5462:	8b 4d 14             	mov    0x14(%ebp),%ecx
    5465:	c1 e1 02             	shl    $0x2,%ecx
    5468:	01 c8                	add    %ecx,%eax
    546a:	8b 00                	mov    (%eax),%eax
    546c:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    546e:	8b 45 08             	mov    0x8(%ebp),%eax
    5471:	8b 40 1c             	mov    0x1c(%eax),%eax
    5474:	8b 55 14             	mov    0x14(%ebp),%edx
    5477:	c1 e2 02             	shl    $0x2,%edx
    547a:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    547d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5480:	8d 50 01             	lea    0x1(%eax),%edx
    5483:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5486:	c1 e0 04             	shl    $0x4,%eax
    5489:	89 c1                	mov    %eax,%ecx
    548b:	8b 45 0c             	mov    0xc(%ebp),%eax
    548e:	01 c8                	add    %ecx,%eax
    5490:	8b 00                	mov    (%eax),%eax
    5492:	6a 00                	push   $0x0
    5494:	52                   	push   %edx
    5495:	50                   	push   %eax
    5496:	ff 75 08             	pushl  0x8(%ebp)
    5499:	e8 6a fc ff ff       	call   5108 <bpmnode_create>
    549e:	83 c4 10             	add    $0x10,%esp
    54a1:	89 03                	mov    %eax,(%ebx)
    54a3:	e9 47 01 00 00       	jmp    55ef <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    54a8:	8b 45 08             	mov    0x8(%ebp),%eax
    54ab:	8b 40 18             	mov    0x18(%eax),%eax
    54ae:	8b 55 14             	mov    0x14(%ebp),%edx
    54b1:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    54b7:	c1 e2 02             	shl    $0x2,%edx
    54ba:	01 d0                	add    %edx,%eax
    54bc:	8b 00                	mov    (%eax),%eax
    54be:	8b 10                	mov    (%eax),%edx
    54c0:	8b 45 08             	mov    0x8(%ebp),%eax
    54c3:	8b 40 1c             	mov    0x1c(%eax),%eax
    54c6:	8b 4d 14             	mov    0x14(%ebp),%ecx
    54c9:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    54cf:	c1 e1 02             	shl    $0x2,%ecx
    54d2:	01 c8                	add    %ecx,%eax
    54d4:	8b 00                	mov    (%eax),%eax
    54d6:	8b 00                	mov    (%eax),%eax
    54d8:	01 d0                	add    %edx,%eax
    54da:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    54dd:	8b 45 08             	mov    0x8(%ebp),%eax
    54e0:	8b 40 18             	mov    0x18(%eax),%eax
    54e3:	8b 55 14             	mov    0x14(%ebp),%edx
    54e6:	c1 e2 02             	shl    $0x2,%edx
    54e9:	01 c2                	add    %eax,%edx
    54eb:	8b 45 08             	mov    0x8(%ebp),%eax
    54ee:	8b 40 1c             	mov    0x1c(%eax),%eax
    54f1:	8b 4d 14             	mov    0x14(%ebp),%ecx
    54f4:	c1 e1 02             	shl    $0x2,%ecx
    54f7:	01 c8                	add    %ecx,%eax
    54f9:	8b 00                	mov    (%eax),%eax
    54fb:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    54fd:	8b 45 10             	mov    0x10(%ebp),%eax
    5500:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    5503:	73 60                	jae    5565 <boundaryPM+0x147>
    5505:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5508:	c1 e0 04             	shl    $0x4,%eax
    550b:	89 c2                	mov    %eax,%edx
    550d:	8b 45 0c             	mov    0xc(%ebp),%eax
    5510:	01 d0                	add    %edx,%eax
    5512:	8b 00                	mov    (%eax),%eax
    5514:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5517:	7d 4c                	jge    5565 <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    5519:	8b 45 08             	mov    0x8(%ebp),%eax
    551c:	8b 40 1c             	mov    0x1c(%eax),%eax
    551f:	8b 55 14             	mov    0x14(%ebp),%edx
    5522:	c1 e2 02             	shl    $0x2,%edx
    5525:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    5528:	8b 45 08             	mov    0x8(%ebp),%eax
    552b:	8b 40 1c             	mov    0x1c(%eax),%eax
    552e:	8b 55 14             	mov    0x14(%ebp),%edx
    5531:	c1 e2 02             	shl    $0x2,%edx
    5534:	01 d0                	add    %edx,%eax
    5536:	8b 00                	mov    (%eax),%eax
    5538:	8b 50 08             	mov    0x8(%eax),%edx
    553b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    553e:	8d 48 01             	lea    0x1(%eax),%ecx
    5541:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5544:	c1 e0 04             	shl    $0x4,%eax
    5547:	89 c6                	mov    %eax,%esi
    5549:	8b 45 0c             	mov    0xc(%ebp),%eax
    554c:	01 f0                	add    %esi,%eax
    554e:	8b 00                	mov    (%eax),%eax
    5550:	52                   	push   %edx
    5551:	51                   	push   %ecx
    5552:	50                   	push   %eax
    5553:	ff 75 08             	pushl  0x8(%ebp)
    5556:	e8 ad fb ff ff       	call   5108 <bpmnode_create>
    555b:	83 c4 10             	add    $0x10,%esp
    555e:	89 03                	mov    %eax,(%ebx)
      return;
    5560:	e9 8a 00 00 00       	jmp    55ef <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    5565:	8b 45 08             	mov    0x8(%ebp),%eax
    5568:	8b 40 1c             	mov    0x1c(%eax),%eax
    556b:	8b 55 14             	mov    0x14(%ebp),%edx
    556e:	c1 e2 02             	shl    $0x2,%edx
    5571:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    5574:	8b 45 08             	mov    0x8(%ebp),%eax
    5577:	8b 40 1c             	mov    0x1c(%eax),%eax
    557a:	8b 55 14             	mov    0x14(%ebp),%edx
    557d:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5583:	c1 e2 02             	shl    $0x2,%edx
    5586:	01 d0                	add    %edx,%eax
    5588:	8b 00                	mov    (%eax),%eax
    558a:	50                   	push   %eax
    558b:	ff 75 f4             	pushl  -0xc(%ebp)
    558e:	ff 75 f0             	pushl  -0x10(%ebp)
    5591:	ff 75 08             	pushl  0x8(%ebp)
    5594:	e8 6f fb ff ff       	call   5108 <bpmnode_create>
    5599:	83 c4 10             	add    $0x10,%esp
    559c:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    559e:	8b 45 18             	mov    0x18(%ebp),%eax
    55a1:	8d 50 01             	lea    0x1(%eax),%edx
    55a4:	8b 45 10             	mov    0x10(%ebp),%eax
    55a7:	83 e8 01             	sub    $0x1,%eax
    55aa:	01 c0                	add    %eax,%eax
    55ac:	39 c2                	cmp    %eax,%edx
    55ae:	7d 3f                	jge    55ef <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    55b0:	8b 45 14             	mov    0x14(%ebp),%eax
    55b3:	83 e8 01             	sub    $0x1,%eax
    55b6:	83 ec 0c             	sub    $0xc,%esp
    55b9:	ff 75 18             	pushl  0x18(%ebp)
    55bc:	50                   	push   %eax
    55bd:	ff 75 10             	pushl  0x10(%ebp)
    55c0:	ff 75 0c             	pushl  0xc(%ebp)
    55c3:	ff 75 08             	pushl  0x8(%ebp)
    55c6:	e8 53 fe ff ff       	call   541e <boundaryPM>
    55cb:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    55ce:	8b 45 14             	mov    0x14(%ebp),%eax
    55d1:	83 e8 01             	sub    $0x1,%eax
    55d4:	83 ec 0c             	sub    $0xc,%esp
    55d7:	ff 75 18             	pushl  0x18(%ebp)
    55da:	50                   	push   %eax
    55db:	ff 75 10             	pushl  0x10(%ebp)
    55de:	ff 75 0c             	pushl  0xc(%ebp)
    55e1:	ff 75 08             	pushl  0x8(%ebp)
    55e4:	e8 35 fe ff ff       	call   541e <boundaryPM>
    55e9:	83 c4 20             	add    $0x20,%esp
    55ec:	eb 01                	jmp    55ef <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    55ee:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    55ef:	8d 65 f8             	lea    -0x8(%ebp),%esp
    55f2:	5b                   	pop    %ebx
    55f3:	5e                   	pop    %esi
    55f4:	5d                   	pop    %ebp
    55f5:	c3                   	ret    

000055f6 <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    55f6:	55                   	push   %ebp
    55f7:	89 e5                	mov    %esp,%ebp
    55f9:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    55fc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    5603:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    560a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    560e:	75 0a                	jne    561a <lodepng_huffman_code_lengths+0x24>
    5610:	b8 50 00 00 00       	mov    $0x50,%eax
    5615:	e9 4d 03 00 00       	jmp    5967 <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    561a:	8b 45 14             	mov    0x14(%ebp),%eax
    561d:	ba 01 00 00 00       	mov    $0x1,%edx
    5622:	89 c1                	mov    %eax,%ecx
    5624:	d3 e2                	shl    %cl,%edx
    5626:	8b 45 10             	mov    0x10(%ebp),%eax
    5629:	39 c2                	cmp    %eax,%edx
    562b:	73 0a                	jae    5637 <lodepng_huffman_code_lengths+0x41>
    562d:	b8 50 00 00 00       	mov    $0x50,%eax
    5632:	e9 30 03 00 00       	jmp    5967 <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    5637:	8b 45 10             	mov    0x10(%ebp),%eax
    563a:	c1 e0 04             	shl    $0x4,%eax
    563d:	83 ec 0c             	sub    $0xc,%esp
    5640:	50                   	push   %eax
    5641:	e8 f7 e3 ff ff       	call   3a3d <lodepng_malloc>
    5646:	83 c4 10             	add    $0x10,%esp
    5649:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    564c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5650:	75 0a                	jne    565c <lodepng_huffman_code_lengths+0x66>
    5652:	b8 53 00 00 00       	mov    $0x53,%eax
    5657:	e9 0b 03 00 00       	jmp    5967 <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    565c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5663:	eb 50                	jmp    56b5 <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    5665:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5668:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    566f:	8b 45 0c             	mov    0xc(%ebp),%eax
    5672:	01 d0                	add    %edx,%eax
    5674:	8b 00                	mov    (%eax),%eax
    5676:	85 c0                	test   %eax,%eax
    5678:	74 37                	je     56b1 <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    567a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    567d:	c1 e0 04             	shl    $0x4,%eax
    5680:	89 c2                	mov    %eax,%edx
    5682:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5685:	01 d0                	add    %edx,%eax
    5687:	8b 55 f0             	mov    -0x10(%ebp),%edx
    568a:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    5691:	8b 55 0c             	mov    0xc(%ebp),%edx
    5694:	01 ca                	add    %ecx,%edx
    5696:	8b 12                	mov    (%edx),%edx
    5698:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    569a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    569d:	c1 e0 04             	shl    $0x4,%eax
    56a0:	89 c2                	mov    %eax,%edx
    56a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    56a5:	01 c2                	add    %eax,%edx
    56a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    56aa:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    56ad:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    56b1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    56b5:	8b 45 10             	mov    0x10(%ebp),%eax
    56b8:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    56bb:	75 a8                	jne    5665 <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    56bd:	8b 45 10             	mov    0x10(%ebp),%eax
    56c0:	c1 e0 02             	shl    $0x2,%eax
    56c3:	83 ec 04             	sub    $0x4,%esp
    56c6:	50                   	push   %eax
    56c7:	6a 00                	push   $0x0
    56c9:	ff 75 08             	pushl  0x8(%ebp)
    56cc:	e8 dd e3 ff ff       	call   3aae <lodepng_memset>
    56d1:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    56d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    56d8:	75 18                	jne    56f2 <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    56da:	8b 45 08             	mov    0x8(%ebp),%eax
    56dd:	83 c0 04             	add    $0x4,%eax
    56e0:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    56e6:	8b 10                	mov    (%eax),%edx
    56e8:	8b 45 08             	mov    0x8(%ebp),%eax
    56eb:	89 10                	mov    %edx,(%eax)
    56ed:	e9 64 02 00 00       	jmp    5956 <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    56f2:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    56f6:	75 3e                	jne    5736 <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    56f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    56fb:	8b 40 04             	mov    0x4(%eax),%eax
    56fe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5705:	8b 45 08             	mov    0x8(%ebp),%eax
    5708:	01 d0                	add    %edx,%eax
    570a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    5710:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5713:	8b 40 04             	mov    0x4(%eax),%eax
    5716:	85 c0                	test   %eax,%eax
    5718:	75 07                	jne    5721 <lodepng_huffman_code_lengths+0x12b>
    571a:	ba 04 00 00 00       	mov    $0x4,%edx
    571f:	eb 05                	jmp    5726 <lodepng_huffman_code_lengths+0x130>
    5721:	ba 00 00 00 00       	mov    $0x0,%edx
    5726:	8b 45 08             	mov    0x8(%ebp),%eax
    5729:	01 d0                	add    %edx,%eax
    572b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    5731:	e9 20 02 00 00       	jmp    5956 <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    5736:	83 ec 08             	sub    $0x8,%esp
    5739:	ff 75 ec             	pushl  -0x14(%ebp)
    573c:	ff 75 e4             	pushl  -0x1c(%ebp)
    573f:	e8 2c fb ff ff       	call   5270 <bpmnode_sort>
    5744:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    5747:	8b 45 14             	mov    0x14(%ebp),%eax
    574a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    574d:	8b 45 14             	mov    0x14(%ebp),%eax
    5750:	83 c0 01             	add    $0x1,%eax
    5753:	0f af 45 14          	imul   0x14(%ebp),%eax
    5757:	01 c0                	add    %eax,%eax
    5759:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    575c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    5763:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5766:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    5769:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    576c:	c1 e0 04             	shl    $0x4,%eax
    576f:	83 ec 0c             	sub    $0xc,%esp
    5772:	50                   	push   %eax
    5773:	e8 c5 e2 ff ff       	call   3a3d <lodepng_malloc>
    5778:	83 c4 10             	add    $0x10,%esp
    577b:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    577e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5781:	c1 e0 02             	shl    $0x2,%eax
    5784:	83 ec 0c             	sub    $0xc,%esp
    5787:	50                   	push   %eax
    5788:	e8 b0 e2 ff ff       	call   3a3d <lodepng_malloc>
    578d:	83 c4 10             	add    $0x10,%esp
    5790:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5793:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5796:	c1 e0 02             	shl    $0x2,%eax
    5799:	83 ec 0c             	sub    $0xc,%esp
    579c:	50                   	push   %eax
    579d:	e8 9b e2 ff ff       	call   3a3d <lodepng_malloc>
    57a2:	83 c4 10             	add    $0x10,%esp
    57a5:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    57a8:	8b 45 d8             	mov    -0x28(%ebp),%eax
    57ab:	c1 e0 02             	shl    $0x2,%eax
    57ae:	83 ec 0c             	sub    $0xc,%esp
    57b1:	50                   	push   %eax
    57b2:	e8 86 e2 ff ff       	call   3a3d <lodepng_malloc>
    57b7:	83 c4 10             	add    $0x10,%esp
    57ba:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    57bd:	8b 45 c8             	mov    -0x38(%ebp),%eax
    57c0:	85 c0                	test   %eax,%eax
    57c2:	74 15                	je     57d9 <lodepng_huffman_code_lengths+0x1e3>
    57c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    57c7:	85 c0                	test   %eax,%eax
    57c9:	74 0e                	je     57d9 <lodepng_huffman_code_lengths+0x1e3>
    57cb:	8b 45 dc             	mov    -0x24(%ebp),%eax
    57ce:	85 c0                	test   %eax,%eax
    57d0:	74 07                	je     57d9 <lodepng_huffman_code_lengths+0x1e3>
    57d2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    57d5:	85 c0                	test   %eax,%eax
    57d7:	75 07                	jne    57e0 <lodepng_huffman_code_lengths+0x1ea>
    57d9:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    57e0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    57e4:	0f 85 30 01 00 00    	jne    591a <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    57ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    57f1:	eb 1c                	jmp    580f <lodepng_huffman_code_lengths+0x219>
    57f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    57f6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    57f9:	c1 e2 02             	shl    $0x2,%edx
    57fc:	01 d0                	add    %edx,%eax
    57fe:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5801:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5804:	c1 e1 04             	shl    $0x4,%ecx
    5807:	01 ca                	add    %ecx,%edx
    5809:	89 10                	mov    %edx,(%eax)
    580b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    580f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5812:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5815:	75 dc                	jne    57f3 <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    5817:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    581a:	8b 00                	mov    (%eax),%eax
    581c:	6a 00                	push   $0x0
    581e:	6a 01                	push   $0x1
    5820:	50                   	push   %eax
    5821:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5824:	50                   	push   %eax
    5825:	e8 de f8 ff ff       	call   5108 <bpmnode_create>
    582a:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    582d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5830:	83 c0 10             	add    $0x10,%eax
    5833:	8b 00                	mov    (%eax),%eax
    5835:	6a 00                	push   $0x0
    5837:	6a 02                	push   $0x2
    5839:	50                   	push   %eax
    583a:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    583d:	50                   	push   %eax
    583e:	e8 c5 f8 ff ff       	call   5108 <bpmnode_create>
    5843:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    5846:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    584d:	eb 27                	jmp    5876 <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    584f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5852:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5855:	c1 e2 02             	shl    $0x2,%edx
    5858:	01 c2                	add    %eax,%edx
    585a:	8b 45 c8             	mov    -0x38(%ebp),%eax
    585d:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    585f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5862:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5865:	c1 e2 02             	shl    $0x2,%edx
    5868:	01 d0                	add    %edx,%eax
    586a:	8b 55 c8             	mov    -0x38(%ebp),%edx
    586d:	83 c2 10             	add    $0x10,%edx
    5870:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    5872:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5876:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5879:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    587c:	75 d1                	jne    584f <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    587e:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    5885:	eb 24                	jmp    58ab <lodepng_huffman_code_lengths+0x2b5>
    5887:	8b 45 f0             	mov    -0x10(%ebp),%eax
    588a:	8b 55 14             	mov    0x14(%ebp),%edx
    588d:	83 ea 01             	sub    $0x1,%edx
    5890:	83 ec 0c             	sub    $0xc,%esp
    5893:	50                   	push   %eax
    5894:	52                   	push   %edx
    5895:	ff 75 ec             	pushl  -0x14(%ebp)
    5898:	ff 75 e4             	pushl  -0x1c(%ebp)
    589b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    589e:	50                   	push   %eax
    589f:	e8 7a fb ff ff       	call   541e <boundaryPM>
    58a4:	83 c4 20             	add    $0x20,%esp
    58a7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    58ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58ae:	83 e8 01             	sub    $0x1,%eax
    58b1:	01 c0                	add    %eax,%eax
    58b3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    58b6:	75 cf                	jne    5887 <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    58b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    58bb:	8b 55 14             	mov    0x14(%ebp),%edx
    58be:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    58c4:	c1 e2 02             	shl    $0x2,%edx
    58c7:	01 d0                	add    %edx,%eax
    58c9:	8b 00                	mov    (%eax),%eax
    58cb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    58ce:	eb 44                	jmp    5914 <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    58d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    58d7:	eb 27                	jmp    5900 <lodepng_huffman_code_lengths+0x30a>
    58d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    58dc:	c1 e0 04             	shl    $0x4,%eax
    58df:	89 c2                	mov    %eax,%edx
    58e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    58e4:	01 d0                	add    %edx,%eax
    58e6:	8b 40 04             	mov    0x4(%eax),%eax
    58e9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58f0:	8b 45 08             	mov    0x8(%ebp),%eax
    58f3:	01 d0                	add    %edx,%eax
    58f5:	8b 10                	mov    (%eax),%edx
    58f7:	83 c2 01             	add    $0x1,%edx
    58fa:	89 10                	mov    %edx,(%eax)
    58fc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5900:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5903:	8b 40 04             	mov    0x4(%eax),%eax
    5906:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5909:	75 ce                	jne    58d9 <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    590b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    590e:	8b 40 08             	mov    0x8(%eax),%eax
    5911:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5914:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    5918:	75 b6                	jne    58d0 <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    591a:	8b 45 c8             	mov    -0x38(%ebp),%eax
    591d:	83 ec 0c             	sub    $0xc,%esp
    5920:	50                   	push   %eax
    5921:	e8 38 e1 ff ff       	call   3a5e <lodepng_free>
    5926:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    5929:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    592c:	83 ec 0c             	sub    $0xc,%esp
    592f:	50                   	push   %eax
    5930:	e8 29 e1 ff ff       	call   3a5e <lodepng_free>
    5935:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    5938:	8b 45 dc             	mov    -0x24(%ebp),%eax
    593b:	83 ec 0c             	sub    $0xc,%esp
    593e:	50                   	push   %eax
    593f:	e8 1a e1 ff ff       	call   3a5e <lodepng_free>
    5944:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    5947:	8b 45 e0             	mov    -0x20(%ebp),%eax
    594a:	83 ec 0c             	sub    $0xc,%esp
    594d:	50                   	push   %eax
    594e:	e8 0b e1 ff ff       	call   3a5e <lodepng_free>
    5953:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    5956:	83 ec 0c             	sub    $0xc,%esp
    5959:	ff 75 e4             	pushl  -0x1c(%ebp)
    595c:	e8 fd e0 ff ff       	call   3a5e <lodepng_free>
    5961:	83 c4 10             	add    $0x10,%esp
  return error;
    5964:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5967:	c9                   	leave  
    5968:	c3                   	ret    

00005969 <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    5969:	55                   	push   %ebp
    596a:	89 e5                	mov    %esp,%ebp
    596c:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    596f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    5976:	eb 04                	jmp    597c <HuffmanTree_makeFromFrequencies+0x13>
    5978:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    597c:	8b 45 14             	mov    0x14(%ebp),%eax
    597f:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5984:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    598b:	8b 45 0c             	mov    0xc(%ebp),%eax
    598e:	01 d0                	add    %edx,%eax
    5990:	8b 00                	mov    (%eax),%eax
    5992:	85 c0                	test   %eax,%eax
    5994:	75 08                	jne    599e <HuffmanTree_makeFromFrequencies+0x35>
    5996:	8b 45 14             	mov    0x14(%ebp),%eax
    5999:	3b 45 10             	cmp    0x10(%ebp),%eax
    599c:	7f da                	jg     5978 <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    599e:	8b 45 14             	mov    0x14(%ebp),%eax
    59a1:	c1 e0 02             	shl    $0x2,%eax
    59a4:	83 ec 0c             	sub    $0xc,%esp
    59a7:	50                   	push   %eax
    59a8:	e8 90 e0 ff ff       	call   3a3d <lodepng_malloc>
    59ad:	83 c4 10             	add    $0x10,%esp
    59b0:	89 c2                	mov    %eax,%edx
    59b2:	8b 45 08             	mov    0x8(%ebp),%eax
    59b5:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    59b8:	8b 45 08             	mov    0x8(%ebp),%eax
    59bb:	8b 40 04             	mov    0x4(%eax),%eax
    59be:	85 c0                	test   %eax,%eax
    59c0:	75 07                	jne    59c9 <HuffmanTree_makeFromFrequencies+0x60>
    59c2:	b8 53 00 00 00       	mov    $0x53,%eax
    59c7:	eb 47                	jmp    5a10 <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    59c9:	8b 45 08             	mov    0x8(%ebp),%eax
    59cc:	8b 55 18             	mov    0x18(%ebp),%edx
    59cf:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    59d2:	8b 55 14             	mov    0x14(%ebp),%edx
    59d5:	8b 45 08             	mov    0x8(%ebp),%eax
    59d8:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    59db:	8b 45 08             	mov    0x8(%ebp),%eax
    59de:	8b 40 04             	mov    0x4(%eax),%eax
    59e1:	ff 75 18             	pushl  0x18(%ebp)
    59e4:	ff 75 14             	pushl  0x14(%ebp)
    59e7:	ff 75 0c             	pushl  0xc(%ebp)
    59ea:	50                   	push   %eax
    59eb:	e8 06 fc ff ff       	call   55f6 <lodepng_huffman_code_lengths>
    59f0:	83 c4 10             	add    $0x10,%esp
    59f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    59f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    59fa:	75 11                	jne    5a0d <HuffmanTree_makeFromFrequencies+0xa4>
    59fc:	83 ec 0c             	sub    $0xc,%esp
    59ff:	ff 75 08             	pushl  0x8(%ebp)
    5a02:	e8 37 f4 ff ff       	call   4e3e <HuffmanTree_makeFromLengths2>
    5a07:	83 c4 10             	add    $0x10,%esp
    5a0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    5a0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5a10:	c9                   	leave  
    5a11:	c3                   	ret    

00005a12 <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    5a12:	55                   	push   %ebp
    5a13:	89 e5                	mov    %esp,%ebp
    5a15:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    5a18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    5a1f:	83 ec 0c             	sub    $0xc,%esp
    5a22:	68 80 04 00 00       	push   $0x480
    5a27:	e8 11 e0 ff ff       	call   3a3d <lodepng_malloc>
    5a2c:	83 c4 10             	add    $0x10,%esp
    5a2f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    5a32:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5a36:	75 0a                	jne    5a42 <generateFixedLitLenTree+0x30>
    5a38:	b8 53 00 00 00       	mov    $0x53,%eax
    5a3d:	e9 d5 00 00 00       	jmp    5b17 <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    5a42:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5a49:	eb 19                	jmp    5a64 <generateFixedLitLenTree+0x52>
    5a4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5a4e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a55:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a58:	01 d0                	add    %edx,%eax
    5a5a:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5a60:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5a64:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    5a6b:	76 de                	jbe    5a4b <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    5a6d:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    5a74:	eb 19                	jmp    5a8f <generateFixedLitLenTree+0x7d>
    5a76:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5a79:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a80:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a83:	01 d0                	add    %edx,%eax
    5a85:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    5a8b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5a8f:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    5a96:	76 de                	jbe    5a76 <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    5a98:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    5a9f:	eb 19                	jmp    5aba <generateFixedLitLenTree+0xa8>
    5aa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5aa4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5aab:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5aae:	01 d0                	add    %edx,%eax
    5ab0:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    5ab6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5aba:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    5ac1:	76 de                	jbe    5aa1 <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    5ac3:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    5aca:	eb 19                	jmp    5ae5 <generateFixedLitLenTree+0xd3>
    5acc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5acf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5ad6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ad9:	01 d0                	add    %edx,%eax
    5adb:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5ae1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5ae5:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    5aec:	76 de                	jbe    5acc <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5aee:	6a 0f                	push   $0xf
    5af0:	68 20 01 00 00       	push   $0x120
    5af5:	ff 75 ec             	pushl  -0x14(%ebp)
    5af8:	ff 75 08             	pushl  0x8(%ebp)
    5afb:	e8 7f f5 ff ff       	call   507f <HuffmanTree_makeFromLengths>
    5b00:	83 c4 10             	add    $0x10,%esp
    5b03:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    5b06:	83 ec 0c             	sub    $0xc,%esp
    5b09:	ff 75 ec             	pushl  -0x14(%ebp)
    5b0c:	e8 4d df ff ff       	call   3a5e <lodepng_free>
    5b11:	83 c4 10             	add    $0x10,%esp
  return error;
    5b14:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    5b17:	c9                   	leave  
    5b18:	c3                   	ret    

00005b19 <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    5b19:	55                   	push   %ebp
    5b1a:	89 e5                	mov    %esp,%ebp
    5b1c:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    5b1f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    5b26:	83 ec 0c             	sub    $0xc,%esp
    5b29:	68 80 00 00 00       	push   $0x80
    5b2e:	e8 0a df ff ff       	call   3a3d <lodepng_malloc>
    5b33:	83 c4 10             	add    $0x10,%esp
    5b36:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    5b39:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5b3d:	75 07                	jne    5b46 <generateFixedDistanceTree+0x2d>
    5b3f:	b8 53 00 00 00       	mov    $0x53,%eax
    5b44:	eb 4e                	jmp    5b94 <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    5b46:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5b4d:	eb 19                	jmp    5b68 <generateFixedDistanceTree+0x4f>
    5b4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5b52:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5b59:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5b5c:	01 d0                	add    %edx,%eax
    5b5e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    5b64:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5b68:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    5b6c:	75 e1                	jne    5b4f <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    5b6e:	6a 0f                	push   $0xf
    5b70:	6a 20                	push   $0x20
    5b72:	ff 75 ec             	pushl  -0x14(%ebp)
    5b75:	ff 75 08             	pushl  0x8(%ebp)
    5b78:	e8 02 f5 ff ff       	call   507f <HuffmanTree_makeFromLengths>
    5b7d:	83 c4 10             	add    $0x10,%esp
    5b80:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    5b83:	83 ec 0c             	sub    $0xc,%esp
    5b86:	ff 75 ec             	pushl  -0x14(%ebp)
    5b89:	e8 d0 de ff ff       	call   3a5e <lodepng_free>
    5b8e:	83 c4 10             	add    $0x10,%esp
  return error;
    5b91:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    5b94:	c9                   	leave  
    5b95:	c3                   	ret    

00005b96 <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    5b96:	55                   	push   %ebp
    5b97:	89 e5                	mov    %esp,%ebp
    5b99:	53                   	push   %ebx
    5b9a:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    5b9d:	6a 09                	push   $0x9
    5b9f:	ff 75 08             	pushl  0x8(%ebp)
    5ba2:	e8 d8 eb ff ff       	call   477f <peekBits>
    5ba7:	83 c4 08             	add    $0x8,%esp
    5baa:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    5bae:	8b 45 0c             	mov    0xc(%ebp),%eax
    5bb1:	8b 50 10             	mov    0x10(%eax),%edx
    5bb4:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    5bb8:	01 d0                	add    %edx,%eax
    5bba:	0f b6 00             	movzbl (%eax),%eax
    5bbd:	0f b6 c0             	movzbl %al,%eax
    5bc0:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    5bc4:	8b 45 0c             	mov    0xc(%ebp),%eax
    5bc7:	8b 40 14             	mov    0x14(%eax),%eax
    5bca:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    5bce:	01 d2                	add    %edx,%edx
    5bd0:	01 d0                	add    %edx,%eax
    5bd2:	0f b7 00             	movzwl (%eax),%eax
    5bd5:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    5bd9:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    5bde:	77 16                	ja     5bf6 <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    5be0:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    5be4:	50                   	push   %eax
    5be5:	ff 75 08             	pushl  0x8(%ebp)
    5be8:	e8 b2 eb ff ff       	call   479f <advanceBits>
    5bed:	83 c4 08             	add    $0x8,%esp
    return value;
    5bf0:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    5bf4:	eb 5c                	jmp    5c52 <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    5bf6:	6a 09                	push   $0x9
    5bf8:	ff 75 08             	pushl  0x8(%ebp)
    5bfb:	e8 9f eb ff ff       	call   479f <advanceBits>
    5c00:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    5c03:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    5c07:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    5c0b:	83 e8 09             	sub    $0x9,%eax
    5c0e:	50                   	push   %eax
    5c0f:	ff 75 08             	pushl  0x8(%ebp)
    5c12:	e8 68 eb ff ff       	call   477f <peekBits>
    5c17:	83 c4 08             	add    $0x8,%esp
    5c1a:	01 d8                	add    %ebx,%eax
    5c1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    5c1f:	8b 45 0c             	mov    0xc(%ebp),%eax
    5c22:	8b 50 10             	mov    0x10(%eax),%edx
    5c25:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c28:	01 d0                	add    %edx,%eax
    5c2a:	0f b6 00             	movzbl (%eax),%eax
    5c2d:	0f b6 c0             	movzbl %al,%eax
    5c30:	83 e8 09             	sub    $0x9,%eax
    5c33:	50                   	push   %eax
    5c34:	ff 75 08             	pushl  0x8(%ebp)
    5c37:	e8 63 eb ff ff       	call   479f <advanceBits>
    5c3c:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    5c3f:	8b 45 0c             	mov    0xc(%ebp),%eax
    5c42:	8b 40 14             	mov    0x14(%eax),%eax
    5c45:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5c48:	01 d2                	add    %edx,%edx
    5c4a:	01 d0                	add    %edx,%eax
    5c4c:	0f b7 00             	movzwl (%eax),%eax
    5c4f:	0f b7 c0             	movzwl %ax,%eax
  }
}
    5c52:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5c55:	c9                   	leave  
    5c56:	c3                   	ret    

00005c57 <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    5c57:	55                   	push   %ebp
    5c58:	89 e5                	mov    %esp,%ebp
    5c5a:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    5c5d:	83 ec 0c             	sub    $0xc,%esp
    5c60:	ff 75 08             	pushl  0x8(%ebp)
    5c63:	e8 aa fd ff ff       	call   5a12 <generateFixedLitLenTree>
    5c68:	83 c4 10             	add    $0x10,%esp
    5c6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    5c6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5c72:	74 05                	je     5c79 <getTreeInflateFixed+0x22>
    5c74:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5c77:	eb 0e                	jmp    5c87 <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    5c79:	83 ec 0c             	sub    $0xc,%esp
    5c7c:	ff 75 0c             	pushl  0xc(%ebp)
    5c7f:	e8 95 fe ff ff       	call   5b19 <generateFixedDistanceTree>
    5c84:	83 c4 10             	add    $0x10,%esp
}
    5c87:	c9                   	leave  
    5c88:	c3                   	ret    

00005c89 <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    5c89:	55                   	push   %ebp
    5c8a:	89 e5                	mov    %esp,%ebp
    5c8c:	53                   	push   %ebx
    5c8d:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    5c90:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    5c97:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    5c9e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    5ca5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    5cac:	6a 0e                	push   $0xe
    5cae:	ff 75 10             	pushl  0x10(%ebp)
    5cb1:	e8 37 e6 ff ff       	call   42ed <ensureBits17>
    5cb6:	83 c4 08             	add    $0x8,%esp
    5cb9:	85 c0                	test   %eax,%eax
    5cbb:	75 0a                	jne    5cc7 <getTreeInflateDynamic+0x3e>
    5cbd:	b8 31 00 00 00       	mov    $0x31,%eax
    5cc2:	e9 ec 04 00 00       	jmp    61b3 <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    5cc7:	6a 05                	push   $0x5
    5cc9:	ff 75 10             	pushl  0x10(%ebp)
    5ccc:	e8 f8 ea ff ff       	call   47c9 <readBits>
    5cd1:	83 c4 08             	add    $0x8,%esp
    5cd4:	05 01 01 00 00       	add    $0x101,%eax
    5cd9:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    5cdc:	6a 05                	push   $0x5
    5cde:	ff 75 10             	pushl  0x10(%ebp)
    5ce1:	e8 e3 ea ff ff       	call   47c9 <readBits>
    5ce6:	83 c4 08             	add    $0x8,%esp
    5ce9:	83 c0 01             	add    $0x1,%eax
    5cec:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    5cef:	6a 04                	push   $0x4
    5cf1:	ff 75 10             	pushl  0x10(%ebp)
    5cf4:	e8 d0 ea ff ff       	call   47c9 <readBits>
    5cf9:	83 c4 08             	add    $0x8,%esp
    5cfc:	83 c0 04             	add    $0x4,%eax
    5cff:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    5d02:	83 ec 0c             	sub    $0xc,%esp
    5d05:	6a 4c                	push   $0x4c
    5d07:	e8 31 dd ff ff       	call   3a3d <lodepng_malloc>
    5d0c:	83 c4 10             	add    $0x10,%esp
    5d0f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    5d12:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    5d16:	75 0a                	jne    5d22 <getTreeInflateDynamic+0x99>
    5d18:	b8 53 00 00 00       	mov    $0x53,%eax
    5d1d:	e9 91 04 00 00       	jmp    61b3 <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    5d22:	83 ec 0c             	sub    $0xc,%esp
    5d25:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5d28:	50                   	push   %eax
    5d29:	e8 03 ec ff ff       	call   4931 <HuffmanTree_init>
    5d2e:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    5d31:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5d35:	0f 85 3c 04 00 00    	jne    6177 <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    5d3b:	8b 45 10             	mov    0x10(%ebp),%eax
    5d3e:	8b 48 08             	mov    0x8(%eax),%ecx
    5d41:	8b 55 d0             	mov    -0x30(%ebp),%edx
    5d44:	89 d0                	mov    %edx,%eax
    5d46:	01 c0                	add    %eax,%eax
    5d48:	01 d0                	add    %edx,%eax
    5d4a:	89 c2                	mov    %eax,%edx
    5d4c:	8b 45 10             	mov    0x10(%ebp),%eax
    5d4f:	8b 40 0c             	mov    0xc(%eax),%eax
    5d52:	83 ec 04             	sub    $0x4,%esp
    5d55:	51                   	push   %ecx
    5d56:	52                   	push   %edx
    5d57:	50                   	push   %eax
    5d58:	e8 f7 dd ff ff       	call   3b54 <lodepng_gtofl>
    5d5d:	83 c4 10             	add    $0x10,%esp
    5d60:	85 c0                	test   %eax,%eax
    5d62:	74 0c                	je     5d70 <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    5d64:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5d6b:	e9 07 04 00 00       	jmp    6177 <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    5d70:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    5d77:	eb 3d                	jmp    5db6 <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    5d79:	83 ec 08             	sub    $0x8,%esp
    5d7c:	6a 03                	push   $0x3
    5d7e:	ff 75 10             	pushl  0x10(%ebp)
    5d81:	e8 8b e4 ff ff       	call   4211 <ensureBits9>
    5d86:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    5d89:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d8c:	8b 04 85 80 a6 01 00 	mov    0x1a680(,%eax,4),%eax
    5d93:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5d9a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5d9d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    5da0:	83 ec 08             	sub    $0x8,%esp
    5da3:	6a 03                	push   $0x3
    5da5:	ff 75 10             	pushl  0x10(%ebp)
    5da8:	e8 1c ea ff ff       	call   47c9 <readBits>
    5dad:	83 c4 10             	add    $0x10,%esp
    5db0:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    5db2:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5db6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5db9:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    5dbc:	75 bb                	jne    5d79 <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5dbe:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5dc1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5dc4:	eb 20                	jmp    5de6 <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    5dc6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5dc9:	8b 04 85 80 a6 01 00 	mov    0x1a680(,%eax,4),%eax
    5dd0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5dd7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5dda:	01 d0                	add    %edx,%eax
    5ddc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5de2:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5de6:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    5dea:	75 da                	jne    5dc6 <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    5dec:	6a 07                	push   $0x7
    5dee:	6a 13                	push   $0x13
    5df0:	ff 75 dc             	pushl  -0x24(%ebp)
    5df3:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5df6:	50                   	push   %eax
    5df7:	e8 83 f2 ff ff       	call   507f <HuffmanTree_makeFromLengths>
    5dfc:	83 c4 10             	add    $0x10,%esp
    5dff:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5e02:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5e06:	0f 85 64 03 00 00    	jne    6170 <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    5e0c:	83 ec 0c             	sub    $0xc,%esp
    5e0f:	68 80 04 00 00       	push   $0x480
    5e14:	e8 24 dc ff ff       	call   3a3d <lodepng_malloc>
    5e19:	83 c4 10             	add    $0x10,%esp
    5e1c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    5e1f:	83 ec 0c             	sub    $0xc,%esp
    5e22:	68 80 00 00 00       	push   $0x80
    5e27:	e8 11 dc ff ff       	call   3a3d <lodepng_malloc>
    5e2c:	83 c4 10             	add    $0x10,%esp
    5e2f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    5e32:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    5e36:	74 06                	je     5e3e <getTreeInflateDynamic+0x1b5>
    5e38:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5e3c:	75 0c                	jne    5e4a <getTreeInflateDynamic+0x1c1>
    5e3e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5e45:	e9 2d 03 00 00       	jmp    6177 <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    5e4a:	83 ec 04             	sub    $0x4,%esp
    5e4d:	68 80 04 00 00       	push   $0x480
    5e52:	6a 00                	push   $0x0
    5e54:	ff 75 e8             	pushl  -0x18(%ebp)
    5e57:	e8 52 dc ff ff       	call   3aae <lodepng_memset>
    5e5c:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    5e5f:	83 ec 04             	sub    $0x4,%esp
    5e62:	68 80 00 00 00       	push   $0x80
    5e67:	6a 00                	push   $0x0
    5e69:	ff 75 e4             	pushl  -0x1c(%ebp)
    5e6c:	e8 3d dc ff ff       	call   3aae <lodepng_memset>
    5e71:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    5e74:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    5e7b:	e9 8d 02 00 00       	jmp    610d <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    5e80:	83 ec 08             	sub    $0x8,%esp
    5e83:	6a 16                	push   $0x16
    5e85:	ff 75 10             	pushl  0x10(%ebp)
    5e88:	e8 8c e5 ff ff       	call   4419 <ensureBits25>
    5e8d:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    5e90:	83 ec 08             	sub    $0x8,%esp
    5e93:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5e96:	50                   	push   %eax
    5e97:	ff 75 10             	pushl  0x10(%ebp)
    5e9a:	e8 f7 fc ff ff       	call   5b96 <huffmanDecodeSymbol>
    5e9f:	83 c4 10             	add    $0x10,%esp
    5ea2:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    5ea5:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    5ea9:	77 3e                	ja     5ee9 <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    5eab:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5eae:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5eb1:	73 16                	jae    5ec9 <getTreeInflateDynamic+0x240>
    5eb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5eb6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5ebd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5ec0:	01 c2                	add    %eax,%edx
    5ec2:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5ec5:	89 02                	mov    %eax,(%edx)
    5ec7:	eb 17                	jmp    5ee0 <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    5ec9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ecc:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5ecf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5ed6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5ed9:	01 c2                	add    %eax,%edx
    5edb:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5ede:	89 02                	mov    %eax,(%edx)
        ++i;
    5ee0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5ee4:	e9 0b 02 00 00       	jmp    60f4 <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    5ee9:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    5eed:	0f 85 da 00 00 00    	jne    5fcd <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    5ef3:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    5efa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5efe:	75 0c                	jne    5f0c <getTreeInflateDynamic+0x283>
    5f00:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    5f07:	e9 12 02 00 00       	jmp    611e <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    5f0c:	83 ec 08             	sub    $0x8,%esp
    5f0f:	6a 02                	push   $0x2
    5f11:	ff 75 10             	pushl  0x10(%ebp)
    5f14:	e8 b0 e8 ff ff       	call   47c9 <readBits>
    5f19:	83 c4 10             	add    $0x10,%esp
    5f1c:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    5f1f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5f22:	83 c0 01             	add    $0x1,%eax
    5f25:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5f28:	76 1b                	jbe    5f45 <getTreeInflateDynamic+0x2bc>
    5f2a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f2d:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5f32:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5f39:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5f3c:	01 d0                	add    %edx,%eax
    5f3e:	8b 00                	mov    (%eax),%eax
    5f40:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5f43:	eb 1c                	jmp    5f61 <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    5f45:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f48:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5f4b:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5f50:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5f57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5f5a:	01 d0                	add    %edx,%eax
    5f5c:	8b 00                	mov    (%eax),%eax
    5f5e:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5f61:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5f68:	eb 56                	jmp    5fc0 <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    5f6a:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5f6d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5f70:	01 d0                	add    %edx,%eax
    5f72:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5f75:	77 0c                	ja     5f83 <getTreeInflateDynamic+0x2fa>
    5f77:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    5f7e:	e9 71 01 00 00       	jmp    60f4 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    5f83:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f86:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5f89:	73 16                	jae    5fa1 <getTreeInflateDynamic+0x318>
    5f8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f8e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5f95:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5f98:	01 c2                	add    %eax,%edx
    5f9a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5f9d:	89 02                	mov    %eax,(%edx)
    5f9f:	eb 17                	jmp    5fb8 <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    5fa1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5fa4:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5fa7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5fae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5fb1:	01 c2                	add    %eax,%edx
    5fb3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5fb6:	89 02                	mov    %eax,(%edx)
          ++i;
    5fb8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5fbc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5fc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5fc3:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    5fc6:	72 a2                	jb     5f6a <getTreeInflateDynamic+0x2e1>
    5fc8:	e9 27 01 00 00       	jmp    60f4 <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    5fcd:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    5fd1:	0f 85 88 00 00 00    	jne    605f <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    5fd7:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    5fde:	83 ec 08             	sub    $0x8,%esp
    5fe1:	6a 03                	push   $0x3
    5fe3:	ff 75 10             	pushl  0x10(%ebp)
    5fe6:	e8 de e7 ff ff       	call   47c9 <readBits>
    5feb:	83 c4 10             	add    $0x10,%esp
    5fee:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5ff1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5ff8:	eb 58                	jmp    6052 <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    5ffa:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5ffd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6000:	01 d0                	add    %edx,%eax
    6002:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6005:	77 0c                	ja     6013 <getTreeInflateDynamic+0x38a>
    6007:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    600e:	e9 e1 00 00 00       	jmp    60f4 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    6013:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6016:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6019:	73 17                	jae    6032 <getTreeInflateDynamic+0x3a9>
    601b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    601e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6025:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6028:	01 d0                	add    %edx,%eax
    602a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    6030:	eb 18                	jmp    604a <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    6032:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6035:	2b 45 d8             	sub    -0x28(%ebp),%eax
    6038:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    603f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6042:	01 d0                	add    %edx,%eax
    6044:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    604a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    604e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    6052:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6055:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    6058:	72 a0                	jb     5ffa <getTreeInflateDynamic+0x371>
    605a:	e9 95 00 00 00       	jmp    60f4 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    605f:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    6063:	0f 85 82 00 00 00    	jne    60eb <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    6069:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    6070:	83 ec 08             	sub    $0x8,%esp
    6073:	6a 07                	push   $0x7
    6075:	ff 75 10             	pushl  0x10(%ebp)
    6078:	e8 4c e7 ff ff       	call   47c9 <readBits>
    607d:	83 c4 10             	add    $0x10,%esp
    6080:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    6083:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    608a:	eb 55                	jmp    60e1 <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    608c:	8b 55 d8             	mov    -0x28(%ebp),%edx
    608f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6092:	01 d0                	add    %edx,%eax
    6094:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6097:	77 09                	ja     60a2 <getTreeInflateDynamic+0x419>
    6099:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    60a0:	eb 52                	jmp    60f4 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    60a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    60a5:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    60a8:	73 17                	jae    60c1 <getTreeInflateDynamic+0x438>
    60aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    60ad:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    60b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    60b7:	01 d0                	add    %edx,%eax
    60b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    60bf:	eb 18                	jmp    60d9 <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    60c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    60c4:	2b 45 d8             	sub    -0x28(%ebp),%eax
    60c7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    60ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    60d1:	01 d0                	add    %edx,%eax
    60d3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    60d9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    60dd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    60e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    60e4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    60e7:	72 a3                	jb     608c <getTreeInflateDynamic+0x403>
    60e9:	eb 09                	jmp    60f4 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    60eb:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    60f2:	eb 2a                	jmp    611e <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    60f4:	8b 45 10             	mov    0x10(%ebp),%eax
    60f7:	8b 50 0c             	mov    0xc(%eax),%edx
    60fa:	8b 45 10             	mov    0x10(%ebp),%eax
    60fd:	8b 40 08             	mov    0x8(%eax),%eax
    6100:	39 c2                	cmp    %eax,%edx
    6102:	7e 09                	jle    610d <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    6104:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    610b:	eb 11                	jmp    611e <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    610d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    6110:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6113:	01 d0                	add    %edx,%eax
    6115:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6118:	0f 87 62 fd ff ff    	ja     5e80 <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    611e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6122:	75 4f                	jne    6173 <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    6124:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6127:	05 00 04 00 00       	add    $0x400,%eax
    612c:	8b 00                	mov    (%eax),%eax
    612e:	85 c0                	test   %eax,%eax
    6130:	75 09                	jne    613b <getTreeInflateDynamic+0x4b2>
    6132:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    6139:	eb 3c                	jmp    6177 <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    613b:	6a 0f                	push   $0xf
    613d:	68 20 01 00 00       	push   $0x120
    6142:	ff 75 e8             	pushl  -0x18(%ebp)
    6145:	ff 75 08             	pushl  0x8(%ebp)
    6148:	e8 32 ef ff ff       	call   507f <HuffmanTree_makeFromLengths>
    614d:	83 c4 10             	add    $0x10,%esp
    6150:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    6153:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6157:	75 1d                	jne    6176 <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    6159:	6a 0f                	push   $0xf
    615b:	6a 20                	push   $0x20
    615d:	ff 75 e4             	pushl  -0x1c(%ebp)
    6160:	ff 75 0c             	pushl  0xc(%ebp)
    6163:	e8 17 ef ff ff       	call   507f <HuffmanTree_makeFromLengths>
    6168:	83 c4 10             	add    $0x10,%esp
    616b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    616e:	eb 07                	jmp    6177 <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    6170:	90                   	nop
    6171:	eb 04                	jmp    6177 <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    6173:	90                   	nop
    6174:	eb 01                	jmp    6177 <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    6176:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    6177:	83 ec 0c             	sub    $0xc,%esp
    617a:	ff 75 dc             	pushl  -0x24(%ebp)
    617d:	e8 dc d8 ff ff       	call   3a5e <lodepng_free>
    6182:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    6185:	83 ec 0c             	sub    $0xc,%esp
    6188:	ff 75 e8             	pushl  -0x18(%ebp)
    618b:	e8 ce d8 ff ff       	call   3a5e <lodepng_free>
    6190:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    6193:	83 ec 0c             	sub    $0xc,%esp
    6196:	ff 75 e4             	pushl  -0x1c(%ebp)
    6199:	e8 c0 d8 ff ff       	call   3a5e <lodepng_free>
    619e:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    61a1:	83 ec 0c             	sub    $0xc,%esp
    61a4:	8d 45 a8             	lea    -0x58(%ebp),%eax
    61a7:	50                   	push   %eax
    61a8:	e8 b1 e7 ff ff       	call   495e <HuffmanTree_cleanup>
    61ad:	83 c4 10             	add    $0x10,%esp

  return error;
    61b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    61b3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    61b6:	c9                   	leave  
    61b7:	c3                   	ret    

000061b8 <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    61b8:	55                   	push   %ebp
    61b9:	89 e5                	mov    %esp,%ebp
    61bb:	53                   	push   %ebx
    61bc:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    61bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    61c6:	8d 45 b8             	lea    -0x48(%ebp),%eax
    61c9:	50                   	push   %eax
    61ca:	e8 62 e7 ff ff       	call   4931 <HuffmanTree_init>
    61cf:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    61d2:	8d 45 a0             	lea    -0x60(%ebp),%eax
    61d5:	50                   	push   %eax
    61d6:	e8 56 e7 ff ff       	call   4931 <HuffmanTree_init>
    61db:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    61de:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    61e2:	75 1b                	jne    61ff <inflateHuffmanBlock+0x47>
    61e4:	83 ec 08             	sub    $0x8,%esp
    61e7:	8d 45 a0             	lea    -0x60(%ebp),%eax
    61ea:	50                   	push   %eax
    61eb:	8d 45 b8             	lea    -0x48(%ebp),%eax
    61ee:	50                   	push   %eax
    61ef:	e8 63 fa ff ff       	call   5c57 <getTreeInflateFixed>
    61f4:	83 c4 10             	add    $0x10,%esp
    61f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    61fa:	e9 9a 02 00 00       	jmp    6499 <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    61ff:	83 ec 04             	sub    $0x4,%esp
    6202:	ff 75 0c             	pushl  0xc(%ebp)
    6205:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6208:	50                   	push   %eax
    6209:	8d 45 b8             	lea    -0x48(%ebp),%eax
    620c:	50                   	push   %eax
    620d:	e8 77 fa ff ff       	call   5c89 <getTreeInflateDynamic>
    6212:	83 c4 10             	add    $0x10,%esp
    6215:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    6218:	e9 7c 02 00 00       	jmp    6499 <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    621d:	83 ec 08             	sub    $0x8,%esp
    6220:	6a 14                	push   $0x14
    6222:	ff 75 0c             	pushl  0xc(%ebp)
    6225:	e8 ef e1 ff ff       	call   4419 <ensureBits25>
    622a:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    622d:	83 ec 08             	sub    $0x8,%esp
    6230:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6233:	50                   	push   %eax
    6234:	ff 75 0c             	pushl  0xc(%ebp)
    6237:	e8 5a f9 ff ff       	call   5b96 <huffmanDecodeSymbol>
    623c:	83 c4 10             	add    $0x10,%esp
    623f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    6242:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    6249:	77 42                	ja     628d <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    624b:	8b 45 08             	mov    0x8(%ebp),%eax
    624e:	8b 40 04             	mov    0x4(%eax),%eax
    6251:	83 c0 01             	add    $0x1,%eax
    6254:	83 ec 08             	sub    $0x8,%esp
    6257:	50                   	push   %eax
    6258:	ff 75 08             	pushl  0x8(%ebp)
    625b:	e8 37 da ff ff       	call   3c97 <ucvector_resize>
    6260:	83 c4 10             	add    $0x10,%esp
    6263:	85 c0                	test   %eax,%eax
    6265:	75 0c                	jne    6273 <inflateHuffmanBlock+0xbb>
    6267:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    626e:	e9 33 02 00 00       	jmp    64a6 <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    6273:	8b 45 08             	mov    0x8(%ebp),%eax
    6276:	8b 10                	mov    (%eax),%edx
    6278:	8b 45 08             	mov    0x8(%ebp),%eax
    627b:	8b 40 04             	mov    0x4(%eax),%eax
    627e:	83 e8 01             	sub    $0x1,%eax
    6281:	01 d0                	add    %edx,%eax
    6283:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6286:	88 10                	mov    %dl,(%eax)
    6288:	e9 d9 01 00 00       	jmp    6466 <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    628d:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    6294:	0f 86 ba 01 00 00    	jbe    6454 <inflateHuffmanBlock+0x29c>
    629a:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    62a1:	0f 87 ad 01 00 00    	ja     6454 <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    62a7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    62aa:	2d 01 01 00 00       	sub    $0x101,%eax
    62af:	8b 04 85 80 a4 01 00 	mov    0x1a480(,%eax,4),%eax
    62b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    62b9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    62bc:	2d 01 01 00 00       	sub    $0x101,%eax
    62c1:	8b 04 85 00 a5 01 00 	mov    0x1a500(,%eax,4),%eax
    62c8:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    62cb:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    62cf:	74 1c                	je     62ed <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    62d1:	8b 45 d8             	mov    -0x28(%ebp),%eax
    62d4:	83 ec 08             	sub    $0x8,%esp
    62d7:	50                   	push   %eax
    62d8:	ff 75 0c             	pushl  0xc(%ebp)
    62db:	e8 e9 e4 ff ff       	call   47c9 <readBits>
    62e0:	83 c4 10             	add    $0x10,%esp
    62e3:	89 c2                	mov    %eax,%edx
    62e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    62e8:	01 d0                	add    %edx,%eax
    62ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    62ed:	83 ec 08             	sub    $0x8,%esp
    62f0:	6a 1c                	push   $0x1c
    62f2:	ff 75 0c             	pushl  0xc(%ebp)
    62f5:	e8 98 e2 ff ff       	call   4592 <ensureBits32>
    62fa:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    62fd:	83 ec 08             	sub    $0x8,%esp
    6300:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6303:	50                   	push   %eax
    6304:	ff 75 0c             	pushl  0xc(%ebp)
    6307:	e8 8a f8 ff ff       	call   5b96 <huffmanDecodeSymbol>
    630c:	83 c4 10             	add    $0x10,%esp
    630f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    6312:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    6316:	76 1e                	jbe    6336 <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    6318:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    631c:	77 0c                	ja     632a <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    631e:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    6325:	e9 7c 01 00 00       	jmp    64a6 <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    632a:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    6331:	e9 70 01 00 00       	jmp    64a6 <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    6336:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6339:	8b 04 85 80 a5 01 00 	mov    0x1a580(,%eax,4),%eax
    6340:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    6343:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6346:	8b 04 85 00 a6 01 00 	mov    0x1a600(,%eax,4),%eax
    634d:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    6350:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    6354:	74 15                	je     636b <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    6356:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6359:	83 ec 08             	sub    $0x8,%esp
    635c:	50                   	push   %eax
    635d:	ff 75 0c             	pushl  0xc(%ebp)
    6360:	e8 64 e4 ff ff       	call   47c9 <readBits>
    6365:	83 c4 10             	add    $0x10,%esp
    6368:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    636b:	8b 45 08             	mov    0x8(%ebp),%eax
    636e:	8b 40 04             	mov    0x4(%eax),%eax
    6371:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    6374:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6377:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    637a:	76 0c                	jbe    6388 <inflateHuffmanBlock+0x1d0>
    637c:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    6383:	e9 1e 01 00 00       	jmp    64a6 <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    6388:	8b 45 ec             	mov    -0x14(%ebp),%eax
    638b:	2b 45 f0             	sub    -0x10(%ebp),%eax
    638e:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    6391:	8b 45 08             	mov    0x8(%ebp),%eax
    6394:	8b 50 04             	mov    0x4(%eax),%edx
    6397:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    639a:	01 d0                	add    %edx,%eax
    639c:	83 ec 08             	sub    $0x8,%esp
    639f:	50                   	push   %eax
    63a0:	ff 75 08             	pushl  0x8(%ebp)
    63a3:	e8 ef d8 ff ff       	call   3c97 <ucvector_resize>
    63a8:	83 c4 10             	add    $0x10,%esp
    63ab:	85 c0                	test   %eax,%eax
    63ad:	75 0c                	jne    63bb <inflateHuffmanBlock+0x203>
    63af:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    63b6:	e9 eb 00 00 00       	jmp    64a6 <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    63bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    63be:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    63c1:	73 6b                	jae    642e <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    63c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    63c6:	8b 55 08             	mov    0x8(%ebp),%edx
    63c9:	8b 0a                	mov    (%edx),%ecx
    63cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
    63ce:	01 d1                	add    %edx,%ecx
    63d0:	8b 55 08             	mov    0x8(%ebp),%edx
    63d3:	8b 1a                	mov    (%edx),%ebx
    63d5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    63d8:	01 da                	add    %ebx,%edx
    63da:	83 ec 04             	sub    $0x4,%esp
    63dd:	50                   	push   %eax
    63de:	51                   	push   %ecx
    63df:	52                   	push   %edx
    63e0:	e8 96 d6 ff ff       	call   3a7b <lodepng_memcpy>
    63e5:	83 c4 10             	add    $0x10,%esp
        start += distance;
    63e8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    63eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    63ee:	01 d0                	add    %edx,%eax
    63f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    63f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    63f6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    63f9:	eb 29                	jmp    6424 <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    63fb:	8b 45 08             	mov    0x8(%ebp),%eax
    63fe:	8b 08                	mov    (%eax),%ecx
    6400:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6403:	8d 50 01             	lea    0x1(%eax),%edx
    6406:	89 55 ec             	mov    %edx,-0x14(%ebp)
    6409:	01 c1                	add    %eax,%ecx
    640b:	8b 45 08             	mov    0x8(%ebp),%eax
    640e:	8b 18                	mov    (%eax),%ebx
    6410:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6413:	8d 50 01             	lea    0x1(%eax),%edx
    6416:	89 55 e8             	mov    %edx,-0x18(%ebp)
    6419:	01 d8                	add    %ebx,%eax
    641b:	0f b6 00             	movzbl (%eax),%eax
    641e:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    6420:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    6424:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6427:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    642a:	7c cf                	jl     63fb <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    642c:	eb 38                	jmp    6466 <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    642e:	8b 45 08             	mov    0x8(%ebp),%eax
    6431:	8b 10                	mov    (%eax),%edx
    6433:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6436:	01 c2                	add    %eax,%edx
    6438:	8b 45 08             	mov    0x8(%ebp),%eax
    643b:	8b 08                	mov    (%eax),%ecx
    643d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6440:	01 c8                	add    %ecx,%eax
    6442:	83 ec 04             	sub    $0x4,%esp
    6445:	ff 75 e4             	pushl  -0x1c(%ebp)
    6448:	52                   	push   %edx
    6449:	50                   	push   %eax
    644a:	e8 2c d6 ff ff       	call   3a7b <lodepng_memcpy>
    644f:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    6452:	eb 12                	jmp    6466 <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    6454:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    645b:	74 48                	je     64a5 <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    645d:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    6464:	eb 40                	jmp    64a6 <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    6466:	8b 45 0c             	mov    0xc(%ebp),%eax
    6469:	8b 50 0c             	mov    0xc(%eax),%edx
    646c:	8b 45 0c             	mov    0xc(%ebp),%eax
    646f:	8b 40 08             	mov    0x8(%eax),%eax
    6472:	39 c2                	cmp    %eax,%edx
    6474:	7e 09                	jle    647f <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    6476:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    647d:	eb 27                	jmp    64a6 <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    647f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    6483:	74 14                	je     6499 <inflateHuffmanBlock+0x2e1>
    6485:	8b 45 08             	mov    0x8(%ebp),%eax
    6488:	8b 40 04             	mov    0x4(%eax),%eax
    648b:	3b 45 14             	cmp    0x14(%ebp),%eax
    648e:	7e 09                	jle    6499 <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    6490:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    6497:	eb 0d                	jmp    64a6 <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    6499:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    649d:	0f 84 7a fd ff ff    	je     621d <inflateHuffmanBlock+0x65>
    64a3:	eb 01                	jmp    64a6 <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    64a5:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    64a6:	83 ec 0c             	sub    $0xc,%esp
    64a9:	8d 45 b8             	lea    -0x48(%ebp),%eax
    64ac:	50                   	push   %eax
    64ad:	e8 ac e4 ff ff       	call   495e <HuffmanTree_cleanup>
    64b2:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    64b5:	83 ec 0c             	sub    $0xc,%esp
    64b8:	8d 45 a0             	lea    -0x60(%ebp),%eax
    64bb:	50                   	push   %eax
    64bc:	e8 9d e4 ff ff       	call   495e <HuffmanTree_cleanup>
    64c1:	83 c4 10             	add    $0x10,%esp

  return error;
    64c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    64c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    64ca:	c9                   	leave  
    64cb:	c3                   	ret    

000064cc <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    64cc:	55                   	push   %ebp
    64cd:	89 e5                	mov    %esp,%ebp
    64cf:	53                   	push   %ebx
    64d0:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    64d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    64d6:	8b 40 04             	mov    0x4(%eax),%eax
    64d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    64dc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    64e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    64e6:	8b 40 0c             	mov    0xc(%eax),%eax
    64e9:	83 c0 07             	add    $0x7,%eax
    64ec:	c1 e8 03             	shr    $0x3,%eax
    64ef:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    64f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    64f5:	83 c0 04             	add    $0x4,%eax
    64f8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    64fb:	7c 0a                	jl     6507 <inflateNoCompression+0x3b>
    64fd:	b8 34 00 00 00       	mov    $0x34,%eax
    6502:	e9 01 01 00 00       	jmp    6608 <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    6507:	8b 45 0c             	mov    0xc(%ebp),%eax
    650a:	8b 10                	mov    (%eax),%edx
    650c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    650f:	01 d0                	add    %edx,%eax
    6511:	0f b6 00             	movzbl (%eax),%eax
    6514:	0f b6 d0             	movzbl %al,%edx
    6517:	8b 45 0c             	mov    0xc(%ebp),%eax
    651a:	8b 00                	mov    (%eax),%eax
    651c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    651f:	83 c1 01             	add    $0x1,%ecx
    6522:	01 c8                	add    %ecx,%eax
    6524:	0f b6 00             	movzbl (%eax),%eax
    6527:	0f b6 c0             	movzbl %al,%eax
    652a:	c1 e0 08             	shl    $0x8,%eax
    652d:	01 d0                	add    %edx,%eax
    652f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    6532:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    6536:	8b 45 0c             	mov    0xc(%ebp),%eax
    6539:	8b 10                	mov    (%eax),%edx
    653b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    653e:	01 d0                	add    %edx,%eax
    6540:	0f b6 00             	movzbl (%eax),%eax
    6543:	0f b6 d0             	movzbl %al,%edx
    6546:	8b 45 0c             	mov    0xc(%ebp),%eax
    6549:	8b 00                	mov    (%eax),%eax
    654b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    654e:	83 c1 01             	add    $0x1,%ecx
    6551:	01 c8                	add    %ecx,%eax
    6553:	0f b6 00             	movzbl (%eax),%eax
    6556:	0f b6 c0             	movzbl %al,%eax
    6559:	c1 e0 08             	shl    $0x8,%eax
    655c:	01 d0                	add    %edx,%eax
    655e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    6561:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    6565:	8b 45 10             	mov    0x10(%ebp),%eax
    6568:	8b 40 04             	mov    0x4(%eax),%eax
    656b:	85 c0                	test   %eax,%eax
    656d:	75 19                	jne    6588 <inflateNoCompression+0xbc>
    656f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6572:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6575:	01 d0                	add    %edx,%eax
    6577:	3d ff ff 00 00       	cmp    $0xffff,%eax
    657c:	74 0a                	je     6588 <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    657e:	b8 15 00 00 00       	mov    $0x15,%eax
    6583:	e9 80 00 00 00       	jmp    6608 <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    6588:	8b 45 08             	mov    0x8(%ebp),%eax
    658b:	8b 40 04             	mov    0x4(%eax),%eax
    658e:	89 c2                	mov    %eax,%edx
    6590:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6593:	01 d0                	add    %edx,%eax
    6595:	50                   	push   %eax
    6596:	ff 75 08             	pushl  0x8(%ebp)
    6599:	e8 f9 d6 ff ff       	call   3c97 <ucvector_resize>
    659e:	83 c4 08             	add    $0x8,%esp
    65a1:	85 c0                	test   %eax,%eax
    65a3:	75 07                	jne    65ac <inflateNoCompression+0xe0>
    65a5:	b8 53 00 00 00       	mov    $0x53,%eax
    65aa:	eb 5c                	jmp    6608 <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    65ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
    65af:	8b 45 ec             	mov    -0x14(%ebp),%eax
    65b2:	01 c2                	add    %eax,%edx
    65b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    65b7:	39 c2                	cmp    %eax,%edx
    65b9:	76 07                	jbe    65c2 <inflateNoCompression+0xf6>
    65bb:	b8 17 00 00 00       	mov    $0x17,%eax
    65c0:	eb 46                	jmp    6608 <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    65c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    65c5:	8b 55 0c             	mov    0xc(%ebp),%edx
    65c8:	8b 0a                	mov    (%edx),%ecx
    65ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
    65cd:	01 d1                	add    %edx,%ecx
    65cf:	8b 55 08             	mov    0x8(%ebp),%edx
    65d2:	8b 1a                	mov    (%edx),%ebx
    65d4:	8b 55 08             	mov    0x8(%ebp),%edx
    65d7:	8b 52 04             	mov    0x4(%edx),%edx
    65da:	2b 55 ec             	sub    -0x14(%ebp),%edx
    65dd:	01 da                	add    %ebx,%edx
    65df:	50                   	push   %eax
    65e0:	51                   	push   %ecx
    65e1:	52                   	push   %edx
    65e2:	e8 94 d4 ff ff       	call   3a7b <lodepng_memcpy>
    65e7:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    65ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
    65ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
    65f0:	01 d0                	add    %edx,%eax
    65f2:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    65f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    65f8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    65ff:	8b 45 0c             	mov    0xc(%ebp),%eax
    6602:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    6605:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6608:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    660b:	c9                   	leave  
    660c:	c3                   	ret    

0000660d <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    660d:	55                   	push   %ebp
    660e:	89 e5                	mov    %esp,%ebp
    6610:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    6613:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    661a:	ff 75 10             	pushl  0x10(%ebp)
    661d:	ff 75 0c             	pushl  0xc(%ebp)
    6620:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6623:	50                   	push   %eax
    6624:	e8 77 db ff ff       	call   41a0 <LodePNGBitReader_init>
    6629:	83 c4 0c             	add    $0xc,%esp
    662c:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    662f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6633:	0f 84 b9 00 00 00    	je     66f2 <lodepng_inflatev+0xe5>
    6639:	8b 45 f0             	mov    -0x10(%ebp),%eax
    663c:	e9 c1 00 00 00       	jmp    6702 <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    6641:	6a 03                	push   $0x3
    6643:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6646:	50                   	push   %eax
    6647:	e8 c5 db ff ff       	call   4211 <ensureBits9>
    664c:	83 c4 08             	add    $0x8,%esp
    664f:	85 c0                	test   %eax,%eax
    6651:	75 0a                	jne    665d <lodepng_inflatev+0x50>
    6653:	b8 34 00 00 00       	mov    $0x34,%eax
    6658:	e9 a5 00 00 00       	jmp    6702 <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    665d:	6a 01                	push   $0x1
    665f:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6662:	50                   	push   %eax
    6663:	e8 61 e1 ff ff       	call   47c9 <readBits>
    6668:	83 c4 08             	add    $0x8,%esp
    666b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    666e:	6a 02                	push   $0x2
    6670:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6673:	50                   	push   %eax
    6674:	e8 50 e1 ff ff       	call   47c9 <readBits>
    6679:	83 c4 08             	add    $0x8,%esp
    667c:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    667f:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    6683:	75 07                	jne    668c <lodepng_inflatev+0x7f>
    6685:	b8 14 00 00 00       	mov    $0x14,%eax
    668a:	eb 76                	jmp    6702 <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    668c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    6690:	75 17                	jne    66a9 <lodepng_inflatev+0x9c>
    6692:	ff 75 14             	pushl  0x14(%ebp)
    6695:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6698:	50                   	push   %eax
    6699:	ff 75 08             	pushl  0x8(%ebp)
    669c:	e8 2b fe ff ff       	call   64cc <inflateNoCompression>
    66a1:	83 c4 0c             	add    $0xc,%esp
    66a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    66a7:	eb 1c                	jmp    66c5 <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    66a9:	8b 45 14             	mov    0x14(%ebp),%eax
    66ac:	8b 40 08             	mov    0x8(%eax),%eax
    66af:	50                   	push   %eax
    66b0:	ff 75 ec             	pushl  -0x14(%ebp)
    66b3:	8d 45 d8             	lea    -0x28(%ebp),%eax
    66b6:	50                   	push   %eax
    66b7:	ff 75 08             	pushl  0x8(%ebp)
    66ba:	e8 f9 fa ff ff       	call   61b8 <inflateHuffmanBlock>
    66bf:	83 c4 10             	add    $0x10,%esp
    66c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    66c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    66c9:	75 21                	jne    66ec <lodepng_inflatev+0xdf>
    66cb:	8b 45 14             	mov    0x14(%ebp),%eax
    66ce:	8b 40 08             	mov    0x8(%eax),%eax
    66d1:	85 c0                	test   %eax,%eax
    66d3:	74 17                	je     66ec <lodepng_inflatev+0xdf>
    66d5:	8b 45 08             	mov    0x8(%ebp),%eax
    66d8:	8b 50 04             	mov    0x4(%eax),%edx
    66db:	8b 45 14             	mov    0x14(%ebp),%eax
    66de:	8b 40 08             	mov    0x8(%eax),%eax
    66e1:	39 c2                	cmp    %eax,%edx
    66e3:	7e 07                	jle    66ec <lodepng_inflatev+0xdf>
    66e5:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    66ec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    66f0:	75 0c                	jne    66fe <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    66f2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    66f6:	0f 84 45 ff ff ff    	je     6641 <lodepng_inflatev+0x34>
    66fc:	eb 01                	jmp    66ff <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    66fe:	90                   	nop
  }

  return error;
    66ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    6702:	c9                   	leave  
    6703:	c3                   	ret    

00006704 <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    6704:	55                   	push   %ebp
    6705:	89 e5                	mov    %esp,%ebp
    6707:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    670a:	8b 45 0c             	mov    0xc(%ebp),%eax
    670d:	8b 08                	mov    (%eax),%ecx
    670f:	8b 45 08             	mov    0x8(%ebp),%eax
    6712:	8b 10                	mov    (%eax),%edx
    6714:	8d 45 e8             	lea    -0x18(%ebp),%eax
    6717:	51                   	push   %ecx
    6718:	52                   	push   %edx
    6719:	50                   	push   %eax
    671a:	e8 df d5 ff ff       	call   3cfe <ucvector_init>
    671f:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    6722:	ff 75 18             	pushl  0x18(%ebp)
    6725:	ff 75 14             	pushl  0x14(%ebp)
    6728:	ff 75 10             	pushl  0x10(%ebp)
    672b:	8d 45 e8             	lea    -0x18(%ebp),%eax
    672e:	50                   	push   %eax
    672f:	e8 d9 fe ff ff       	call   660d <lodepng_inflatev>
    6734:	83 c4 10             	add    $0x10,%esp
    6737:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    673a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    673d:	8b 45 08             	mov    0x8(%ebp),%eax
    6740:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    6742:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6745:	8b 45 0c             	mov    0xc(%ebp),%eax
    6748:	89 10                	mov    %edx,(%eax)
  return error;
    674a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    674d:	c9                   	leave  
    674e:	c3                   	ret    

0000674f <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    674f:	55                   	push   %ebp
    6750:	89 e5                	mov    %esp,%ebp
    6752:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    6755:	8b 45 14             	mov    0x14(%ebp),%eax
    6758:	8b 40 10             	mov    0x10(%eax),%eax
    675b:	85 c0                	test   %eax,%eax
    675d:	74 64                	je     67c3 <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    675f:	8b 45 14             	mov    0x14(%ebp),%eax
    6762:	8b 40 10             	mov    0x10(%eax),%eax
    6765:	8b 55 08             	mov    0x8(%ebp),%edx
    6768:	8d 4a 04             	lea    0x4(%edx),%ecx
    676b:	8b 55 08             	mov    0x8(%ebp),%edx
    676e:	83 ec 0c             	sub    $0xc,%esp
    6771:	ff 75 14             	pushl  0x14(%ebp)
    6774:	ff 75 10             	pushl  0x10(%ebp)
    6777:	ff 75 0c             	pushl  0xc(%ebp)
    677a:	51                   	push   %ecx
    677b:	52                   	push   %edx
    677c:	ff d0                	call   *%eax
    677e:	83 c4 20             	add    $0x20,%esp
    6781:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    6784:	8b 45 08             	mov    0x8(%ebp),%eax
    6787:	8b 50 04             	mov    0x4(%eax),%edx
    678a:	8b 45 08             	mov    0x8(%ebp),%eax
    678d:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    6790:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6794:	74 28                	je     67be <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    6796:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    679d:	8b 45 14             	mov    0x14(%ebp),%eax
    67a0:	8b 40 08             	mov    0x8(%eax),%eax
    67a3:	85 c0                	test   %eax,%eax
    67a5:	74 17                	je     67be <inflatev+0x6f>
    67a7:	8b 45 08             	mov    0x8(%ebp),%eax
    67aa:	8b 50 04             	mov    0x4(%eax),%edx
    67ad:	8b 45 14             	mov    0x14(%ebp),%eax
    67b0:	8b 40 08             	mov    0x8(%eax),%eax
    67b3:	39 c2                	cmp    %eax,%edx
    67b5:	7e 07                	jle    67be <inflatev+0x6f>
    67b7:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    67be:	8b 45 f4             	mov    -0xc(%ebp),%eax
    67c1:	eb 14                	jmp    67d7 <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    67c3:	ff 75 14             	pushl  0x14(%ebp)
    67c6:	ff 75 10             	pushl  0x10(%ebp)
    67c9:	ff 75 0c             	pushl  0xc(%ebp)
    67cc:	ff 75 08             	pushl  0x8(%ebp)
    67cf:	e8 39 fe ff ff       	call   660d <lodepng_inflatev>
    67d4:	83 c4 10             	add    $0x10,%esp
  }
}
    67d7:	c9                   	leave  
    67d8:	c3                   	ret    

000067d9 <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    67d9:	55                   	push   %ebp
    67da:	89 e5                	mov    %esp,%ebp
    67dc:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    67df:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    67e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    67e9:	83 e8 01             	sub    $0x1,%eax
    67ec:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    67ef:	eb 39                	jmp    682a <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    67f1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    67f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    67f7:	01 d0                	add    %edx,%eax
    67f9:	d1 f8                	sar    %eax
    67fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    67fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6801:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6808:	8b 45 08             	mov    0x8(%ebp),%eax
    680b:	01 d0                	add    %edx,%eax
    680d:	8b 10                	mov    (%eax),%edx
    680f:	8b 45 10             	mov    0x10(%ebp),%eax
    6812:	39 c2                	cmp    %eax,%edx
    6814:	72 0b                	jb     6821 <searchCodeIndex+0x48>
    6816:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6819:	83 e8 01             	sub    $0x1,%eax
    681c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    681f:	eb 09                	jmp    682a <searchCodeIndex+0x51>
    else left = mid + 1;
    6821:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6824:	83 c0 01             	add    $0x1,%eax
    6827:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    682a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    682d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6830:	7e bf                	jle    67f1 <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    6832:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6835:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6838:	7d 18                	jge    6852 <searchCodeIndex+0x79>
    683a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    683d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6844:	8b 45 08             	mov    0x8(%ebp),%eax
    6847:	01 d0                	add    %edx,%eax
    6849:	8b 10                	mov    (%eax),%edx
    684b:	8b 45 10             	mov    0x10(%ebp),%eax
    684e:	39 c2                	cmp    %eax,%edx
    6850:	76 04                	jbe    6856 <searchCodeIndex+0x7d>
    6852:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    6856:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    6859:	c9                   	leave  
    685a:	c3                   	ret    

0000685b <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    685b:	55                   	push   %ebp
    685c:	89 e5                	mov    %esp,%ebp
    685e:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    6861:	ff 75 0c             	pushl  0xc(%ebp)
    6864:	6a 1d                	push   $0x1d
    6866:	68 80 a4 01 00       	push   $0x1a480
    686b:	e8 69 ff ff ff       	call   67d9 <searchCodeIndex>
    6870:	83 c4 0c             	add    $0xc,%esp
    6873:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    6876:	8b 55 0c             	mov    0xc(%ebp),%edx
    6879:	8b 45 fc             	mov    -0x4(%ebp),%eax
    687c:	8b 04 85 80 a4 01 00 	mov    0x1a480(,%eax,4),%eax
    6883:	29 c2                	sub    %eax,%edx
    6885:	89 d0                	mov    %edx,%eax
    6887:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    688a:	ff 75 10             	pushl  0x10(%ebp)
    688d:	6a 1e                	push   $0x1e
    688f:	68 80 a5 01 00       	push   $0x1a580
    6894:	e8 40 ff ff ff       	call   67d9 <searchCodeIndex>
    6899:	83 c4 0c             	add    $0xc,%esp
    689c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    689f:	8b 55 10             	mov    0x10(%ebp),%edx
    68a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    68a5:	8b 04 85 80 a5 01 00 	mov    0x1a580(,%eax,4),%eax
    68ac:	29 c2                	sub    %eax,%edx
    68ae:	89 d0                	mov    %edx,%eax
    68b0:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    68b3:	8b 45 08             	mov    0x8(%ebp),%eax
    68b6:	8b 40 04             	mov    0x4(%eax),%eax
    68b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    68bc:	8b 45 08             	mov    0x8(%ebp),%eax
    68bf:	8b 40 04             	mov    0x4(%eax),%eax
    68c2:	83 c0 04             	add    $0x4,%eax
    68c5:	50                   	push   %eax
    68c6:	ff 75 08             	pushl  0x8(%ebp)
    68c9:	e8 f0 d2 ff ff       	call   3bbe <uivector_resize>
    68ce:	83 c4 08             	add    $0x8,%esp
    68d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    68d4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    68d8:	74 57                	je     6931 <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    68da:	8b 45 08             	mov    0x8(%ebp),%eax
    68dd:	8b 00                	mov    (%eax),%eax
    68df:	8b 55 ec             	mov    -0x14(%ebp),%edx
    68e2:	c1 e2 02             	shl    $0x2,%edx
    68e5:	01 d0                	add    %edx,%eax
    68e7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    68ea:	81 c2 01 01 00 00    	add    $0x101,%edx
    68f0:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    68f2:	8b 45 08             	mov    0x8(%ebp),%eax
    68f5:	8b 00                	mov    (%eax),%eax
    68f7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    68fa:	83 c2 01             	add    $0x1,%edx
    68fd:	c1 e2 02             	shl    $0x2,%edx
    6900:	01 c2                	add    %eax,%edx
    6902:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6905:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    6907:	8b 45 08             	mov    0x8(%ebp),%eax
    690a:	8b 00                	mov    (%eax),%eax
    690c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    690f:	83 c2 02             	add    $0x2,%edx
    6912:	c1 e2 02             	shl    $0x2,%edx
    6915:	01 c2                	add    %eax,%edx
    6917:	8b 45 f4             	mov    -0xc(%ebp),%eax
    691a:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    691c:	8b 45 08             	mov    0x8(%ebp),%eax
    691f:	8b 00                	mov    (%eax),%eax
    6921:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6924:	83 c2 03             	add    $0x3,%edx
    6927:	c1 e2 02             	shl    $0x2,%edx
    692a:	01 c2                	add    %eax,%edx
    692c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    692f:	89 02                	mov    %eax,(%edx)
  }
}
    6931:	90                   	nop
    6932:	c9                   	leave  
    6933:	c3                   	ret    

00006934 <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    6934:	55                   	push   %ebp
    6935:	89 e5                	mov    %esp,%ebp
    6937:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    693a:	b8 00 00 01 00       	mov    $0x10000,%eax
    693f:	c1 e0 02             	shl    $0x2,%eax
    6942:	83 ec 0c             	sub    $0xc,%esp
    6945:	50                   	push   %eax
    6946:	e8 f2 d0 ff ff       	call   3a3d <lodepng_malloc>
    694b:	83 c4 10             	add    $0x10,%esp
    694e:	89 c2                	mov    %eax,%edx
    6950:	8b 45 08             	mov    0x8(%ebp),%eax
    6953:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    6955:	8b 45 0c             	mov    0xc(%ebp),%eax
    6958:	c1 e0 02             	shl    $0x2,%eax
    695b:	83 ec 0c             	sub    $0xc,%esp
    695e:	50                   	push   %eax
    695f:	e8 d9 d0 ff ff       	call   3a3d <lodepng_malloc>
    6964:	83 c4 10             	add    $0x10,%esp
    6967:	89 c2                	mov    %eax,%edx
    6969:	8b 45 08             	mov    0x8(%ebp),%eax
    696c:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    696f:	8b 45 0c             	mov    0xc(%ebp),%eax
    6972:	01 c0                	add    %eax,%eax
    6974:	83 ec 0c             	sub    $0xc,%esp
    6977:	50                   	push   %eax
    6978:	e8 c0 d0 ff ff       	call   3a3d <lodepng_malloc>
    697d:	83 c4 10             	add    $0x10,%esp
    6980:	89 c2                	mov    %eax,%edx
    6982:	8b 45 08             	mov    0x8(%ebp),%eax
    6985:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6988:	8b 45 0c             	mov    0xc(%ebp),%eax
    698b:	01 c0                	add    %eax,%eax
    698d:	83 ec 0c             	sub    $0xc,%esp
    6990:	50                   	push   %eax
    6991:	e8 a7 d0 ff ff       	call   3a3d <lodepng_malloc>
    6996:	83 c4 10             	add    $0x10,%esp
    6999:	89 c2                	mov    %eax,%edx
    699b:	8b 45 08             	mov    0x8(%ebp),%eax
    699e:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    69a1:	b8 02 01 00 00       	mov    $0x102,%eax
    69a6:	83 c0 01             	add    $0x1,%eax
    69a9:	c1 e0 02             	shl    $0x2,%eax
    69ac:	83 ec 0c             	sub    $0xc,%esp
    69af:	50                   	push   %eax
    69b0:	e8 88 d0 ff ff       	call   3a3d <lodepng_malloc>
    69b5:	83 c4 10             	add    $0x10,%esp
    69b8:	89 c2                	mov    %eax,%edx
    69ba:	8b 45 08             	mov    0x8(%ebp),%eax
    69bd:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    69c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    69c3:	01 c0                	add    %eax,%eax
    69c5:	83 ec 0c             	sub    $0xc,%esp
    69c8:	50                   	push   %eax
    69c9:	e8 6f d0 ff ff       	call   3a3d <lodepng_malloc>
    69ce:	83 c4 10             	add    $0x10,%esp
    69d1:	89 c2                	mov    %eax,%edx
    69d3:	8b 45 08             	mov    0x8(%ebp),%eax
    69d6:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    69d9:	8b 45 08             	mov    0x8(%ebp),%eax
    69dc:	8b 00                	mov    (%eax),%eax
    69de:	85 c0                	test   %eax,%eax
    69e0:	74 32                	je     6a14 <hash_init+0xe0>
    69e2:	8b 45 08             	mov    0x8(%ebp),%eax
    69e5:	8b 40 04             	mov    0x4(%eax),%eax
    69e8:	85 c0                	test   %eax,%eax
    69ea:	74 28                	je     6a14 <hash_init+0xe0>
    69ec:	8b 45 08             	mov    0x8(%ebp),%eax
    69ef:	8b 40 08             	mov    0x8(%eax),%eax
    69f2:	85 c0                	test   %eax,%eax
    69f4:	74 1e                	je     6a14 <hash_init+0xe0>
    69f6:	8b 45 08             	mov    0x8(%ebp),%eax
    69f9:	8b 40 0c             	mov    0xc(%eax),%eax
    69fc:	85 c0                	test   %eax,%eax
    69fe:	74 14                	je     6a14 <hash_init+0xe0>
    6a00:	8b 45 08             	mov    0x8(%ebp),%eax
    6a03:	8b 40 10             	mov    0x10(%eax),%eax
    6a06:	85 c0                	test   %eax,%eax
    6a08:	74 0a                	je     6a14 <hash_init+0xe0>
    6a0a:	8b 45 08             	mov    0x8(%ebp),%eax
    6a0d:	8b 40 14             	mov    0x14(%eax),%eax
    6a10:	85 c0                	test   %eax,%eax
    6a12:	75 0a                	jne    6a1e <hash_init+0xea>
    return 83; /*alloc fail*/
    6a14:	b8 53 00 00 00       	mov    $0x53,%eax
    6a19:	e9 d3 00 00 00       	jmp    6af1 <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    6a1e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6a25:	eb 17                	jmp    6a3e <hash_init+0x10a>
    6a27:	8b 45 08             	mov    0x8(%ebp),%eax
    6a2a:	8b 00                	mov    (%eax),%eax
    6a2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6a2f:	c1 e2 02             	shl    $0x2,%edx
    6a32:	01 d0                	add    %edx,%eax
    6a34:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6a3a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6a3e:	b8 00 00 01 00       	mov    $0x10000,%eax
    6a43:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    6a46:	75 df                	jne    6a27 <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    6a48:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6a4f:	eb 18                	jmp    6a69 <hash_init+0x135>
    6a51:	8b 45 08             	mov    0x8(%ebp),%eax
    6a54:	8b 40 08             	mov    0x8(%eax),%eax
    6a57:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6a5a:	c1 e2 02             	shl    $0x2,%edx
    6a5d:	01 d0                	add    %edx,%eax
    6a5f:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6a65:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6a69:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6a6c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6a6f:	75 e0                	jne    6a51 <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    6a71:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6a78:	eb 17                	jmp    6a91 <hash_init+0x15d>
    6a7a:	8b 45 08             	mov    0x8(%ebp),%eax
    6a7d:	8b 40 04             	mov    0x4(%eax),%eax
    6a80:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6a83:	01 d2                	add    %edx,%edx
    6a85:	01 d0                	add    %edx,%eax
    6a87:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6a8a:	66 89 10             	mov    %dx,(%eax)
    6a8d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6a91:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6a94:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6a97:	75 e1                	jne    6a7a <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    6a99:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6aa0:	eb 18                	jmp    6aba <hash_init+0x186>
    6aa2:	8b 45 08             	mov    0x8(%ebp),%eax
    6aa5:	8b 40 0c             	mov    0xc(%eax),%eax
    6aa8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6aab:	c1 e2 02             	shl    $0x2,%edx
    6aae:	01 d0                	add    %edx,%eax
    6ab0:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6ab6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6aba:	b8 02 01 00 00       	mov    $0x102,%eax
    6abf:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    6ac2:	76 de                	jbe    6aa2 <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    6ac4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6acb:	eb 17                	jmp    6ae4 <hash_init+0x1b0>
    6acd:	8b 45 08             	mov    0x8(%ebp),%eax
    6ad0:	8b 40 10             	mov    0x10(%eax),%eax
    6ad3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6ad6:	01 d2                	add    %edx,%edx
    6ad8:	01 d0                	add    %edx,%eax
    6ada:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6add:	66 89 10             	mov    %dx,(%eax)
    6ae0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6ae4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6ae7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6aea:	75 e1                	jne    6acd <hash_init+0x199>

  return 0;
    6aec:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6af1:	c9                   	leave  
    6af2:	c3                   	ret    

00006af3 <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    6af3:	55                   	push   %ebp
    6af4:	89 e5                	mov    %esp,%ebp
    6af6:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    6af9:	8b 45 08             	mov    0x8(%ebp),%eax
    6afc:	8b 00                	mov    (%eax),%eax
    6afe:	83 ec 0c             	sub    $0xc,%esp
    6b01:	50                   	push   %eax
    6b02:	e8 57 cf ff ff       	call   3a5e <lodepng_free>
    6b07:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    6b0a:	8b 45 08             	mov    0x8(%ebp),%eax
    6b0d:	8b 40 08             	mov    0x8(%eax),%eax
    6b10:	83 ec 0c             	sub    $0xc,%esp
    6b13:	50                   	push   %eax
    6b14:	e8 45 cf ff ff       	call   3a5e <lodepng_free>
    6b19:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    6b1c:	8b 45 08             	mov    0x8(%ebp),%eax
    6b1f:	8b 40 04             	mov    0x4(%eax),%eax
    6b22:	83 ec 0c             	sub    $0xc,%esp
    6b25:	50                   	push   %eax
    6b26:	e8 33 cf ff ff       	call   3a5e <lodepng_free>
    6b2b:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    6b2e:	8b 45 08             	mov    0x8(%ebp),%eax
    6b31:	8b 40 14             	mov    0x14(%eax),%eax
    6b34:	83 ec 0c             	sub    $0xc,%esp
    6b37:	50                   	push   %eax
    6b38:	e8 21 cf ff ff       	call   3a5e <lodepng_free>
    6b3d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    6b40:	8b 45 08             	mov    0x8(%ebp),%eax
    6b43:	8b 40 0c             	mov    0xc(%eax),%eax
    6b46:	83 ec 0c             	sub    $0xc,%esp
    6b49:	50                   	push   %eax
    6b4a:	e8 0f cf ff ff       	call   3a5e <lodepng_free>
    6b4f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    6b52:	8b 45 08             	mov    0x8(%ebp),%eax
    6b55:	8b 40 10             	mov    0x10(%eax),%eax
    6b58:	83 ec 0c             	sub    $0xc,%esp
    6b5b:	50                   	push   %eax
    6b5c:	e8 fd ce ff ff       	call   3a5e <lodepng_free>
    6b61:	83 c4 10             	add    $0x10,%esp
}
    6b64:	90                   	nop
    6b65:	c9                   	leave  
    6b66:	c3                   	ret    

00006b67 <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    6b67:	55                   	push   %ebp
    6b68:	89 e5                	mov    %esp,%ebp
    6b6a:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    6b6d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    6b74:	8b 45 10             	mov    0x10(%ebp),%eax
    6b77:	83 c0 02             	add    $0x2,%eax
    6b7a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6b7d:	7d 41                	jge    6bc0 <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    6b7f:	8b 55 10             	mov    0x10(%ebp),%edx
    6b82:	8b 45 08             	mov    0x8(%ebp),%eax
    6b85:	01 d0                	add    %edx,%eax
    6b87:	0f b6 00             	movzbl (%eax),%eax
    6b8a:	0f b6 c0             	movzbl %al,%eax
    6b8d:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    6b90:	8b 45 10             	mov    0x10(%ebp),%eax
    6b93:	8d 50 01             	lea    0x1(%eax),%edx
    6b96:	8b 45 08             	mov    0x8(%ebp),%eax
    6b99:	01 d0                	add    %edx,%eax
    6b9b:	0f b6 00             	movzbl (%eax),%eax
    6b9e:	0f b6 c0             	movzbl %al,%eax
    6ba1:	c1 e0 04             	shl    $0x4,%eax
    6ba4:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    6ba7:	8b 45 10             	mov    0x10(%ebp),%eax
    6baa:	8d 50 02             	lea    0x2(%eax),%edx
    6bad:	8b 45 08             	mov    0x8(%ebp),%eax
    6bb0:	01 d0                	add    %edx,%eax
    6bb2:	0f b6 00             	movzbl (%eax),%eax
    6bb5:	0f b6 c0             	movzbl %al,%eax
    6bb8:	c1 e0 08             	shl    $0x8,%eax
    6bbb:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6bbe:	eb 51                	jmp    6c11 <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    6bc0:	8b 45 10             	mov    0x10(%ebp),%eax
    6bc3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6bc6:	7c 07                	jl     6bcf <getHash+0x68>
    6bc8:	b8 00 00 00 00       	mov    $0x0,%eax
    6bcd:	eb 4a                	jmp    6c19 <getHash+0xb2>
    amount = size - pos;
    6bcf:	8b 45 0c             	mov    0xc(%ebp),%eax
    6bd2:	2b 45 10             	sub    0x10(%ebp),%eax
    6bd5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    6bd8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6bdf:	eb 28                	jmp    6c09 <getHash+0xa2>
    6be1:	8b 55 10             	mov    0x10(%ebp),%edx
    6be4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6be7:	01 d0                	add    %edx,%eax
    6be9:	89 c2                	mov    %eax,%edx
    6beb:	8b 45 08             	mov    0x8(%ebp),%eax
    6bee:	01 d0                	add    %edx,%eax
    6bf0:	0f b6 00             	movzbl (%eax),%eax
    6bf3:	0f b6 d0             	movzbl %al,%edx
    6bf6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6bf9:	c1 e0 03             	shl    $0x3,%eax
    6bfc:	89 c1                	mov    %eax,%ecx
    6bfe:	d3 e2                	shl    %cl,%edx
    6c00:	89 d0                	mov    %edx,%eax
    6c02:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6c05:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6c09:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6c0c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    6c0f:	75 d0                	jne    6be1 <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    6c11:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6c16:	23 45 fc             	and    -0x4(%ebp),%eax
}
    6c19:	c9                   	leave  
    6c1a:	c3                   	ret    

00006c1b <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    6c1b:	55                   	push   %ebp
    6c1c:	89 e5                	mov    %esp,%ebp
    6c1e:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    6c21:	8b 55 10             	mov    0x10(%ebp),%edx
    6c24:	8b 45 08             	mov    0x8(%ebp),%eax
    6c27:	01 d0                	add    %edx,%eax
    6c29:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    6c2c:	b8 02 01 00 00       	mov    $0x102,%eax
    6c31:	89 c2                	mov    %eax,%edx
    6c33:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6c36:	01 d0                	add    %edx,%eax
    6c38:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    6c3b:	8b 55 0c             	mov    0xc(%ebp),%edx
    6c3e:	8b 45 08             	mov    0x8(%ebp),%eax
    6c41:	01 d0                	add    %edx,%eax
    6c43:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6c46:	73 0b                	jae    6c53 <countZeros+0x38>
    6c48:	8b 55 0c             	mov    0xc(%ebp),%edx
    6c4b:	8b 45 08             	mov    0x8(%ebp),%eax
    6c4e:	01 d0                	add    %edx,%eax
    6c50:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    6c53:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6c56:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    6c59:	eb 04                	jmp    6c5f <countZeros+0x44>
    6c5b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    6c5f:	8b 45 08             	mov    0x8(%ebp),%eax
    6c62:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6c65:	74 0a                	je     6c71 <countZeros+0x56>
    6c67:	8b 45 08             	mov    0x8(%ebp),%eax
    6c6a:	0f b6 00             	movzbl (%eax),%eax
    6c6d:	84 c0                	test   %al,%al
    6c6f:	74 ea                	je     6c5b <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    6c71:	8b 55 08             	mov    0x8(%ebp),%edx
    6c74:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6c77:	29 c2                	sub    %eax,%edx
    6c79:	89 d0                	mov    %edx,%eax
}
    6c7b:	c9                   	leave  
    6c7c:	c3                   	ret    

00006c7d <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    6c7d:	55                   	push   %ebp
    6c7e:	89 e5                	mov    %esp,%ebp
    6c80:	83 ec 04             	sub    $0x4,%esp
    6c83:	8b 45 14             	mov    0x14(%ebp),%eax
    6c86:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    6c8a:	8b 45 08             	mov    0x8(%ebp),%eax
    6c8d:	8b 40 08             	mov    0x8(%eax),%eax
    6c90:	8b 55 0c             	mov    0xc(%ebp),%edx
    6c93:	c1 e2 02             	shl    $0x2,%edx
    6c96:	01 c2                	add    %eax,%edx
    6c98:	8b 45 10             	mov    0x10(%ebp),%eax
    6c9b:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    6c9d:	8b 45 08             	mov    0x8(%ebp),%eax
    6ca0:	8b 00                	mov    (%eax),%eax
    6ca2:	8b 55 10             	mov    0x10(%ebp),%edx
    6ca5:	c1 e2 02             	shl    $0x2,%edx
    6ca8:	01 d0                	add    %edx,%eax
    6caa:	8b 00                	mov    (%eax),%eax
    6cac:	83 f8 ff             	cmp    $0xffffffff,%eax
    6caf:	74 1f                	je     6cd0 <updateHashChain+0x53>
    6cb1:	8b 45 08             	mov    0x8(%ebp),%eax
    6cb4:	8b 40 04             	mov    0x4(%eax),%eax
    6cb7:	8b 55 0c             	mov    0xc(%ebp),%edx
    6cba:	01 d2                	add    %edx,%edx
    6cbc:	01 c2                	add    %eax,%edx
    6cbe:	8b 45 08             	mov    0x8(%ebp),%eax
    6cc1:	8b 00                	mov    (%eax),%eax
    6cc3:	8b 4d 10             	mov    0x10(%ebp),%ecx
    6cc6:	c1 e1 02             	shl    $0x2,%ecx
    6cc9:	01 c8                	add    %ecx,%eax
    6ccb:	8b 00                	mov    (%eax),%eax
    6ccd:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    6cd0:	8b 45 08             	mov    0x8(%ebp),%eax
    6cd3:	8b 00                	mov    (%eax),%eax
    6cd5:	8b 55 10             	mov    0x10(%ebp),%edx
    6cd8:	c1 e2 02             	shl    $0x2,%edx
    6cdb:	01 c2                	add    %eax,%edx
    6cdd:	8b 45 0c             	mov    0xc(%ebp),%eax
    6ce0:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    6ce2:	8b 45 08             	mov    0x8(%ebp),%eax
    6ce5:	8b 40 14             	mov    0x14(%eax),%eax
    6ce8:	8b 55 0c             	mov    0xc(%ebp),%edx
    6ceb:	01 d2                	add    %edx,%edx
    6ced:	01 c2                	add    %eax,%edx
    6cef:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    6cf3:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    6cf6:	8b 45 08             	mov    0x8(%ebp),%eax
    6cf9:	8b 40 0c             	mov    0xc(%eax),%eax
    6cfc:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    6d00:	c1 e2 02             	shl    $0x2,%edx
    6d03:	01 d0                	add    %edx,%eax
    6d05:	8b 00                	mov    (%eax),%eax
    6d07:	83 f8 ff             	cmp    $0xffffffff,%eax
    6d0a:	74 21                	je     6d2d <updateHashChain+0xb0>
    6d0c:	8b 45 08             	mov    0x8(%ebp),%eax
    6d0f:	8b 40 10             	mov    0x10(%eax),%eax
    6d12:	8b 55 0c             	mov    0xc(%ebp),%edx
    6d15:	01 d2                	add    %edx,%edx
    6d17:	01 c2                	add    %eax,%edx
    6d19:	8b 45 08             	mov    0x8(%ebp),%eax
    6d1c:	8b 40 0c             	mov    0xc(%eax),%eax
    6d1f:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    6d23:	c1 e1 02             	shl    $0x2,%ecx
    6d26:	01 c8                	add    %ecx,%eax
    6d28:	8b 00                	mov    (%eax),%eax
    6d2a:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    6d2d:	8b 45 08             	mov    0x8(%ebp),%eax
    6d30:	8b 40 0c             	mov    0xc(%eax),%eax
    6d33:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    6d37:	c1 e2 02             	shl    $0x2,%edx
    6d3a:	01 c2                	add    %eax,%edx
    6d3c:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d3f:	89 02                	mov    %eax,(%edx)
}
    6d41:	90                   	nop
    6d42:	c9                   	leave  
    6d43:	c3                   	ret    

00006d44 <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    6d44:	55                   	push   %ebp
    6d45:	89 e5                	mov    %esp,%ebp
    6d47:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    6d4a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    6d51:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6d58:	77 08                	ja     6d62 <encodeLZ77+0x1e>
    6d5a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6d5d:	c1 e8 03             	shr    $0x3,%eax
    6d60:	eb 03                	jmp    6d65 <encodeLZ77+0x21>
    6d62:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6d65:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    6d68:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6d6f:	76 07                	jbe    6d78 <encodeLZ77+0x34>
    6d71:	b8 02 01 00 00       	mov    $0x102,%eax
    6d76:	eb 05                	jmp    6d7d <encodeLZ77+0x39>
    6d78:	b8 40 00 00 00       	mov    $0x40,%eax
    6d7d:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    6d80:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    6d87:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    6d8e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    6d95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    6d9c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    6da3:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    6da7:	74 09                	je     6db2 <encodeLZ77+0x6e>
    6da9:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    6db0:	76 0a                	jbe    6dbc <encodeLZ77+0x78>
    6db2:	b8 3c 00 00 00       	mov    $0x3c,%eax
    6db7:	e9 e3 04 00 00       	jmp    729f <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    6dbc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6dbf:	83 e8 01             	sub    $0x1,%eax
    6dc2:	23 45 1c             	and    0x1c(%ebp),%eax
    6dc5:	85 c0                	test   %eax,%eax
    6dc7:	74 0a                	je     6dd3 <encodeLZ77+0x8f>
    6dc9:	b8 5a 00 00 00       	mov    $0x5a,%eax
    6dce:	e9 cc 04 00 00       	jmp    729f <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    6dd3:	b8 02 01 00 00       	mov    $0x102,%eax
    6dd8:	39 45 24             	cmp    %eax,0x24(%ebp)
    6ddb:	76 08                	jbe    6de5 <encodeLZ77+0xa1>
    6ddd:	b8 02 01 00 00       	mov    $0x102,%eax
    6de2:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    6de5:	8b 45 14             	mov    0x14(%ebp),%eax
    6de8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    6deb:	e9 a0 04 00 00       	jmp    7290 <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    6df0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6df3:	8d 50 ff             	lea    -0x1(%eax),%edx
    6df6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6df9:	21 d0                	and    %edx,%eax
    6dfb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    6dfe:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    6e05:	ff 75 fc             	pushl  -0x4(%ebp)
    6e08:	ff 75 18             	pushl  0x18(%ebp)
    6e0b:	ff 75 10             	pushl  0x10(%ebp)
    6e0e:	e8 54 fd ff ff       	call   6b67 <getHash>
    6e13:	83 c4 0c             	add    $0xc,%esp
    6e16:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    6e19:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6e1d:	74 4e                	je     6e6d <encodeLZ77+0x129>
    6e1f:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6e23:	75 48                	jne    6e6d <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6e25:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6e29:	75 16                	jne    6e41 <encodeLZ77+0xfd>
    6e2b:	ff 75 fc             	pushl  -0x4(%ebp)
    6e2e:	ff 75 18             	pushl  0x18(%ebp)
    6e31:	ff 75 10             	pushl  0x10(%ebp)
    6e34:	e8 e2 fd ff ff       	call   6c1b <countZeros>
    6e39:	83 c4 0c             	add    $0xc,%esp
    6e3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6e3f:	eb 35                	jmp    6e76 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6e41:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6e44:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6e47:	01 c2                	add    %eax,%edx
    6e49:	8b 45 18             	mov    0x18(%ebp),%eax
    6e4c:	39 c2                	cmp    %eax,%edx
    6e4e:	77 17                	ja     6e67 <encodeLZ77+0x123>
    6e50:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6e53:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6e56:	01 d0                	add    %edx,%eax
    6e58:	8d 50 ff             	lea    -0x1(%eax),%edx
    6e5b:	8b 45 10             	mov    0x10(%ebp),%eax
    6e5e:	01 d0                	add    %edx,%eax
    6e60:	0f b6 00             	movzbl (%eax),%eax
    6e63:	84 c0                	test   %al,%al
    6e65:	74 0f                	je     6e76 <encodeLZ77+0x132>
    6e67:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6e6b:	eb 09                	jmp    6e76 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    6e6d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6e74:	eb 01                	jmp    6e77 <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6e76:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    6e77:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6e7a:	0f b7 c0             	movzwl %ax,%eax
    6e7d:	50                   	push   %eax
    6e7e:	ff 75 b0             	pushl  -0x50(%ebp)
    6e81:	ff 75 b4             	pushl  -0x4c(%ebp)
    6e84:	ff 75 0c             	pushl  0xc(%ebp)
    6e87:	e8 f1 fd ff ff       	call   6c7d <updateHashChain>
    6e8c:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    6e8f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    6e96:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    6e9d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6ea0:	8b 40 04             	mov    0x4(%eax),%eax
    6ea3:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    6ea6:	01 d2                	add    %edx,%edx
    6ea8:	01 d0                	add    %edx,%eax
    6eaa:	0f b7 00             	movzwl (%eax),%eax
    6ead:	0f b7 c0             	movzwl %ax,%eax
    6eb0:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    6eb3:	ba 02 01 00 00       	mov    $0x102,%edx
    6eb8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6ebb:	01 c2                	add    %eax,%edx
    6ebd:	8b 45 18             	mov    0x18(%ebp),%eax
    6ec0:	39 c2                	cmp    %eax,%edx
    6ec2:	0f 4e c2             	cmovle %edx,%eax
    6ec5:	89 c2                	mov    %eax,%edx
    6ec7:	8b 45 10             	mov    0x10(%ebp),%eax
    6eca:	01 d0                	add    %edx,%eax
    6ecc:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    6ecf:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6ed6:	8b 45 c8             	mov    -0x38(%ebp),%eax
    6ed9:	8d 50 01             	lea    0x1(%eax),%edx
    6edc:	89 55 c8             	mov    %edx,-0x38(%ebp)
    6edf:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    6ee2:	0f 83 67 01 00 00    	jae    704f <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    6ee8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6eeb:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    6eee:	77 08                	ja     6ef8 <encodeLZ77+0x1b4>
    6ef0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6ef3:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6ef6:	eb 0d                	jmp    6f05 <encodeLZ77+0x1c1>
    6ef8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6efb:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6efe:	89 c2                	mov    %eax,%edx
    6f00:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f03:	01 d0                	add    %edx,%eax
    6f05:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6f08:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6f0b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6f0e:	0f 82 3e 01 00 00    	jb     7052 <encodeLZ77+0x30e>
      prev_offset = current_offset;
    6f14:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6f17:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    6f1a:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    6f1e:	0f 84 a3 00 00 00    	je     6fc7 <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    6f24:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6f27:	8b 45 10             	mov    0x10(%ebp),%eax
    6f2a:	01 d0                	add    %edx,%eax
    6f2c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    6f2f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6f32:	2b 45 a8             	sub    -0x58(%ebp),%eax
    6f35:	89 c2                	mov    %eax,%edx
    6f37:	8b 45 10             	mov    0x10(%ebp),%eax
    6f3a:	01 d0                	add    %edx,%eax
    6f3c:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    6f3f:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6f43:	76 3a                	jbe    6f7f <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    6f45:	8b 45 0c             	mov    0xc(%ebp),%eax
    6f48:	8b 40 14             	mov    0x14(%eax),%eax
    6f4b:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6f4e:	01 d2                	add    %edx,%edx
    6f50:	01 d0                	add    %edx,%eax
    6f52:	0f b7 00             	movzwl (%eax),%eax
    6f55:	0f b7 c0             	movzwl %ax,%eax
    6f58:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    6f5b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6f5e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6f61:	76 06                	jbe    6f69 <encodeLZ77+0x225>
    6f63:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6f66:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    6f69:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6f6c:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    6f6f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6f72:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6f75:	eb 08                	jmp    6f7f <encodeLZ77+0x23b>
          ++backptr;
    6f77:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    6f7b:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6f7f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6f82:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    6f85:	74 10                	je     6f97 <encodeLZ77+0x253>
    6f87:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6f8a:	0f b6 10             	movzbl (%eax),%edx
    6f8d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6f90:	0f b6 00             	movzbl (%eax),%eax
    6f93:	38 c2                	cmp    %al,%dl
    6f95:	74 e0                	je     6f77 <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    6f97:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6f9a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    6f9d:	8b 55 10             	mov    0x10(%ebp),%edx
    6fa0:	01 ca                	add    %ecx,%edx
    6fa2:	29 d0                	sub    %edx,%eax
    6fa4:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    6fa7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6faa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6fad:	76 18                	jbe    6fc7 <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    6faf:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6fb2:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    6fb5:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6fb8:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6fbb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6fbe:	3b 45 24             	cmp    0x24(%ebp),%eax
    6fc1:	0f 83 8e 00 00 00    	jae    7055 <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6fc7:	8b 45 0c             	mov    0xc(%ebp),%eax
    6fca:	8b 40 04             	mov    0x4(%eax),%eax
    6fcd:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6fd0:	01 d2                	add    %edx,%edx
    6fd2:	01 d0                	add    %edx,%eax
    6fd4:	0f b7 00             	movzwl (%eax),%eax
    6fd7:	0f b7 c0             	movzwl %ax,%eax
    6fda:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    6fdd:	74 79                	je     7058 <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    6fdf:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6fe3:	76 38                	jbe    701d <encodeLZ77+0x2d9>
    6fe5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6fe8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6feb:	76 30                	jbe    701d <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    6fed:	8b 45 0c             	mov    0xc(%ebp),%eax
    6ff0:	8b 40 10             	mov    0x10(%eax),%eax
    6ff3:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6ff6:	01 d2                	add    %edx,%edx
    6ff8:	01 d0                	add    %edx,%eax
    6ffa:	0f b7 00             	movzwl (%eax),%eax
    6ffd:	0f b7 c0             	movzwl %ax,%eax
    7000:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    7003:	8b 45 0c             	mov    0xc(%ebp),%eax
    7006:	8b 40 14             	mov    0x14(%eax),%eax
    7009:	8b 55 cc             	mov    -0x34(%ebp),%edx
    700c:	01 d2                	add    %edx,%edx
    700e:	01 d0                	add    %edx,%eax
    7010:	0f b7 00             	movzwl (%eax),%eax
    7013:	0f b7 c0             	movzwl %ax,%eax
    7016:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7019:	74 2f                	je     704a <encodeLZ77+0x306>
    701b:	eb 3f                	jmp    705c <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    701d:	8b 45 0c             	mov    0xc(%ebp),%eax
    7020:	8b 40 04             	mov    0x4(%eax),%eax
    7023:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7026:	01 d2                	add    %edx,%edx
    7028:	01 d0                	add    %edx,%eax
    702a:	0f b7 00             	movzwl (%eax),%eax
    702d:	0f b7 c0             	movzwl %ax,%eax
    7030:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    7033:	8b 45 0c             	mov    0xc(%ebp),%eax
    7036:	8b 40 08             	mov    0x8(%eax),%eax
    7039:	8b 55 cc             	mov    -0x34(%ebp),%edx
    703c:	c1 e2 02             	shl    $0x2,%edx
    703f:	01 d0                	add    %edx,%eax
    7041:	8b 10                	mov    (%eax),%edx
    7043:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7046:	39 c2                	cmp    %eax,%edx
    7048:	75 11                	jne    705b <encodeLZ77+0x317>
      }
    }
    704a:	e9 87 fe ff ff       	jmp    6ed6 <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    704f:	90                   	nop
    7050:	eb 0a                	jmp    705c <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    7052:	90                   	nop
    7053:	eb 07                	jmp    705c <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    7055:	90                   	nop
    7056:	eb 04                	jmp    705c <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    7058:	90                   	nop
    7059:	eb 01                	jmp    705c <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    705b:	90                   	nop
      }
    }

    if(lazymatching) {
    705c:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    7060:	0f 84 c8 00 00 00    	je     712e <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    7066:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    706a:	75 30                	jne    709c <encodeLZ77+0x358>
    706c:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    7070:	76 2a                	jbe    709c <encodeLZ77+0x358>
    7072:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7075:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    7078:	77 22                	ja     709c <encodeLZ77+0x358>
    707a:	b8 02 01 00 00       	mov    $0x102,%eax
    707f:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    7082:	73 18                	jae    709c <encodeLZ77+0x358>
        lazy = 1;
    7084:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    708b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    708e:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    7091:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7094:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    7097:	e9 f0 01 00 00       	jmp    728c <encodeLZ77+0x548>
      }
      if(lazy) {
    709c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    70a0:	0f 84 88 00 00 00    	je     712e <encodeLZ77+0x3ea>
        lazy = 0;
    70a6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    70ad:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    70b1:	75 0c                	jne    70bf <encodeLZ77+0x37b>
    70b3:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    70ba:	e9 dd 01 00 00       	jmp    729c <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    70bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
    70c2:	83 c0 01             	add    $0x1,%eax
    70c5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    70c8:	73 2d                	jae    70f7 <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    70ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
    70cd:	8d 50 ff             	lea    -0x1(%eax),%edx
    70d0:	8b 45 10             	mov    0x10(%ebp),%eax
    70d3:	01 d0                	add    %edx,%eax
    70d5:	0f b6 00             	movzbl (%eax),%eax
    70d8:	0f b6 c0             	movzbl %al,%eax
    70db:	50                   	push   %eax
    70dc:	ff 75 08             	pushl  0x8(%ebp)
    70df:	e8 6f cb ff ff       	call   3c53 <uivector_push_back>
    70e4:	83 c4 08             	add    $0x8,%esp
    70e7:	85 c0                	test   %eax,%eax
    70e9:	75 43                	jne    712e <encodeLZ77+0x3ea>
    70eb:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    70f2:	e9 a5 01 00 00       	jmp    729c <encodeLZ77+0x558>
        } else {
          length = lazylength;
    70f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    70fa:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    70fd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7100:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    7103:	8b 45 0c             	mov    0xc(%ebp),%eax
    7106:	8b 00                	mov    (%eax),%eax
    7108:	8b 55 b0             	mov    -0x50(%ebp),%edx
    710b:	c1 e2 02             	shl    $0x2,%edx
    710e:	01 d0                	add    %edx,%eax
    7110:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    7116:	8b 45 0c             	mov    0xc(%ebp),%eax
    7119:	8b 40 0c             	mov    0xc(%eax),%eax
    711c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    711f:	c1 e2 02             	shl    $0x2,%edx
    7122:	01 d0                	add    %edx,%eax
    7124:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    712a:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    712e:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    7132:	76 14                	jbe    7148 <encodeLZ77+0x404>
    7134:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7137:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    713a:	76 0c                	jbe    7148 <encodeLZ77+0x404>
    713c:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    7143:	e9 54 01 00 00       	jmp    729c <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    7148:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    714c:	77 2e                	ja     717c <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    714e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7151:	8b 45 10             	mov    0x10(%ebp),%eax
    7154:	01 d0                	add    %edx,%eax
    7156:	0f b6 00             	movzbl (%eax),%eax
    7159:	0f b6 c0             	movzbl %al,%eax
    715c:	50                   	push   %eax
    715d:	ff 75 08             	pushl  0x8(%ebp)
    7160:	e8 ee ca ff ff       	call   3c53 <uivector_push_back>
    7165:	83 c4 08             	add    $0x8,%esp
    7168:	85 c0                	test   %eax,%eax
    716a:	0f 85 1c 01 00 00    	jne    728c <encodeLZ77+0x548>
    7170:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7177:	e9 20 01 00 00       	jmp    729c <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    717c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    717f:	3b 45 20             	cmp    0x20(%ebp),%eax
    7182:	72 0f                	jb     7193 <encodeLZ77+0x44f>
    7184:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    7188:	75 37                	jne    71c1 <encodeLZ77+0x47d>
    718a:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    7191:	76 2e                	jbe    71c1 <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    7193:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7196:	8b 45 10             	mov    0x10(%ebp),%eax
    7199:	01 d0                	add    %edx,%eax
    719b:	0f b6 00             	movzbl (%eax),%eax
    719e:	0f b6 c0             	movzbl %al,%eax
    71a1:	50                   	push   %eax
    71a2:	ff 75 08             	pushl  0x8(%ebp)
    71a5:	e8 a9 ca ff ff       	call   3c53 <uivector_push_back>
    71aa:	83 c4 08             	add    $0x8,%esp
    71ad:	85 c0                	test   %eax,%eax
    71af:	0f 85 d7 00 00 00    	jne    728c <encodeLZ77+0x548>
    71b5:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    71bc:	e9 db 00 00 00       	jmp    729c <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    71c1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    71c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71c7:	52                   	push   %edx
    71c8:	50                   	push   %eax
    71c9:	ff 75 08             	pushl  0x8(%ebp)
    71cc:	e8 8a f6 ff ff       	call   685b <addLengthDistance>
    71d1:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    71d4:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    71db:	e9 a0 00 00 00       	jmp    7280 <encodeLZ77+0x53c>
        ++pos;
    71e0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    71e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    71e7:	8d 50 ff             	lea    -0x1(%eax),%edx
    71ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
    71ed:	21 d0                	and    %edx,%eax
    71ef:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    71f2:	ff 75 fc             	pushl  -0x4(%ebp)
    71f5:	ff 75 18             	pushl  0x18(%ebp)
    71f8:	ff 75 10             	pushl  0x10(%ebp)
    71fb:	e8 67 f9 ff ff       	call   6b67 <getHash>
    7200:	83 c4 0c             	add    $0xc,%esp
    7203:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    7206:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    720a:	74 4e                	je     725a <encodeLZ77+0x516>
    720c:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    7210:	75 48                	jne    725a <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    7212:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7216:	75 16                	jne    722e <encodeLZ77+0x4ea>
    7218:	ff 75 fc             	pushl  -0x4(%ebp)
    721b:	ff 75 18             	pushl  0x18(%ebp)
    721e:	ff 75 10             	pushl  0x10(%ebp)
    7221:	e8 f5 f9 ff ff       	call   6c1b <countZeros>
    7226:	83 c4 0c             	add    $0xc,%esp
    7229:	89 45 f0             	mov    %eax,-0x10(%ebp)
    722c:	eb 35                	jmp    7263 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    722e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7231:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7234:	01 c2                	add    %eax,%edx
    7236:	8b 45 18             	mov    0x18(%ebp),%eax
    7239:	39 c2                	cmp    %eax,%edx
    723b:	77 17                	ja     7254 <encodeLZ77+0x510>
    723d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7240:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7243:	01 d0                	add    %edx,%eax
    7245:	8d 50 ff             	lea    -0x1(%eax),%edx
    7248:	8b 45 10             	mov    0x10(%ebp),%eax
    724b:	01 d0                	add    %edx,%eax
    724d:	0f b6 00             	movzbl (%eax),%eax
    7250:	84 c0                	test   %al,%al
    7252:	74 0f                	je     7263 <encodeLZ77+0x51f>
    7254:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    7258:	eb 09                	jmp    7263 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    725a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7261:	eb 01                	jmp    7264 <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    7263:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    7264:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7267:	0f b7 c0             	movzwl %ax,%eax
    726a:	50                   	push   %eax
    726b:	ff 75 b0             	pushl  -0x50(%ebp)
    726e:	ff 75 b4             	pushl  -0x4c(%ebp)
    7271:	ff 75 0c             	pushl  0xc(%ebp)
    7274:	e8 04 fa ff ff       	call   6c7d <updateHashChain>
    7279:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    727c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    7280:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7283:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7286:	0f 82 54 ff ff ff    	jb     71e0 <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    728c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7290:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7293:	3b 45 18             	cmp    0x18(%ebp),%eax
    7296:	0f 8c 54 fb ff ff    	jl     6df0 <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    729c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    729f:	c9                   	leave  
    72a0:	c3                   	ret    

000072a1 <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    72a1:	55                   	push   %ebp
    72a2:	89 e5                	mov    %esp,%ebp
    72a4:	53                   	push   %ebx
    72a5:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    72a8:	8b 45 10             	mov    0x10(%ebp),%eax
    72ab:	05 fe ff 00 00       	add    $0xfffe,%eax
    72b0:	ba 01 80 00 80       	mov    $0x80008001,%edx
    72b5:	f7 e2                	mul    %edx
    72b7:	89 d0                	mov    %edx,%eax
    72b9:	c1 e8 0f             	shr    $0xf,%eax
    72bc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    72bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    72c6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    72cd:	e9 1b 01 00 00       	jmp    73ed <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    72d2:	8b 45 08             	mov    0x8(%ebp),%eax
    72d5:	8b 40 04             	mov    0x4(%eax),%eax
    72d8:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    72db:	8b 45 ec             	mov    -0x14(%ebp),%eax
    72de:	83 e8 01             	sub    $0x1,%eax
    72e1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    72e4:	0f 94 c0             	sete   %al
    72e7:	0f b6 c0             	movzbl %al,%eax
    72ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    72ed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    72f4:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    72fb:	8b 45 10             	mov    0x10(%ebp),%eax
    72fe:	2b 45 f4             	sub    -0xc(%ebp),%eax
    7301:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    7306:	77 09                	ja     7311 <deflateNoCompression+0x70>
    7308:	8b 45 10             	mov    0x10(%ebp),%eax
    730b:	2b 45 f4             	sub    -0xc(%ebp),%eax
    730e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    7311:	b8 ff ff 00 00       	mov    $0xffff,%eax
    7316:	2b 45 f0             	sub    -0x10(%ebp),%eax
    7319:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    731c:	8b 45 08             	mov    0x8(%ebp),%eax
    731f:	8b 40 04             	mov    0x4(%eax),%eax
    7322:	89 c2                	mov    %eax,%edx
    7324:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7327:	01 d0                	add    %edx,%eax
    7329:	83 c0 05             	add    $0x5,%eax
    732c:	50                   	push   %eax
    732d:	ff 75 08             	pushl  0x8(%ebp)
    7330:	e8 62 c9 ff ff       	call   3c97 <ucvector_resize>
    7335:	83 c4 08             	add    $0x8,%esp
    7338:	85 c0                	test   %eax,%eax
    733a:	75 0a                	jne    7346 <deflateNoCompression+0xa5>
    733c:	b8 53 00 00 00       	mov    $0x53,%eax
    7341:	e9 b8 00 00 00       	jmp    73fe <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    7346:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7349:	89 c2                	mov    %eax,%edx
    734b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    734e:	83 e0 01             	and    $0x1,%eax
    7351:	01 c0                	add    %eax,%eax
    7353:	01 c2                	add    %eax,%edx
    7355:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7358:	83 e0 02             	and    $0x2,%eax
    735b:	01 c0                	add    %eax,%eax
    735d:	01 d0                	add    %edx,%eax
    735f:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    7362:	8b 45 08             	mov    0x8(%ebp),%eax
    7365:	8b 10                	mov    (%eax),%edx
    7367:	8b 45 e8             	mov    -0x18(%ebp),%eax
    736a:	01 c2                	add    %eax,%edx
    736c:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    7370:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    7372:	8b 45 08             	mov    0x8(%ebp),%eax
    7375:	8b 00                	mov    (%eax),%eax
    7377:	8b 55 e8             	mov    -0x18(%ebp),%edx
    737a:	83 c2 01             	add    $0x1,%edx
    737d:	01 d0                	add    %edx,%eax
    737f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    7382:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    7384:	8b 45 08             	mov    0x8(%ebp),%eax
    7387:	8b 00                	mov    (%eax),%eax
    7389:	8b 55 e8             	mov    -0x18(%ebp),%edx
    738c:	83 c2 02             	add    $0x2,%edx
    738f:	01 d0                	add    %edx,%eax
    7391:	8b 55 f0             	mov    -0x10(%ebp),%edx
    7394:	c1 ea 08             	shr    $0x8,%edx
    7397:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    7399:	8b 45 08             	mov    0x8(%ebp),%eax
    739c:	8b 00                	mov    (%eax),%eax
    739e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    73a1:	83 c2 03             	add    $0x3,%edx
    73a4:	01 d0                	add    %edx,%eax
    73a6:	8b 55 dc             	mov    -0x24(%ebp),%edx
    73a9:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    73ab:	8b 45 08             	mov    0x8(%ebp),%eax
    73ae:	8b 00                	mov    (%eax),%eax
    73b0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    73b3:	83 c2 04             	add    $0x4,%edx
    73b6:	01 d0                	add    %edx,%eax
    73b8:	8b 55 dc             	mov    -0x24(%ebp),%edx
    73bb:	c1 ea 08             	shr    $0x8,%edx
    73be:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    73c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    73c3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    73c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    73c9:	01 d1                	add    %edx,%ecx
    73cb:	8b 55 08             	mov    0x8(%ebp),%edx
    73ce:	8b 12                	mov    (%edx),%edx
    73d0:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    73d3:	83 c3 05             	add    $0x5,%ebx
    73d6:	01 da                	add    %ebx,%edx
    73d8:	50                   	push   %eax
    73d9:	51                   	push   %ecx
    73da:	52                   	push   %edx
    73db:	e8 9b c6 ff ff       	call   3a7b <lodepng_memcpy>
    73e0:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    73e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    73e6:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    73e9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    73ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
    73f0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    73f3:	0f 85 d9 fe ff ff    	jne    72d2 <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    73f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    73fe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7401:	c9                   	leave  
    7402:	c3                   	ret    

00007403 <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    7403:	55                   	push   %ebp
    7404:	89 e5                	mov    %esp,%ebp
    7406:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    7409:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    7410:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    7417:	e9 10 01 00 00       	jmp    752c <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    741c:	8b 45 0c             	mov    0xc(%ebp),%eax
    741f:	8b 00                	mov    (%eax),%eax
    7421:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7424:	c1 e2 02             	shl    $0x2,%edx
    7427:	01 d0                	add    %edx,%eax
    7429:	8b 00                	mov    (%eax),%eax
    742b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    742e:	8b 45 10             	mov    0x10(%ebp),%eax
    7431:	8b 40 04             	mov    0x4(%eax),%eax
    7434:	8b 55 f8             	mov    -0x8(%ebp),%edx
    7437:	c1 e2 02             	shl    $0x2,%edx
    743a:	01 d0                	add    %edx,%eax
    743c:	8b 00                	mov    (%eax),%eax
    743e:	89 c1                	mov    %eax,%ecx
    7440:	8b 45 10             	mov    0x10(%ebp),%eax
    7443:	8b 00                	mov    (%eax),%eax
    7445:	8b 55 f8             	mov    -0x8(%ebp),%edx
    7448:	c1 e2 02             	shl    $0x2,%edx
    744b:	01 d0                	add    %edx,%eax
    744d:	8b 00                	mov    (%eax),%eax
    744f:	51                   	push   %ecx
    7450:	50                   	push   %eax
    7451:	ff 75 08             	pushl  0x8(%ebp)
    7454:	e8 60 cc ff ff       	call   40b9 <writeBitsReversed>
    7459:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    745c:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    7463:	0f 86 bf 00 00 00    	jbe    7528 <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    7469:	8b 45 f8             	mov    -0x8(%ebp),%eax
    746c:	2d 01 01 00 00       	sub    $0x101,%eax
    7471:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    7474:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7477:	8b 04 85 00 a5 01 00 	mov    0x1a500(,%eax,4),%eax
    747e:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    7481:	8b 45 0c             	mov    0xc(%ebp),%eax
    7484:	8b 00                	mov    (%eax),%eax
    7486:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    748a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    748d:	c1 e2 02             	shl    $0x2,%edx
    7490:	01 d0                	add    %edx,%eax
    7492:	8b 00                	mov    (%eax),%eax
    7494:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    7497:	8b 45 0c             	mov    0xc(%ebp),%eax
    749a:	8b 00                	mov    (%eax),%eax
    749c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    74a0:	8b 55 fc             	mov    -0x4(%ebp),%edx
    74a3:	c1 e2 02             	shl    $0x2,%edx
    74a6:	01 d0                	add    %edx,%eax
    74a8:	8b 00                	mov    (%eax),%eax
    74aa:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    74ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    74b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    74b6:	8b 04 85 00 a6 01 00 	mov    0x1a600(,%eax,4),%eax
    74bd:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    74c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    74c3:	8b 00                	mov    (%eax),%eax
    74c5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    74c9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    74cc:	c1 e2 02             	shl    $0x2,%edx
    74cf:	01 d0                	add    %edx,%eax
    74d1:	8b 00                	mov    (%eax),%eax
    74d3:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    74d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    74d9:	50                   	push   %eax
    74da:	ff 75 ec             	pushl  -0x14(%ebp)
    74dd:	ff 75 08             	pushl  0x8(%ebp)
    74e0:	e8 40 ca ff ff       	call   3f25 <writeBits>
    74e5:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    74e8:	8b 45 14             	mov    0x14(%ebp),%eax
    74eb:	8b 40 04             	mov    0x4(%eax),%eax
    74ee:	8b 55 e8             	mov    -0x18(%ebp),%edx
    74f1:	c1 e2 02             	shl    $0x2,%edx
    74f4:	01 d0                	add    %edx,%eax
    74f6:	8b 00                	mov    (%eax),%eax
    74f8:	89 c1                	mov    %eax,%ecx
    74fa:	8b 45 14             	mov    0x14(%ebp),%eax
    74fd:	8b 00                	mov    (%eax),%eax
    74ff:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7502:	c1 e2 02             	shl    $0x2,%edx
    7505:	01 d0                	add    %edx,%eax
    7507:	8b 00                	mov    (%eax),%eax
    7509:	51                   	push   %ecx
    750a:	50                   	push   %eax
    750b:	ff 75 08             	pushl  0x8(%ebp)
    750e:	e8 a6 cb ff ff       	call   40b9 <writeBitsReversed>
    7513:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    7516:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7519:	50                   	push   %eax
    751a:	ff 75 dc             	pushl  -0x24(%ebp)
    751d:	ff 75 08             	pushl  0x8(%ebp)
    7520:	e8 00 ca ff ff       	call   3f25 <writeBits>
    7525:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    7528:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    752c:	8b 45 0c             	mov    0xc(%ebp),%eax
    752f:	8b 40 04             	mov    0x4(%eax),%eax
    7532:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    7535:	0f 85 e1 fe ff ff    	jne    741c <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    753b:	90                   	nop
    753c:	c9                   	leave  
    753d:	c3                   	ret    

0000753e <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    753e:	55                   	push   %ebp
    753f:	89 e5                	mov    %esp,%ebp
    7541:	53                   	push   %ebx
    7542:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    7548:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    754f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    7556:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    755d:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    7564:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    756b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    7572:	8b 45 18             	mov    0x18(%ebp),%eax
    7575:	2b 45 14             	sub    0x14(%ebp),%eax
    7578:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    757b:	8b 45 20             	mov    0x20(%ebp),%eax
    757e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    7581:	8d 45 90             	lea    -0x70(%ebp),%eax
    7584:	50                   	push   %eax
    7585:	e8 a4 c6 ff ff       	call   3c2e <uivector_init>
    758a:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    758d:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7593:	50                   	push   %eax
    7594:	e8 98 d3 ff ff       	call   4931 <HuffmanTree_init>
    7599:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    759c:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    75a2:	50                   	push   %eax
    75a3:	e8 89 d3 ff ff       	call   4931 <HuffmanTree_init>
    75a8:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    75ab:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    75b1:	50                   	push   %eax
    75b2:	e8 7a d3 ff ff       	call   4931 <HuffmanTree_init>
    75b7:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    75ba:	83 ec 0c             	sub    $0xc,%esp
    75bd:	68 78 04 00 00       	push   $0x478
    75c2:	e8 76 c4 ff ff       	call   3a3d <lodepng_malloc>
    75c7:	83 c4 10             	add    $0x10,%esp
    75ca:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    75cd:	83 ec 0c             	sub    $0xc,%esp
    75d0:	6a 78                	push   $0x78
    75d2:	e8 66 c4 ff ff       	call   3a3d <lodepng_malloc>
    75d7:	83 c4 10             	add    $0x10,%esp
    75da:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    75dd:	83 ec 0c             	sub    $0xc,%esp
    75e0:	6a 4c                	push   $0x4c
    75e2:	e8 56 c4 ff ff       	call   3a3d <lodepng_malloc>
    75e7:	83 c4 10             	add    $0x10,%esp
    75ea:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    75ed:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    75f1:	74 0c                	je     75ff <deflateDynamic+0xc1>
    75f3:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    75f7:	74 06                	je     75ff <deflateDynamic+0xc1>
    75f9:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    75fd:	75 07                	jne    7606 <deflateDynamic+0xc8>
    75ff:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    7606:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    760a:	0f 85 f6 07 00 00    	jne    7e06 <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    7610:	83 ec 04             	sub    $0x4,%esp
    7613:	68 78 04 00 00       	push   $0x478
    7618:	6a 00                	push   $0x0
    761a:	ff 75 d4             	pushl  -0x2c(%ebp)
    761d:	e8 8c c4 ff ff       	call   3aae <lodepng_memset>
    7622:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    7625:	83 ec 04             	sub    $0x4,%esp
    7628:	6a 78                	push   $0x78
    762a:	6a 00                	push   $0x0
    762c:	ff 75 d0             	pushl  -0x30(%ebp)
    762f:	e8 7a c4 ff ff       	call   3aae <lodepng_memset>
    7634:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    7637:	83 ec 04             	sub    $0x4,%esp
    763a:	6a 4c                	push   $0x4c
    763c:	6a 00                	push   $0x0
    763e:	ff 75 cc             	pushl  -0x34(%ebp)
    7641:	e8 68 c4 ff ff       	call   3aae <lodepng_memset>
    7646:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    7649:	8b 45 1c             	mov    0x1c(%ebp),%eax
    764c:	8b 40 04             	mov    0x4(%eax),%eax
    764f:	85 c0                	test   %eax,%eax
    7651:	74 45                	je     7698 <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    7653:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7656:	8b 58 14             	mov    0x14(%eax),%ebx
    7659:	8b 45 1c             	mov    0x1c(%ebp),%eax
    765c:	8b 48 10             	mov    0x10(%eax),%ecx
    765f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7662:	8b 50 0c             	mov    0xc(%eax),%edx
    7665:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7668:	8b 40 08             	mov    0x8(%eax),%eax
    766b:	83 ec 0c             	sub    $0xc,%esp
    766e:	53                   	push   %ebx
    766f:	51                   	push   %ecx
    7670:	52                   	push   %edx
    7671:	50                   	push   %eax
    7672:	ff 75 18             	pushl  0x18(%ebp)
    7675:	ff 75 14             	pushl  0x14(%ebp)
    7678:	ff 75 10             	pushl  0x10(%ebp)
    767b:	ff 75 0c             	pushl  0xc(%ebp)
    767e:	8d 45 90             	lea    -0x70(%ebp),%eax
    7681:	50                   	push   %eax
    7682:	e8 bd f6 ff ff       	call   6d44 <encodeLZ77>
    7687:	83 c4 30             	add    $0x30,%esp
    768a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    768d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7691:	74 59                	je     76ec <deflateDynamic+0x1ae>
    7693:	e9 6e 07 00 00       	jmp    7e06 <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    7698:	83 ec 08             	sub    $0x8,%esp
    769b:	ff 75 c8             	pushl  -0x38(%ebp)
    769e:	8d 45 90             	lea    -0x70(%ebp),%eax
    76a1:	50                   	push   %eax
    76a2:	e8 17 c5 ff ff       	call   3bbe <uivector_resize>
    76a7:	83 c4 10             	add    $0x10,%esp
    76aa:	85 c0                	test   %eax,%eax
    76ac:	75 0c                	jne    76ba <deflateDynamic+0x17c>
    76ae:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    76b5:	e9 4c 07 00 00       	jmp    7e06 <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    76ba:	8b 45 14             	mov    0x14(%ebp),%eax
    76bd:	89 45 e8             	mov    %eax,-0x18(%ebp)
    76c0:	eb 22                	jmp    76e4 <deflateDynamic+0x1a6>
    76c2:	8b 55 90             	mov    -0x70(%ebp),%edx
    76c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76c8:	2b 45 14             	sub    0x14(%ebp),%eax
    76cb:	c1 e0 02             	shl    $0x2,%eax
    76ce:	01 c2                	add    %eax,%edx
    76d0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    76d3:	8b 45 10             	mov    0x10(%ebp),%eax
    76d6:	01 c8                	add    %ecx,%eax
    76d8:	0f b6 00             	movzbl (%eax),%eax
    76db:	0f b6 c0             	movzbl %al,%eax
    76de:	89 02                	mov    %eax,(%edx)
    76e0:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    76e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76e7:	3b 45 18             	cmp    0x18(%ebp),%eax
    76ea:	7c d6                	jl     76c2 <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    76ec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    76f3:	eb 60                	jmp    7755 <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    76f5:	8b 45 90             	mov    -0x70(%ebp),%eax
    76f8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    76fb:	c1 e2 02             	shl    $0x2,%edx
    76fe:	01 d0                	add    %edx,%eax
    7700:	8b 00                	mov    (%eax),%eax
    7702:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    7705:	8b 45 c0             	mov    -0x40(%ebp),%eax
    7708:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    770f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7712:	01 d0                	add    %edx,%eax
    7714:	8b 10                	mov    (%eax),%edx
    7716:	83 c2 01             	add    $0x1,%edx
    7719:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    771b:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    7722:	76 2d                	jbe    7751 <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    7724:	8b 45 90             	mov    -0x70(%ebp),%eax
    7727:	8b 55 e8             	mov    -0x18(%ebp),%edx
    772a:	83 c2 02             	add    $0x2,%edx
    772d:	c1 e2 02             	shl    $0x2,%edx
    7730:	01 d0                	add    %edx,%eax
    7732:	8b 00                	mov    (%eax),%eax
    7734:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    7737:	8b 45 bc             	mov    -0x44(%ebp),%eax
    773a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7741:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7744:	01 d0                	add    %edx,%eax
    7746:	8b 10                	mov    (%eax),%edx
    7748:	83 c2 01             	add    $0x1,%edx
    774b:	89 10                	mov    %edx,(%eax)
        i += 3;
    774d:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    7751:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7755:	8b 45 94             	mov    -0x6c(%ebp),%eax
    7758:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    775b:	75 98                	jne    76f5 <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    775d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7760:	05 00 04 00 00       	add    $0x400,%eax
    7765:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    776b:	83 ec 0c             	sub    $0xc,%esp
    776e:	6a 0f                	push   $0xf
    7770:	68 1e 01 00 00       	push   $0x11e
    7775:	68 01 01 00 00       	push   $0x101
    777a:	ff 75 d4             	pushl  -0x2c(%ebp)
    777d:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7783:	50                   	push   %eax
    7784:	e8 e0 e1 ff ff       	call   5969 <HuffmanTree_makeFromFrequencies>
    7789:	83 c4 20             	add    $0x20,%esp
    778c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    778f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7793:	0f 85 66 06 00 00    	jne    7dff <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    7799:	83 ec 0c             	sub    $0xc,%esp
    779c:	6a 0f                	push   $0xf
    779e:	6a 1e                	push   $0x1e
    77a0:	6a 02                	push   $0x2
    77a2:	ff 75 d0             	pushl  -0x30(%ebp)
    77a5:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    77ab:	50                   	push   %eax
    77ac:	e8 b8 e1 ff ff       	call   5969 <HuffmanTree_makeFromFrequencies>
    77b1:	83 c4 20             	add    $0x20,%esp
    77b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    77b7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    77bb:	0f 85 41 06 00 00    	jne    7e02 <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    77c1:	8b 45 84             	mov    -0x7c(%ebp),%eax
    77c4:	ba 1e 01 00 00       	mov    $0x11e,%edx
    77c9:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    77ce:	0f 47 c2             	cmova  %edx,%eax
    77d1:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    77d4:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    77da:	ba 1e 00 00 00       	mov    $0x1e,%edx
    77df:	83 f8 1e             	cmp    $0x1e,%eax
    77e2:	0f 47 c2             	cmova  %edx,%eax
    77e5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    77e8:	8b 55 b8             	mov    -0x48(%ebp),%edx
    77eb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    77ee:	01 d0                	add    %edx,%eax
    77f0:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    77f3:	8b 45 b0             	mov    -0x50(%ebp),%eax
    77f6:	c1 e0 02             	shl    $0x2,%eax
    77f9:	83 ec 0c             	sub    $0xc,%esp
    77fc:	50                   	push   %eax
    77fd:	e8 3b c2 ff ff       	call   3a3d <lodepng_malloc>
    7802:	83 c4 10             	add    $0x10,%esp
    7805:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    7808:	8b 45 b0             	mov    -0x50(%ebp),%eax
    780b:	c1 e0 02             	shl    $0x2,%eax
    780e:	83 ec 0c             	sub    $0xc,%esp
    7811:	50                   	push   %eax
    7812:	e8 26 c2 ff ff       	call   3a3d <lodepng_malloc>
    7817:	83 c4 10             	add    $0x10,%esp
    781a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    781d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7821:	74 06                	je     7829 <deflateDynamic+0x2eb>
    7823:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    7827:	75 0c                	jne    7835 <deflateDynamic+0x2f7>
    7829:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7830:	e9 d1 05 00 00       	jmp    7e06 <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    7835:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    783c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7843:	eb 25                	jmp    786a <deflateDynamic+0x32c>
    7845:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7848:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    784f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7852:	01 c2                	add    %eax,%edx
    7854:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    785a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    785d:	c1 e1 02             	shl    $0x2,%ecx
    7860:	01 c8                	add    %ecx,%eax
    7862:	8b 00                	mov    (%eax),%eax
    7864:	89 02                	mov    %eax,(%edx)
    7866:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    786a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    786d:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    7870:	75 d3                	jne    7845 <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    7872:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7879:	eb 2a                	jmp    78a5 <deflateDynamic+0x367>
    787b:	8b 55 b8             	mov    -0x48(%ebp),%edx
    787e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7881:	01 d0                	add    %edx,%eax
    7883:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    788a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    788d:	01 c2                	add    %eax,%edx
    788f:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    7895:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7898:	c1 e1 02             	shl    $0x2,%ecx
    789b:	01 c8                	add    %ecx,%eax
    789d:	8b 00                	mov    (%eax),%eax
    789f:	89 02                	mov    %eax,(%edx)
    78a1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    78a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    78a8:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    78ab:	75 ce                	jne    787b <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    78ad:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    78b4:	e9 3b 02 00 00       	jmp    7af4 <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    78b9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    78c0:	eb 04                	jmp    78c6 <deflateDynamic+0x388>
    78c2:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    78c6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    78c9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    78cc:	01 d0                	add    %edx,%eax
    78ce:	8d 50 01             	lea    0x1(%eax),%edx
    78d1:	8b 45 b0             	mov    -0x50(%ebp),%eax
    78d4:	39 c2                	cmp    %eax,%edx
    78d6:	73 2e                	jae    7906 <deflateDynamic+0x3c8>
    78d8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    78db:	8b 45 dc             	mov    -0x24(%ebp),%eax
    78de:	01 d0                	add    %edx,%eax
    78e0:	83 c0 01             	add    $0x1,%eax
    78e3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    78ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
    78ed:	01 d0                	add    %edx,%eax
    78ef:	8b 10                	mov    (%eax),%edx
    78f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    78f4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    78fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    78fe:	01 c8                	add    %ecx,%eax
    7900:	8b 00                	mov    (%eax),%eax
    7902:	39 c2                	cmp    %eax,%edx
    7904:	74 bc                	je     78c2 <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    7906:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7909:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7910:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7913:	01 d0                	add    %edx,%eax
    7915:	8b 00                	mov    (%eax),%eax
    7917:	85 c0                	test   %eax,%eax
    7919:	0f 85 a9 00 00 00    	jne    79c8 <deflateDynamic+0x48a>
    791f:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    7923:	0f 86 9f 00 00 00    	jbe    79c8 <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    7929:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    792d:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    7931:	77 3a                	ja     796d <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    7933:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7936:	8d 50 01             	lea    0x1(%eax),%edx
    7939:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    793c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7943:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7946:	01 d0                	add    %edx,%eax
    7948:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    794e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7951:	8d 50 01             	lea    0x1(%eax),%edx
    7954:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7957:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    795e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7961:	01 d0                	add    %edx,%eax
    7963:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7966:	83 ea 03             	sub    $0x3,%edx
    7969:	89 10                	mov    %edx,(%eax)
    796b:	eb 48                	jmp    79b5 <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    796d:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    7974:	76 07                	jbe    797d <deflateDynamic+0x43f>
    7976:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    797d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7980:	8d 50 01             	lea    0x1(%eax),%edx
    7983:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7986:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    798d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7990:	01 d0                	add    %edx,%eax
    7992:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    7998:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    799b:	8d 50 01             	lea    0x1(%eax),%edx
    799e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    79a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    79a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    79ab:	01 d0                	add    %edx,%eax
    79ad:	8b 55 dc             	mov    -0x24(%ebp),%edx
    79b0:	83 ea 0b             	sub    $0xb,%edx
    79b3:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    79b5:	8b 55 e8             	mov    -0x18(%ebp),%edx
    79b8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    79bb:	01 d0                	add    %edx,%eax
    79bd:	83 e8 01             	sub    $0x1,%eax
    79c0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    79c3:	e9 28 01 00 00       	jmp    7af0 <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    79c8:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    79cc:	0f 86 f6 00 00 00    	jbe    7ac8 <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    79d2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    79d5:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    79da:	f7 e2                	mul    %edx
    79dc:	89 d0                	mov    %edx,%eax
    79de:	c1 e8 02             	shr    $0x2,%eax
    79e1:	89 45 ac             	mov    %eax,-0x54(%ebp)
    79e4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    79e7:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    79ec:	89 c8                	mov    %ecx,%eax
    79ee:	f7 e2                	mul    %edx
    79f0:	c1 ea 02             	shr    $0x2,%edx
    79f3:	89 d0                	mov    %edx,%eax
    79f5:	01 c0                	add    %eax,%eax
    79f7:	01 d0                	add    %edx,%eax
    79f9:	01 c0                	add    %eax,%eax
    79fb:	29 c1                	sub    %eax,%ecx
    79fd:	89 c8                	mov    %ecx,%eax
    79ff:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    7a02:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7a05:	8d 50 01             	lea    0x1(%eax),%edx
    7a08:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7a0b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7a12:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7a15:	01 c2                	add    %eax,%edx
    7a17:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7a1a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7a21:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7a24:	01 c8                	add    %ecx,%eax
    7a26:	8b 00                	mov    (%eax),%eax
    7a28:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    7a2a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    7a31:	eb 3a                	jmp    7a6d <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7a33:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7a36:	8d 50 01             	lea    0x1(%eax),%edx
    7a39:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7a3c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7a43:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7a46:	01 d0                	add    %edx,%eax
    7a48:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    7a4e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7a51:	8d 50 01             	lea    0x1(%eax),%edx
    7a54:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7a57:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7a5e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7a61:	01 d0                	add    %edx,%eax
    7a63:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    7a69:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    7a6d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7a70:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    7a73:	72 be                	jb     7a33 <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    7a75:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    7a79:	76 3a                	jbe    7ab5 <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7a7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7a7e:	8d 50 01             	lea    0x1(%eax),%edx
    7a81:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7a84:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7a8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7a8e:	01 d0                	add    %edx,%eax
    7a90:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    7a96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7a99:	8d 50 01             	lea    0x1(%eax),%edx
    7a9c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7a9f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7aa6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7aa9:	01 d0                	add    %edx,%eax
    7aab:	8b 55 a8             	mov    -0x58(%ebp),%edx
    7aae:	83 ea 03             	sub    $0x3,%edx
    7ab1:	89 10                	mov    %edx,(%eax)
    7ab3:	eb 06                	jmp    7abb <deflateDynamic+0x57d>
        }
        else j -= rest;
    7ab5:	8b 45 a8             	mov    -0x58(%ebp),%eax
    7ab8:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    7abb:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7abe:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7ac1:	01 d0                	add    %edx,%eax
    7ac3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7ac6:	eb 28                	jmp    7af0 <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    7ac8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7acb:	8d 50 01             	lea    0x1(%eax),%edx
    7ace:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7ad1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7ad8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7adb:	01 c2                	add    %eax,%edx
    7add:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7ae0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7ae7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7aea:	01 c8                	add    %ecx,%eax
    7aec:	8b 00                	mov    (%eax),%eax
    7aee:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7af0:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7af4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7af7:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    7afa:	0f 85 b9 fd ff ff    	jne    78b9 <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7b00:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7b07:	eb 42                	jmp    7b4b <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    7b09:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7b0c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7b13:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7b16:	01 d0                	add    %edx,%eax
    7b18:	8b 00                	mov    (%eax),%eax
    7b1a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7b21:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7b24:	01 d0                	add    %edx,%eax
    7b26:	8b 10                	mov    (%eax),%edx
    7b28:	83 c2 01             	add    $0x1,%edx
    7b2b:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    7b2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7b30:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7b37:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7b3a:	01 d0                	add    %edx,%eax
    7b3c:	8b 00                	mov    (%eax),%eax
    7b3e:	83 f8 0f             	cmp    $0xf,%eax
    7b41:	76 04                	jbe    7b47 <deflateDynamic+0x609>
    7b43:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7b47:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7b4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7b4e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7b51:	75 b6                	jne    7b09 <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    7b53:	83 ec 0c             	sub    $0xc,%esp
    7b56:	6a 07                	push   $0x7
    7b58:	6a 13                	push   $0x13
    7b5a:	6a 13                	push   $0x13
    7b5c:	ff 75 cc             	pushl  -0x34(%ebp)
    7b5f:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7b65:	50                   	push   %eax
    7b66:	e8 fe dd ff ff       	call   5969 <HuffmanTree_makeFromFrequencies>
    7b6b:	83 c4 20             	add    $0x20,%esp
    7b6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    7b71:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b75:	0f 85 8a 02 00 00    	jne    7e05 <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    7b7b:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7b82:	eb 04                	jmp    7b88 <deflateDynamic+0x64a>
      numcodes_cl--;
    7b84:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7b88:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7b8b:	83 f8 04             	cmp    $0x4,%eax
    7b8e:	76 1e                	jbe    7bae <deflateDynamic+0x670>
    7b90:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7b96:	8b 55 e0             	mov    -0x20(%ebp),%edx
    7b99:	83 ea 01             	sub    $0x1,%edx
    7b9c:	8b 14 95 80 a6 01 00 	mov    0x1a680(,%edx,4),%edx
    7ba3:	c1 e2 02             	shl    $0x2,%edx
    7ba6:	01 d0                	add    %edx,%eax
    7ba8:	8b 00                	mov    (%eax),%eax
    7baa:	85 c0                	test   %eax,%eax
    7bac:	74 d6                	je     7b84 <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    7bae:	83 ec 04             	sub    $0x4,%esp
    7bb1:	6a 01                	push   $0x1
    7bb3:	ff 75 c4             	pushl  -0x3c(%ebp)
    7bb6:	ff 75 08             	pushl  0x8(%ebp)
    7bb9:	e8 67 c3 ff ff       	call   3f25 <writeBits>
    7bbe:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    7bc1:	83 ec 04             	sub    $0x4,%esp
    7bc4:	6a 01                	push   $0x1
    7bc6:	6a 00                	push   $0x0
    7bc8:	ff 75 08             	pushl  0x8(%ebp)
    7bcb:	e8 55 c3 ff ff       	call   3f25 <writeBits>
    7bd0:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    7bd3:	83 ec 04             	sub    $0x4,%esp
    7bd6:	6a 01                	push   $0x1
    7bd8:	6a 01                	push   $0x1
    7bda:	ff 75 08             	pushl  0x8(%ebp)
    7bdd:	e8 43 c3 ff ff       	call   3f25 <writeBits>
    7be2:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    7be5:	8b 45 b8             	mov    -0x48(%ebp),%eax
    7be8:	2d 01 01 00 00       	sub    $0x101,%eax
    7bed:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    7bf0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7bf3:	83 e8 01             	sub    $0x1,%eax
    7bf6:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    7bf9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7bfc:	83 e8 04             	sub    $0x4,%eax
    7bff:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    7c02:	83 ec 04             	sub    $0x4,%esp
    7c05:	6a 05                	push   $0x5
    7c07:	ff 75 a4             	pushl  -0x5c(%ebp)
    7c0a:	ff 75 08             	pushl  0x8(%ebp)
    7c0d:	e8 13 c3 ff ff       	call   3f25 <writeBits>
    7c12:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    7c15:	83 ec 04             	sub    $0x4,%esp
    7c18:	6a 05                	push   $0x5
    7c1a:	ff 75 a0             	pushl  -0x60(%ebp)
    7c1d:	ff 75 08             	pushl  0x8(%ebp)
    7c20:	e8 00 c3 ff ff       	call   3f25 <writeBits>
    7c25:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    7c28:	83 ec 04             	sub    $0x4,%esp
    7c2b:	6a 04                	push   $0x4
    7c2d:	ff 75 9c             	pushl  -0x64(%ebp)
    7c30:	ff 75 08             	pushl  0x8(%ebp)
    7c33:	e8 ed c2 ff ff       	call   3f25 <writeBits>
    7c38:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    7c3b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7c42:	eb 2c                	jmp    7c70 <deflateDynamic+0x732>
    7c44:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    7c4a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7c4d:	8b 04 85 80 a6 01 00 	mov    0x1a680(,%eax,4),%eax
    7c54:	c1 e0 02             	shl    $0x2,%eax
    7c57:	01 d0                	add    %edx,%eax
    7c59:	8b 00                	mov    (%eax),%eax
    7c5b:	83 ec 04             	sub    $0x4,%esp
    7c5e:	6a 03                	push   $0x3
    7c60:	50                   	push   %eax
    7c61:	ff 75 08             	pushl  0x8(%ebp)
    7c64:	e8 bc c2 ff ff       	call   3f25 <writeBits>
    7c69:	83 c4 10             	add    $0x10,%esp
    7c6c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7c70:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7c73:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    7c76:	75 cc                	jne    7c44 <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7c78:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7c7f:	e9 0a 01 00 00       	jmp    7d8e <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    7c84:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7c8a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7c8d:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    7c94:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7c97:	01 ca                	add    %ecx,%edx
    7c99:	8b 12                	mov    (%edx),%edx
    7c9b:	c1 e2 02             	shl    $0x2,%edx
    7c9e:	01 d0                	add    %edx,%eax
    7ca0:	8b 00                	mov    (%eax),%eax
    7ca2:	89 c3                	mov    %eax,%ebx
    7ca4:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    7caa:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7cad:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    7cb4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7cb7:	01 ca                	add    %ecx,%edx
    7cb9:	8b 12                	mov    (%edx),%edx
    7cbb:	c1 e2 02             	shl    $0x2,%edx
    7cbe:	01 d0                	add    %edx,%eax
    7cc0:	8b 00                	mov    (%eax),%eax
    7cc2:	83 ec 04             	sub    $0x4,%esp
    7cc5:	53                   	push   %ebx
    7cc6:	50                   	push   %eax
    7cc7:	ff 75 08             	pushl  0x8(%ebp)
    7cca:	e8 ea c3 ff ff       	call   40b9 <writeBitsReversed>
    7ccf:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    7cd2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7cd5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7cdc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7cdf:	01 d0                	add    %edx,%eax
    7ce1:	8b 00                	mov    (%eax),%eax
    7ce3:	83 f8 10             	cmp    $0x10,%eax
    7ce6:	75 28                	jne    7d10 <deflateDynamic+0x7d2>
    7ce8:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7cec:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7cef:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7cf6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7cf9:	01 d0                	add    %edx,%eax
    7cfb:	8b 00                	mov    (%eax),%eax
    7cfd:	83 ec 04             	sub    $0x4,%esp
    7d00:	6a 02                	push   $0x2
    7d02:	50                   	push   %eax
    7d03:	ff 75 08             	pushl  0x8(%ebp)
    7d06:	e8 1a c2 ff ff       	call   3f25 <writeBits>
    7d0b:	83 c4 10             	add    $0x10,%esp
    7d0e:	eb 7a                	jmp    7d8a <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    7d10:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7d13:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7d1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7d1d:	01 d0                	add    %edx,%eax
    7d1f:	8b 00                	mov    (%eax),%eax
    7d21:	83 f8 11             	cmp    $0x11,%eax
    7d24:	75 28                	jne    7d4e <deflateDynamic+0x810>
    7d26:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7d2a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7d2d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7d34:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7d37:	01 d0                	add    %edx,%eax
    7d39:	8b 00                	mov    (%eax),%eax
    7d3b:	83 ec 04             	sub    $0x4,%esp
    7d3e:	6a 03                	push   $0x3
    7d40:	50                   	push   %eax
    7d41:	ff 75 08             	pushl  0x8(%ebp)
    7d44:	e8 dc c1 ff ff       	call   3f25 <writeBits>
    7d49:	83 c4 10             	add    $0x10,%esp
    7d4c:	eb 3c                	jmp    7d8a <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    7d4e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7d51:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7d58:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7d5b:	01 d0                	add    %edx,%eax
    7d5d:	8b 00                	mov    (%eax),%eax
    7d5f:	83 f8 12             	cmp    $0x12,%eax
    7d62:	75 26                	jne    7d8a <deflateDynamic+0x84c>
    7d64:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7d68:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7d6b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7d72:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7d75:	01 d0                	add    %edx,%eax
    7d77:	8b 00                	mov    (%eax),%eax
    7d79:	83 ec 04             	sub    $0x4,%esp
    7d7c:	6a 07                	push   $0x7
    7d7e:	50                   	push   %eax
    7d7f:	ff 75 08             	pushl  0x8(%ebp)
    7d82:	e8 9e c1 ff ff       	call   3f25 <writeBits>
    7d87:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7d8a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7d8e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7d91:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7d94:	0f 85 ea fe ff ff    	jne    7c84 <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7d9a:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7da0:	50                   	push   %eax
    7da1:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7da7:	50                   	push   %eax
    7da8:	8d 45 90             	lea    -0x70(%ebp),%eax
    7dab:	50                   	push   %eax
    7dac:	ff 75 08             	pushl  0x8(%ebp)
    7daf:	e8 4f f6 ff ff       	call   7403 <writeLZ77data>
    7db4:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    7db7:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7dbd:	05 00 04 00 00       	add    $0x400,%eax
    7dc2:	8b 00                	mov    (%eax),%eax
    7dc4:	85 c0                	test   %eax,%eax
    7dc6:	75 09                	jne    7dd1 <deflateDynamic+0x893>
    7dc8:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    7dcf:	eb 35                	jmp    7e06 <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    7dd1:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7dd7:	05 00 04 00 00       	add    $0x400,%eax
    7ddc:	8b 00                	mov    (%eax),%eax
    7dde:	89 c2                	mov    %eax,%edx
    7de0:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    7de6:	05 00 04 00 00       	add    $0x400,%eax
    7deb:	8b 00                	mov    (%eax),%eax
    7ded:	83 ec 04             	sub    $0x4,%esp
    7df0:	52                   	push   %edx
    7df1:	50                   	push   %eax
    7df2:	ff 75 08             	pushl  0x8(%ebp)
    7df5:	e8 bf c2 ff ff       	call   40b9 <writeBitsReversed>
    7dfa:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    7dfd:	eb 07                	jmp    7e06 <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    7dff:	90                   	nop
    7e00:	eb 04                	jmp    7e06 <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    7e02:	90                   	nop
    7e03:	eb 01                	jmp    7e06 <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    7e05:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    7e06:	83 ec 0c             	sub    $0xc,%esp
    7e09:	8d 45 90             	lea    -0x70(%ebp),%eax
    7e0c:	50                   	push   %eax
    7e0d:	e8 73 bd ff ff       	call   3b85 <uivector_cleanup>
    7e12:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    7e15:	83 ec 0c             	sub    $0xc,%esp
    7e18:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7e1e:	50                   	push   %eax
    7e1f:	e8 3a cb ff ff       	call   495e <HuffmanTree_cleanup>
    7e24:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7e27:	83 ec 0c             	sub    $0xc,%esp
    7e2a:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7e30:	50                   	push   %eax
    7e31:	e8 28 cb ff ff       	call   495e <HuffmanTree_cleanup>
    7e36:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    7e39:	83 ec 0c             	sub    $0xc,%esp
    7e3c:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7e42:	50                   	push   %eax
    7e43:	e8 16 cb ff ff       	call   495e <HuffmanTree_cleanup>
    7e48:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    7e4b:	83 ec 0c             	sub    $0xc,%esp
    7e4e:	ff 75 d4             	pushl  -0x2c(%ebp)
    7e51:	e8 08 bc ff ff       	call   3a5e <lodepng_free>
    7e56:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    7e59:	83 ec 0c             	sub    $0xc,%esp
    7e5c:	ff 75 d0             	pushl  -0x30(%ebp)
    7e5f:	e8 fa bb ff ff       	call   3a5e <lodepng_free>
    7e64:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    7e67:	83 ec 0c             	sub    $0xc,%esp
    7e6a:	ff 75 cc             	pushl  -0x34(%ebp)
    7e6d:	e8 ec bb ff ff       	call   3a5e <lodepng_free>
    7e72:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    7e75:	83 ec 0c             	sub    $0xc,%esp
    7e78:	ff 75 f0             	pushl  -0x10(%ebp)
    7e7b:	e8 de bb ff ff       	call   3a5e <lodepng_free>
    7e80:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    7e83:	83 ec 0c             	sub    $0xc,%esp
    7e86:	ff 75 ec             	pushl  -0x14(%ebp)
    7e89:	e8 d0 bb ff ff       	call   3a5e <lodepng_free>
    7e8e:	83 c4 10             	add    $0x10,%esp

  return error;
    7e91:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7e94:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7e97:	c9                   	leave  
    7e98:	c3                   	ret    

00007e99 <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    7e99:	55                   	push   %ebp
    7e9a:	89 e5                	mov    %esp,%ebp
    7e9c:	53                   	push   %ebx
    7e9d:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    7ea0:	8b 45 20             	mov    0x20(%ebp),%eax
    7ea3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    7ea6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    7ead:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7eb0:	50                   	push   %eax
    7eb1:	e8 7b ca ff ff       	call   4931 <HuffmanTree_init>
    7eb6:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    7eb9:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7ebc:	50                   	push   %eax
    7ebd:	e8 6f ca ff ff       	call   4931 <HuffmanTree_init>
    7ec2:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    7ec5:	83 ec 0c             	sub    $0xc,%esp
    7ec8:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7ecb:	50                   	push   %eax
    7ecc:	e8 41 db ff ff       	call   5a12 <generateFixedLitLenTree>
    7ed1:	83 c4 10             	add    $0x10,%esp
    7ed4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    7ed7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7edb:	75 12                	jne    7eef <deflateFixed+0x56>
    7edd:	83 ec 0c             	sub    $0xc,%esp
    7ee0:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7ee3:	50                   	push   %eax
    7ee4:	e8 30 dc ff ff       	call   5b19 <generateFixedDistanceTree>
    7ee9:	83 c4 10             	add    $0x10,%esp
    7eec:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7eef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7ef3:	0f 85 3a 01 00 00    	jne    8033 <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    7ef9:	83 ec 04             	sub    $0x4,%esp
    7efc:	6a 01                	push   $0x1
    7efe:	ff 75 ec             	pushl  -0x14(%ebp)
    7f01:	ff 75 08             	pushl  0x8(%ebp)
    7f04:	e8 1c c0 ff ff       	call   3f25 <writeBits>
    7f09:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    7f0c:	83 ec 04             	sub    $0x4,%esp
    7f0f:	6a 01                	push   $0x1
    7f11:	6a 01                	push   $0x1
    7f13:	ff 75 08             	pushl  0x8(%ebp)
    7f16:	e8 0a c0 ff ff       	call   3f25 <writeBits>
    7f1b:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    7f1e:	83 ec 04             	sub    $0x4,%esp
    7f21:	6a 01                	push   $0x1
    7f23:	6a 00                	push   $0x0
    7f25:	ff 75 08             	pushl  0x8(%ebp)
    7f28:	e8 f8 bf ff ff       	call   3f25 <writeBits>
    7f2d:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    7f30:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7f33:	8b 40 04             	mov    0x4(%eax),%eax
    7f36:	85 c0                	test   %eax,%eax
    7f38:	74 77                	je     7fb1 <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    7f3a:	83 ec 0c             	sub    $0xc,%esp
    7f3d:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7f40:	50                   	push   %eax
    7f41:	e8 e8 bc ff ff       	call   3c2e <uivector_init>
    7f46:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    7f49:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7f4c:	8b 58 14             	mov    0x14(%eax),%ebx
    7f4f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7f52:	8b 48 10             	mov    0x10(%eax),%ecx
    7f55:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7f58:	8b 50 0c             	mov    0xc(%eax),%edx
    7f5b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7f5e:	8b 40 08             	mov    0x8(%eax),%eax
    7f61:	83 ec 0c             	sub    $0xc,%esp
    7f64:	53                   	push   %ebx
    7f65:	51                   	push   %ecx
    7f66:	52                   	push   %edx
    7f67:	50                   	push   %eax
    7f68:	ff 75 18             	pushl  0x18(%ebp)
    7f6b:	ff 75 14             	pushl  0x14(%ebp)
    7f6e:	ff 75 10             	pushl  0x10(%ebp)
    7f71:	ff 75 0c             	pushl  0xc(%ebp)
    7f74:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7f77:	50                   	push   %eax
    7f78:	e8 c7 ed ff ff       	call   6d44 <encodeLZ77>
    7f7d:	83 c4 30             	add    $0x30,%esp
    7f80:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7f83:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7f87:	75 17                	jne    7fa0 <deflateFixed+0x107>
    7f89:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7f8c:	50                   	push   %eax
    7f8d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7f90:	50                   	push   %eax
    7f91:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7f94:	50                   	push   %eax
    7f95:	ff 75 08             	pushl  0x8(%ebp)
    7f98:	e8 66 f4 ff ff       	call   7403 <writeLZ77data>
    7f9d:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    7fa0:	83 ec 0c             	sub    $0xc,%esp
    7fa3:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7fa6:	50                   	push   %eax
    7fa7:	e8 d9 bb ff ff       	call   3b85 <uivector_cleanup>
    7fac:	83 c4 10             	add    $0x10,%esp
    7faf:	eb 56                	jmp    8007 <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7fb1:	8b 45 14             	mov    0x14(%ebp),%eax
    7fb4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7fb7:	eb 46                	jmp    7fff <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    7fb9:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7fbc:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7fbf:	8b 55 10             	mov    0x10(%ebp),%edx
    7fc2:	01 ca                	add    %ecx,%edx
    7fc4:	0f b6 12             	movzbl (%edx),%edx
    7fc7:	0f b6 d2             	movzbl %dl,%edx
    7fca:	c1 e2 02             	shl    $0x2,%edx
    7fcd:	01 d0                	add    %edx,%eax
    7fcf:	8b 00                	mov    (%eax),%eax
    7fd1:	89 c3                	mov    %eax,%ebx
    7fd3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7fd6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7fd9:	8b 55 10             	mov    0x10(%ebp),%edx
    7fdc:	01 ca                	add    %ecx,%edx
    7fde:	0f b6 12             	movzbl (%edx),%edx
    7fe1:	0f b6 d2             	movzbl %dl,%edx
    7fe4:	c1 e2 02             	shl    $0x2,%edx
    7fe7:	01 d0                	add    %edx,%eax
    7fe9:	8b 00                	mov    (%eax),%eax
    7feb:	83 ec 04             	sub    $0x4,%esp
    7fee:	53                   	push   %ebx
    7fef:	50                   	push   %eax
    7ff0:	ff 75 08             	pushl  0x8(%ebp)
    7ff3:	e8 c1 c0 ff ff       	call   40b9 <writeBitsReversed>
    7ff8:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7ffb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7fff:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8002:	3b 45 18             	cmp    0x18(%ebp),%eax
    8005:	7c b2                	jl     7fb9 <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    8007:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    800b:	75 26                	jne    8033 <deflateFixed+0x19a>
    800d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8010:	05 00 04 00 00       	add    $0x400,%eax
    8015:	8b 00                	mov    (%eax),%eax
    8017:	89 c2                	mov    %eax,%edx
    8019:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    801c:	05 00 04 00 00       	add    $0x400,%eax
    8021:	8b 00                	mov    (%eax),%eax
    8023:	83 ec 04             	sub    $0x4,%esp
    8026:	52                   	push   %edx
    8027:	50                   	push   %eax
    8028:	ff 75 08             	pushl  0x8(%ebp)
    802b:	e8 89 c0 ff ff       	call   40b9 <writeBitsReversed>
    8030:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    8033:	83 ec 0c             	sub    $0xc,%esp
    8036:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    8039:	50                   	push   %eax
    803a:	e8 1f c9 ff ff       	call   495e <HuffmanTree_cleanup>
    803f:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    8042:	83 ec 0c             	sub    $0xc,%esp
    8045:	8d 45 bc             	lea    -0x44(%ebp),%eax
    8048:	50                   	push   %eax
    8049:	e8 10 c9 ff ff       	call   495e <HuffmanTree_cleanup>
    804e:	83 c4 10             	add    $0x10,%esp

  return error;
    8051:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8054:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8057:	c9                   	leave  
    8058:	c3                   	ret    

00008059 <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    8059:	55                   	push   %ebp
    805a:	89 e5                	mov    %esp,%ebp
    805c:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    805f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    8066:	ff 75 08             	pushl  0x8(%ebp)
    8069:	8d 45 bc             	lea    -0x44(%ebp),%eax
    806c:	50                   	push   %eax
    806d:	e8 9e be ff ff       	call   3f10 <LodePNGBitWriter_init>
    8072:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    8075:	8b 45 14             	mov    0x14(%ebp),%eax
    8078:	8b 00                	mov    (%eax),%eax
    807a:	83 f8 02             	cmp    $0x2,%eax
    807d:	76 0a                	jbe    8089 <lodepng_deflatev+0x30>
    807f:	b8 3d 00 00 00       	mov    $0x3d,%eax
    8084:	e9 68 01 00 00       	jmp    81f1 <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    8089:	8b 45 14             	mov    0x14(%ebp),%eax
    808c:	8b 00                	mov    (%eax),%eax
    808e:	85 c0                	test   %eax,%eax
    8090:	75 16                	jne    80a8 <lodepng_deflatev+0x4f>
    8092:	ff 75 10             	pushl  0x10(%ebp)
    8095:	ff 75 0c             	pushl  0xc(%ebp)
    8098:	ff 75 08             	pushl  0x8(%ebp)
    809b:	e8 01 f2 ff ff       	call   72a1 <deflateNoCompression>
    80a0:	83 c4 0c             	add    $0xc,%esp
    80a3:	e9 49 01 00 00       	jmp    81f1 <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    80a8:	8b 45 14             	mov    0x14(%ebp),%eax
    80ab:	8b 00                	mov    (%eax),%eax
    80ad:	83 f8 01             	cmp    $0x1,%eax
    80b0:	75 08                	jne    80ba <lodepng_deflatev+0x61>
    80b2:	8b 45 10             	mov    0x10(%ebp),%eax
    80b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    80b8:	eb 2c                	jmp    80e6 <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    80ba:	8b 45 10             	mov    0x10(%ebp),%eax
    80bd:	c1 e8 03             	shr    $0x3,%eax
    80c0:	83 c0 08             	add    $0x8,%eax
    80c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    80c6:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    80cd:	7f 07                	jg     80d6 <lodepng_deflatev+0x7d>
    80cf:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    80d6:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    80dd:	7e 07                	jle    80e6 <lodepng_deflatev+0x8d>
    80df:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    80e6:	8b 55 10             	mov    0x10(%ebp),%edx
    80e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    80ec:	01 d0                	add    %edx,%eax
    80ee:	83 e8 01             	sub    $0x1,%eax
    80f1:	99                   	cltd   
    80f2:	f7 7d ec             	idivl  -0x14(%ebp)
    80f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    80f8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    80fc:	75 07                	jne    8105 <lodepng_deflatev+0xac>
    80fe:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    8105:	8b 45 14             	mov    0x14(%ebp),%eax
    8108:	8b 40 08             	mov    0x8(%eax),%eax
    810b:	83 ec 08             	sub    $0x8,%esp
    810e:	50                   	push   %eax
    810f:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    8112:	50                   	push   %eax
    8113:	e8 1c e8 ff ff       	call   6934 <hash_init>
    8118:	83 c4 10             	add    $0x10,%esp
    811b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    811e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8122:	0f 85 b7 00 00 00    	jne    81df <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    8128:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    812f:	e9 99 00 00 00       	jmp    81cd <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    8134:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8137:	83 e8 01             	sub    $0x1,%eax
    813a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    813d:	0f 94 c0             	sete   %al
    8140:	0f b6 c0             	movzbl %al,%eax
    8143:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    8146:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8149:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    814d:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    8150:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8153:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8156:	01 d0                	add    %edx,%eax
    8158:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    815b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    815e:	3b 45 10             	cmp    0x10(%ebp),%eax
    8161:	7e 06                	jle    8169 <lodepng_deflatev+0x110>
    8163:	8b 45 10             	mov    0x10(%ebp),%eax
    8166:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    8169:	8b 45 14             	mov    0x14(%ebp),%eax
    816c:	8b 00                	mov    (%eax),%eax
    816e:	83 f8 01             	cmp    $0x1,%eax
    8171:	75 27                	jne    819a <lodepng_deflatev+0x141>
    8173:	83 ec 04             	sub    $0x4,%esp
    8176:	ff 75 e0             	pushl  -0x20(%ebp)
    8179:	ff 75 14             	pushl  0x14(%ebp)
    817c:	ff 75 e4             	pushl  -0x1c(%ebp)
    817f:	ff 75 dc             	pushl  -0x24(%ebp)
    8182:	ff 75 0c             	pushl  0xc(%ebp)
    8185:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    8188:	50                   	push   %eax
    8189:	8d 45 bc             	lea    -0x44(%ebp),%eax
    818c:	50                   	push   %eax
    818d:	e8 07 fd ff ff       	call   7e99 <deflateFixed>
    8192:	83 c4 20             	add    $0x20,%esp
    8195:	89 45 f4             	mov    %eax,-0xc(%ebp)
    8198:	eb 2f                	jmp    81c9 <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    819a:	8b 45 14             	mov    0x14(%ebp),%eax
    819d:	8b 00                	mov    (%eax),%eax
    819f:	83 f8 02             	cmp    $0x2,%eax
    81a2:	75 25                	jne    81c9 <lodepng_deflatev+0x170>
    81a4:	83 ec 04             	sub    $0x4,%esp
    81a7:	ff 75 e0             	pushl  -0x20(%ebp)
    81aa:	ff 75 14             	pushl  0x14(%ebp)
    81ad:	ff 75 e4             	pushl  -0x1c(%ebp)
    81b0:	ff 75 dc             	pushl  -0x24(%ebp)
    81b3:	ff 75 0c             	pushl  0xc(%ebp)
    81b6:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    81b9:	50                   	push   %eax
    81ba:	8d 45 bc             	lea    -0x44(%ebp),%eax
    81bd:	50                   	push   %eax
    81be:	e8 7b f3 ff ff       	call   753e <deflateDynamic>
    81c3:	83 c4 20             	add    $0x20,%esp
    81c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    81c9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    81cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    81d0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    81d3:	74 0a                	je     81df <lodepng_deflatev+0x186>
    81d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    81d9:	0f 84 55 ff ff ff    	je     8134 <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    81df:	83 ec 0c             	sub    $0xc,%esp
    81e2:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    81e5:	50                   	push   %eax
    81e6:	e8 08 e9 ff ff       	call   6af3 <hash_cleanup>
    81eb:	83 c4 10             	add    $0x10,%esp

  return error;
    81ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    81f1:	c9                   	leave  
    81f2:	c3                   	ret    

000081f3 <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    81f3:	55                   	push   %ebp
    81f4:	89 e5                	mov    %esp,%ebp
    81f6:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    81f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    81fc:	8b 08                	mov    (%eax),%ecx
    81fe:	8b 45 08             	mov    0x8(%ebp),%eax
    8201:	8b 10                	mov    (%eax),%edx
    8203:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8206:	51                   	push   %ecx
    8207:	52                   	push   %edx
    8208:	50                   	push   %eax
    8209:	e8 f0 ba ff ff       	call   3cfe <ucvector_init>
    820e:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    8211:	ff 75 18             	pushl  0x18(%ebp)
    8214:	ff 75 14             	pushl  0x14(%ebp)
    8217:	ff 75 10             	pushl  0x10(%ebp)
    821a:	8d 45 e8             	lea    -0x18(%ebp),%eax
    821d:	50                   	push   %eax
    821e:	e8 36 fe ff ff       	call   8059 <lodepng_deflatev>
    8223:	83 c4 10             	add    $0x10,%esp
    8226:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    8229:	8b 55 e8             	mov    -0x18(%ebp),%edx
    822c:	8b 45 08             	mov    0x8(%ebp),%eax
    822f:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8231:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8234:	8b 45 0c             	mov    0xc(%ebp),%eax
    8237:	89 10                	mov    %edx,(%eax)
  return error;
    8239:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    823c:	c9                   	leave  
    823d:	c3                   	ret    

0000823e <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    823e:	55                   	push   %ebp
    823f:	89 e5                	mov    %esp,%ebp
    8241:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    8244:	8b 45 18             	mov    0x18(%ebp),%eax
    8247:	8b 40 1c             	mov    0x1c(%eax),%eax
    824a:	85 c0                	test   %eax,%eax
    824c:	74 34                	je     8282 <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    824e:	8b 45 18             	mov    0x18(%ebp),%eax
    8251:	8b 40 1c             	mov    0x1c(%eax),%eax
    8254:	83 ec 0c             	sub    $0xc,%esp
    8257:	ff 75 18             	pushl  0x18(%ebp)
    825a:	ff 75 14             	pushl  0x14(%ebp)
    825d:	ff 75 10             	pushl  0x10(%ebp)
    8260:	ff 75 0c             	pushl  0xc(%ebp)
    8263:	ff 75 08             	pushl  0x8(%ebp)
    8266:	ff d0                	call   *%eax
    8268:	83 c4 20             	add    $0x20,%esp
    826b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    826e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8272:	74 07                	je     827b <deflate+0x3d>
    8274:	b8 6f 00 00 00       	mov    $0x6f,%eax
    8279:	eb 21                	jmp    829c <deflate+0x5e>
    827b:	b8 00 00 00 00       	mov    $0x0,%eax
    8280:	eb 1a                	jmp    829c <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    8282:	83 ec 0c             	sub    $0xc,%esp
    8285:	ff 75 18             	pushl  0x18(%ebp)
    8288:	ff 75 14             	pushl  0x14(%ebp)
    828b:	ff 75 10             	pushl  0x10(%ebp)
    828e:	ff 75 0c             	pushl  0xc(%ebp)
    8291:	ff 75 08             	pushl  0x8(%ebp)
    8294:	e8 5a ff ff ff       	call   81f3 <lodepng_deflate>
    8299:	83 c4 20             	add    $0x20,%esp
  }
}
    829c:	c9                   	leave  
    829d:	c3                   	ret    

0000829e <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    829e:	55                   	push   %ebp
    829f:	89 e5                	mov    %esp,%ebp
    82a1:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    82a4:	8b 45 08             	mov    0x8(%ebp),%eax
    82a7:	0f b7 c0             	movzwl %ax,%eax
    82aa:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    82ad:	8b 45 08             	mov    0x8(%ebp),%eax
    82b0:	c1 e8 10             	shr    $0x10,%eax
    82b3:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    82b6:	e9 82 00 00 00       	jmp    833d <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    82bb:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    82c0:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    82c7:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    82cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    82ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
    82d1:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    82d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    82db:	eb 1c                	jmp    82f9 <update_adler32+0x5b>
      s1 += (*data++);
    82dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    82e0:	8d 50 01             	lea    0x1(%eax),%edx
    82e3:	89 55 0c             	mov    %edx,0xc(%ebp)
    82e6:	0f b6 00             	movzbl (%eax),%eax
    82e9:	0f b6 c0             	movzbl %al,%eax
    82ec:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    82ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
    82f2:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    82f5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    82f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    82fc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    82ff:	75 dc                	jne    82dd <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    8301:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    8304:	ba 71 80 07 80       	mov    $0x80078071,%edx
    8309:	89 c8                	mov    %ecx,%eax
    830b:	f7 e2                	mul    %edx
    830d:	89 d0                	mov    %edx,%eax
    830f:	c1 e8 0f             	shr    $0xf,%eax
    8312:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    8318:	29 c1                	sub    %eax,%ecx
    831a:	89 c8                	mov    %ecx,%eax
    831c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    831f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    8322:	ba 71 80 07 80       	mov    $0x80078071,%edx
    8327:	89 c8                	mov    %ecx,%eax
    8329:	f7 e2                	mul    %edx
    832b:	89 d0                	mov    %edx,%eax
    832d:	c1 e8 0f             	shr    $0xf,%eax
    8330:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    8336:	29 c1                	sub    %eax,%ecx
    8338:	89 c8                	mov    %ecx,%eax
    833a:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    833d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    8341:	0f 85 74 ff ff ff    	jne    82bb <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    8347:	8b 45 f8             	mov    -0x8(%ebp),%eax
    834a:	c1 e0 10             	shl    $0x10,%eax
    834d:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    8350:	c9                   	leave  
    8351:	c3                   	ret    

00008352 <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    8352:	55                   	push   %ebp
    8353:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    8355:	ff 75 0c             	pushl  0xc(%ebp)
    8358:	ff 75 08             	pushl  0x8(%ebp)
    835b:	6a 01                	push   $0x1
    835d:	e8 3c ff ff ff       	call   829e <update_adler32>
    8362:	83 c4 0c             	add    $0xc,%esp
}
    8365:	c9                   	leave  
    8366:	c3                   	ret    

00008367 <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    8367:	55                   	push   %ebp
    8368:	89 e5                	mov    %esp,%ebp
    836a:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    836d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    8374:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    8378:	7f 0a                	jg     8384 <lodepng_zlib_decompressv+0x1d>
    837a:	b8 35 00 00 00       	mov    $0x35,%eax
    837f:	e9 27 01 00 00       	jmp    84ab <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    8384:	8b 45 0c             	mov    0xc(%ebp),%eax
    8387:	0f b6 00             	movzbl (%eax),%eax
    838a:	0f b6 c0             	movzbl %al,%eax
    838d:	c1 e0 08             	shl    $0x8,%eax
    8390:	89 c2                	mov    %eax,%edx
    8392:	8b 45 0c             	mov    0xc(%ebp),%eax
    8395:	83 c0 01             	add    $0x1,%eax
    8398:	0f b6 00             	movzbl (%eax),%eax
    839b:	0f b6 c0             	movzbl %al,%eax
    839e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    83a1:	ba 43 08 21 84       	mov    $0x84210843,%edx
    83a6:	89 c8                	mov    %ecx,%eax
    83a8:	f7 ea                	imul   %edx
    83aa:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    83ad:	c1 f8 04             	sar    $0x4,%eax
    83b0:	89 c2                	mov    %eax,%edx
    83b2:	89 c8                	mov    %ecx,%eax
    83b4:	c1 f8 1f             	sar    $0x1f,%eax
    83b7:	29 c2                	sub    %eax,%edx
    83b9:	89 d0                	mov    %edx,%eax
    83bb:	89 c2                	mov    %eax,%edx
    83bd:	c1 e2 05             	shl    $0x5,%edx
    83c0:	29 c2                	sub    %eax,%edx
    83c2:	89 c8                	mov    %ecx,%eax
    83c4:	29 d0                	sub    %edx,%eax
    83c6:	85 c0                	test   %eax,%eax
    83c8:	74 0a                	je     83d4 <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    83ca:	b8 18 00 00 00       	mov    $0x18,%eax
    83cf:	e9 d7 00 00 00       	jmp    84ab <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    83d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    83d7:	0f b6 00             	movzbl (%eax),%eax
    83da:	0f b6 c0             	movzbl %al,%eax
    83dd:	83 e0 0f             	and    $0xf,%eax
    83e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    83e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    83e6:	0f b6 00             	movzbl (%eax),%eax
    83e9:	c0 e8 04             	shr    $0x4,%al
    83ec:	0f b6 c0             	movzbl %al,%eax
    83ef:	83 e0 0f             	and    $0xf,%eax
    83f2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    83f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    83f8:	83 c0 01             	add    $0x1,%eax
    83fb:	0f b6 00             	movzbl (%eax),%eax
    83fe:	c0 e8 05             	shr    $0x5,%al
    8401:	0f b6 c0             	movzbl %al,%eax
    8404:	83 e0 01             	and    $0x1,%eax
    8407:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    840a:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    840e:	75 06                	jne    8416 <lodepng_zlib_decompressv+0xaf>
    8410:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    8414:	76 0a                	jbe    8420 <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    8416:	b8 19 00 00 00       	mov    $0x19,%eax
    841b:	e9 8b 00 00 00       	jmp    84ab <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    8420:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    8424:	74 07                	je     842d <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    8426:	b8 1a 00 00 00       	mov    $0x1a,%eax
    842b:	eb 7e                	jmp    84ab <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    842d:	8b 45 10             	mov    0x10(%ebp),%eax
    8430:	8d 50 fe             	lea    -0x2(%eax),%edx
    8433:	8b 45 0c             	mov    0xc(%ebp),%eax
    8436:	83 c0 02             	add    $0x2,%eax
    8439:	ff 75 14             	pushl  0x14(%ebp)
    843c:	52                   	push   %edx
    843d:	50                   	push   %eax
    843e:	ff 75 08             	pushl  0x8(%ebp)
    8441:	e8 09 e3 ff ff       	call   674f <inflatev>
    8446:	83 c4 10             	add    $0x10,%esp
    8449:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    844c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8450:	74 05                	je     8457 <lodepng_zlib_decompressv+0xf0>
    8452:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8455:	eb 54                	jmp    84ab <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    8457:	8b 45 14             	mov    0x14(%ebp),%eax
    845a:	8b 00                	mov    (%eax),%eax
    845c:	85 c0                	test   %eax,%eax
    845e:	75 46                	jne    84a6 <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    8460:	8b 45 10             	mov    0x10(%ebp),%eax
    8463:	8d 50 fc             	lea    -0x4(%eax),%edx
    8466:	8b 45 0c             	mov    0xc(%ebp),%eax
    8469:	01 d0                	add    %edx,%eax
    846b:	83 ec 0c             	sub    $0xc,%esp
    846e:	50                   	push   %eax
    846f:	e8 47 b9 ff ff       	call   3dbb <lodepng_read32bitInt>
    8474:	83 c4 10             	add    $0x10,%esp
    8477:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    847a:	8b 45 08             	mov    0x8(%ebp),%eax
    847d:	8b 40 04             	mov    0x4(%eax),%eax
    8480:	89 c2                	mov    %eax,%edx
    8482:	8b 45 08             	mov    0x8(%ebp),%eax
    8485:	8b 00                	mov    (%eax),%eax
    8487:	83 ec 08             	sub    $0x8,%esp
    848a:	52                   	push   %edx
    848b:	50                   	push   %eax
    848c:	e8 c1 fe ff ff       	call   8352 <adler32>
    8491:	83 c4 10             	add    $0x10,%esp
    8494:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    8497:	8b 45 e0             	mov    -0x20(%ebp),%eax
    849a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    849d:	74 07                	je     84a6 <lodepng_zlib_decompressv+0x13f>
    849f:	b8 3a 00 00 00       	mov    $0x3a,%eax
    84a4:	eb 05                	jmp    84ab <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    84a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    84ab:	c9                   	leave  
    84ac:	c3                   	ret    

000084ad <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    84ad:	55                   	push   %ebp
    84ae:	89 e5                	mov    %esp,%ebp
    84b0:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    84b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    84b6:	8b 08                	mov    (%eax),%ecx
    84b8:	8b 45 08             	mov    0x8(%ebp),%eax
    84bb:	8b 10                	mov    (%eax),%edx
    84bd:	8d 45 e8             	lea    -0x18(%ebp),%eax
    84c0:	51                   	push   %ecx
    84c1:	52                   	push   %edx
    84c2:	50                   	push   %eax
    84c3:	e8 36 b8 ff ff       	call   3cfe <ucvector_init>
    84c8:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    84cb:	ff 75 18             	pushl  0x18(%ebp)
    84ce:	ff 75 14             	pushl  0x14(%ebp)
    84d1:	ff 75 10             	pushl  0x10(%ebp)
    84d4:	8d 45 e8             	lea    -0x18(%ebp),%eax
    84d7:	50                   	push   %eax
    84d8:	e8 8a fe ff ff       	call   8367 <lodepng_zlib_decompressv>
    84dd:	83 c4 10             	add    $0x10,%esp
    84e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    84e3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    84e6:	8b 45 08             	mov    0x8(%ebp),%eax
    84e9:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    84eb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    84ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    84f1:	89 10                	mov    %edx,(%eax)
  return error;
    84f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    84f6:	c9                   	leave  
    84f7:	c3                   	ret    

000084f8 <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    84f8:	55                   	push   %ebp
    84f9:	89 e5                	mov    %esp,%ebp
    84fb:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    84fe:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8501:	8b 40 0c             	mov    0xc(%eax),%eax
    8504:	85 c0                	test   %eax,%eax
    8506:	74 57                	je     855f <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    8508:	8b 45 1c             	mov    0x1c(%ebp),%eax
    850b:	8b 40 0c             	mov    0xc(%eax),%eax
    850e:	83 ec 0c             	sub    $0xc,%esp
    8511:	ff 75 1c             	pushl  0x1c(%ebp)
    8514:	ff 75 18             	pushl  0x18(%ebp)
    8517:	ff 75 14             	pushl  0x14(%ebp)
    851a:	ff 75 0c             	pushl  0xc(%ebp)
    851d:	ff 75 08             	pushl  0x8(%ebp)
    8520:	ff d0                	call   *%eax
    8522:	83 c4 20             	add    $0x20,%esp
    8525:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    8528:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    852c:	0f 84 98 00 00 00    	je     85ca <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    8532:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    8539:	8b 45 1c             	mov    0x1c(%ebp),%eax
    853c:	8b 40 08             	mov    0x8(%eax),%eax
    853f:	85 c0                	test   %eax,%eax
    8541:	0f 84 83 00 00 00    	je     85ca <zlib_decompress+0xd2>
    8547:	8b 45 0c             	mov    0xc(%ebp),%eax
    854a:	8b 10                	mov    (%eax),%edx
    854c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    854f:	8b 40 08             	mov    0x8(%eax),%eax
    8552:	39 c2                	cmp    %eax,%edx
    8554:	7e 74                	jle    85ca <zlib_decompress+0xd2>
    8556:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    855d:	eb 6b                	jmp    85ca <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    855f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8562:	8b 08                	mov    (%eax),%ecx
    8564:	8b 45 08             	mov    0x8(%ebp),%eax
    8567:	8b 10                	mov    (%eax),%edx
    8569:	8d 45 e8             	lea    -0x18(%ebp),%eax
    856c:	83 ec 04             	sub    $0x4,%esp
    856f:	51                   	push   %ecx
    8570:	52                   	push   %edx
    8571:	50                   	push   %eax
    8572:	e8 87 b7 ff ff       	call   3cfe <ucvector_init>
    8577:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    857a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    857e:	74 22                	je     85a2 <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    8580:	8b 45 0c             	mov    0xc(%ebp),%eax
    8583:	8b 10                	mov    (%eax),%edx
    8585:	8b 45 10             	mov    0x10(%ebp),%eax
    8588:	01 d0                	add    %edx,%eax
    858a:	83 ec 08             	sub    $0x8,%esp
    858d:	50                   	push   %eax
    858e:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8591:	50                   	push   %eax
    8592:	e8 00 b7 ff ff       	call   3c97 <ucvector_resize>
    8597:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    859a:	8b 45 0c             	mov    0xc(%ebp),%eax
    859d:	8b 00                	mov    (%eax),%eax
    859f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    85a2:	ff 75 1c             	pushl  0x1c(%ebp)
    85a5:	ff 75 18             	pushl  0x18(%ebp)
    85a8:	ff 75 14             	pushl  0x14(%ebp)
    85ab:	8d 45 e8             	lea    -0x18(%ebp),%eax
    85ae:	50                   	push   %eax
    85af:	e8 b3 fd ff ff       	call   8367 <lodepng_zlib_decompressv>
    85b4:	83 c4 10             	add    $0x10,%esp
    85b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    85ba:	8b 55 e8             	mov    -0x18(%ebp),%edx
    85bd:	8b 45 08             	mov    0x8(%ebp),%eax
    85c0:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    85c2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    85c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    85c8:	89 10                	mov    %edx,(%eax)
  }
  return error;
    85ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    85cd:	c9                   	leave  
    85ce:	c3                   	ret    

000085cf <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    85cf:	55                   	push   %ebp
    85d0:	89 e5                	mov    %esp,%ebp
    85d2:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    85d5:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    85dc:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    85e3:	83 ec 0c             	sub    $0xc,%esp
    85e6:	ff 75 18             	pushl  0x18(%ebp)
    85e9:	ff 75 14             	pushl  0x14(%ebp)
    85ec:	ff 75 10             	pushl  0x10(%ebp)
    85ef:	8d 45 d0             	lea    -0x30(%ebp),%eax
    85f2:	50                   	push   %eax
    85f3:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    85f6:	50                   	push   %eax
    85f7:	e8 42 fc ff ff       	call   823e <deflate>
    85fc:	83 c4 20             	add    $0x20,%esp
    85ff:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    8602:	8b 45 08             	mov    0x8(%ebp),%eax
    8605:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    860b:	8b 45 0c             	mov    0xc(%ebp),%eax
    860e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    8614:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    8618:	75 33                	jne    864d <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    861a:	8b 45 d0             	mov    -0x30(%ebp),%eax
    861d:	8d 50 06             	lea    0x6(%eax),%edx
    8620:	8b 45 0c             	mov    0xc(%ebp),%eax
    8623:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    8625:	8b 45 0c             	mov    0xc(%ebp),%eax
    8628:	8b 00                	mov    (%eax),%eax
    862a:	83 ec 0c             	sub    $0xc,%esp
    862d:	50                   	push   %eax
    862e:	e8 0a b4 ff ff       	call   3a3d <lodepng_malloc>
    8633:	83 c4 10             	add    $0x10,%esp
    8636:	89 c2                	mov    %eax,%edx
    8638:	8b 45 08             	mov    0x8(%ebp),%eax
    863b:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    863d:	8b 45 08             	mov    0x8(%ebp),%eax
    8640:	8b 00                	mov    (%eax),%eax
    8642:	85 c0                	test   %eax,%eax
    8644:	75 07                	jne    864d <lodepng_zlib_compress+0x7e>
    8646:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    864d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    8651:	0f 85 e2 00 00 00    	jne    8739 <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    8657:	8b 45 14             	mov    0x14(%ebp),%eax
    865a:	83 ec 08             	sub    $0x8,%esp
    865d:	50                   	push   %eax
    865e:	ff 75 10             	pushl  0x10(%ebp)
    8661:	e8 ec fc ff ff       	call   8352 <adler32>
    8666:	83 c4 10             	add    $0x10,%esp
    8669:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    866c:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    8673:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    867a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    8681:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8684:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    868b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    868e:	01 d0                	add    %edx,%eax
    8690:	8d 14 00             	lea    (%eax,%eax,1),%edx
    8693:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8696:	01 d0                	add    %edx,%eax
    8698:	c1 e0 05             	shl    $0x5,%eax
    869b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    869e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    86a1:	ba 85 10 42 08       	mov    $0x8421085,%edx
    86a6:	89 c8                	mov    %ecx,%eax
    86a8:	f7 e2                	mul    %edx
    86aa:	89 c8                	mov    %ecx,%eax
    86ac:	29 d0                	sub    %edx,%eax
    86ae:	d1 e8                	shr    %eax
    86b0:	01 d0                	add    %edx,%eax
    86b2:	c1 e8 04             	shr    $0x4,%eax
    86b5:	89 c2                	mov    %eax,%edx
    86b7:	c1 e2 05             	shl    $0x5,%edx
    86ba:	29 c2                	sub    %eax,%edx
    86bc:	89 c8                	mov    %ecx,%eax
    86be:	29 d0                	sub    %edx,%eax
    86c0:	ba 1f 00 00 00       	mov    $0x1f,%edx
    86c5:	29 c2                	sub    %eax,%edx
    86c7:	89 d0                	mov    %edx,%eax
    86c9:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    86cc:	8b 45 d8             	mov    -0x28(%ebp),%eax
    86cf:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    86d2:	8b 45 08             	mov    0x8(%ebp),%eax
    86d5:	8b 00                	mov    (%eax),%eax
    86d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
    86da:	c1 ea 08             	shr    $0x8,%edx
    86dd:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    86df:	8b 45 08             	mov    0x8(%ebp),%eax
    86e2:	8b 00                	mov    (%eax),%eax
    86e4:	83 c0 01             	add    $0x1,%eax
    86e7:	8b 55 dc             	mov    -0x24(%ebp),%edx
    86ea:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    86ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    86f3:	eb 1e                	jmp    8713 <lodepng_zlib_compress+0x144>
    86f5:	8b 45 08             	mov    0x8(%ebp),%eax
    86f8:	8b 00                	mov    (%eax),%eax
    86fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
    86fd:	83 c2 02             	add    $0x2,%edx
    8700:	01 c2                	add    %eax,%edx
    8702:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    8705:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8708:	01 c8                	add    %ecx,%eax
    870a:	0f b6 00             	movzbl (%eax),%eax
    870d:	88 02                	mov    %al,(%edx)
    870f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8713:	8b 45 d0             	mov    -0x30(%ebp),%eax
    8716:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    8719:	75 da                	jne    86f5 <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    871b:	8b 45 08             	mov    0x8(%ebp),%eax
    871e:	8b 10                	mov    (%eax),%edx
    8720:	8b 45 0c             	mov    0xc(%ebp),%eax
    8723:	8b 00                	mov    (%eax),%eax
    8725:	83 e8 04             	sub    $0x4,%eax
    8728:	01 d0                	add    %edx,%eax
    872a:	83 ec 08             	sub    $0x8,%esp
    872d:	ff 75 ec             	pushl  -0x14(%ebp)
    8730:	50                   	push   %eax
    8731:	e8 c8 b6 ff ff       	call   3dfe <lodepng_set32bitInt>
    8736:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    8739:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    873c:	83 ec 0c             	sub    $0xc,%esp
    873f:	50                   	push   %eax
    8740:	e8 19 b3 ff ff       	call   3a5e <lodepng_free>
    8745:	83 c4 10             	add    $0x10,%esp
  return error;
    8748:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    874b:	c9                   	leave  
    874c:	c3                   	ret    

0000874d <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    874d:	55                   	push   %ebp
    874e:	89 e5                	mov    %esp,%ebp
    8750:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    8753:	8b 45 18             	mov    0x18(%ebp),%eax
    8756:	8b 40 18             	mov    0x18(%eax),%eax
    8759:	85 c0                	test   %eax,%eax
    875b:	74 34                	je     8791 <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    875d:	8b 45 18             	mov    0x18(%ebp),%eax
    8760:	8b 40 18             	mov    0x18(%eax),%eax
    8763:	83 ec 0c             	sub    $0xc,%esp
    8766:	ff 75 18             	pushl  0x18(%ebp)
    8769:	ff 75 14             	pushl  0x14(%ebp)
    876c:	ff 75 10             	pushl  0x10(%ebp)
    876f:	ff 75 0c             	pushl  0xc(%ebp)
    8772:	ff 75 08             	pushl  0x8(%ebp)
    8775:	ff d0                	call   *%eax
    8777:	83 c4 20             	add    $0x20,%esp
    877a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    877d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8781:	74 07                	je     878a <zlib_compress+0x3d>
    8783:	b8 6f 00 00 00       	mov    $0x6f,%eax
    8788:	eb 21                	jmp    87ab <zlib_compress+0x5e>
    878a:	b8 00 00 00 00       	mov    $0x0,%eax
    878f:	eb 1a                	jmp    87ab <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    8791:	83 ec 0c             	sub    $0xc,%esp
    8794:	ff 75 18             	pushl  0x18(%ebp)
    8797:	ff 75 14             	pushl  0x14(%ebp)
    879a:	ff 75 10             	pushl  0x10(%ebp)
    879d:	ff 75 0c             	pushl  0xc(%ebp)
    87a0:	ff 75 08             	pushl  0x8(%ebp)
    87a3:	e8 27 fe ff ff       	call   85cf <lodepng_zlib_compress>
    87a8:	83 c4 20             	add    $0x20,%esp
  }
}
    87ab:	c9                   	leave  
    87ac:	c3                   	ret    

000087ad <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    87ad:	55                   	push   %ebp
    87ae:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    87b0:	8b 45 08             	mov    0x8(%ebp),%eax
    87b3:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    87b9:	8b 45 08             	mov    0x8(%ebp),%eax
    87bc:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    87c3:	8b 45 08             	mov    0x8(%ebp),%eax
    87c6:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    87cd:	8b 45 08             	mov    0x8(%ebp),%eax
    87d0:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    87d7:	8b 45 08             	mov    0x8(%ebp),%eax
    87da:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    87e1:	8b 45 08             	mov    0x8(%ebp),%eax
    87e4:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    87eb:	8b 45 08             	mov    0x8(%ebp),%eax
    87ee:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    87f5:	8b 45 08             	mov    0x8(%ebp),%eax
    87f8:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    87ff:	8b 45 08             	mov    0x8(%ebp),%eax
    8802:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    8809:	90                   	nop
    880a:	5d                   	pop    %ebp
    880b:	c3                   	ret    

0000880c <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    880c:	55                   	push   %ebp
    880d:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    880f:	8b 45 08             	mov    0x8(%ebp),%eax
    8812:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    8818:	8b 45 08             	mov    0x8(%ebp),%eax
    881b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    8822:	8b 45 08             	mov    0x8(%ebp),%eax
    8825:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    882c:	8b 45 08             	mov    0x8(%ebp),%eax
    882f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    8836:	8b 45 08             	mov    0x8(%ebp),%eax
    8839:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    8840:	8b 45 08             	mov    0x8(%ebp),%eax
    8843:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    884a:	90                   	nop
    884b:	5d                   	pop    %ebp
    884c:	c3                   	ret    

0000884d <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    884d:	55                   	push   %ebp
    884e:	89 e5                	mov    %esp,%ebp
    8850:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    8853:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    885a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8861:	eb 2a                	jmp    888d <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    8863:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8866:	8b 45 08             	mov    0x8(%ebp),%eax
    8869:	01 d0                	add    %edx,%eax
    886b:	0f b6 00             	movzbl (%eax),%eax
    886e:	0f b6 c0             	movzbl %al,%eax
    8871:	33 45 fc             	xor    -0x4(%ebp),%eax
    8874:	0f b6 c0             	movzbl %al,%eax
    8877:	8b 04 85 a0 e8 01 00 	mov    0x1e8a0(,%eax,4),%eax
    887e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8881:	c1 ea 08             	shr    $0x8,%edx
    8884:	31 d0                	xor    %edx,%eax
    8886:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    8889:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    888d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8890:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8893:	7c ce                	jl     8863 <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    8895:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8898:	f7 d0                	not    %eax
}
    889a:	c9                   	leave  
    889b:	c3                   	ret    

0000889c <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    889c:	55                   	push   %ebp
    889d:	89 e5                	mov    %esp,%ebp
    889f:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    88a2:	8b 45 08             	mov    0x8(%ebp),%eax
    88a5:	8b 00                	mov    (%eax),%eax
    88a7:	c1 f8 03             	sar    $0x3,%eax
    88aa:	89 c2                	mov    %eax,%edx
    88ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    88af:	01 d0                	add    %edx,%eax
    88b1:	0f b6 00             	movzbl (%eax),%eax
    88b4:	0f b6 d0             	movzbl %al,%edx
    88b7:	8b 45 08             	mov    0x8(%ebp),%eax
    88ba:	8b 00                	mov    (%eax),%eax
    88bc:	f7 d0                	not    %eax
    88be:	83 e0 07             	and    $0x7,%eax
    88c1:	89 c1                	mov    %eax,%ecx
    88c3:	d3 fa                	sar    %cl,%edx
    88c5:	89 d0                	mov    %edx,%eax
    88c7:	83 e0 01             	and    $0x1,%eax
    88ca:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    88cd:	8b 45 08             	mov    0x8(%ebp),%eax
    88d0:	8b 00                	mov    (%eax),%eax
    88d2:	8d 50 01             	lea    0x1(%eax),%edx
    88d5:	8b 45 08             	mov    0x8(%ebp),%eax
    88d8:	89 10                	mov    %edx,(%eax)
  return result;
    88da:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    88de:	c9                   	leave  
    88df:	c3                   	ret    

000088e0 <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    88e0:	55                   	push   %ebp
    88e1:	89 e5                	mov    %esp,%ebp
    88e3:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    88e6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    88ed:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    88f4:	eb 1b                	jmp    8911 <readBitsFromReversedStream+0x31>
    result <<= 1u;
    88f6:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    88f9:	ff 75 0c             	pushl  0xc(%ebp)
    88fc:	ff 75 08             	pushl  0x8(%ebp)
    88ff:	e8 98 ff ff ff       	call   889c <readBitFromReversedStream>
    8904:	83 c4 08             	add    $0x8,%esp
    8907:	0f b6 c0             	movzbl %al,%eax
    890a:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    890d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8911:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8914:	3b 45 10             	cmp    0x10(%ebp),%eax
    8917:	7c dd                	jl     88f6 <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    8919:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    891c:	c9                   	leave  
    891d:	c3                   	ret    

0000891e <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    891e:	55                   	push   %ebp
    891f:	89 e5                	mov    %esp,%ebp
    8921:	56                   	push   %esi
    8922:	53                   	push   %ebx
    8923:	83 ec 04             	sub    $0x4,%esp
    8926:	8b 45 10             	mov    0x10(%ebp),%eax
    8929:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    892c:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    8930:	75 3e                	jne    8970 <setBitOfReversedStream+0x52>
    8932:	8b 45 08             	mov    0x8(%ebp),%eax
    8935:	8b 00                	mov    (%eax),%eax
    8937:	c1 f8 03             	sar    $0x3,%eax
    893a:	89 c2                	mov    %eax,%edx
    893c:	8b 45 0c             	mov    0xc(%ebp),%eax
    893f:	01 c2                	add    %eax,%edx
    8941:	8b 45 08             	mov    0x8(%ebp),%eax
    8944:	8b 00                	mov    (%eax),%eax
    8946:	c1 f8 03             	sar    $0x3,%eax
    8949:	89 c1                	mov    %eax,%ecx
    894b:	8b 45 0c             	mov    0xc(%ebp),%eax
    894e:	01 c8                	add    %ecx,%eax
    8950:	0f b6 18             	movzbl (%eax),%ebx
    8953:	8b 45 08             	mov    0x8(%ebp),%eax
    8956:	8b 00                	mov    (%eax),%eax
    8958:	f7 d0                	not    %eax
    895a:	83 e0 07             	and    $0x7,%eax
    895d:	be 01 00 00 00       	mov    $0x1,%esi
    8962:	89 c1                	mov    %eax,%ecx
    8964:	d3 e6                	shl    %cl,%esi
    8966:	89 f0                	mov    %esi,%eax
    8968:	f7 d0                	not    %eax
    896a:	21 d8                	and    %ebx,%eax
    896c:	88 02                	mov    %al,(%edx)
    896e:	eb 3a                	jmp    89aa <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    8970:	8b 45 08             	mov    0x8(%ebp),%eax
    8973:	8b 00                	mov    (%eax),%eax
    8975:	c1 f8 03             	sar    $0x3,%eax
    8978:	89 c2                	mov    %eax,%edx
    897a:	8b 45 0c             	mov    0xc(%ebp),%eax
    897d:	01 c2                	add    %eax,%edx
    897f:	8b 45 08             	mov    0x8(%ebp),%eax
    8982:	8b 00                	mov    (%eax),%eax
    8984:	c1 f8 03             	sar    $0x3,%eax
    8987:	89 c1                	mov    %eax,%ecx
    8989:	8b 45 0c             	mov    0xc(%ebp),%eax
    898c:	01 c8                	add    %ecx,%eax
    898e:	0f b6 18             	movzbl (%eax),%ebx
    8991:	8b 45 08             	mov    0x8(%ebp),%eax
    8994:	8b 00                	mov    (%eax),%eax
    8996:	f7 d0                	not    %eax
    8998:	83 e0 07             	and    $0x7,%eax
    899b:	be 01 00 00 00       	mov    $0x1,%esi
    89a0:	89 c1                	mov    %eax,%ecx
    89a2:	d3 e6                	shl    %cl,%esi
    89a4:	89 f0                	mov    %esi,%eax
    89a6:	09 d8                	or     %ebx,%eax
    89a8:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    89aa:	8b 45 08             	mov    0x8(%ebp),%eax
    89ad:	8b 00                	mov    (%eax),%eax
    89af:	8d 50 01             	lea    0x1(%eax),%edx
    89b2:	8b 45 08             	mov    0x8(%ebp),%eax
    89b5:	89 10                	mov    %edx,(%eax)
}
    89b7:	90                   	nop
    89b8:	83 c4 04             	add    $0x4,%esp
    89bb:	5b                   	pop    %ebx
    89bc:	5e                   	pop    %esi
    89bd:	5d                   	pop    %ebp
    89be:	c3                   	ret    

000089bf <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    89bf:	55                   	push   %ebp
    89c0:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    89c2:	ff 75 08             	pushl  0x8(%ebp)
    89c5:	e8 f1 b3 ff ff       	call   3dbb <lodepng_read32bitInt>
    89ca:	83 c4 04             	add    $0x4,%esp
}
    89cd:	c9                   	leave  
    89ce:	c3                   	ret    

000089cf <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    89cf:	55                   	push   %ebp
    89d0:	89 e5                	mov    %esp,%ebp
    89d2:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    89d5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    89dc:	eb 1c                	jmp    89fa <lodepng_chunk_type+0x2b>
    89de:	8b 55 08             	mov    0x8(%ebp),%edx
    89e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    89e4:	01 d0                	add    %edx,%eax
    89e6:	8b 55 fc             	mov    -0x4(%ebp),%edx
    89e9:	8d 4a 04             	lea    0x4(%edx),%ecx
    89ec:	8b 55 0c             	mov    0xc(%ebp),%edx
    89ef:	01 ca                	add    %ecx,%edx
    89f1:	0f b6 12             	movzbl (%edx),%edx
    89f4:	88 10                	mov    %dl,(%eax)
    89f6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    89fa:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    89fe:	75 de                	jne    89de <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    8a00:	8b 45 08             	mov    0x8(%ebp),%eax
    8a03:	83 c0 04             	add    $0x4,%eax
    8a06:	c6 00 00             	movb   $0x0,(%eax)
}
    8a09:	90                   	nop
    8a0a:	c9                   	leave  
    8a0b:	c3                   	ret    

00008a0c <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    8a0c:	55                   	push   %ebp
    8a0d:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    8a0f:	ff 75 0c             	pushl  0xc(%ebp)
    8a12:	e8 c2 b0 ff ff       	call   3ad9 <lodepng_strlen>
    8a17:	83 c4 04             	add    $0x4,%esp
    8a1a:	83 f8 04             	cmp    $0x4,%eax
    8a1d:	74 07                	je     8a26 <lodepng_chunk_type_equals+0x1a>
    8a1f:	b8 00 00 00 00       	mov    $0x0,%eax
    8a24:	eb 79                	jmp    8a9f <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    8a26:	8b 45 08             	mov    0x8(%ebp),%eax
    8a29:	83 c0 04             	add    $0x4,%eax
    8a2c:	0f b6 00             	movzbl (%eax),%eax
    8a2f:	0f b6 d0             	movzbl %al,%edx
    8a32:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a35:	0f b6 00             	movzbl (%eax),%eax
    8a38:	0f be c0             	movsbl %al,%eax
    8a3b:	39 c2                	cmp    %eax,%edx
    8a3d:	75 5b                	jne    8a9a <lodepng_chunk_type_equals+0x8e>
    8a3f:	8b 45 08             	mov    0x8(%ebp),%eax
    8a42:	83 c0 05             	add    $0x5,%eax
    8a45:	0f b6 00             	movzbl (%eax),%eax
    8a48:	0f b6 d0             	movzbl %al,%edx
    8a4b:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a4e:	83 c0 01             	add    $0x1,%eax
    8a51:	0f b6 00             	movzbl (%eax),%eax
    8a54:	0f be c0             	movsbl %al,%eax
    8a57:	39 c2                	cmp    %eax,%edx
    8a59:	75 3f                	jne    8a9a <lodepng_chunk_type_equals+0x8e>
    8a5b:	8b 45 08             	mov    0x8(%ebp),%eax
    8a5e:	83 c0 06             	add    $0x6,%eax
    8a61:	0f b6 00             	movzbl (%eax),%eax
    8a64:	0f b6 d0             	movzbl %al,%edx
    8a67:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a6a:	83 c0 02             	add    $0x2,%eax
    8a6d:	0f b6 00             	movzbl (%eax),%eax
    8a70:	0f be c0             	movsbl %al,%eax
    8a73:	39 c2                	cmp    %eax,%edx
    8a75:	75 23                	jne    8a9a <lodepng_chunk_type_equals+0x8e>
    8a77:	8b 45 08             	mov    0x8(%ebp),%eax
    8a7a:	83 c0 07             	add    $0x7,%eax
    8a7d:	0f b6 00             	movzbl (%eax),%eax
    8a80:	0f b6 d0             	movzbl %al,%edx
    8a83:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a86:	83 c0 03             	add    $0x3,%eax
    8a89:	0f b6 00             	movzbl (%eax),%eax
    8a8c:	0f be c0             	movsbl %al,%eax
    8a8f:	39 c2                	cmp    %eax,%edx
    8a91:	75 07                	jne    8a9a <lodepng_chunk_type_equals+0x8e>
    8a93:	b8 01 00 00 00       	mov    $0x1,%eax
    8a98:	eb 05                	jmp    8a9f <lodepng_chunk_type_equals+0x93>
    8a9a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8a9f:	c9                   	leave  
    8aa0:	c3                   	ret    

00008aa1 <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    8aa1:	55                   	push   %ebp
    8aa2:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    8aa4:	8b 45 08             	mov    0x8(%ebp),%eax
    8aa7:	83 c0 04             	add    $0x4,%eax
    8aaa:	0f b6 00             	movzbl (%eax),%eax
    8aad:	0f b6 c0             	movzbl %al,%eax
    8ab0:	83 e0 20             	and    $0x20,%eax
    8ab3:	85 c0                	test   %eax,%eax
    8ab5:	0f 95 c0             	setne  %al
}
    8ab8:	5d                   	pop    %ebp
    8ab9:	c3                   	ret    

00008aba <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    8aba:	55                   	push   %ebp
    8abb:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    8abd:	8b 45 08             	mov    0x8(%ebp),%eax
    8ac0:	83 c0 06             	add    $0x6,%eax
    8ac3:	0f b6 00             	movzbl (%eax),%eax
    8ac6:	0f b6 c0             	movzbl %al,%eax
    8ac9:	83 e0 20             	and    $0x20,%eax
    8acc:	85 c0                	test   %eax,%eax
    8ace:	0f 95 c0             	setne  %al
}
    8ad1:	5d                   	pop    %ebp
    8ad2:	c3                   	ret    

00008ad3 <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    8ad3:	55                   	push   %ebp
    8ad4:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    8ad6:	8b 45 08             	mov    0x8(%ebp),%eax
    8ad9:	83 c0 07             	add    $0x7,%eax
    8adc:	0f b6 00             	movzbl (%eax),%eax
    8adf:	0f b6 c0             	movzbl %al,%eax
    8ae2:	83 e0 20             	and    $0x20,%eax
    8ae5:	85 c0                	test   %eax,%eax
    8ae7:	0f 95 c0             	setne  %al
}
    8aea:	5d                   	pop    %ebp
    8aeb:	c3                   	ret    

00008aec <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    8aec:	55                   	push   %ebp
    8aed:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    8aef:	8b 45 08             	mov    0x8(%ebp),%eax
    8af2:	83 c0 08             	add    $0x8,%eax
}
    8af5:	5d                   	pop    %ebp
    8af6:	c3                   	ret    

00008af7 <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    8af7:	55                   	push   %ebp
    8af8:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    8afa:	8b 45 08             	mov    0x8(%ebp),%eax
    8afd:	83 c0 08             	add    $0x8,%eax
}
    8b00:	5d                   	pop    %ebp
    8b01:	c3                   	ret    

00008b02 <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    8b02:	55                   	push   %ebp
    8b03:	89 e5                	mov    %esp,%ebp
    8b05:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    8b08:	ff 75 08             	pushl  0x8(%ebp)
    8b0b:	e8 af fe ff ff       	call   89bf <lodepng_chunk_length>
    8b10:	83 c4 04             	add    $0x4,%esp
    8b13:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    8b16:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8b19:	8d 50 08             	lea    0x8(%eax),%edx
    8b1c:	8b 45 08             	mov    0x8(%ebp),%eax
    8b1f:	01 d0                	add    %edx,%eax
    8b21:	50                   	push   %eax
    8b22:	e8 94 b2 ff ff       	call   3dbb <lodepng_read32bitInt>
    8b27:	83 c4 04             	add    $0x4,%esp
    8b2a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    8b2d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8b30:	83 c0 04             	add    $0x4,%eax
    8b33:	89 c2                	mov    %eax,%edx
    8b35:	8b 45 08             	mov    0x8(%ebp),%eax
    8b38:	83 c0 04             	add    $0x4,%eax
    8b3b:	52                   	push   %edx
    8b3c:	50                   	push   %eax
    8b3d:	e8 0b fd ff ff       	call   884d <lodepng_crc32>
    8b42:	83 c4 08             	add    $0x8,%esp
    8b45:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    8b48:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8b4b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    8b4e:	74 07                	je     8b57 <lodepng_chunk_check_crc+0x55>
    8b50:	b8 01 00 00 00       	mov    $0x1,%eax
    8b55:	eb 05                	jmp    8b5c <lodepng_chunk_check_crc+0x5a>
  else return 0;
    8b57:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8b5c:	c9                   	leave  
    8b5d:	c3                   	ret    

00008b5e <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    8b5e:	55                   	push   %ebp
    8b5f:	89 e5                	mov    %esp,%ebp
    8b61:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    8b64:	ff 75 08             	pushl  0x8(%ebp)
    8b67:	e8 53 fe ff ff       	call   89bf <lodepng_chunk_length>
    8b6c:	83 c4 04             	add    $0x4,%esp
    8b6f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    8b72:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8b75:	83 c0 04             	add    $0x4,%eax
    8b78:	89 c2                	mov    %eax,%edx
    8b7a:	8b 45 08             	mov    0x8(%ebp),%eax
    8b7d:	83 c0 04             	add    $0x4,%eax
    8b80:	52                   	push   %edx
    8b81:	50                   	push   %eax
    8b82:	e8 c6 fc ff ff       	call   884d <lodepng_crc32>
    8b87:	83 c4 08             	add    $0x8,%esp
    8b8a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    8b8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8b90:	8d 50 08             	lea    0x8(%eax),%edx
    8b93:	8b 45 08             	mov    0x8(%ebp),%eax
    8b96:	01 d0                	add    %edx,%eax
    8b98:	ff 75 f8             	pushl  -0x8(%ebp)
    8b9b:	50                   	push   %eax
    8b9c:	e8 5d b2 ff ff       	call   3dfe <lodepng_set32bitInt>
    8ba1:	83 c4 08             	add    $0x8,%esp
}
    8ba4:	90                   	nop
    8ba5:	c9                   	leave  
    8ba6:	c3                   	ret    

00008ba7 <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    8ba7:	55                   	push   %ebp
    8ba8:	89 e5                	mov    %esp,%ebp
    8baa:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8bad:	8b 45 08             	mov    0x8(%ebp),%eax
    8bb0:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8bb3:	73 0f                	jae    8bc4 <lodepng_chunk_next+0x1d>
    8bb5:	8b 55 0c             	mov    0xc(%ebp),%edx
    8bb8:	8b 45 08             	mov    0x8(%ebp),%eax
    8bbb:	29 c2                	sub    %eax,%edx
    8bbd:	89 d0                	mov    %edx,%eax
    8bbf:	83 f8 0b             	cmp    $0xb,%eax
    8bc2:	7f 08                	jg     8bcc <lodepng_chunk_next+0x25>
    8bc4:	8b 45 0c             	mov    0xc(%ebp),%eax
    8bc7:	e9 af 00 00 00       	jmp    8c7b <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8bcc:	8b 45 08             	mov    0x8(%ebp),%eax
    8bcf:	0f b6 00             	movzbl (%eax),%eax
    8bd2:	3c 89                	cmp    $0x89,%al
    8bd4:	75 63                	jne    8c39 <lodepng_chunk_next+0x92>
    8bd6:	8b 45 08             	mov    0x8(%ebp),%eax
    8bd9:	83 c0 01             	add    $0x1,%eax
    8bdc:	0f b6 00             	movzbl (%eax),%eax
    8bdf:	3c 50                	cmp    $0x50,%al
    8be1:	75 56                	jne    8c39 <lodepng_chunk_next+0x92>
    8be3:	8b 45 08             	mov    0x8(%ebp),%eax
    8be6:	83 c0 02             	add    $0x2,%eax
    8be9:	0f b6 00             	movzbl (%eax),%eax
    8bec:	3c 4e                	cmp    $0x4e,%al
    8bee:	75 49                	jne    8c39 <lodepng_chunk_next+0x92>
    8bf0:	8b 45 08             	mov    0x8(%ebp),%eax
    8bf3:	83 c0 03             	add    $0x3,%eax
    8bf6:	0f b6 00             	movzbl (%eax),%eax
    8bf9:	3c 47                	cmp    $0x47,%al
    8bfb:	75 3c                	jne    8c39 <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    8bfd:	8b 45 08             	mov    0x8(%ebp),%eax
    8c00:	83 c0 04             	add    $0x4,%eax
    8c03:	0f b6 00             	movzbl (%eax),%eax
    8c06:	3c 0d                	cmp    $0xd,%al
    8c08:	75 2f                	jne    8c39 <lodepng_chunk_next+0x92>
    8c0a:	8b 45 08             	mov    0x8(%ebp),%eax
    8c0d:	83 c0 05             	add    $0x5,%eax
    8c10:	0f b6 00             	movzbl (%eax),%eax
    8c13:	3c 0a                	cmp    $0xa,%al
    8c15:	75 22                	jne    8c39 <lodepng_chunk_next+0x92>
    8c17:	8b 45 08             	mov    0x8(%ebp),%eax
    8c1a:	83 c0 06             	add    $0x6,%eax
    8c1d:	0f b6 00             	movzbl (%eax),%eax
    8c20:	3c 1a                	cmp    $0x1a,%al
    8c22:	75 15                	jne    8c39 <lodepng_chunk_next+0x92>
    8c24:	8b 45 08             	mov    0x8(%ebp),%eax
    8c27:	83 c0 07             	add    $0x7,%eax
    8c2a:	0f b6 00             	movzbl (%eax),%eax
    8c2d:	3c 0a                	cmp    $0xa,%al
    8c2f:	75 08                	jne    8c39 <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    8c31:	8b 45 08             	mov    0x8(%ebp),%eax
    8c34:	83 c0 08             	add    $0x8,%eax
    8c37:	eb 42                	jmp    8c7b <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    8c39:	ff 75 08             	pushl  0x8(%ebp)
    8c3c:	e8 7e fd ff ff       	call   89bf <lodepng_chunk_length>
    8c41:	83 c4 04             	add    $0x4,%esp
    8c44:	89 c2                	mov    %eax,%edx
    8c46:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8c49:	50                   	push   %eax
    8c4a:	6a 0c                	push   $0xc
    8c4c:	52                   	push   %edx
    8c4d:	e8 af ae ff ff       	call   3b01 <lodepng_addofl>
    8c52:	83 c4 0c             	add    $0xc,%esp
    8c55:	85 c0                	test   %eax,%eax
    8c57:	74 05                	je     8c5e <lodepng_chunk_next+0xb7>
    8c59:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c5c:	eb 1d                	jmp    8c7b <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    8c5e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8c61:	89 c2                	mov    %eax,%edx
    8c63:	8b 45 08             	mov    0x8(%ebp),%eax
    8c66:	01 d0                	add    %edx,%eax
    8c68:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8c6b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8c6e:	3b 45 08             	cmp    0x8(%ebp),%eax
    8c71:	73 05                	jae    8c78 <lodepng_chunk_next+0xd1>
    8c73:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c76:	eb 03                	jmp    8c7b <lodepng_chunk_next+0xd4>
    return result;
    8c78:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8c7b:	c9                   	leave  
    8c7c:	c3                   	ret    

00008c7d <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    8c7d:	55                   	push   %ebp
    8c7e:	89 e5                	mov    %esp,%ebp
    8c80:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8c83:	8b 45 08             	mov    0x8(%ebp),%eax
    8c86:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8c89:	73 0f                	jae    8c9a <lodepng_chunk_next_const+0x1d>
    8c8b:	8b 55 0c             	mov    0xc(%ebp),%edx
    8c8e:	8b 45 08             	mov    0x8(%ebp),%eax
    8c91:	29 c2                	sub    %eax,%edx
    8c93:	89 d0                	mov    %edx,%eax
    8c95:	83 f8 0b             	cmp    $0xb,%eax
    8c98:	7f 08                	jg     8ca2 <lodepng_chunk_next_const+0x25>
    8c9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c9d:	e9 af 00 00 00       	jmp    8d51 <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8ca2:	8b 45 08             	mov    0x8(%ebp),%eax
    8ca5:	0f b6 00             	movzbl (%eax),%eax
    8ca8:	3c 89                	cmp    $0x89,%al
    8caa:	75 63                	jne    8d0f <lodepng_chunk_next_const+0x92>
    8cac:	8b 45 08             	mov    0x8(%ebp),%eax
    8caf:	83 c0 01             	add    $0x1,%eax
    8cb2:	0f b6 00             	movzbl (%eax),%eax
    8cb5:	3c 50                	cmp    $0x50,%al
    8cb7:	75 56                	jne    8d0f <lodepng_chunk_next_const+0x92>
    8cb9:	8b 45 08             	mov    0x8(%ebp),%eax
    8cbc:	83 c0 02             	add    $0x2,%eax
    8cbf:	0f b6 00             	movzbl (%eax),%eax
    8cc2:	3c 4e                	cmp    $0x4e,%al
    8cc4:	75 49                	jne    8d0f <lodepng_chunk_next_const+0x92>
    8cc6:	8b 45 08             	mov    0x8(%ebp),%eax
    8cc9:	83 c0 03             	add    $0x3,%eax
    8ccc:	0f b6 00             	movzbl (%eax),%eax
    8ccf:	3c 47                	cmp    $0x47,%al
    8cd1:	75 3c                	jne    8d0f <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    8cd3:	8b 45 08             	mov    0x8(%ebp),%eax
    8cd6:	83 c0 04             	add    $0x4,%eax
    8cd9:	0f b6 00             	movzbl (%eax),%eax
    8cdc:	3c 0d                	cmp    $0xd,%al
    8cde:	75 2f                	jne    8d0f <lodepng_chunk_next_const+0x92>
    8ce0:	8b 45 08             	mov    0x8(%ebp),%eax
    8ce3:	83 c0 05             	add    $0x5,%eax
    8ce6:	0f b6 00             	movzbl (%eax),%eax
    8ce9:	3c 0a                	cmp    $0xa,%al
    8ceb:	75 22                	jne    8d0f <lodepng_chunk_next_const+0x92>
    8ced:	8b 45 08             	mov    0x8(%ebp),%eax
    8cf0:	83 c0 06             	add    $0x6,%eax
    8cf3:	0f b6 00             	movzbl (%eax),%eax
    8cf6:	3c 1a                	cmp    $0x1a,%al
    8cf8:	75 15                	jne    8d0f <lodepng_chunk_next_const+0x92>
    8cfa:	8b 45 08             	mov    0x8(%ebp),%eax
    8cfd:	83 c0 07             	add    $0x7,%eax
    8d00:	0f b6 00             	movzbl (%eax),%eax
    8d03:	3c 0a                	cmp    $0xa,%al
    8d05:	75 08                	jne    8d0f <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    8d07:	8b 45 08             	mov    0x8(%ebp),%eax
    8d0a:	83 c0 08             	add    $0x8,%eax
    8d0d:	eb 42                	jmp    8d51 <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    8d0f:	ff 75 08             	pushl  0x8(%ebp)
    8d12:	e8 a8 fc ff ff       	call   89bf <lodepng_chunk_length>
    8d17:	83 c4 04             	add    $0x4,%esp
    8d1a:	89 c2                	mov    %eax,%edx
    8d1c:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8d1f:	50                   	push   %eax
    8d20:	6a 0c                	push   $0xc
    8d22:	52                   	push   %edx
    8d23:	e8 d9 ad ff ff       	call   3b01 <lodepng_addofl>
    8d28:	83 c4 0c             	add    $0xc,%esp
    8d2b:	85 c0                	test   %eax,%eax
    8d2d:	74 05                	je     8d34 <lodepng_chunk_next_const+0xb7>
    8d2f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d32:	eb 1d                	jmp    8d51 <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    8d34:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8d37:	89 c2                	mov    %eax,%edx
    8d39:	8b 45 08             	mov    0x8(%ebp),%eax
    8d3c:	01 d0                	add    %edx,%eax
    8d3e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8d41:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d44:	3b 45 08             	cmp    0x8(%ebp),%eax
    8d47:	73 05                	jae    8d4e <lodepng_chunk_next_const+0xd1>
    8d49:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d4c:	eb 03                	jmp    8d51 <lodepng_chunk_next_const+0xd4>
    return result;
    8d4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8d51:	c9                   	leave  
    8d52:	c3                   	ret    

00008d53 <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    8d53:	55                   	push   %ebp
    8d54:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    8d56:	8b 45 08             	mov    0x8(%ebp),%eax
    8d59:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8d5c:	73 0f                	jae    8d6d <lodepng_chunk_find+0x1a>
    8d5e:	8b 55 0c             	mov    0xc(%ebp),%edx
    8d61:	8b 45 08             	mov    0x8(%ebp),%eax
    8d64:	29 c2                	sub    %eax,%edx
    8d66:	89 d0                	mov    %edx,%eax
    8d68:	83 f8 0b             	cmp    $0xb,%eax
    8d6b:	7f 07                	jg     8d74 <lodepng_chunk_find+0x21>
    8d6d:	b8 00 00 00 00       	mov    $0x0,%eax
    8d72:	eb 2a                	jmp    8d9e <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    8d74:	ff 75 10             	pushl  0x10(%ebp)
    8d77:	ff 75 08             	pushl  0x8(%ebp)
    8d7a:	e8 8d fc ff ff       	call   8a0c <lodepng_chunk_type_equals>
    8d7f:	83 c4 08             	add    $0x8,%esp
    8d82:	84 c0                	test   %al,%al
    8d84:	74 05                	je     8d8b <lodepng_chunk_find+0x38>
    8d86:	8b 45 08             	mov    0x8(%ebp),%eax
    8d89:	eb 13                	jmp    8d9e <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    8d8b:	ff 75 0c             	pushl  0xc(%ebp)
    8d8e:	ff 75 08             	pushl  0x8(%ebp)
    8d91:	e8 11 fe ff ff       	call   8ba7 <lodepng_chunk_next>
    8d96:	83 c4 08             	add    $0x8,%esp
    8d99:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8d9c:	eb b8                	jmp    8d56 <lodepng_chunk_find+0x3>
}
    8d9e:	c9                   	leave  
    8d9f:	c3                   	ret    

00008da0 <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    8da0:	55                   	push   %ebp
    8da1:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    8da3:	8b 45 08             	mov    0x8(%ebp),%eax
    8da6:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8da9:	73 0f                	jae    8dba <lodepng_chunk_find_const+0x1a>
    8dab:	8b 55 0c             	mov    0xc(%ebp),%edx
    8dae:	8b 45 08             	mov    0x8(%ebp),%eax
    8db1:	29 c2                	sub    %eax,%edx
    8db3:	89 d0                	mov    %edx,%eax
    8db5:	83 f8 0b             	cmp    $0xb,%eax
    8db8:	7f 07                	jg     8dc1 <lodepng_chunk_find_const+0x21>
    8dba:	b8 00 00 00 00       	mov    $0x0,%eax
    8dbf:	eb 2a                	jmp    8deb <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    8dc1:	ff 75 10             	pushl  0x10(%ebp)
    8dc4:	ff 75 08             	pushl  0x8(%ebp)
    8dc7:	e8 40 fc ff ff       	call   8a0c <lodepng_chunk_type_equals>
    8dcc:	83 c4 08             	add    $0x8,%esp
    8dcf:	84 c0                	test   %al,%al
    8dd1:	74 05                	je     8dd8 <lodepng_chunk_find_const+0x38>
    8dd3:	8b 45 08             	mov    0x8(%ebp),%eax
    8dd6:	eb 13                	jmp    8deb <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    8dd8:	ff 75 0c             	pushl  0xc(%ebp)
    8ddb:	ff 75 08             	pushl  0x8(%ebp)
    8dde:	e8 9a fe ff ff       	call   8c7d <lodepng_chunk_next_const>
    8de3:	83 c4 08             	add    $0x8,%esp
    8de6:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8de9:	eb b8                	jmp    8da3 <lodepng_chunk_find_const+0x3>
}
    8deb:	c9                   	leave  
    8dec:	c3                   	ret    

00008ded <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    8ded:	55                   	push   %ebp
    8dee:	89 e5                	mov    %esp,%ebp
    8df0:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    8df3:	ff 75 10             	pushl  0x10(%ebp)
    8df6:	e8 c4 fb ff ff       	call   89bf <lodepng_chunk_length>
    8dfb:	83 c4 04             	add    $0x4,%esp
    8dfe:	89 c2                	mov    %eax,%edx
    8e00:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8e03:	50                   	push   %eax
    8e04:	6a 0c                	push   $0xc
    8e06:	52                   	push   %edx
    8e07:	e8 f5 ac ff ff       	call   3b01 <lodepng_addofl>
    8e0c:	83 c4 0c             	add    $0xc,%esp
    8e0f:	85 c0                	test   %eax,%eax
    8e11:	74 0a                	je     8e1d <lodepng_chunk_append+0x30>
    8e13:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8e18:	e9 96 00 00 00       	jmp    8eb3 <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    8e1d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8e20:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e23:	8b 00                	mov    (%eax),%eax
    8e25:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    8e28:	51                   	push   %ecx
    8e29:	52                   	push   %edx
    8e2a:	50                   	push   %eax
    8e2b:	e8 d1 ac ff ff       	call   3b01 <lodepng_addofl>
    8e30:	83 c4 0c             	add    $0xc,%esp
    8e33:	85 c0                	test   %eax,%eax
    8e35:	74 07                	je     8e3e <lodepng_chunk_append+0x51>
    8e37:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8e3c:	eb 75                	jmp    8eb3 <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    8e3e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8e41:	8b 45 08             	mov    0x8(%ebp),%eax
    8e44:	8b 00                	mov    (%eax),%eax
    8e46:	52                   	push   %edx
    8e47:	50                   	push   %eax
    8e48:	e8 07 ac ff ff       	call   3a54 <lodepng_realloc>
    8e4d:	83 c4 08             	add    $0x8,%esp
    8e50:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    8e53:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    8e57:	75 07                	jne    8e60 <lodepng_chunk_append+0x73>
    8e59:	b8 53 00 00 00       	mov    $0x53,%eax
    8e5e:	eb 53                	jmp    8eb3 <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    8e60:	8b 45 08             	mov    0x8(%ebp),%eax
    8e63:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8e66:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    8e68:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8e6b:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e6e:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    8e70:	8b 45 08             	mov    0x8(%ebp),%eax
    8e73:	8b 00                	mov    (%eax),%eax
    8e75:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    8e78:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8e7b:	29 d1                	sub    %edx,%ecx
    8e7d:	89 ca                	mov    %ecx,%edx
    8e7f:	01 d0                	add    %edx,%eax
    8e81:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    8e84:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8e8b:	eb 19                	jmp    8ea6 <lodepng_chunk_append+0xb9>
    8e8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8e90:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8e93:	01 c2                	add    %eax,%edx
    8e95:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8e98:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8e9b:	01 c8                	add    %ecx,%eax
    8e9d:	0f b6 00             	movzbl (%eax),%eax
    8ea0:	88 02                	mov    %al,(%edx)
    8ea2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8ea6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8ea9:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    8eac:	75 df                	jne    8e8d <lodepng_chunk_append+0xa0>

  return 0;
    8eae:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8eb3:	c9                   	leave  
    8eb4:	c3                   	ret    

00008eb5 <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    8eb5:	55                   	push   %ebp
    8eb6:	89 e5                	mov    %esp,%ebp
    8eb8:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    8ebb:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ebe:	8b 40 04             	mov    0x4(%eax),%eax
    8ec1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    8ec4:	8b 55 10             	mov    0x10(%ebp),%edx
    8ec7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8eca:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    8ecd:	51                   	push   %ecx
    8ece:	52                   	push   %edx
    8ecf:	50                   	push   %eax
    8ed0:	e8 2c ac ff ff       	call   3b01 <lodepng_addofl>
    8ed5:	83 c4 0c             	add    $0xc,%esp
    8ed8:	85 c0                	test   %eax,%eax
    8eda:	74 07                	je     8ee3 <lodepng_chunk_init+0x2e>
    8edc:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8ee1:	eb 78                	jmp    8f5b <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    8ee3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8ee6:	8d 55 fc             	lea    -0x4(%ebp),%edx
    8ee9:	52                   	push   %edx
    8eea:	6a 0c                	push   $0xc
    8eec:	50                   	push   %eax
    8eed:	e8 0f ac ff ff       	call   3b01 <lodepng_addofl>
    8ef2:	83 c4 0c             	add    $0xc,%esp
    8ef5:	85 c0                	test   %eax,%eax
    8ef7:	74 07                	je     8f00 <lodepng_chunk_init+0x4b>
    8ef9:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8efe:	eb 5b                	jmp    8f5b <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    8f00:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8f03:	50                   	push   %eax
    8f04:	ff 75 0c             	pushl  0xc(%ebp)
    8f07:	e8 8b ad ff ff       	call   3c97 <ucvector_resize>
    8f0c:	83 c4 08             	add    $0x8,%esp
    8f0f:	85 c0                	test   %eax,%eax
    8f11:	75 07                	jne    8f1a <lodepng_chunk_init+0x65>
    8f13:	b8 53 00 00 00       	mov    $0x53,%eax
    8f18:	eb 41                	jmp    8f5b <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    8f1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f1d:	8b 00                	mov    (%eax),%eax
    8f1f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8f22:	2b 55 10             	sub    0x10(%ebp),%edx
    8f25:	83 ea 0c             	sub    $0xc,%edx
    8f28:	01 c2                	add    %eax,%edx
    8f2a:	8b 45 08             	mov    0x8(%ebp),%eax
    8f2d:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    8f2f:	8b 45 08             	mov    0x8(%ebp),%eax
    8f32:	8b 00                	mov    (%eax),%eax
    8f34:	ff 75 10             	pushl  0x10(%ebp)
    8f37:	50                   	push   %eax
    8f38:	e8 c1 ae ff ff       	call   3dfe <lodepng_set32bitInt>
    8f3d:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    8f40:	8b 45 08             	mov    0x8(%ebp),%eax
    8f43:	8b 00                	mov    (%eax),%eax
    8f45:	83 c0 04             	add    $0x4,%eax
    8f48:	6a 04                	push   $0x4
    8f4a:	ff 75 14             	pushl  0x14(%ebp)
    8f4d:	50                   	push   %eax
    8f4e:	e8 28 ab ff ff       	call   3a7b <lodepng_memcpy>
    8f53:	83 c4 0c             	add    $0xc,%esp

  return 0;
    8f56:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f5b:	c9                   	leave  
    8f5c:	c3                   	ret    

00008f5d <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    8f5d:	55                   	push   %ebp
    8f5e:	89 e5                	mov    %esp,%ebp
    8f60:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    8f63:	ff 75 10             	pushl  0x10(%ebp)
    8f66:	ff 75 0c             	pushl  0xc(%ebp)
    8f69:	ff 75 08             	pushl  0x8(%ebp)
    8f6c:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8f6f:	50                   	push   %eax
    8f70:	e8 40 ff ff ff       	call   8eb5 <lodepng_chunk_init>
    8f75:	83 c4 10             	add    $0x10,%esp
    8f78:	89 45 fc             	mov    %eax,-0x4(%ebp)
    8f7b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    8f7f:	74 05                	je     8f86 <lodepng_chunk_createv+0x29>
    8f81:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8f84:	eb 27                	jmp    8fad <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    8f86:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f89:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8f8c:	83 c2 08             	add    $0x8,%edx
    8f8f:	50                   	push   %eax
    8f90:	ff 75 14             	pushl  0x14(%ebp)
    8f93:	52                   	push   %edx
    8f94:	e8 e2 aa ff ff       	call   3a7b <lodepng_memcpy>
    8f99:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    8f9c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8f9f:	50                   	push   %eax
    8fa0:	e8 b9 fb ff ff       	call   8b5e <lodepng_chunk_generate_crc>
    8fa5:	83 c4 04             	add    $0x4,%esp

  return 0;
    8fa8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8fad:	c9                   	leave  
    8fae:	c3                   	ret    

00008faf <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    8faf:	55                   	push   %ebp
    8fb0:	89 e5                	mov    %esp,%ebp
    8fb2:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    8fb5:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fb8:	8b 08                	mov    (%eax),%ecx
    8fba:	8b 45 08             	mov    0x8(%ebp),%eax
    8fbd:	8b 10                	mov    (%eax),%edx
    8fbf:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8fc2:	51                   	push   %ecx
    8fc3:	52                   	push   %edx
    8fc4:	50                   	push   %eax
    8fc5:	e8 34 ad ff ff       	call   3cfe <ucvector_init>
    8fca:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    8fcd:	ff 75 18             	pushl  0x18(%ebp)
    8fd0:	ff 75 14             	pushl  0x14(%ebp)
    8fd3:	ff 75 10             	pushl  0x10(%ebp)
    8fd6:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8fd9:	50                   	push   %eax
    8fda:	e8 7e ff ff ff       	call   8f5d <lodepng_chunk_createv>
    8fdf:	83 c4 10             	add    $0x10,%esp
    8fe2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    8fe5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8fe8:	8b 45 08             	mov    0x8(%ebp),%eax
    8feb:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8fed:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ff0:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ff3:	89 10                	mov    %edx,(%eax)
  return error;
    8ff5:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    8ff8:	c9                   	leave  
    8ff9:	c3                   	ret    

00008ffa <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    8ffa:	55                   	push   %ebp
    8ffb:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8ffd:	8b 45 08             	mov    0x8(%ebp),%eax
    9000:	83 f8 03             	cmp    $0x3,%eax
    9003:	74 6d                	je     9072 <checkColorValidity+0x78>
    9005:	83 f8 03             	cmp    $0x3,%eax
    9008:	77 0e                	ja     9018 <checkColorValidity+0x1e>
    900a:	85 c0                	test   %eax,%eax
    900c:	74 28                	je     9036 <checkColorValidity+0x3c>
    900e:	83 f8 02             	cmp    $0x2,%eax
    9011:	74 4c                	je     905f <checkColorValidity+0x65>
    9013:	e9 a6 00 00 00       	jmp    90be <checkColorValidity+0xc4>
    9018:	83 f8 06             	cmp    $0x6,%eax
    901b:	0f 84 83 00 00 00    	je     90a4 <checkColorValidity+0xaa>
    9021:	3d ff 00 00 00       	cmp    $0xff,%eax
    9026:	0f 84 8b 00 00 00    	je     90b7 <checkColorValidity+0xbd>
    902c:	83 f8 04             	cmp    $0x4,%eax
    902f:	74 60                	je     9091 <checkColorValidity+0x97>
    9031:	e9 88 00 00 00       	jmp    90be <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    9036:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    903a:	0f 84 85 00 00 00    	je     90c5 <checkColorValidity+0xcb>
    9040:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    9044:	74 7f                	je     90c5 <checkColorValidity+0xcb>
    9046:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    904a:	74 79                	je     90c5 <checkColorValidity+0xcb>
    904c:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    9050:	74 73                	je     90c5 <checkColorValidity+0xcb>
    9052:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    9056:	74 6d                	je     90c5 <checkColorValidity+0xcb>
    9058:	b8 25 00 00 00       	mov    $0x25,%eax
    905d:	eb 78                	jmp    90d7 <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    905f:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    9063:	74 63                	je     90c8 <checkColorValidity+0xce>
    9065:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    9069:	74 5d                	je     90c8 <checkColorValidity+0xce>
    906b:	b8 25 00 00 00       	mov    $0x25,%eax
    9070:	eb 65                	jmp    90d7 <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    9072:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    9076:	74 53                	je     90cb <checkColorValidity+0xd1>
    9078:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    907c:	74 4d                	je     90cb <checkColorValidity+0xd1>
    907e:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    9082:	74 47                	je     90cb <checkColorValidity+0xd1>
    9084:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    9088:	74 41                	je     90cb <checkColorValidity+0xd1>
    908a:	b8 25 00 00 00       	mov    $0x25,%eax
    908f:	eb 46                	jmp    90d7 <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    9091:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    9095:	74 37                	je     90ce <checkColorValidity+0xd4>
    9097:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    909b:	74 31                	je     90ce <checkColorValidity+0xd4>
    909d:	b8 25 00 00 00       	mov    $0x25,%eax
    90a2:	eb 33                	jmp    90d7 <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    90a4:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    90a8:	74 27                	je     90d1 <checkColorValidity+0xd7>
    90aa:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    90ae:	74 21                	je     90d1 <checkColorValidity+0xd7>
    90b0:	b8 25 00 00 00       	mov    $0x25,%eax
    90b5:	eb 20                	jmp    90d7 <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    90b7:	b8 1f 00 00 00       	mov    $0x1f,%eax
    90bc:	eb 19                	jmp    90d7 <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    90be:	b8 1f 00 00 00       	mov    $0x1f,%eax
    90c3:	eb 12                	jmp    90d7 <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    90c5:	90                   	nop
    90c6:	eb 0a                	jmp    90d2 <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    90c8:	90                   	nop
    90c9:	eb 07                	jmp    90d2 <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    90cb:	90                   	nop
    90cc:	eb 04                	jmp    90d2 <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    90ce:	90                   	nop
    90cf:	eb 01                	jmp    90d2 <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    90d1:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    90d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    90d7:	5d                   	pop    %ebp
    90d8:	c3                   	ret    

000090d9 <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    90d9:	55                   	push   %ebp
    90da:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    90dc:	8b 45 08             	mov    0x8(%ebp),%eax
    90df:	83 f8 03             	cmp    $0x3,%eax
    90e2:	74 31                	je     9115 <getNumColorChannels+0x3c>
    90e4:	83 f8 03             	cmp    $0x3,%eax
    90e7:	77 0b                	ja     90f4 <getNumColorChannels+0x1b>
    90e9:	85 c0                	test   %eax,%eax
    90eb:	74 1a                	je     9107 <getNumColorChannels+0x2e>
    90ed:	83 f8 02             	cmp    $0x2,%eax
    90f0:	74 1c                	je     910e <getNumColorChannels+0x35>
    90f2:	eb 3d                	jmp    9131 <getNumColorChannels+0x58>
    90f4:	83 f8 06             	cmp    $0x6,%eax
    90f7:	74 2a                	je     9123 <getNumColorChannels+0x4a>
    90f9:	3d ff 00 00 00       	cmp    $0xff,%eax
    90fe:	74 2a                	je     912a <getNumColorChannels+0x51>
    9100:	83 f8 04             	cmp    $0x4,%eax
    9103:	74 17                	je     911c <getNumColorChannels+0x43>
    9105:	eb 2a                	jmp    9131 <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    9107:	b8 01 00 00 00       	mov    $0x1,%eax
    910c:	eb 28                	jmp    9136 <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    910e:	b8 03 00 00 00       	mov    $0x3,%eax
    9113:	eb 21                	jmp    9136 <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    9115:	b8 01 00 00 00       	mov    $0x1,%eax
    911a:	eb 1a                	jmp    9136 <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    911c:	b8 02 00 00 00       	mov    $0x2,%eax
    9121:	eb 13                	jmp    9136 <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    9123:	b8 04 00 00 00       	mov    $0x4,%eax
    9128:	eb 0c                	jmp    9136 <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    912a:	b8 00 00 00 00       	mov    $0x0,%eax
    912f:	eb 05                	jmp    9136 <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    9131:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    9136:	5d                   	pop    %ebp
    9137:	c3                   	ret    

00009138 <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    9138:	55                   	push   %ebp
    9139:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    913b:	ff 75 08             	pushl  0x8(%ebp)
    913e:	e8 96 ff ff ff       	call   90d9 <getNumColorChannels>
    9143:	83 c4 04             	add    $0x4,%esp
    9146:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    914a:	c9                   	leave  
    914b:	c3                   	ret    

0000914c <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    914c:	55                   	push   %ebp
    914d:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    914f:	8b 45 08             	mov    0x8(%ebp),%eax
    9152:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    9159:	8b 45 08             	mov    0x8(%ebp),%eax
    915c:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    9163:	8b 45 08             	mov    0x8(%ebp),%eax
    9166:	8b 50 1c             	mov    0x1c(%eax),%edx
    9169:	8b 45 08             	mov    0x8(%ebp),%eax
    916c:	89 50 18             	mov    %edx,0x18(%eax)
    916f:	8b 45 08             	mov    0x8(%ebp),%eax
    9172:	8b 50 18             	mov    0x18(%eax),%edx
    9175:	8b 45 08             	mov    0x8(%ebp),%eax
    9178:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    917b:	8b 45 08             	mov    0x8(%ebp),%eax
    917e:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    9184:	8b 45 08             	mov    0x8(%ebp),%eax
    9187:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    918e:	8b 45 08             	mov    0x8(%ebp),%eax
    9191:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    9198:	8b 45 08             	mov    0x8(%ebp),%eax
    919b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    91a2:	90                   	nop
    91a3:	5d                   	pop    %ebp
    91a4:	c3                   	ret    

000091a5 <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    91a5:	55                   	push   %ebp
    91a6:	89 e5                	mov    %esp,%ebp
    91a8:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    91ab:	8b 45 08             	mov    0x8(%ebp),%eax
    91ae:	8b 40 08             	mov    0x8(%eax),%eax
    91b1:	85 c0                	test   %eax,%eax
    91b3:	75 18                	jne    91cd <lodepng_color_mode_alloc_palette+0x28>
    91b5:	83 ec 0c             	sub    $0xc,%esp
    91b8:	68 00 04 00 00       	push   $0x400
    91bd:	e8 7b a8 ff ff       	call   3a3d <lodepng_malloc>
    91c2:	83 c4 10             	add    $0x10,%esp
    91c5:	89 c2                	mov    %eax,%edx
    91c7:	8b 45 08             	mov    0x8(%ebp),%eax
    91ca:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    91cd:	8b 45 08             	mov    0x8(%ebp),%eax
    91d0:	8b 40 08             	mov    0x8(%eax),%eax
    91d3:	85 c0                	test   %eax,%eax
    91d5:	74 65                	je     923c <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    91d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    91de:	eb 51                	jmp    9231 <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    91e0:	8b 45 08             	mov    0x8(%ebp),%eax
    91e3:	8b 40 08             	mov    0x8(%eax),%eax
    91e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91e9:	c1 e2 02             	shl    $0x2,%edx
    91ec:	01 d0                	add    %edx,%eax
    91ee:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    91f1:	8b 45 08             	mov    0x8(%ebp),%eax
    91f4:	8b 40 08             	mov    0x8(%eax),%eax
    91f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91fa:	c1 e2 02             	shl    $0x2,%edx
    91fd:	83 c2 01             	add    $0x1,%edx
    9200:	01 d0                	add    %edx,%eax
    9202:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    9205:	8b 45 08             	mov    0x8(%ebp),%eax
    9208:	8b 40 08             	mov    0x8(%eax),%eax
    920b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    920e:	c1 e2 02             	shl    $0x2,%edx
    9211:	83 c2 02             	add    $0x2,%edx
    9214:	01 d0                	add    %edx,%eax
    9216:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    9219:	8b 45 08             	mov    0x8(%ebp),%eax
    921c:	8b 40 08             	mov    0x8(%eax),%eax
    921f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9222:	c1 e2 02             	shl    $0x2,%edx
    9225:	83 c2 03             	add    $0x3,%edx
    9228:	01 d0                	add    %edx,%eax
    922a:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    922d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9231:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    9238:	75 a6                	jne    91e0 <lodepng_color_mode_alloc_palette+0x3b>
    923a:	eb 01                	jmp    923d <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    923c:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    923d:	c9                   	leave  
    923e:	c3                   	ret    

0000923f <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    923f:	55                   	push   %ebp
    9240:	89 e5                	mov    %esp,%ebp
    9242:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    9245:	83 ec 0c             	sub    $0xc,%esp
    9248:	ff 75 08             	pushl  0x8(%ebp)
    924b:	e8 f3 01 00 00       	call   9443 <lodepng_palette_clear>
    9250:	83 c4 10             	add    $0x10,%esp
}
    9253:	90                   	nop
    9254:	c9                   	leave  
    9255:	c3                   	ret    

00009256 <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    9256:	55                   	push   %ebp
    9257:	89 e5                	mov    %esp,%ebp
    9259:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    925c:	83 ec 0c             	sub    $0xc,%esp
    925f:	ff 75 08             	pushl  0x8(%ebp)
    9262:	e8 d8 ff ff ff       	call   923f <lodepng_color_mode_cleanup>
    9267:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    926a:	83 ec 04             	sub    $0x4,%esp
    926d:	6a 20                	push   $0x20
    926f:	ff 75 0c             	pushl  0xc(%ebp)
    9272:	ff 75 08             	pushl  0x8(%ebp)
    9275:	e8 01 a8 ff ff       	call   3a7b <lodepng_memcpy>
    927a:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    927d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9280:	8b 40 08             	mov    0x8(%eax),%eax
    9283:	85 c0                	test   %eax,%eax
    9285:	74 5a                	je     92e1 <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    9287:	83 ec 0c             	sub    $0xc,%esp
    928a:	68 00 04 00 00       	push   $0x400
    928f:	e8 a9 a7 ff ff       	call   3a3d <lodepng_malloc>
    9294:	83 c4 10             	add    $0x10,%esp
    9297:	89 c2                	mov    %eax,%edx
    9299:	8b 45 08             	mov    0x8(%ebp),%eax
    929c:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    929f:	8b 45 08             	mov    0x8(%ebp),%eax
    92a2:	8b 40 08             	mov    0x8(%eax),%eax
    92a5:	85 c0                	test   %eax,%eax
    92a7:	75 11                	jne    92ba <lodepng_color_mode_copy+0x64>
    92a9:	8b 45 0c             	mov    0xc(%ebp),%eax
    92ac:	8b 40 0c             	mov    0xc(%eax),%eax
    92af:	85 c0                	test   %eax,%eax
    92b1:	74 07                	je     92ba <lodepng_color_mode_copy+0x64>
    92b3:	b8 53 00 00 00       	mov    $0x53,%eax
    92b8:	eb 2c                	jmp    92e6 <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    92ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    92bd:	8b 40 0c             	mov    0xc(%eax),%eax
    92c0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    92c7:	8b 45 0c             	mov    0xc(%ebp),%eax
    92ca:	8b 50 08             	mov    0x8(%eax),%edx
    92cd:	8b 45 08             	mov    0x8(%ebp),%eax
    92d0:	8b 40 08             	mov    0x8(%eax),%eax
    92d3:	83 ec 04             	sub    $0x4,%esp
    92d6:	51                   	push   %ecx
    92d7:	52                   	push   %edx
    92d8:	50                   	push   %eax
    92d9:	e8 9d a7 ff ff       	call   3a7b <lodepng_memcpy>
    92de:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    92e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    92e6:	c9                   	leave  
    92e7:	c3                   	ret    

000092e8 <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    92e8:	55                   	push   %ebp
    92e9:	89 e5                	mov    %esp,%ebp
    92eb:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    92ee:	8d 45 e0             	lea    -0x20(%ebp),%eax
    92f1:	50                   	push   %eax
    92f2:	e8 55 fe ff ff       	call   914c <lodepng_color_mode_init>
    92f7:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    92fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    92fd:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    9300:	8b 45 10             	mov    0x10(%ebp),%eax
    9303:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    9306:	8b 45 08             	mov    0x8(%ebp),%eax
    9309:	8b 55 e0             	mov    -0x20(%ebp),%edx
    930c:	89 10                	mov    %edx,(%eax)
    930e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    9311:	89 50 04             	mov    %edx,0x4(%eax)
    9314:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9317:	89 50 08             	mov    %edx,0x8(%eax)
    931a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    931d:	89 50 0c             	mov    %edx,0xc(%eax)
    9320:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9323:	89 50 10             	mov    %edx,0x10(%eax)
    9326:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9329:	89 50 14             	mov    %edx,0x14(%eax)
    932c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    932f:	89 50 18             	mov    %edx,0x18(%eax)
    9332:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9335:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    9338:	8b 45 08             	mov    0x8(%ebp),%eax
    933b:	c9                   	leave  
    933c:	c2 04 00             	ret    $0x4

0000933f <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    933f:	55                   	push   %ebp
    9340:	89 e5                	mov    %esp,%ebp
    9342:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    9345:	8b 45 08             	mov    0x8(%ebp),%eax
    9348:	8b 10                	mov    (%eax),%edx
    934a:	8b 45 0c             	mov    0xc(%ebp),%eax
    934d:	8b 00                	mov    (%eax),%eax
    934f:	39 c2                	cmp    %eax,%edx
    9351:	74 0a                	je     935d <lodepng_color_mode_equal+0x1e>
    9353:	b8 00 00 00 00       	mov    $0x0,%eax
    9358:	e9 e4 00 00 00       	jmp    9441 <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    935d:	8b 45 08             	mov    0x8(%ebp),%eax
    9360:	8b 50 04             	mov    0x4(%eax),%edx
    9363:	8b 45 0c             	mov    0xc(%ebp),%eax
    9366:	8b 40 04             	mov    0x4(%eax),%eax
    9369:	39 c2                	cmp    %eax,%edx
    936b:	74 0a                	je     9377 <lodepng_color_mode_equal+0x38>
    936d:	b8 00 00 00 00       	mov    $0x0,%eax
    9372:	e9 ca 00 00 00       	jmp    9441 <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    9377:	8b 45 08             	mov    0x8(%ebp),%eax
    937a:	8b 50 10             	mov    0x10(%eax),%edx
    937d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9380:	8b 40 10             	mov    0x10(%eax),%eax
    9383:	39 c2                	cmp    %eax,%edx
    9385:	74 0a                	je     9391 <lodepng_color_mode_equal+0x52>
    9387:	b8 00 00 00 00       	mov    $0x0,%eax
    938c:	e9 b0 00 00 00       	jmp    9441 <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    9391:	8b 45 08             	mov    0x8(%ebp),%eax
    9394:	8b 40 10             	mov    0x10(%eax),%eax
    9397:	85 c0                	test   %eax,%eax
    9399:	74 48                	je     93e3 <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    939b:	8b 45 08             	mov    0x8(%ebp),%eax
    939e:	8b 50 14             	mov    0x14(%eax),%edx
    93a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    93a4:	8b 40 14             	mov    0x14(%eax),%eax
    93a7:	39 c2                	cmp    %eax,%edx
    93a9:	74 0a                	je     93b5 <lodepng_color_mode_equal+0x76>
    93ab:	b8 00 00 00 00       	mov    $0x0,%eax
    93b0:	e9 8c 00 00 00       	jmp    9441 <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    93b5:	8b 45 08             	mov    0x8(%ebp),%eax
    93b8:	8b 50 18             	mov    0x18(%eax),%edx
    93bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    93be:	8b 40 18             	mov    0x18(%eax),%eax
    93c1:	39 c2                	cmp    %eax,%edx
    93c3:	74 07                	je     93cc <lodepng_color_mode_equal+0x8d>
    93c5:	b8 00 00 00 00       	mov    $0x0,%eax
    93ca:	eb 75                	jmp    9441 <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    93cc:	8b 45 08             	mov    0x8(%ebp),%eax
    93cf:	8b 50 1c             	mov    0x1c(%eax),%edx
    93d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    93d5:	8b 40 1c             	mov    0x1c(%eax),%eax
    93d8:	39 c2                	cmp    %eax,%edx
    93da:	74 07                	je     93e3 <lodepng_color_mode_equal+0xa4>
    93dc:	b8 00 00 00 00       	mov    $0x0,%eax
    93e1:	eb 5e                	jmp    9441 <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    93e3:	8b 45 08             	mov    0x8(%ebp),%eax
    93e6:	8b 50 0c             	mov    0xc(%eax),%edx
    93e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    93ec:	8b 40 0c             	mov    0xc(%eax),%eax
    93ef:	39 c2                	cmp    %eax,%edx
    93f1:	74 07                	je     93fa <lodepng_color_mode_equal+0xbb>
    93f3:	b8 00 00 00 00       	mov    $0x0,%eax
    93f8:	eb 47                	jmp    9441 <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    93fa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9401:	eb 2b                	jmp    942e <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    9403:	8b 45 08             	mov    0x8(%ebp),%eax
    9406:	8b 50 08             	mov    0x8(%eax),%edx
    9409:	8b 45 fc             	mov    -0x4(%ebp),%eax
    940c:	01 d0                	add    %edx,%eax
    940e:	0f b6 10             	movzbl (%eax),%edx
    9411:	8b 45 0c             	mov    0xc(%ebp),%eax
    9414:	8b 48 08             	mov    0x8(%eax),%ecx
    9417:	8b 45 fc             	mov    -0x4(%ebp),%eax
    941a:	01 c8                	add    %ecx,%eax
    941c:	0f b6 00             	movzbl (%eax),%eax
    941f:	38 c2                	cmp    %al,%dl
    9421:	74 07                	je     942a <lodepng_color_mode_equal+0xeb>
    9423:	b8 00 00 00 00       	mov    $0x0,%eax
    9428:	eb 17                	jmp    9441 <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    942a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    942e:	8b 45 08             	mov    0x8(%ebp),%eax
    9431:	8b 40 0c             	mov    0xc(%eax),%eax
    9434:	c1 e0 02             	shl    $0x2,%eax
    9437:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    943a:	75 c7                	jne    9403 <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    943c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    9441:	c9                   	leave  
    9442:	c3                   	ret    

00009443 <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    9443:	55                   	push   %ebp
    9444:	89 e5                	mov    %esp,%ebp
    9446:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    9449:	8b 45 08             	mov    0x8(%ebp),%eax
    944c:	8b 40 08             	mov    0x8(%eax),%eax
    944f:	85 c0                	test   %eax,%eax
    9451:	74 12                	je     9465 <lodepng_palette_clear+0x22>
    9453:	8b 45 08             	mov    0x8(%ebp),%eax
    9456:	8b 40 08             	mov    0x8(%eax),%eax
    9459:	83 ec 0c             	sub    $0xc,%esp
    945c:	50                   	push   %eax
    945d:	e8 fc a5 ff ff       	call   3a5e <lodepng_free>
    9462:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    9465:	8b 45 08             	mov    0x8(%ebp),%eax
    9468:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    946f:	8b 45 08             	mov    0x8(%ebp),%eax
    9472:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    9479:	90                   	nop
    947a:	c9                   	leave  
    947b:	c3                   	ret    

0000947c <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    947c:	55                   	push   %ebp
    947d:	89 e5                	mov    %esp,%ebp
    947f:	53                   	push   %ebx
    9480:	83 ec 14             	sub    $0x14,%esp
    9483:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9486:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9489:	8b 55 14             	mov    0x14(%ebp),%edx
    948c:	8b 45 18             	mov    0x18(%ebp),%eax
    948f:	88 5d f4             	mov    %bl,-0xc(%ebp)
    9492:	88 4d f0             	mov    %cl,-0x10(%ebp)
    9495:	88 55 ec             	mov    %dl,-0x14(%ebp)
    9498:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    949b:	8b 45 08             	mov    0x8(%ebp),%eax
    949e:	8b 40 08             	mov    0x8(%eax),%eax
    94a1:	85 c0                	test   %eax,%eax
    94a3:	75 22                	jne    94c7 <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    94a5:	83 ec 0c             	sub    $0xc,%esp
    94a8:	ff 75 08             	pushl  0x8(%ebp)
    94ab:	e8 f5 fc ff ff       	call   91a5 <lodepng_color_mode_alloc_palette>
    94b0:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    94b3:	8b 45 08             	mov    0x8(%ebp),%eax
    94b6:	8b 40 08             	mov    0x8(%eax),%eax
    94b9:	85 c0                	test   %eax,%eax
    94bb:	75 0a                	jne    94c7 <lodepng_palette_add+0x4b>
    94bd:	b8 53 00 00 00       	mov    $0x53,%eax
    94c2:	e9 8d 00 00 00       	jmp    9554 <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    94c7:	8b 45 08             	mov    0x8(%ebp),%eax
    94ca:	8b 40 0c             	mov    0xc(%eax),%eax
    94cd:	3d ff 00 00 00       	cmp    $0xff,%eax
    94d2:	7e 07                	jle    94db <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    94d4:	b8 6c 00 00 00       	mov    $0x6c,%eax
    94d9:	eb 79                	jmp    9554 <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    94db:	8b 45 08             	mov    0x8(%ebp),%eax
    94de:	8b 50 08             	mov    0x8(%eax),%edx
    94e1:	8b 45 08             	mov    0x8(%ebp),%eax
    94e4:	8b 40 0c             	mov    0xc(%eax),%eax
    94e7:	c1 e0 02             	shl    $0x2,%eax
    94ea:	01 c2                	add    %eax,%edx
    94ec:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    94f0:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    94f2:	8b 45 08             	mov    0x8(%ebp),%eax
    94f5:	8b 50 08             	mov    0x8(%eax),%edx
    94f8:	8b 45 08             	mov    0x8(%ebp),%eax
    94fb:	8b 40 0c             	mov    0xc(%eax),%eax
    94fe:	c1 e0 02             	shl    $0x2,%eax
    9501:	83 c0 01             	add    $0x1,%eax
    9504:	01 c2                	add    %eax,%edx
    9506:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    950a:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    950c:	8b 45 08             	mov    0x8(%ebp),%eax
    950f:	8b 50 08             	mov    0x8(%eax),%edx
    9512:	8b 45 08             	mov    0x8(%ebp),%eax
    9515:	8b 40 0c             	mov    0xc(%eax),%eax
    9518:	c1 e0 02             	shl    $0x2,%eax
    951b:	83 c0 02             	add    $0x2,%eax
    951e:	01 c2                	add    %eax,%edx
    9520:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    9524:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    9526:	8b 45 08             	mov    0x8(%ebp),%eax
    9529:	8b 50 08             	mov    0x8(%eax),%edx
    952c:	8b 45 08             	mov    0x8(%ebp),%eax
    952f:	8b 40 0c             	mov    0xc(%eax),%eax
    9532:	c1 e0 02             	shl    $0x2,%eax
    9535:	83 c0 03             	add    $0x3,%eax
    9538:	01 c2                	add    %eax,%edx
    953a:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    953e:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    9540:	8b 45 08             	mov    0x8(%ebp),%eax
    9543:	8b 40 0c             	mov    0xc(%eax),%eax
    9546:	8d 50 01             	lea    0x1(%eax),%edx
    9549:	8b 45 08             	mov    0x8(%ebp),%eax
    954c:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    954f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9554:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9557:	c9                   	leave  
    9558:	c3                   	ret    

00009559 <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    9559:	55                   	push   %ebp
    955a:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    955c:	8b 45 08             	mov    0x8(%ebp),%eax
    955f:	8b 50 04             	mov    0x4(%eax),%edx
    9562:	8b 45 08             	mov    0x8(%ebp),%eax
    9565:	8b 00                	mov    (%eax),%eax
    9567:	52                   	push   %edx
    9568:	50                   	push   %eax
    9569:	e8 ca fb ff ff       	call   9138 <lodepng_get_bpp_lct>
    956e:	83 c4 08             	add    $0x8,%esp
}
    9571:	c9                   	leave  
    9572:	c3                   	ret    

00009573 <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    9573:	55                   	push   %ebp
    9574:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    9576:	8b 45 08             	mov    0x8(%ebp),%eax
    9579:	8b 00                	mov    (%eax),%eax
    957b:	50                   	push   %eax
    957c:	e8 58 fb ff ff       	call   90d9 <getNumColorChannels>
    9581:	83 c4 04             	add    $0x4,%esp
}
    9584:	c9                   	leave  
    9585:	c3                   	ret    

00009586 <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    9586:	55                   	push   %ebp
    9587:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    9589:	8b 45 08             	mov    0x8(%ebp),%eax
    958c:	8b 00                	mov    (%eax),%eax
    958e:	85 c0                	test   %eax,%eax
    9590:	74 0a                	je     959c <lodepng_is_greyscale_type+0x16>
    9592:	8b 45 08             	mov    0x8(%ebp),%eax
    9595:	8b 00                	mov    (%eax),%eax
    9597:	83 f8 04             	cmp    $0x4,%eax
    959a:	75 07                	jne    95a3 <lodepng_is_greyscale_type+0x1d>
    959c:	b8 01 00 00 00       	mov    $0x1,%eax
    95a1:	eb 05                	jmp    95a8 <lodepng_is_greyscale_type+0x22>
    95a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    95a8:	5d                   	pop    %ebp
    95a9:	c3                   	ret    

000095aa <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    95aa:	55                   	push   %ebp
    95ab:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    95ad:	8b 45 08             	mov    0x8(%ebp),%eax
    95b0:	8b 00                	mov    (%eax),%eax
    95b2:	83 e0 04             	and    $0x4,%eax
    95b5:	85 c0                	test   %eax,%eax
    95b7:	0f 95 c0             	setne  %al
    95ba:	0f b6 c0             	movzbl %al,%eax
}
    95bd:	5d                   	pop    %ebp
    95be:	c3                   	ret    

000095bf <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    95bf:	55                   	push   %ebp
    95c0:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    95c2:	8b 45 08             	mov    0x8(%ebp),%eax
    95c5:	8b 00                	mov    (%eax),%eax
    95c7:	83 f8 03             	cmp    $0x3,%eax
    95ca:	0f 94 c0             	sete   %al
    95cd:	0f b6 c0             	movzbl %al,%eax
}
    95d0:	5d                   	pop    %ebp
    95d1:	c3                   	ret    

000095d2 <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    95d2:	55                   	push   %ebp
    95d3:	89 e5                	mov    %esp,%ebp
    95d5:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    95d8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    95df:	eb 23                	jmp    9604 <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    95e1:	8b 45 08             	mov    0x8(%ebp),%eax
    95e4:	8b 40 08             	mov    0x8(%eax),%eax
    95e7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    95ea:	c1 e2 02             	shl    $0x2,%edx
    95ed:	83 c2 03             	add    $0x3,%edx
    95f0:	01 d0                	add    %edx,%eax
    95f2:	0f b6 00             	movzbl (%eax),%eax
    95f5:	3c ff                	cmp    $0xff,%al
    95f7:	74 07                	je     9600 <lodepng_has_palette_alpha+0x2e>
    95f9:	b8 01 00 00 00       	mov    $0x1,%eax
    95fe:	eb 14                	jmp    9614 <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    9600:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9604:	8b 45 08             	mov    0x8(%ebp),%eax
    9607:	8b 40 0c             	mov    0xc(%eax),%eax
    960a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    960d:	75 d2                	jne    95e1 <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    960f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9614:	c9                   	leave  
    9615:	c3                   	ret    

00009616 <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    9616:	55                   	push   %ebp
    9617:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    9619:	8b 45 08             	mov    0x8(%ebp),%eax
    961c:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    961f:	85 c0                	test   %eax,%eax
    9621:	75 1e                	jne    9641 <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    9623:	ff 75 08             	pushl  0x8(%ebp)
    9626:	e8 7f ff ff ff       	call   95aa <lodepng_is_alpha_type>
    962b:	83 c4 04             	add    $0x4,%esp
    962e:	85 c0                	test   %eax,%eax
    9630:	75 0f                	jne    9641 <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    9632:	ff 75 08             	pushl  0x8(%ebp)
    9635:	e8 98 ff ff ff       	call   95d2 <lodepng_has_palette_alpha>
    963a:	83 c4 04             	add    $0x4,%esp
    963d:	85 c0                	test   %eax,%eax
    963f:	74 07                	je     9648 <lodepng_can_have_alpha+0x32>
    9641:	b8 01 00 00 00       	mov    $0x1,%eax
    9646:	eb 05                	jmp    964d <lodepng_can_have_alpha+0x37>
    9648:	b8 00 00 00 00       	mov    $0x0,%eax
}
    964d:	c9                   	leave  
    964e:	c3                   	ret    

0000964f <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    964f:	55                   	push   %ebp
    9650:	89 e5                	mov    %esp,%ebp
    9652:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    9655:	ff 75 14             	pushl  0x14(%ebp)
    9658:	ff 75 10             	pushl  0x10(%ebp)
    965b:	e8 d8 fa ff ff       	call   9138 <lodepng_get_bpp_lct>
    9660:	83 c4 08             	add    $0x8,%esp
    9663:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    9666:	8b 55 08             	mov    0x8(%ebp),%edx
    9669:	8b 45 0c             	mov    0xc(%ebp),%eax
    966c:	0f af c2             	imul   %edx,%eax
    966f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    9672:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9675:	c1 e8 03             	shr    $0x3,%eax
    9678:	89 c2                	mov    %eax,%edx
    967a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    967d:	0f af c2             	imul   %edx,%eax
    9680:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9683:	89 d1                	mov    %edx,%ecx
    9685:	83 e1 07             	and    $0x7,%ecx
    9688:	8b 55 fc             	mov    -0x4(%ebp),%edx
    968b:	0f af d1             	imul   %ecx,%edx
    968e:	83 c2 07             	add    $0x7,%edx
    9691:	c1 ea 03             	shr    $0x3,%edx
    9694:	01 d0                	add    %edx,%eax
}
    9696:	c9                   	leave  
    9697:	c3                   	ret    

00009698 <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    9698:	55                   	push   %ebp
    9699:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    969b:	8b 45 10             	mov    0x10(%ebp),%eax
    969e:	8b 50 04             	mov    0x4(%eax),%edx
    96a1:	8b 45 10             	mov    0x10(%ebp),%eax
    96a4:	8b 00                	mov    (%eax),%eax
    96a6:	52                   	push   %edx
    96a7:	50                   	push   %eax
    96a8:	ff 75 0c             	pushl  0xc(%ebp)
    96ab:	ff 75 08             	pushl  0x8(%ebp)
    96ae:	e8 9c ff ff ff       	call   964f <lodepng_get_raw_size_lct>
    96b3:	83 c4 10             	add    $0x10,%esp
}
    96b6:	c9                   	leave  
    96b7:	c3                   	ret    

000096b8 <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    96b8:	55                   	push   %ebp
    96b9:	89 e5                	mov    %esp,%ebp
    96bb:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    96be:	8b 45 08             	mov    0x8(%ebp),%eax
    96c1:	c1 e8 03             	shr    $0x3,%eax
    96c4:	0f af 45 10          	imul   0x10(%ebp),%eax
    96c8:	8b 55 08             	mov    0x8(%ebp),%edx
    96cb:	83 e2 07             	and    $0x7,%edx
    96ce:	0f af 55 10          	imul   0x10(%ebp),%edx
    96d2:	83 c2 07             	add    $0x7,%edx
    96d5:	c1 ea 03             	shr    $0x3,%edx
    96d8:	01 d0                	add    %edx,%eax
    96da:	83 c0 01             	add    $0x1,%eax
    96dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    96e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    96e3:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    96e7:	c9                   	leave  
    96e8:	c3                   	ret    

000096e9 <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    96e9:	55                   	push   %ebp
    96ea:	89 e5                	mov    %esp,%ebp
    96ec:	53                   	push   %ebx
    96ed:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    96f0:	ff 75 10             	pushl  0x10(%ebp)
    96f3:	e8 61 fe ff ff       	call   9559 <lodepng_get_bpp>
    96f8:	83 c4 04             	add    $0x4,%esp
    96fb:	89 c3                	mov    %eax,%ebx
    96fd:	ff 75 14             	pushl  0x14(%ebp)
    9700:	e8 54 fe ff ff       	call   9559 <lodepng_get_bpp>
    9705:	83 c4 04             	add    $0x4,%esp
    9708:	39 c3                	cmp    %eax,%ebx
    970a:	76 0d                	jbe    9719 <lodepng_pixel_overflow+0x30>
    970c:	ff 75 10             	pushl  0x10(%ebp)
    970f:	e8 45 fe ff ff       	call   9559 <lodepng_get_bpp>
    9714:	83 c4 04             	add    $0x4,%esp
    9717:	eb 0b                	jmp    9724 <lodepng_pixel_overflow+0x3b>
    9719:	ff 75 14             	pushl  0x14(%ebp)
    971c:	e8 38 fe ff ff       	call   9559 <lodepng_get_bpp>
    9721:	83 c4 04             	add    $0x4,%esp
    9724:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    9727:	8b 55 0c             	mov    0xc(%ebp),%edx
    972a:	8b 45 08             	mov    0x8(%ebp),%eax
    972d:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    9730:	51                   	push   %ecx
    9731:	52                   	push   %edx
    9732:	50                   	push   %eax
    9733:	e8 e9 a3 ff ff       	call   3b21 <lodepng_mulofl>
    9738:	83 c4 0c             	add    $0xc,%esp
    973b:	85 c0                	test   %eax,%eax
    973d:	74 0a                	je     9749 <lodepng_pixel_overflow+0x60>
    973f:	b8 01 00 00 00       	mov    $0x1,%eax
    9744:	e9 b6 00 00 00       	jmp    97ff <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    9749:	8b 45 f4             	mov    -0xc(%ebp),%eax
    974c:	8d 55 f0             	lea    -0x10(%ebp),%edx
    974f:	52                   	push   %edx
    9750:	6a 08                	push   $0x8
    9752:	50                   	push   %eax
    9753:	e8 c9 a3 ff ff       	call   3b21 <lodepng_mulofl>
    9758:	83 c4 0c             	add    $0xc,%esp
    975b:	85 c0                	test   %eax,%eax
    975d:	74 0a                	je     9769 <lodepng_pixel_overflow+0x80>
    975f:	b8 01 00 00 00       	mov    $0x1,%eax
    9764:	e9 96 00 00 00       	jmp    97ff <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    9769:	8b 45 08             	mov    0x8(%ebp),%eax
    976c:	c1 e8 03             	shr    $0x3,%eax
    976f:	89 c2                	mov    %eax,%edx
    9771:	8d 45 ec             	lea    -0x14(%ebp),%eax
    9774:	50                   	push   %eax
    9775:	ff 75 f8             	pushl  -0x8(%ebp)
    9778:	52                   	push   %edx
    9779:	e8 a3 a3 ff ff       	call   3b21 <lodepng_mulofl>
    977e:	83 c4 0c             	add    $0xc,%esp
    9781:	85 c0                	test   %eax,%eax
    9783:	74 07                	je     978c <lodepng_pixel_overflow+0xa3>
    9785:	b8 01 00 00 00       	mov    $0x1,%eax
    978a:	eb 73                	jmp    97ff <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    978c:	8b 45 08             	mov    0x8(%ebp),%eax
    978f:	83 e0 07             	and    $0x7,%eax
    9792:	89 c2                	mov    %eax,%edx
    9794:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9797:	0f af c2             	imul   %edx,%eax
    979a:	83 c0 07             	add    $0x7,%eax
    979d:	c1 e8 03             	shr    $0x3,%eax
    97a0:	89 c1                	mov    %eax,%ecx
    97a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    97a5:	8d 55 ec             	lea    -0x14(%ebp),%edx
    97a8:	52                   	push   %edx
    97a9:	51                   	push   %ecx
    97aa:	50                   	push   %eax
    97ab:	e8 51 a3 ff ff       	call   3b01 <lodepng_addofl>
    97b0:	83 c4 0c             	add    $0xc,%esp
    97b3:	85 c0                	test   %eax,%eax
    97b5:	74 07                	je     97be <lodepng_pixel_overflow+0xd5>
    97b7:	b8 01 00 00 00       	mov    $0x1,%eax
    97bc:	eb 41                	jmp    97ff <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    97be:	8b 45 ec             	mov    -0x14(%ebp),%eax
    97c1:	8d 55 ec             	lea    -0x14(%ebp),%edx
    97c4:	52                   	push   %edx
    97c5:	6a 05                	push   $0x5
    97c7:	50                   	push   %eax
    97c8:	e8 34 a3 ff ff       	call   3b01 <lodepng_addofl>
    97cd:	83 c4 0c             	add    $0xc,%esp
    97d0:	85 c0                	test   %eax,%eax
    97d2:	74 07                	je     97db <lodepng_pixel_overflow+0xf2>
    97d4:	b8 01 00 00 00       	mov    $0x1,%eax
    97d9:	eb 24                	jmp    97ff <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    97db:	8b 55 0c             	mov    0xc(%ebp),%edx
    97de:	8b 45 ec             	mov    -0x14(%ebp),%eax
    97e1:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    97e4:	51                   	push   %ecx
    97e5:	52                   	push   %edx
    97e6:	50                   	push   %eax
    97e7:	e8 35 a3 ff ff       	call   3b21 <lodepng_mulofl>
    97ec:	83 c4 0c             	add    $0xc,%esp
    97ef:	85 c0                	test   %eax,%eax
    97f1:	74 07                	je     97fa <lodepng_pixel_overflow+0x111>
    97f3:	b8 01 00 00 00       	mov    $0x1,%eax
    97f8:	eb 05                	jmp    97ff <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    97fa:	b8 00 00 00 00       	mov    $0x0,%eax
}
    97ff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9802:	c9                   	leave  
    9803:	c3                   	ret    

00009804 <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    9804:	55                   	push   %ebp
    9805:	89 e5                	mov    %esp,%ebp
    9807:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    980a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9811:	eb 15                	jmp    9828 <LodePNGUnknownChunks_init+0x24>
    9813:	8b 45 08             	mov    0x8(%ebp),%eax
    9816:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9819:	83 c2 30             	add    $0x30,%edx
    981c:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    9823:	00 
    9824:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9828:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    982c:	75 e5                	jne    9813 <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    982e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9835:	eb 15                	jmp    984c <LodePNGUnknownChunks_init+0x48>
    9837:	8b 45 08             	mov    0x8(%ebp),%eax
    983a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    983d:	83 c2 34             	add    $0x34,%edx
    9840:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    9847:	00 
    9848:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    984c:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9850:	75 e5                	jne    9837 <LodePNGUnknownChunks_init+0x33>
}
    9852:	90                   	nop
    9853:	c9                   	leave  
    9854:	c3                   	ret    

00009855 <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    9855:	55                   	push   %ebp
    9856:	89 e5                	mov    %esp,%ebp
    9858:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    985b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9862:	eb 1d                	jmp    9881 <LodePNGUnknownChunks_cleanup+0x2c>
    9864:	8b 45 08             	mov    0x8(%ebp),%eax
    9867:	8b 55 f4             	mov    -0xc(%ebp),%edx
    986a:	83 c2 30             	add    $0x30,%edx
    986d:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    9871:	83 ec 0c             	sub    $0xc,%esp
    9874:	50                   	push   %eax
    9875:	e8 e4 a1 ff ff       	call   3a5e <lodepng_free>
    987a:	83 c4 10             	add    $0x10,%esp
    987d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9881:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    9885:	75 dd                	jne    9864 <LodePNGUnknownChunks_cleanup+0xf>
}
    9887:	90                   	nop
    9888:	c9                   	leave  
    9889:	c3                   	ret    

0000988a <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    988a:	55                   	push   %ebp
    988b:	89 e5                	mov    %esp,%ebp
    988d:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    9890:	83 ec 0c             	sub    $0xc,%esp
    9893:	ff 75 08             	pushl  0x8(%ebp)
    9896:	e8 ba ff ff ff       	call   9855 <LodePNGUnknownChunks_cleanup>
    989b:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    989e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    98a5:	e9 b7 00 00 00       	jmp    9961 <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    98aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    98ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
    98b0:	83 c2 34             	add    $0x34,%edx
    98b3:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    98b7:	8b 45 08             	mov    0x8(%ebp),%eax
    98ba:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    98bd:	83 c1 34             	add    $0x34,%ecx
    98c0:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    98c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    98c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    98ca:	83 c2 34             	add    $0x34,%edx
    98cd:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    98d1:	83 ec 0c             	sub    $0xc,%esp
    98d4:	50                   	push   %eax
    98d5:	e8 63 a1 ff ff       	call   3a3d <lodepng_malloc>
    98da:	83 c4 10             	add    $0x10,%esp
    98dd:	89 c1                	mov    %eax,%ecx
    98df:	8b 45 08             	mov    0x8(%ebp),%eax
    98e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    98e5:	83 c2 30             	add    $0x30,%edx
    98e8:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    98ec:	8b 45 08             	mov    0x8(%ebp),%eax
    98ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
    98f2:	83 c2 30             	add    $0x30,%edx
    98f5:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    98f9:	85 c0                	test   %eax,%eax
    98fb:	75 18                	jne    9915 <LodePNGUnknownChunks_copy+0x8b>
    98fd:	8b 45 08             	mov    0x8(%ebp),%eax
    9900:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9903:	83 c2 34             	add    $0x34,%edx
    9906:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    990a:	85 c0                	test   %eax,%eax
    990c:	74 07                	je     9915 <LodePNGUnknownChunks_copy+0x8b>
    990e:	b8 53 00 00 00       	mov    $0x53,%eax
    9913:	eb 5b                	jmp    9970 <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    9915:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    991c:	eb 2d                	jmp    994b <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    991e:	8b 45 08             	mov    0x8(%ebp),%eax
    9921:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9924:	83 c2 30             	add    $0x30,%edx
    9927:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    992b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    992e:	01 c2                	add    %eax,%edx
    9930:	8b 45 0c             	mov    0xc(%ebp),%eax
    9933:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9936:	83 c1 30             	add    $0x30,%ecx
    9939:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    993d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9940:	01 c8                	add    %ecx,%eax
    9942:	0f b6 00             	movzbl (%eax),%eax
    9945:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    9947:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    994b:	8b 45 0c             	mov    0xc(%ebp),%eax
    994e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9951:	83 c2 34             	add    $0x34,%edx
    9954:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9958:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    995b:	7f c1                	jg     991e <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    995d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9961:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    9965:	0f 85 3f ff ff ff    	jne    98aa <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    996b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9970:	c9                   	leave  
    9971:	c3                   	ret    

00009972 <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    9972:	55                   	push   %ebp
    9973:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    9975:	8b 45 08             	mov    0x8(%ebp),%eax
    9978:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    997f:	8b 45 08             	mov    0x8(%ebp),%eax
    9982:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    9989:	8b 45 08             	mov    0x8(%ebp),%eax
    998c:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    9993:	90                   	nop
    9994:	5d                   	pop    %ebp
    9995:	c3                   	ret    

00009996 <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    9996:	55                   	push   %ebp
    9997:	89 e5                	mov    %esp,%ebp
    9999:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    999c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    99a3:	eb 38                	jmp    99dd <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    99a5:	8b 45 08             	mov    0x8(%ebp),%eax
    99a8:	8b 40 40             	mov    0x40(%eax),%eax
    99ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
    99ae:	c1 e2 02             	shl    $0x2,%edx
    99b1:	01 d0                	add    %edx,%eax
    99b3:	83 ec 0c             	sub    $0xc,%esp
    99b6:	50                   	push   %eax
    99b7:	e8 75 a3 ff ff       	call   3d31 <string_cleanup>
    99bc:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    99bf:	8b 45 08             	mov    0x8(%ebp),%eax
    99c2:	8b 40 44             	mov    0x44(%eax),%eax
    99c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    99c8:	c1 e2 02             	shl    $0x2,%edx
    99cb:	01 d0                	add    %edx,%eax
    99cd:	83 ec 0c             	sub    $0xc,%esp
    99d0:	50                   	push   %eax
    99d1:	e8 5b a3 ff ff       	call   3d31 <string_cleanup>
    99d6:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    99d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    99dd:	8b 45 08             	mov    0x8(%ebp),%eax
    99e0:	8b 40 3c             	mov    0x3c(%eax),%eax
    99e3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    99e6:	75 bd                	jne    99a5 <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    99e8:	8b 45 08             	mov    0x8(%ebp),%eax
    99eb:	8b 40 40             	mov    0x40(%eax),%eax
    99ee:	83 ec 0c             	sub    $0xc,%esp
    99f1:	50                   	push   %eax
    99f2:	e8 67 a0 ff ff       	call   3a5e <lodepng_free>
    99f7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    99fa:	8b 45 08             	mov    0x8(%ebp),%eax
    99fd:	8b 40 44             	mov    0x44(%eax),%eax
    9a00:	83 ec 0c             	sub    $0xc,%esp
    9a03:	50                   	push   %eax
    9a04:	e8 55 a0 ff ff       	call   3a5e <lodepng_free>
    9a09:	83 c4 10             	add    $0x10,%esp
}
    9a0c:	90                   	nop
    9a0d:	c9                   	leave  
    9a0e:	c3                   	ret    

00009a0f <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9a0f:	55                   	push   %ebp
    9a10:	89 e5                	mov    %esp,%ebp
    9a12:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    9a15:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    9a1c:	8b 45 08             	mov    0x8(%ebp),%eax
    9a1f:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    9a26:	8b 45 08             	mov    0x8(%ebp),%eax
    9a29:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    9a30:	8b 45 08             	mov    0x8(%ebp),%eax
    9a33:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    9a3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9a41:	eb 42                	jmp    9a85 <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    9a43:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a46:	8b 40 44             	mov    0x44(%eax),%eax
    9a49:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9a4c:	c1 e2 02             	shl    $0x2,%edx
    9a4f:	01 d0                	add    %edx,%eax
    9a51:	8b 10                	mov    (%eax),%edx
    9a53:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a56:	8b 40 40             	mov    0x40(%eax),%eax
    9a59:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9a5c:	c1 e1 02             	shl    $0x2,%ecx
    9a5f:	01 c8                	add    %ecx,%eax
    9a61:	8b 00                	mov    (%eax),%eax
    9a63:	83 ec 04             	sub    $0x4,%esp
    9a66:	52                   	push   %edx
    9a67:	50                   	push   %eax
    9a68:	ff 75 08             	pushl  0x8(%ebp)
    9a6b:	e8 4d 01 00 00       	call   9bbd <lodepng_add_text>
    9a70:	83 c4 10             	add    $0x10,%esp
    9a73:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9a76:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9a7a:	74 05                	je     9a81 <LodePNGText_copy+0x72>
    9a7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9a7f:	eb 14                	jmp    9a95 <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    9a81:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9a85:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a88:	8b 40 3c             	mov    0x3c(%eax),%eax
    9a8b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9a8e:	75 b3                	jne    9a43 <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    9a90:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9a95:	c9                   	leave  
    9a96:	c3                   	ret    

00009a97 <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    9a97:	55                   	push   %ebp
    9a98:	89 e5                	mov    %esp,%ebp
    9a9a:	53                   	push   %ebx
    9a9b:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    9a9e:	8b 45 08             	mov    0x8(%ebp),%eax
    9aa1:	8b 40 3c             	mov    0x3c(%eax),%eax
    9aa4:	83 c0 01             	add    $0x1,%eax
    9aa7:	c1 e0 02             	shl    $0x2,%eax
    9aaa:	89 c2                	mov    %eax,%edx
    9aac:	8b 45 08             	mov    0x8(%ebp),%eax
    9aaf:	8b 40 40             	mov    0x40(%eax),%eax
    9ab2:	52                   	push   %edx
    9ab3:	50                   	push   %eax
    9ab4:	e8 9b 9f ff ff       	call   3a54 <lodepng_realloc>
    9ab9:	83 c4 08             	add    $0x8,%esp
    9abc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    9abf:	8b 45 08             	mov    0x8(%ebp),%eax
    9ac2:	8b 40 3c             	mov    0x3c(%eax),%eax
    9ac5:	83 c0 01             	add    $0x1,%eax
    9ac8:	c1 e0 02             	shl    $0x2,%eax
    9acb:	89 c2                	mov    %eax,%edx
    9acd:	8b 45 08             	mov    0x8(%ebp),%eax
    9ad0:	8b 40 44             	mov    0x44(%eax),%eax
    9ad3:	52                   	push   %edx
    9ad4:	50                   	push   %eax
    9ad5:	e8 7a 9f ff ff       	call   3a54 <lodepng_realloc>
    9ada:	83 c4 08             	add    $0x8,%esp
    9add:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    9ae0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9ae4:	74 09                	je     9aef <lodepng_add_text_sized+0x58>
    9ae6:	8b 45 08             	mov    0x8(%ebp),%eax
    9ae9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9aec:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    9aef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9af3:	74 09                	je     9afe <lodepng_add_text_sized+0x67>
    9af5:	8b 45 08             	mov    0x8(%ebp),%eax
    9af8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9afb:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    9afe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9b02:	74 06                	je     9b0a <lodepng_add_text_sized+0x73>
    9b04:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9b08:	75 0a                	jne    9b14 <lodepng_add_text_sized+0x7d>
    9b0a:	b8 53 00 00 00       	mov    $0x53,%eax
    9b0f:	e9 a4 00 00 00       	jmp    9bb8 <lodepng_add_text_sized+0x121>

  ++info->text_num;
    9b14:	8b 45 08             	mov    0x8(%ebp),%eax
    9b17:	8b 40 3c             	mov    0x3c(%eax),%eax
    9b1a:	8d 50 01             	lea    0x1(%eax),%edx
    9b1d:	8b 45 08             	mov    0x8(%ebp),%eax
    9b20:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    9b23:	8b 45 08             	mov    0x8(%ebp),%eax
    9b26:	8b 50 40             	mov    0x40(%eax),%edx
    9b29:	8b 45 08             	mov    0x8(%ebp),%eax
    9b2c:	8b 40 3c             	mov    0x3c(%eax),%eax
    9b2f:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9b34:	c1 e0 02             	shl    $0x2,%eax
    9b37:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9b3a:	83 ec 0c             	sub    $0xc,%esp
    9b3d:	ff 75 0c             	pushl  0xc(%ebp)
    9b40:	e8 54 a2 ff ff       	call   3d99 <alloc_string>
    9b45:	83 c4 10             	add    $0x10,%esp
    9b48:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    9b4a:	8b 45 08             	mov    0x8(%ebp),%eax
    9b4d:	8b 50 44             	mov    0x44(%eax),%edx
    9b50:	8b 45 08             	mov    0x8(%ebp),%eax
    9b53:	8b 40 3c             	mov    0x3c(%eax),%eax
    9b56:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9b5b:	c1 e0 02             	shl    $0x2,%eax
    9b5e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9b61:	83 ec 08             	sub    $0x8,%esp
    9b64:	ff 75 14             	pushl  0x14(%ebp)
    9b67:	ff 75 10             	pushl  0x10(%ebp)
    9b6a:	e8 e5 a1 ff ff       	call   3d54 <alloc_string_sized>
    9b6f:	83 c4 10             	add    $0x10,%esp
    9b72:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    9b74:	8b 45 08             	mov    0x8(%ebp),%eax
    9b77:	8b 50 40             	mov    0x40(%eax),%edx
    9b7a:	8b 45 08             	mov    0x8(%ebp),%eax
    9b7d:	8b 40 3c             	mov    0x3c(%eax),%eax
    9b80:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9b85:	c1 e0 02             	shl    $0x2,%eax
    9b88:	01 d0                	add    %edx,%eax
    9b8a:	8b 00                	mov    (%eax),%eax
    9b8c:	85 c0                	test   %eax,%eax
    9b8e:	74 1c                	je     9bac <lodepng_add_text_sized+0x115>
    9b90:	8b 45 08             	mov    0x8(%ebp),%eax
    9b93:	8b 50 44             	mov    0x44(%eax),%edx
    9b96:	8b 45 08             	mov    0x8(%ebp),%eax
    9b99:	8b 40 3c             	mov    0x3c(%eax),%eax
    9b9c:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9ba1:	c1 e0 02             	shl    $0x2,%eax
    9ba4:	01 d0                	add    %edx,%eax
    9ba6:	8b 00                	mov    (%eax),%eax
    9ba8:	85 c0                	test   %eax,%eax
    9baa:	75 07                	jne    9bb3 <lodepng_add_text_sized+0x11c>
    9bac:	b8 53 00 00 00       	mov    $0x53,%eax
    9bb1:	eb 05                	jmp    9bb8 <lodepng_add_text_sized+0x121>

  return 0;
    9bb3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9bb8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9bbb:	c9                   	leave  
    9bbc:	c3                   	ret    

00009bbd <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    9bbd:	55                   	push   %ebp
    9bbe:	89 e5                	mov    %esp,%ebp
    9bc0:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    9bc3:	ff 75 10             	pushl  0x10(%ebp)
    9bc6:	e8 0e 9f ff ff       	call   3ad9 <lodepng_strlen>
    9bcb:	83 c4 04             	add    $0x4,%esp
    9bce:	50                   	push   %eax
    9bcf:	ff 75 10             	pushl  0x10(%ebp)
    9bd2:	ff 75 0c             	pushl  0xc(%ebp)
    9bd5:	ff 75 08             	pushl  0x8(%ebp)
    9bd8:	e8 ba fe ff ff       	call   9a97 <lodepng_add_text_sized>
    9bdd:	83 c4 10             	add    $0x10,%esp
}
    9be0:	c9                   	leave  
    9be1:	c3                   	ret    

00009be2 <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    9be2:	55                   	push   %ebp
    9be3:	89 e5                	mov    %esp,%ebp
    9be5:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    9be8:	83 ec 0c             	sub    $0xc,%esp
    9beb:	ff 75 08             	pushl  0x8(%ebp)
    9bee:	e8 a3 fd ff ff       	call   9996 <LodePNGText_cleanup>
    9bf3:	83 c4 10             	add    $0x10,%esp
}
    9bf6:	90                   	nop
    9bf7:	c9                   	leave  
    9bf8:	c3                   	ret    

00009bf9 <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    9bf9:	55                   	push   %ebp
    9bfa:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    9bfc:	8b 45 08             	mov    0x8(%ebp),%eax
    9bff:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    9c06:	8b 45 08             	mov    0x8(%ebp),%eax
    9c09:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    9c10:	8b 45 08             	mov    0x8(%ebp),%eax
    9c13:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    9c1a:	8b 45 08             	mov    0x8(%ebp),%eax
    9c1d:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    9c24:	8b 45 08             	mov    0x8(%ebp),%eax
    9c27:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    9c2e:	90                   	nop
    9c2f:	5d                   	pop    %ebp
    9c30:	c3                   	ret    

00009c31 <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    9c31:	55                   	push   %ebp
    9c32:	89 e5                	mov    %esp,%ebp
    9c34:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    9c37:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9c3e:	eb 6c                	jmp    9cac <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    9c40:	8b 45 08             	mov    0x8(%ebp),%eax
    9c43:	8b 40 4c             	mov    0x4c(%eax),%eax
    9c46:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9c49:	c1 e2 02             	shl    $0x2,%edx
    9c4c:	01 d0                	add    %edx,%eax
    9c4e:	83 ec 0c             	sub    $0xc,%esp
    9c51:	50                   	push   %eax
    9c52:	e8 da a0 ff ff       	call   3d31 <string_cleanup>
    9c57:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    9c5a:	8b 45 08             	mov    0x8(%ebp),%eax
    9c5d:	8b 40 50             	mov    0x50(%eax),%eax
    9c60:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9c63:	c1 e2 02             	shl    $0x2,%edx
    9c66:	01 d0                	add    %edx,%eax
    9c68:	83 ec 0c             	sub    $0xc,%esp
    9c6b:	50                   	push   %eax
    9c6c:	e8 c0 a0 ff ff       	call   3d31 <string_cleanup>
    9c71:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    9c74:	8b 45 08             	mov    0x8(%ebp),%eax
    9c77:	8b 40 54             	mov    0x54(%eax),%eax
    9c7a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9c7d:	c1 e2 02             	shl    $0x2,%edx
    9c80:	01 d0                	add    %edx,%eax
    9c82:	83 ec 0c             	sub    $0xc,%esp
    9c85:	50                   	push   %eax
    9c86:	e8 a6 a0 ff ff       	call   3d31 <string_cleanup>
    9c8b:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    9c8e:	8b 45 08             	mov    0x8(%ebp),%eax
    9c91:	8b 40 58             	mov    0x58(%eax),%eax
    9c94:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9c97:	c1 e2 02             	shl    $0x2,%edx
    9c9a:	01 d0                	add    %edx,%eax
    9c9c:	83 ec 0c             	sub    $0xc,%esp
    9c9f:	50                   	push   %eax
    9ca0:	e8 8c a0 ff ff       	call   3d31 <string_cleanup>
    9ca5:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    9ca8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9cac:	8b 45 08             	mov    0x8(%ebp),%eax
    9caf:	8b 40 48             	mov    0x48(%eax),%eax
    9cb2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9cb5:	75 89                	jne    9c40 <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    9cb7:	8b 45 08             	mov    0x8(%ebp),%eax
    9cba:	8b 40 4c             	mov    0x4c(%eax),%eax
    9cbd:	83 ec 0c             	sub    $0xc,%esp
    9cc0:	50                   	push   %eax
    9cc1:	e8 98 9d ff ff       	call   3a5e <lodepng_free>
    9cc6:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    9cc9:	8b 45 08             	mov    0x8(%ebp),%eax
    9ccc:	8b 40 50             	mov    0x50(%eax),%eax
    9ccf:	83 ec 0c             	sub    $0xc,%esp
    9cd2:	50                   	push   %eax
    9cd3:	e8 86 9d ff ff       	call   3a5e <lodepng_free>
    9cd8:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    9cdb:	8b 45 08             	mov    0x8(%ebp),%eax
    9cde:	8b 40 54             	mov    0x54(%eax),%eax
    9ce1:	83 ec 0c             	sub    $0xc,%esp
    9ce4:	50                   	push   %eax
    9ce5:	e8 74 9d ff ff       	call   3a5e <lodepng_free>
    9cea:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    9ced:	8b 45 08             	mov    0x8(%ebp),%eax
    9cf0:	8b 40 58             	mov    0x58(%eax),%eax
    9cf3:	83 ec 0c             	sub    $0xc,%esp
    9cf6:	50                   	push   %eax
    9cf7:	e8 62 9d ff ff       	call   3a5e <lodepng_free>
    9cfc:	83 c4 10             	add    $0x10,%esp
}
    9cff:	90                   	nop
    9d00:	c9                   	leave  
    9d01:	c3                   	ret    

00009d02 <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9d02:	55                   	push   %ebp
    9d03:	89 e5                	mov    %esp,%ebp
    9d05:	56                   	push   %esi
    9d06:	53                   	push   %ebx
    9d07:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    9d0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    9d11:	8b 45 08             	mov    0x8(%ebp),%eax
    9d14:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    9d1b:	8b 45 08             	mov    0x8(%ebp),%eax
    9d1e:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    9d25:	8b 45 08             	mov    0x8(%ebp),%eax
    9d28:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    9d2f:	8b 45 08             	mov    0x8(%ebp),%eax
    9d32:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    9d39:	8b 45 08             	mov    0x8(%ebp),%eax
    9d3c:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    9d43:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9d4a:	eb 64                	jmp    9db0 <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    9d4c:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d4f:	8b 40 58             	mov    0x58(%eax),%eax
    9d52:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d55:	c1 e2 02             	shl    $0x2,%edx
    9d58:	01 d0                	add    %edx,%eax
    9d5a:	8b 18                	mov    (%eax),%ebx
    9d5c:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d5f:	8b 40 54             	mov    0x54(%eax),%eax
    9d62:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d65:	c1 e2 02             	shl    $0x2,%edx
    9d68:	01 d0                	add    %edx,%eax
    9d6a:	8b 08                	mov    (%eax),%ecx
    9d6c:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d6f:	8b 40 50             	mov    0x50(%eax),%eax
    9d72:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d75:	c1 e2 02             	shl    $0x2,%edx
    9d78:	01 d0                	add    %edx,%eax
    9d7a:	8b 10                	mov    (%eax),%edx
    9d7c:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d7f:	8b 40 4c             	mov    0x4c(%eax),%eax
    9d82:	8b 75 f4             	mov    -0xc(%ebp),%esi
    9d85:	c1 e6 02             	shl    $0x2,%esi
    9d88:	01 f0                	add    %esi,%eax
    9d8a:	8b 00                	mov    (%eax),%eax
    9d8c:	83 ec 0c             	sub    $0xc,%esp
    9d8f:	53                   	push   %ebx
    9d90:	51                   	push   %ecx
    9d91:	52                   	push   %edx
    9d92:	50                   	push   %eax
    9d93:	ff 75 08             	pushl  0x8(%ebp)
    9d96:	e8 e4 01 00 00       	call   9f7f <lodepng_add_itext>
    9d9b:	83 c4 20             	add    $0x20,%esp
    9d9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9da1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9da5:	74 05                	je     9dac <LodePNGIText_copy+0xaa>
    9da7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9daa:	eb 14                	jmp    9dc0 <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    9dac:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9db0:	8b 45 0c             	mov    0xc(%ebp),%eax
    9db3:	8b 40 48             	mov    0x48(%eax),%eax
    9db6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9db9:	75 91                	jne    9d4c <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    9dbb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9dc0:	8d 65 f8             	lea    -0x8(%ebp),%esp
    9dc3:	5b                   	pop    %ebx
    9dc4:	5e                   	pop    %esi
    9dc5:	5d                   	pop    %ebp
    9dc6:	c3                   	ret    

00009dc7 <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    9dc7:	55                   	push   %ebp
    9dc8:	89 e5                	mov    %esp,%ebp
    9dca:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    9dcd:	83 ec 0c             	sub    $0xc,%esp
    9dd0:	ff 75 08             	pushl  0x8(%ebp)
    9dd3:	e8 59 fe ff ff       	call   9c31 <LodePNGIText_cleanup>
    9dd8:	83 c4 10             	add    $0x10,%esp
}
    9ddb:	90                   	nop
    9ddc:	c9                   	leave  
    9ddd:	c3                   	ret    

00009dde <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    9dde:	55                   	push   %ebp
    9ddf:	89 e5                	mov    %esp,%ebp
    9de1:	53                   	push   %ebx
    9de2:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    9de5:	8b 45 08             	mov    0x8(%ebp),%eax
    9de8:	8b 40 48             	mov    0x48(%eax),%eax
    9deb:	83 c0 01             	add    $0x1,%eax
    9dee:	c1 e0 02             	shl    $0x2,%eax
    9df1:	89 c2                	mov    %eax,%edx
    9df3:	8b 45 08             	mov    0x8(%ebp),%eax
    9df6:	8b 40 4c             	mov    0x4c(%eax),%eax
    9df9:	52                   	push   %edx
    9dfa:	50                   	push   %eax
    9dfb:	e8 54 9c ff ff       	call   3a54 <lodepng_realloc>
    9e00:	83 c4 08             	add    $0x8,%esp
    9e03:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    9e06:	8b 45 08             	mov    0x8(%ebp),%eax
    9e09:	8b 40 48             	mov    0x48(%eax),%eax
    9e0c:	83 c0 01             	add    $0x1,%eax
    9e0f:	c1 e0 02             	shl    $0x2,%eax
    9e12:	89 c2                	mov    %eax,%edx
    9e14:	8b 45 08             	mov    0x8(%ebp),%eax
    9e17:	8b 40 50             	mov    0x50(%eax),%eax
    9e1a:	52                   	push   %edx
    9e1b:	50                   	push   %eax
    9e1c:	e8 33 9c ff ff       	call   3a54 <lodepng_realloc>
    9e21:	83 c4 08             	add    $0x8,%esp
    9e24:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    9e27:	8b 45 08             	mov    0x8(%ebp),%eax
    9e2a:	8b 40 48             	mov    0x48(%eax),%eax
    9e2d:	83 c0 01             	add    $0x1,%eax
    9e30:	c1 e0 02             	shl    $0x2,%eax
    9e33:	89 c2                	mov    %eax,%edx
    9e35:	8b 45 08             	mov    0x8(%ebp),%eax
    9e38:	8b 40 54             	mov    0x54(%eax),%eax
    9e3b:	52                   	push   %edx
    9e3c:	50                   	push   %eax
    9e3d:	e8 12 9c ff ff       	call   3a54 <lodepng_realloc>
    9e42:	83 c4 08             	add    $0x8,%esp
    9e45:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    9e48:	8b 45 08             	mov    0x8(%ebp),%eax
    9e4b:	8b 40 48             	mov    0x48(%eax),%eax
    9e4e:	83 c0 01             	add    $0x1,%eax
    9e51:	c1 e0 02             	shl    $0x2,%eax
    9e54:	89 c2                	mov    %eax,%edx
    9e56:	8b 45 08             	mov    0x8(%ebp),%eax
    9e59:	8b 40 58             	mov    0x58(%eax),%eax
    9e5c:	52                   	push   %edx
    9e5d:	50                   	push   %eax
    9e5e:	e8 f1 9b ff ff       	call   3a54 <lodepng_realloc>
    9e63:	83 c4 08             	add    $0x8,%esp
    9e66:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    9e69:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9e6d:	74 09                	je     9e78 <lodepng_add_itext_sized+0x9a>
    9e6f:	8b 45 08             	mov    0x8(%ebp),%eax
    9e72:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e75:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    9e78:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9e7c:	74 09                	je     9e87 <lodepng_add_itext_sized+0xa9>
    9e7e:	8b 45 08             	mov    0x8(%ebp),%eax
    9e81:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9e84:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    9e87:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9e8b:	74 09                	je     9e96 <lodepng_add_itext_sized+0xb8>
    9e8d:	8b 45 08             	mov    0x8(%ebp),%eax
    9e90:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9e93:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    9e96:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9e9a:	74 09                	je     9ea5 <lodepng_add_itext_sized+0xc7>
    9e9c:	8b 45 08             	mov    0x8(%ebp),%eax
    9e9f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9ea2:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    9ea5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9ea9:	74 12                	je     9ebd <lodepng_add_itext_sized+0xdf>
    9eab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9eaf:	74 0c                	je     9ebd <lodepng_add_itext_sized+0xdf>
    9eb1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9eb5:	74 06                	je     9ebd <lodepng_add_itext_sized+0xdf>
    9eb7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9ebb:	75 0a                	jne    9ec7 <lodepng_add_itext_sized+0xe9>
    9ebd:	b8 53 00 00 00       	mov    $0x53,%eax
    9ec2:	e9 b3 00 00 00       	jmp    9f7a <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    9ec7:	8b 45 08             	mov    0x8(%ebp),%eax
    9eca:	8b 40 48             	mov    0x48(%eax),%eax
    9ecd:	8d 50 01             	lea    0x1(%eax),%edx
    9ed0:	8b 45 08             	mov    0x8(%ebp),%eax
    9ed3:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    9ed6:	8b 45 08             	mov    0x8(%ebp),%eax
    9ed9:	8b 50 4c             	mov    0x4c(%eax),%edx
    9edc:	8b 45 08             	mov    0x8(%ebp),%eax
    9edf:	8b 40 48             	mov    0x48(%eax),%eax
    9ee2:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9ee7:	c1 e0 02             	shl    $0x2,%eax
    9eea:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9eed:	83 ec 0c             	sub    $0xc,%esp
    9ef0:	ff 75 0c             	pushl  0xc(%ebp)
    9ef3:	e8 a1 9e ff ff       	call   3d99 <alloc_string>
    9ef8:	83 c4 10             	add    $0x10,%esp
    9efb:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    9efd:	8b 45 08             	mov    0x8(%ebp),%eax
    9f00:	8b 50 50             	mov    0x50(%eax),%edx
    9f03:	8b 45 08             	mov    0x8(%ebp),%eax
    9f06:	8b 40 48             	mov    0x48(%eax),%eax
    9f09:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9f0e:	c1 e0 02             	shl    $0x2,%eax
    9f11:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9f14:	83 ec 0c             	sub    $0xc,%esp
    9f17:	ff 75 10             	pushl  0x10(%ebp)
    9f1a:	e8 7a 9e ff ff       	call   3d99 <alloc_string>
    9f1f:	83 c4 10             	add    $0x10,%esp
    9f22:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    9f24:	8b 45 08             	mov    0x8(%ebp),%eax
    9f27:	8b 50 54             	mov    0x54(%eax),%edx
    9f2a:	8b 45 08             	mov    0x8(%ebp),%eax
    9f2d:	8b 40 48             	mov    0x48(%eax),%eax
    9f30:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9f35:	c1 e0 02             	shl    $0x2,%eax
    9f38:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9f3b:	83 ec 0c             	sub    $0xc,%esp
    9f3e:	ff 75 14             	pushl  0x14(%ebp)
    9f41:	e8 53 9e ff ff       	call   3d99 <alloc_string>
    9f46:	83 c4 10             	add    $0x10,%esp
    9f49:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    9f4b:	8b 45 08             	mov    0x8(%ebp),%eax
    9f4e:	8b 50 58             	mov    0x58(%eax),%edx
    9f51:	8b 45 08             	mov    0x8(%ebp),%eax
    9f54:	8b 40 48             	mov    0x48(%eax),%eax
    9f57:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9f5c:	c1 e0 02             	shl    $0x2,%eax
    9f5f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9f62:	83 ec 08             	sub    $0x8,%esp
    9f65:	ff 75 1c             	pushl  0x1c(%ebp)
    9f68:	ff 75 18             	pushl  0x18(%ebp)
    9f6b:	e8 e4 9d ff ff       	call   3d54 <alloc_string_sized>
    9f70:	83 c4 10             	add    $0x10,%esp
    9f73:	89 03                	mov    %eax,(%ebx)

  return 0;
    9f75:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9f7a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9f7d:	c9                   	leave  
    9f7e:	c3                   	ret    

00009f7f <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    9f7f:	55                   	push   %ebp
    9f80:	89 e5                	mov    %esp,%ebp
    9f82:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    9f85:	ff 75 18             	pushl  0x18(%ebp)
    9f88:	e8 4c 9b ff ff       	call   3ad9 <lodepng_strlen>
    9f8d:	83 c4 04             	add    $0x4,%esp
    9f90:	83 ec 08             	sub    $0x8,%esp
    9f93:	50                   	push   %eax
    9f94:	ff 75 18             	pushl  0x18(%ebp)
    9f97:	ff 75 14             	pushl  0x14(%ebp)
    9f9a:	ff 75 10             	pushl  0x10(%ebp)
    9f9d:	ff 75 0c             	pushl  0xc(%ebp)
    9fa0:	ff 75 08             	pushl  0x8(%ebp)
    9fa3:	e8 36 fe ff ff       	call   9dde <lodepng_add_itext_sized>
    9fa8:	83 c4 20             	add    $0x20,%esp
}
    9fab:	c9                   	leave  
    9fac:	c3                   	ret    

00009fad <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9fad:	55                   	push   %ebp
    9fae:	89 e5                	mov    %esp,%ebp
    9fb0:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    9fb3:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    9fb7:	75 0a                	jne    9fc3 <lodepng_assign_icc+0x16>
    9fb9:	b8 64 00 00 00       	mov    $0x64,%eax
    9fbe:	e9 81 00 00 00       	jmp    a044 <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    9fc3:	83 ec 0c             	sub    $0xc,%esp
    9fc6:	ff 75 0c             	pushl  0xc(%ebp)
    9fc9:	e8 cb 9d ff ff       	call   3d99 <alloc_string>
    9fce:	83 c4 10             	add    $0x10,%esp
    9fd1:	89 c2                	mov    %eax,%edx
    9fd3:	8b 45 08             	mov    0x8(%ebp),%eax
    9fd6:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    9fdc:	8b 45 14             	mov    0x14(%ebp),%eax
    9fdf:	83 ec 0c             	sub    $0xc,%esp
    9fe2:	50                   	push   %eax
    9fe3:	e8 55 9a ff ff       	call   3a3d <lodepng_malloc>
    9fe8:	83 c4 10             	add    $0x10,%esp
    9feb:	89 c2                	mov    %eax,%edx
    9fed:	8b 45 08             	mov    0x8(%ebp),%eax
    9ff0:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    9ff6:	8b 45 08             	mov    0x8(%ebp),%eax
    9ff9:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9fff:	85 c0                	test   %eax,%eax
    a001:	74 0d                	je     a010 <lodepng_assign_icc+0x63>
    a003:	8b 45 08             	mov    0x8(%ebp),%eax
    a006:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    a00c:	85 c0                	test   %eax,%eax
    a00e:	75 07                	jne    a017 <lodepng_assign_icc+0x6a>
    a010:	b8 53 00 00 00       	mov    $0x53,%eax
    a015:	eb 2d                	jmp    a044 <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    a017:	8b 55 14             	mov    0x14(%ebp),%edx
    a01a:	8b 45 08             	mov    0x8(%ebp),%eax
    a01d:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    a023:	83 ec 04             	sub    $0x4,%esp
    a026:	52                   	push   %edx
    a027:	ff 75 10             	pushl  0x10(%ebp)
    a02a:	50                   	push   %eax
    a02b:	e8 4b 9a ff ff       	call   3a7b <lodepng_memcpy>
    a030:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    a033:	8b 45 08             	mov    0x8(%ebp),%eax
    a036:	8b 55 14             	mov    0x14(%ebp),%edx
    a039:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    a03f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a044:	c9                   	leave  
    a045:	c3                   	ret    

0000a046 <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    a046:	55                   	push   %ebp
    a047:	89 e5                	mov    %esp,%ebp
    a049:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    a04c:	8b 45 08             	mov    0x8(%ebp),%eax
    a04f:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    a055:	85 c0                	test   %eax,%eax
    a057:	74 0e                	je     a067 <lodepng_set_icc+0x21>
    a059:	83 ec 0c             	sub    $0xc,%esp
    a05c:	ff 75 08             	pushl  0x8(%ebp)
    a05f:	e8 26 00 00 00       	call   a08a <lodepng_clear_icc>
    a064:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    a067:	8b 45 08             	mov    0x8(%ebp),%eax
    a06a:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    a071:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    a074:	ff 75 14             	pushl  0x14(%ebp)
    a077:	ff 75 10             	pushl  0x10(%ebp)
    a07a:	ff 75 0c             	pushl  0xc(%ebp)
    a07d:	ff 75 08             	pushl  0x8(%ebp)
    a080:	e8 28 ff ff ff       	call   9fad <lodepng_assign_icc>
    a085:	83 c4 10             	add    $0x10,%esp
}
    a088:	c9                   	leave  
    a089:	c3                   	ret    

0000a08a <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    a08a:	55                   	push   %ebp
    a08b:	89 e5                	mov    %esp,%ebp
    a08d:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    a090:	8b 45 08             	mov    0x8(%ebp),%eax
    a093:	05 c0 00 00 00       	add    $0xc0,%eax
    a098:	83 ec 0c             	sub    $0xc,%esp
    a09b:	50                   	push   %eax
    a09c:	e8 90 9c ff ff       	call   3d31 <string_cleanup>
    a0a1:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    a0a4:	8b 45 08             	mov    0x8(%ebp),%eax
    a0a7:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    a0ad:	83 ec 0c             	sub    $0xc,%esp
    a0b0:	50                   	push   %eax
    a0b1:	e8 a8 99 ff ff       	call   3a5e <lodepng_free>
    a0b6:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    a0b9:	8b 45 08             	mov    0x8(%ebp),%eax
    a0bc:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    a0c3:	00 00 00 
  info->iccp_profile_size = 0;
    a0c6:	8b 45 08             	mov    0x8(%ebp),%eax
    a0c9:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    a0d0:	00 00 00 
  info->iccp_defined = 0;
    a0d3:	8b 45 08             	mov    0x8(%ebp),%eax
    a0d6:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    a0dd:	00 00 00 
}
    a0e0:	90                   	nop
    a0e1:	c9                   	leave  
    a0e2:	c3                   	ret    

0000a0e3 <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    a0e3:	55                   	push   %ebp
    a0e4:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    a0e6:	8b 45 08             	mov    0x8(%ebp),%eax
    a0e9:	83 c0 0c             	add    $0xc,%eax
    a0ec:	50                   	push   %eax
    a0ed:	e8 5a f0 ff ff       	call   914c <lodepng_color_mode_init>
    a0f2:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    a0f5:	8b 45 08             	mov    0x8(%ebp),%eax
    a0f8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    a0ff:	8b 45 08             	mov    0x8(%ebp),%eax
    a102:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    a108:	8b 45 08             	mov    0x8(%ebp),%eax
    a10b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    a112:	8b 45 08             	mov    0x8(%ebp),%eax
    a115:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    a11c:	8b 45 08             	mov    0x8(%ebp),%eax
    a11f:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    a126:	8b 45 08             	mov    0x8(%ebp),%eax
    a129:	8b 50 38             	mov    0x38(%eax),%edx
    a12c:	8b 45 08             	mov    0x8(%ebp),%eax
    a12f:	89 50 34             	mov    %edx,0x34(%eax)
    a132:	8b 45 08             	mov    0x8(%ebp),%eax
    a135:	8b 50 34             	mov    0x34(%eax),%edx
    a138:	8b 45 08             	mov    0x8(%ebp),%eax
    a13b:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    a13e:	ff 75 08             	pushl  0x8(%ebp)
    a141:	e8 2c f8 ff ff       	call   9972 <LodePNGText_init>
    a146:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    a149:	ff 75 08             	pushl  0x8(%ebp)
    a14c:	e8 a8 fa ff ff       	call   9bf9 <LodePNGIText_init>
    a151:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    a154:	8b 45 08             	mov    0x8(%ebp),%eax
    a157:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    a15e:	8b 45 08             	mov    0x8(%ebp),%eax
    a161:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    a168:	8b 45 08             	mov    0x8(%ebp),%eax
    a16b:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    a172:	00 00 00 
  info->chrm_defined = 0;
    a175:	8b 45 08             	mov    0x8(%ebp),%eax
    a178:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    a17f:	00 00 00 
  info->srgb_defined = 0;
    a182:	8b 45 08             	mov    0x8(%ebp),%eax
    a185:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    a18c:	00 00 00 
  info->iccp_defined = 0;
    a18f:	8b 45 08             	mov    0x8(%ebp),%eax
    a192:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    a199:	00 00 00 
  info->iccp_name = NULL;
    a19c:	8b 45 08             	mov    0x8(%ebp),%eax
    a19f:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    a1a6:	00 00 00 
  info->iccp_profile = NULL;
    a1a9:	8b 45 08             	mov    0x8(%ebp),%eax
    a1ac:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    a1b3:	00 00 00 

  LodePNGUnknownChunks_init(info);
    a1b6:	ff 75 08             	pushl  0x8(%ebp)
    a1b9:	e8 46 f6 ff ff       	call   9804 <LodePNGUnknownChunks_init>
    a1be:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    a1c1:	90                   	nop
    a1c2:	c9                   	leave  
    a1c3:	c3                   	ret    

0000a1c4 <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    a1c4:	55                   	push   %ebp
    a1c5:	89 e5                	mov    %esp,%ebp
    a1c7:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    a1ca:	8b 45 08             	mov    0x8(%ebp),%eax
    a1cd:	83 c0 0c             	add    $0xc,%eax
    a1d0:	83 ec 0c             	sub    $0xc,%esp
    a1d3:	50                   	push   %eax
    a1d4:	e8 66 f0 ff ff       	call   923f <lodepng_color_mode_cleanup>
    a1d9:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    a1dc:	83 ec 0c             	sub    $0xc,%esp
    a1df:	ff 75 08             	pushl  0x8(%ebp)
    a1e2:	e8 af f7 ff ff       	call   9996 <LodePNGText_cleanup>
    a1e7:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    a1ea:	83 ec 0c             	sub    $0xc,%esp
    a1ed:	ff 75 08             	pushl  0x8(%ebp)
    a1f0:	e8 3c fa ff ff       	call   9c31 <LodePNGIText_cleanup>
    a1f5:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    a1f8:	83 ec 0c             	sub    $0xc,%esp
    a1fb:	ff 75 08             	pushl  0x8(%ebp)
    a1fe:	e8 87 fe ff ff       	call   a08a <lodepng_clear_icc>
    a203:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    a206:	83 ec 0c             	sub    $0xc,%esp
    a209:	ff 75 08             	pushl  0x8(%ebp)
    a20c:	e8 44 f6 ff ff       	call   9855 <LodePNGUnknownChunks_cleanup>
    a211:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    a214:	90                   	nop
    a215:	c9                   	leave  
    a216:	c3                   	ret    

0000a217 <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    a217:	55                   	push   %ebp
    a218:	89 e5                	mov    %esp,%ebp
    a21a:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    a21d:	83 ec 0c             	sub    $0xc,%esp
    a220:	ff 75 08             	pushl  0x8(%ebp)
    a223:	e8 9c ff ff ff       	call   a1c4 <lodepng_info_cleanup>
    a228:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    a22b:	83 ec 04             	sub    $0x4,%esp
    a22e:	68 e4 00 00 00       	push   $0xe4
    a233:	ff 75 0c             	pushl  0xc(%ebp)
    a236:	ff 75 08             	pushl  0x8(%ebp)
    a239:	e8 3d 98 ff ff       	call   3a7b <lodepng_memcpy>
    a23e:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    a241:	8b 45 08             	mov    0x8(%ebp),%eax
    a244:	83 c0 0c             	add    $0xc,%eax
    a247:	83 ec 0c             	sub    $0xc,%esp
    a24a:	50                   	push   %eax
    a24b:	e8 fc ee ff ff       	call   914c <lodepng_color_mode_init>
    a250:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    a253:	8b 45 0c             	mov    0xc(%ebp),%eax
    a256:	8d 50 0c             	lea    0xc(%eax),%edx
    a259:	8b 45 08             	mov    0x8(%ebp),%eax
    a25c:	83 c0 0c             	add    $0xc,%eax
    a25f:	83 ec 08             	sub    $0x8,%esp
    a262:	52                   	push   %edx
    a263:	50                   	push   %eax
    a264:	e8 ed ef ff ff       	call   9256 <lodepng_color_mode_copy>
    a269:	83 c4 10             	add    $0x10,%esp
    a26c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    a26f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    a273:	74 08                	je     a27d <lodepng_info_copy+0x66>
    a275:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a278:	e9 b7 00 00 00       	jmp    a334 <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    a27d:	83 ec 08             	sub    $0x8,%esp
    a280:	ff 75 0c             	pushl  0xc(%ebp)
    a283:	ff 75 08             	pushl  0x8(%ebp)
    a286:	e8 84 f7 ff ff       	call   9a0f <LodePNGText_copy>
    a28b:	83 c4 10             	add    $0x10,%esp
    a28e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    a291:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a295:	74 08                	je     a29f <lodepng_info_copy+0x88>
    a297:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a29a:	e9 95 00 00 00       	jmp    a334 <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    a29f:	83 ec 08             	sub    $0x8,%esp
    a2a2:	ff 75 0c             	pushl  0xc(%ebp)
    a2a5:	ff 75 08             	pushl  0x8(%ebp)
    a2a8:	e8 55 fa ff ff       	call   9d02 <LodePNGIText_copy>
    a2ad:	83 c4 10             	add    $0x10,%esp
    a2b0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    a2b3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    a2b7:	74 05                	je     a2be <lodepng_info_copy+0xa7>
    a2b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a2bc:	eb 76                	jmp    a334 <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    a2be:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2c1:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    a2c7:	85 c0                	test   %eax,%eax
    a2c9:	74 37                	je     a302 <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    a2cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2ce:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    a2d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2d7:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    a2dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2e0:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    a2e6:	51                   	push   %ecx
    a2e7:	52                   	push   %edx
    a2e8:	50                   	push   %eax
    a2e9:	ff 75 08             	pushl  0x8(%ebp)
    a2ec:	e8 bc fc ff ff       	call   9fad <lodepng_assign_icc>
    a2f1:	83 c4 10             	add    $0x10,%esp
    a2f4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    a2f7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    a2fb:	74 05                	je     a302 <lodepng_info_copy+0xeb>
    a2fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a300:	eb 32                	jmp    a334 <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    a302:	83 ec 0c             	sub    $0xc,%esp
    a305:	ff 75 08             	pushl  0x8(%ebp)
    a308:	e8 f7 f4 ff ff       	call   9804 <LodePNGUnknownChunks_init>
    a30d:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    a310:	83 ec 08             	sub    $0x8,%esp
    a313:	ff 75 0c             	pushl  0xc(%ebp)
    a316:	ff 75 08             	pushl  0x8(%ebp)
    a319:	e8 6c f5 ff ff       	call   988a <LodePNGUnknownChunks_copy>
    a31e:	83 c4 10             	add    $0x10,%esp
    a321:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    a324:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    a328:	74 05                	je     a32f <lodepng_info_copy+0x118>
    a32a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a32d:	eb 05                	jmp    a334 <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    a32f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a334:	c9                   	leave  
    a335:	c3                   	ret    

0000a336 <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    a336:	55                   	push   %ebp
    a337:	89 e5                	mov    %esp,%ebp
    a339:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    a33c:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    a340:	74 14                	je     a356 <addColorBits+0x20>
    a342:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    a346:	75 07                	jne    a34f <addColorBits+0x19>
    a348:	b8 03 00 00 00       	mov    $0x3,%eax
    a34d:	eb 0c                	jmp    a35b <addColorBits+0x25>
    a34f:	b8 01 00 00 00       	mov    $0x1,%eax
    a354:	eb 05                	jmp    a35b <addColorBits+0x25>
    a356:	b8 07 00 00 00       	mov    $0x7,%eax
    a35b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    a35e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a361:	23 45 fc             	and    -0x4(%ebp),%eax
    a364:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    a367:	8b 45 10             	mov    0x10(%ebp),%eax
    a36a:	ba 01 00 00 00       	mov    $0x1,%edx
    a36f:	89 c1                	mov    %eax,%ecx
    a371:	d3 e2                	shl    %cl,%edx
    a373:	89 d0                	mov    %edx,%eax
    a375:	83 e8 01             	sub    $0x1,%eax
    a378:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    a37b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a37e:	2b 45 f8             	sub    -0x8(%ebp),%eax
    a381:	0f af 45 10          	imul   0x10(%ebp),%eax
    a385:	89 c1                	mov    %eax,%ecx
    a387:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    a38a:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a38e:	75 18                	jne    a3a8 <addColorBits+0x72>
    a390:	8b 45 0c             	mov    0xc(%ebp),%eax
    a393:	0f af 45 10          	imul   0x10(%ebp),%eax
    a397:	c1 e8 03             	shr    $0x3,%eax
    a39a:	89 c2                	mov    %eax,%edx
    a39c:	8b 45 08             	mov    0x8(%ebp),%eax
    a39f:	01 d0                	add    %edx,%eax
    a3a1:	8b 55 14             	mov    0x14(%ebp),%edx
    a3a4:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    a3a6:	eb 1e                	jmp    a3c6 <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    a3a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3ab:	0f af 45 10          	imul   0x10(%ebp),%eax
    a3af:	c1 e8 03             	shr    $0x3,%eax
    a3b2:	8b 55 08             	mov    0x8(%ebp),%edx
    a3b5:	01 c2                	add    %eax,%edx
    a3b7:	8b 4d 08             	mov    0x8(%ebp),%ecx
    a3ba:	01 c8                	add    %ecx,%eax
    a3bc:	0f b6 08             	movzbl (%eax),%ecx
    a3bf:	8b 45 14             	mov    0x14(%ebp),%eax
    a3c2:	09 c8                	or     %ecx,%eax
    a3c4:	88 02                	mov    %al,(%edx)
}
    a3c6:	90                   	nop
    a3c7:	c9                   	leave  
    a3c8:	c3                   	ret    

0000a3c9 <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    a3c9:	55                   	push   %ebp
    a3ca:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    a3cc:	8b 45 08             	mov    0x8(%ebp),%eax
    a3cf:	6a 40                	push   $0x40
    a3d1:	6a 00                	push   $0x0
    a3d3:	50                   	push   %eax
    a3d4:	e8 d5 96 ff ff       	call   3aae <lodepng_memset>
    a3d9:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    a3dc:	8b 45 08             	mov    0x8(%ebp),%eax
    a3df:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    a3e6:	90                   	nop
    a3e7:	c9                   	leave  
    a3e8:	c3                   	ret    

0000a3e9 <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    a3e9:	55                   	push   %ebp
    a3ea:	89 e5                	mov    %esp,%ebp
    a3ec:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    a3ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a3f6:	eb 3b                	jmp    a433 <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    a3f8:	8b 45 08             	mov    0x8(%ebp),%eax
    a3fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a3fe:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a401:	85 c0                	test   %eax,%eax
    a403:	74 2a                	je     a42f <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    a405:	8b 45 08             	mov    0x8(%ebp),%eax
    a408:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a40b:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a40e:	83 ec 0c             	sub    $0xc,%esp
    a411:	50                   	push   %eax
    a412:	e8 d2 ff ff ff       	call   a3e9 <color_tree_cleanup>
    a417:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    a41a:	8b 45 08             	mov    0x8(%ebp),%eax
    a41d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a420:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a423:	83 ec 0c             	sub    $0xc,%esp
    a426:	50                   	push   %eax
    a427:	e8 32 96 ff ff       	call   3a5e <lodepng_free>
    a42c:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    a42f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a433:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    a437:	75 bf                	jne    a3f8 <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    a439:	90                   	nop
    a43a:	c9                   	leave  
    a43b:	c3                   	ret    

0000a43c <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a43c:	55                   	push   %ebp
    a43d:	89 e5                	mov    %esp,%ebp
    a43f:	53                   	push   %ebx
    a440:	83 ec 20             	sub    $0x20,%esp
    a443:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a446:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a449:	8b 55 14             	mov    0x14(%ebp),%edx
    a44c:	8b 45 18             	mov    0x18(%ebp),%eax
    a44f:	88 5d e8             	mov    %bl,-0x18(%ebp)
    a452:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    a455:	88 55 e0             	mov    %dl,-0x20(%ebp)
    a458:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    a45b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    a462:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    a469:	eb 76                	jmp    a4e1 <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    a46b:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a46f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a472:	89 c1                	mov    %eax,%ecx
    a474:	d3 fa                	sar    %cl,%edx
    a476:	89 d0                	mov    %edx,%eax
    a478:	83 e0 01             	and    $0x1,%eax
    a47b:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a47e:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a482:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a485:	89 c1                	mov    %eax,%ecx
    a487:	d3 fa                	sar    %cl,%edx
    a489:	89 d0                	mov    %edx,%eax
    a48b:	83 e0 01             	and    $0x1,%eax
    a48e:	01 d8                	add    %ebx,%eax
    a490:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a493:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a497:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a49a:	89 c1                	mov    %eax,%ecx
    a49c:	d3 fa                	sar    %cl,%edx
    a49e:	89 d0                	mov    %edx,%eax
    a4a0:	83 e0 01             	and    $0x1,%eax
    a4a3:	01 d8                	add    %ebx,%eax
    a4a5:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a4a8:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a4ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a4af:	89 c1                	mov    %eax,%ecx
    a4b1:	d3 fa                	sar    %cl,%edx
    a4b3:	89 d0                	mov    %edx,%eax
    a4b5:	83 e0 01             	and    $0x1,%eax
    a4b8:	01 d8                	add    %ebx,%eax
    a4ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    a4bd:	8b 45 08             	mov    0x8(%ebp),%eax
    a4c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a4c3:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a4c6:	85 c0                	test   %eax,%eax
    a4c8:	75 07                	jne    a4d1 <color_tree_get+0x95>
    a4ca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a4cf:	eb 2a                	jmp    a4fb <color_tree_get+0xbf>
    else tree = tree->children[i];
    a4d1:	8b 45 08             	mov    0x8(%ebp),%eax
    a4d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a4d7:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a4da:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    a4dd:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    a4e1:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    a4e5:	7e 84                	jle    a46b <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    a4e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    a4eb:	74 08                	je     a4f5 <color_tree_get+0xb9>
    a4ed:	8b 45 08             	mov    0x8(%ebp),%eax
    a4f0:	8b 40 40             	mov    0x40(%eax),%eax
    a4f3:	eb 05                	jmp    a4fa <color_tree_get+0xbe>
    a4f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a4fa:	90                   	nop
}
    a4fb:	83 c4 20             	add    $0x20,%esp
    a4fe:	5b                   	pop    %ebx
    a4ff:	5d                   	pop    %ebp
    a500:	c3                   	ret    

0000a501 <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a501:	55                   	push   %ebp
    a502:	89 e5                	mov    %esp,%ebp
    a504:	53                   	push   %ebx
    a505:	83 ec 10             	sub    $0x10,%esp
    a508:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a50b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a50e:	8b 55 14             	mov    0x14(%ebp),%edx
    a511:	8b 45 18             	mov    0x18(%ebp),%eax
    a514:	88 5d f8             	mov    %bl,-0x8(%ebp)
    a517:	88 4d f4             	mov    %cl,-0xc(%ebp)
    a51a:	88 55 f0             	mov    %dl,-0x10(%ebp)
    a51d:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    a520:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    a524:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    a528:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    a52c:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    a530:	53                   	push   %ebx
    a531:	51                   	push   %ecx
    a532:	52                   	push   %edx
    a533:	50                   	push   %eax
    a534:	ff 75 08             	pushl  0x8(%ebp)
    a537:	e8 00 ff ff ff       	call   a43c <color_tree_get>
    a53c:	83 c4 14             	add    $0x14,%esp
    a53f:	f7 d0                	not    %eax
    a541:	c1 e8 1f             	shr    $0x1f,%eax
    a544:	0f b6 c0             	movzbl %al,%eax
}
    a547:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a54a:	c9                   	leave  
    a54b:	c3                   	ret    

0000a54c <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    a54c:	55                   	push   %ebp
    a54d:	89 e5                	mov    %esp,%ebp
    a54f:	53                   	push   %ebx
    a550:	83 ec 24             	sub    $0x24,%esp
    a553:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a556:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a559:	8b 55 14             	mov    0x14(%ebp),%edx
    a55c:	8b 45 18             	mov    0x18(%ebp),%eax
    a55f:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    a562:	88 4d e0             	mov    %cl,-0x20(%ebp)
    a565:	88 55 dc             	mov    %dl,-0x24(%ebp)
    a568:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    a56b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a572:	e9 b0 00 00 00       	jmp    a627 <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    a577:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a57b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a57e:	89 c1                	mov    %eax,%ecx
    a580:	d3 fa                	sar    %cl,%edx
    a582:	89 d0                	mov    %edx,%eax
    a584:	83 e0 01             	and    $0x1,%eax
    a587:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a58a:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a58e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a591:	89 c1                	mov    %eax,%ecx
    a593:	d3 fa                	sar    %cl,%edx
    a595:	89 d0                	mov    %edx,%eax
    a597:	83 e0 01             	and    $0x1,%eax
    a59a:	01 d8                	add    %ebx,%eax
    a59c:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a59f:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a5a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a5a6:	89 c1                	mov    %eax,%ecx
    a5a8:	d3 fa                	sar    %cl,%edx
    a5aa:	89 d0                	mov    %edx,%eax
    a5ac:	83 e0 01             	and    $0x1,%eax
    a5af:	01 d8                	add    %ebx,%eax
    a5b1:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a5b4:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    a5b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a5bb:	89 c1                	mov    %eax,%ecx
    a5bd:	d3 fa                	sar    %cl,%edx
    a5bf:	89 d0                	mov    %edx,%eax
    a5c1:	83 e0 01             	and    $0x1,%eax
    a5c4:	01 d8                	add    %ebx,%eax
    a5c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    a5c9:	8b 45 08             	mov    0x8(%ebp),%eax
    a5cc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a5cf:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a5d2:	85 c0                	test   %eax,%eax
    a5d4:	75 41                	jne    a617 <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    a5d6:	83 ec 0c             	sub    $0xc,%esp
    a5d9:	6a 44                	push   $0x44
    a5db:	e8 5d 94 ff ff       	call   3a3d <lodepng_malloc>
    a5e0:	83 c4 10             	add    $0x10,%esp
    a5e3:	89 c1                	mov    %eax,%ecx
    a5e5:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a5eb:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    a5ee:	8b 45 08             	mov    0x8(%ebp),%eax
    a5f1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a5f4:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a5f7:	85 c0                	test   %eax,%eax
    a5f9:	75 07                	jne    a602 <color_tree_add+0xb6>
    a5fb:	b8 53 00 00 00       	mov    $0x53,%eax
    a600:	eb 3d                	jmp    a63f <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    a602:	8b 45 08             	mov    0x8(%ebp),%eax
    a605:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a608:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a60b:	83 ec 0c             	sub    $0xc,%esp
    a60e:	50                   	push   %eax
    a60f:	e8 b5 fd ff ff       	call   a3c9 <color_tree_init>
    a614:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    a617:	8b 45 08             	mov    0x8(%ebp),%eax
    a61a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a61d:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a620:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    a623:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a627:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    a62b:	0f 8e 46 ff ff ff    	jle    a577 <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    a631:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a634:	8b 45 08             	mov    0x8(%ebp),%eax
    a637:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    a63a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a63f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a642:	c9                   	leave  
    a643:	c3                   	ret    

0000a644 <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a644:	55                   	push   %ebp
    a645:	89 e5                	mov    %esp,%ebp
    a647:	53                   	push   %ebx
    a648:	83 ec 20             	sub    $0x20,%esp
    a64b:	8b 5d 18             	mov    0x18(%ebp),%ebx
    a64e:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    a651:	8b 55 20             	mov    0x20(%ebp),%edx
    a654:	8b 45 24             	mov    0x24(%ebp),%eax
    a657:	88 5d e8             	mov    %bl,-0x18(%ebp)
    a65a:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    a65d:	88 55 e0             	mov    %dl,-0x20(%ebp)
    a660:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a663:	8b 45 10             	mov    0x10(%ebp),%eax
    a666:	8b 00                	mov    (%eax),%eax
    a668:	85 c0                	test   %eax,%eax
    a66a:	0f 85 ad 00 00 00    	jne    a71d <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a670:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a674:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    a677:	8b 45 10             	mov    0x10(%ebp),%eax
    a67a:	8b 40 04             	mov    0x4(%eax),%eax
    a67d:	83 f8 08             	cmp    $0x8,%eax
    a680:	75 13                	jne    a695 <rgba8ToPixel+0x51>
    a682:	8b 55 0c             	mov    0xc(%ebp),%edx
    a685:	8b 45 08             	mov    0x8(%ebp),%eax
    a688:	01 c2                	add    %eax,%edx
    a68a:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    a68e:	88 02                	mov    %al,(%edx)
    a690:	e9 b4 03 00 00       	jmp    aa49 <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    a695:	8b 45 10             	mov    0x10(%ebp),%eax
    a698:	8b 40 04             	mov    0x4(%eax),%eax
    a69b:	83 f8 10             	cmp    $0x10,%eax
    a69e:	75 2a                	jne    a6ca <rgba8ToPixel+0x86>
    a6a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6a3:	01 c0                	add    %eax,%eax
    a6a5:	89 c2                	mov    %eax,%edx
    a6a7:	8b 45 08             	mov    0x8(%ebp),%eax
    a6aa:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a6ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6b0:	01 c0                	add    %eax,%eax
    a6b2:	8d 50 01             	lea    0x1(%eax),%edx
    a6b5:	8b 45 08             	mov    0x8(%ebp),%eax
    a6b8:	01 d0                	add    %edx,%eax
    a6ba:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a6be:	88 10                	mov    %dl,(%eax)
    a6c0:	0f b6 00             	movzbl (%eax),%eax
    a6c3:	88 01                	mov    %al,(%ecx)
    a6c5:	e9 7f 03 00 00       	jmp    aa49 <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    a6ca:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a6ce:	8b 45 10             	mov    0x10(%ebp),%eax
    a6d1:	8b 40 04             	mov    0x4(%eax),%eax
    a6d4:	b9 08 00 00 00       	mov    $0x8,%ecx
    a6d9:	29 c1                	sub    %eax,%ecx
    a6db:	89 c8                	mov    %ecx,%eax
    a6dd:	89 c1                	mov    %eax,%ecx
    a6df:	d3 ea                	shr    %cl,%edx
    a6e1:	89 d0                	mov    %edx,%eax
    a6e3:	89 c2                	mov    %eax,%edx
    a6e5:	8b 45 10             	mov    0x10(%ebp),%eax
    a6e8:	8b 40 04             	mov    0x4(%eax),%eax
    a6eb:	bb 01 00 00 00       	mov    $0x1,%ebx
    a6f0:	89 c1                	mov    %eax,%ecx
    a6f2:	d3 e3                	shl    %cl,%ebx
    a6f4:	89 d8                	mov    %ebx,%eax
    a6f6:	83 e8 01             	sub    $0x1,%eax
    a6f9:	21 d0                	and    %edx,%eax
    a6fb:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    a6fe:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a702:	8b 45 10             	mov    0x10(%ebp),%eax
    a705:	8b 40 04             	mov    0x4(%eax),%eax
    a708:	52                   	push   %edx
    a709:	50                   	push   %eax
    a70a:	ff 75 0c             	pushl  0xc(%ebp)
    a70d:	ff 75 08             	pushl  0x8(%ebp)
    a710:	e8 21 fc ff ff       	call   a336 <addColorBits>
    a715:	83 c4 10             	add    $0x10,%esp
    a718:	e9 2c 03 00 00       	jmp    aa49 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    a71d:	8b 45 10             	mov    0x10(%ebp),%eax
    a720:	8b 00                	mov    (%eax),%eax
    a722:	83 f8 02             	cmp    $0x2,%eax
    a725:	0f 85 ee 00 00 00    	jne    a819 <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    a72b:	8b 45 10             	mov    0x10(%ebp),%eax
    a72e:	8b 40 04             	mov    0x4(%eax),%eax
    a731:	83 f8 08             	cmp    $0x8,%eax
    a734:	75 49                	jne    a77f <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    a736:	8b 55 0c             	mov    0xc(%ebp),%edx
    a739:	89 d0                	mov    %edx,%eax
    a73b:	01 c0                	add    %eax,%eax
    a73d:	01 d0                	add    %edx,%eax
    a73f:	89 c2                	mov    %eax,%edx
    a741:	8b 45 08             	mov    0x8(%ebp),%eax
    a744:	01 c2                	add    %eax,%edx
    a746:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a74a:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    a74c:	8b 55 0c             	mov    0xc(%ebp),%edx
    a74f:	89 d0                	mov    %edx,%eax
    a751:	01 c0                	add    %eax,%eax
    a753:	01 d0                	add    %edx,%eax
    a755:	8d 50 01             	lea    0x1(%eax),%edx
    a758:	8b 45 08             	mov    0x8(%ebp),%eax
    a75b:	01 c2                	add    %eax,%edx
    a75d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a761:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a763:	8b 55 0c             	mov    0xc(%ebp),%edx
    a766:	89 d0                	mov    %edx,%eax
    a768:	01 c0                	add    %eax,%eax
    a76a:	01 d0                	add    %edx,%eax
    a76c:	8d 50 02             	lea    0x2(%eax),%edx
    a76f:	8b 45 08             	mov    0x8(%ebp),%eax
    a772:	01 c2                	add    %eax,%edx
    a774:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a778:	88 02                	mov    %al,(%edx)
    a77a:	e9 ca 02 00 00       	jmp    aa49 <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a77f:	8b 55 0c             	mov    0xc(%ebp),%edx
    a782:	89 d0                	mov    %edx,%eax
    a784:	01 c0                	add    %eax,%eax
    a786:	01 d0                	add    %edx,%eax
    a788:	01 c0                	add    %eax,%eax
    a78a:	89 c2                	mov    %eax,%edx
    a78c:	8b 45 08             	mov    0x8(%ebp),%eax
    a78f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a792:	8b 55 0c             	mov    0xc(%ebp),%edx
    a795:	89 d0                	mov    %edx,%eax
    a797:	01 c0                	add    %eax,%eax
    a799:	01 d0                	add    %edx,%eax
    a79b:	01 c0                	add    %eax,%eax
    a79d:	8d 50 01             	lea    0x1(%eax),%edx
    a7a0:	8b 45 08             	mov    0x8(%ebp),%eax
    a7a3:	01 d0                	add    %edx,%eax
    a7a5:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a7a9:	88 10                	mov    %dl,(%eax)
    a7ab:	0f b6 00             	movzbl (%eax),%eax
    a7ae:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a7b0:	8b 55 0c             	mov    0xc(%ebp),%edx
    a7b3:	89 d0                	mov    %edx,%eax
    a7b5:	01 c0                	add    %eax,%eax
    a7b7:	01 d0                	add    %edx,%eax
    a7b9:	01 c0                	add    %eax,%eax
    a7bb:	8d 50 02             	lea    0x2(%eax),%edx
    a7be:	8b 45 08             	mov    0x8(%ebp),%eax
    a7c1:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a7c4:	8b 55 0c             	mov    0xc(%ebp),%edx
    a7c7:	89 d0                	mov    %edx,%eax
    a7c9:	01 c0                	add    %eax,%eax
    a7cb:	01 d0                	add    %edx,%eax
    a7cd:	01 c0                	add    %eax,%eax
    a7cf:	8d 50 03             	lea    0x3(%eax),%edx
    a7d2:	8b 45 08             	mov    0x8(%ebp),%eax
    a7d5:	01 d0                	add    %edx,%eax
    a7d7:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a7db:	88 10                	mov    %dl,(%eax)
    a7dd:	0f b6 00             	movzbl (%eax),%eax
    a7e0:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a7e2:	8b 55 0c             	mov    0xc(%ebp),%edx
    a7e5:	89 d0                	mov    %edx,%eax
    a7e7:	01 c0                	add    %eax,%eax
    a7e9:	01 d0                	add    %edx,%eax
    a7eb:	01 c0                	add    %eax,%eax
    a7ed:	8d 50 04             	lea    0x4(%eax),%edx
    a7f0:	8b 45 08             	mov    0x8(%ebp),%eax
    a7f3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a7f6:	8b 55 0c             	mov    0xc(%ebp),%edx
    a7f9:	89 d0                	mov    %edx,%eax
    a7fb:	01 c0                	add    %eax,%eax
    a7fd:	01 d0                	add    %edx,%eax
    a7ff:	01 c0                	add    %eax,%eax
    a801:	8d 50 05             	lea    0x5(%eax),%edx
    a804:	8b 45 08             	mov    0x8(%ebp),%eax
    a807:	01 d0                	add    %edx,%eax
    a809:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a80d:	88 10                	mov    %dl,(%eax)
    a80f:	0f b6 00             	movzbl (%eax),%eax
    a812:	88 01                	mov    %al,(%ecx)
    a814:	e9 30 02 00 00       	jmp    aa49 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a819:	8b 45 10             	mov    0x10(%ebp),%eax
    a81c:	8b 00                	mov    (%eax),%eax
    a81e:	83 f8 03             	cmp    $0x3,%eax
    a821:	75 6d                	jne    a890 <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a823:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a827:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a82b:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a82f:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a833:	53                   	push   %ebx
    a834:	51                   	push   %ecx
    a835:	52                   	push   %edx
    a836:	50                   	push   %eax
    a837:	ff 75 14             	pushl  0x14(%ebp)
    a83a:	e8 fd fb ff ff       	call   a43c <color_tree_get>
    a83f:	83 c4 14             	add    $0x14,%esp
    a842:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a845:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a849:	79 0a                	jns    a855 <rgba8ToPixel+0x211>
    a84b:	b8 52 00 00 00       	mov    $0x52,%eax
    a850:	e9 f9 01 00 00       	jmp    aa4e <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a855:	8b 45 10             	mov    0x10(%ebp),%eax
    a858:	8b 40 04             	mov    0x4(%eax),%eax
    a85b:	83 f8 08             	cmp    $0x8,%eax
    a85e:	75 12                	jne    a872 <rgba8ToPixel+0x22e>
    a860:	8b 55 0c             	mov    0xc(%ebp),%edx
    a863:	8b 45 08             	mov    0x8(%ebp),%eax
    a866:	01 d0                	add    %edx,%eax
    a868:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a86b:	88 10                	mov    %dl,(%eax)
    a86d:	e9 d7 01 00 00       	jmp    aa49 <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a872:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a875:	8b 45 10             	mov    0x10(%ebp),%eax
    a878:	8b 40 04             	mov    0x4(%eax),%eax
    a87b:	52                   	push   %edx
    a87c:	50                   	push   %eax
    a87d:	ff 75 0c             	pushl  0xc(%ebp)
    a880:	ff 75 08             	pushl  0x8(%ebp)
    a883:	e8 ae fa ff ff       	call   a336 <addColorBits>
    a888:	83 c4 10             	add    $0x10,%esp
    a88b:	e9 b9 01 00 00       	jmp    aa49 <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a890:	8b 45 10             	mov    0x10(%ebp),%eax
    a893:	8b 00                	mov    (%eax),%eax
    a895:	83 f8 04             	cmp    $0x4,%eax
    a898:	0f 85 9f 00 00 00    	jne    a93d <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a89e:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a8a2:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a8a5:	8b 45 10             	mov    0x10(%ebp),%eax
    a8a8:	8b 40 04             	mov    0x4(%eax),%eax
    a8ab:	83 f8 08             	cmp    $0x8,%eax
    a8ae:	75 2a                	jne    a8da <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a8b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8b3:	01 c0                	add    %eax,%eax
    a8b5:	89 c2                	mov    %eax,%edx
    a8b7:	8b 45 08             	mov    0x8(%ebp),%eax
    a8ba:	01 c2                	add    %eax,%edx
    a8bc:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a8c0:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a8c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8c5:	01 c0                	add    %eax,%eax
    a8c7:	8d 50 01             	lea    0x1(%eax),%edx
    a8ca:	8b 45 08             	mov    0x8(%ebp),%eax
    a8cd:	01 c2                	add    %eax,%edx
    a8cf:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a8d3:	88 02                	mov    %al,(%edx)
    a8d5:	e9 6f 01 00 00       	jmp    aa49 <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a8da:	8b 45 10             	mov    0x10(%ebp),%eax
    a8dd:	8b 40 04             	mov    0x4(%eax),%eax
    a8e0:	83 f8 10             	cmp    $0x10,%eax
    a8e3:	0f 85 60 01 00 00    	jne    aa49 <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a8e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8ec:	c1 e0 02             	shl    $0x2,%eax
    a8ef:	89 c2                	mov    %eax,%edx
    a8f1:	8b 45 08             	mov    0x8(%ebp),%eax
    a8f4:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a8f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8fa:	c1 e0 02             	shl    $0x2,%eax
    a8fd:	8d 50 01             	lea    0x1(%eax),%edx
    a900:	8b 45 08             	mov    0x8(%ebp),%eax
    a903:	01 d0                	add    %edx,%eax
    a905:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a909:	88 10                	mov    %dl,(%eax)
    a90b:	0f b6 00             	movzbl (%eax),%eax
    a90e:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a910:	8b 45 0c             	mov    0xc(%ebp),%eax
    a913:	c1 e0 02             	shl    $0x2,%eax
    a916:	8d 50 02             	lea    0x2(%eax),%edx
    a919:	8b 45 08             	mov    0x8(%ebp),%eax
    a91c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a91f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a922:	c1 e0 02             	shl    $0x2,%eax
    a925:	8d 50 03             	lea    0x3(%eax),%edx
    a928:	8b 45 08             	mov    0x8(%ebp),%eax
    a92b:	01 d0                	add    %edx,%eax
    a92d:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a931:	88 10                	mov    %dl,(%eax)
    a933:	0f b6 00             	movzbl (%eax),%eax
    a936:	88 01                	mov    %al,(%ecx)
    a938:	e9 0c 01 00 00       	jmp    aa49 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a93d:	8b 45 10             	mov    0x10(%ebp),%eax
    a940:	8b 00                	mov    (%eax),%eax
    a942:	83 f8 06             	cmp    $0x6,%eax
    a945:	0f 85 fe 00 00 00    	jne    aa49 <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a94b:	8b 45 10             	mov    0x10(%ebp),%eax
    a94e:	8b 40 04             	mov    0x4(%eax),%eax
    a951:	83 f8 08             	cmp    $0x8,%eax
    a954:	75 54                	jne    a9aa <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a956:	8b 45 0c             	mov    0xc(%ebp),%eax
    a959:	c1 e0 02             	shl    $0x2,%eax
    a95c:	89 c2                	mov    %eax,%edx
    a95e:	8b 45 08             	mov    0x8(%ebp),%eax
    a961:	01 c2                	add    %eax,%edx
    a963:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a967:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a969:	8b 45 0c             	mov    0xc(%ebp),%eax
    a96c:	c1 e0 02             	shl    $0x2,%eax
    a96f:	8d 50 01             	lea    0x1(%eax),%edx
    a972:	8b 45 08             	mov    0x8(%ebp),%eax
    a975:	01 c2                	add    %eax,%edx
    a977:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a97b:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a97d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a980:	c1 e0 02             	shl    $0x2,%eax
    a983:	8d 50 02             	lea    0x2(%eax),%edx
    a986:	8b 45 08             	mov    0x8(%ebp),%eax
    a989:	01 c2                	add    %eax,%edx
    a98b:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a98f:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a991:	8b 45 0c             	mov    0xc(%ebp),%eax
    a994:	c1 e0 02             	shl    $0x2,%eax
    a997:	8d 50 03             	lea    0x3(%eax),%edx
    a99a:	8b 45 08             	mov    0x8(%ebp),%eax
    a99d:	01 c2                	add    %eax,%edx
    a99f:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a9a3:	88 02                	mov    %al,(%edx)
    a9a5:	e9 9f 00 00 00       	jmp    aa49 <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a9aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9ad:	c1 e0 03             	shl    $0x3,%eax
    a9b0:	89 c2                	mov    %eax,%edx
    a9b2:	8b 45 08             	mov    0x8(%ebp),%eax
    a9b5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a9b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9bb:	c1 e0 03             	shl    $0x3,%eax
    a9be:	8d 50 01             	lea    0x1(%eax),%edx
    a9c1:	8b 45 08             	mov    0x8(%ebp),%eax
    a9c4:	01 d0                	add    %edx,%eax
    a9c6:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a9ca:	88 10                	mov    %dl,(%eax)
    a9cc:	0f b6 00             	movzbl (%eax),%eax
    a9cf:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a9d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9d4:	c1 e0 03             	shl    $0x3,%eax
    a9d7:	8d 50 02             	lea    0x2(%eax),%edx
    a9da:	8b 45 08             	mov    0x8(%ebp),%eax
    a9dd:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a9e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9e3:	c1 e0 03             	shl    $0x3,%eax
    a9e6:	8d 50 03             	lea    0x3(%eax),%edx
    a9e9:	8b 45 08             	mov    0x8(%ebp),%eax
    a9ec:	01 d0                	add    %edx,%eax
    a9ee:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a9f2:	88 10                	mov    %dl,(%eax)
    a9f4:	0f b6 00             	movzbl (%eax),%eax
    a9f7:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a9f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9fc:	c1 e0 03             	shl    $0x3,%eax
    a9ff:	8d 50 04             	lea    0x4(%eax),%edx
    aa02:	8b 45 08             	mov    0x8(%ebp),%eax
    aa05:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    aa08:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa0b:	c1 e0 03             	shl    $0x3,%eax
    aa0e:	8d 50 05             	lea    0x5(%eax),%edx
    aa11:	8b 45 08             	mov    0x8(%ebp),%eax
    aa14:	01 d0                	add    %edx,%eax
    aa16:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    aa1a:	88 10                	mov    %dl,(%eax)
    aa1c:	0f b6 00             	movzbl (%eax),%eax
    aa1f:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    aa21:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa24:	c1 e0 03             	shl    $0x3,%eax
    aa27:	8d 50 06             	lea    0x6(%eax),%edx
    aa2a:	8b 45 08             	mov    0x8(%ebp),%eax
    aa2d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    aa30:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa33:	c1 e0 03             	shl    $0x3,%eax
    aa36:	8d 50 07             	lea    0x7(%eax),%edx
    aa39:	8b 45 08             	mov    0x8(%ebp),%eax
    aa3c:	01 d0                	add    %edx,%eax
    aa3e:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    aa42:	88 10                	mov    %dl,(%eax)
    aa44:	0f b6 00             	movzbl (%eax),%eax
    aa47:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    aa49:	b8 00 00 00 00       	mov    $0x0,%eax
}
    aa4e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    aa51:	c9                   	leave  
    aa52:	c3                   	ret    

0000aa53 <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    aa53:	55                   	push   %ebp
    aa54:	89 e5                	mov    %esp,%ebp
    aa56:	53                   	push   %ebx
    aa57:	83 ec 20             	sub    $0x20,%esp
    aa5a:	8b 5d 14             	mov    0x14(%ebp),%ebx
    aa5d:	8b 4d 18             	mov    0x18(%ebp),%ecx
    aa60:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aa63:	8b 45 20             	mov    0x20(%ebp),%eax
    aa66:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    aa6a:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    aa6e:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    aa72:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    aa76:	8b 45 10             	mov    0x10(%ebp),%eax
    aa79:	8b 00                	mov    (%eax),%eax
    aa7b:	85 c0                	test   %eax,%eax
    aa7d:	75 36                	jne    aab5 <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    aa7f:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    aa83:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    aa87:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa8a:	01 c0                	add    %eax,%eax
    aa8c:	89 c2                	mov    %eax,%edx
    aa8e:	8b 45 08             	mov    0x8(%ebp),%eax
    aa91:	01 d0                	add    %edx,%eax
    aa93:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    aa97:	66 c1 ea 08          	shr    $0x8,%dx
    aa9b:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    aa9d:	8b 45 0c             	mov    0xc(%ebp),%eax
    aaa0:	01 c0                	add    %eax,%eax
    aaa2:	8d 50 01             	lea    0x1(%eax),%edx
    aaa5:	8b 45 08             	mov    0x8(%ebp),%eax
    aaa8:	01 d0                	add    %edx,%eax
    aaaa:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    aaae:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    aab0:	e9 df 01 00 00       	jmp    ac94 <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    aab5:	8b 45 10             	mov    0x10(%ebp),%eax
    aab8:	8b 00                	mov    (%eax),%eax
    aaba:	83 f8 02             	cmp    $0x2,%eax
    aabd:	0f 85 a6 00 00 00    	jne    ab69 <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    aac3:	8b 55 0c             	mov    0xc(%ebp),%edx
    aac6:	89 d0                	mov    %edx,%eax
    aac8:	01 c0                	add    %eax,%eax
    aaca:	01 d0                	add    %edx,%eax
    aacc:	01 c0                	add    %eax,%eax
    aace:	89 c2                	mov    %eax,%edx
    aad0:	8b 45 08             	mov    0x8(%ebp),%eax
    aad3:	01 d0                	add    %edx,%eax
    aad5:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    aad9:	66 c1 ea 08          	shr    $0x8,%dx
    aadd:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    aadf:	8b 55 0c             	mov    0xc(%ebp),%edx
    aae2:	89 d0                	mov    %edx,%eax
    aae4:	01 c0                	add    %eax,%eax
    aae6:	01 d0                	add    %edx,%eax
    aae8:	01 c0                	add    %eax,%eax
    aaea:	8d 50 01             	lea    0x1(%eax),%edx
    aaed:	8b 45 08             	mov    0x8(%ebp),%eax
    aaf0:	01 d0                	add    %edx,%eax
    aaf2:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    aaf6:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    aaf8:	8b 55 0c             	mov    0xc(%ebp),%edx
    aafb:	89 d0                	mov    %edx,%eax
    aafd:	01 c0                	add    %eax,%eax
    aaff:	01 d0                	add    %edx,%eax
    ab01:	01 c0                	add    %eax,%eax
    ab03:	8d 50 02             	lea    0x2(%eax),%edx
    ab06:	8b 45 08             	mov    0x8(%ebp),%eax
    ab09:	01 d0                	add    %edx,%eax
    ab0b:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    ab0f:	66 c1 ea 08          	shr    $0x8,%dx
    ab13:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    ab15:	8b 55 0c             	mov    0xc(%ebp),%edx
    ab18:	89 d0                	mov    %edx,%eax
    ab1a:	01 c0                	add    %eax,%eax
    ab1c:	01 d0                	add    %edx,%eax
    ab1e:	01 c0                	add    %eax,%eax
    ab20:	8d 50 03             	lea    0x3(%eax),%edx
    ab23:	8b 45 08             	mov    0x8(%ebp),%eax
    ab26:	01 d0                	add    %edx,%eax
    ab28:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    ab2c:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    ab2e:	8b 55 0c             	mov    0xc(%ebp),%edx
    ab31:	89 d0                	mov    %edx,%eax
    ab33:	01 c0                	add    %eax,%eax
    ab35:	01 d0                	add    %edx,%eax
    ab37:	01 c0                	add    %eax,%eax
    ab39:	8d 50 04             	lea    0x4(%eax),%edx
    ab3c:	8b 45 08             	mov    0x8(%ebp),%eax
    ab3f:	01 d0                	add    %edx,%eax
    ab41:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    ab45:	66 c1 ea 08          	shr    $0x8,%dx
    ab49:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    ab4b:	8b 55 0c             	mov    0xc(%ebp),%edx
    ab4e:	89 d0                	mov    %edx,%eax
    ab50:	01 c0                	add    %eax,%eax
    ab52:	01 d0                	add    %edx,%eax
    ab54:	01 c0                	add    %eax,%eax
    ab56:	8d 50 05             	lea    0x5(%eax),%edx
    ab59:	8b 45 08             	mov    0x8(%ebp),%eax
    ab5c:	01 d0                	add    %edx,%eax
    ab5e:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    ab62:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    ab64:	e9 2b 01 00 00       	jmp    ac94 <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    ab69:	8b 45 10             	mov    0x10(%ebp),%eax
    ab6c:	8b 00                	mov    (%eax),%eax
    ab6e:	83 f8 04             	cmp    $0x4,%eax
    ab71:	75 64                	jne    abd7 <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    ab73:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    ab77:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    ab7b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab7e:	c1 e0 02             	shl    $0x2,%eax
    ab81:	89 c2                	mov    %eax,%edx
    ab83:	8b 45 08             	mov    0x8(%ebp),%eax
    ab86:	01 d0                	add    %edx,%eax
    ab88:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    ab8c:	66 c1 ea 08          	shr    $0x8,%dx
    ab90:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    ab92:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab95:	c1 e0 02             	shl    $0x2,%eax
    ab98:	8d 50 01             	lea    0x1(%eax),%edx
    ab9b:	8b 45 08             	mov    0x8(%ebp),%eax
    ab9e:	01 d0                	add    %edx,%eax
    aba0:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    aba4:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    aba6:	8b 45 0c             	mov    0xc(%ebp),%eax
    aba9:	c1 e0 02             	shl    $0x2,%eax
    abac:	8d 50 02             	lea    0x2(%eax),%edx
    abaf:	8b 45 08             	mov    0x8(%ebp),%eax
    abb2:	01 d0                	add    %edx,%eax
    abb4:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    abb8:	66 c1 ea 08          	shr    $0x8,%dx
    abbc:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    abbe:	8b 45 0c             	mov    0xc(%ebp),%eax
    abc1:	c1 e0 02             	shl    $0x2,%eax
    abc4:	8d 50 03             	lea    0x3(%eax),%edx
    abc7:	8b 45 08             	mov    0x8(%ebp),%eax
    abca:	01 d0                	add    %edx,%eax
    abcc:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    abd0:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    abd2:	e9 bd 00 00 00       	jmp    ac94 <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    abd7:	8b 45 10             	mov    0x10(%ebp),%eax
    abda:	8b 00                	mov    (%eax),%eax
    abdc:	83 f8 06             	cmp    $0x6,%eax
    abdf:	0f 85 af 00 00 00    	jne    ac94 <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    abe5:	8b 45 0c             	mov    0xc(%ebp),%eax
    abe8:	c1 e0 03             	shl    $0x3,%eax
    abeb:	89 c2                	mov    %eax,%edx
    abed:	8b 45 08             	mov    0x8(%ebp),%eax
    abf0:	01 d0                	add    %edx,%eax
    abf2:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    abf6:	66 c1 ea 08          	shr    $0x8,%dx
    abfa:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    abfc:	8b 45 0c             	mov    0xc(%ebp),%eax
    abff:	c1 e0 03             	shl    $0x3,%eax
    ac02:	8d 50 01             	lea    0x1(%eax),%edx
    ac05:	8b 45 08             	mov    0x8(%ebp),%eax
    ac08:	01 d0                	add    %edx,%eax
    ac0a:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    ac0e:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    ac10:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac13:	c1 e0 03             	shl    $0x3,%eax
    ac16:	8d 50 02             	lea    0x2(%eax),%edx
    ac19:	8b 45 08             	mov    0x8(%ebp),%eax
    ac1c:	01 d0                	add    %edx,%eax
    ac1e:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    ac22:	66 c1 ea 08          	shr    $0x8,%dx
    ac26:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    ac28:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac2b:	c1 e0 03             	shl    $0x3,%eax
    ac2e:	8d 50 03             	lea    0x3(%eax),%edx
    ac31:	8b 45 08             	mov    0x8(%ebp),%eax
    ac34:	01 d0                	add    %edx,%eax
    ac36:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    ac3a:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    ac3c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac3f:	c1 e0 03             	shl    $0x3,%eax
    ac42:	8d 50 04             	lea    0x4(%eax),%edx
    ac45:	8b 45 08             	mov    0x8(%ebp),%eax
    ac48:	01 d0                	add    %edx,%eax
    ac4a:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    ac4e:	66 c1 ea 08          	shr    $0x8,%dx
    ac52:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    ac54:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac57:	c1 e0 03             	shl    $0x3,%eax
    ac5a:	8d 50 05             	lea    0x5(%eax),%edx
    ac5d:	8b 45 08             	mov    0x8(%ebp),%eax
    ac60:	01 d0                	add    %edx,%eax
    ac62:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    ac66:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    ac68:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac6b:	c1 e0 03             	shl    $0x3,%eax
    ac6e:	8d 50 06             	lea    0x6(%eax),%edx
    ac71:	8b 45 08             	mov    0x8(%ebp),%eax
    ac74:	01 d0                	add    %edx,%eax
    ac76:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    ac7a:	66 c1 ea 08          	shr    $0x8,%dx
    ac7e:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    ac80:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac83:	c1 e0 03             	shl    $0x3,%eax
    ac86:	8d 50 07             	lea    0x7(%eax),%edx
    ac89:	8b 45 08             	mov    0x8(%ebp),%eax
    ac8c:	01 d0                	add    %edx,%eax
    ac8e:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    ac92:	88 10                	mov    %dl,(%eax)
  }
}
    ac94:	90                   	nop
    ac95:	83 c4 20             	add    $0x20,%esp
    ac98:	5b                   	pop    %ebx
    ac99:	5d                   	pop    %ebp
    ac9a:	c3                   	ret    

0000ac9b <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    ac9b:	55                   	push   %ebp
    ac9c:	89 e5                	mov    %esp,%ebp
    ac9e:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    aca1:	8b 45 20             	mov    0x20(%ebp),%eax
    aca4:	8b 00                	mov    (%eax),%eax
    aca6:	85 c0                	test   %eax,%eax
    aca8:	0f 85 8c 01 00 00    	jne    ae3a <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    acae:	8b 45 20             	mov    0x20(%ebp),%eax
    acb1:	8b 40 04             	mov    0x4(%eax),%eax
    acb4:	83 f8 08             	cmp    $0x8,%eax
    acb7:	75 59                	jne    ad12 <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    acb9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    acbc:	8b 45 18             	mov    0x18(%ebp),%eax
    acbf:	01 d0                	add    %edx,%eax
    acc1:	0f b6 10             	movzbl (%eax),%edx
    acc4:	8b 45 10             	mov    0x10(%ebp),%eax
    acc7:	88 10                	mov    %dl,(%eax)
    acc9:	8b 45 10             	mov    0x10(%ebp),%eax
    accc:	0f b6 10             	movzbl (%eax),%edx
    accf:	8b 45 0c             	mov    0xc(%ebp),%eax
    acd2:	88 10                	mov    %dl,(%eax)
    acd4:	8b 45 0c             	mov    0xc(%ebp),%eax
    acd7:	0f b6 10             	movzbl (%eax),%edx
    acda:	8b 45 08             	mov    0x8(%ebp),%eax
    acdd:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    acdf:	8b 45 20             	mov    0x20(%ebp),%eax
    ace2:	8b 40 10             	mov    0x10(%eax),%eax
    ace5:	85 c0                	test   %eax,%eax
    ace7:	74 1e                	je     ad07 <getPixelColorRGBA8+0x6c>
    ace9:	8b 45 08             	mov    0x8(%ebp),%eax
    acec:	0f b6 00             	movzbl (%eax),%eax
    acef:	0f b6 d0             	movzbl %al,%edx
    acf2:	8b 45 20             	mov    0x20(%ebp),%eax
    acf5:	8b 40 14             	mov    0x14(%eax),%eax
    acf8:	39 c2                	cmp    %eax,%edx
    acfa:	75 0b                	jne    ad07 <getPixelColorRGBA8+0x6c>
    acfc:	8b 45 14             	mov    0x14(%ebp),%eax
    acff:	c6 00 00             	movb   $0x0,(%eax)
    ad02:	e9 5e 05 00 00       	jmp    b265 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    ad07:	8b 45 14             	mov    0x14(%ebp),%eax
    ad0a:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ad0d:	e9 53 05 00 00       	jmp    b265 <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    ad12:	8b 45 20             	mov    0x20(%ebp),%eax
    ad15:	8b 40 04             	mov    0x4(%eax),%eax
    ad18:	83 f8 10             	cmp    $0x10,%eax
    ad1b:	0f 85 80 00 00 00    	jne    ada1 <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    ad21:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad24:	01 c0                	add    %eax,%eax
    ad26:	89 c2                	mov    %eax,%edx
    ad28:	8b 45 18             	mov    0x18(%ebp),%eax
    ad2b:	01 d0                	add    %edx,%eax
    ad2d:	0f b6 10             	movzbl (%eax),%edx
    ad30:	8b 45 10             	mov    0x10(%ebp),%eax
    ad33:	88 10                	mov    %dl,(%eax)
    ad35:	8b 45 10             	mov    0x10(%ebp),%eax
    ad38:	0f b6 10             	movzbl (%eax),%edx
    ad3b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad3e:	88 10                	mov    %dl,(%eax)
    ad40:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad43:	0f b6 10             	movzbl (%eax),%edx
    ad46:	8b 45 08             	mov    0x8(%ebp),%eax
    ad49:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    ad4b:	8b 45 20             	mov    0x20(%ebp),%eax
    ad4e:	8b 40 10             	mov    0x10(%eax),%eax
    ad51:	85 c0                	test   %eax,%eax
    ad53:	74 41                	je     ad96 <getPixelColorRGBA8+0xfb>
    ad55:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad58:	01 c0                	add    %eax,%eax
    ad5a:	89 c2                	mov    %eax,%edx
    ad5c:	8b 45 18             	mov    0x18(%ebp),%eax
    ad5f:	01 d0                	add    %edx,%eax
    ad61:	0f b6 00             	movzbl (%eax),%eax
    ad64:	0f b6 c0             	movzbl %al,%eax
    ad67:	c1 e0 08             	shl    $0x8,%eax
    ad6a:	89 c2                	mov    %eax,%edx
    ad6c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad6f:	01 c0                	add    %eax,%eax
    ad71:	8d 48 01             	lea    0x1(%eax),%ecx
    ad74:	8b 45 18             	mov    0x18(%ebp),%eax
    ad77:	01 c8                	add    %ecx,%eax
    ad79:	0f b6 00             	movzbl (%eax),%eax
    ad7c:	0f b6 c0             	movzbl %al,%eax
    ad7f:	01 c2                	add    %eax,%edx
    ad81:	8b 45 20             	mov    0x20(%ebp),%eax
    ad84:	8b 40 14             	mov    0x14(%eax),%eax
    ad87:	39 c2                	cmp    %eax,%edx
    ad89:	75 0b                	jne    ad96 <getPixelColorRGBA8+0xfb>
    ad8b:	8b 45 14             	mov    0x14(%ebp),%eax
    ad8e:	c6 00 00             	movb   $0x0,(%eax)
    ad91:	e9 cf 04 00 00       	jmp    b265 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    ad96:	8b 45 14             	mov    0x14(%ebp),%eax
    ad99:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ad9c:	e9 c4 04 00 00       	jmp    b265 <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    ada1:	8b 45 20             	mov    0x20(%ebp),%eax
    ada4:	8b 40 04             	mov    0x4(%eax),%eax
    ada7:	ba 01 00 00 00       	mov    $0x1,%edx
    adac:	89 c1                	mov    %eax,%ecx
    adae:	d3 e2                	shl    %cl,%edx
    adb0:	89 d0                	mov    %edx,%eax
    adb2:	83 e8 01             	sub    $0x1,%eax
    adb5:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    adb8:	8b 45 20             	mov    0x20(%ebp),%eax
    adbb:	8b 50 04             	mov    0x4(%eax),%edx
    adbe:	8b 45 1c             	mov    0x1c(%ebp),%eax
    adc1:	0f af c2             	imul   %edx,%eax
    adc4:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    adc7:	8b 45 20             	mov    0x20(%ebp),%eax
    adca:	8b 40 04             	mov    0x4(%eax),%eax
    adcd:	50                   	push   %eax
    adce:	ff 75 18             	pushl  0x18(%ebp)
    add1:	8d 45 f0             	lea    -0x10(%ebp),%eax
    add4:	50                   	push   %eax
    add5:	e8 06 db ff ff       	call   88e0 <readBitsFromReversedStream>
    adda:	83 c4 0c             	add    $0xc,%esp
    addd:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    ade0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ade3:	89 d0                	mov    %edx,%eax
    ade5:	c1 e0 08             	shl    $0x8,%eax
    ade8:	29 d0                	sub    %edx,%eax
    adea:	ba 00 00 00 00       	mov    $0x0,%edx
    adef:	f7 75 f8             	divl   -0x8(%ebp)
    adf2:	89 c2                	mov    %eax,%edx
    adf4:	8b 45 10             	mov    0x10(%ebp),%eax
    adf7:	88 10                	mov    %dl,(%eax)
    adf9:	8b 45 10             	mov    0x10(%ebp),%eax
    adfc:	0f b6 10             	movzbl (%eax),%edx
    adff:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae02:	88 10                	mov    %dl,(%eax)
    ae04:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae07:	0f b6 10             	movzbl (%eax),%edx
    ae0a:	8b 45 08             	mov    0x8(%ebp),%eax
    ae0d:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    ae0f:	8b 45 20             	mov    0x20(%ebp),%eax
    ae12:	8b 40 10             	mov    0x10(%eax),%eax
    ae15:	85 c0                	test   %eax,%eax
    ae17:	74 16                	je     ae2f <getPixelColorRGBA8+0x194>
    ae19:	8b 45 20             	mov    0x20(%ebp),%eax
    ae1c:	8b 40 14             	mov    0x14(%eax),%eax
    ae1f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    ae22:	75 0b                	jne    ae2f <getPixelColorRGBA8+0x194>
    ae24:	8b 45 14             	mov    0x14(%ebp),%eax
    ae27:	c6 00 00             	movb   $0x0,(%eax)
    ae2a:	e9 36 04 00 00       	jmp    b265 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    ae2f:	8b 45 14             	mov    0x14(%ebp),%eax
    ae32:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ae35:	e9 2b 04 00 00       	jmp    b265 <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    ae3a:	8b 45 20             	mov    0x20(%ebp),%eax
    ae3d:	8b 00                	mov    (%eax),%eax
    ae3f:	83 f8 02             	cmp    $0x2,%eax
    ae42:	0f 85 f5 01 00 00    	jne    b03d <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    ae48:	8b 45 20             	mov    0x20(%ebp),%eax
    ae4b:	8b 40 04             	mov    0x4(%eax),%eax
    ae4e:	83 f8 08             	cmp    $0x8,%eax
    ae51:	0f 85 a3 00 00 00    	jne    aefa <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    ae57:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ae5a:	89 d0                	mov    %edx,%eax
    ae5c:	01 c0                	add    %eax,%eax
    ae5e:	01 d0                	add    %edx,%eax
    ae60:	89 c2                	mov    %eax,%edx
    ae62:	8b 45 18             	mov    0x18(%ebp),%eax
    ae65:	01 d0                	add    %edx,%eax
    ae67:	0f b6 10             	movzbl (%eax),%edx
    ae6a:	8b 45 08             	mov    0x8(%ebp),%eax
    ae6d:	88 10                	mov    %dl,(%eax)
    ae6f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ae72:	89 d0                	mov    %edx,%eax
    ae74:	01 c0                	add    %eax,%eax
    ae76:	01 d0                	add    %edx,%eax
    ae78:	8d 50 01             	lea    0x1(%eax),%edx
    ae7b:	8b 45 18             	mov    0x18(%ebp),%eax
    ae7e:	01 d0                	add    %edx,%eax
    ae80:	0f b6 10             	movzbl (%eax),%edx
    ae83:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae86:	88 10                	mov    %dl,(%eax)
    ae88:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ae8b:	89 d0                	mov    %edx,%eax
    ae8d:	01 c0                	add    %eax,%eax
    ae8f:	01 d0                	add    %edx,%eax
    ae91:	8d 50 02             	lea    0x2(%eax),%edx
    ae94:	8b 45 18             	mov    0x18(%ebp),%eax
    ae97:	01 d0                	add    %edx,%eax
    ae99:	0f b6 10             	movzbl (%eax),%edx
    ae9c:	8b 45 10             	mov    0x10(%ebp),%eax
    ae9f:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    aea1:	8b 45 20             	mov    0x20(%ebp),%eax
    aea4:	8b 40 10             	mov    0x10(%eax),%eax
    aea7:	85 c0                	test   %eax,%eax
    aea9:	74 44                	je     aeef <getPixelColorRGBA8+0x254>
    aeab:	8b 45 08             	mov    0x8(%ebp),%eax
    aeae:	0f b6 00             	movzbl (%eax),%eax
    aeb1:	0f b6 d0             	movzbl %al,%edx
    aeb4:	8b 45 20             	mov    0x20(%ebp),%eax
    aeb7:	8b 40 14             	mov    0x14(%eax),%eax
    aeba:	39 c2                	cmp    %eax,%edx
    aebc:	75 31                	jne    aeef <getPixelColorRGBA8+0x254>
    aebe:	8b 45 0c             	mov    0xc(%ebp),%eax
    aec1:	0f b6 00             	movzbl (%eax),%eax
    aec4:	0f b6 d0             	movzbl %al,%edx
    aec7:	8b 45 20             	mov    0x20(%ebp),%eax
    aeca:	8b 40 18             	mov    0x18(%eax),%eax
    aecd:	39 c2                	cmp    %eax,%edx
    aecf:	75 1e                	jne    aeef <getPixelColorRGBA8+0x254>
    aed1:	8b 45 10             	mov    0x10(%ebp),%eax
    aed4:	0f b6 00             	movzbl (%eax),%eax
    aed7:	0f b6 d0             	movzbl %al,%edx
    aeda:	8b 45 20             	mov    0x20(%ebp),%eax
    aedd:	8b 40 1c             	mov    0x1c(%eax),%eax
    aee0:	39 c2                	cmp    %eax,%edx
    aee2:	75 0b                	jne    aeef <getPixelColorRGBA8+0x254>
    aee4:	8b 45 14             	mov    0x14(%ebp),%eax
    aee7:	c6 00 00             	movb   $0x0,(%eax)
    aeea:	e9 76 03 00 00       	jmp    b265 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    aeef:	8b 45 14             	mov    0x14(%ebp),%eax
    aef2:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aef5:	e9 6b 03 00 00       	jmp    b265 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    aefa:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aefd:	89 d0                	mov    %edx,%eax
    aeff:	01 c0                	add    %eax,%eax
    af01:	01 d0                	add    %edx,%eax
    af03:	01 c0                	add    %eax,%eax
    af05:	89 c2                	mov    %eax,%edx
    af07:	8b 45 18             	mov    0x18(%ebp),%eax
    af0a:	01 d0                	add    %edx,%eax
    af0c:	0f b6 10             	movzbl (%eax),%edx
    af0f:	8b 45 08             	mov    0x8(%ebp),%eax
    af12:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    af14:	8b 55 1c             	mov    0x1c(%ebp),%edx
    af17:	89 d0                	mov    %edx,%eax
    af19:	01 c0                	add    %eax,%eax
    af1b:	01 d0                	add    %edx,%eax
    af1d:	01 c0                	add    %eax,%eax
    af1f:	8d 50 02             	lea    0x2(%eax),%edx
    af22:	8b 45 18             	mov    0x18(%ebp),%eax
    af25:	01 d0                	add    %edx,%eax
    af27:	0f b6 10             	movzbl (%eax),%edx
    af2a:	8b 45 0c             	mov    0xc(%ebp),%eax
    af2d:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    af2f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    af32:	89 d0                	mov    %edx,%eax
    af34:	01 c0                	add    %eax,%eax
    af36:	01 d0                	add    %edx,%eax
    af38:	01 c0                	add    %eax,%eax
    af3a:	8d 50 04             	lea    0x4(%eax),%edx
    af3d:	8b 45 18             	mov    0x18(%ebp),%eax
    af40:	01 d0                	add    %edx,%eax
    af42:	0f b6 10             	movzbl (%eax),%edx
    af45:	8b 45 10             	mov    0x10(%ebp),%eax
    af48:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    af4a:	8b 45 20             	mov    0x20(%ebp),%eax
    af4d:	8b 40 10             	mov    0x10(%eax),%eax
    af50:	85 c0                	test   %eax,%eax
    af52:	0f 84 da 00 00 00    	je     b032 <getPixelColorRGBA8+0x397>
    af58:	8b 55 1c             	mov    0x1c(%ebp),%edx
    af5b:	89 d0                	mov    %edx,%eax
    af5d:	01 c0                	add    %eax,%eax
    af5f:	01 d0                	add    %edx,%eax
    af61:	01 c0                	add    %eax,%eax
    af63:	89 c2                	mov    %eax,%edx
    af65:	8b 45 18             	mov    0x18(%ebp),%eax
    af68:	01 d0                	add    %edx,%eax
    af6a:	0f b6 00             	movzbl (%eax),%eax
    af6d:	0f b6 c0             	movzbl %al,%eax
    af70:	c1 e0 08             	shl    $0x8,%eax
    af73:	89 c1                	mov    %eax,%ecx
    af75:	8b 55 1c             	mov    0x1c(%ebp),%edx
    af78:	89 d0                	mov    %edx,%eax
    af7a:	01 c0                	add    %eax,%eax
    af7c:	01 d0                	add    %edx,%eax
    af7e:	01 c0                	add    %eax,%eax
    af80:	8d 50 01             	lea    0x1(%eax),%edx
    af83:	8b 45 18             	mov    0x18(%ebp),%eax
    af86:	01 d0                	add    %edx,%eax
    af88:	0f b6 00             	movzbl (%eax),%eax
    af8b:	0f b6 c0             	movzbl %al,%eax
    af8e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    af91:	8b 45 20             	mov    0x20(%ebp),%eax
    af94:	8b 40 14             	mov    0x14(%eax),%eax
    af97:	39 c2                	cmp    %eax,%edx
    af99:	0f 85 93 00 00 00    	jne    b032 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    af9f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    afa2:	89 d0                	mov    %edx,%eax
    afa4:	01 c0                	add    %eax,%eax
    afa6:	01 d0                	add    %edx,%eax
    afa8:	01 c0                	add    %eax,%eax
    afaa:	8d 50 02             	lea    0x2(%eax),%edx
    afad:	8b 45 18             	mov    0x18(%ebp),%eax
    afb0:	01 d0                	add    %edx,%eax
    afb2:	0f b6 00             	movzbl (%eax),%eax
    afb5:	0f b6 c0             	movzbl %al,%eax
    afb8:	c1 e0 08             	shl    $0x8,%eax
    afbb:	89 c1                	mov    %eax,%ecx
    afbd:	8b 55 1c             	mov    0x1c(%ebp),%edx
    afc0:	89 d0                	mov    %edx,%eax
    afc2:	01 c0                	add    %eax,%eax
    afc4:	01 d0                	add    %edx,%eax
    afc6:	01 c0                	add    %eax,%eax
    afc8:	8d 50 03             	lea    0x3(%eax),%edx
    afcb:	8b 45 18             	mov    0x18(%ebp),%eax
    afce:	01 d0                	add    %edx,%eax
    afd0:	0f b6 00             	movzbl (%eax),%eax
    afd3:	0f b6 c0             	movzbl %al,%eax
    afd6:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    afd9:	8b 45 20             	mov    0x20(%ebp),%eax
    afdc:	8b 40 18             	mov    0x18(%eax),%eax
    afdf:	39 c2                	cmp    %eax,%edx
    afe1:	75 4f                	jne    b032 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    afe3:	8b 55 1c             	mov    0x1c(%ebp),%edx
    afe6:	89 d0                	mov    %edx,%eax
    afe8:	01 c0                	add    %eax,%eax
    afea:	01 d0                	add    %edx,%eax
    afec:	01 c0                	add    %eax,%eax
    afee:	8d 50 04             	lea    0x4(%eax),%edx
    aff1:	8b 45 18             	mov    0x18(%ebp),%eax
    aff4:	01 d0                	add    %edx,%eax
    aff6:	0f b6 00             	movzbl (%eax),%eax
    aff9:	0f b6 c0             	movzbl %al,%eax
    affc:	c1 e0 08             	shl    $0x8,%eax
    afff:	89 c1                	mov    %eax,%ecx
    b001:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b004:	89 d0                	mov    %edx,%eax
    b006:	01 c0                	add    %eax,%eax
    b008:	01 d0                	add    %edx,%eax
    b00a:	01 c0                	add    %eax,%eax
    b00c:	8d 50 05             	lea    0x5(%eax),%edx
    b00f:	8b 45 18             	mov    0x18(%ebp),%eax
    b012:	01 d0                	add    %edx,%eax
    b014:	0f b6 00             	movzbl (%eax),%eax
    b017:	0f b6 c0             	movzbl %al,%eax
    b01a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b01d:	8b 45 20             	mov    0x20(%ebp),%eax
    b020:	8b 40 1c             	mov    0x1c(%eax),%eax
    b023:	39 c2                	cmp    %eax,%edx
    b025:	75 0b                	jne    b032 <getPixelColorRGBA8+0x397>
    b027:	8b 45 14             	mov    0x14(%ebp),%eax
    b02a:	c6 00 00             	movb   $0x0,(%eax)
    b02d:	e9 33 02 00 00       	jmp    b265 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    b032:	8b 45 14             	mov    0x14(%ebp),%eax
    b035:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b038:	e9 28 02 00 00       	jmp    b265 <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b03d:	8b 45 20             	mov    0x20(%ebp),%eax
    b040:	8b 00                	mov    (%eax),%eax
    b042:	83 f8 03             	cmp    $0x3,%eax
    b045:	0f 85 ac 00 00 00    	jne    b0f7 <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    b04b:	8b 45 20             	mov    0x20(%ebp),%eax
    b04e:	8b 40 04             	mov    0x4(%eax),%eax
    b051:	83 f8 08             	cmp    $0x8,%eax
    b054:	75 13                	jne    b069 <getPixelColorRGBA8+0x3ce>
    b056:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b059:	8b 45 18             	mov    0x18(%ebp),%eax
    b05c:	01 d0                	add    %edx,%eax
    b05e:	0f b6 00             	movzbl (%eax),%eax
    b061:	0f b6 c0             	movzbl %al,%eax
    b064:	89 45 fc             	mov    %eax,-0x4(%ebp)
    b067:	eb 28                	jmp    b091 <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    b069:	8b 45 20             	mov    0x20(%ebp),%eax
    b06c:	8b 50 04             	mov    0x4(%eax),%edx
    b06f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b072:	0f af c2             	imul   %edx,%eax
    b075:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b078:	8b 45 20             	mov    0x20(%ebp),%eax
    b07b:	8b 40 04             	mov    0x4(%eax),%eax
    b07e:	50                   	push   %eax
    b07f:	ff 75 18             	pushl  0x18(%ebp)
    b082:	8d 45 ec             	lea    -0x14(%ebp),%eax
    b085:	50                   	push   %eax
    b086:	e8 55 d8 ff ff       	call   88e0 <readBitsFromReversedStream>
    b08b:	83 c4 0c             	add    $0xc,%esp
    b08e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    b091:	8b 45 20             	mov    0x20(%ebp),%eax
    b094:	8b 40 08             	mov    0x8(%eax),%eax
    b097:	8b 55 fc             	mov    -0x4(%ebp),%edx
    b09a:	c1 e2 02             	shl    $0x2,%edx
    b09d:	01 d0                	add    %edx,%eax
    b09f:	0f b6 10             	movzbl (%eax),%edx
    b0a2:	8b 45 08             	mov    0x8(%ebp),%eax
    b0a5:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    b0a7:	8b 45 20             	mov    0x20(%ebp),%eax
    b0aa:	8b 40 08             	mov    0x8(%eax),%eax
    b0ad:	8b 55 fc             	mov    -0x4(%ebp),%edx
    b0b0:	c1 e2 02             	shl    $0x2,%edx
    b0b3:	83 c2 01             	add    $0x1,%edx
    b0b6:	01 d0                	add    %edx,%eax
    b0b8:	0f b6 10             	movzbl (%eax),%edx
    b0bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    b0be:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    b0c0:	8b 45 20             	mov    0x20(%ebp),%eax
    b0c3:	8b 40 08             	mov    0x8(%eax),%eax
    b0c6:	8b 55 fc             	mov    -0x4(%ebp),%edx
    b0c9:	c1 e2 02             	shl    $0x2,%edx
    b0cc:	83 c2 02             	add    $0x2,%edx
    b0cf:	01 d0                	add    %edx,%eax
    b0d1:	0f b6 10             	movzbl (%eax),%edx
    b0d4:	8b 45 10             	mov    0x10(%ebp),%eax
    b0d7:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    b0d9:	8b 45 20             	mov    0x20(%ebp),%eax
    b0dc:	8b 40 08             	mov    0x8(%eax),%eax
    b0df:	8b 55 fc             	mov    -0x4(%ebp),%edx
    b0e2:	c1 e2 02             	shl    $0x2,%edx
    b0e5:	83 c2 03             	add    $0x3,%edx
    b0e8:	01 d0                	add    %edx,%eax
    b0ea:	0f b6 10             	movzbl (%eax),%edx
    b0ed:	8b 45 14             	mov    0x14(%ebp),%eax
    b0f0:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b0f2:	e9 6e 01 00 00       	jmp    b265 <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b0f7:	8b 45 20             	mov    0x20(%ebp),%eax
    b0fa:	8b 00                	mov    (%eax),%eax
    b0fc:	83 f8 04             	cmp    $0x4,%eax
    b0ff:	0f 85 95 00 00 00    	jne    b19a <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    b105:	8b 45 20             	mov    0x20(%ebp),%eax
    b108:	8b 40 04             	mov    0x4(%eax),%eax
    b10b:	83 f8 08             	cmp    $0x8,%eax
    b10e:	75 44                	jne    b154 <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    b110:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b113:	01 c0                	add    %eax,%eax
    b115:	89 c2                	mov    %eax,%edx
    b117:	8b 45 18             	mov    0x18(%ebp),%eax
    b11a:	01 d0                	add    %edx,%eax
    b11c:	0f b6 10             	movzbl (%eax),%edx
    b11f:	8b 45 10             	mov    0x10(%ebp),%eax
    b122:	88 10                	mov    %dl,(%eax)
    b124:	8b 45 10             	mov    0x10(%ebp),%eax
    b127:	0f b6 10             	movzbl (%eax),%edx
    b12a:	8b 45 0c             	mov    0xc(%ebp),%eax
    b12d:	88 10                	mov    %dl,(%eax)
    b12f:	8b 45 0c             	mov    0xc(%ebp),%eax
    b132:	0f b6 10             	movzbl (%eax),%edx
    b135:	8b 45 08             	mov    0x8(%ebp),%eax
    b138:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    b13a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b13d:	01 c0                	add    %eax,%eax
    b13f:	8d 50 01             	lea    0x1(%eax),%edx
    b142:	8b 45 18             	mov    0x18(%ebp),%eax
    b145:	01 d0                	add    %edx,%eax
    b147:	0f b6 10             	movzbl (%eax),%edx
    b14a:	8b 45 14             	mov    0x14(%ebp),%eax
    b14d:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b14f:	e9 11 01 00 00       	jmp    b265 <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    b154:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b157:	c1 e0 02             	shl    $0x2,%eax
    b15a:	89 c2                	mov    %eax,%edx
    b15c:	8b 45 18             	mov    0x18(%ebp),%eax
    b15f:	01 d0                	add    %edx,%eax
    b161:	0f b6 10             	movzbl (%eax),%edx
    b164:	8b 45 10             	mov    0x10(%ebp),%eax
    b167:	88 10                	mov    %dl,(%eax)
    b169:	8b 45 10             	mov    0x10(%ebp),%eax
    b16c:	0f b6 10             	movzbl (%eax),%edx
    b16f:	8b 45 0c             	mov    0xc(%ebp),%eax
    b172:	88 10                	mov    %dl,(%eax)
    b174:	8b 45 0c             	mov    0xc(%ebp),%eax
    b177:	0f b6 10             	movzbl (%eax),%edx
    b17a:	8b 45 08             	mov    0x8(%ebp),%eax
    b17d:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    b17f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b182:	c1 e0 02             	shl    $0x2,%eax
    b185:	8d 50 02             	lea    0x2(%eax),%edx
    b188:	8b 45 18             	mov    0x18(%ebp),%eax
    b18b:	01 d0                	add    %edx,%eax
    b18d:	0f b6 10             	movzbl (%eax),%edx
    b190:	8b 45 14             	mov    0x14(%ebp),%eax
    b193:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b195:	e9 cb 00 00 00       	jmp    b265 <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    b19a:	8b 45 20             	mov    0x20(%ebp),%eax
    b19d:	8b 00                	mov    (%eax),%eax
    b19f:	83 f8 06             	cmp    $0x6,%eax
    b1a2:	0f 85 bd 00 00 00    	jne    b265 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    b1a8:	8b 45 20             	mov    0x20(%ebp),%eax
    b1ab:	8b 40 04             	mov    0x4(%eax),%eax
    b1ae:	83 f8 08             	cmp    $0x8,%eax
    b1b1:	75 59                	jne    b20c <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    b1b3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b1b6:	c1 e0 02             	shl    $0x2,%eax
    b1b9:	89 c2                	mov    %eax,%edx
    b1bb:	8b 45 18             	mov    0x18(%ebp),%eax
    b1be:	01 d0                	add    %edx,%eax
    b1c0:	0f b6 10             	movzbl (%eax),%edx
    b1c3:	8b 45 08             	mov    0x8(%ebp),%eax
    b1c6:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    b1c8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b1cb:	c1 e0 02             	shl    $0x2,%eax
    b1ce:	8d 50 01             	lea    0x1(%eax),%edx
    b1d1:	8b 45 18             	mov    0x18(%ebp),%eax
    b1d4:	01 d0                	add    %edx,%eax
    b1d6:	0f b6 10             	movzbl (%eax),%edx
    b1d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    b1dc:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    b1de:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b1e1:	c1 e0 02             	shl    $0x2,%eax
    b1e4:	8d 50 02             	lea    0x2(%eax),%edx
    b1e7:	8b 45 18             	mov    0x18(%ebp),%eax
    b1ea:	01 d0                	add    %edx,%eax
    b1ec:	0f b6 10             	movzbl (%eax),%edx
    b1ef:	8b 45 10             	mov    0x10(%ebp),%eax
    b1f2:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    b1f4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b1f7:	c1 e0 02             	shl    $0x2,%eax
    b1fa:	8d 50 03             	lea    0x3(%eax),%edx
    b1fd:	8b 45 18             	mov    0x18(%ebp),%eax
    b200:	01 d0                	add    %edx,%eax
    b202:	0f b6 10             	movzbl (%eax),%edx
    b205:	8b 45 14             	mov    0x14(%ebp),%eax
    b208:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b20a:	eb 59                	jmp    b265 <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    b20c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b20f:	c1 e0 03             	shl    $0x3,%eax
    b212:	89 c2                	mov    %eax,%edx
    b214:	8b 45 18             	mov    0x18(%ebp),%eax
    b217:	01 d0                	add    %edx,%eax
    b219:	0f b6 10             	movzbl (%eax),%edx
    b21c:	8b 45 08             	mov    0x8(%ebp),%eax
    b21f:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    b221:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b224:	c1 e0 03             	shl    $0x3,%eax
    b227:	8d 50 02             	lea    0x2(%eax),%edx
    b22a:	8b 45 18             	mov    0x18(%ebp),%eax
    b22d:	01 d0                	add    %edx,%eax
    b22f:	0f b6 10             	movzbl (%eax),%edx
    b232:	8b 45 0c             	mov    0xc(%ebp),%eax
    b235:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    b237:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b23a:	c1 e0 03             	shl    $0x3,%eax
    b23d:	8d 50 04             	lea    0x4(%eax),%edx
    b240:	8b 45 18             	mov    0x18(%ebp),%eax
    b243:	01 d0                	add    %edx,%eax
    b245:	0f b6 10             	movzbl (%eax),%edx
    b248:	8b 45 10             	mov    0x10(%ebp),%eax
    b24b:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    b24d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b250:	c1 e0 03             	shl    $0x3,%eax
    b253:	8d 50 06             	lea    0x6(%eax),%edx
    b256:	8b 45 18             	mov    0x18(%ebp),%eax
    b259:	01 d0                	add    %edx,%eax
    b25b:	0f b6 10             	movzbl (%eax),%edx
    b25e:	8b 45 14             	mov    0x14(%ebp),%eax
    b261:	88 10                	mov    %dl,(%eax)
    }
  }
}
    b263:	eb 00                	jmp    b265 <getPixelColorRGBA8+0x5ca>
    b265:	90                   	nop
    b266:	c9                   	leave  
    b267:	c3                   	ret    

0000b268 <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    b268:	55                   	push   %ebp
    b269:	89 e5                	mov    %esp,%ebp
    b26b:	53                   	push   %ebx
    b26c:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    b26f:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b276:	8b 45 14             	mov    0x14(%ebp),%eax
    b279:	8b 00                	mov    (%eax),%eax
    b27b:	85 c0                	test   %eax,%eax
    b27d:	0f 85 14 02 00 00    	jne    b497 <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    b283:	8b 45 14             	mov    0x14(%ebp),%eax
    b286:	8b 40 04             	mov    0x4(%eax),%eax
    b289:	83 f8 08             	cmp    $0x8,%eax
    b28c:	0f 85 a0 00 00 00    	jne    b332 <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b292:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b299:	eb 39                	jmp    b2d4 <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b29b:	8b 45 08             	mov    0x8(%ebp),%eax
    b29e:	83 c0 01             	add    $0x1,%eax
    b2a1:	8b 55 08             	mov    0x8(%ebp),%edx
    b2a4:	83 c2 02             	add    $0x2,%edx
    b2a7:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b2aa:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b2ad:	01 d9                	add    %ebx,%ecx
    b2af:	0f b6 09             	movzbl (%ecx),%ecx
    b2b2:	88 0a                	mov    %cl,(%edx)
    b2b4:	0f b6 12             	movzbl (%edx),%edx
    b2b7:	88 10                	mov    %dl,(%eax)
    b2b9:	0f b6 10             	movzbl (%eax),%edx
    b2bc:	8b 45 08             	mov    0x8(%ebp),%eax
    b2bf:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    b2c1:	8b 45 08             	mov    0x8(%ebp),%eax
    b2c4:	83 c0 03             	add    $0x3,%eax
    b2c7:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2ca:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b2ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b2d1:	01 45 08             	add    %eax,0x8(%ebp)
    b2d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2d7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b2da:	75 bf                	jne    b29b <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    b2dc:	8b 45 14             	mov    0x14(%ebp),%eax
    b2df:	8b 40 10             	mov    0x10(%eax),%eax
    b2e2:	85 c0                	test   %eax,%eax
    b2e4:	0f 84 48 06 00 00    	je     b932 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    b2ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    b2ed:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    b2f1:	f7 d8                	neg    %eax
    b2f3:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2f6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b2fd:	eb 26                	jmp    b325 <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    b2ff:	8b 45 08             	mov    0x8(%ebp),%eax
    b302:	0f b6 00             	movzbl (%eax),%eax
    b305:	0f b6 d0             	movzbl %al,%edx
    b308:	8b 45 14             	mov    0x14(%ebp),%eax
    b30b:	8b 40 14             	mov    0x14(%eax),%eax
    b30e:	39 c2                	cmp    %eax,%edx
    b310:	75 09                	jne    b31b <getPixelColorsRGBA8+0xb3>
    b312:	8b 45 08             	mov    0x8(%ebp),%eax
    b315:	83 c0 03             	add    $0x3,%eax
    b318:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b31b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b31f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b322:	01 45 08             	add    %eax,0x8(%ebp)
    b325:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b328:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b32b:	75 d2                	jne    b2ff <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b32d:	e9 00 06 00 00       	jmp    b932 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    b332:	8b 45 14             	mov    0x14(%ebp),%eax
    b335:	8b 40 04             	mov    0x4(%eax),%eax
    b338:	83 f8 10             	cmp    $0x10,%eax
    b33b:	0f 85 a5 00 00 00    	jne    b3e6 <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b341:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b348:	e9 88 00 00 00       	jmp    b3d5 <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b34d:	8b 45 08             	mov    0x8(%ebp),%eax
    b350:	83 c0 01             	add    $0x1,%eax
    b353:	8b 55 08             	mov    0x8(%ebp),%edx
    b356:	83 c2 02             	add    $0x2,%edx
    b359:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b35c:	01 c9                	add    %ecx,%ecx
    b35e:	89 cb                	mov    %ecx,%ebx
    b360:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b363:	01 d9                	add    %ebx,%ecx
    b365:	0f b6 09             	movzbl (%ecx),%ecx
    b368:	88 0a                	mov    %cl,(%edx)
    b36a:	0f b6 12             	movzbl (%edx),%edx
    b36d:	88 10                	mov    %dl,(%eax)
    b36f:	0f b6 10             	movzbl (%eax),%edx
    b372:	8b 45 08             	mov    0x8(%ebp),%eax
    b375:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    b377:	8b 45 08             	mov    0x8(%ebp),%eax
    b37a:	8d 50 03             	lea    0x3(%eax),%edx
    b37d:	8b 45 14             	mov    0x14(%ebp),%eax
    b380:	8b 40 10             	mov    0x10(%eax),%eax
    b383:	85 c0                	test   %eax,%eax
    b385:	74 3d                	je     b3c4 <getPixelColorsRGBA8+0x15c>
    b387:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b38a:	01 c0                	add    %eax,%eax
    b38c:	89 c1                	mov    %eax,%ecx
    b38e:	8b 45 10             	mov    0x10(%ebp),%eax
    b391:	01 c8                	add    %ecx,%eax
    b393:	0f b6 00             	movzbl (%eax),%eax
    b396:	0f b6 c0             	movzbl %al,%eax
    b399:	c1 e0 08             	shl    $0x8,%eax
    b39c:	89 c1                	mov    %eax,%ecx
    b39e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3a1:	01 c0                	add    %eax,%eax
    b3a3:	8d 58 01             	lea    0x1(%eax),%ebx
    b3a6:	8b 45 10             	mov    0x10(%ebp),%eax
    b3a9:	01 d8                	add    %ebx,%eax
    b3ab:	0f b6 00             	movzbl (%eax),%eax
    b3ae:	0f b6 c0             	movzbl %al,%eax
    b3b1:	01 c1                	add    %eax,%ecx
    b3b3:	8b 45 14             	mov    0x14(%ebp),%eax
    b3b6:	8b 40 14             	mov    0x14(%eax),%eax
    b3b9:	39 c1                	cmp    %eax,%ecx
    b3bb:	75 07                	jne    b3c4 <getPixelColorsRGBA8+0x15c>
    b3bd:	b8 00 00 00 00       	mov    $0x0,%eax
    b3c2:	eb 05                	jmp    b3c9 <getPixelColorsRGBA8+0x161>
    b3c4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b3c9:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3cb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3d2:	01 45 08             	add    %eax,0x8(%ebp)
    b3d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3d8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b3db:	0f 85 6c ff ff ff    	jne    b34d <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b3e1:	e9 4c 05 00 00       	jmp    b932 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b3e6:	8b 45 14             	mov    0x14(%ebp),%eax
    b3e9:	8b 40 04             	mov    0x4(%eax),%eax
    b3ec:	ba 01 00 00 00       	mov    $0x1,%edx
    b3f1:	89 c1                	mov    %eax,%ecx
    b3f3:	d3 e2                	shl    %cl,%edx
    b3f5:	89 d0                	mov    %edx,%eax
    b3f7:	83 e8 01             	sub    $0x1,%eax
    b3fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b3fd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b404:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b40b:	eb 79                	jmp    b486 <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b40d:	8b 45 14             	mov    0x14(%ebp),%eax
    b410:	8b 40 04             	mov    0x4(%eax),%eax
    b413:	50                   	push   %eax
    b414:	ff 75 10             	pushl  0x10(%ebp)
    b417:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b41a:	50                   	push   %eax
    b41b:	e8 c0 d4 ff ff       	call   88e0 <readBitsFromReversedStream>
    b420:	83 c4 0c             	add    $0xc,%esp
    b423:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b426:	8b 45 08             	mov    0x8(%ebp),%eax
    b429:	8d 48 01             	lea    0x1(%eax),%ecx
    b42c:	8b 45 08             	mov    0x8(%ebp),%eax
    b42f:	8d 58 02             	lea    0x2(%eax),%ebx
    b432:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b435:	89 d0                	mov    %edx,%eax
    b437:	c1 e0 08             	shl    $0x8,%eax
    b43a:	29 d0                	sub    %edx,%eax
    b43c:	ba 00 00 00 00       	mov    $0x0,%edx
    b441:	f7 75 f0             	divl   -0x10(%ebp)
    b444:	88 03                	mov    %al,(%ebx)
    b446:	0f b6 03             	movzbl (%ebx),%eax
    b449:	88 01                	mov    %al,(%ecx)
    b44b:	0f b6 11             	movzbl (%ecx),%edx
    b44e:	8b 45 08             	mov    0x8(%ebp),%eax
    b451:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    b453:	8b 45 08             	mov    0x8(%ebp),%eax
    b456:	8d 50 03             	lea    0x3(%eax),%edx
    b459:	8b 45 14             	mov    0x14(%ebp),%eax
    b45c:	8b 40 10             	mov    0x10(%eax),%eax
    b45f:	85 c0                	test   %eax,%eax
    b461:	74 12                	je     b475 <getPixelColorsRGBA8+0x20d>
    b463:	8b 45 14             	mov    0x14(%ebp),%eax
    b466:	8b 40 14             	mov    0x14(%eax),%eax
    b469:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    b46c:	75 07                	jne    b475 <getPixelColorsRGBA8+0x20d>
    b46e:	b8 00 00 00 00       	mov    $0x0,%eax
    b473:	eb 05                	jmp    b47a <getPixelColorsRGBA8+0x212>
    b475:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b47a:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b47c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b480:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b483:	01 45 08             	add    %eax,0x8(%ebp)
    b486:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b489:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b48c:	0f 85 7b ff ff ff    	jne    b40d <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b492:	e9 9b 04 00 00       	jmp    b932 <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b497:	8b 45 14             	mov    0x14(%ebp),%eax
    b49a:	8b 00                	mov    (%eax),%eax
    b49c:	83 f8 02             	cmp    $0x2,%eax
    b49f:	0f 85 41 02 00 00    	jne    b6e6 <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    b4a5:	8b 45 14             	mov    0x14(%ebp),%eax
    b4a8:	8b 40 04             	mov    0x4(%eax),%eax
    b4ab:	83 f8 08             	cmp    $0x8,%eax
    b4ae:	0f 85 c4 00 00 00    	jne    b578 <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4b4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b4bb:	eb 31                	jmp    b4ee <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    b4bd:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b4c0:	89 d0                	mov    %edx,%eax
    b4c2:	01 c0                	add    %eax,%eax
    b4c4:	01 d0                	add    %edx,%eax
    b4c6:	89 c2                	mov    %eax,%edx
    b4c8:	8b 45 10             	mov    0x10(%ebp),%eax
    b4cb:	01 d0                	add    %edx,%eax
    b4cd:	6a 03                	push   $0x3
    b4cf:	50                   	push   %eax
    b4d0:	ff 75 08             	pushl  0x8(%ebp)
    b4d3:	e8 a3 85 ff ff       	call   3a7b <lodepng_memcpy>
    b4d8:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    b4db:	8b 45 08             	mov    0x8(%ebp),%eax
    b4de:	83 c0 03             	add    $0x3,%eax
    b4e1:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4e4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b4e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b4eb:	01 45 08             	add    %eax,0x8(%ebp)
    b4ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4f1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b4f4:	75 c7                	jne    b4bd <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    b4f6:	8b 45 14             	mov    0x14(%ebp),%eax
    b4f9:	8b 40 10             	mov    0x10(%eax),%eax
    b4fc:	85 c0                	test   %eax,%eax
    b4fe:	0f 84 2e 04 00 00    	je     b932 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    b504:	8b 45 0c             	mov    0xc(%ebp),%eax
    b507:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    b50b:	f7 d8                	neg    %eax
    b50d:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b510:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b517:	eb 52                	jmp    b56b <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    b519:	8b 45 08             	mov    0x8(%ebp),%eax
    b51c:	0f b6 00             	movzbl (%eax),%eax
    b51f:	0f b6 d0             	movzbl %al,%edx
    b522:	8b 45 14             	mov    0x14(%ebp),%eax
    b525:	8b 40 14             	mov    0x14(%eax),%eax
    b528:	39 c2                	cmp    %eax,%edx
    b52a:	75 35                	jne    b561 <getPixelColorsRGBA8+0x2f9>
    b52c:	8b 45 08             	mov    0x8(%ebp),%eax
    b52f:	83 c0 01             	add    $0x1,%eax
    b532:	0f b6 00             	movzbl (%eax),%eax
    b535:	0f b6 d0             	movzbl %al,%edx
    b538:	8b 45 14             	mov    0x14(%ebp),%eax
    b53b:	8b 40 18             	mov    0x18(%eax),%eax
    b53e:	39 c2                	cmp    %eax,%edx
    b540:	75 1f                	jne    b561 <getPixelColorsRGBA8+0x2f9>
    b542:	8b 45 08             	mov    0x8(%ebp),%eax
    b545:	83 c0 02             	add    $0x2,%eax
    b548:	0f b6 00             	movzbl (%eax),%eax
    b54b:	0f b6 d0             	movzbl %al,%edx
    b54e:	8b 45 14             	mov    0x14(%ebp),%eax
    b551:	8b 40 1c             	mov    0x1c(%eax),%eax
    b554:	39 c2                	cmp    %eax,%edx
    b556:	75 09                	jne    b561 <getPixelColorsRGBA8+0x2f9>
    b558:	8b 45 08             	mov    0x8(%ebp),%eax
    b55b:	83 c0 03             	add    $0x3,%eax
    b55e:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b561:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b565:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b568:	01 45 08             	add    %eax,0x8(%ebp)
    b56b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b56e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b571:	75 a6                	jne    b519 <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b573:	e9 ba 03 00 00       	jmp    b932 <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b578:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b57f:	e9 51 01 00 00       	jmp    b6d5 <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    b584:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b587:	89 d0                	mov    %edx,%eax
    b589:	01 c0                	add    %eax,%eax
    b58b:	01 d0                	add    %edx,%eax
    b58d:	01 c0                	add    %eax,%eax
    b58f:	89 c2                	mov    %eax,%edx
    b591:	8b 45 10             	mov    0x10(%ebp),%eax
    b594:	01 d0                	add    %edx,%eax
    b596:	0f b6 10             	movzbl (%eax),%edx
    b599:	8b 45 08             	mov    0x8(%ebp),%eax
    b59c:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b59e:	8b 45 08             	mov    0x8(%ebp),%eax
    b5a1:	8d 48 01             	lea    0x1(%eax),%ecx
    b5a4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b5a7:	89 d0                	mov    %edx,%eax
    b5a9:	01 c0                	add    %eax,%eax
    b5ab:	01 d0                	add    %edx,%eax
    b5ad:	01 c0                	add    %eax,%eax
    b5af:	8d 50 02             	lea    0x2(%eax),%edx
    b5b2:	8b 45 10             	mov    0x10(%ebp),%eax
    b5b5:	01 d0                	add    %edx,%eax
    b5b7:	0f b6 00             	movzbl (%eax),%eax
    b5ba:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b5bc:	8b 45 08             	mov    0x8(%ebp),%eax
    b5bf:	8d 48 02             	lea    0x2(%eax),%ecx
    b5c2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b5c5:	89 d0                	mov    %edx,%eax
    b5c7:	01 c0                	add    %eax,%eax
    b5c9:	01 d0                	add    %edx,%eax
    b5cb:	01 c0                	add    %eax,%eax
    b5cd:	8d 50 04             	lea    0x4(%eax),%edx
    b5d0:	8b 45 10             	mov    0x10(%ebp),%eax
    b5d3:	01 d0                	add    %edx,%eax
    b5d5:	0f b6 00             	movzbl (%eax),%eax
    b5d8:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    b5da:	8b 45 08             	mov    0x8(%ebp),%eax
    b5dd:	8d 48 03             	lea    0x3(%eax),%ecx
    b5e0:	8b 45 14             	mov    0x14(%ebp),%eax
    b5e3:	8b 40 10             	mov    0x10(%eax),%eax
    b5e6:	85 c0                	test   %eax,%eax
    b5e8:	0f 84 d6 00 00 00    	je     b6c4 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b5ee:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b5f1:	89 d0                	mov    %edx,%eax
    b5f3:	01 c0                	add    %eax,%eax
    b5f5:	01 d0                	add    %edx,%eax
    b5f7:	01 c0                	add    %eax,%eax
    b5f9:	89 c2                	mov    %eax,%edx
    b5fb:	8b 45 10             	mov    0x10(%ebp),%eax
    b5fe:	01 d0                	add    %edx,%eax
    b600:	0f b6 00             	movzbl (%eax),%eax
    b603:	0f b6 c0             	movzbl %al,%eax
    b606:	c1 e0 08             	shl    $0x8,%eax
    b609:	89 c3                	mov    %eax,%ebx
    b60b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b60e:	89 d0                	mov    %edx,%eax
    b610:	01 c0                	add    %eax,%eax
    b612:	01 d0                	add    %edx,%eax
    b614:	01 c0                	add    %eax,%eax
    b616:	8d 50 01             	lea    0x1(%eax),%edx
    b619:	8b 45 10             	mov    0x10(%ebp),%eax
    b61c:	01 d0                	add    %edx,%eax
    b61e:	0f b6 00             	movzbl (%eax),%eax
    b621:	0f b6 c0             	movzbl %al,%eax
    b624:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b627:	8b 45 14             	mov    0x14(%ebp),%eax
    b62a:	8b 40 14             	mov    0x14(%eax),%eax
    b62d:	39 c2                	cmp    %eax,%edx
    b62f:	0f 85 8f 00 00 00    	jne    b6c4 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b635:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b638:	89 d0                	mov    %edx,%eax
    b63a:	01 c0                	add    %eax,%eax
    b63c:	01 d0                	add    %edx,%eax
    b63e:	01 c0                	add    %eax,%eax
    b640:	8d 50 02             	lea    0x2(%eax),%edx
    b643:	8b 45 10             	mov    0x10(%ebp),%eax
    b646:	01 d0                	add    %edx,%eax
    b648:	0f b6 00             	movzbl (%eax),%eax
    b64b:	0f b6 c0             	movzbl %al,%eax
    b64e:	c1 e0 08             	shl    $0x8,%eax
    b651:	89 c3                	mov    %eax,%ebx
    b653:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b656:	89 d0                	mov    %edx,%eax
    b658:	01 c0                	add    %eax,%eax
    b65a:	01 d0                	add    %edx,%eax
    b65c:	01 c0                	add    %eax,%eax
    b65e:	8d 50 03             	lea    0x3(%eax),%edx
    b661:	8b 45 10             	mov    0x10(%ebp),%eax
    b664:	01 d0                	add    %edx,%eax
    b666:	0f b6 00             	movzbl (%eax),%eax
    b669:	0f b6 c0             	movzbl %al,%eax
    b66c:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b66f:	8b 45 14             	mov    0x14(%ebp),%eax
    b672:	8b 40 18             	mov    0x18(%eax),%eax
    b675:	39 c2                	cmp    %eax,%edx
    b677:	75 4b                	jne    b6c4 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    b679:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b67c:	89 d0                	mov    %edx,%eax
    b67e:	01 c0                	add    %eax,%eax
    b680:	01 d0                	add    %edx,%eax
    b682:	01 c0                	add    %eax,%eax
    b684:	8d 50 04             	lea    0x4(%eax),%edx
    b687:	8b 45 10             	mov    0x10(%ebp),%eax
    b68a:	01 d0                	add    %edx,%eax
    b68c:	0f b6 00             	movzbl (%eax),%eax
    b68f:	0f b6 c0             	movzbl %al,%eax
    b692:	c1 e0 08             	shl    $0x8,%eax
    b695:	89 c3                	mov    %eax,%ebx
    b697:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b69a:	89 d0                	mov    %edx,%eax
    b69c:	01 c0                	add    %eax,%eax
    b69e:	01 d0                	add    %edx,%eax
    b6a0:	01 c0                	add    %eax,%eax
    b6a2:	8d 50 05             	lea    0x5(%eax),%edx
    b6a5:	8b 45 10             	mov    0x10(%ebp),%eax
    b6a8:	01 d0                	add    %edx,%eax
    b6aa:	0f b6 00             	movzbl (%eax),%eax
    b6ad:	0f b6 c0             	movzbl %al,%eax
    b6b0:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b6b3:	8b 45 14             	mov    0x14(%ebp),%eax
    b6b6:	8b 40 1c             	mov    0x1c(%eax),%eax
    b6b9:	39 c2                	cmp    %eax,%edx
    b6bb:	75 07                	jne    b6c4 <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    b6bd:	b8 00 00 00 00       	mov    $0x0,%eax
    b6c2:	eb 05                	jmp    b6c9 <getPixelColorsRGBA8+0x461>
    b6c4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b6c9:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b6cb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b6cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b6d2:	01 45 08             	add    %eax,0x8(%ebp)
    b6d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6d8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b6db:	0f 85 a3 fe ff ff    	jne    b584 <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b6e1:	e9 4c 02 00 00       	jmp    b932 <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b6e6:	8b 45 14             	mov    0x14(%ebp),%eax
    b6e9:	8b 00                	mov    (%eax),%eax
    b6eb:	83 f8 03             	cmp    $0x3,%eax
    b6ee:	0f 85 b4 00 00 00    	jne    b7a8 <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    b6f4:	8b 45 14             	mov    0x14(%ebp),%eax
    b6f7:	8b 40 04             	mov    0x4(%eax),%eax
    b6fa:	83 f8 08             	cmp    $0x8,%eax
    b6fd:	75 4d                	jne    b74c <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b6ff:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b706:	eb 37                	jmp    b73f <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    b708:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b70b:	8b 45 10             	mov    0x10(%ebp),%eax
    b70e:	01 d0                	add    %edx,%eax
    b710:	0f b6 00             	movzbl (%eax),%eax
    b713:	0f b6 c0             	movzbl %al,%eax
    b716:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b719:	8b 45 14             	mov    0x14(%ebp),%eax
    b71c:	8b 40 08             	mov    0x8(%eax),%eax
    b71f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b722:	c1 e2 02             	shl    $0x2,%edx
    b725:	01 d0                	add    %edx,%eax
    b727:	6a 04                	push   $0x4
    b729:	50                   	push   %eax
    b72a:	ff 75 08             	pushl  0x8(%ebp)
    b72d:	e8 49 83 ff ff       	call   3a7b <lodepng_memcpy>
    b732:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b735:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b739:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b73c:	01 45 08             	add    %eax,0x8(%ebp)
    b73f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b742:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b745:	75 c1                	jne    b708 <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b747:	e9 e6 01 00 00       	jmp    b932 <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    b74c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b753:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b75a:	eb 3f                	jmp    b79b <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b75c:	8b 45 14             	mov    0x14(%ebp),%eax
    b75f:	8b 40 04             	mov    0x4(%eax),%eax
    b762:	50                   	push   %eax
    b763:	ff 75 10             	pushl  0x10(%ebp)
    b766:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b769:	50                   	push   %eax
    b76a:	e8 71 d1 ff ff       	call   88e0 <readBitsFromReversedStream>
    b76f:	83 c4 0c             	add    $0xc,%esp
    b772:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b775:	8b 45 14             	mov    0x14(%ebp),%eax
    b778:	8b 40 08             	mov    0x8(%eax),%eax
    b77b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b77e:	c1 e2 02             	shl    $0x2,%edx
    b781:	01 d0                	add    %edx,%eax
    b783:	6a 04                	push   $0x4
    b785:	50                   	push   %eax
    b786:	ff 75 08             	pushl  0x8(%ebp)
    b789:	e8 ed 82 ff ff       	call   3a7b <lodepng_memcpy>
    b78e:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b791:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b795:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b798:	01 45 08             	add    %eax,0x8(%ebp)
    b79b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b79e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b7a1:	75 b9                	jne    b75c <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b7a3:	e9 8a 01 00 00       	jmp    b932 <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b7a8:	8b 45 14             	mov    0x14(%ebp),%eax
    b7ab:	8b 00                	mov    (%eax),%eax
    b7ad:	83 f8 04             	cmp    $0x4,%eax
    b7b0:	0f 85 d1 00 00 00    	jne    b887 <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b7b6:	8b 45 14             	mov    0x14(%ebp),%eax
    b7b9:	8b 40 04             	mov    0x4(%eax),%eax
    b7bc:	83 f8 08             	cmp    $0x8,%eax
    b7bf:	75 62                	jne    b823 <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b7c1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b7c8:	eb 4c                	jmp    b816 <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b7ca:	8b 45 08             	mov    0x8(%ebp),%eax
    b7cd:	83 c0 01             	add    $0x1,%eax
    b7d0:	8b 55 08             	mov    0x8(%ebp),%edx
    b7d3:	83 c2 02             	add    $0x2,%edx
    b7d6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b7d9:	01 c9                	add    %ecx,%ecx
    b7db:	89 cb                	mov    %ecx,%ebx
    b7dd:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b7e0:	01 d9                	add    %ebx,%ecx
    b7e2:	0f b6 09             	movzbl (%ecx),%ecx
    b7e5:	88 0a                	mov    %cl,(%edx)
    b7e7:	0f b6 12             	movzbl (%edx),%edx
    b7ea:	88 10                	mov    %dl,(%eax)
    b7ec:	0f b6 10             	movzbl (%eax),%edx
    b7ef:	8b 45 08             	mov    0x8(%ebp),%eax
    b7f2:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b7f4:	8b 45 08             	mov    0x8(%ebp),%eax
    b7f7:	8d 50 03             	lea    0x3(%eax),%edx
    b7fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b7fd:	01 c0                	add    %eax,%eax
    b7ff:	8d 48 01             	lea    0x1(%eax),%ecx
    b802:	8b 45 10             	mov    0x10(%ebp),%eax
    b805:	01 c8                	add    %ecx,%eax
    b807:	0f b6 00             	movzbl (%eax),%eax
    b80a:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b80c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b810:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b813:	01 45 08             	add    %eax,0x8(%ebp)
    b816:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b819:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b81c:	75 ac                	jne    b7ca <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b81e:	e9 0f 01 00 00       	jmp    b932 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b823:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b82a:	eb 4e                	jmp    b87a <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b82c:	8b 45 08             	mov    0x8(%ebp),%eax
    b82f:	83 c0 01             	add    $0x1,%eax
    b832:	8b 55 08             	mov    0x8(%ebp),%edx
    b835:	83 c2 02             	add    $0x2,%edx
    b838:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b83b:	c1 e1 02             	shl    $0x2,%ecx
    b83e:	89 cb                	mov    %ecx,%ebx
    b840:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b843:	01 d9                	add    %ebx,%ecx
    b845:	0f b6 09             	movzbl (%ecx),%ecx
    b848:	88 0a                	mov    %cl,(%edx)
    b84a:	0f b6 12             	movzbl (%edx),%edx
    b84d:	88 10                	mov    %dl,(%eax)
    b84f:	0f b6 10             	movzbl (%eax),%edx
    b852:	8b 45 08             	mov    0x8(%ebp),%eax
    b855:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b857:	8b 45 08             	mov    0x8(%ebp),%eax
    b85a:	8d 50 03             	lea    0x3(%eax),%edx
    b85d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b860:	c1 e0 02             	shl    $0x2,%eax
    b863:	8d 48 02             	lea    0x2(%eax),%ecx
    b866:	8b 45 10             	mov    0x10(%ebp),%eax
    b869:	01 c8                	add    %ecx,%eax
    b86b:	0f b6 00             	movzbl (%eax),%eax
    b86e:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b870:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b874:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b877:	01 45 08             	add    %eax,0x8(%ebp)
    b87a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b87d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b880:	75 aa                	jne    b82c <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b882:	e9 ab 00 00 00       	jmp    b932 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b887:	8b 45 14             	mov    0x14(%ebp),%eax
    b88a:	8b 00                	mov    (%eax),%eax
    b88c:	83 f8 06             	cmp    $0x6,%eax
    b88f:	0f 85 9d 00 00 00    	jne    b932 <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b895:	8b 45 14             	mov    0x14(%ebp),%eax
    b898:	8b 40 04             	mov    0x4(%eax),%eax
    b89b:	83 f8 08             	cmp    $0x8,%eax
    b89e:	75 17                	jne    b8b7 <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b8a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8a3:	c1 e0 02             	shl    $0x2,%eax
    b8a6:	50                   	push   %eax
    b8a7:	ff 75 10             	pushl  0x10(%ebp)
    b8aa:	ff 75 08             	pushl  0x8(%ebp)
    b8ad:	e8 c9 81 ff ff       	call   3a7b <lodepng_memcpy>
    b8b2:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b8b5:	eb 7b                	jmp    b932 <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b8b7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b8be:	eb 6a                	jmp    b92a <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b8c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b8c3:	c1 e0 03             	shl    $0x3,%eax
    b8c6:	89 c2                	mov    %eax,%edx
    b8c8:	8b 45 10             	mov    0x10(%ebp),%eax
    b8cb:	01 d0                	add    %edx,%eax
    b8cd:	0f b6 10             	movzbl (%eax),%edx
    b8d0:	8b 45 08             	mov    0x8(%ebp),%eax
    b8d3:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b8d5:	8b 45 08             	mov    0x8(%ebp),%eax
    b8d8:	8d 50 01             	lea    0x1(%eax),%edx
    b8db:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b8de:	c1 e0 03             	shl    $0x3,%eax
    b8e1:	8d 48 02             	lea    0x2(%eax),%ecx
    b8e4:	8b 45 10             	mov    0x10(%ebp),%eax
    b8e7:	01 c8                	add    %ecx,%eax
    b8e9:	0f b6 00             	movzbl (%eax),%eax
    b8ec:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b8ee:	8b 45 08             	mov    0x8(%ebp),%eax
    b8f1:	8d 50 02             	lea    0x2(%eax),%edx
    b8f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b8f7:	c1 e0 03             	shl    $0x3,%eax
    b8fa:	8d 48 04             	lea    0x4(%eax),%ecx
    b8fd:	8b 45 10             	mov    0x10(%ebp),%eax
    b900:	01 c8                	add    %ecx,%eax
    b902:	0f b6 00             	movzbl (%eax),%eax
    b905:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b907:	8b 45 08             	mov    0x8(%ebp),%eax
    b90a:	8d 50 03             	lea    0x3(%eax),%edx
    b90d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b910:	c1 e0 03             	shl    $0x3,%eax
    b913:	8d 48 06             	lea    0x6(%eax),%ecx
    b916:	8b 45 10             	mov    0x10(%ebp),%eax
    b919:	01 c8                	add    %ecx,%eax
    b91b:	0f b6 00             	movzbl (%eax),%eax
    b91e:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b920:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b924:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b927:	01 45 08             	add    %eax,0x8(%ebp)
    b92a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b92d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b930:	75 8e                	jne    b8c0 <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b932:	90                   	nop
    b933:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b936:	c9                   	leave  
    b937:	c3                   	ret    

0000b938 <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b938:	55                   	push   %ebp
    b939:	89 e5                	mov    %esp,%ebp
    b93b:	53                   	push   %ebx
    b93c:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b93f:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b946:	8b 45 14             	mov    0x14(%ebp),%eax
    b949:	8b 00                	mov    (%eax),%eax
    b94b:	85 c0                	test   %eax,%eax
    b94d:	0f 85 2a 01 00 00    	jne    ba7d <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b953:	8b 45 14             	mov    0x14(%ebp),%eax
    b956:	8b 40 04             	mov    0x4(%eax),%eax
    b959:	83 f8 08             	cmp    $0x8,%eax
    b95c:	75 46                	jne    b9a4 <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b95e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b965:	eb 30                	jmp    b997 <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b967:	8b 45 08             	mov    0x8(%ebp),%eax
    b96a:	83 c0 01             	add    $0x1,%eax
    b96d:	8b 55 08             	mov    0x8(%ebp),%edx
    b970:	83 c2 02             	add    $0x2,%edx
    b973:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b976:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b979:	01 d9                	add    %ebx,%ecx
    b97b:	0f b6 09             	movzbl (%ecx),%ecx
    b97e:	88 0a                	mov    %cl,(%edx)
    b980:	0f b6 12             	movzbl (%edx),%edx
    b983:	88 10                	mov    %dl,(%eax)
    b985:	0f b6 10             	movzbl (%eax),%edx
    b988:	8b 45 08             	mov    0x8(%ebp),%eax
    b98b:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b98d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b991:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b994:	01 45 08             	add    %eax,0x8(%ebp)
    b997:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b99a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b99d:	75 c8                	jne    b967 <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b99f:	e9 a8 03 00 00       	jmp    bd4c <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b9a4:	8b 45 14             	mov    0x14(%ebp),%eax
    b9a7:	8b 40 04             	mov    0x4(%eax),%eax
    b9aa:	83 f8 10             	cmp    $0x10,%eax
    b9ad:	75 4a                	jne    b9f9 <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b9af:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b9b6:	eb 34                	jmp    b9ec <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b9b8:	8b 45 08             	mov    0x8(%ebp),%eax
    b9bb:	83 c0 01             	add    $0x1,%eax
    b9be:	8b 55 08             	mov    0x8(%ebp),%edx
    b9c1:	83 c2 02             	add    $0x2,%edx
    b9c4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b9c7:	01 c9                	add    %ecx,%ecx
    b9c9:	89 cb                	mov    %ecx,%ebx
    b9cb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b9ce:	01 d9                	add    %ebx,%ecx
    b9d0:	0f b6 09             	movzbl (%ecx),%ecx
    b9d3:	88 0a                	mov    %cl,(%edx)
    b9d5:	0f b6 12             	movzbl (%edx),%edx
    b9d8:	88 10                	mov    %dl,(%eax)
    b9da:	0f b6 10             	movzbl (%eax),%edx
    b9dd:	8b 45 08             	mov    0x8(%ebp),%eax
    b9e0:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b9e2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b9e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b9e9:	01 45 08             	add    %eax,0x8(%ebp)
    b9ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b9ef:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b9f2:	75 c4                	jne    b9b8 <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b9f4:	e9 53 03 00 00       	jmp    bd4c <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b9f9:	8b 45 14             	mov    0x14(%ebp),%eax
    b9fc:	8b 40 04             	mov    0x4(%eax),%eax
    b9ff:	ba 01 00 00 00       	mov    $0x1,%edx
    ba04:	89 c1                	mov    %eax,%ecx
    ba06:	d3 e2                	shl    %cl,%edx
    ba08:	89 d0                	mov    %edx,%eax
    ba0a:	83 e8 01             	sub    $0x1,%eax
    ba0d:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    ba10:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ba17:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ba1e:	eb 50                	jmp    ba70 <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ba20:	8b 45 14             	mov    0x14(%ebp),%eax
    ba23:	8b 40 04             	mov    0x4(%eax),%eax
    ba26:	50                   	push   %eax
    ba27:	ff 75 10             	pushl  0x10(%ebp)
    ba2a:	8d 45 e0             	lea    -0x20(%ebp),%eax
    ba2d:	50                   	push   %eax
    ba2e:	e8 ad ce ff ff       	call   88e0 <readBitsFromReversedStream>
    ba33:	83 c4 0c             	add    $0xc,%esp
    ba36:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    ba39:	8b 45 08             	mov    0x8(%ebp),%eax
    ba3c:	8d 48 01             	lea    0x1(%eax),%ecx
    ba3f:	8b 45 08             	mov    0x8(%ebp),%eax
    ba42:	8d 58 02             	lea    0x2(%eax),%ebx
    ba45:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ba48:	89 d0                	mov    %edx,%eax
    ba4a:	c1 e0 08             	shl    $0x8,%eax
    ba4d:	29 d0                	sub    %edx,%eax
    ba4f:	ba 00 00 00 00       	mov    $0x0,%edx
    ba54:	f7 75 f0             	divl   -0x10(%ebp)
    ba57:	88 03                	mov    %al,(%ebx)
    ba59:	0f b6 03             	movzbl (%ebx),%eax
    ba5c:	88 01                	mov    %al,(%ecx)
    ba5e:	0f b6 11             	movzbl (%ecx),%edx
    ba61:	8b 45 08             	mov    0x8(%ebp),%eax
    ba64:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ba66:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ba6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ba6d:	01 45 08             	add    %eax,0x8(%ebp)
    ba70:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ba73:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ba76:	75 a8                	jne    ba20 <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    ba78:	e9 cf 02 00 00       	jmp    bd4c <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    ba7d:	8b 45 14             	mov    0x14(%ebp),%eax
    ba80:	8b 00                	mov    (%eax),%eax
    ba82:	83 f8 02             	cmp    $0x2,%eax
    ba85:	0f 85 9e 00 00 00    	jne    bb29 <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    ba8b:	8b 45 14             	mov    0x14(%ebp),%eax
    ba8e:	8b 40 04             	mov    0x4(%eax),%eax
    ba91:	83 f8 08             	cmp    $0x8,%eax
    ba94:	75 1d                	jne    bab3 <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    ba96:	8b 55 0c             	mov    0xc(%ebp),%edx
    ba99:	89 d0                	mov    %edx,%eax
    ba9b:	01 c0                	add    %eax,%eax
    ba9d:	01 d0                	add    %edx,%eax
    ba9f:	50                   	push   %eax
    baa0:	ff 75 10             	pushl  0x10(%ebp)
    baa3:	ff 75 08             	pushl  0x8(%ebp)
    baa6:	e8 d0 7f ff ff       	call   3a7b <lodepng_memcpy>
    baab:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    baae:	e9 99 02 00 00       	jmp    bd4c <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bab3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    baba:	eb 60                	jmp    bb1c <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    babc:	8b 55 f8             	mov    -0x8(%ebp),%edx
    babf:	89 d0                	mov    %edx,%eax
    bac1:	01 c0                	add    %eax,%eax
    bac3:	01 d0                	add    %edx,%eax
    bac5:	01 c0                	add    %eax,%eax
    bac7:	89 c2                	mov    %eax,%edx
    bac9:	8b 45 10             	mov    0x10(%ebp),%eax
    bacc:	01 d0                	add    %edx,%eax
    bace:	0f b6 10             	movzbl (%eax),%edx
    bad1:	8b 45 08             	mov    0x8(%ebp),%eax
    bad4:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    bad6:	8b 45 08             	mov    0x8(%ebp),%eax
    bad9:	8d 48 01             	lea    0x1(%eax),%ecx
    badc:	8b 55 f8             	mov    -0x8(%ebp),%edx
    badf:	89 d0                	mov    %edx,%eax
    bae1:	01 c0                	add    %eax,%eax
    bae3:	01 d0                	add    %edx,%eax
    bae5:	01 c0                	add    %eax,%eax
    bae7:	8d 50 02             	lea    0x2(%eax),%edx
    baea:	8b 45 10             	mov    0x10(%ebp),%eax
    baed:	01 d0                	add    %edx,%eax
    baef:	0f b6 00             	movzbl (%eax),%eax
    baf2:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    baf4:	8b 45 08             	mov    0x8(%ebp),%eax
    baf7:	8d 48 02             	lea    0x2(%eax),%ecx
    bafa:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bafd:	89 d0                	mov    %edx,%eax
    baff:	01 c0                	add    %eax,%eax
    bb01:	01 d0                	add    %edx,%eax
    bb03:	01 c0                	add    %eax,%eax
    bb05:	8d 50 04             	lea    0x4(%eax),%edx
    bb08:	8b 45 10             	mov    0x10(%ebp),%eax
    bb0b:	01 d0                	add    %edx,%eax
    bb0d:	0f b6 00             	movzbl (%eax),%eax
    bb10:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bb12:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bb16:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bb19:	01 45 08             	add    %eax,0x8(%ebp)
    bb1c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bb1f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bb22:	75 98                	jne    babc <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bb24:	e9 23 02 00 00       	jmp    bd4c <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    bb29:	8b 45 14             	mov    0x14(%ebp),%eax
    bb2c:	8b 00                	mov    (%eax),%eax
    bb2e:	83 f8 03             	cmp    $0x3,%eax
    bb31:	0f 85 b4 00 00 00    	jne    bbeb <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    bb37:	8b 45 14             	mov    0x14(%ebp),%eax
    bb3a:	8b 40 04             	mov    0x4(%eax),%eax
    bb3d:	83 f8 08             	cmp    $0x8,%eax
    bb40:	75 4d                	jne    bb8f <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bb42:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bb49:	eb 37                	jmp    bb82 <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    bb4b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bb4e:	8b 45 10             	mov    0x10(%ebp),%eax
    bb51:	01 d0                	add    %edx,%eax
    bb53:	0f b6 00             	movzbl (%eax),%eax
    bb56:	0f b6 c0             	movzbl %al,%eax
    bb59:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    bb5c:	8b 45 14             	mov    0x14(%ebp),%eax
    bb5f:	8b 40 08             	mov    0x8(%eax),%eax
    bb62:	8b 55 e8             	mov    -0x18(%ebp),%edx
    bb65:	c1 e2 02             	shl    $0x2,%edx
    bb68:	01 d0                	add    %edx,%eax
    bb6a:	6a 03                	push   $0x3
    bb6c:	50                   	push   %eax
    bb6d:	ff 75 08             	pushl  0x8(%ebp)
    bb70:	e8 06 7f ff ff       	call   3a7b <lodepng_memcpy>
    bb75:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bb78:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bb7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bb7f:	01 45 08             	add    %eax,0x8(%ebp)
    bb82:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bb85:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bb88:	75 c1                	jne    bb4b <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bb8a:	e9 bd 01 00 00       	jmp    bd4c <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    bb8f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bb96:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bb9d:	eb 3f                	jmp    bbde <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    bb9f:	8b 45 14             	mov    0x14(%ebp),%eax
    bba2:	8b 40 04             	mov    0x4(%eax),%eax
    bba5:	50                   	push   %eax
    bba6:	ff 75 10             	pushl  0x10(%ebp)
    bba9:	8d 45 dc             	lea    -0x24(%ebp),%eax
    bbac:	50                   	push   %eax
    bbad:	e8 2e cd ff ff       	call   88e0 <readBitsFromReversedStream>
    bbb2:	83 c4 0c             	add    $0xc,%esp
    bbb5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    bbb8:	8b 45 14             	mov    0x14(%ebp),%eax
    bbbb:	8b 40 08             	mov    0x8(%eax),%eax
    bbbe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bbc1:	c1 e2 02             	shl    $0x2,%edx
    bbc4:	01 d0                	add    %edx,%eax
    bbc6:	6a 03                	push   $0x3
    bbc8:	50                   	push   %eax
    bbc9:	ff 75 08             	pushl  0x8(%ebp)
    bbcc:	e8 aa 7e ff ff       	call   3a7b <lodepng_memcpy>
    bbd1:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bbd4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bbd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bbdb:	01 45 08             	add    %eax,0x8(%ebp)
    bbde:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bbe1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bbe4:	75 b9                	jne    bb9f <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bbe6:	e9 61 01 00 00       	jmp    bd4c <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    bbeb:	8b 45 14             	mov    0x14(%ebp),%eax
    bbee:	8b 00                	mov    (%eax),%eax
    bbf0:	83 f8 04             	cmp    $0x4,%eax
    bbf3:	0f 85 a0 00 00 00    	jne    bc99 <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    bbf9:	8b 45 14             	mov    0x14(%ebp),%eax
    bbfc:	8b 40 04             	mov    0x4(%eax),%eax
    bbff:	83 f8 08             	cmp    $0x8,%eax
    bc02:	75 4a                	jne    bc4e <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bc04:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bc0b:	eb 34                	jmp    bc41 <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    bc0d:	8b 45 08             	mov    0x8(%ebp),%eax
    bc10:	83 c0 01             	add    $0x1,%eax
    bc13:	8b 55 08             	mov    0x8(%ebp),%edx
    bc16:	83 c2 02             	add    $0x2,%edx
    bc19:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    bc1c:	01 c9                	add    %ecx,%ecx
    bc1e:	89 cb                	mov    %ecx,%ebx
    bc20:	8b 4d 10             	mov    0x10(%ebp),%ecx
    bc23:	01 d9                	add    %ebx,%ecx
    bc25:	0f b6 09             	movzbl (%ecx),%ecx
    bc28:	88 0a                	mov    %cl,(%edx)
    bc2a:	0f b6 12             	movzbl (%edx),%edx
    bc2d:	88 10                	mov    %dl,(%eax)
    bc2f:	0f b6 10             	movzbl (%eax),%edx
    bc32:	8b 45 08             	mov    0x8(%ebp),%eax
    bc35:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bc37:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bc3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bc3e:	01 45 08             	add    %eax,0x8(%ebp)
    bc41:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bc44:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bc47:	75 c4                	jne    bc0d <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bc49:	e9 fe 00 00 00       	jmp    bd4c <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bc4e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bc55:	eb 35                	jmp    bc8c <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    bc57:	8b 45 08             	mov    0x8(%ebp),%eax
    bc5a:	83 c0 01             	add    $0x1,%eax
    bc5d:	8b 55 08             	mov    0x8(%ebp),%edx
    bc60:	83 c2 02             	add    $0x2,%edx
    bc63:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    bc66:	c1 e1 02             	shl    $0x2,%ecx
    bc69:	89 cb                	mov    %ecx,%ebx
    bc6b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    bc6e:	01 d9                	add    %ebx,%ecx
    bc70:	0f b6 09             	movzbl (%ecx),%ecx
    bc73:	88 0a                	mov    %cl,(%edx)
    bc75:	0f b6 12             	movzbl (%edx),%edx
    bc78:	88 10                	mov    %dl,(%eax)
    bc7a:	0f b6 10             	movzbl (%eax),%edx
    bc7d:	8b 45 08             	mov    0x8(%ebp),%eax
    bc80:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bc82:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bc86:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bc89:	01 45 08             	add    %eax,0x8(%ebp)
    bc8c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bc8f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bc92:	75 c3                	jne    bc57 <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bc94:	e9 b3 00 00 00       	jmp    bd4c <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    bc99:	8b 45 14             	mov    0x14(%ebp),%eax
    bc9c:	8b 00                	mov    (%eax),%eax
    bc9e:	83 f8 06             	cmp    $0x6,%eax
    bca1:	0f 85 a5 00 00 00    	jne    bd4c <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    bca7:	8b 45 14             	mov    0x14(%ebp),%eax
    bcaa:	8b 40 04             	mov    0x4(%eax),%eax
    bcad:	83 f8 08             	cmp    $0x8,%eax
    bcb0:	75 38                	jne    bcea <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bcb2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bcb9:	eb 25                	jmp    bce0 <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    bcbb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bcbe:	c1 e0 02             	shl    $0x2,%eax
    bcc1:	89 c2                	mov    %eax,%edx
    bcc3:	8b 45 10             	mov    0x10(%ebp),%eax
    bcc6:	01 d0                	add    %edx,%eax
    bcc8:	6a 03                	push   $0x3
    bcca:	50                   	push   %eax
    bccb:	ff 75 08             	pushl  0x8(%ebp)
    bcce:	e8 a8 7d ff ff       	call   3a7b <lodepng_memcpy>
    bcd3:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bcd6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bcda:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bcdd:	01 45 08             	add    %eax,0x8(%ebp)
    bce0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bce3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bce6:	75 d3                	jne    bcbb <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bce8:	eb 62                	jmp    bd4c <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bcea:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bcf1:	eb 51                	jmp    bd44 <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    bcf3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bcf6:	c1 e0 03             	shl    $0x3,%eax
    bcf9:	89 c2                	mov    %eax,%edx
    bcfb:	8b 45 10             	mov    0x10(%ebp),%eax
    bcfe:	01 d0                	add    %edx,%eax
    bd00:	0f b6 10             	movzbl (%eax),%edx
    bd03:	8b 45 08             	mov    0x8(%ebp),%eax
    bd06:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    bd08:	8b 45 08             	mov    0x8(%ebp),%eax
    bd0b:	8d 50 01             	lea    0x1(%eax),%edx
    bd0e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bd11:	c1 e0 03             	shl    $0x3,%eax
    bd14:	8d 48 02             	lea    0x2(%eax),%ecx
    bd17:	8b 45 10             	mov    0x10(%ebp),%eax
    bd1a:	01 c8                	add    %ecx,%eax
    bd1c:	0f b6 00             	movzbl (%eax),%eax
    bd1f:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    bd21:	8b 45 08             	mov    0x8(%ebp),%eax
    bd24:	8d 50 02             	lea    0x2(%eax),%edx
    bd27:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bd2a:	c1 e0 03             	shl    $0x3,%eax
    bd2d:	8d 48 04             	lea    0x4(%eax),%ecx
    bd30:	8b 45 10             	mov    0x10(%ebp),%eax
    bd33:	01 c8                	add    %ecx,%eax
    bd35:	0f b6 00             	movzbl (%eax),%eax
    bd38:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bd3a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bd3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bd41:	01 45 08             	add    %eax,0x8(%ebp)
    bd44:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bd47:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bd4a:	75 a7                	jne    bcf3 <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bd4c:	90                   	nop
    bd4d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    bd50:	c9                   	leave  
    bd51:	c3                   	ret    

0000bd52 <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    bd52:	55                   	push   %ebp
    bd53:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    bd55:	8b 45 20             	mov    0x20(%ebp),%eax
    bd58:	8b 00                	mov    (%eax),%eax
    bd5a:	85 c0                	test   %eax,%eax
    bd5c:	0f 85 a4 00 00 00    	jne    be06 <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    bd62:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bd65:	01 c0                	add    %eax,%eax
    bd67:	89 c2                	mov    %eax,%edx
    bd69:	8b 45 18             	mov    0x18(%ebp),%eax
    bd6c:	01 d0                	add    %edx,%eax
    bd6e:	0f b6 00             	movzbl (%eax),%eax
    bd71:	0f b6 c0             	movzbl %al,%eax
    bd74:	c1 e0 08             	shl    $0x8,%eax
    bd77:	89 c2                	mov    %eax,%edx
    bd79:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bd7c:	01 c0                	add    %eax,%eax
    bd7e:	8d 48 01             	lea    0x1(%eax),%ecx
    bd81:	8b 45 18             	mov    0x18(%ebp),%eax
    bd84:	01 c8                	add    %ecx,%eax
    bd86:	0f b6 00             	movzbl (%eax),%eax
    bd89:	0f b6 c0             	movzbl %al,%eax
    bd8c:	01 c2                	add    %eax,%edx
    bd8e:	8b 45 10             	mov    0x10(%ebp),%eax
    bd91:	66 89 10             	mov    %dx,(%eax)
    bd94:	8b 45 10             	mov    0x10(%ebp),%eax
    bd97:	0f b7 10             	movzwl (%eax),%edx
    bd9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    bd9d:	66 89 10             	mov    %dx,(%eax)
    bda0:	8b 45 0c             	mov    0xc(%ebp),%eax
    bda3:	0f b7 10             	movzwl (%eax),%edx
    bda6:	8b 45 08             	mov    0x8(%ebp),%eax
    bda9:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    bdac:	8b 45 20             	mov    0x20(%ebp),%eax
    bdaf:	8b 40 10             	mov    0x10(%eax),%eax
    bdb2:	85 c0                	test   %eax,%eax
    bdb4:	74 43                	je     bdf9 <getPixelColorRGBA16+0xa7>
    bdb6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bdb9:	01 c0                	add    %eax,%eax
    bdbb:	89 c2                	mov    %eax,%edx
    bdbd:	8b 45 18             	mov    0x18(%ebp),%eax
    bdc0:	01 d0                	add    %edx,%eax
    bdc2:	0f b6 00             	movzbl (%eax),%eax
    bdc5:	0f b6 c0             	movzbl %al,%eax
    bdc8:	c1 e0 08             	shl    $0x8,%eax
    bdcb:	89 c2                	mov    %eax,%edx
    bdcd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bdd0:	01 c0                	add    %eax,%eax
    bdd2:	8d 48 01             	lea    0x1(%eax),%ecx
    bdd5:	8b 45 18             	mov    0x18(%ebp),%eax
    bdd8:	01 c8                	add    %ecx,%eax
    bdda:	0f b6 00             	movzbl (%eax),%eax
    bddd:	0f b6 c0             	movzbl %al,%eax
    bde0:	01 c2                	add    %eax,%edx
    bde2:	8b 45 20             	mov    0x20(%ebp),%eax
    bde5:	8b 40 14             	mov    0x14(%eax),%eax
    bde8:	39 c2                	cmp    %eax,%edx
    bdea:	75 0d                	jne    bdf9 <getPixelColorRGBA16+0xa7>
    bdec:	8b 45 14             	mov    0x14(%ebp),%eax
    bdef:	66 c7 00 00 00       	movw   $0x0,(%eax)
    bdf4:	e9 48 03 00 00       	jmp    c141 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    bdf9:	8b 45 14             	mov    0x14(%ebp),%eax
    bdfc:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    be01:	e9 3b 03 00 00       	jmp    c141 <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    be06:	8b 45 20             	mov    0x20(%ebp),%eax
    be09:	8b 00                	mov    (%eax),%eax
    be0b:	83 f8 02             	cmp    $0x2,%eax
    be0e:	0f 85 b6 01 00 00    	jne    bfca <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    be14:	8b 55 1c             	mov    0x1c(%ebp),%edx
    be17:	89 d0                	mov    %edx,%eax
    be19:	01 c0                	add    %eax,%eax
    be1b:	01 d0                	add    %edx,%eax
    be1d:	01 c0                	add    %eax,%eax
    be1f:	89 c2                	mov    %eax,%edx
    be21:	8b 45 18             	mov    0x18(%ebp),%eax
    be24:	01 d0                	add    %edx,%eax
    be26:	0f b6 00             	movzbl (%eax),%eax
    be29:	0f b6 c0             	movzbl %al,%eax
    be2c:	c1 e0 08             	shl    $0x8,%eax
    be2f:	89 c1                	mov    %eax,%ecx
    be31:	8b 55 1c             	mov    0x1c(%ebp),%edx
    be34:	89 d0                	mov    %edx,%eax
    be36:	01 c0                	add    %eax,%eax
    be38:	01 d0                	add    %edx,%eax
    be3a:	01 c0                	add    %eax,%eax
    be3c:	8d 50 01             	lea    0x1(%eax),%edx
    be3f:	8b 45 18             	mov    0x18(%ebp),%eax
    be42:	01 d0                	add    %edx,%eax
    be44:	0f b6 00             	movzbl (%eax),%eax
    be47:	0f b6 c0             	movzbl %al,%eax
    be4a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    be4d:	8b 45 08             	mov    0x8(%ebp),%eax
    be50:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    be53:	8b 55 1c             	mov    0x1c(%ebp),%edx
    be56:	89 d0                	mov    %edx,%eax
    be58:	01 c0                	add    %eax,%eax
    be5a:	01 d0                	add    %edx,%eax
    be5c:	01 c0                	add    %eax,%eax
    be5e:	8d 50 02             	lea    0x2(%eax),%edx
    be61:	8b 45 18             	mov    0x18(%ebp),%eax
    be64:	01 d0                	add    %edx,%eax
    be66:	0f b6 00             	movzbl (%eax),%eax
    be69:	0f b6 c0             	movzbl %al,%eax
    be6c:	c1 e0 08             	shl    $0x8,%eax
    be6f:	89 c1                	mov    %eax,%ecx
    be71:	8b 55 1c             	mov    0x1c(%ebp),%edx
    be74:	89 d0                	mov    %edx,%eax
    be76:	01 c0                	add    %eax,%eax
    be78:	01 d0                	add    %edx,%eax
    be7a:	01 c0                	add    %eax,%eax
    be7c:	8d 50 03             	lea    0x3(%eax),%edx
    be7f:	8b 45 18             	mov    0x18(%ebp),%eax
    be82:	01 d0                	add    %edx,%eax
    be84:	0f b6 00             	movzbl (%eax),%eax
    be87:	0f b6 c0             	movzbl %al,%eax
    be8a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    be8d:	8b 45 0c             	mov    0xc(%ebp),%eax
    be90:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    be93:	8b 55 1c             	mov    0x1c(%ebp),%edx
    be96:	89 d0                	mov    %edx,%eax
    be98:	01 c0                	add    %eax,%eax
    be9a:	01 d0                	add    %edx,%eax
    be9c:	01 c0                	add    %eax,%eax
    be9e:	8d 50 04             	lea    0x4(%eax),%edx
    bea1:	8b 45 18             	mov    0x18(%ebp),%eax
    bea4:	01 d0                	add    %edx,%eax
    bea6:	0f b6 00             	movzbl (%eax),%eax
    bea9:	0f b6 c0             	movzbl %al,%eax
    beac:	c1 e0 08             	shl    $0x8,%eax
    beaf:	89 c1                	mov    %eax,%ecx
    beb1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    beb4:	89 d0                	mov    %edx,%eax
    beb6:	01 c0                	add    %eax,%eax
    beb8:	01 d0                	add    %edx,%eax
    beba:	01 c0                	add    %eax,%eax
    bebc:	8d 50 05             	lea    0x5(%eax),%edx
    bebf:	8b 45 18             	mov    0x18(%ebp),%eax
    bec2:	01 d0                	add    %edx,%eax
    bec4:	0f b6 00             	movzbl (%eax),%eax
    bec7:	0f b6 c0             	movzbl %al,%eax
    beca:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    becd:	8b 45 10             	mov    0x10(%ebp),%eax
    bed0:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    bed3:	8b 45 20             	mov    0x20(%ebp),%eax
    bed6:	8b 40 10             	mov    0x10(%eax),%eax
    bed9:	85 c0                	test   %eax,%eax
    bedb:	0f 84 dc 00 00 00    	je     bfbd <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    bee1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bee4:	89 d0                	mov    %edx,%eax
    bee6:	01 c0                	add    %eax,%eax
    bee8:	01 d0                	add    %edx,%eax
    beea:	01 c0                	add    %eax,%eax
    beec:	89 c2                	mov    %eax,%edx
    beee:	8b 45 18             	mov    0x18(%ebp),%eax
    bef1:	01 d0                	add    %edx,%eax
    bef3:	0f b6 00             	movzbl (%eax),%eax
    bef6:	0f b6 c0             	movzbl %al,%eax
    bef9:	c1 e0 08             	shl    $0x8,%eax
    befc:	89 c1                	mov    %eax,%ecx
    befe:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bf01:	89 d0                	mov    %edx,%eax
    bf03:	01 c0                	add    %eax,%eax
    bf05:	01 d0                	add    %edx,%eax
    bf07:	01 c0                	add    %eax,%eax
    bf09:	8d 50 01             	lea    0x1(%eax),%edx
    bf0c:	8b 45 18             	mov    0x18(%ebp),%eax
    bf0f:	01 d0                	add    %edx,%eax
    bf11:	0f b6 00             	movzbl (%eax),%eax
    bf14:	0f b6 c0             	movzbl %al,%eax
    bf17:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bf1a:	8b 45 20             	mov    0x20(%ebp),%eax
    bf1d:	8b 40 14             	mov    0x14(%eax),%eax
    bf20:	39 c2                	cmp    %eax,%edx
    bf22:	0f 85 95 00 00 00    	jne    bfbd <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    bf28:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bf2b:	89 d0                	mov    %edx,%eax
    bf2d:	01 c0                	add    %eax,%eax
    bf2f:	01 d0                	add    %edx,%eax
    bf31:	01 c0                	add    %eax,%eax
    bf33:	8d 50 02             	lea    0x2(%eax),%edx
    bf36:	8b 45 18             	mov    0x18(%ebp),%eax
    bf39:	01 d0                	add    %edx,%eax
    bf3b:	0f b6 00             	movzbl (%eax),%eax
    bf3e:	0f b6 c0             	movzbl %al,%eax
    bf41:	c1 e0 08             	shl    $0x8,%eax
    bf44:	89 c1                	mov    %eax,%ecx
    bf46:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bf49:	89 d0                	mov    %edx,%eax
    bf4b:	01 c0                	add    %eax,%eax
    bf4d:	01 d0                	add    %edx,%eax
    bf4f:	01 c0                	add    %eax,%eax
    bf51:	8d 50 03             	lea    0x3(%eax),%edx
    bf54:	8b 45 18             	mov    0x18(%ebp),%eax
    bf57:	01 d0                	add    %edx,%eax
    bf59:	0f b6 00             	movzbl (%eax),%eax
    bf5c:	0f b6 c0             	movzbl %al,%eax
    bf5f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bf62:	8b 45 20             	mov    0x20(%ebp),%eax
    bf65:	8b 40 18             	mov    0x18(%eax),%eax
    bf68:	39 c2                	cmp    %eax,%edx
    bf6a:	75 51                	jne    bfbd <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    bf6c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bf6f:	89 d0                	mov    %edx,%eax
    bf71:	01 c0                	add    %eax,%eax
    bf73:	01 d0                	add    %edx,%eax
    bf75:	01 c0                	add    %eax,%eax
    bf77:	8d 50 04             	lea    0x4(%eax),%edx
    bf7a:	8b 45 18             	mov    0x18(%ebp),%eax
    bf7d:	01 d0                	add    %edx,%eax
    bf7f:	0f b6 00             	movzbl (%eax),%eax
    bf82:	0f b6 c0             	movzbl %al,%eax
    bf85:	c1 e0 08             	shl    $0x8,%eax
    bf88:	89 c1                	mov    %eax,%ecx
    bf8a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bf8d:	89 d0                	mov    %edx,%eax
    bf8f:	01 c0                	add    %eax,%eax
    bf91:	01 d0                	add    %edx,%eax
    bf93:	01 c0                	add    %eax,%eax
    bf95:	8d 50 05             	lea    0x5(%eax),%edx
    bf98:	8b 45 18             	mov    0x18(%ebp),%eax
    bf9b:	01 d0                	add    %edx,%eax
    bf9d:	0f b6 00             	movzbl (%eax),%eax
    bfa0:	0f b6 c0             	movzbl %al,%eax
    bfa3:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bfa6:	8b 45 20             	mov    0x20(%ebp),%eax
    bfa9:	8b 40 1c             	mov    0x1c(%eax),%eax
    bfac:	39 c2                	cmp    %eax,%edx
    bfae:	75 0d                	jne    bfbd <getPixelColorRGBA16+0x26b>
    bfb0:	8b 45 14             	mov    0x14(%ebp),%eax
    bfb3:	66 c7 00 00 00       	movw   $0x0,(%eax)
    bfb8:	e9 84 01 00 00       	jmp    c141 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    bfbd:	8b 45 14             	mov    0x14(%ebp),%eax
    bfc0:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    bfc5:	e9 77 01 00 00       	jmp    c141 <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    bfca:	8b 45 20             	mov    0x20(%ebp),%eax
    bfcd:	8b 00                	mov    (%eax),%eax
    bfcf:	83 f8 04             	cmp    $0x4,%eax
    bfd2:	0f 85 86 00 00 00    	jne    c05e <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    bfd8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bfdb:	c1 e0 02             	shl    $0x2,%eax
    bfde:	89 c2                	mov    %eax,%edx
    bfe0:	8b 45 18             	mov    0x18(%ebp),%eax
    bfe3:	01 d0                	add    %edx,%eax
    bfe5:	0f b6 00             	movzbl (%eax),%eax
    bfe8:	0f b6 c0             	movzbl %al,%eax
    bfeb:	c1 e0 08             	shl    $0x8,%eax
    bfee:	89 c2                	mov    %eax,%edx
    bff0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bff3:	c1 e0 02             	shl    $0x2,%eax
    bff6:	8d 48 01             	lea    0x1(%eax),%ecx
    bff9:	8b 45 18             	mov    0x18(%ebp),%eax
    bffc:	01 c8                	add    %ecx,%eax
    bffe:	0f b6 00             	movzbl (%eax),%eax
    c001:	0f b6 c0             	movzbl %al,%eax
    c004:	01 c2                	add    %eax,%edx
    c006:	8b 45 10             	mov    0x10(%ebp),%eax
    c009:	66 89 10             	mov    %dx,(%eax)
    c00c:	8b 45 10             	mov    0x10(%ebp),%eax
    c00f:	0f b7 10             	movzwl (%eax),%edx
    c012:	8b 45 0c             	mov    0xc(%ebp),%eax
    c015:	66 89 10             	mov    %dx,(%eax)
    c018:	8b 45 0c             	mov    0xc(%ebp),%eax
    c01b:	0f b7 10             	movzwl (%eax),%edx
    c01e:	8b 45 08             	mov    0x8(%ebp),%eax
    c021:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    c024:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c027:	c1 e0 02             	shl    $0x2,%eax
    c02a:	8d 50 02             	lea    0x2(%eax),%edx
    c02d:	8b 45 18             	mov    0x18(%ebp),%eax
    c030:	01 d0                	add    %edx,%eax
    c032:	0f b6 00             	movzbl (%eax),%eax
    c035:	0f b6 c0             	movzbl %al,%eax
    c038:	c1 e0 08             	shl    $0x8,%eax
    c03b:	89 c2                	mov    %eax,%edx
    c03d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c040:	c1 e0 02             	shl    $0x2,%eax
    c043:	8d 48 03             	lea    0x3(%eax),%ecx
    c046:	8b 45 18             	mov    0x18(%ebp),%eax
    c049:	01 c8                	add    %ecx,%eax
    c04b:	0f b6 00             	movzbl (%eax),%eax
    c04e:	0f b6 c0             	movzbl %al,%eax
    c051:	01 c2                	add    %eax,%edx
    c053:	8b 45 14             	mov    0x14(%ebp),%eax
    c056:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    c059:	e9 e3 00 00 00       	jmp    c141 <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    c05e:	8b 45 20             	mov    0x20(%ebp),%eax
    c061:	8b 00                	mov    (%eax),%eax
    c063:	83 f8 06             	cmp    $0x6,%eax
    c066:	0f 85 d5 00 00 00    	jne    c141 <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    c06c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c06f:	c1 e0 03             	shl    $0x3,%eax
    c072:	89 c2                	mov    %eax,%edx
    c074:	8b 45 18             	mov    0x18(%ebp),%eax
    c077:	01 d0                	add    %edx,%eax
    c079:	0f b6 00             	movzbl (%eax),%eax
    c07c:	0f b6 c0             	movzbl %al,%eax
    c07f:	c1 e0 08             	shl    $0x8,%eax
    c082:	89 c2                	mov    %eax,%edx
    c084:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c087:	c1 e0 03             	shl    $0x3,%eax
    c08a:	8d 48 01             	lea    0x1(%eax),%ecx
    c08d:	8b 45 18             	mov    0x18(%ebp),%eax
    c090:	01 c8                	add    %ecx,%eax
    c092:	0f b6 00             	movzbl (%eax),%eax
    c095:	0f b6 c0             	movzbl %al,%eax
    c098:	01 c2                	add    %eax,%edx
    c09a:	8b 45 08             	mov    0x8(%ebp),%eax
    c09d:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    c0a0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c0a3:	c1 e0 03             	shl    $0x3,%eax
    c0a6:	8d 50 02             	lea    0x2(%eax),%edx
    c0a9:	8b 45 18             	mov    0x18(%ebp),%eax
    c0ac:	01 d0                	add    %edx,%eax
    c0ae:	0f b6 00             	movzbl (%eax),%eax
    c0b1:	0f b6 c0             	movzbl %al,%eax
    c0b4:	c1 e0 08             	shl    $0x8,%eax
    c0b7:	89 c2                	mov    %eax,%edx
    c0b9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c0bc:	c1 e0 03             	shl    $0x3,%eax
    c0bf:	8d 48 03             	lea    0x3(%eax),%ecx
    c0c2:	8b 45 18             	mov    0x18(%ebp),%eax
    c0c5:	01 c8                	add    %ecx,%eax
    c0c7:	0f b6 00             	movzbl (%eax),%eax
    c0ca:	0f b6 c0             	movzbl %al,%eax
    c0cd:	01 c2                	add    %eax,%edx
    c0cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    c0d2:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    c0d5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c0d8:	c1 e0 03             	shl    $0x3,%eax
    c0db:	8d 50 04             	lea    0x4(%eax),%edx
    c0de:	8b 45 18             	mov    0x18(%ebp),%eax
    c0e1:	01 d0                	add    %edx,%eax
    c0e3:	0f b6 00             	movzbl (%eax),%eax
    c0e6:	0f b6 c0             	movzbl %al,%eax
    c0e9:	c1 e0 08             	shl    $0x8,%eax
    c0ec:	89 c2                	mov    %eax,%edx
    c0ee:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c0f1:	c1 e0 03             	shl    $0x3,%eax
    c0f4:	8d 48 05             	lea    0x5(%eax),%ecx
    c0f7:	8b 45 18             	mov    0x18(%ebp),%eax
    c0fa:	01 c8                	add    %ecx,%eax
    c0fc:	0f b6 00             	movzbl (%eax),%eax
    c0ff:	0f b6 c0             	movzbl %al,%eax
    c102:	01 c2                	add    %eax,%edx
    c104:	8b 45 10             	mov    0x10(%ebp),%eax
    c107:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    c10a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c10d:	c1 e0 03             	shl    $0x3,%eax
    c110:	8d 50 06             	lea    0x6(%eax),%edx
    c113:	8b 45 18             	mov    0x18(%ebp),%eax
    c116:	01 d0                	add    %edx,%eax
    c118:	0f b6 00             	movzbl (%eax),%eax
    c11b:	0f b6 c0             	movzbl %al,%eax
    c11e:	c1 e0 08             	shl    $0x8,%eax
    c121:	89 c2                	mov    %eax,%edx
    c123:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c126:	c1 e0 03             	shl    $0x3,%eax
    c129:	8d 48 07             	lea    0x7(%eax),%ecx
    c12c:	8b 45 18             	mov    0x18(%ebp),%eax
    c12f:	01 c8                	add    %ecx,%eax
    c131:	0f b6 00             	movzbl (%eax),%eax
    c134:	0f b6 c0             	movzbl %al,%eax
    c137:	01 c2                	add    %eax,%edx
    c139:	8b 45 14             	mov    0x14(%ebp),%eax
    c13c:	66 89 10             	mov    %dx,(%eax)
  }
}
    c13f:	eb 00                	jmp    c141 <getPixelColorRGBA16+0x3ef>
    c141:	90                   	nop
    c142:	5d                   	pop    %ebp
    c143:	c3                   	ret    

0000c144 <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    c144:	55                   	push   %ebp
    c145:	89 e5                	mov    %esp,%ebp
    c147:	56                   	push   %esi
    c148:	53                   	push   %ebx
    c149:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c14c:	8b 55 18             	mov    0x18(%ebp),%edx
    c14f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c152:	0f af c2             	imul   %edx,%eax
    c155:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    c158:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    c15f:	8b 45 14             	mov    0x14(%ebp),%eax
    c162:	8b 00                	mov    (%eax),%eax
    c164:	83 f8 03             	cmp    $0x3,%eax
    c167:	75 14                	jne    c17d <lodepng_convert+0x39>
    c169:	8b 45 14             	mov    0x14(%ebp),%eax
    c16c:	8b 40 08             	mov    0x8(%eax),%eax
    c16f:	85 c0                	test   %eax,%eax
    c171:	75 0a                	jne    c17d <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    c173:	b8 6b 00 00 00       	mov    $0x6b,%eax
    c178:	e9 19 03 00 00       	jmp    c496 <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    c17d:	ff 75 14             	pushl  0x14(%ebp)
    c180:	ff 75 10             	pushl  0x10(%ebp)
    c183:	e8 b7 d1 ff ff       	call   933f <lodepng_color_mode_equal>
    c188:	83 c4 08             	add    $0x8,%esp
    c18b:	85 c0                	test   %eax,%eax
    c18d:	74 2f                	je     c1be <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    c18f:	ff 75 14             	pushl  0x14(%ebp)
    c192:	ff 75 1c             	pushl  0x1c(%ebp)
    c195:	ff 75 18             	pushl  0x18(%ebp)
    c198:	e8 fb d4 ff ff       	call   9698 <lodepng_get_raw_size>
    c19d:	83 c4 0c             	add    $0xc,%esp
    c1a0:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    c1a3:	ff 75 dc             	pushl  -0x24(%ebp)
    c1a6:	ff 75 0c             	pushl  0xc(%ebp)
    c1a9:	ff 75 08             	pushl  0x8(%ebp)
    c1ac:	e8 ca 78 ff ff       	call   3a7b <lodepng_memcpy>
    c1b1:	83 c4 0c             	add    $0xc,%esp
    return 0;
    c1b4:	b8 00 00 00 00       	mov    $0x0,%eax
    c1b9:	e9 d8 02 00 00       	jmp    c496 <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    c1be:	8b 45 10             	mov    0x10(%ebp),%eax
    c1c1:	8b 00                	mov    (%eax),%eax
    c1c3:	83 f8 03             	cmp    $0x3,%eax
    c1c6:	0f 85 16 01 00 00    	jne    c2e2 <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    c1cc:	8b 45 10             	mov    0x10(%ebp),%eax
    c1cf:	8b 40 0c             	mov    0xc(%eax),%eax
    c1d2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    c1d5:	8b 45 10             	mov    0x10(%ebp),%eax
    c1d8:	8b 40 08             	mov    0x8(%eax),%eax
    c1db:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    c1de:	8b 45 10             	mov    0x10(%ebp),%eax
    c1e1:	8b 40 04             	mov    0x4(%eax),%eax
    c1e4:	ba 01 00 00 00       	mov    $0x1,%edx
    c1e9:	89 c1                	mov    %eax,%ecx
    c1eb:	d3 e2                	shl    %cl,%edx
    c1ed:	89 d0                	mov    %edx,%eax
    c1ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    c1f2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c1f6:	75 5b                	jne    c253 <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    c1f8:	8b 45 14             	mov    0x14(%ebp),%eax
    c1fb:	8b 40 0c             	mov    0xc(%eax),%eax
    c1fe:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    c201:	8b 45 14             	mov    0x14(%ebp),%eax
    c204:	8b 40 08             	mov    0x8(%eax),%eax
    c207:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    c20a:	8b 45 14             	mov    0x14(%ebp),%eax
    c20d:	8b 00                	mov    (%eax),%eax
    c20f:	83 f8 03             	cmp    $0x3,%eax
    c212:	75 3f                	jne    c253 <lodepng_convert+0x10f>
    c214:	8b 45 14             	mov    0x14(%ebp),%eax
    c217:	8b 50 04             	mov    0x4(%eax),%edx
    c21a:	8b 45 10             	mov    0x10(%ebp),%eax
    c21d:	8b 40 04             	mov    0x4(%eax),%eax
    c220:	39 c2                	cmp    %eax,%edx
    c222:	75 2f                	jne    c253 <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    c224:	ff 75 14             	pushl  0x14(%ebp)
    c227:	ff 75 1c             	pushl  0x1c(%ebp)
    c22a:	ff 75 18             	pushl  0x18(%ebp)
    c22d:	e8 66 d4 ff ff       	call   9698 <lodepng_get_raw_size>
    c232:	83 c4 0c             	add    $0xc,%esp
    c235:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    c238:	ff 75 d8             	pushl  -0x28(%ebp)
    c23b:	ff 75 0c             	pushl  0xc(%ebp)
    c23e:	ff 75 08             	pushl  0x8(%ebp)
    c241:	e8 35 78 ff ff       	call   3a7b <lodepng_memcpy>
    c246:	83 c4 0c             	add    $0xc,%esp
        return 0;
    c249:	b8 00 00 00 00       	mov    $0x0,%eax
    c24e:	e9 43 02 00 00       	jmp    c496 <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    c253:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c256:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    c259:	7d 06                	jge    c261 <lodepng_convert+0x11d>
    c25b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c25e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    c261:	8d 45 90             	lea    -0x70(%ebp),%eax
    c264:	50                   	push   %eax
    c265:	e8 5f e1 ff ff       	call   a3c9 <color_tree_init>
    c26a:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    c26d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c274:	eb 61                	jmp    c2d7 <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    c276:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c279:	c1 e0 02             	shl    $0x2,%eax
    c27c:	89 c2                	mov    %eax,%edx
    c27e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c281:	01 d0                	add    %edx,%eax
    c283:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    c286:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c289:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c28c:	83 c0 03             	add    $0x3,%eax
    c28f:	0f b6 00             	movzbl (%eax),%eax
    c292:	0f b6 d8             	movzbl %al,%ebx
    c295:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c298:	83 c0 02             	add    $0x2,%eax
    c29b:	0f b6 00             	movzbl (%eax),%eax
    c29e:	0f b6 c8             	movzbl %al,%ecx
    c2a1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c2a4:	83 c0 01             	add    $0x1,%eax
    c2a7:	0f b6 00             	movzbl (%eax),%eax
    c2aa:	0f b6 d0             	movzbl %al,%edx
    c2ad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c2b0:	0f b6 00             	movzbl (%eax),%eax
    c2b3:	0f b6 c0             	movzbl %al,%eax
    c2b6:	83 ec 08             	sub    $0x8,%esp
    c2b9:	56                   	push   %esi
    c2ba:	53                   	push   %ebx
    c2bb:	51                   	push   %ecx
    c2bc:	52                   	push   %edx
    c2bd:	50                   	push   %eax
    c2be:	8d 45 90             	lea    -0x70(%ebp),%eax
    c2c1:	50                   	push   %eax
    c2c2:	e8 85 e2 ff ff       	call   a54c <color_tree_add>
    c2c7:	83 c4 20             	add    $0x20,%esp
    c2ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    c2cd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c2d1:	75 0e                	jne    c2e1 <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    c2d3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c2d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c2da:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    c2dd:	75 97                	jne    c276 <lodepng_convert+0x132>
    c2df:	eb 01                	jmp    c2e2 <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    c2e1:	90                   	nop
    }
  }

  if(!error) {
    c2e2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c2e6:	0f 85 8e 01 00 00    	jne    c47a <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    c2ec:	8b 45 14             	mov    0x14(%ebp),%eax
    c2ef:	8b 40 04             	mov    0x4(%eax),%eax
    c2f2:	83 f8 10             	cmp    $0x10,%eax
    c2f5:	0f 85 99 00 00 00    	jne    c394 <lodepng_convert+0x250>
    c2fb:	8b 45 10             	mov    0x10(%ebp),%eax
    c2fe:	8b 40 04             	mov    0x4(%eax),%eax
    c301:	83 f8 10             	cmp    $0x10,%eax
    c304:	0f 85 8a 00 00 00    	jne    c394 <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    c30a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c311:	eb 74                	jmp    c387 <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    c313:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    c319:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    c31f:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    c325:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c32b:	83 ec 04             	sub    $0x4,%esp
    c32e:	ff 75 14             	pushl  0x14(%ebp)
    c331:	ff 75 f4             	pushl  -0xc(%ebp)
    c334:	ff 75 0c             	pushl  0xc(%ebp)
    c337:	8d 45 88             	lea    -0x78(%ebp),%eax
    c33a:	50                   	push   %eax
    c33b:	8d 45 8a             	lea    -0x76(%ebp),%eax
    c33e:	50                   	push   %eax
    c33f:	8d 45 8c             	lea    -0x74(%ebp),%eax
    c342:	50                   	push   %eax
    c343:	8d 45 8e             	lea    -0x72(%ebp),%eax
    c346:	50                   	push   %eax
    c347:	e8 06 fa ff ff       	call   bd52 <getPixelColorRGBA16>
    c34c:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    c34f:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    c353:	0f b7 d8             	movzwl %ax,%ebx
    c356:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    c35a:	0f b7 c8             	movzwl %ax,%ecx
    c35d:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    c361:	0f b7 d0             	movzwl %ax,%edx
    c364:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    c368:	0f b7 c0             	movzwl %ax,%eax
    c36b:	83 ec 04             	sub    $0x4,%esp
    c36e:	53                   	push   %ebx
    c36f:	51                   	push   %ecx
    c370:	52                   	push   %edx
    c371:	50                   	push   %eax
    c372:	ff 75 10             	pushl  0x10(%ebp)
    c375:	ff 75 f4             	pushl  -0xc(%ebp)
    c378:	ff 75 08             	pushl  0x8(%ebp)
    c37b:	e8 d3 e6 ff ff       	call   aa53 <rgba16ToPixel>
    c380:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    c383:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c387:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c38a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    c38d:	75 84                	jne    c313 <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    c38f:	e9 e6 00 00 00       	jmp    c47a <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    c394:	8b 45 10             	mov    0x10(%ebp),%eax
    c397:	8b 40 04             	mov    0x4(%eax),%eax
    c39a:	83 f8 08             	cmp    $0x8,%eax
    c39d:	75 23                	jne    c3c2 <lodepng_convert+0x27e>
    c39f:	8b 45 10             	mov    0x10(%ebp),%eax
    c3a2:	8b 00                	mov    (%eax),%eax
    c3a4:	83 f8 06             	cmp    $0x6,%eax
    c3a7:	75 19                	jne    c3c2 <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    c3a9:	ff 75 14             	pushl  0x14(%ebp)
    c3ac:	ff 75 0c             	pushl  0xc(%ebp)
    c3af:	ff 75 e0             	pushl  -0x20(%ebp)
    c3b2:	ff 75 08             	pushl  0x8(%ebp)
    c3b5:	e8 ae ee ff ff       	call   b268 <getPixelColorsRGBA8>
    c3ba:	83 c4 10             	add    $0x10,%esp
    c3bd:	e9 b8 00 00 00       	jmp    c47a <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    c3c2:	8b 45 10             	mov    0x10(%ebp),%eax
    c3c5:	8b 40 04             	mov    0x4(%eax),%eax
    c3c8:	83 f8 08             	cmp    $0x8,%eax
    c3cb:	75 23                	jne    c3f0 <lodepng_convert+0x2ac>
    c3cd:	8b 45 10             	mov    0x10(%ebp),%eax
    c3d0:	8b 00                	mov    (%eax),%eax
    c3d2:	83 f8 02             	cmp    $0x2,%eax
    c3d5:	75 19                	jne    c3f0 <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    c3d7:	ff 75 14             	pushl  0x14(%ebp)
    c3da:	ff 75 0c             	pushl  0xc(%ebp)
    c3dd:	ff 75 e0             	pushl  -0x20(%ebp)
    c3e0:	ff 75 08             	pushl  0x8(%ebp)
    c3e3:	e8 50 f5 ff ff       	call   b938 <getPixelColorsRGB8>
    c3e8:	83 c4 10             	add    $0x10,%esp
    c3eb:	e9 8a 00 00 00       	jmp    c47a <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    c3f0:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    c3f4:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    c3f8:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    c3fc:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    c400:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c407:	eb 66                	jmp    c46f <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c409:	83 ec 04             	sub    $0x4,%esp
    c40c:	ff 75 14             	pushl  0x14(%ebp)
    c40f:	ff 75 f4             	pushl  -0xc(%ebp)
    c412:	ff 75 0c             	pushl  0xc(%ebp)
    c415:	8d 45 84             	lea    -0x7c(%ebp),%eax
    c418:	50                   	push   %eax
    c419:	8d 45 85             	lea    -0x7b(%ebp),%eax
    c41c:	50                   	push   %eax
    c41d:	8d 45 86             	lea    -0x7a(%ebp),%eax
    c420:	50                   	push   %eax
    c421:	8d 45 87             	lea    -0x79(%ebp),%eax
    c424:	50                   	push   %eax
    c425:	e8 71 e8 ff ff       	call   ac9b <getPixelColorRGBA8>
    c42a:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    c42d:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    c431:	0f b6 d8             	movzbl %al,%ebx
    c434:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    c438:	0f b6 c8             	movzbl %al,%ecx
    c43b:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    c43f:	0f b6 d0             	movzbl %al,%edx
    c442:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    c446:	0f b6 c0             	movzbl %al,%eax
    c449:	53                   	push   %ebx
    c44a:	51                   	push   %ecx
    c44b:	52                   	push   %edx
    c44c:	50                   	push   %eax
    c44d:	8d 45 90             	lea    -0x70(%ebp),%eax
    c450:	50                   	push   %eax
    c451:	ff 75 10             	pushl  0x10(%ebp)
    c454:	ff 75 f4             	pushl  -0xc(%ebp)
    c457:	ff 75 08             	pushl  0x8(%ebp)
    c45a:	e8 e5 e1 ff ff       	call   a644 <rgba8ToPixel>
    c45f:	83 c4 20             	add    $0x20,%esp
    c462:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    c465:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c469:	75 0e                	jne    c479 <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    c46b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c46f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c472:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    c475:	75 92                	jne    c409 <lodepng_convert+0x2c5>
    c477:	eb 01                	jmp    c47a <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    c479:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    c47a:	8b 45 10             	mov    0x10(%ebp),%eax
    c47d:	8b 00                	mov    (%eax),%eax
    c47f:	83 f8 03             	cmp    $0x3,%eax
    c482:	75 0f                	jne    c493 <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    c484:	83 ec 0c             	sub    $0xc,%esp
    c487:	8d 45 90             	lea    -0x70(%ebp),%eax
    c48a:	50                   	push   %eax
    c48b:	e8 59 df ff ff       	call   a3e9 <color_tree_cleanup>
    c490:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    c493:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    c496:	8d 65 f8             	lea    -0x8(%ebp),%esp
    c499:	5b                   	pop    %ebx
    c49a:	5e                   	pop    %esi
    c49b:	5d                   	pop    %ebp
    c49c:	c3                   	ret    

0000c49d <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    c49d:	55                   	push   %ebp
    c49e:	89 e5                	mov    %esp,%ebp
    c4a0:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    c4a3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    c4aa:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c4b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    c4b8:	8b 45 24             	mov    0x24(%ebp),%eax
    c4bb:	8b 40 04             	mov    0x4(%eax),%eax
    c4be:	ba 01 00 00 00       	mov    $0x1,%edx
    c4c3:	89 c1                	mov    %eax,%ecx
    c4c5:	d3 e2                	shl    %cl,%edx
    c4c7:	89 d0                	mov    %edx,%eax
    c4c9:	8d 48 ff             	lea    -0x1(%eax),%ecx
    c4cc:	b8 ff ff 00 00       	mov    $0xffff,%eax
    c4d1:	ba 00 00 00 00       	mov    $0x0,%edx
    c4d6:	f7 f1                	div    %ecx
    c4d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    c4db:	8b 45 20             	mov    0x20(%ebp),%eax
    c4de:	8b 40 04             	mov    0x4(%eax),%eax
    c4e1:	ba 10 00 00 00       	mov    $0x10,%edx
    c4e6:	29 c2                	sub    %eax,%edx
    c4e8:	89 d0                	mov    %edx,%eax
    c4ea:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    c4ed:	8b 45 24             	mov    0x24(%ebp),%eax
    c4f0:	8b 00                	mov    (%eax),%eax
    c4f2:	85 c0                	test   %eax,%eax
    c4f4:	74 0a                	je     c500 <lodepng_convert_rgb+0x63>
    c4f6:	8b 45 24             	mov    0x24(%ebp),%eax
    c4f9:	8b 00                	mov    (%eax),%eax
    c4fb:	83 f8 04             	cmp    $0x4,%eax
    c4fe:	75 1b                	jne    c51b <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    c500:	8b 45 14             	mov    0x14(%ebp),%eax
    c503:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c507:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c50a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c50d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    c510:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c513:	89 45 fc             	mov    %eax,-0x4(%ebp)
    c516:	e9 c2 00 00 00       	jmp    c5dd <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    c51b:	8b 45 24             	mov    0x24(%ebp),%eax
    c51e:	8b 00                	mov    (%eax),%eax
    c520:	83 f8 02             	cmp    $0x2,%eax
    c523:	74 0a                	je     c52f <lodepng_convert_rgb+0x92>
    c525:	8b 45 24             	mov    0x24(%ebp),%eax
    c528:	8b 00                	mov    (%eax),%eax
    c52a:	83 f8 06             	cmp    $0x6,%eax
    c52d:	75 23                	jne    c552 <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    c52f:	8b 45 14             	mov    0x14(%ebp),%eax
    c532:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c536:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    c539:	8b 45 18             	mov    0x18(%ebp),%eax
    c53c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c540:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    c543:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c546:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c54a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c54d:	e9 8b 00 00 00       	jmp    c5dd <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    c552:	8b 45 24             	mov    0x24(%ebp),%eax
    c555:	8b 00                	mov    (%eax),%eax
    c557:	83 f8 03             	cmp    $0x3,%eax
    c55a:	75 77                	jne    c5d3 <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    c55c:	8b 45 24             	mov    0x24(%ebp),%eax
    c55f:	8b 40 0c             	mov    0xc(%eax),%eax
    c562:	3b 45 14             	cmp    0x14(%ebp),%eax
    c565:	77 0a                	ja     c571 <lodepng_convert_rgb+0xd4>
    c567:	b8 52 00 00 00       	mov    $0x52,%eax
    c56c:	e9 cb 01 00 00       	jmp    c73c <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    c571:	8b 45 24             	mov    0x24(%ebp),%eax
    c574:	8b 40 08             	mov    0x8(%eax),%eax
    c577:	8b 55 14             	mov    0x14(%ebp),%edx
    c57a:	c1 e2 02             	shl    $0x2,%edx
    c57d:	01 d0                	add    %edx,%eax
    c57f:	0f b6 00             	movzbl (%eax),%eax
    c582:	0f b6 d0             	movzbl %al,%edx
    c585:	89 d0                	mov    %edx,%eax
    c587:	c1 e0 08             	shl    $0x8,%eax
    c58a:	01 d0                	add    %edx,%eax
    c58c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    c58f:	8b 45 24             	mov    0x24(%ebp),%eax
    c592:	8b 40 08             	mov    0x8(%eax),%eax
    c595:	8b 55 14             	mov    0x14(%ebp),%edx
    c598:	c1 e2 02             	shl    $0x2,%edx
    c59b:	83 c2 01             	add    $0x1,%edx
    c59e:	01 d0                	add    %edx,%eax
    c5a0:	0f b6 00             	movzbl (%eax),%eax
    c5a3:	0f b6 d0             	movzbl %al,%edx
    c5a6:	89 d0                	mov    %edx,%eax
    c5a8:	c1 e0 08             	shl    $0x8,%eax
    c5ab:	01 d0                	add    %edx,%eax
    c5ad:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    c5b0:	8b 45 24             	mov    0x24(%ebp),%eax
    c5b3:	8b 40 08             	mov    0x8(%eax),%eax
    c5b6:	8b 55 14             	mov    0x14(%ebp),%edx
    c5b9:	c1 e2 02             	shl    $0x2,%edx
    c5bc:	83 c2 02             	add    $0x2,%edx
    c5bf:	01 d0                	add    %edx,%eax
    c5c1:	0f b6 00             	movzbl (%eax),%eax
    c5c4:	0f b6 d0             	movzbl %al,%edx
    c5c7:	89 d0                	mov    %edx,%eax
    c5c9:	c1 e0 08             	shl    $0x8,%eax
    c5cc:	01 d0                	add    %edx,%eax
    c5ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c5d1:	eb 0a                	jmp    c5dd <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    c5d3:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c5d8:	e9 5f 01 00 00       	jmp    c73c <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    c5dd:	8b 45 20             	mov    0x20(%ebp),%eax
    c5e0:	8b 00                	mov    (%eax),%eax
    c5e2:	85 c0                	test   %eax,%eax
    c5e4:	74 0a                	je     c5f0 <lodepng_convert_rgb+0x153>
    c5e6:	8b 45 20             	mov    0x20(%ebp),%eax
    c5e9:	8b 00                	mov    (%eax),%eax
    c5eb:	83 f8 04             	cmp    $0x4,%eax
    c5ee:	75 14                	jne    c604 <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    c5f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c5f3:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c5f6:	89 c1                	mov    %eax,%ecx
    c5f8:	d3 ea                	shr    %cl,%edx
    c5fa:	8b 45 08             	mov    0x8(%ebp),%eax
    c5fd:	89 10                	mov    %edx,(%eax)
    c5ff:	e9 33 01 00 00       	jmp    c737 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    c604:	8b 45 20             	mov    0x20(%ebp),%eax
    c607:	8b 00                	mov    (%eax),%eax
    c609:	83 f8 02             	cmp    $0x2,%eax
    c60c:	74 0a                	je     c618 <lodepng_convert_rgb+0x17b>
    c60e:	8b 45 20             	mov    0x20(%ebp),%eax
    c611:	8b 00                	mov    (%eax),%eax
    c613:	83 f8 06             	cmp    $0x6,%eax
    c616:	75 32                	jne    c64a <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    c618:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c61b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c61e:	89 c1                	mov    %eax,%ecx
    c620:	d3 ea                	shr    %cl,%edx
    c622:	8b 45 08             	mov    0x8(%ebp),%eax
    c625:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    c627:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c62a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c62d:	89 c1                	mov    %eax,%ecx
    c62f:	d3 ea                	shr    %cl,%edx
    c631:	8b 45 0c             	mov    0xc(%ebp),%eax
    c634:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    c636:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c639:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c63c:	89 c1                	mov    %eax,%ecx
    c63e:	d3 ea                	shr    %cl,%edx
    c640:	8b 45 10             	mov    0x10(%ebp),%eax
    c643:	89 10                	mov    %edx,(%eax)
    c645:	e9 ed 00 00 00       	jmp    c737 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    c64a:	8b 45 20             	mov    0x20(%ebp),%eax
    c64d:	8b 00                	mov    (%eax),%eax
    c64f:	83 f8 03             	cmp    $0x3,%eax
    c652:	0f 85 d8 00 00 00    	jne    c730 <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    c658:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c65b:	c1 e8 08             	shr    $0x8,%eax
    c65e:	89 c2                	mov    %eax,%edx
    c660:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c663:	0f b6 c0             	movzbl %al,%eax
    c666:	39 c2                	cmp    %eax,%edx
    c668:	75 24                	jne    c68e <lodepng_convert_rgb+0x1f1>
    c66a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c66d:	c1 e8 08             	shr    $0x8,%eax
    c670:	89 c2                	mov    %eax,%edx
    c672:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c675:	0f b6 c0             	movzbl %al,%eax
    c678:	39 c2                	cmp    %eax,%edx
    c67a:	75 12                	jne    c68e <lodepng_convert_rgb+0x1f1>
    c67c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c67f:	c1 e8 08             	shr    $0x8,%eax
    c682:	89 c2                	mov    %eax,%edx
    c684:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c687:	0f b6 c0             	movzbl %al,%eax
    c68a:	39 c2                	cmp    %eax,%edx
    c68c:	74 0a                	je     c698 <lodepng_convert_rgb+0x1fb>
    c68e:	b8 52 00 00 00       	mov    $0x52,%eax
    c693:	e9 a4 00 00 00       	jmp    c73c <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    c698:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    c69f:	eb 79                	jmp    c71a <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    c6a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c6a4:	c1 e0 02             	shl    $0x2,%eax
    c6a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c6aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c6ad:	c1 e8 08             	shr    $0x8,%eax
    c6b0:	89 c1                	mov    %eax,%ecx
    c6b2:	8b 45 20             	mov    0x20(%ebp),%eax
    c6b5:	8b 50 08             	mov    0x8(%eax),%edx
    c6b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c6bb:	01 d0                	add    %edx,%eax
    c6bd:	0f b6 00             	movzbl (%eax),%eax
    c6c0:	0f b6 c0             	movzbl %al,%eax
    c6c3:	39 c1                	cmp    %eax,%ecx
    c6c5:	75 4f                	jne    c716 <lodepng_convert_rgb+0x279>
    c6c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c6ca:	c1 e8 08             	shr    $0x8,%eax
    c6cd:	89 c1                	mov    %eax,%ecx
    c6cf:	8b 45 20             	mov    0x20(%ebp),%eax
    c6d2:	8b 40 08             	mov    0x8(%eax),%eax
    c6d5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c6d8:	83 c2 01             	add    $0x1,%edx
    c6db:	01 d0                	add    %edx,%eax
    c6dd:	0f b6 00             	movzbl (%eax),%eax
    c6e0:	0f b6 c0             	movzbl %al,%eax
    c6e3:	39 c1                	cmp    %eax,%ecx
    c6e5:	75 2f                	jne    c716 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    c6e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c6ea:	c1 e8 08             	shr    $0x8,%eax
    c6ed:	89 c1                	mov    %eax,%ecx
    c6ef:	8b 45 20             	mov    0x20(%ebp),%eax
    c6f2:	8b 40 08             	mov    0x8(%eax),%eax
    c6f5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c6f8:	83 c2 02             	add    $0x2,%edx
    c6fb:	01 d0                	add    %edx,%eax
    c6fd:	0f b6 00             	movzbl (%eax),%eax
    c700:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c703:	39 c1                	cmp    %eax,%ecx
    c705:	75 0f                	jne    c716 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    c707:	8b 45 08             	mov    0x8(%ebp),%eax
    c70a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c70d:	89 10                	mov    %edx,(%eax)
        return 0;
    c70f:	b8 00 00 00 00       	mov    $0x0,%eax
    c714:	eb 26                	jmp    c73c <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    c716:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c71a:	8b 45 20             	mov    0x20(%ebp),%eax
    c71d:	8b 40 0c             	mov    0xc(%eax),%eax
    c720:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    c723:	0f 87 78 ff ff ff    	ja     c6a1 <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    c729:	b8 52 00 00 00       	mov    $0x52,%eax
    c72e:	eb 0c                	jmp    c73c <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    c730:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c735:	eb 05                	jmp    c73c <lodepng_convert_rgb+0x29f>
  }

  return 0;
    c737:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c73c:	c9                   	leave  
    c73d:	c3                   	ret    

0000c73e <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    c73e:	55                   	push   %ebp
    c73f:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    c741:	8b 45 08             	mov    0x8(%ebp),%eax
    c744:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    c74a:	8b 45 08             	mov    0x8(%ebp),%eax
    c74d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    c754:	8b 45 08             	mov    0x8(%ebp),%eax
    c757:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    c75d:	8b 45 08             	mov    0x8(%ebp),%eax
    c760:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c764:	8b 45 08             	mov    0x8(%ebp),%eax
    c767:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c76b:	8b 45 08             	mov    0x8(%ebp),%eax
    c76e:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c772:	8b 45 08             	mov    0x8(%ebp),%eax
    c775:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c779:	8b 45 08             	mov    0x8(%ebp),%eax
    c77c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c783:	8b 45 08             	mov    0x8(%ebp),%eax
    c786:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c78d:	8b 45 08             	mov    0x8(%ebp),%eax
    c790:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c797:	00 00 00 
  stats->numpixels = 0;
    c79a:	8b 45 08             	mov    0x8(%ebp),%eax
    c79d:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c7a4:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c7a7:	8b 45 08             	mov    0x8(%ebp),%eax
    c7aa:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c7b1:	00 00 00 
  stats->allow_greyscale = 1;
    c7b4:	8b 45 08             	mov    0x8(%ebp),%eax
    c7b7:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c7be:	00 00 00 
}
    c7c1:	90                   	nop
    c7c2:	5d                   	pop    %ebp
    c7c3:	c3                   	ret    

0000c7c4 <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c7c4:	55                   	push   %ebp
    c7c5:	89 e5                	mov    %esp,%ebp
    c7c7:	53                   	push   %ebx
    c7c8:	83 ec 04             	sub    $0x4,%esp
    c7cb:	8b 45 08             	mov    0x8(%ebp),%eax
    c7ce:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c7d1:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c7d5:	74 06                	je     c7dd <getValueRequiredBits+0x19>
    c7d7:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c7db:	75 07                	jne    c7e4 <getValueRequiredBits+0x20>
    c7dd:	b8 01 00 00 00       	mov    $0x1,%eax
    c7e2:	eb 6b                	jmp    c84f <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c7e4:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c7e8:	0f b6 d9             	movzbl %cl,%ebx
    c7eb:	89 da                	mov    %ebx,%edx
    c7ed:	89 d0                	mov    %edx,%eax
    c7ef:	c1 e0 04             	shl    $0x4,%eax
    c7f2:	89 c2                	mov    %eax,%edx
    c7f4:	89 d0                	mov    %edx,%eax
    c7f6:	c1 e0 04             	shl    $0x4,%eax
    c7f9:	29 d0                	sub    %edx,%eax
    c7fb:	01 d8                	add    %ebx,%eax
    c7fd:	66 c1 e8 08          	shr    $0x8,%ax
    c801:	c0 e8 04             	shr    $0x4,%al
    c804:	89 c2                	mov    %eax,%edx
    c806:	c1 e2 04             	shl    $0x4,%edx
    c809:	01 c2                	add    %eax,%edx
    c80b:	89 c8                	mov    %ecx,%eax
    c80d:	29 d0                	sub    %edx,%eax
    c80f:	84 c0                	test   %al,%al
    c811:	75 37                	jne    c84a <getValueRequiredBits+0x86>
    c813:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c817:	0f b6 d1             	movzbl %cl,%edx
    c81a:	89 d0                	mov    %edx,%eax
    c81c:	01 c0                	add    %eax,%eax
    c81e:	01 d0                	add    %edx,%eax
    c820:	c1 e0 06             	shl    $0x6,%eax
    c823:	01 d0                	add    %edx,%eax
    c825:	66 c1 e8 08          	shr    $0x8,%ax
    c829:	c0 e8 06             	shr    $0x6,%al
    c82c:	ba 55 00 00 00       	mov    $0x55,%edx
    c831:	0f af c2             	imul   %edx,%eax
    c834:	29 c1                	sub    %eax,%ecx
    c836:	89 c8                	mov    %ecx,%eax
    c838:	84 c0                	test   %al,%al
    c83a:	75 07                	jne    c843 <getValueRequiredBits+0x7f>
    c83c:	b8 02 00 00 00       	mov    $0x2,%eax
    c841:	eb 0c                	jmp    c84f <getValueRequiredBits+0x8b>
    c843:	b8 04 00 00 00       	mov    $0x4,%eax
    c848:	eb 05                	jmp    c84f <getValueRequiredBits+0x8b>
  return 8;
    c84a:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c84f:	83 c4 04             	add    $0x4,%esp
    c852:	5b                   	pop    %ebx
    c853:	5d                   	pop    %ebp
    c854:	c3                   	ret    

0000c855 <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c855:	55                   	push   %ebp
    c856:	89 e5                	mov    %esp,%ebp
    c858:	56                   	push   %esi
    c859:	53                   	push   %ebx
    c85a:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c860:	8b 55 10             	mov    0x10(%ebp),%edx
    c863:	8b 45 14             	mov    0x14(%ebp),%eax
    c866:	0f af c2             	imul   %edx,%eax
    c869:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c86c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c873:	ff 75 18             	pushl  0x18(%ebp)
    c876:	e8 0b cd ff ff       	call   9586 <lodepng_is_greyscale_type>
    c87b:	83 c4 04             	add    $0x4,%esp
    c87e:	85 c0                	test   %eax,%eax
    c880:	0f 95 c0             	setne  %al
    c883:	0f b6 c0             	movzbl %al,%eax
    c886:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c889:	ff 75 18             	pushl  0x18(%ebp)
    c88c:	e8 85 cd ff ff       	call   9616 <lodepng_can_have_alpha>
    c891:	83 c4 04             	add    $0x4,%esp
    c894:	85 c0                	test   %eax,%eax
    c896:	0f 94 c0             	sete   %al
    c899:	0f b6 c0             	movzbl %al,%eax
    c89c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c89f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c8a6:	ff 75 18             	pushl  0x18(%ebp)
    c8a9:	e8 ab cc ff ff       	call   9559 <lodepng_get_bpp>
    c8ae:	83 c4 04             	add    $0x4,%esp
    c8b1:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c8b4:	8b 45 08             	mov    0x8(%ebp),%eax
    c8b7:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c8bd:	83 f8 01             	cmp    $0x1,%eax
    c8c0:	75 0d                	jne    c8cf <lodepng_compute_color_stats+0x7a>
    c8c2:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c8c6:	75 07                	jne    c8cf <lodepng_compute_color_stats+0x7a>
    c8c8:	b8 01 00 00 00       	mov    $0x1,%eax
    c8cd:	eb 05                	jmp    c8d4 <lodepng_compute_color_stats+0x7f>
    c8cf:	b8 00 00 00 00       	mov    $0x0,%eax
    c8d4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c8d7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c8de:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c8e5:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c8e9:	77 26                	ja     c911 <lodepng_compute_color_stats+0xbc>
    c8eb:	8b 45 08             	mov    0x8(%ebp),%eax
    c8ee:	8b 50 14             	mov    0x14(%eax),%edx
    c8f1:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c8f4:	bb 01 00 00 00       	mov    $0x1,%ebx
    c8f9:	89 c1                	mov    %eax,%ecx
    c8fb:	d3 e3                	shl    %cl,%ebx
    c8fd:	89 d8                	mov    %ebx,%eax
    c8ff:	01 d0                	add    %edx,%eax
    c901:	ba 01 01 00 00       	mov    $0x101,%edx
    c906:	3d 01 01 00 00       	cmp    $0x101,%eax
    c90b:	0f 47 c2             	cmova  %edx,%eax
    c90e:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c911:	8b 45 08             	mov    0x8(%ebp),%eax
    c914:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c91a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c91d:	01 c2                	add    %eax,%edx
    c91f:	8b 45 08             	mov    0x8(%ebp),%eax
    c922:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c928:	8b 45 08             	mov    0x8(%ebp),%eax
    c92b:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c931:	85 c0                	test   %eax,%eax
    c933:	75 07                	jne    c93c <lodepng_compute_color_stats+0xe7>
    c935:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c93c:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c942:	50                   	push   %eax
    c943:	e8 81 da ff ff       	call   a3c9 <color_tree_init>
    c948:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c94b:	8b 45 08             	mov    0x8(%ebp),%eax
    c94e:	8b 40 10             	mov    0x10(%eax),%eax
    c951:	85 c0                	test   %eax,%eax
    c953:	74 07                	je     c95c <lodepng_compute_color_stats+0x107>
    c955:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c95c:	8b 45 08             	mov    0x8(%ebp),%eax
    c95f:	8b 00                	mov    (%eax),%eax
    c961:	85 c0                	test   %eax,%eax
    c963:	74 07                	je     c96c <lodepng_compute_color_stats+0x117>
    c965:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c96c:	8b 45 08             	mov    0x8(%ebp),%eax
    c96f:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c975:	83 f8 10             	cmp    $0x10,%eax
    c978:	75 07                	jne    c981 <lodepng_compute_color_stats+0x12c>
    c97a:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c981:	8b 45 08             	mov    0x8(%ebp),%eax
    c984:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c98a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c98d:	72 07                	jb     c996 <lodepng_compute_color_stats+0x141>
    c98f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c996:	8b 45 08             	mov    0x8(%ebp),%eax
    c999:	8b 40 14             	mov    0x14(%eax),%eax
    c99c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c99f:	72 07                	jb     c9a8 <lodepng_compute_color_stats+0x153>
    c9a1:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c9a8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c9ac:	0f 85 82 00 00 00    	jne    ca34 <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c9b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c9b9:	eb 6c                	jmp    ca27 <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c9bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c9be:	c1 e0 02             	shl    $0x2,%eax
    c9c1:	8d 50 10             	lea    0x10(%eax),%edx
    c9c4:	8b 45 08             	mov    0x8(%ebp),%eax
    c9c7:	01 d0                	add    %edx,%eax
    c9c9:	83 c0 08             	add    $0x8,%eax
    c9cc:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c9cf:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c9d2:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c9d5:	83 c0 03             	add    $0x3,%eax
    c9d8:	0f b6 00             	movzbl (%eax),%eax
    c9db:	0f b6 d8             	movzbl %al,%ebx
    c9de:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c9e1:	83 c0 02             	add    $0x2,%eax
    c9e4:	0f b6 00             	movzbl (%eax),%eax
    c9e7:	0f b6 c8             	movzbl %al,%ecx
    c9ea:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c9ed:	83 c0 01             	add    $0x1,%eax
    c9f0:	0f b6 00             	movzbl (%eax),%eax
    c9f3:	0f b6 d0             	movzbl %al,%edx
    c9f6:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c9f9:	0f b6 00             	movzbl (%eax),%eax
    c9fc:	0f b6 c0             	movzbl %al,%eax
    c9ff:	83 ec 08             	sub    $0x8,%esp
    ca02:	56                   	push   %esi
    ca03:	53                   	push   %ebx
    ca04:	51                   	push   %ecx
    ca05:	52                   	push   %edx
    ca06:	50                   	push   %eax
    ca07:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    ca0d:	50                   	push   %eax
    ca0e:	e8 39 db ff ff       	call   a54c <color_tree_add>
    ca13:	83 c4 20             	add    $0x20,%esp
    ca16:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    ca19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ca1d:	0f 85 22 09 00 00    	jne    d345 <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    ca23:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ca27:	8b 45 08             	mov    0x8(%ebp),%eax
    ca2a:	8b 50 14             	mov    0x14(%eax),%edx
    ca2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ca30:	39 c2                	cmp    %eax,%edx
    ca32:	77 87                	ja     c9bb <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    ca34:	8b 45 18             	mov    0x18(%ebp),%eax
    ca37:	8b 40 04             	mov    0x4(%eax),%eax
    ca3a:	83 f8 10             	cmp    $0x10,%eax
    ca3d:	0f 85 1e 01 00 00    	jne    cb61 <lodepng_compute_color_stats+0x30c>
    ca43:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    ca47:	0f 85 14 01 00 00    	jne    cb61 <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    ca4d:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    ca54:	00 00 
    ca56:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    ca5d:	00 00 
    ca5f:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    ca66:	00 00 
    ca68:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    ca6f:	00 00 
    for(i = 0; i != numpixels; ++i) {
    ca71:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ca78:	e9 d8 00 00 00       	jmp    cb55 <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    ca7d:	83 ec 04             	sub    $0x4,%esp
    ca80:	ff 75 18             	pushl  0x18(%ebp)
    ca83:	ff 75 f4             	pushl  -0xc(%ebp)
    ca86:	ff 75 0c             	pushl  0xc(%ebp)
    ca89:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    ca8f:	50                   	push   %eax
    ca90:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    ca96:	50                   	push   %eax
    ca97:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    ca9d:	50                   	push   %eax
    ca9e:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    caa4:	50                   	push   %eax
    caa5:	e8 a8 f2 ff ff       	call   bd52 <getPixelColorRGBA16>
    caaa:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    caad:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    cab4:	66 c1 e8 08          	shr    $0x8,%ax
    cab8:	89 c2                	mov    %eax,%edx
    caba:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    cac1:	31 d0                	xor    %edx,%eax
    cac3:	0f b7 c0             	movzwl %ax,%eax
    cac6:	0f b6 c0             	movzbl %al,%eax
    cac9:	85 c0                	test   %eax,%eax
    cacb:	75 60                	jne    cb2d <lodepng_compute_color_stats+0x2d8>
    cacd:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    cad4:	66 c1 e8 08          	shr    $0x8,%ax
    cad8:	89 c2                	mov    %eax,%edx
    cada:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    cae1:	31 d0                	xor    %edx,%eax
    cae3:	0f b7 c0             	movzwl %ax,%eax
    cae6:	0f b6 c0             	movzbl %al,%eax
    cae9:	85 c0                	test   %eax,%eax
    caeb:	75 40                	jne    cb2d <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    caed:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    caf4:	66 c1 e8 08          	shr    $0x8,%ax
    caf8:	89 c2                	mov    %eax,%edx
    cafa:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    cb01:	31 d0                	xor    %edx,%eax
    cb03:	0f b7 c0             	movzwl %ax,%eax
    cb06:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    cb09:	85 c0                	test   %eax,%eax
    cb0b:	75 20                	jne    cb2d <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    cb0d:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    cb14:	66 c1 e8 08          	shr    $0x8,%ax
    cb18:	89 c2                	mov    %eax,%edx
    cb1a:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    cb21:	31 d0                	xor    %edx,%eax
    cb23:	0f b7 c0             	movzwl %ax,%eax
    cb26:	0f b6 c0             	movzbl %al,%eax
    cb29:	85 c0                	test   %eax,%eax
    cb2b:	74 24                	je     cb51 <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    cb2d:	8b 45 08             	mov    0x8(%ebp),%eax
    cb30:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    cb37:	00 00 00 
        sixteen = 1;
    cb3a:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    cb41:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    cb48:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    cb4f:	eb 10                	jmp    cb61 <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    cb51:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cb55:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cb58:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cb5b:	0f 85 1c ff ff ff    	jne    ca7d <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    cb61:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    cb65:	0f 84 bd 02 00 00    	je     ce28 <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    cb6b:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    cb72:	00 00 
    cb74:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    cb7b:	00 00 
    cb7d:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    cb84:	00 00 
    cb86:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    cb8d:	00 00 

    for(i = 0; i != numpixels; ++i) {
    cb8f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cb96:	e9 b1 01 00 00       	jmp    cd4c <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    cb9b:	83 ec 04             	sub    $0x4,%esp
    cb9e:	ff 75 18             	pushl  0x18(%ebp)
    cba1:	ff 75 f4             	pushl  -0xc(%ebp)
    cba4:	ff 75 0c             	pushl  0xc(%ebp)
    cba7:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    cbad:	50                   	push   %eax
    cbae:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    cbb4:	50                   	push   %eax
    cbb5:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    cbbb:	50                   	push   %eax
    cbbc:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    cbc2:	50                   	push   %eax
    cbc3:	e8 8a f1 ff ff       	call   bd52 <getPixelColorRGBA16>
    cbc8:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    cbcb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cbcf:	75 36                	jne    cc07 <lodepng_compute_color_stats+0x3b2>
    cbd1:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    cbd8:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    cbdf:	66 39 c2             	cmp    %ax,%dx
    cbe2:	75 13                	jne    cbf7 <lodepng_compute_color_stats+0x3a2>
    cbe4:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    cbeb:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    cbf2:	66 39 c2             	cmp    %ax,%dx
    cbf5:	74 10                	je     cc07 <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    cbf7:	8b 45 08             	mov    0x8(%ebp),%eax
    cbfa:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    cc00:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    cc07:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cc0b:	0f 85 1f 01 00 00    	jne    cd30 <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    cc11:	8b 45 08             	mov    0x8(%ebp),%eax
    cc14:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    cc18:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    cc1f:	66 39 c2             	cmp    %ax,%dx
    cc22:	75 2d                	jne    cc51 <lodepng_compute_color_stats+0x3fc>
    cc24:	8b 45 08             	mov    0x8(%ebp),%eax
    cc27:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cc2b:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    cc32:	66 39 c2             	cmp    %ax,%dx
    cc35:	75 1a                	jne    cc51 <lodepng_compute_color_stats+0x3fc>
    cc37:	8b 45 08             	mov    0x8(%ebp),%eax
    cc3a:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    cc3e:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    cc45:	66 39 c2             	cmp    %ax,%dx
    cc48:	75 07                	jne    cc51 <lodepng_compute_color_stats+0x3fc>
    cc4a:	b8 01 00 00 00       	mov    $0x1,%eax
    cc4f:	eb 05                	jmp    cc56 <lodepng_compute_color_stats+0x401>
    cc51:	b8 00 00 00 00       	mov    $0x0,%eax
    cc56:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    cc59:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    cc60:	66 83 f8 ff          	cmp    $0xffff,%ax
    cc64:	74 3c                	je     cca2 <lodepng_compute_color_stats+0x44d>
    cc66:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    cc6d:	66 85 c0             	test   %ax,%ax
    cc70:	75 10                	jne    cc82 <lodepng_compute_color_stats+0x42d>
    cc72:	8b 45 08             	mov    0x8(%ebp),%eax
    cc75:	8b 40 04             	mov    0x4(%eax),%eax
    cc78:	85 c0                	test   %eax,%eax
    cc7a:	74 26                	je     cca2 <lodepng_compute_color_stats+0x44d>
    cc7c:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    cc80:	75 20                	jne    cca2 <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    cc82:	8b 45 08             	mov    0x8(%ebp),%eax
    cc85:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cc8c:	8b 45 08             	mov    0x8(%ebp),%eax
    cc8f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cc96:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    cc9d:	e9 8e 00 00 00       	jmp    cd30 <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    cca2:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    cca9:	66 85 c0             	test   %ax,%ax
    ccac:	75 4a                	jne    ccf8 <lodepng_compute_color_stats+0x4a3>
    ccae:	8b 45 08             	mov    0x8(%ebp),%eax
    ccb1:	8b 40 10             	mov    0x10(%eax),%eax
    ccb4:	85 c0                	test   %eax,%eax
    ccb6:	75 40                	jne    ccf8 <lodepng_compute_color_stats+0x4a3>
    ccb8:	8b 45 08             	mov    0x8(%ebp),%eax
    ccbb:	8b 40 04             	mov    0x4(%eax),%eax
    ccbe:	85 c0                	test   %eax,%eax
    ccc0:	75 36                	jne    ccf8 <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    ccc2:	8b 45 08             	mov    0x8(%ebp),%eax
    ccc5:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    cccc:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    ccd3:	8b 45 08             	mov    0x8(%ebp),%eax
    ccd6:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    ccda:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    cce1:	8b 45 08             	mov    0x8(%ebp),%eax
    cce4:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    cce8:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    ccef:	8b 45 08             	mov    0x8(%ebp),%eax
    ccf2:	66 89 50 0c          	mov    %dx,0xc(%eax)
    ccf6:	eb 38                	jmp    cd30 <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    ccf8:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    ccff:	66 83 f8 ff          	cmp    $0xffff,%ax
    cd03:	75 2b                	jne    cd30 <lodepng_compute_color_stats+0x4db>
    cd05:	8b 45 08             	mov    0x8(%ebp),%eax
    cd08:	8b 40 04             	mov    0x4(%eax),%eax
    cd0b:	85 c0                	test   %eax,%eax
    cd0d:	74 21                	je     cd30 <lodepng_compute_color_stats+0x4db>
    cd0f:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    cd13:	74 1b                	je     cd30 <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cd15:	8b 45 08             	mov    0x8(%ebp),%eax
    cd18:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cd1f:	8b 45 08             	mov    0x8(%ebp),%eax
    cd22:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cd29:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cd30:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cd34:	74 12                	je     cd48 <lodepng_compute_color_stats+0x4f3>
    cd36:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cd3a:	74 0c                	je     cd48 <lodepng_compute_color_stats+0x4f3>
    cd3c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cd40:	74 06                	je     cd48 <lodepng_compute_color_stats+0x4f3>
    cd42:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cd46:	75 12                	jne    cd5a <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    cd48:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cd4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cd4f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cd52:	0f 85 43 fe ff ff    	jne    cb9b <lodepng_compute_color_stats+0x346>
    cd58:	eb 01                	jmp    cd5b <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cd5a:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    cd5b:	8b 45 08             	mov    0x8(%ebp),%eax
    cd5e:	8b 40 04             	mov    0x4(%eax),%eax
    cd61:	85 c0                	test   %eax,%eax
    cd63:	0f 84 e0 05 00 00    	je     d349 <lodepng_compute_color_stats+0xaf4>
    cd69:	8b 45 08             	mov    0x8(%ebp),%eax
    cd6c:	8b 40 10             	mov    0x10(%eax),%eax
    cd6f:	85 c0                	test   %eax,%eax
    cd71:	0f 85 d2 05 00 00    	jne    d349 <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    cd77:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cd7e:	e9 94 00 00 00       	jmp    ce17 <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    cd83:	83 ec 04             	sub    $0x4,%esp
    cd86:	ff 75 18             	pushl  0x18(%ebp)
    cd89:	ff 75 f4             	pushl  -0xc(%ebp)
    cd8c:	ff 75 0c             	pushl  0xc(%ebp)
    cd8f:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    cd95:	50                   	push   %eax
    cd96:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    cd9c:	50                   	push   %eax
    cd9d:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    cda3:	50                   	push   %eax
    cda4:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    cdaa:	50                   	push   %eax
    cdab:	e8 a2 ef ff ff       	call   bd52 <getPixelColorRGBA16>
    cdb0:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    cdb3:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    cdba:	66 85 c0             	test   %ax,%ax
    cdbd:	74 54                	je     ce13 <lodepng_compute_color_stats+0x5be>
    cdbf:	8b 45 08             	mov    0x8(%ebp),%eax
    cdc2:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    cdc6:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    cdcd:	66 39 c2             	cmp    %ax,%dx
    cdd0:	75 41                	jne    ce13 <lodepng_compute_color_stats+0x5be>
    cdd2:	8b 45 08             	mov    0x8(%ebp),%eax
    cdd5:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cdd9:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    cde0:	66 39 c2             	cmp    %ax,%dx
    cde3:	75 2e                	jne    ce13 <lodepng_compute_color_stats+0x5be>
    cde5:	8b 45 08             	mov    0x8(%ebp),%eax
    cde8:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    cdec:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    cdf3:	66 39 c2             	cmp    %ax,%dx
    cdf6:	75 1b                	jne    ce13 <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cdf8:	8b 45 08             	mov    0x8(%ebp),%eax
    cdfb:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    ce02:	8b 45 08             	mov    0x8(%ebp),%eax
    ce05:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    ce0c:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    ce13:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ce17:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ce1a:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    ce1d:	0f 85 60 ff ff ff    	jne    cd83 <lodepng_compute_color_stats+0x52e>
    ce23:	e9 21 05 00 00       	jmp    d349 <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    ce28:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    ce2f:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    ce36:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    ce3d:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    ce44:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ce4b:	e9 ab 03 00 00       	jmp    d1fb <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    ce50:	83 ec 04             	sub    $0x4,%esp
    ce53:	ff 75 18             	pushl  0x18(%ebp)
    ce56:	ff 75 f4             	pushl  -0xc(%ebp)
    ce59:	ff 75 0c             	pushl  0xc(%ebp)
    ce5c:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    ce62:	50                   	push   %eax
    ce63:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    ce69:	50                   	push   %eax
    ce6a:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    ce70:	50                   	push   %eax
    ce71:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    ce77:	50                   	push   %eax
    ce78:	e8 1e de ff ff       	call   ac9b <getPixelColorRGBA8>
    ce7d:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    ce80:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ce84:	75 41                	jne    cec7 <lodepng_compute_color_stats+0x672>
    ce86:	8b 45 08             	mov    0x8(%ebp),%eax
    ce89:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ce8f:	83 f8 07             	cmp    $0x7,%eax
    ce92:	77 33                	ja     cec7 <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    ce94:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ce9b:	0f b6 c0             	movzbl %al,%eax
    ce9e:	83 ec 0c             	sub    $0xc,%esp
    cea1:	50                   	push   %eax
    cea2:	e8 1d f9 ff ff       	call   c7c4 <getValueRequiredBits>
    cea7:	83 c4 10             	add    $0x10,%esp
    ceaa:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    cead:	8b 45 08             	mov    0x8(%ebp),%eax
    ceb0:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ceb6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    ceb9:	73 0c                	jae    cec7 <lodepng_compute_color_stats+0x672>
    cebb:	8b 45 08             	mov    0x8(%ebp),%eax
    cebe:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    cec1:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    cec7:	8b 45 08             	mov    0x8(%ebp),%eax
    ceca:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ced0:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    ced3:	0f 93 c0             	setae  %al
    ced6:	0f b6 c0             	movzbl %al,%eax
    ced9:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    cedc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cee0:	75 4f                	jne    cf31 <lodepng_compute_color_stats+0x6dc>
    cee2:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    cee9:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cef0:	38 c2                	cmp    %al,%dl
    cef2:	75 12                	jne    cf06 <lodepng_compute_color_stats+0x6b1>
    cef4:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    cefb:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cf02:	38 c2                	cmp    %al,%dl
    cf04:	74 2b                	je     cf31 <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    cf06:	8b 45 08             	mov    0x8(%ebp),%eax
    cf09:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    cf0f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    cf16:	8b 45 08             	mov    0x8(%ebp),%eax
    cf19:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cf1f:	83 f8 07             	cmp    $0x7,%eax
    cf22:	77 0d                	ja     cf31 <lodepng_compute_color_stats+0x6dc>
    cf24:	8b 45 08             	mov    0x8(%ebp),%eax
    cf27:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cf2e:	00 00 00 
      }

      if(!alpha_done) {
    cf31:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cf35:	0f 85 65 01 00 00    	jne    d0a0 <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    cf3b:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cf42:	0f b6 d0             	movzbl %al,%edx
    cf45:	8b 45 08             	mov    0x8(%ebp),%eax
    cf48:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cf4c:	66 39 c2             	cmp    %ax,%dx
    cf4f:	75 33                	jne    cf84 <lodepng_compute_color_stats+0x72f>
    cf51:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cf58:	0f b6 d0             	movzbl %al,%edx
    cf5b:	8b 45 08             	mov    0x8(%ebp),%eax
    cf5e:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cf62:	66 39 c2             	cmp    %ax,%dx
    cf65:	75 1d                	jne    cf84 <lodepng_compute_color_stats+0x72f>
    cf67:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cf6e:	0f b6 d0             	movzbl %al,%edx
    cf71:	8b 45 08             	mov    0x8(%ebp),%eax
    cf74:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cf78:	66 39 c2             	cmp    %ax,%dx
    cf7b:	75 07                	jne    cf84 <lodepng_compute_color_stats+0x72f>
    cf7d:	b8 01 00 00 00       	mov    $0x1,%eax
    cf82:	eb 05                	jmp    cf89 <lodepng_compute_color_stats+0x734>
    cf84:	b8 00 00 00 00       	mov    $0x0,%eax
    cf89:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    cf8c:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cf93:	3c ff                	cmp    $0xff,%al
    cf95:	74 5a                	je     cff1 <lodepng_compute_color_stats+0x79c>
    cf97:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cf9e:	84 c0                	test   %al,%al
    cfa0:	75 10                	jne    cfb2 <lodepng_compute_color_stats+0x75d>
    cfa2:	8b 45 08             	mov    0x8(%ebp),%eax
    cfa5:	8b 40 04             	mov    0x4(%eax),%eax
    cfa8:	85 c0                	test   %eax,%eax
    cfaa:	74 45                	je     cff1 <lodepng_compute_color_stats+0x79c>
    cfac:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    cfb0:	75 3f                	jne    cff1 <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    cfb2:	8b 45 08             	mov    0x8(%ebp),%eax
    cfb5:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cfbc:	8b 45 08             	mov    0x8(%ebp),%eax
    cfbf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cfc6:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cfcd:	8b 45 08             	mov    0x8(%ebp),%eax
    cfd0:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cfd6:	83 f8 07             	cmp    $0x7,%eax
    cfd9:	0f 87 c1 00 00 00    	ja     d0a0 <lodepng_compute_color_stats+0x84b>
    cfdf:	8b 45 08             	mov    0x8(%ebp),%eax
    cfe2:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cfe9:	00 00 00 
    cfec:	e9 af 00 00 00       	jmp    d0a0 <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    cff1:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cff8:	84 c0                	test   %al,%al
    cffa:	75 53                	jne    d04f <lodepng_compute_color_stats+0x7fa>
    cffc:	8b 45 08             	mov    0x8(%ebp),%eax
    cfff:	8b 40 10             	mov    0x10(%eax),%eax
    d002:	85 c0                	test   %eax,%eax
    d004:	75 49                	jne    d04f <lodepng_compute_color_stats+0x7fa>
    d006:	8b 45 08             	mov    0x8(%ebp),%eax
    d009:	8b 40 04             	mov    0x4(%eax),%eax
    d00c:	85 c0                	test   %eax,%eax
    d00e:	75 3f                	jne    d04f <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    d010:	8b 45 08             	mov    0x8(%ebp),%eax
    d013:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    d01a:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d021:	0f b6 d0             	movzbl %al,%edx
    d024:	8b 45 08             	mov    0x8(%ebp),%eax
    d027:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    d02b:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d032:	0f b6 d0             	movzbl %al,%edx
    d035:	8b 45 08             	mov    0x8(%ebp),%eax
    d038:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    d03c:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d043:	0f b6 d0             	movzbl %al,%edx
    d046:	8b 45 08             	mov    0x8(%ebp),%eax
    d049:	66 89 50 0c          	mov    %dx,0xc(%eax)
    d04d:	eb 51                	jmp    d0a0 <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    d04f:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d056:	3c ff                	cmp    $0xff,%al
    d058:	75 46                	jne    d0a0 <lodepng_compute_color_stats+0x84b>
    d05a:	8b 45 08             	mov    0x8(%ebp),%eax
    d05d:	8b 40 04             	mov    0x4(%eax),%eax
    d060:	85 c0                	test   %eax,%eax
    d062:	74 3c                	je     d0a0 <lodepng_compute_color_stats+0x84b>
    d064:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    d068:	74 36                	je     d0a0 <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    d06a:	8b 45 08             	mov    0x8(%ebp),%eax
    d06d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    d074:	8b 45 08             	mov    0x8(%ebp),%eax
    d077:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    d07e:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    d085:	8b 45 08             	mov    0x8(%ebp),%eax
    d088:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d08e:	83 f8 07             	cmp    $0x7,%eax
    d091:	77 0d                	ja     d0a0 <lodepng_compute_color_stats+0x84b>
    d093:	8b 45 08             	mov    0x8(%ebp),%eax
    d096:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    d09d:	00 00 00 
        }
      }

      if(!numcolors_done) {
    d0a0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d0a4:	0f 85 35 01 00 00    	jne    d1df <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    d0aa:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d0b1:	0f b6 d8             	movzbl %al,%ebx
    d0b4:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d0bb:	0f b6 c8             	movzbl %al,%ecx
    d0be:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d0c5:	0f b6 d0             	movzbl %al,%edx
    d0c8:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d0cf:	0f b6 c0             	movzbl %al,%eax
    d0d2:	83 ec 0c             	sub    $0xc,%esp
    d0d5:	53                   	push   %ebx
    d0d6:	51                   	push   %ecx
    d0d7:	52                   	push   %edx
    d0d8:	50                   	push   %eax
    d0d9:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    d0df:	50                   	push   %eax
    d0e0:	e8 1c d4 ff ff       	call   a501 <color_tree_has>
    d0e5:	83 c4 20             	add    $0x20,%esp
    d0e8:	85 c0                	test   %eax,%eax
    d0ea:	0f 85 ef 00 00 00    	jne    d1df <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    d0f0:	8b 45 08             	mov    0x8(%ebp),%eax
    d0f3:	8b 70 14             	mov    0x14(%eax),%esi
    d0f6:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d0fd:	0f b6 d8             	movzbl %al,%ebx
    d100:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d107:	0f b6 c8             	movzbl %al,%ecx
    d10a:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d111:	0f b6 d0             	movzbl %al,%edx
    d114:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d11b:	0f b6 c0             	movzbl %al,%eax
    d11e:	83 ec 08             	sub    $0x8,%esp
    d121:	56                   	push   %esi
    d122:	53                   	push   %ebx
    d123:	51                   	push   %ecx
    d124:	52                   	push   %edx
    d125:	50                   	push   %eax
    d126:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    d12c:	50                   	push   %eax
    d12d:	e8 1a d4 ff ff       	call   a54c <color_tree_add>
    d132:	83 c4 20             	add    $0x20,%esp
    d135:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    d138:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d13c:	0f 85 06 02 00 00    	jne    d348 <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    d142:	8b 45 08             	mov    0x8(%ebp),%eax
    d145:	8b 40 14             	mov    0x14(%eax),%eax
    d148:	3d ff 00 00 00       	cmp    $0xff,%eax
    d14d:	77 6f                	ja     d1be <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    d14f:	8b 45 08             	mov    0x8(%ebp),%eax
    d152:	83 c0 18             	add    $0x18,%eax
    d155:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    d158:	8b 45 08             	mov    0x8(%ebp),%eax
    d15b:	8b 40 14             	mov    0x14(%eax),%eax
    d15e:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    d161:	8b 45 b8             	mov    -0x48(%ebp),%eax
    d164:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d16b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    d16e:	01 c2                	add    %eax,%edx
    d170:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d177:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    d179:	8b 45 b8             	mov    -0x48(%ebp),%eax
    d17c:	c1 e0 02             	shl    $0x2,%eax
    d17f:	8d 50 01             	lea    0x1(%eax),%edx
    d182:	8b 45 bc             	mov    -0x44(%ebp),%eax
    d185:	01 c2                	add    %eax,%edx
    d187:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d18e:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    d190:	8b 45 b8             	mov    -0x48(%ebp),%eax
    d193:	c1 e0 02             	shl    $0x2,%eax
    d196:	8d 50 02             	lea    0x2(%eax),%edx
    d199:	8b 45 bc             	mov    -0x44(%ebp),%eax
    d19c:	01 c2                	add    %eax,%edx
    d19e:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d1a5:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    d1a7:	8b 45 b8             	mov    -0x48(%ebp),%eax
    d1aa:	c1 e0 02             	shl    $0x2,%eax
    d1ad:	8d 50 03             	lea    0x3(%eax),%edx
    d1b0:	8b 45 bc             	mov    -0x44(%ebp),%eax
    d1b3:	01 c2                	add    %eax,%edx
    d1b5:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d1bc:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    d1be:	8b 45 08             	mov    0x8(%ebp),%eax
    d1c1:	8b 40 14             	mov    0x14(%eax),%eax
    d1c4:	8d 50 01             	lea    0x1(%eax),%edx
    d1c7:	8b 45 08             	mov    0x8(%ebp),%eax
    d1ca:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    d1cd:	8b 45 08             	mov    0x8(%ebp),%eax
    d1d0:	8b 40 14             	mov    0x14(%eax),%eax
    d1d3:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    d1d6:	0f 93 c0             	setae  %al
    d1d9:	0f b6 c0             	movzbl %al,%eax
    d1dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    d1df:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d1e3:	74 12                	je     d1f7 <lodepng_compute_color_stats+0x9a2>
    d1e5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d1e9:	74 0c                	je     d1f7 <lodepng_compute_color_stats+0x9a2>
    d1eb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d1ef:	74 06                	je     d1f7 <lodepng_compute_color_stats+0x9a2>
    d1f1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d1f5:	75 12                	jne    d209 <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    d1f7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d1fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1fe:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    d201:	0f 85 49 fc ff ff    	jne    ce50 <lodepng_compute_color_stats+0x5fb>
    d207:	eb 01                	jmp    d20a <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    d209:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    d20a:	8b 45 08             	mov    0x8(%ebp),%eax
    d20d:	8b 40 04             	mov    0x4(%eax),%eax
    d210:	85 c0                	test   %eax,%eax
    d212:	0f 84 dd 00 00 00    	je     d2f5 <lodepng_compute_color_stats+0xaa0>
    d218:	8b 45 08             	mov    0x8(%ebp),%eax
    d21b:	8b 40 10             	mov    0x10(%eax),%eax
    d21e:	85 c0                	test   %eax,%eax
    d220:	0f 85 cf 00 00 00    	jne    d2f5 <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    d226:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d22d:	e9 b7 00 00 00       	jmp    d2e9 <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    d232:	83 ec 04             	sub    $0x4,%esp
    d235:	ff 75 18             	pushl  0x18(%ebp)
    d238:	ff 75 f4             	pushl  -0xc(%ebp)
    d23b:	ff 75 0c             	pushl  0xc(%ebp)
    d23e:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    d244:	50                   	push   %eax
    d245:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    d24b:	50                   	push   %eax
    d24c:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    d252:	50                   	push   %eax
    d253:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    d259:	50                   	push   %eax
    d25a:	e8 3c da ff ff       	call   ac9b <getPixelColorRGBA8>
    d25f:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    d262:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d269:	84 c0                	test   %al,%al
    d26b:	74 78                	je     d2e5 <lodepng_compute_color_stats+0xa90>
    d26d:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d274:	0f b6 d0             	movzbl %al,%edx
    d277:	8b 45 08             	mov    0x8(%ebp),%eax
    d27a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d27e:	66 39 c2             	cmp    %ax,%dx
    d281:	75 62                	jne    d2e5 <lodepng_compute_color_stats+0xa90>
    d283:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d28a:	0f b6 d0             	movzbl %al,%edx
    d28d:	8b 45 08             	mov    0x8(%ebp),%eax
    d290:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d294:	66 39 c2             	cmp    %ax,%dx
    d297:	75 4c                	jne    d2e5 <lodepng_compute_color_stats+0xa90>
    d299:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d2a0:	0f b6 d0             	movzbl %al,%edx
    d2a3:	8b 45 08             	mov    0x8(%ebp),%eax
    d2a6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d2aa:	66 39 c2             	cmp    %ax,%dx
    d2ad:	75 36                	jne    d2e5 <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    d2af:	8b 45 08             	mov    0x8(%ebp),%eax
    d2b2:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    d2b9:	8b 45 08             	mov    0x8(%ebp),%eax
    d2bc:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    d2c3:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    d2ca:	8b 45 08             	mov    0x8(%ebp),%eax
    d2cd:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d2d3:	83 f8 07             	cmp    $0x7,%eax
    d2d6:	77 0d                	ja     d2e5 <lodepng_compute_color_stats+0xa90>
    d2d8:	8b 45 08             	mov    0x8(%ebp),%eax
    d2db:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    d2e2:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    d2e5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d2e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2ec:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    d2ef:	0f 85 3d ff ff ff    	jne    d232 <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    d2f5:	8b 45 08             	mov    0x8(%ebp),%eax
    d2f8:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    d2fc:	8b 45 08             	mov    0x8(%ebp),%eax
    d2ff:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d303:	c1 e0 08             	shl    $0x8,%eax
    d306:	01 c2                	add    %eax,%edx
    d308:	8b 45 08             	mov    0x8(%ebp),%eax
    d30b:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    d30f:	8b 45 08             	mov    0x8(%ebp),%eax
    d312:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    d316:	8b 45 08             	mov    0x8(%ebp),%eax
    d319:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d31d:	c1 e0 08             	shl    $0x8,%eax
    d320:	01 c2                	add    %eax,%edx
    d322:	8b 45 08             	mov    0x8(%ebp),%eax
    d325:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    d329:	8b 45 08             	mov    0x8(%ebp),%eax
    d32c:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    d330:	8b 45 08             	mov    0x8(%ebp),%eax
    d333:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d337:	c1 e0 08             	shl    $0x8,%eax
    d33a:	01 c2                	add    %eax,%edx
    d33c:	8b 45 08             	mov    0x8(%ebp),%eax
    d33f:	66 89 50 0c          	mov    %dx,0xc(%eax)
    d343:	eb 04                	jmp    d349 <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    d345:	90                   	nop
    d346:	eb 01                	jmp    d349 <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    d348:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    d349:	83 ec 0c             	sub    $0xc,%esp
    d34c:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    d352:	50                   	push   %eax
    d353:	e8 91 d0 ff ff       	call   a3e9 <color_tree_cleanup>
    d358:	83 c4 10             	add    $0x10,%esp
  return error;
    d35b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    d35e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d361:	5b                   	pop    %ebx
    d362:	5e                   	pop    %esi
    d363:	5d                   	pop    %ebp
    d364:	c3                   	ret    

0000d365 <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    d365:	55                   	push   %ebp
    d366:	89 e5                	mov    %esp,%ebp
    d368:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    d36b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    d372:	8d 45 cc             	lea    -0x34(%ebp),%eax
    d375:	50                   	push   %eax
    d376:	e8 d1 bd ff ff       	call   914c <lodepng_color_mode_init>
    d37b:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    d37e:	8b 45 0c             	mov    0xc(%ebp),%eax
    d381:	c1 e8 08             	shr    $0x8,%eax
    d384:	88 45 ec             	mov    %al,-0x14(%ebp)
    d387:	8b 45 0c             	mov    0xc(%ebp),%eax
    d38a:	88 45 ed             	mov    %al,-0x13(%ebp)
    d38d:	8b 45 10             	mov    0x10(%ebp),%eax
    d390:	c1 e8 08             	shr    $0x8,%eax
    d393:	88 45 ee             	mov    %al,-0x12(%ebp)
    d396:	8b 45 10             	mov    0x10(%ebp),%eax
    d399:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    d39c:	8b 45 14             	mov    0x14(%ebp),%eax
    d39f:	c1 e8 08             	shr    $0x8,%eax
    d3a2:	88 45 f0             	mov    %al,-0x10(%ebp)
    d3a5:	8b 45 14             	mov    0x14(%ebp),%eax
    d3a8:	88 45 f1             	mov    %al,-0xf(%ebp)
    d3ab:	8b 45 18             	mov    0x18(%ebp),%eax
    d3ae:	c1 e8 08             	shr    $0x8,%eax
    d3b1:	88 45 f2             	mov    %al,-0xe(%ebp)
    d3b4:	8b 45 18             	mov    0x18(%ebp),%eax
    d3b7:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    d3ba:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    d3c1:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    d3c8:	83 ec 0c             	sub    $0xc,%esp
    d3cb:	8d 45 cc             	lea    -0x34(%ebp),%eax
    d3ce:	50                   	push   %eax
    d3cf:	6a 01                	push   $0x1
    d3d1:	6a 01                	push   $0x1
    d3d3:	8d 45 ec             	lea    -0x14(%ebp),%eax
    d3d6:	50                   	push   %eax
    d3d7:	ff 75 08             	pushl  0x8(%ebp)
    d3da:	e8 76 f4 ff ff       	call   c855 <lodepng_compute_color_stats>
    d3df:	83 c4 20             	add    $0x20,%esp
    d3e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    d3e5:	83 ec 0c             	sub    $0xc,%esp
    d3e8:	8d 45 cc             	lea    -0x34(%ebp),%eax
    d3eb:	50                   	push   %eax
    d3ec:	e8 4e be ff ff       	call   923f <lodepng_color_mode_cleanup>
    d3f1:	83 c4 10             	add    $0x10,%esp
  return error;
    d3f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d3f7:	c9                   	leave  
    d3f8:	c3                   	ret    

0000d3f9 <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    d3f9:	55                   	push   %ebp
    d3fa:	89 e5                	mov    %esp,%ebp
    d3fc:	56                   	push   %esi
    d3fd:	53                   	push   %ebx
    d3fe:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    d401:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    d408:	8b 45 10             	mov    0x10(%ebp),%eax
    d40b:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    d411:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    d414:	8b 45 10             	mov    0x10(%ebp),%eax
    d417:	8b 40 10             	mov    0x10(%eax),%eax
    d41a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    d41d:	8b 45 10             	mov    0x10(%ebp),%eax
    d420:	8b 40 04             	mov    0x4(%eax),%eax
    d423:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    d426:	8b 45 10             	mov    0x10(%ebp),%eax
    d429:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d42f:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    d432:	8b 45 08             	mov    0x8(%ebp),%eax
    d435:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    d43c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d440:	74 21                	je     d463 <auto_choose_color+0x6a>
    d442:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    d446:	7f 1b                	jg     d463 <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    d448:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    d44f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    d456:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    d45a:	77 07                	ja     d463 <auto_choose_color+0x6a>
    d45c:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    d463:	8b 45 10             	mov    0x10(%ebp),%eax
    d466:	8b 00                	mov    (%eax),%eax
    d468:	85 c0                	test   %eax,%eax
    d46a:	0f 94 c0             	sete   %al
    d46d:	0f b6 c0             	movzbl %al,%eax
    d470:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    d473:	8b 45 10             	mov    0x10(%ebp),%eax
    d476:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    d47c:	85 c0                	test   %eax,%eax
    d47e:	75 07                	jne    d487 <auto_choose_color+0x8e>
    d480:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    d487:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d48b:	75 0d                	jne    d49a <auto_choose_color+0xa1>
    d48d:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    d491:	77 07                	ja     d49a <auto_choose_color+0xa1>
    d493:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    d49a:	8b 45 10             	mov    0x10(%ebp),%eax
    d49d:	8b 40 14             	mov    0x14(%eax),%eax
    d4a0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    d4a3:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    d4a7:	7e 21                	jle    d4ca <auto_choose_color+0xd1>
    d4a9:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    d4ad:	7e 14                	jle    d4c3 <auto_choose_color+0xca>
    d4af:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    d4b3:	7f 07                	jg     d4bc <auto_choose_color+0xc3>
    d4b5:	b8 04 00 00 00       	mov    $0x4,%eax
    d4ba:	eb 13                	jmp    d4cf <auto_choose_color+0xd6>
    d4bc:	b8 08 00 00 00       	mov    $0x8,%eax
    d4c1:	eb 0c                	jmp    d4cf <auto_choose_color+0xd6>
    d4c3:	b8 02 00 00 00       	mov    $0x2,%eax
    d4c8:	eb 05                	jmp    d4cf <auto_choose_color+0xd6>
    d4ca:	b8 01 00 00 00       	mov    $0x1,%eax
    d4cf:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    d4d2:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    d4d9:	7f 13                	jg     d4ee <auto_choose_color+0xf5>
    d4db:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    d4df:	77 0d                	ja     d4ee <auto_choose_color+0xf5>
    d4e1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    d4e5:	74 07                	je     d4ee <auto_choose_color+0xf5>
    d4e7:	b8 01 00 00 00       	mov    $0x1,%eax
    d4ec:	eb 05                	jmp    d4f3 <auto_choose_color+0xfa>
    d4ee:	b8 00 00 00 00       	mov    $0x0,%eax
    d4f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    d4f6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d4f9:	01 c0                	add    %eax,%eax
    d4fb:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    d4fe:	7e 07                	jle    d507 <auto_choose_color+0x10e>
    d500:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    d507:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d50b:	74 15                	je     d522 <auto_choose_color+0x129>
    d50d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d511:	75 0f                	jne    d522 <auto_choose_color+0x129>
    d513:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d516:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    d519:	77 07                	ja     d522 <auto_choose_color+0x129>
    d51b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    d522:	8b 45 10             	mov    0x10(%ebp),%eax
    d525:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    d52b:	85 c0                	test   %eax,%eax
    d52d:	75 07                	jne    d536 <auto_choose_color+0x13d>
    d52f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    d536:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d53a:	0f 84 0a 01 00 00    	je     d64a <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    d540:	8b 45 10             	mov    0x10(%ebp),%eax
    d543:	83 c0 18             	add    $0x18,%eax
    d546:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    d549:	83 ec 0c             	sub    $0xc,%esp
    d54c:	ff 75 08             	pushl  0x8(%ebp)
    d54f:	e8 ef be ff ff       	call   9443 <lodepng_palette_clear>
    d554:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    d557:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    d55e:	eb 6e                	jmp    d5ce <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    d560:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d563:	c1 e0 02             	shl    $0x2,%eax
    d566:	8d 50 03             	lea    0x3(%eax),%edx
    d569:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d56c:	01 d0                	add    %edx,%eax
    d56e:	0f b6 00             	movzbl (%eax),%eax
    d571:	0f b6 d8             	movzbl %al,%ebx
    d574:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d577:	c1 e0 02             	shl    $0x2,%eax
    d57a:	8d 50 02             	lea    0x2(%eax),%edx
    d57d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d580:	01 d0                	add    %edx,%eax
    d582:	0f b6 00             	movzbl (%eax),%eax
    d585:	0f b6 c8             	movzbl %al,%ecx
    d588:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d58b:	c1 e0 02             	shl    $0x2,%eax
    d58e:	8d 50 01             	lea    0x1(%eax),%edx
    d591:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d594:	01 d0                	add    %edx,%eax
    d596:	0f b6 00             	movzbl (%eax),%eax
    d599:	0f b6 d0             	movzbl %al,%edx
    d59c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d59f:	c1 e0 02             	shl    $0x2,%eax
    d5a2:	89 c6                	mov    %eax,%esi
    d5a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d5a7:	01 f0                	add    %esi,%eax
    d5a9:	0f b6 00             	movzbl (%eax),%eax
    d5ac:	0f b6 c0             	movzbl %al,%eax
    d5af:	83 ec 0c             	sub    $0xc,%esp
    d5b2:	53                   	push   %ebx
    d5b3:	51                   	push   %ecx
    d5b4:	52                   	push   %edx
    d5b5:	50                   	push   %eax
    d5b6:	ff 75 08             	pushl  0x8(%ebp)
    d5b9:	e8 be be ff ff       	call   947c <lodepng_palette_add>
    d5be:	83 c4 20             	add    $0x20,%esp
    d5c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    d5c4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    d5c8:	75 13                	jne    d5dd <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    d5ca:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    d5ce:	8b 45 10             	mov    0x10(%ebp),%eax
    d5d1:	8b 50 14             	mov    0x14(%eax),%edx
    d5d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d5d7:	39 c2                	cmp    %eax,%edx
    d5d9:	75 85                	jne    d560 <auto_choose_color+0x167>
    d5db:	eb 01                	jmp    d5de <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    d5dd:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    d5de:	8b 45 08             	mov    0x8(%ebp),%eax
    d5e1:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    d5e7:	8b 45 08             	mov    0x8(%ebp),%eax
    d5ea:	8b 55 d0             	mov    -0x30(%ebp),%edx
    d5ed:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    d5f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    d5f3:	8b 00                	mov    (%eax),%eax
    d5f5:	83 f8 03             	cmp    $0x3,%eax
    d5f8:	0f 85 ec 00 00 00    	jne    d6ea <auto_choose_color+0x2f1>
    d5fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    d601:	8b 50 0c             	mov    0xc(%eax),%edx
    d604:	8b 45 08             	mov    0x8(%ebp),%eax
    d607:	8b 40 0c             	mov    0xc(%eax),%eax
    d60a:	39 c2                	cmp    %eax,%edx
    d60c:	0f 8c d8 00 00 00    	jl     d6ea <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    d612:	8b 45 0c             	mov    0xc(%ebp),%eax
    d615:	8b 50 04             	mov    0x4(%eax),%edx
    d618:	8b 45 08             	mov    0x8(%ebp),%eax
    d61b:	8b 40 04             	mov    0x4(%eax),%eax
    d61e:	39 c2                	cmp    %eax,%edx
    d620:	0f 85 c4 00 00 00    	jne    d6ea <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    d626:	83 ec 0c             	sub    $0xc,%esp
    d629:	ff 75 08             	pushl  0x8(%ebp)
    d62c:	e8 0e bc ff ff       	call   923f <lodepng_color_mode_cleanup>
    d631:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    d634:	83 ec 08             	sub    $0x8,%esp
    d637:	ff 75 0c             	pushl  0xc(%ebp)
    d63a:	ff 75 08             	pushl  0x8(%ebp)
    d63d:	e8 14 bc ff ff       	call   9256 <lodepng_color_mode_copy>
    d642:	83 c4 10             	add    $0x10,%esp
    d645:	e9 a0 00 00 00       	jmp    d6ea <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    d64a:	8b 45 08             	mov    0x8(%ebp),%eax
    d64d:	8b 55 dc             	mov    -0x24(%ebp),%edx
    d650:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    d653:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d657:	74 14                	je     d66d <auto_choose_color+0x274>
    d659:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d65d:	74 07                	je     d666 <auto_choose_color+0x26d>
    d65f:	b8 04 00 00 00       	mov    $0x4,%eax
    d664:	eb 19                	jmp    d67f <auto_choose_color+0x286>
    d666:	b8 06 00 00 00       	mov    $0x6,%eax
    d66b:	eb 12                	jmp    d67f <auto_choose_color+0x286>
    d66d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d671:	74 07                	je     d67a <auto_choose_color+0x281>
    d673:	b8 00 00 00 00       	mov    $0x0,%eax
    d678:	eb 05                	jmp    d67f <auto_choose_color+0x286>
    d67a:	b8 02 00 00 00       	mov    $0x2,%eax
    d67f:	8b 55 08             	mov    0x8(%ebp),%edx
    d682:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    d684:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d688:	74 60                	je     d6ea <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    d68a:	8b 45 08             	mov    0x8(%ebp),%eax
    d68d:	8b 40 04             	mov    0x4(%eax),%eax
    d690:	ba 01 00 00 00       	mov    $0x1,%edx
    d695:	89 c1                	mov    %eax,%ecx
    d697:	d3 e2                	shl    %cl,%edx
    d699:	89 d0                	mov    %edx,%eax
    d69b:	83 e8 01             	sub    $0x1,%eax
    d69e:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    d6a1:	8b 45 10             	mov    0x10(%ebp),%eax
    d6a4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d6a8:	0f b7 c0             	movzwl %ax,%eax
    d6ab:	23 45 c8             	and    -0x38(%ebp),%eax
    d6ae:	89 c2                	mov    %eax,%edx
    d6b0:	8b 45 08             	mov    0x8(%ebp),%eax
    d6b3:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    d6b6:	8b 45 10             	mov    0x10(%ebp),%eax
    d6b9:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d6bd:	0f b7 c0             	movzwl %ax,%eax
    d6c0:	23 45 c8             	and    -0x38(%ebp),%eax
    d6c3:	89 c2                	mov    %eax,%edx
    d6c5:	8b 45 08             	mov    0x8(%ebp),%eax
    d6c8:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    d6cb:	8b 45 10             	mov    0x10(%ebp),%eax
    d6ce:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d6d2:	0f b7 c0             	movzwl %ax,%eax
    d6d5:	23 45 c8             	and    -0x38(%ebp),%eax
    d6d8:	89 c2                	mov    %eax,%edx
    d6da:	8b 45 08             	mov    0x8(%ebp),%eax
    d6dd:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    d6e0:	8b 45 08             	mov    0x8(%ebp),%eax
    d6e3:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    d6ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d6ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d6f0:	5b                   	pop    %ebx
    d6f1:	5e                   	pop    %esi
    d6f2:	5d                   	pop    %ebp
    d6f3:	c3                   	ret    

0000d6f4 <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    d6f4:	55                   	push   %ebp
    d6f5:	89 e5                	mov    %esp,%ebp
    d6f7:	83 ec 1c             	sub    $0x1c,%esp
    d6fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d6fd:	8b 55 0c             	mov    0xc(%ebp),%edx
    d700:	8b 45 10             	mov    0x10(%ebp),%eax
    d703:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    d707:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    d70b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    d70f:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    d713:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d717:	29 c2                	sub    %eax,%edx
    d719:	89 d0                	mov    %edx,%eax
    d71b:	99                   	cltd   
    d71c:	31 d0                	xor    %edx,%eax
    d71e:	29 d0                	sub    %edx,%eax
    d720:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    d724:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d728:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d72c:	29 c2                	sub    %eax,%edx
    d72e:	89 d0                	mov    %edx,%eax
    d730:	99                   	cltd   
    d731:	31 d0                	xor    %edx,%eax
    d733:	29 d0                	sub    %edx,%eax
    d735:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    d739:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d73d:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    d741:	01 c2                	add    %eax,%edx
    d743:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d747:	29 c2                	sub    %eax,%edx
    d749:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d74d:	29 c2                	sub    %eax,%edx
    d74f:	89 d0                	mov    %edx,%eax
    d751:	99                   	cltd   
    d752:	31 d0                	xor    %edx,%eax
    d754:	29 d0                	sub    %edx,%eax
    d756:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    d75a:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d75e:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d762:	7d 10                	jge    d774 <paethPredictor+0x80>
    d764:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d768:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d76c:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d770:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d774:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d778:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d77c:	7d 06                	jge    d784 <paethPredictor+0x90>
    d77e:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d782:	eb 04                	jmp    d788 <paethPredictor+0x94>
    d784:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d788:	c9                   	leave  
    d789:	c3                   	ret    

0000d78a <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d78a:	55                   	push   %ebp
    d78b:	89 e5                	mov    %esp,%ebp
    d78d:	56                   	push   %esi
    d78e:	53                   	push   %ebx
    d78f:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d792:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d799:	e9 e2 00 00 00       	jmp    d880 <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d79e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d7a8:	8b 45 08             	mov    0x8(%ebp),%eax
    d7ab:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d7ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7b1:	8b 14 85 54 a7 01 00 	mov    0x1a754(,%eax,4),%edx
    d7b8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d7bb:	01 c2                	add    %eax,%edx
    d7bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7c0:	8b 04 85 1c a7 01 00 	mov    0x1a71c(,%eax,4),%eax
    d7c7:	29 c2                	sub    %eax,%edx
    d7c9:	89 d0                	mov    %edx,%eax
    d7cb:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d7ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7d1:	8b 34 85 54 a7 01 00 	mov    0x1a754(,%eax,4),%esi
    d7d8:	89 d8                	mov    %ebx,%eax
    d7da:	ba 00 00 00 00       	mov    $0x0,%edx
    d7df:	f7 f6                	div    %esi
    d7e1:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d7e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7e6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d7ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7f0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d7f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7f6:	8b 14 85 70 a7 01 00 	mov    0x1a770(,%eax,4),%edx
    d7fd:	8b 45 20             	mov    0x20(%ebp),%eax
    d800:	01 c2                	add    %eax,%edx
    d802:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d805:	8b 04 85 38 a7 01 00 	mov    0x1a738(,%eax,4),%eax
    d80c:	29 c2                	sub    %eax,%edx
    d80e:	89 d0                	mov    %edx,%eax
    d810:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d813:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d816:	8b 34 85 70 a7 01 00 	mov    0x1a770(,%eax,4),%esi
    d81d:	89 d8                	mov    %ebx,%eax
    d81f:	ba 00 00 00 00       	mov    $0x0,%edx
    d824:	f7 f6                	div    %esi
    d826:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d828:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d82b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d832:	8b 45 08             	mov    0x8(%ebp),%eax
    d835:	01 d0                	add    %edx,%eax
    d837:	8b 00                	mov    (%eax),%eax
    d839:	85 c0                	test   %eax,%eax
    d83b:	75 15                	jne    d852 <Adam7_getpassvalues+0xc8>
    d83d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d840:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d847:	8b 45 0c             	mov    0xc(%ebp),%eax
    d84a:	01 d0                	add    %edx,%eax
    d84c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d852:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d855:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d85c:	8b 45 0c             	mov    0xc(%ebp),%eax
    d85f:	01 d0                	add    %edx,%eax
    d861:	8b 00                	mov    (%eax),%eax
    d863:	85 c0                	test   %eax,%eax
    d865:	75 15                	jne    d87c <Adam7_getpassvalues+0xf2>
    d867:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d86a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d871:	8b 45 08             	mov    0x8(%ebp),%eax
    d874:	01 d0                	add    %edx,%eax
    d876:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d87c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d880:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d884:	0f 85 14 ff ff ff    	jne    d79e <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d88a:	8b 45 18             	mov    0x18(%ebp),%eax
    d88d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d893:	8b 45 18             	mov    0x18(%ebp),%eax
    d896:	8b 10                	mov    (%eax),%edx
    d898:	8b 45 14             	mov    0x14(%ebp),%eax
    d89b:	89 10                	mov    %edx,(%eax)
    d89d:	8b 45 14             	mov    0x14(%ebp),%eax
    d8a0:	8b 10                	mov    (%eax),%edx
    d8a2:	8b 45 10             	mov    0x10(%ebp),%eax
    d8a5:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d8a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d8ae:	e9 40 01 00 00       	jmp    d9f3 <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d8b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8b6:	83 c0 01             	add    $0x1,%eax
    d8b9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d8c0:	8b 45 10             	mov    0x10(%ebp),%eax
    d8c3:	01 c2                	add    %eax,%edx
    d8c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8c8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d8cf:	8b 45 10             	mov    0x10(%ebp),%eax
    d8d2:	01 c8                	add    %ecx,%eax
    d8d4:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d8d6:	89 c6                	mov    %eax,%esi
    d8d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8db:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d8e2:	8b 45 08             	mov    0x8(%ebp),%eax
    d8e5:	01 c8                	add    %ecx,%eax
    d8e7:	8b 00                	mov    (%eax),%eax
    d8e9:	85 c0                	test   %eax,%eax
    d8eb:	74 49                	je     d936 <Adam7_getpassvalues+0x1ac>
    d8ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8f0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d8f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8fa:	01 c8                	add    %ecx,%eax
    d8fc:	8b 00                	mov    (%eax),%eax
    d8fe:	85 c0                	test   %eax,%eax
    d900:	74 34                	je     d936 <Adam7_getpassvalues+0x1ac>
    d902:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d905:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d90c:	8b 45 0c             	mov    0xc(%ebp),%eax
    d90f:	01 c8                	add    %ecx,%eax
    d911:	8b 08                	mov    (%eax),%ecx
    d913:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d916:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d91d:	8b 45 08             	mov    0x8(%ebp),%eax
    d920:	01 d8                	add    %ebx,%eax
    d922:	8b 00                	mov    (%eax),%eax
    d924:	0f af 45 24          	imul   0x24(%ebp),%eax
    d928:	83 c0 07             	add    $0x7,%eax
    d92b:	c1 e8 03             	shr    $0x3,%eax
    d92e:	83 c0 01             	add    $0x1,%eax
    d931:	0f af c1             	imul   %ecx,%eax
    d934:	eb 05                	jmp    d93b <Adam7_getpassvalues+0x1b1>
    d936:	b8 00 00 00 00       	mov    $0x0,%eax
    d93b:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d93d:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d93f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d942:	83 c0 01             	add    $0x1,%eax
    d945:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d94c:	8b 45 14             	mov    0x14(%ebp),%eax
    d94f:	01 c2                	add    %eax,%edx
    d951:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d954:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d95b:	8b 45 14             	mov    0x14(%ebp),%eax
    d95e:	01 c8                	add    %ecx,%eax
    d960:	8b 00                	mov    (%eax),%eax
    d962:	89 c6                	mov    %eax,%esi
    d964:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d967:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d96e:	8b 45 0c             	mov    0xc(%ebp),%eax
    d971:	01 c8                	add    %ecx,%eax
    d973:	8b 08                	mov    (%eax),%ecx
    d975:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d978:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d97f:	8b 45 08             	mov    0x8(%ebp),%eax
    d982:	01 d8                	add    %ebx,%eax
    d984:	8b 00                	mov    (%eax),%eax
    d986:	0f af 45 24          	imul   0x24(%ebp),%eax
    d98a:	83 c0 07             	add    $0x7,%eax
    d98d:	c1 e8 03             	shr    $0x3,%eax
    d990:	0f af c1             	imul   %ecx,%eax
    d993:	01 f0                	add    %esi,%eax
    d995:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d997:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d99a:	83 c0 01             	add    $0x1,%eax
    d99d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d9a4:	8b 45 18             	mov    0x18(%ebp),%eax
    d9a7:	01 c2                	add    %eax,%edx
    d9a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9ac:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d9b3:	8b 45 18             	mov    0x18(%ebp),%eax
    d9b6:	01 c8                	add    %ecx,%eax
    d9b8:	8b 00                	mov    (%eax),%eax
    d9ba:	89 c6                	mov    %eax,%esi
    d9bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9bf:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d9c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    d9c9:	01 c8                	add    %ecx,%eax
    d9cb:	8b 08                	mov    (%eax),%ecx
    d9cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9d0:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d9d7:	8b 45 08             	mov    0x8(%ebp),%eax
    d9da:	01 d8                	add    %ebx,%eax
    d9dc:	8b 00                	mov    (%eax),%eax
    d9de:	0f af c1             	imul   %ecx,%eax
    d9e1:	0f af 45 24          	imul   0x24(%ebp),%eax
    d9e5:	83 c0 07             	add    $0x7,%eax
    d9e8:	c1 e8 03             	shr    $0x3,%eax
    d9eb:	01 f0                	add    %esi,%eax
    d9ed:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d9ef:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d9f3:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d9f7:	0f 85 b6 fe ff ff    	jne    d8b3 <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d9fd:	90                   	nop
    d9fe:	83 c4 10             	add    $0x10,%esp
    da01:	5b                   	pop    %ebx
    da02:	5e                   	pop    %esi
    da03:	5d                   	pop    %ebp
    da04:	c3                   	ret    

0000da05 <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    da05:	55                   	push   %ebp
    da06:	89 e5                	mov    %esp,%ebp
    da08:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    da0b:	8b 45 10             	mov    0x10(%ebp),%eax
    da0e:	05 98 00 00 00       	add    $0x98,%eax
    da13:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    da16:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    da1a:	74 06                	je     da22 <lodepng_inspect+0x1d>
    da1c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    da20:	75 17                	jne    da39 <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    da22:	8b 45 10             	mov    0x10(%ebp),%eax
    da25:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    da2c:	00 00 00 
    da2f:	b8 30 00 00 00       	mov    $0x30,%eax
    da34:	e9 ce 02 00 00       	jmp    dd07 <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    da39:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    da3d:	7f 17                	jg     da56 <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    da3f:	8b 45 10             	mov    0x10(%ebp),%eax
    da42:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    da49:	00 00 00 
    da4c:	b8 1b 00 00 00       	mov    $0x1b,%eax
    da51:	e9 b1 02 00 00       	jmp    dd07 <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    da56:	83 ec 0c             	sub    $0xc,%esp
    da59:	ff 75 f4             	pushl  -0xc(%ebp)
    da5c:	e8 63 c7 ff ff       	call   a1c4 <lodepng_info_cleanup>
    da61:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    da64:	83 ec 0c             	sub    $0xc,%esp
    da67:	ff 75 f4             	pushl  -0xc(%ebp)
    da6a:	e8 74 c6 ff ff       	call   a0e3 <lodepng_info_init>
    da6f:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    da72:	8b 45 14             	mov    0x14(%ebp),%eax
    da75:	0f b6 00             	movzbl (%eax),%eax
    da78:	3c 89                	cmp    $0x89,%al
    da7a:	75 5b                	jne    dad7 <lodepng_inspect+0xd2>
    da7c:	8b 45 14             	mov    0x14(%ebp),%eax
    da7f:	83 c0 01             	add    $0x1,%eax
    da82:	0f b6 00             	movzbl (%eax),%eax
    da85:	3c 50                	cmp    $0x50,%al
    da87:	75 4e                	jne    dad7 <lodepng_inspect+0xd2>
    da89:	8b 45 14             	mov    0x14(%ebp),%eax
    da8c:	83 c0 02             	add    $0x2,%eax
    da8f:	0f b6 00             	movzbl (%eax),%eax
    da92:	3c 4e                	cmp    $0x4e,%al
    da94:	75 41                	jne    dad7 <lodepng_inspect+0xd2>
    da96:	8b 45 14             	mov    0x14(%ebp),%eax
    da99:	83 c0 03             	add    $0x3,%eax
    da9c:	0f b6 00             	movzbl (%eax),%eax
    da9f:	3c 47                	cmp    $0x47,%al
    daa1:	75 34                	jne    dad7 <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    daa3:	8b 45 14             	mov    0x14(%ebp),%eax
    daa6:	83 c0 04             	add    $0x4,%eax
    daa9:	0f b6 00             	movzbl (%eax),%eax
    daac:	3c 0d                	cmp    $0xd,%al
    daae:	75 27                	jne    dad7 <lodepng_inspect+0xd2>
    dab0:	8b 45 14             	mov    0x14(%ebp),%eax
    dab3:	83 c0 05             	add    $0x5,%eax
    dab6:	0f b6 00             	movzbl (%eax),%eax
    dab9:	3c 0a                	cmp    $0xa,%al
    dabb:	75 1a                	jne    dad7 <lodepng_inspect+0xd2>
    dabd:	8b 45 14             	mov    0x14(%ebp),%eax
    dac0:	83 c0 06             	add    $0x6,%eax
    dac3:	0f b6 00             	movzbl (%eax),%eax
    dac6:	3c 1a                	cmp    $0x1a,%al
    dac8:	75 0d                	jne    dad7 <lodepng_inspect+0xd2>
    daca:	8b 45 14             	mov    0x14(%ebp),%eax
    dacd:	83 c0 07             	add    $0x7,%eax
    dad0:	0f b6 00             	movzbl (%eax),%eax
    dad3:	3c 0a                	cmp    $0xa,%al
    dad5:	74 17                	je     daee <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    dad7:	8b 45 10             	mov    0x10(%ebp),%eax
    dada:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    dae1:	00 00 00 
    dae4:	b8 1c 00 00 00       	mov    $0x1c,%eax
    dae9:	e9 19 02 00 00       	jmp    dd07 <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    daee:	8b 45 14             	mov    0x14(%ebp),%eax
    daf1:	83 c0 08             	add    $0x8,%eax
    daf4:	83 ec 0c             	sub    $0xc,%esp
    daf7:	50                   	push   %eax
    daf8:	e8 c2 ae ff ff       	call   89bf <lodepng_chunk_length>
    dafd:	83 c4 10             	add    $0x10,%esp
    db00:	83 f8 0d             	cmp    $0xd,%eax
    db03:	74 17                	je     db1c <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    db05:	8b 45 10             	mov    0x10(%ebp),%eax
    db08:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    db0f:	00 00 00 
    db12:	b8 5e 00 00 00       	mov    $0x5e,%eax
    db17:	e9 eb 01 00 00       	jmp    dd07 <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    db1c:	8b 45 14             	mov    0x14(%ebp),%eax
    db1f:	83 c0 08             	add    $0x8,%eax
    db22:	83 ec 08             	sub    $0x8,%esp
    db25:	68 8c a7 01 00       	push   $0x1a78c
    db2a:	50                   	push   %eax
    db2b:	e8 dc ae ff ff       	call   8a0c <lodepng_chunk_type_equals>
    db30:	83 c4 10             	add    $0x10,%esp
    db33:	84 c0                	test   %al,%al
    db35:	75 17                	jne    db4e <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    db37:	8b 45 10             	mov    0x10(%ebp),%eax
    db3a:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    db41:	00 00 00 
    db44:	b8 1d 00 00 00       	mov    $0x1d,%eax
    db49:	e9 b9 01 00 00       	jmp    dd07 <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    db4e:	8b 45 14             	mov    0x14(%ebp),%eax
    db51:	83 c0 10             	add    $0x10,%eax
    db54:	83 ec 0c             	sub    $0xc,%esp
    db57:	50                   	push   %eax
    db58:	e8 5e 62 ff ff       	call   3dbb <lodepng_read32bitInt>
    db5d:	83 c4 10             	add    $0x10,%esp
    db60:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    db63:	8b 45 14             	mov    0x14(%ebp),%eax
    db66:	83 c0 14             	add    $0x14,%eax
    db69:	83 ec 0c             	sub    $0xc,%esp
    db6c:	50                   	push   %eax
    db6d:	e8 49 62 ff ff       	call   3dbb <lodepng_read32bitInt>
    db72:	83 c4 10             	add    $0x10,%esp
    db75:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    db78:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    db7c:	74 08                	je     db86 <lodepng_inspect+0x181>
    db7e:	8b 45 08             	mov    0x8(%ebp),%eax
    db81:	8b 55 f0             	mov    -0x10(%ebp),%edx
    db84:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    db86:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    db8a:	74 08                	je     db94 <lodepng_inspect+0x18f>
    db8c:	8b 45 0c             	mov    0xc(%ebp),%eax
    db8f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    db92:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    db94:	8b 45 14             	mov    0x14(%ebp),%eax
    db97:	83 c0 18             	add    $0x18,%eax
    db9a:	0f b6 00             	movzbl (%eax),%eax
    db9d:	0f b6 d0             	movzbl %al,%edx
    dba0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dba3:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    dba6:	8b 45 14             	mov    0x14(%ebp),%eax
    dba9:	83 c0 19             	add    $0x19,%eax
    dbac:	0f b6 00             	movzbl (%eax),%eax
    dbaf:	0f b6 d0             	movzbl %al,%edx
    dbb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbb5:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    dbb8:	8b 45 14             	mov    0x14(%ebp),%eax
    dbbb:	83 c0 1a             	add    $0x1a,%eax
    dbbe:	0f b6 00             	movzbl (%eax),%eax
    dbc1:	0f b6 d0             	movzbl %al,%edx
    dbc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbc7:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    dbc9:	8b 45 14             	mov    0x14(%ebp),%eax
    dbcc:	83 c0 1b             	add    $0x1b,%eax
    dbcf:	0f b6 00             	movzbl (%eax),%eax
    dbd2:	0f b6 d0             	movzbl %al,%edx
    dbd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbd8:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    dbdb:	8b 45 14             	mov    0x14(%ebp),%eax
    dbde:	83 c0 1c             	add    $0x1c,%eax
    dbe1:	0f b6 00             	movzbl (%eax),%eax
    dbe4:	0f b6 d0             	movzbl %al,%edx
    dbe7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbea:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    dbed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    dbf1:	74 06                	je     dbf9 <lodepng_inspect+0x1f4>
    dbf3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    dbf7:	75 17                	jne    dc10 <lodepng_inspect+0x20b>
    dbf9:	8b 45 10             	mov    0x10(%ebp),%eax
    dbfc:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    dc03:	00 00 00 
    dc06:	b8 5d 00 00 00       	mov    $0x5d,%eax
    dc0b:	e9 f7 00 00 00       	jmp    dd07 <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    dc10:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc13:	8b 50 10             	mov    0x10(%eax),%edx
    dc16:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc19:	8b 40 0c             	mov    0xc(%eax),%eax
    dc1c:	83 ec 08             	sub    $0x8,%esp
    dc1f:	52                   	push   %edx
    dc20:	50                   	push   %eax
    dc21:	e8 d4 b3 ff ff       	call   8ffa <checkColorValidity>
    dc26:	83 c4 10             	add    $0x10,%esp
    dc29:	89 c2                	mov    %eax,%edx
    dc2b:	8b 45 10             	mov    0x10(%ebp),%eax
    dc2e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    dc34:	8b 45 10             	mov    0x10(%ebp),%eax
    dc37:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    dc3d:	85 c0                	test   %eax,%eax
    dc3f:	74 0e                	je     dc4f <lodepng_inspect+0x24a>
    dc41:	8b 45 10             	mov    0x10(%ebp),%eax
    dc44:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    dc4a:	e9 b8 00 00 00       	jmp    dd07 <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    dc4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc52:	8b 00                	mov    (%eax),%eax
    dc54:	85 c0                	test   %eax,%eax
    dc56:	74 17                	je     dc6f <lodepng_inspect+0x26a>
    dc58:	8b 45 10             	mov    0x10(%ebp),%eax
    dc5b:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    dc62:	00 00 00 
    dc65:	b8 20 00 00 00       	mov    $0x20,%eax
    dc6a:	e9 98 00 00 00       	jmp    dd07 <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    dc6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc72:	8b 40 04             	mov    0x4(%eax),%eax
    dc75:	85 c0                	test   %eax,%eax
    dc77:	74 14                	je     dc8d <lodepng_inspect+0x288>
    dc79:	8b 45 10             	mov    0x10(%ebp),%eax
    dc7c:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    dc83:	00 00 00 
    dc86:	b8 21 00 00 00       	mov    $0x21,%eax
    dc8b:	eb 7a                	jmp    dd07 <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    dc8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc90:	8b 40 08             	mov    0x8(%eax),%eax
    dc93:	83 f8 01             	cmp    $0x1,%eax
    dc96:	76 14                	jbe    dcac <lodepng_inspect+0x2a7>
    dc98:	8b 45 10             	mov    0x10(%ebp),%eax
    dc9b:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    dca2:	00 00 00 
    dca5:	b8 22 00 00 00       	mov    $0x22,%eax
    dcaa:	eb 5b                	jmp    dd07 <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    dcac:	8b 45 10             	mov    0x10(%ebp),%eax
    dcaf:	8b 40 18             	mov    0x18(%eax),%eax
    dcb2:	85 c0                	test   %eax,%eax
    dcb4:	75 48                	jne    dcfe <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    dcb6:	8b 45 14             	mov    0x14(%ebp),%eax
    dcb9:	83 c0 1d             	add    $0x1d,%eax
    dcbc:	83 ec 0c             	sub    $0xc,%esp
    dcbf:	50                   	push   %eax
    dcc0:	e8 f6 60 ff ff       	call   3dbb <lodepng_read32bitInt>
    dcc5:	83 c4 10             	add    $0x10,%esp
    dcc8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    dccb:	8b 45 14             	mov    0x14(%ebp),%eax
    dcce:	83 c0 0c             	add    $0xc,%eax
    dcd1:	83 ec 08             	sub    $0x8,%esp
    dcd4:	6a 11                	push   $0x11
    dcd6:	50                   	push   %eax
    dcd7:	e8 71 ab ff ff       	call   884d <lodepng_crc32>
    dcdc:	83 c4 10             	add    $0x10,%esp
    dcdf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    dce2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dce5:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    dce8:	74 14                	je     dcfe <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    dcea:	8b 45 10             	mov    0x10(%ebp),%eax
    dced:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    dcf4:	00 00 00 
    dcf7:	b8 39 00 00 00       	mov    $0x39,%eax
    dcfc:	eb 09                	jmp    dd07 <lodepng_inspect+0x302>
    }
  }

  return state->error;
    dcfe:	8b 45 10             	mov    0x10(%ebp),%eax
    dd01:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    dd07:	c9                   	leave  
    dd08:	c3                   	ret    

0000dd09 <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    dd09:	55                   	push   %ebp
    dd0a:	89 e5                	mov    %esp,%ebp
    dd0c:	56                   	push   %esi
    dd0d:	53                   	push   %ebx
    dd0e:	83 ec 44             	sub    $0x44,%esp
    dd11:	8b 45 18             	mov    0x18(%ebp),%eax
    dd14:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    dd17:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    dd1b:	83 f8 04             	cmp    $0x4,%eax
    dd1e:	0f 87 81 07 00 00    	ja     e4a5 <unfilterScanline+0x79c>
    dd24:	8b 04 85 94 a7 01 00 	mov    0x1a794(,%eax,4),%eax
    dd2b:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    dd2d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dd34:	eb 19                	jmp    dd4f <unfilterScanline+0x46>
    dd36:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd39:	8b 45 08             	mov    0x8(%ebp),%eax
    dd3c:	01 c2                	add    %eax,%edx
    dd3e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd41:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd44:	01 c8                	add    %ecx,%eax
    dd46:	0f b6 00             	movzbl (%eax),%eax
    dd49:	88 02                	mov    %al,(%edx)
    dd4b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd52:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd55:	75 df                	jne    dd36 <unfilterScanline+0x2d>
      break;
    dd57:	e9 50 07 00 00       	jmp    e4ac <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    dd5c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dd63:	eb 19                	jmp    dd7e <unfilterScanline+0x75>
    dd65:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd68:	8b 45 08             	mov    0x8(%ebp),%eax
    dd6b:	01 c2                	add    %eax,%edx
    dd6d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd70:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd73:	01 c8                	add    %ecx,%eax
    dd75:	0f b6 00             	movzbl (%eax),%eax
    dd78:	88 02                	mov    %al,(%edx)
    dd7a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd81:	3b 45 14             	cmp    0x14(%ebp),%eax
    dd84:	75 df                	jne    dd65 <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    dd86:	8b 45 14             	mov    0x14(%ebp),%eax
    dd89:	89 45 f4             	mov    %eax,-0xc(%ebp)
    dd8c:	eb 2b                	jmp    ddb9 <unfilterScanline+0xb0>
    dd8e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd91:	8b 45 08             	mov    0x8(%ebp),%eax
    dd94:	01 c2                	add    %eax,%edx
    dd96:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd99:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd9c:	01 c8                	add    %ecx,%eax
    dd9e:	0f b6 08             	movzbl (%eax),%ecx
    dda1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dda4:	2b 45 14             	sub    0x14(%ebp),%eax
    dda7:	89 c3                	mov    %eax,%ebx
    dda9:	8b 45 08             	mov    0x8(%ebp),%eax
    ddac:	01 d8                	add    %ebx,%eax
    ddae:	0f b6 00             	movzbl (%eax),%eax
    ddb1:	01 c8                	add    %ecx,%eax
    ddb3:	88 02                	mov    %al,(%edx)
    ddb5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ddb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddbc:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ddbf:	7c cd                	jl     dd8e <unfilterScanline+0x85>
      break;
    ddc1:	e9 e6 06 00 00       	jmp    e4ac <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    ddc6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    ddca:	74 3c                	je     de08 <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    ddcc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ddd3:	eb 26                	jmp    ddfb <unfilterScanline+0xf2>
    ddd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ddd8:	8b 45 08             	mov    0x8(%ebp),%eax
    dddb:	01 d0                	add    %edx,%eax
    dddd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dde0:	8b 55 0c             	mov    0xc(%ebp),%edx
    dde3:	01 ca                	add    %ecx,%edx
    dde5:	0f b6 0a             	movzbl (%edx),%ecx
    dde8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    ddeb:	8b 55 10             	mov    0x10(%ebp),%edx
    ddee:	01 da                	add    %ebx,%edx
    ddf0:	0f b6 12             	movzbl (%edx),%edx
    ddf3:	01 ca                	add    %ecx,%edx
    ddf5:	88 10                	mov    %dl,(%eax)
    ddf7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ddfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddfe:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    de01:	75 d2                	jne    ddd5 <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    de03:	e9 a4 06 00 00       	jmp    e4ac <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    de08:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    de0f:	eb 19                	jmp    de2a <unfilterScanline+0x121>
    de11:	8b 55 f4             	mov    -0xc(%ebp),%edx
    de14:	8b 45 08             	mov    0x8(%ebp),%eax
    de17:	01 c2                	add    %eax,%edx
    de19:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    de1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    de1f:	01 c8                	add    %ecx,%eax
    de21:	0f b6 00             	movzbl (%eax),%eax
    de24:	88 02                	mov    %al,(%edx)
    de26:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    de2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de2d:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    de30:	75 df                	jne    de11 <unfilterScanline+0x108>
      }
      break;
    de32:	e9 75 06 00 00       	jmp    e4ac <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    de37:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    de3b:	0f 84 8e 00 00 00    	je     decf <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    de41:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    de48:	eb 28                	jmp    de72 <unfilterScanline+0x169>
    de4a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    de4d:	8b 45 08             	mov    0x8(%ebp),%eax
    de50:	01 d0                	add    %edx,%eax
    de52:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    de55:	8b 55 0c             	mov    0xc(%ebp),%edx
    de58:	01 ca                	add    %ecx,%edx
    de5a:	0f b6 12             	movzbl (%edx),%edx
    de5d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    de60:	8b 4d 10             	mov    0x10(%ebp),%ecx
    de63:	01 d9                	add    %ebx,%ecx
    de65:	0f b6 09             	movzbl (%ecx),%ecx
    de68:	d0 e9                	shr    %cl
    de6a:	01 ca                	add    %ecx,%edx
    de6c:	88 10                	mov    %dl,(%eax)
    de6e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    de72:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de75:	3b 45 14             	cmp    0x14(%ebp),%eax
    de78:	75 d0                	jne    de4a <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    de7a:	8b 45 14             	mov    0x14(%ebp),%eax
    de7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    de80:	eb 40                	jmp    dec2 <unfilterScanline+0x1b9>
    de82:	8b 55 f4             	mov    -0xc(%ebp),%edx
    de85:	8b 45 08             	mov    0x8(%ebp),%eax
    de88:	01 c2                	add    %eax,%edx
    de8a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    de8d:	8b 45 0c             	mov    0xc(%ebp),%eax
    de90:	01 c8                	add    %ecx,%eax
    de92:	0f b6 08             	movzbl (%eax),%ecx
    de95:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de98:	2b 45 14             	sub    0x14(%ebp),%eax
    de9b:	89 c3                	mov    %eax,%ebx
    de9d:	8b 45 08             	mov    0x8(%ebp),%eax
    dea0:	01 d8                	add    %ebx,%eax
    dea2:	0f b6 00             	movzbl (%eax),%eax
    dea5:	0f b6 d8             	movzbl %al,%ebx
    dea8:	8b 75 f4             	mov    -0xc(%ebp),%esi
    deab:	8b 45 10             	mov    0x10(%ebp),%eax
    deae:	01 f0                	add    %esi,%eax
    deb0:	0f b6 00             	movzbl (%eax),%eax
    deb3:	0f b6 c0             	movzbl %al,%eax
    deb6:	01 d8                	add    %ebx,%eax
    deb8:	d1 f8                	sar    %eax
    deba:	01 c8                	add    %ecx,%eax
    debc:	88 02                	mov    %al,(%edx)
    debe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dec2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dec5:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dec8:	7c b8                	jl     de82 <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    deca:	e9 dd 05 00 00       	jmp    e4ac <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    decf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ded6:	eb 19                	jmp    def1 <unfilterScanline+0x1e8>
    ded8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dedb:	8b 45 08             	mov    0x8(%ebp),%eax
    dede:	01 c2                	add    %eax,%edx
    dee0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dee3:	8b 45 0c             	mov    0xc(%ebp),%eax
    dee6:	01 c8                	add    %ecx,%eax
    dee8:	0f b6 00             	movzbl (%eax),%eax
    deeb:	88 02                	mov    %al,(%edx)
    deed:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    def1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    def4:	3b 45 14             	cmp    0x14(%ebp),%eax
    def7:	75 df                	jne    ded8 <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    def9:	8b 45 14             	mov    0x14(%ebp),%eax
    defc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    deff:	eb 2d                	jmp    df2e <unfilterScanline+0x225>
    df01:	8b 55 f4             	mov    -0xc(%ebp),%edx
    df04:	8b 45 08             	mov    0x8(%ebp),%eax
    df07:	01 c2                	add    %eax,%edx
    df09:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    df0c:	8b 45 0c             	mov    0xc(%ebp),%eax
    df0f:	01 c8                	add    %ecx,%eax
    df11:	0f b6 08             	movzbl (%eax),%ecx
    df14:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df17:	2b 45 14             	sub    0x14(%ebp),%eax
    df1a:	89 c3                	mov    %eax,%ebx
    df1c:	8b 45 08             	mov    0x8(%ebp),%eax
    df1f:	01 d8                	add    %ebx,%eax
    df21:	0f b6 00             	movzbl (%eax),%eax
    df24:	d0 e8                	shr    %al
    df26:	01 c8                	add    %ecx,%eax
    df28:	88 02                	mov    %al,(%edx)
    df2a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    df2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df31:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    df34:	7c cb                	jl     df01 <unfilterScanline+0x1f8>
      }
      break;
    df36:	e9 71 05 00 00       	jmp    e4ac <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    df3b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    df3f:	0f 84 f9 04 00 00    	je     e43e <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    df45:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    df4c:	eb 26                	jmp    df74 <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    df4e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    df51:	8b 45 08             	mov    0x8(%ebp),%eax
    df54:	01 d0                	add    %edx,%eax
    df56:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    df59:	8b 55 0c             	mov    0xc(%ebp),%edx
    df5c:	01 ca                	add    %ecx,%edx
    df5e:	0f b6 0a             	movzbl (%edx),%ecx
    df61:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    df64:	8b 55 10             	mov    0x10(%ebp),%edx
    df67:	01 da                	add    %ebx,%edx
    df69:	0f b6 12             	movzbl (%edx),%edx
    df6c:	01 ca                	add    %ecx,%edx
    df6e:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    df70:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    df74:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df77:	3b 45 14             	cmp    0x14(%ebp),%eax
    df7a:	75 d2                	jne    df4e <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    df7c:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    df80:	0f 8e db 01 00 00    	jle    e161 <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    df86:	e9 c2 01 00 00       	jmp    e14d <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    df8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df8e:	2b 45 14             	sub    0x14(%ebp),%eax
    df91:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    df94:	8b 55 f4             	mov    -0xc(%ebp),%edx
    df97:	8b 45 0c             	mov    0xc(%ebp),%eax
    df9a:	01 d0                	add    %edx,%eax
    df9c:	0f b6 00             	movzbl (%eax),%eax
    df9f:	88 45 ef             	mov    %al,-0x11(%ebp)
    dfa2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dfa5:	8d 50 01             	lea    0x1(%eax),%edx
    dfa8:	8b 45 0c             	mov    0xc(%ebp),%eax
    dfab:	01 d0                	add    %edx,%eax
    dfad:	0f b6 00             	movzbl (%eax),%eax
    dfb0:	88 45 ee             	mov    %al,-0x12(%ebp)
    dfb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dfb6:	8d 50 02             	lea    0x2(%eax),%edx
    dfb9:	8b 45 0c             	mov    0xc(%ebp),%eax
    dfbc:	01 d0                	add    %edx,%eax
    dfbe:	0f b6 00             	movzbl (%eax),%eax
    dfc1:	88 45 ed             	mov    %al,-0x13(%ebp)
    dfc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dfc7:	8d 50 03             	lea    0x3(%eax),%edx
    dfca:	8b 45 0c             	mov    0xc(%ebp),%eax
    dfcd:	01 d0                	add    %edx,%eax
    dfcf:	0f b6 00             	movzbl (%eax),%eax
    dfd2:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    dfd5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    dfd8:	8b 45 08             	mov    0x8(%ebp),%eax
    dfdb:	01 d0                	add    %edx,%eax
    dfdd:	0f b6 00             	movzbl (%eax),%eax
    dfe0:	88 45 eb             	mov    %al,-0x15(%ebp)
    dfe3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dfe6:	8d 50 01             	lea    0x1(%eax),%edx
    dfe9:	8b 45 08             	mov    0x8(%ebp),%eax
    dfec:	01 d0                	add    %edx,%eax
    dfee:	0f b6 00             	movzbl (%eax),%eax
    dff1:	88 45 ea             	mov    %al,-0x16(%ebp)
    dff4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dff7:	8d 50 02             	lea    0x2(%eax),%edx
    dffa:	8b 45 08             	mov    0x8(%ebp),%eax
    dffd:	01 d0                	add    %edx,%eax
    dfff:	0f b6 00             	movzbl (%eax),%eax
    e002:	88 45 e9             	mov    %al,-0x17(%ebp)
    e005:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e008:	8d 50 03             	lea    0x3(%eax),%edx
    e00b:	8b 45 08             	mov    0x8(%ebp),%eax
    e00e:	01 d0                	add    %edx,%eax
    e010:	0f b6 00             	movzbl (%eax),%eax
    e013:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    e016:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e019:	8b 45 10             	mov    0x10(%ebp),%eax
    e01c:	01 d0                	add    %edx,%eax
    e01e:	0f b6 00             	movzbl (%eax),%eax
    e021:	88 45 e7             	mov    %al,-0x19(%ebp)
    e024:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e027:	8d 50 01             	lea    0x1(%eax),%edx
    e02a:	8b 45 10             	mov    0x10(%ebp),%eax
    e02d:	01 d0                	add    %edx,%eax
    e02f:	0f b6 00             	movzbl (%eax),%eax
    e032:	88 45 e6             	mov    %al,-0x1a(%ebp)
    e035:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e038:	8d 50 02             	lea    0x2(%eax),%edx
    e03b:	8b 45 10             	mov    0x10(%ebp),%eax
    e03e:	01 d0                	add    %edx,%eax
    e040:	0f b6 00             	movzbl (%eax),%eax
    e043:	88 45 e5             	mov    %al,-0x1b(%ebp)
    e046:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e049:	8d 50 03             	lea    0x3(%eax),%edx
    e04c:	8b 45 10             	mov    0x10(%ebp),%eax
    e04f:	01 d0                	add    %edx,%eax
    e051:	0f b6 00             	movzbl (%eax),%eax
    e054:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    e057:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e05a:	8b 45 10             	mov    0x10(%ebp),%eax
    e05d:	01 d0                	add    %edx,%eax
    e05f:	0f b6 00             	movzbl (%eax),%eax
    e062:	88 45 e3             	mov    %al,-0x1d(%ebp)
    e065:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e068:	8d 50 01             	lea    0x1(%eax),%edx
    e06b:	8b 45 10             	mov    0x10(%ebp),%eax
    e06e:	01 d0                	add    %edx,%eax
    e070:	0f b6 00             	movzbl (%eax),%eax
    e073:	88 45 e2             	mov    %al,-0x1e(%ebp)
    e076:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e079:	8d 50 02             	lea    0x2(%eax),%edx
    e07c:	8b 45 10             	mov    0x10(%ebp),%eax
    e07f:	01 d0                	add    %edx,%eax
    e081:	0f b6 00             	movzbl (%eax),%eax
    e084:	88 45 e1             	mov    %al,-0x1f(%ebp)
    e087:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e08a:	8d 50 03             	lea    0x3(%eax),%edx
    e08d:	8b 45 10             	mov    0x10(%ebp),%eax
    e090:	01 d0                	add    %edx,%eax
    e092:	0f b6 00             	movzbl (%eax),%eax
    e095:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    e098:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e09b:	8b 45 08             	mov    0x8(%ebp),%eax
    e09e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e0a1:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    e0a5:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    e0a9:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    e0ad:	51                   	push   %ecx
    e0ae:	52                   	push   %edx
    e0af:	50                   	push   %eax
    e0b0:	e8 3f f6 ff ff       	call   d6f4 <paethPredictor>
    e0b5:	83 c4 0c             	add    $0xc,%esp
    e0b8:	89 c2                	mov    %eax,%edx
    e0ba:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    e0be:	01 d0                	add    %edx,%eax
    e0c0:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    e0c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e0c5:	8d 50 01             	lea    0x1(%eax),%edx
    e0c8:	8b 45 08             	mov    0x8(%ebp),%eax
    e0cb:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e0ce:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    e0d2:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    e0d6:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    e0da:	51                   	push   %ecx
    e0db:	52                   	push   %edx
    e0dc:	50                   	push   %eax
    e0dd:	e8 12 f6 ff ff       	call   d6f4 <paethPredictor>
    e0e2:	83 c4 0c             	add    $0xc,%esp
    e0e5:	89 c2                	mov    %eax,%edx
    e0e7:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    e0eb:	01 d0                	add    %edx,%eax
    e0ed:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    e0ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e0f2:	8d 50 02             	lea    0x2(%eax),%edx
    e0f5:	8b 45 08             	mov    0x8(%ebp),%eax
    e0f8:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e0fb:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    e0ff:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    e103:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    e107:	51                   	push   %ecx
    e108:	52                   	push   %edx
    e109:	50                   	push   %eax
    e10a:	e8 e5 f5 ff ff       	call   d6f4 <paethPredictor>
    e10f:	83 c4 0c             	add    $0xc,%esp
    e112:	89 c2                	mov    %eax,%edx
    e114:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    e118:	01 d0                	add    %edx,%eax
    e11a:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    e11c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e11f:	8d 50 03             	lea    0x3(%eax),%edx
    e122:	8b 45 08             	mov    0x8(%ebp),%eax
    e125:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e128:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    e12c:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    e130:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    e134:	51                   	push   %ecx
    e135:	52                   	push   %edx
    e136:	50                   	push   %eax
    e137:	e8 b8 f5 ff ff       	call   d6f4 <paethPredictor>
    e13c:	83 c4 0c             	add    $0xc,%esp
    e13f:	89 c2                	mov    %eax,%edx
    e141:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    e145:	01 d0                	add    %edx,%eax
    e147:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    e149:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    e14d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e150:	83 c0 03             	add    $0x3,%eax
    e153:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e156:	0f 8c 2f fe ff ff    	jl     df8b <unfilterScanline+0x282>
    e15c:	e9 d3 02 00 00       	jmp    e434 <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    e161:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    e165:	0f 8e 6a 01 00 00    	jle    e2d5 <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    e16b:	e9 51 01 00 00       	jmp    e2c1 <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    e170:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e173:	2b 45 14             	sub    0x14(%ebp),%eax
    e176:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    e179:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e17c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e17f:	01 d0                	add    %edx,%eax
    e181:	0f b6 00             	movzbl (%eax),%eax
    e184:	88 45 db             	mov    %al,-0x25(%ebp)
    e187:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e18a:	8d 50 01             	lea    0x1(%eax),%edx
    e18d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e190:	01 d0                	add    %edx,%eax
    e192:	0f b6 00             	movzbl (%eax),%eax
    e195:	88 45 da             	mov    %al,-0x26(%ebp)
    e198:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e19b:	8d 50 02             	lea    0x2(%eax),%edx
    e19e:	8b 45 0c             	mov    0xc(%ebp),%eax
    e1a1:	01 d0                	add    %edx,%eax
    e1a3:	0f b6 00             	movzbl (%eax),%eax
    e1a6:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    e1a9:	8b 55 dc             	mov    -0x24(%ebp),%edx
    e1ac:	8b 45 08             	mov    0x8(%ebp),%eax
    e1af:	01 d0                	add    %edx,%eax
    e1b1:	0f b6 00             	movzbl (%eax),%eax
    e1b4:	88 45 d8             	mov    %al,-0x28(%ebp)
    e1b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e1ba:	8d 50 01             	lea    0x1(%eax),%edx
    e1bd:	8b 45 08             	mov    0x8(%ebp),%eax
    e1c0:	01 d0                	add    %edx,%eax
    e1c2:	0f b6 00             	movzbl (%eax),%eax
    e1c5:	88 45 d7             	mov    %al,-0x29(%ebp)
    e1c8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e1cb:	8d 50 02             	lea    0x2(%eax),%edx
    e1ce:	8b 45 08             	mov    0x8(%ebp),%eax
    e1d1:	01 d0                	add    %edx,%eax
    e1d3:	0f b6 00             	movzbl (%eax),%eax
    e1d6:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    e1d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e1dc:	8b 45 10             	mov    0x10(%ebp),%eax
    e1df:	01 d0                	add    %edx,%eax
    e1e1:	0f b6 00             	movzbl (%eax),%eax
    e1e4:	88 45 d5             	mov    %al,-0x2b(%ebp)
    e1e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1ea:	8d 50 01             	lea    0x1(%eax),%edx
    e1ed:	8b 45 10             	mov    0x10(%ebp),%eax
    e1f0:	01 d0                	add    %edx,%eax
    e1f2:	0f b6 00             	movzbl (%eax),%eax
    e1f5:	88 45 d4             	mov    %al,-0x2c(%ebp)
    e1f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1fb:	8d 50 02             	lea    0x2(%eax),%edx
    e1fe:	8b 45 10             	mov    0x10(%ebp),%eax
    e201:	01 d0                	add    %edx,%eax
    e203:	0f b6 00             	movzbl (%eax),%eax
    e206:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    e209:	8b 55 dc             	mov    -0x24(%ebp),%edx
    e20c:	8b 45 10             	mov    0x10(%ebp),%eax
    e20f:	01 d0                	add    %edx,%eax
    e211:	0f b6 00             	movzbl (%eax),%eax
    e214:	88 45 d2             	mov    %al,-0x2e(%ebp)
    e217:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e21a:	8d 50 01             	lea    0x1(%eax),%edx
    e21d:	8b 45 10             	mov    0x10(%ebp),%eax
    e220:	01 d0                	add    %edx,%eax
    e222:	0f b6 00             	movzbl (%eax),%eax
    e225:	88 45 d1             	mov    %al,-0x2f(%ebp)
    e228:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e22b:	8d 50 02             	lea    0x2(%eax),%edx
    e22e:	8b 45 10             	mov    0x10(%ebp),%eax
    e231:	01 d0                	add    %edx,%eax
    e233:	0f b6 00             	movzbl (%eax),%eax
    e236:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    e239:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e23c:	8b 45 08             	mov    0x8(%ebp),%eax
    e23f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e242:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    e246:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    e24a:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    e24e:	51                   	push   %ecx
    e24f:	52                   	push   %edx
    e250:	50                   	push   %eax
    e251:	e8 9e f4 ff ff       	call   d6f4 <paethPredictor>
    e256:	83 c4 0c             	add    $0xc,%esp
    e259:	89 c2                	mov    %eax,%edx
    e25b:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    e25f:	01 d0                	add    %edx,%eax
    e261:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    e263:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e266:	8d 50 01             	lea    0x1(%eax),%edx
    e269:	8b 45 08             	mov    0x8(%ebp),%eax
    e26c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e26f:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    e273:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    e277:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    e27b:	51                   	push   %ecx
    e27c:	52                   	push   %edx
    e27d:	50                   	push   %eax
    e27e:	e8 71 f4 ff ff       	call   d6f4 <paethPredictor>
    e283:	83 c4 0c             	add    $0xc,%esp
    e286:	89 c2                	mov    %eax,%edx
    e288:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    e28c:	01 d0                	add    %edx,%eax
    e28e:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    e290:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e293:	8d 50 02             	lea    0x2(%eax),%edx
    e296:	8b 45 08             	mov    0x8(%ebp),%eax
    e299:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e29c:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    e2a0:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    e2a4:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    e2a8:	51                   	push   %ecx
    e2a9:	52                   	push   %edx
    e2aa:	50                   	push   %eax
    e2ab:	e8 44 f4 ff ff       	call   d6f4 <paethPredictor>
    e2b0:	83 c4 0c             	add    $0xc,%esp
    e2b3:	89 c2                	mov    %eax,%edx
    e2b5:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    e2b9:	01 d0                	add    %edx,%eax
    e2bb:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    e2bd:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    e2c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e2c4:	83 c0 02             	add    $0x2,%eax
    e2c7:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e2ca:	0f 8c a0 fe ff ff    	jl     e170 <unfilterScanline+0x467>
    e2d0:	e9 5f 01 00 00       	jmp    e434 <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    e2d5:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    e2d9:	0f 8e 55 01 00 00    	jle    e434 <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    e2df:	e9 e0 00 00 00       	jmp    e3c4 <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    e2e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e2e7:	2b 45 14             	sub    0x14(%ebp),%eax
    e2ea:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    e2ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e2f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    e2f3:	01 d0                	add    %edx,%eax
    e2f5:	0f b6 00             	movzbl (%eax),%eax
    e2f8:	88 45 cb             	mov    %al,-0x35(%ebp)
    e2fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e2fe:	8d 50 01             	lea    0x1(%eax),%edx
    e301:	8b 45 0c             	mov    0xc(%ebp),%eax
    e304:	01 d0                	add    %edx,%eax
    e306:	0f b6 00             	movzbl (%eax),%eax
    e309:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    e30c:	8b 55 cc             	mov    -0x34(%ebp),%edx
    e30f:	8b 45 08             	mov    0x8(%ebp),%eax
    e312:	01 d0                	add    %edx,%eax
    e314:	0f b6 00             	movzbl (%eax),%eax
    e317:	88 45 c9             	mov    %al,-0x37(%ebp)
    e31a:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e31d:	8d 50 01             	lea    0x1(%eax),%edx
    e320:	8b 45 08             	mov    0x8(%ebp),%eax
    e323:	01 d0                	add    %edx,%eax
    e325:	0f b6 00             	movzbl (%eax),%eax
    e328:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    e32b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e32e:	8b 45 10             	mov    0x10(%ebp),%eax
    e331:	01 d0                	add    %edx,%eax
    e333:	0f b6 00             	movzbl (%eax),%eax
    e336:	88 45 c7             	mov    %al,-0x39(%ebp)
    e339:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e33c:	8d 50 01             	lea    0x1(%eax),%edx
    e33f:	8b 45 10             	mov    0x10(%ebp),%eax
    e342:	01 d0                	add    %edx,%eax
    e344:	0f b6 00             	movzbl (%eax),%eax
    e347:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    e34a:	8b 55 cc             	mov    -0x34(%ebp),%edx
    e34d:	8b 45 10             	mov    0x10(%ebp),%eax
    e350:	01 d0                	add    %edx,%eax
    e352:	0f b6 00             	movzbl (%eax),%eax
    e355:	88 45 c5             	mov    %al,-0x3b(%ebp)
    e358:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e35b:	8d 50 01             	lea    0x1(%eax),%edx
    e35e:	8b 45 10             	mov    0x10(%ebp),%eax
    e361:	01 d0                	add    %edx,%eax
    e363:	0f b6 00             	movzbl (%eax),%eax
    e366:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    e369:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e36c:	8b 45 08             	mov    0x8(%ebp),%eax
    e36f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e372:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    e376:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    e37a:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    e37e:	51                   	push   %ecx
    e37f:	52                   	push   %edx
    e380:	50                   	push   %eax
    e381:	e8 6e f3 ff ff       	call   d6f4 <paethPredictor>
    e386:	83 c4 0c             	add    $0xc,%esp
    e389:	89 c2                	mov    %eax,%edx
    e38b:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    e38f:	01 d0                	add    %edx,%eax
    e391:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    e393:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e396:	8d 50 01             	lea    0x1(%eax),%edx
    e399:	8b 45 08             	mov    0x8(%ebp),%eax
    e39c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e39f:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    e3a3:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    e3a7:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    e3ab:	51                   	push   %ecx
    e3ac:	52                   	push   %edx
    e3ad:	50                   	push   %eax
    e3ae:	e8 41 f3 ff ff       	call   d6f4 <paethPredictor>
    e3b3:	83 c4 0c             	add    $0xc,%esp
    e3b6:	89 c2                	mov    %eax,%edx
    e3b8:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    e3bc:	01 d0                	add    %edx,%eax
    e3be:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    e3c0:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    e3c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3c7:	83 c0 01             	add    $0x1,%eax
    e3ca:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e3cd:	0f 8c 11 ff ff ff    	jl     e2e4 <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    e3d3:	eb 5f                	jmp    e434 <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    e3d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e3d8:	8b 45 08             	mov    0x8(%ebp),%eax
    e3db:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e3de:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e3e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    e3e4:	01 d0                	add    %edx,%eax
    e3e6:	0f b6 00             	movzbl (%eax),%eax
    e3e9:	88 45 b7             	mov    %al,-0x49(%ebp)
    e3ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3ef:	2b 45 14             	sub    0x14(%ebp),%eax
    e3f2:	89 c2                	mov    %eax,%edx
    e3f4:	8b 45 10             	mov    0x10(%ebp),%eax
    e3f7:	01 d0                	add    %edx,%eax
    e3f9:	0f b6 00             	movzbl (%eax),%eax
    e3fc:	0f b6 c8             	movzbl %al,%ecx
    e3ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e402:	8b 45 10             	mov    0x10(%ebp),%eax
    e405:	01 d0                	add    %edx,%eax
    e407:	0f b6 00             	movzbl (%eax),%eax
    e40a:	0f b6 d0             	movzbl %al,%edx
    e40d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e410:	2b 45 14             	sub    0x14(%ebp),%eax
    e413:	89 c6                	mov    %eax,%esi
    e415:	8b 45 08             	mov    0x8(%ebp),%eax
    e418:	01 f0                	add    %esi,%eax
    e41a:	0f b6 00             	movzbl (%eax),%eax
    e41d:	0f b6 c0             	movzbl %al,%eax
    e420:	51                   	push   %ecx
    e421:	52                   	push   %edx
    e422:	50                   	push   %eax
    e423:	e8 cc f2 ff ff       	call   d6f4 <paethPredictor>
    e428:	83 c4 0c             	add    $0xc,%esp
    e42b:	02 45 b7             	add    -0x49(%ebp),%al
    e42e:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    e430:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e434:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e437:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e43a:	75 99                	jne    e3d5 <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    e43c:	eb 6e                	jmp    e4ac <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    e43e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e445:	eb 19                	jmp    e460 <unfilterScanline+0x757>
          recon[i] = scanline[i];
    e447:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e44a:	8b 45 08             	mov    0x8(%ebp),%eax
    e44d:	01 c2                	add    %eax,%edx
    e44f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e452:	8b 45 0c             	mov    0xc(%ebp),%eax
    e455:	01 c8                	add    %ecx,%eax
    e457:	0f b6 00             	movzbl (%eax),%eax
    e45a:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    e45c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e460:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e463:	3b 45 14             	cmp    0x14(%ebp),%eax
    e466:	75 df                	jne    e447 <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    e468:	8b 45 14             	mov    0x14(%ebp),%eax
    e46b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e46e:	eb 2b                	jmp    e49b <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    e470:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e473:	8b 45 08             	mov    0x8(%ebp),%eax
    e476:	01 c2                	add    %eax,%edx
    e478:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e47b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e47e:	01 c8                	add    %ecx,%eax
    e480:	0f b6 08             	movzbl (%eax),%ecx
    e483:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e486:	2b 45 14             	sub    0x14(%ebp),%eax
    e489:	89 c3                	mov    %eax,%ebx
    e48b:	8b 45 08             	mov    0x8(%ebp),%eax
    e48e:	01 d8                	add    %ebx,%eax
    e490:	0f b6 00             	movzbl (%eax),%eax
    e493:	01 c8                	add    %ecx,%eax
    e495:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    e497:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e49b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e49e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e4a1:	7c cd                	jl     e470 <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    e4a3:	eb 07                	jmp    e4ac <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    e4a5:	b8 24 00 00 00       	mov    $0x24,%eax
    e4aa:	eb 05                	jmp    e4b1 <unfilterScanline+0x7a8>
  }
  return 0;
    e4ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e4b1:	8d 65 f8             	lea    -0x8(%ebp),%esp
    e4b4:	5b                   	pop    %ebx
    e4b5:	5e                   	pop    %esi
    e4b6:	5d                   	pop    %ebp
    e4b7:	c3                   	ret    

0000e4b8 <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    e4b8:	55                   	push   %ebp
    e4b9:	89 e5                	mov    %esp,%ebp
    e4bb:	53                   	push   %ebx
    e4bc:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    e4bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    e4c6:	8b 45 18             	mov    0x18(%ebp),%eax
    e4c9:	83 c0 07             	add    $0x7,%eax
    e4cc:	c1 e8 03             	shr    $0x3,%eax
    e4cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    e4d2:	ff 75 18             	pushl  0x18(%ebp)
    e4d5:	6a 01                	push   $0x1
    e4d7:	ff 75 10             	pushl  0x10(%ebp)
    e4da:	e8 d9 b1 ff ff       	call   96b8 <lodepng_get_raw_size_idat>
    e4df:	83 c4 0c             	add    $0xc,%esp
    e4e2:	83 e8 01             	sub    $0x1,%eax
    e4e5:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    e4e8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e4ef:	eb 6d                	jmp    e55e <unfilter+0xa6>
    size_t outindex = linebytes * y;
    e4f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e4f4:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e4f8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    e4fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e4fe:	83 c0 01             	add    $0x1,%eax
    e501:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e505:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    e508:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e50b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e50e:	01 d0                	add    %edx,%eax
    e510:	0f b6 00             	movzbl (%eax),%eax
    e513:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    e516:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    e51a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e51d:	8d 4a 01             	lea    0x1(%edx),%ecx
    e520:	8b 55 0c             	mov    0xc(%ebp),%edx
    e523:	01 d1                	add    %edx,%ecx
    e525:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    e528:	8b 55 08             	mov    0x8(%ebp),%edx
    e52b:	01 da                	add    %ebx,%edx
    e52d:	ff 75 ec             	pushl  -0x14(%ebp)
    e530:	50                   	push   %eax
    e531:	ff 75 f0             	pushl  -0x10(%ebp)
    e534:	ff 75 f4             	pushl  -0xc(%ebp)
    e537:	51                   	push   %ecx
    e538:	52                   	push   %edx
    e539:	e8 cb f7 ff ff       	call   dd09 <unfilterScanline>
    e53e:	83 c4 18             	add    $0x18,%esp
    e541:	89 45 dc             	mov    %eax,-0x24(%ebp)
    e544:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    e548:	74 05                	je     e54f <unfilter+0x97>
    e54a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e54d:	eb 1c                	jmp    e56b <unfilter+0xb3>

    prevline = &out[outindex];
    e54f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e552:	8b 45 08             	mov    0x8(%ebp),%eax
    e555:	01 d0                	add    %edx,%eax
    e557:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    e55a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e55e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e561:	3b 45 14             	cmp    0x14(%ebp),%eax
    e564:	72 8b                	jb     e4f1 <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    e566:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e56b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    e56e:	c9                   	leave  
    e56f:	c3                   	ret    

0000e570 <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    e570:	55                   	push   %ebp
    e571:	89 e5                	mov    %esp,%ebp
    e573:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e579:	ff 75 18             	pushl  0x18(%ebp)
    e57c:	ff 75 14             	pushl  0x14(%ebp)
    e57f:	ff 75 10             	pushl  0x10(%ebp)
    e582:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    e588:	50                   	push   %eax
    e589:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    e58f:	50                   	push   %eax
    e590:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    e596:	50                   	push   %eax
    e597:	8d 45 94             	lea    -0x6c(%ebp),%eax
    e59a:	50                   	push   %eax
    e59b:	8d 45 b0             	lea    -0x50(%ebp),%eax
    e59e:	50                   	push   %eax
    e59f:	e8 e6 f1 ff ff       	call   d78a <Adam7_getpassvalues>
    e5a4:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    e5a7:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    e5ab:	0f 86 0a 01 00 00    	jbe    e6bb <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    e5b1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e5b8:	e9 ef 00 00 00       	jmp    e6ac <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    e5bd:	8b 45 18             	mov    0x18(%ebp),%eax
    e5c0:	c1 e8 03             	shr    $0x3,%eax
    e5c3:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    e5c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e5cd:	e9 c6 00 00 00       	jmp    e698 <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    e5d2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e5d9:	e9 a6 00 00 00       	jmp    e684 <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    e5de:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e5e1:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e5e8:	89 c1                	mov    %eax,%ecx
    e5ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e5ed:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e5f1:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e5f5:	89 c2                	mov    %eax,%edx
    e5f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e5fa:	01 c2                	add    %eax,%edx
    e5fc:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e5ff:	0f af c2             	imul   %edx,%eax
    e602:	01 c8                	add    %ecx,%eax
    e604:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    e607:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e60a:	8b 14 85 38 a7 01 00 	mov    0x1a738(,%eax,4),%edx
    e611:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e614:	8b 04 85 70 a7 01 00 	mov    0x1a770(,%eax,4),%eax
    e61b:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e61f:	01 d0                	add    %edx,%eax
    e621:	0f af 45 10          	imul   0x10(%ebp),%eax
    e625:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    e627:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e62a:	8b 04 85 54 a7 01 00 	mov    0x1a754(,%eax,4),%eax
    e631:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e635:	01 c2                	add    %eax,%edx
    e637:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e63a:	8b 04 85 1c a7 01 00 	mov    0x1a71c(,%eax,4),%eax
    e641:	01 c2                	add    %eax,%edx
    e643:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e646:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    e649:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e64c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e653:	eb 23                	jmp    e678 <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    e655:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e658:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e65b:	01 c2                	add    %eax,%edx
    e65d:	8b 45 08             	mov    0x8(%ebp),%eax
    e660:	01 c2                	add    %eax,%edx
    e662:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    e665:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e668:	01 c1                	add    %eax,%ecx
    e66a:	8b 45 0c             	mov    0xc(%ebp),%eax
    e66d:	01 c8                	add    %ecx,%eax
    e66f:	0f b6 00             	movzbl (%eax),%eax
    e672:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e674:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e678:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e67b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e67e:	72 d5                	jb     e655 <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e680:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e684:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e687:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e68b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    e68e:	0f 87 4a ff ff ff    	ja     e5de <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    e694:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e698:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e69b:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e69f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    e6a2:	0f 87 2a ff ff ff    	ja     e5d2 <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    e6a8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e6ac:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e6b0:	0f 85 07 ff ff ff    	jne    e5bd <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e6b6:	e9 22 01 00 00       	jmp    e7dd <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e6bb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e6c2:	e9 0c 01 00 00       	jmp    e7d3 <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    e6c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e6ca:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e6ce:	0f af 45 18          	imul   0x18(%ebp),%eax
    e6d2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    e6d5:	8b 45 18             	mov    0x18(%ebp),%eax
    e6d8:	0f af 45 10          	imul   0x10(%ebp),%eax
    e6dc:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e6df:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    e6e6:	e9 d4 00 00 00       	jmp    e7bf <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    e6eb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e6f2:	e9 b4 00 00 00       	jmp    e7ab <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    e6f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e6fa:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e701:	c1 e0 03             	shl    $0x3,%eax
    e704:	89 c1                	mov    %eax,%ecx
    e706:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e709:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    e70d:	89 c2                	mov    %eax,%edx
    e70f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e712:	0f af 45 18          	imul   0x18(%ebp),%eax
    e716:	01 d0                	add    %edx,%eax
    e718:	01 c8                	add    %ecx,%eax
    e71a:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    e720:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e723:	8b 14 85 38 a7 01 00 	mov    0x1a738(,%eax,4),%edx
    e72a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e72d:	8b 04 85 70 a7 01 00 	mov    0x1a770(,%eax,4),%eax
    e734:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    e738:	01 d0                	add    %edx,%eax
    e73a:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    e73e:	89 c2                	mov    %eax,%edx
    e740:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e743:	8b 0c 85 1c a7 01 00 	mov    0x1a71c(,%eax,4),%ecx
    e74a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e74d:	8b 04 85 54 a7 01 00 	mov    0x1a754(,%eax,4),%eax
    e754:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e758:	01 c8                	add    %ecx,%eax
    e75a:	0f af 45 18          	imul   0x18(%ebp),%eax
    e75e:	01 d0                	add    %edx,%eax
    e760:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e766:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e76d:	eb 30                	jmp    e79f <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e76f:	ff 75 0c             	pushl  0xc(%ebp)
    e772:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e778:	50                   	push   %eax
    e779:	e8 1e a1 ff ff       	call   889c <readBitFromReversedStream>
    e77e:	83 c4 08             	add    $0x8,%esp
    e781:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e784:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e788:	50                   	push   %eax
    e789:	ff 75 08             	pushl  0x8(%ebp)
    e78c:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e792:	50                   	push   %eax
    e793:	e8 86 a1 ff ff       	call   891e <setBitOfReversedStream>
    e798:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e79b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e79f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e7a2:	3b 45 18             	cmp    0x18(%ebp),%eax
    e7a5:	72 c8                	jb     e76f <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e7a7:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e7ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e7ae:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e7b2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e7b5:	0f 87 3c ff ff ff    	ja     e6f7 <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e7bb:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e7bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e7c2:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e7c6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e7c9:	0f 87 1c ff ff ff    	ja     e6eb <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e7cf:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e7d3:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e7d7:	0f 85 ea fe ff ff    	jne    e6c7 <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e7dd:	90                   	nop
    e7de:	c9                   	leave  
    e7df:	c3                   	ret    

0000e7e0 <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e7e0:	55                   	push   %ebp
    e7e1:	89 e5                	mov    %esp,%ebp
    e7e3:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e7e6:	8b 45 14             	mov    0x14(%ebp),%eax
    e7e9:	2b 45 10             	sub    0x10(%ebp),%eax
    e7ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e7ef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e7f6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e7fd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e804:	eb 4a                	jmp    e850 <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e806:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e80d:	eb 2a                	jmp    e839 <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e80f:	ff 75 0c             	pushl  0xc(%ebp)
    e812:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e815:	50                   	push   %eax
    e816:	e8 81 a0 ff ff       	call   889c <readBitFromReversedStream>
    e81b:	83 c4 08             	add    $0x8,%esp
    e81e:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e821:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e825:	50                   	push   %eax
    e826:	ff 75 08             	pushl  0x8(%ebp)
    e829:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e82c:	50                   	push   %eax
    e82d:	e8 ec a0 ff ff       	call   891e <setBitOfReversedStream>
    e832:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e835:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e839:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e83c:	3b 45 10             	cmp    0x10(%ebp),%eax
    e83f:	7c ce                	jl     e80f <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e841:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e844:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e847:	01 d0                	add    %edx,%eax
    e849:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e84c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e850:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e853:	3b 45 18             	cmp    0x18(%ebp),%eax
    e856:	72 ae                	jb     e806 <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e858:	90                   	nop
    e859:	c9                   	leave  
    e85a:	c3                   	ret    

0000e85b <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e85b:	55                   	push   %ebp
    e85c:	89 e5                	mov    %esp,%ebp
    e85e:	57                   	push   %edi
    e85f:	56                   	push   %esi
    e860:	53                   	push   %ebx
    e861:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e867:	8b 45 18             	mov    0x18(%ebp),%eax
    e86a:	83 c0 0c             	add    $0xc,%eax
    e86d:	50                   	push   %eax
    e86e:	e8 e6 ac ff ff       	call   9559 <lodepng_get_bpp>
    e873:	83 c4 04             	add    $0x4,%esp
    e876:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e879:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e87d:	75 0a                	jne    e889 <postProcessScanlines+0x2e>
    e87f:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e884:	e9 c3 01 00 00       	jmp    ea4c <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e889:	8b 45 18             	mov    0x18(%ebp),%eax
    e88c:	8b 40 08             	mov    0x8(%eax),%eax
    e88f:	85 c0                	test   %eax,%eax
    e891:	0f 85 a8 00 00 00    	jne    e93f <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e897:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e89b:	77 76                	ja     e913 <postProcessScanlines+0xb8>
    e89d:	8b 45 10             	mov    0x10(%ebp),%eax
    e8a0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e8a4:	89 c2                	mov    %eax,%edx
    e8a6:	8b 45 10             	mov    0x10(%ebp),%eax
    e8a9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e8ad:	83 c0 07             	add    $0x7,%eax
    e8b0:	c1 e8 03             	shr    $0x3,%eax
    e8b3:	c1 e0 03             	shl    $0x3,%eax
    e8b6:	39 c2                	cmp    %eax,%edx
    e8b8:	74 59                	je     e913 <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e8ba:	ff 75 ec             	pushl  -0x14(%ebp)
    e8bd:	ff 75 14             	pushl  0x14(%ebp)
    e8c0:	ff 75 10             	pushl  0x10(%ebp)
    e8c3:	ff 75 0c             	pushl  0xc(%ebp)
    e8c6:	ff 75 0c             	pushl  0xc(%ebp)
    e8c9:	e8 ea fb ff ff       	call   e4b8 <unfilter>
    e8ce:	83 c4 14             	add    $0x14,%esp
    e8d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e8d4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e8d8:	74 08                	je     e8e2 <postProcessScanlines+0x87>
    e8da:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e8dd:	e9 6a 01 00 00       	jmp    ea4c <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e8e2:	8b 45 10             	mov    0x10(%ebp),%eax
    e8e5:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e8e9:	83 c0 07             	add    $0x7,%eax
    e8ec:	c1 e8 03             	shr    $0x3,%eax
    e8ef:	c1 e0 03             	shl    $0x3,%eax
    e8f2:	89 c2                	mov    %eax,%edx
    e8f4:	8b 45 10             	mov    0x10(%ebp),%eax
    e8f7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e8fb:	ff 75 14             	pushl  0x14(%ebp)
    e8fe:	52                   	push   %edx
    e8ff:	50                   	push   %eax
    e900:	ff 75 0c             	pushl  0xc(%ebp)
    e903:	ff 75 08             	pushl  0x8(%ebp)
    e906:	e8 d5 fe ff ff       	call   e7e0 <removePaddingBits>
    e90b:	83 c4 14             	add    $0x14,%esp
    e90e:	e9 34 01 00 00       	jmp    ea47 <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e913:	ff 75 ec             	pushl  -0x14(%ebp)
    e916:	ff 75 14             	pushl  0x14(%ebp)
    e919:	ff 75 10             	pushl  0x10(%ebp)
    e91c:	ff 75 0c             	pushl  0xc(%ebp)
    e91f:	ff 75 08             	pushl  0x8(%ebp)
    e922:	e8 91 fb ff ff       	call   e4b8 <unfilter>
    e927:	83 c4 14             	add    $0x14,%esp
    e92a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e92d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e931:	0f 84 10 01 00 00    	je     ea47 <postProcessScanlines+0x1ec>
    e937:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e93a:	e9 0d 01 00 00       	jmp    ea4c <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e93f:	ff 75 ec             	pushl  -0x14(%ebp)
    e942:	ff 75 14             	pushl  0x14(%ebp)
    e945:	ff 75 10             	pushl  0x10(%ebp)
    e948:	8d 45 88             	lea    -0x78(%ebp),%eax
    e94b:	50                   	push   %eax
    e94c:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e952:	50                   	push   %eax
    e953:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e959:	50                   	push   %eax
    e95a:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e95d:	50                   	push   %eax
    e95e:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e961:	50                   	push   %eax
    e962:	e8 23 ee ff ff       	call   d78a <Adam7_getpassvalues>
    e967:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e96a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e971:	e9 b0 00 00 00       	jmp    ea26 <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e976:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e979:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e97d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e980:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e984:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e987:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e98e:	89 cb                	mov    %ecx,%ebx
    e990:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e993:	01 cb                	add    %ecx,%ebx
    e995:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e998:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e99f:	89 ce                	mov    %ecx,%esi
    e9a1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e9a4:	01 f1                	add    %esi,%ecx
    e9a6:	ff 75 ec             	pushl  -0x14(%ebp)
    e9a9:	52                   	push   %edx
    e9aa:	50                   	push   %eax
    e9ab:	53                   	push   %ebx
    e9ac:	51                   	push   %ecx
    e9ad:	e8 06 fb ff ff       	call   e4b8 <unfilter>
    e9b2:	83 c4 14             	add    $0x14,%esp
    e9b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e9b8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e9bc:	74 08                	je     e9c6 <postProcessScanlines+0x16b>
    e9be:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e9c1:	e9 86 00 00 00       	jmp    ea4c <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e9c6:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e9ca:	77 56                	ja     ea22 <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e9cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9cf:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e9d3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e9d6:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e9da:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e9de:	83 c2 07             	add    $0x7,%edx
    e9e1:	c1 ea 03             	shr    $0x3,%edx
    e9e4:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e9e7:	89 d6                	mov    %edx,%esi
    e9e9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e9ec:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e9f0:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e9f4:	89 d3                	mov    %edx,%ebx
    e9f6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e9f9:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    ea00:	89 d1                	mov    %edx,%ecx
    ea02:	8b 55 0c             	mov    0xc(%ebp),%edx
    ea05:	01 d1                	add    %edx,%ecx
    ea07:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ea0a:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    ea0e:	89 d7                	mov    %edx,%edi
    ea10:	8b 55 0c             	mov    0xc(%ebp),%edx
    ea13:	01 fa                	add    %edi,%edx
    ea15:	50                   	push   %eax
    ea16:	56                   	push   %esi
    ea17:	53                   	push   %ebx
    ea18:	51                   	push   %ecx
    ea19:	52                   	push   %edx
    ea1a:	e8 c1 fd ff ff       	call   e7e0 <removePaddingBits>
    ea1f:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    ea22:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ea26:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    ea2a:	0f 85 46 ff ff ff    	jne    e976 <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    ea30:	ff 75 ec             	pushl  -0x14(%ebp)
    ea33:	ff 75 14             	pushl  0x14(%ebp)
    ea36:	ff 75 10             	pushl  0x10(%ebp)
    ea39:	ff 75 0c             	pushl  0xc(%ebp)
    ea3c:	ff 75 08             	pushl  0x8(%ebp)
    ea3f:	e8 2c fb ff ff       	call   e570 <Adam7_deinterlace>
    ea44:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    ea47:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ea4c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    ea4f:	5b                   	pop    %ebx
    ea50:	5e                   	pop    %esi
    ea51:	5f                   	pop    %edi
    ea52:	5d                   	pop    %ebp
    ea53:	c3                   	ret    

0000ea54 <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    ea54:	55                   	push   %ebp
    ea55:	89 e5                	mov    %esp,%ebp
    ea57:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    ea5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    ea61:	8b 45 10             	mov    0x10(%ebp),%eax
    ea64:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    ea69:	f7 e2                	mul    %edx
    ea6b:	89 d0                	mov    %edx,%eax
    ea6d:	d1 e8                	shr    %eax
    ea6f:	89 c2                	mov    %eax,%edx
    ea71:	8b 45 08             	mov    0x8(%ebp),%eax
    ea74:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    ea77:	8b 45 08             	mov    0x8(%ebp),%eax
    ea7a:	8b 40 0c             	mov    0xc(%eax),%eax
    ea7d:	85 c0                	test   %eax,%eax
    ea7f:	74 0d                	je     ea8e <readChunk_PLTE+0x3a>
    ea81:	8b 45 08             	mov    0x8(%ebp),%eax
    ea84:	8b 40 0c             	mov    0xc(%eax),%eax
    ea87:	3d 00 01 00 00       	cmp    $0x100,%eax
    ea8c:	7e 0a                	jle    ea98 <readChunk_PLTE+0x44>
    ea8e:	b8 26 00 00 00       	mov    $0x26,%eax
    ea93:	e9 da 00 00 00       	jmp    eb72 <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    ea98:	83 ec 0c             	sub    $0xc,%esp
    ea9b:	ff 75 08             	pushl  0x8(%ebp)
    ea9e:	e8 02 a7 ff ff       	call   91a5 <lodepng_color_mode_alloc_palette>
    eaa3:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    eaa6:	8b 45 08             	mov    0x8(%ebp),%eax
    eaa9:	8b 40 08             	mov    0x8(%eax),%eax
    eaac:	85 c0                	test   %eax,%eax
    eaae:	75 1e                	jne    eace <readChunk_PLTE+0x7a>
    eab0:	8b 45 08             	mov    0x8(%ebp),%eax
    eab3:	8b 40 0c             	mov    0xc(%eax),%eax
    eab6:	85 c0                	test   %eax,%eax
    eab8:	74 14                	je     eace <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    eaba:	8b 45 08             	mov    0x8(%ebp),%eax
    eabd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    eac4:	b8 53 00 00 00       	mov    $0x53,%eax
    eac9:	e9 a4 00 00 00       	jmp    eb72 <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    eace:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ead5:	e9 84 00 00 00       	jmp    eb5e <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    eada:	8b 45 08             	mov    0x8(%ebp),%eax
    eadd:	8b 40 08             	mov    0x8(%eax),%eax
    eae0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    eae3:	c1 e2 02             	shl    $0x2,%edx
    eae6:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    eae9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eaec:	8d 50 01             	lea    0x1(%eax),%edx
    eaef:	89 55 f4             	mov    %edx,-0xc(%ebp)
    eaf2:	8b 55 0c             	mov    0xc(%ebp),%edx
    eaf5:	01 d0                	add    %edx,%eax
    eaf7:	0f b6 00             	movzbl (%eax),%eax
    eafa:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    eafc:	8b 45 08             	mov    0x8(%ebp),%eax
    eaff:	8b 40 08             	mov    0x8(%eax),%eax
    eb02:	8b 55 f0             	mov    -0x10(%ebp),%edx
    eb05:	c1 e2 02             	shl    $0x2,%edx
    eb08:	83 c2 01             	add    $0x1,%edx
    eb0b:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    eb0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eb11:	8d 50 01             	lea    0x1(%eax),%edx
    eb14:	89 55 f4             	mov    %edx,-0xc(%ebp)
    eb17:	8b 55 0c             	mov    0xc(%ebp),%edx
    eb1a:	01 d0                	add    %edx,%eax
    eb1c:	0f b6 00             	movzbl (%eax),%eax
    eb1f:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    eb21:	8b 45 08             	mov    0x8(%ebp),%eax
    eb24:	8b 40 08             	mov    0x8(%eax),%eax
    eb27:	8b 55 f0             	mov    -0x10(%ebp),%edx
    eb2a:	c1 e2 02             	shl    $0x2,%edx
    eb2d:	83 c2 02             	add    $0x2,%edx
    eb30:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    eb33:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eb36:	8d 50 01             	lea    0x1(%eax),%edx
    eb39:	89 55 f4             	mov    %edx,-0xc(%ebp)
    eb3c:	8b 55 0c             	mov    0xc(%ebp),%edx
    eb3f:	01 d0                	add    %edx,%eax
    eb41:	0f b6 00             	movzbl (%eax),%eax
    eb44:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    eb46:	8b 45 08             	mov    0x8(%ebp),%eax
    eb49:	8b 40 08             	mov    0x8(%eax),%eax
    eb4c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    eb4f:	c1 e2 02             	shl    $0x2,%edx
    eb52:	83 c2 03             	add    $0x3,%edx
    eb55:	01 d0                	add    %edx,%eax
    eb57:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    eb5a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    eb5e:	8b 45 08             	mov    0x8(%ebp),%eax
    eb61:	8b 40 0c             	mov    0xc(%eax),%eax
    eb64:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    eb67:	0f 85 6d ff ff ff    	jne    eada <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    eb6d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    eb72:	c9                   	leave  
    eb73:	c3                   	ret    

0000eb74 <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    eb74:	55                   	push   %ebp
    eb75:	89 e5                	mov    %esp,%ebp
    eb77:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    eb7a:	8b 45 08             	mov    0x8(%ebp),%eax
    eb7d:	8b 00                	mov    (%eax),%eax
    eb7f:	83 f8 03             	cmp    $0x3,%eax
    eb82:	75 4d                	jne    ebd1 <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    eb84:	8b 45 08             	mov    0x8(%ebp),%eax
    eb87:	8b 40 0c             	mov    0xc(%eax),%eax
    eb8a:	3b 45 10             	cmp    0x10(%ebp),%eax
    eb8d:	7d 0a                	jge    eb99 <readChunk_tRNS+0x25>
    eb8f:	b8 27 00 00 00       	mov    $0x27,%eax
    eb94:	e9 3c 01 00 00       	jmp    ecd5 <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    eb99:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    eba0:	eb 22                	jmp    ebc4 <readChunk_tRNS+0x50>
    eba2:	8b 45 08             	mov    0x8(%ebp),%eax
    eba5:	8b 40 08             	mov    0x8(%eax),%eax
    eba8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ebab:	c1 e2 02             	shl    $0x2,%edx
    ebae:	83 c2 03             	add    $0x3,%edx
    ebb1:	01 c2                	add    %eax,%edx
    ebb3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    ebb6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ebb9:	01 c8                	add    %ecx,%eax
    ebbb:	0f b6 00             	movzbl (%eax),%eax
    ebbe:	88 02                	mov    %al,(%edx)
    ebc0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    ebc4:	8b 45 10             	mov    0x10(%ebp),%eax
    ebc7:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    ebca:	75 d6                	jne    eba2 <readChunk_tRNS+0x2e>
    ebcc:	e9 ff 00 00 00       	jmp    ecd0 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    ebd1:	8b 45 08             	mov    0x8(%ebp),%eax
    ebd4:	8b 00                	mov    (%eax),%eax
    ebd6:	85 c0                	test   %eax,%eax
    ebd8:	75 59                	jne    ec33 <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    ebda:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    ebde:	74 0a                	je     ebea <readChunk_tRNS+0x76>
    ebe0:	b8 1e 00 00 00       	mov    $0x1e,%eax
    ebe5:	e9 eb 00 00 00       	jmp    ecd5 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    ebea:	8b 45 08             	mov    0x8(%ebp),%eax
    ebed:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    ebf4:	8b 45 0c             	mov    0xc(%ebp),%eax
    ebf7:	0f b6 00             	movzbl (%eax),%eax
    ebfa:	0f b6 c0             	movzbl %al,%eax
    ebfd:	c1 e0 08             	shl    $0x8,%eax
    ec00:	89 c2                	mov    %eax,%edx
    ec02:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec05:	83 c0 01             	add    $0x1,%eax
    ec08:	0f b6 00             	movzbl (%eax),%eax
    ec0b:	0f b6 c0             	movzbl %al,%eax
    ec0e:	01 c2                	add    %eax,%edx
    ec10:	8b 45 08             	mov    0x8(%ebp),%eax
    ec13:	89 50 1c             	mov    %edx,0x1c(%eax)
    ec16:	8b 45 08             	mov    0x8(%ebp),%eax
    ec19:	8b 50 1c             	mov    0x1c(%eax),%edx
    ec1c:	8b 45 08             	mov    0x8(%ebp),%eax
    ec1f:	89 50 18             	mov    %edx,0x18(%eax)
    ec22:	8b 45 08             	mov    0x8(%ebp),%eax
    ec25:	8b 50 18             	mov    0x18(%eax),%edx
    ec28:	8b 45 08             	mov    0x8(%ebp),%eax
    ec2b:	89 50 14             	mov    %edx,0x14(%eax)
    ec2e:	e9 9d 00 00 00       	jmp    ecd0 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    ec33:	8b 45 08             	mov    0x8(%ebp),%eax
    ec36:	8b 00                	mov    (%eax),%eax
    ec38:	83 f8 02             	cmp    $0x2,%eax
    ec3b:	0f 85 88 00 00 00    	jne    ecc9 <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    ec41:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    ec45:	74 0a                	je     ec51 <readChunk_tRNS+0xdd>
    ec47:	b8 29 00 00 00       	mov    $0x29,%eax
    ec4c:	e9 84 00 00 00       	jmp    ecd5 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    ec51:	8b 45 08             	mov    0x8(%ebp),%eax
    ec54:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    ec5b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec5e:	0f b6 00             	movzbl (%eax),%eax
    ec61:	0f b6 c0             	movzbl %al,%eax
    ec64:	c1 e0 08             	shl    $0x8,%eax
    ec67:	89 c2                	mov    %eax,%edx
    ec69:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec6c:	83 c0 01             	add    $0x1,%eax
    ec6f:	0f b6 00             	movzbl (%eax),%eax
    ec72:	0f b6 c0             	movzbl %al,%eax
    ec75:	01 c2                	add    %eax,%edx
    ec77:	8b 45 08             	mov    0x8(%ebp),%eax
    ec7a:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    ec7d:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec80:	83 c0 02             	add    $0x2,%eax
    ec83:	0f b6 00             	movzbl (%eax),%eax
    ec86:	0f b6 c0             	movzbl %al,%eax
    ec89:	c1 e0 08             	shl    $0x8,%eax
    ec8c:	89 c2                	mov    %eax,%edx
    ec8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec91:	83 c0 03             	add    $0x3,%eax
    ec94:	0f b6 00             	movzbl (%eax),%eax
    ec97:	0f b6 c0             	movzbl %al,%eax
    ec9a:	01 c2                	add    %eax,%edx
    ec9c:	8b 45 08             	mov    0x8(%ebp),%eax
    ec9f:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    eca2:	8b 45 0c             	mov    0xc(%ebp),%eax
    eca5:	83 c0 04             	add    $0x4,%eax
    eca8:	0f b6 00             	movzbl (%eax),%eax
    ecab:	0f b6 c0             	movzbl %al,%eax
    ecae:	c1 e0 08             	shl    $0x8,%eax
    ecb1:	89 c2                	mov    %eax,%edx
    ecb3:	8b 45 0c             	mov    0xc(%ebp),%eax
    ecb6:	83 c0 05             	add    $0x5,%eax
    ecb9:	0f b6 00             	movzbl (%eax),%eax
    ecbc:	0f b6 c0             	movzbl %al,%eax
    ecbf:	01 c2                	add    %eax,%edx
    ecc1:	8b 45 08             	mov    0x8(%ebp),%eax
    ecc4:	89 50 1c             	mov    %edx,0x1c(%eax)
    ecc7:	eb 07                	jmp    ecd0 <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    ecc9:	b8 2a 00 00 00       	mov    $0x2a,%eax
    ecce:	eb 05                	jmp    ecd5 <readChunk_tRNS+0x161>

  return 0; /* OK */
    ecd0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ecd5:	c9                   	leave  
    ecd6:	c3                   	ret    

0000ecd7 <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ecd7:	55                   	push   %ebp
    ecd8:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    ecda:	8b 45 08             	mov    0x8(%ebp),%eax
    ecdd:	8b 40 0c             	mov    0xc(%eax),%eax
    ece0:	83 f8 03             	cmp    $0x3,%eax
    ece3:	75 63                	jne    ed48 <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    ece5:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    ece9:	74 0a                	je     ecf5 <readChunk_bKGD+0x1e>
    eceb:	b8 2b 00 00 00       	mov    $0x2b,%eax
    ecf0:	e9 63 01 00 00       	jmp    ee58 <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    ecf5:	8b 45 0c             	mov    0xc(%ebp),%eax
    ecf8:	0f b6 00             	movzbl (%eax),%eax
    ecfb:	0f b6 d0             	movzbl %al,%edx
    ecfe:	8b 45 08             	mov    0x8(%ebp),%eax
    ed01:	8b 40 18             	mov    0x18(%eax),%eax
    ed04:	39 c2                	cmp    %eax,%edx
    ed06:	7c 0a                	jl     ed12 <readChunk_bKGD+0x3b>
    ed08:	b8 67 00 00 00       	mov    $0x67,%eax
    ed0d:	e9 46 01 00 00       	jmp    ee58 <readChunk_bKGD+0x181>

    info->background_defined = 1;
    ed12:	8b 45 08             	mov    0x8(%ebp),%eax
    ed15:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    ed1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed1f:	0f b6 00             	movzbl (%eax),%eax
    ed22:	0f b6 d0             	movzbl %al,%edx
    ed25:	8b 45 08             	mov    0x8(%ebp),%eax
    ed28:	89 50 38             	mov    %edx,0x38(%eax)
    ed2b:	8b 45 08             	mov    0x8(%ebp),%eax
    ed2e:	8b 50 38             	mov    0x38(%eax),%edx
    ed31:	8b 45 08             	mov    0x8(%ebp),%eax
    ed34:	89 50 34             	mov    %edx,0x34(%eax)
    ed37:	8b 45 08             	mov    0x8(%ebp),%eax
    ed3a:	8b 50 34             	mov    0x34(%eax),%edx
    ed3d:	8b 45 08             	mov    0x8(%ebp),%eax
    ed40:	89 50 30             	mov    %edx,0x30(%eax)
    ed43:	e9 0b 01 00 00       	jmp    ee53 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    ed48:	8b 45 08             	mov    0x8(%ebp),%eax
    ed4b:	8b 40 0c             	mov    0xc(%eax),%eax
    ed4e:	85 c0                	test   %eax,%eax
    ed50:	74 0b                	je     ed5d <readChunk_bKGD+0x86>
    ed52:	8b 45 08             	mov    0x8(%ebp),%eax
    ed55:	8b 40 0c             	mov    0xc(%eax),%eax
    ed58:	83 f8 04             	cmp    $0x4,%eax
    ed5b:	75 59                	jne    edb6 <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    ed5d:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    ed61:	74 0a                	je     ed6d <readChunk_bKGD+0x96>
    ed63:	b8 2c 00 00 00       	mov    $0x2c,%eax
    ed68:	e9 eb 00 00 00       	jmp    ee58 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    ed6d:	8b 45 08             	mov    0x8(%ebp),%eax
    ed70:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    ed77:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed7a:	0f b6 00             	movzbl (%eax),%eax
    ed7d:	0f b6 c0             	movzbl %al,%eax
    ed80:	c1 e0 08             	shl    $0x8,%eax
    ed83:	89 c2                	mov    %eax,%edx
    ed85:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed88:	83 c0 01             	add    $0x1,%eax
    ed8b:	0f b6 00             	movzbl (%eax),%eax
    ed8e:	0f b6 c0             	movzbl %al,%eax
    ed91:	01 c2                	add    %eax,%edx
    ed93:	8b 45 08             	mov    0x8(%ebp),%eax
    ed96:	89 50 38             	mov    %edx,0x38(%eax)
    ed99:	8b 45 08             	mov    0x8(%ebp),%eax
    ed9c:	8b 50 38             	mov    0x38(%eax),%edx
    ed9f:	8b 45 08             	mov    0x8(%ebp),%eax
    eda2:	89 50 34             	mov    %edx,0x34(%eax)
    eda5:	8b 45 08             	mov    0x8(%ebp),%eax
    eda8:	8b 50 34             	mov    0x34(%eax),%edx
    edab:	8b 45 08             	mov    0x8(%ebp),%eax
    edae:	89 50 30             	mov    %edx,0x30(%eax)
    edb1:	e9 9d 00 00 00       	jmp    ee53 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    edb6:	8b 45 08             	mov    0x8(%ebp),%eax
    edb9:	8b 40 0c             	mov    0xc(%eax),%eax
    edbc:	83 f8 02             	cmp    $0x2,%eax
    edbf:	74 0f                	je     edd0 <readChunk_bKGD+0xf9>
    edc1:	8b 45 08             	mov    0x8(%ebp),%eax
    edc4:	8b 40 0c             	mov    0xc(%eax),%eax
    edc7:	83 f8 06             	cmp    $0x6,%eax
    edca:	0f 85 83 00 00 00    	jne    ee53 <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    edd0:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    edd4:	74 07                	je     eddd <readChunk_bKGD+0x106>
    edd6:	b8 2d 00 00 00       	mov    $0x2d,%eax
    eddb:	eb 7b                	jmp    ee58 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    eddd:	8b 45 08             	mov    0x8(%ebp),%eax
    ede0:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    ede7:	8b 45 0c             	mov    0xc(%ebp),%eax
    edea:	0f b6 00             	movzbl (%eax),%eax
    eded:	0f b6 c0             	movzbl %al,%eax
    edf0:	c1 e0 08             	shl    $0x8,%eax
    edf3:	89 c2                	mov    %eax,%edx
    edf5:	8b 45 0c             	mov    0xc(%ebp),%eax
    edf8:	83 c0 01             	add    $0x1,%eax
    edfb:	0f b6 00             	movzbl (%eax),%eax
    edfe:	0f b6 c0             	movzbl %al,%eax
    ee01:	01 c2                	add    %eax,%edx
    ee03:	8b 45 08             	mov    0x8(%ebp),%eax
    ee06:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    ee09:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee0c:	83 c0 02             	add    $0x2,%eax
    ee0f:	0f b6 00             	movzbl (%eax),%eax
    ee12:	0f b6 c0             	movzbl %al,%eax
    ee15:	c1 e0 08             	shl    $0x8,%eax
    ee18:	89 c2                	mov    %eax,%edx
    ee1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee1d:	83 c0 03             	add    $0x3,%eax
    ee20:	0f b6 00             	movzbl (%eax),%eax
    ee23:	0f b6 c0             	movzbl %al,%eax
    ee26:	01 c2                	add    %eax,%edx
    ee28:	8b 45 08             	mov    0x8(%ebp),%eax
    ee2b:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    ee2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee31:	83 c0 04             	add    $0x4,%eax
    ee34:	0f b6 00             	movzbl (%eax),%eax
    ee37:	0f b6 c0             	movzbl %al,%eax
    ee3a:	c1 e0 08             	shl    $0x8,%eax
    ee3d:	89 c2                	mov    %eax,%edx
    ee3f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee42:	83 c0 05             	add    $0x5,%eax
    ee45:	0f b6 00             	movzbl (%eax),%eax
    ee48:	0f b6 c0             	movzbl %al,%eax
    ee4b:	01 c2                	add    %eax,%edx
    ee4d:	8b 45 08             	mov    0x8(%ebp),%eax
    ee50:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    ee53:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ee58:	5d                   	pop    %ebp
    ee59:	c3                   	ret    

0000ee5a <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ee5a:	55                   	push   %ebp
    ee5b:	89 e5                	mov    %esp,%ebp
    ee5d:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    ee60:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    ee67:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ee6e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ee75:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ee79:	0f 85 06 01 00 00    	jne    ef85 <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    ee7f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    ee86:	eb 04                	jmp    ee8c <readChunk_tEXt+0x32>
    ee88:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    ee8c:	8b 45 10             	mov    0x10(%ebp),%eax
    ee8f:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    ee92:	73 0f                	jae    eea3 <readChunk_tEXt+0x49>
    ee94:	8b 55 0c             	mov    0xc(%ebp),%edx
    ee97:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ee9a:	01 d0                	add    %edx,%eax
    ee9c:	0f b6 00             	movzbl (%eax),%eax
    ee9f:	84 c0                	test   %al,%al
    eea1:	75 e5                	jne    ee88 <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    eea3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    eea7:	74 06                	je     eeaf <readChunk_tEXt+0x55>
    eea9:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    eead:	76 0c                	jbe    eebb <readChunk_tEXt+0x61>
    eeaf:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    eeb6:	e9 ca 00 00 00       	jmp    ef85 <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    eebb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eebe:	83 c0 01             	add    $0x1,%eax
    eec1:	83 ec 0c             	sub    $0xc,%esp
    eec4:	50                   	push   %eax
    eec5:	e8 73 4b ff ff       	call   3a3d <lodepng_malloc>
    eeca:	83 c4 10             	add    $0x10,%esp
    eecd:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    eed0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    eed4:	75 0c                	jne    eee2 <readChunk_tEXt+0x88>
    eed6:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eedd:	e9 a3 00 00 00       	jmp    ef85 <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    eee2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eee5:	83 ec 04             	sub    $0x4,%esp
    eee8:	50                   	push   %eax
    eee9:	ff 75 0c             	pushl  0xc(%ebp)
    eeec:	ff 75 f0             	pushl  -0x10(%ebp)
    eeef:	e8 87 4b ff ff       	call   3a7b <lodepng_memcpy>
    eef4:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    eef7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    eefa:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eefd:	01 d0                	add    %edx,%eax
    eeff:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    ef02:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ef05:	83 c0 01             	add    $0x1,%eax
    ef08:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    ef0b:	8b 45 10             	mov    0x10(%ebp),%eax
    ef0e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    ef11:	72 08                	jb     ef1b <readChunk_tEXt+0xc1>
    ef13:	8b 45 10             	mov    0x10(%ebp),%eax
    ef16:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    ef19:	eb 05                	jmp    ef20 <readChunk_tEXt+0xc6>
    ef1b:	b8 00 00 00 00       	mov    $0x0,%eax
    ef20:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    ef23:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ef26:	83 c0 01             	add    $0x1,%eax
    ef29:	83 ec 0c             	sub    $0xc,%esp
    ef2c:	50                   	push   %eax
    ef2d:	e8 0b 4b ff ff       	call   3a3d <lodepng_malloc>
    ef32:	83 c4 10             	add    $0x10,%esp
    ef35:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    ef38:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ef3c:	75 09                	jne    ef47 <readChunk_tEXt+0xed>
    ef3e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ef45:	eb 3e                	jmp    ef85 <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    ef47:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ef4a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    ef4d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ef50:	01 ca                	add    %ecx,%edx
    ef52:	83 ec 04             	sub    $0x4,%esp
    ef55:	50                   	push   %eax
    ef56:	52                   	push   %edx
    ef57:	ff 75 ec             	pushl  -0x14(%ebp)
    ef5a:	e8 1c 4b ff ff       	call   3a7b <lodepng_memcpy>
    ef5f:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    ef62:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ef65:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ef68:	01 d0                	add    %edx,%eax
    ef6a:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    ef6d:	83 ec 04             	sub    $0x4,%esp
    ef70:	ff 75 ec             	pushl  -0x14(%ebp)
    ef73:	ff 75 f0             	pushl  -0x10(%ebp)
    ef76:	ff 75 08             	pushl  0x8(%ebp)
    ef79:	e8 3f ac ff ff       	call   9bbd <lodepng_add_text>
    ef7e:	83 c4 10             	add    $0x10,%esp
    ef81:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    ef84:	90                   	nop
  }

  lodepng_free(key);
    ef85:	83 ec 0c             	sub    $0xc,%esp
    ef88:	ff 75 f0             	pushl  -0x10(%ebp)
    ef8b:	e8 ce 4a ff ff       	call   3a5e <lodepng_free>
    ef90:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    ef93:	83 ec 0c             	sub    $0xc,%esp
    ef96:	ff 75 ec             	pushl  -0x14(%ebp)
    ef99:	e8 c0 4a ff ff       	call   3a5e <lodepng_free>
    ef9e:	83 c4 10             	add    $0x10,%esp

  return error;
    efa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    efa4:	c9                   	leave  
    efa5:	c3                   	ret    

0000efa6 <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    efa6:	55                   	push   %ebp
    efa7:	89 e5                	mov    %esp,%ebp
    efa9:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    efac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    efb3:	8b 45 0c             	mov    0xc(%ebp),%eax
    efb6:	8b 10                	mov    (%eax),%edx
    efb8:	89 55 d0             	mov    %edx,-0x30(%ebp)
    efbb:	8b 50 04             	mov    0x4(%eax),%edx
    efbe:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    efc1:	8b 50 08             	mov    0x8(%eax),%edx
    efc4:	89 55 d8             	mov    %edx,-0x28(%ebp)
    efc7:	8b 50 0c             	mov    0xc(%eax),%edx
    efca:	89 55 dc             	mov    %edx,-0x24(%ebp)
    efcd:	8b 50 10             	mov    0x10(%eax),%edx
    efd0:	89 55 e0             	mov    %edx,-0x20(%ebp)
    efd3:	8b 40 14             	mov    0x14(%eax),%eax
    efd6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    efd9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    efe0:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    efe7:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    efee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eff2:	0f 85 48 01 00 00    	jne    f140 <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    eff8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    efff:	eb 04                	jmp    f005 <readChunk_zTXt+0x5f>
    f001:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f005:	8b 45 14             	mov    0x14(%ebp),%eax
    f008:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    f00b:	73 0f                	jae    f01c <readChunk_zTXt+0x76>
    f00d:	8b 55 10             	mov    0x10(%ebp),%edx
    f010:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f013:	01 d0                	add    %edx,%eax
    f015:	0f b6 00             	movzbl (%eax),%eax
    f018:	84 c0                	test   %al,%al
    f01a:	75 e5                	jne    f001 <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    f01c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f01f:	8d 50 02             	lea    0x2(%eax),%edx
    f022:	8b 45 14             	mov    0x14(%ebp),%eax
    f025:	39 c2                	cmp    %eax,%edx
    f027:	72 0c                	jb     f035 <readChunk_zTXt+0x8f>
    f029:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    f030:	e9 0b 01 00 00       	jmp    f140 <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    f035:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f039:	74 06                	je     f041 <readChunk_zTXt+0x9b>
    f03b:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    f03f:	76 0c                	jbe    f04d <readChunk_zTXt+0xa7>
    f041:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    f048:	e9 f3 00 00 00       	jmp    f140 <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    f04d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f050:	83 c0 01             	add    $0x1,%eax
    f053:	83 ec 0c             	sub    $0xc,%esp
    f056:	50                   	push   %eax
    f057:	e8 e1 49 ff ff       	call   3a3d <lodepng_malloc>
    f05c:	83 c4 10             	add    $0x10,%esp
    f05f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    f062:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f066:	75 0c                	jne    f074 <readChunk_zTXt+0xce>
    f068:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f06f:	e9 cc 00 00 00       	jmp    f140 <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    f074:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f077:	83 ec 04             	sub    $0x4,%esp
    f07a:	50                   	push   %eax
    f07b:	ff 75 10             	pushl  0x10(%ebp)
    f07e:	ff 75 ec             	pushl  -0x14(%ebp)
    f081:	e8 f5 49 ff ff       	call   3a7b <lodepng_memcpy>
    f086:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    f089:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f08c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f08f:	01 d0                	add    %edx,%eax
    f091:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    f094:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f097:	8d 50 01             	lea    0x1(%eax),%edx
    f09a:	8b 45 10             	mov    0x10(%ebp),%eax
    f09d:	01 d0                	add    %edx,%eax
    f09f:	0f b6 00             	movzbl (%eax),%eax
    f0a2:	84 c0                	test   %al,%al
    f0a4:	74 0c                	je     f0b2 <readChunk_zTXt+0x10c>
    f0a6:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    f0ad:	e9 8e 00 00 00       	jmp    f140 <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    f0b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f0b5:	83 c0 02             	add    $0x2,%eax
    f0b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    f0bb:	8b 45 14             	mov    0x14(%ebp),%eax
    f0be:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f0c1:	76 09                	jbe    f0cc <readChunk_zTXt+0x126>
    f0c3:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    f0ca:	eb 74                	jmp    f140 <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    f0cc:	8b 45 14             	mov    0x14(%ebp),%eax
    f0cf:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f0d2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    f0d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0d8:	8b 40 30             	mov    0x30(%eax),%eax
    f0db:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    f0de:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f0e1:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f0e4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f0e7:	01 d1                	add    %edx,%ecx
    f0e9:	83 ec 08             	sub    $0x8,%esp
    f0ec:	8d 55 d0             	lea    -0x30(%ebp),%edx
    f0ef:	52                   	push   %edx
    f0f0:	50                   	push   %eax
    f0f1:	51                   	push   %ecx
    f0f2:	6a 00                	push   $0x0
    f0f4:	8d 45 c8             	lea    -0x38(%ebp),%eax
    f0f7:	50                   	push   %eax
    f0f8:	8d 45 cc             	lea    -0x34(%ebp),%eax
    f0fb:	50                   	push   %eax
    f0fc:	e8 f7 93 ff ff       	call   84f8 <zlib_decompress>
    f101:	83 c4 20             	add    $0x20,%esp
    f104:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    f107:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f10b:	74 11                	je     f11e <readChunk_zTXt+0x178>
    f10d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f110:	8b 45 c8             	mov    -0x38(%ebp),%eax
    f113:	39 c2                	cmp    %eax,%edx
    f115:	7d 07                	jge    f11e <readChunk_zTXt+0x178>
    f117:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    f11e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f122:	75 1b                	jne    f13f <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    f124:	8b 55 c8             	mov    -0x38(%ebp),%edx
    f127:	8b 45 cc             	mov    -0x34(%ebp),%eax
    f12a:	52                   	push   %edx
    f12b:	50                   	push   %eax
    f12c:	ff 75 ec             	pushl  -0x14(%ebp)
    f12f:	ff 75 08             	pushl  0x8(%ebp)
    f132:	e8 60 a9 ff ff       	call   9a97 <lodepng_add_text_sized>
    f137:	83 c4 10             	add    $0x10,%esp
    f13a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    f13d:	eb 01                	jmp    f140 <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    f13f:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    f140:	83 ec 0c             	sub    $0xc,%esp
    f143:	ff 75 ec             	pushl  -0x14(%ebp)
    f146:	e8 13 49 ff ff       	call   3a5e <lodepng_free>
    f14b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    f14e:	8b 45 cc             	mov    -0x34(%ebp),%eax
    f151:	83 ec 0c             	sub    $0xc,%esp
    f154:	50                   	push   %eax
    f155:	e8 04 49 ff ff       	call   3a5e <lodepng_free>
    f15a:	83 c4 10             	add    $0x10,%esp

  return error;
    f15d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f160:	c9                   	leave  
    f161:	c3                   	ret    

0000f162 <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f162:	55                   	push   %ebp
    f163:	89 e5                	mov    %esp,%ebp
    f165:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    f168:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f16f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f172:	8b 10                	mov    (%eax),%edx
    f174:	89 55 c0             	mov    %edx,-0x40(%ebp)
    f177:	8b 50 04             	mov    0x4(%eax),%edx
    f17a:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    f17d:	8b 50 08             	mov    0x8(%eax),%edx
    f180:	89 55 c8             	mov    %edx,-0x38(%ebp)
    f183:	8b 50 0c             	mov    0xc(%eax),%edx
    f186:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f189:	8b 50 10             	mov    0x10(%eax),%edx
    f18c:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f18f:	8b 40 14             	mov    0x14(%eax),%eax
    f192:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    f195:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    f19c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    f1a3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    f1aa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f1ae:	0f 85 d5 02 00 00    	jne    f489 <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    f1b4:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    f1b8:	7f 0c                	jg     f1c6 <readChunk_iTXt+0x64>
    f1ba:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    f1c1:	e9 c3 02 00 00       	jmp    f489 <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f1c6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f1cd:	eb 04                	jmp    f1d3 <readChunk_iTXt+0x71>
    f1cf:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f1d3:	8b 45 14             	mov    0x14(%ebp),%eax
    f1d6:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f1d9:	73 0f                	jae    f1ea <readChunk_iTXt+0x88>
    f1db:	8b 55 10             	mov    0x10(%ebp),%edx
    f1de:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f1e1:	01 d0                	add    %edx,%eax
    f1e3:	0f b6 00             	movzbl (%eax),%eax
    f1e6:	84 c0                	test   %al,%al
    f1e8:	75 e5                	jne    f1cf <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    f1ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f1ed:	8d 50 03             	lea    0x3(%eax),%edx
    f1f0:	8b 45 14             	mov    0x14(%ebp),%eax
    f1f3:	39 c2                	cmp    %eax,%edx
    f1f5:	72 0c                	jb     f203 <readChunk_iTXt+0xa1>
    f1f7:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    f1fe:	e9 86 02 00 00       	jmp    f489 <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    f203:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f207:	74 06                	je     f20f <readChunk_iTXt+0xad>
    f209:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f20d:	76 0c                	jbe    f21b <readChunk_iTXt+0xb9>
    f20f:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    f216:	e9 6e 02 00 00       	jmp    f489 <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    f21b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f21e:	83 c0 01             	add    $0x1,%eax
    f221:	83 ec 0c             	sub    $0xc,%esp
    f224:	50                   	push   %eax
    f225:	e8 13 48 ff ff       	call   3a3d <lodepng_malloc>
    f22a:	83 c4 10             	add    $0x10,%esp
    f22d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    f230:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    f234:	75 0c                	jne    f242 <readChunk_iTXt+0xe0>
    f236:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f23d:	e9 47 02 00 00       	jmp    f489 <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    f242:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f245:	83 ec 04             	sub    $0x4,%esp
    f248:	50                   	push   %eax
    f249:	ff 75 10             	pushl  0x10(%ebp)
    f24c:	ff 75 e8             	pushl  -0x18(%ebp)
    f24f:	e8 27 48 ff ff       	call   3a7b <lodepng_memcpy>
    f254:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    f257:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f25a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f25d:	01 d0                	add    %edx,%eax
    f25f:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    f262:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f265:	8d 50 01             	lea    0x1(%eax),%edx
    f268:	8b 45 10             	mov    0x10(%ebp),%eax
    f26b:	01 d0                	add    %edx,%eax
    f26d:	0f b6 00             	movzbl (%eax),%eax
    f270:	0f b6 c0             	movzbl %al,%eax
    f273:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    f276:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f279:	8d 50 02             	lea    0x2(%eax),%edx
    f27c:	8b 45 10             	mov    0x10(%ebp),%eax
    f27f:	01 d0                	add    %edx,%eax
    f281:	0f b6 00             	movzbl (%eax),%eax
    f284:	84 c0                	test   %al,%al
    f286:	74 0c                	je     f294 <readChunk_iTXt+0x132>
    f288:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    f28f:	e9 f5 01 00 00       	jmp    f489 <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    f294:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f297:	83 c0 03             	add    $0x3,%eax
    f29a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    f29d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    f2a4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    f2a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f2aa:	eb 08                	jmp    f2b4 <readChunk_iTXt+0x152>
    f2ac:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f2b0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f2b4:	8b 45 14             	mov    0x14(%ebp),%eax
    f2b7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    f2ba:	73 0f                	jae    f2cb <readChunk_iTXt+0x169>
    f2bc:	8b 55 10             	mov    0x10(%ebp),%edx
    f2bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f2c2:	01 d0                	add    %edx,%eax
    f2c4:	0f b6 00             	movzbl (%eax),%eax
    f2c7:	84 c0                	test   %al,%al
    f2c9:	75 e1                	jne    f2ac <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    f2cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2ce:	83 c0 01             	add    $0x1,%eax
    f2d1:	83 ec 0c             	sub    $0xc,%esp
    f2d4:	50                   	push   %eax
    f2d5:	e8 63 47 ff ff       	call   3a3d <lodepng_malloc>
    f2da:	83 c4 10             	add    $0x10,%esp
    f2dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    f2e0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    f2e4:	75 0c                	jne    f2f2 <readChunk_iTXt+0x190>
    f2e6:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f2ed:	e9 97 01 00 00       	jmp    f489 <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    f2f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2f5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f2f8:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f2fb:	01 ca                	add    %ecx,%edx
    f2fd:	83 ec 04             	sub    $0x4,%esp
    f300:	50                   	push   %eax
    f301:	52                   	push   %edx
    f302:	ff 75 e4             	pushl  -0x1c(%ebp)
    f305:	e8 71 47 ff ff       	call   3a7b <lodepng_memcpy>
    f30a:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    f30d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f310:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f313:	01 d0                	add    %edx,%eax
    f315:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    f318:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f31b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    f31e:	01 d0                	add    %edx,%eax
    f320:	83 c0 01             	add    $0x1,%eax
    f323:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    f326:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    f32d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    f330:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f333:	eb 08                	jmp    f33d <readChunk_iTXt+0x1db>
    f335:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f339:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f33d:	8b 45 14             	mov    0x14(%ebp),%eax
    f340:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    f343:	73 0f                	jae    f354 <readChunk_iTXt+0x1f2>
    f345:	8b 55 10             	mov    0x10(%ebp),%edx
    f348:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f34b:	01 d0                	add    %edx,%eax
    f34d:	0f b6 00             	movzbl (%eax),%eax
    f350:	84 c0                	test   %al,%al
    f352:	75 e1                	jne    f335 <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    f354:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f357:	83 c0 01             	add    $0x1,%eax
    f35a:	83 ec 0c             	sub    $0xc,%esp
    f35d:	50                   	push   %eax
    f35e:	e8 da 46 ff ff       	call   3a3d <lodepng_malloc>
    f363:	83 c4 10             	add    $0x10,%esp
    f366:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    f369:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    f36d:	75 0c                	jne    f37b <readChunk_iTXt+0x219>
    f36f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f376:	e9 0e 01 00 00       	jmp    f489 <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    f37b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f37e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f381:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f384:	01 ca                	add    %ecx,%edx
    f386:	83 ec 04             	sub    $0x4,%esp
    f389:	50                   	push   %eax
    f38a:	52                   	push   %edx
    f38b:	ff 75 e0             	pushl  -0x20(%ebp)
    f38e:	e8 e8 46 ff ff       	call   3a7b <lodepng_memcpy>
    f393:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    f396:	8b 55 e0             	mov    -0x20(%ebp),%edx
    f399:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f39c:	01 d0                	add    %edx,%eax
    f39e:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    f3a1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f3a4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    f3a7:	01 d0                	add    %edx,%eax
    f3a9:	83 c0 01             	add    $0x1,%eax
    f3ac:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    f3af:	8b 45 14             	mov    0x14(%ebp),%eax
    f3b2:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    f3b5:	72 08                	jb     f3bf <readChunk_iTXt+0x25d>
    f3b7:	8b 45 14             	mov    0x14(%ebp),%eax
    f3ba:	2b 45 d8             	sub    -0x28(%ebp),%eax
    f3bd:	eb 05                	jmp    f3c4 <readChunk_iTXt+0x262>
    f3bf:	b8 00 00 00 00       	mov    $0x0,%eax
    f3c4:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    f3c7:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    f3cb:	0f 84 90 00 00 00    	je     f461 <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    f3d1:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    f3d8:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    f3df:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3e2:	8b 40 30             	mov    0x30(%eax),%eax
    f3e5:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    f3e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f3eb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f3ee:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f3f1:	01 d1                	add    %edx,%ecx
    f3f3:	83 ec 08             	sub    $0x8,%esp
    f3f6:	8d 55 c0             	lea    -0x40(%ebp),%edx
    f3f9:	52                   	push   %edx
    f3fa:	50                   	push   %eax
    f3fb:	51                   	push   %ecx
    f3fc:	6a 00                	push   $0x0
    f3fe:	8d 45 b8             	lea    -0x48(%ebp),%eax
    f401:	50                   	push   %eax
    f402:	8d 45 bc             	lea    -0x44(%ebp),%eax
    f405:	50                   	push   %eax
    f406:	e8 ed 90 ff ff       	call   84f8 <zlib_decompress>
    f40b:	83 c4 20             	add    $0x20,%esp
    f40e:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    f411:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f415:	74 11                	je     f428 <readChunk_iTXt+0x2c6>
    f417:	8b 55 c8             	mov    -0x38(%ebp),%edx
    f41a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    f41d:	39 c2                	cmp    %eax,%edx
    f41f:	7d 07                	jge    f428 <readChunk_iTXt+0x2c6>
    f421:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    f428:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f42c:	75 22                	jne    f450 <readChunk_iTXt+0x2ee>
    f42e:	8b 55 b8             	mov    -0x48(%ebp),%edx
    f431:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f434:	83 ec 08             	sub    $0x8,%esp
    f437:	52                   	push   %edx
    f438:	50                   	push   %eax
    f439:	ff 75 e0             	pushl  -0x20(%ebp)
    f43c:	ff 75 e4             	pushl  -0x1c(%ebp)
    f43f:	ff 75 e8             	pushl  -0x18(%ebp)
    f442:	ff 75 08             	pushl  0x8(%ebp)
    f445:	e8 94 a9 ff ff       	call   9dde <lodepng_add_itext_sized>
    f44a:	83 c4 20             	add    $0x20,%esp
    f44d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    f450:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f453:	83 ec 0c             	sub    $0xc,%esp
    f456:	50                   	push   %eax
    f457:	e8 02 46 ff ff       	call   3a5e <lodepng_free>
    f45c:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    f45f:	eb 27                	jmp    f488 <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    f461:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f464:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f467:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f46a:	01 ca                	add    %ecx,%edx
    f46c:	83 ec 08             	sub    $0x8,%esp
    f46f:	50                   	push   %eax
    f470:	52                   	push   %edx
    f471:	ff 75 e0             	pushl  -0x20(%ebp)
    f474:	ff 75 e4             	pushl  -0x1c(%ebp)
    f477:	ff 75 e8             	pushl  -0x18(%ebp)
    f47a:	ff 75 08             	pushl  0x8(%ebp)
    f47d:	e8 5c a9 ff ff       	call   9dde <lodepng_add_itext_sized>
    f482:	83 c4 20             	add    $0x20,%esp
    f485:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    f488:	90                   	nop
  }

  lodepng_free(key);
    f489:	83 ec 0c             	sub    $0xc,%esp
    f48c:	ff 75 e8             	pushl  -0x18(%ebp)
    f48f:	e8 ca 45 ff ff       	call   3a5e <lodepng_free>
    f494:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    f497:	83 ec 0c             	sub    $0xc,%esp
    f49a:	ff 75 e4             	pushl  -0x1c(%ebp)
    f49d:	e8 bc 45 ff ff       	call   3a5e <lodepng_free>
    f4a2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    f4a5:	83 ec 0c             	sub    $0xc,%esp
    f4a8:	ff 75 e0             	pushl  -0x20(%ebp)
    f4ab:	e8 ae 45 ff ff       	call   3a5e <lodepng_free>
    f4b0:	83 c4 10             	add    $0x10,%esp

  return error;
    f4b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f4b6:	c9                   	leave  
    f4b7:	c3                   	ret    

0000f4b8 <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f4b8:	55                   	push   %ebp
    f4b9:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    f4bb:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    f4bf:	74 0a                	je     f4cb <readChunk_tIME+0x13>
    f4c1:	b8 49 00 00 00       	mov    $0x49,%eax
    f4c6:	e9 8b 00 00 00       	jmp    f556 <readChunk_tIME+0x9e>

  info->time_defined = 1;
    f4cb:	8b 45 08             	mov    0x8(%ebp),%eax
    f4ce:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    f4d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4d8:	0f b6 00             	movzbl (%eax),%eax
    f4db:	0f b6 c0             	movzbl %al,%eax
    f4de:	c1 e0 08             	shl    $0x8,%eax
    f4e1:	89 c2                	mov    %eax,%edx
    f4e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4e6:	83 c0 01             	add    $0x1,%eax
    f4e9:	0f b6 00             	movzbl (%eax),%eax
    f4ec:	0f b6 c0             	movzbl %al,%eax
    f4ef:	01 c2                	add    %eax,%edx
    f4f1:	8b 45 08             	mov    0x8(%ebp),%eax
    f4f4:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    f4f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4fa:	83 c0 02             	add    $0x2,%eax
    f4fd:	0f b6 00             	movzbl (%eax),%eax
    f500:	0f b6 d0             	movzbl %al,%edx
    f503:	8b 45 08             	mov    0x8(%ebp),%eax
    f506:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    f509:	8b 45 0c             	mov    0xc(%ebp),%eax
    f50c:	83 c0 03             	add    $0x3,%eax
    f50f:	0f b6 00             	movzbl (%eax),%eax
    f512:	0f b6 d0             	movzbl %al,%edx
    f515:	8b 45 08             	mov    0x8(%ebp),%eax
    f518:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    f51b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f51e:	83 c0 04             	add    $0x4,%eax
    f521:	0f b6 00             	movzbl (%eax),%eax
    f524:	0f b6 d0             	movzbl %al,%edx
    f527:	8b 45 08             	mov    0x8(%ebp),%eax
    f52a:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    f52d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f530:	83 c0 05             	add    $0x5,%eax
    f533:	0f b6 00             	movzbl (%eax),%eax
    f536:	0f b6 d0             	movzbl %al,%edx
    f539:	8b 45 08             	mov    0x8(%ebp),%eax
    f53c:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    f53f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f542:	83 c0 06             	add    $0x6,%eax
    f545:	0f b6 00             	movzbl (%eax),%eax
    f548:	0f b6 d0             	movzbl %al,%edx
    f54b:	8b 45 08             	mov    0x8(%ebp),%eax
    f54e:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    f551:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f556:	5d                   	pop    %ebp
    f557:	c3                   	ret    

0000f558 <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f558:	55                   	push   %ebp
    f559:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    f55b:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    f55f:	74 0a                	je     f56b <readChunk_pHYs+0x13>
    f561:	b8 4a 00 00 00       	mov    $0x4a,%eax
    f566:	e9 ba 00 00 00       	jmp    f625 <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    f56b:	8b 45 08             	mov    0x8(%ebp),%eax
    f56e:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    f575:	8b 45 0c             	mov    0xc(%ebp),%eax
    f578:	0f b6 00             	movzbl (%eax),%eax
    f57b:	0f b6 c0             	movzbl %al,%eax
    f57e:	c1 e0 08             	shl    $0x8,%eax
    f581:	89 c2                	mov    %eax,%edx
    f583:	8b 45 0c             	mov    0xc(%ebp),%eax
    f586:	83 c0 01             	add    $0x1,%eax
    f589:	0f b6 00             	movzbl (%eax),%eax
    f58c:	0f b6 c0             	movzbl %al,%eax
    f58f:	01 d0                	add    %edx,%eax
    f591:	c1 e0 08             	shl    $0x8,%eax
    f594:	89 c2                	mov    %eax,%edx
    f596:	8b 45 0c             	mov    0xc(%ebp),%eax
    f599:	83 c0 02             	add    $0x2,%eax
    f59c:	0f b6 00             	movzbl (%eax),%eax
    f59f:	0f b6 c0             	movzbl %al,%eax
    f5a2:	01 d0                	add    %edx,%eax
    f5a4:	c1 e0 08             	shl    $0x8,%eax
    f5a7:	89 c2                	mov    %eax,%edx
    f5a9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5ac:	83 c0 03             	add    $0x3,%eax
    f5af:	0f b6 00             	movzbl (%eax),%eax
    f5b2:	0f b6 c0             	movzbl %al,%eax
    f5b5:	01 c2                	add    %eax,%edx
    f5b7:	8b 45 08             	mov    0x8(%ebp),%eax
    f5ba:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    f5bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5c0:	83 c0 04             	add    $0x4,%eax
    f5c3:	0f b6 00             	movzbl (%eax),%eax
    f5c6:	0f b6 c0             	movzbl %al,%eax
    f5c9:	c1 e0 08             	shl    $0x8,%eax
    f5cc:	89 c2                	mov    %eax,%edx
    f5ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5d1:	83 c0 05             	add    $0x5,%eax
    f5d4:	0f b6 00             	movzbl (%eax),%eax
    f5d7:	0f b6 c0             	movzbl %al,%eax
    f5da:	01 d0                	add    %edx,%eax
    f5dc:	c1 e0 08             	shl    $0x8,%eax
    f5df:	89 c2                	mov    %eax,%edx
    f5e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5e4:	83 c0 06             	add    $0x6,%eax
    f5e7:	0f b6 00             	movzbl (%eax),%eax
    f5ea:	0f b6 c0             	movzbl %al,%eax
    f5ed:	01 d0                	add    %edx,%eax
    f5ef:	c1 e0 08             	shl    $0x8,%eax
    f5f2:	89 c2                	mov    %eax,%edx
    f5f4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5f7:	83 c0 07             	add    $0x7,%eax
    f5fa:	0f b6 00             	movzbl (%eax),%eax
    f5fd:	0f b6 c0             	movzbl %al,%eax
    f600:	01 c2                	add    %eax,%edx
    f602:	8b 45 08             	mov    0x8(%ebp),%eax
    f605:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    f60b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f60e:	83 c0 08             	add    $0x8,%eax
    f611:	0f b6 00             	movzbl (%eax),%eax
    f614:	0f b6 d0             	movzbl %al,%edx
    f617:	8b 45 08             	mov    0x8(%ebp),%eax
    f61a:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    f620:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f625:	5d                   	pop    %ebp
    f626:	c3                   	ret    

0000f627 <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f627:	55                   	push   %ebp
    f628:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    f62a:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    f62e:	74 07                	je     f637 <readChunk_gAMA+0x10>
    f630:	b8 60 00 00 00       	mov    $0x60,%eax
    f635:	eb 5d                	jmp    f694 <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    f637:	8b 45 08             	mov    0x8(%ebp),%eax
    f63a:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    f641:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    f644:	8b 45 0c             	mov    0xc(%ebp),%eax
    f647:	0f b6 00             	movzbl (%eax),%eax
    f64a:	0f b6 c0             	movzbl %al,%eax
    f64d:	c1 e0 08             	shl    $0x8,%eax
    f650:	89 c2                	mov    %eax,%edx
    f652:	8b 45 0c             	mov    0xc(%ebp),%eax
    f655:	83 c0 01             	add    $0x1,%eax
    f658:	0f b6 00             	movzbl (%eax),%eax
    f65b:	0f b6 c0             	movzbl %al,%eax
    f65e:	01 d0                	add    %edx,%eax
    f660:	c1 e0 08             	shl    $0x8,%eax
    f663:	89 c2                	mov    %eax,%edx
    f665:	8b 45 0c             	mov    0xc(%ebp),%eax
    f668:	83 c0 02             	add    $0x2,%eax
    f66b:	0f b6 00             	movzbl (%eax),%eax
    f66e:	0f b6 c0             	movzbl %al,%eax
    f671:	01 d0                	add    %edx,%eax
    f673:	c1 e0 08             	shl    $0x8,%eax
    f676:	89 c2                	mov    %eax,%edx
    f678:	8b 45 0c             	mov    0xc(%ebp),%eax
    f67b:	83 c0 03             	add    $0x3,%eax
    f67e:	0f b6 00             	movzbl (%eax),%eax
    f681:	0f b6 c0             	movzbl %al,%eax
    f684:	01 c2                	add    %eax,%edx
    f686:	8b 45 08             	mov    0x8(%ebp),%eax
    f689:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    f68f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f694:	5d                   	pop    %ebp
    f695:	c3                   	ret    

0000f696 <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f696:	55                   	push   %ebp
    f697:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    f699:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    f69d:	74 0a                	je     f6a9 <readChunk_cHRM+0x13>
    f69f:	b8 61 00 00 00       	mov    $0x61,%eax
    f6a4:	e9 7f 02 00 00       	jmp    f928 <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    f6a9:	8b 45 08             	mov    0x8(%ebp),%eax
    f6ac:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    f6b3:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    f6b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f6b9:	0f b6 00             	movzbl (%eax),%eax
    f6bc:	0f b6 c0             	movzbl %al,%eax
    f6bf:	c1 e0 08             	shl    $0x8,%eax
    f6c2:	89 c2                	mov    %eax,%edx
    f6c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f6c7:	83 c0 01             	add    $0x1,%eax
    f6ca:	0f b6 00             	movzbl (%eax),%eax
    f6cd:	0f b6 c0             	movzbl %al,%eax
    f6d0:	01 d0                	add    %edx,%eax
    f6d2:	c1 e0 08             	shl    $0x8,%eax
    f6d5:	89 c2                	mov    %eax,%edx
    f6d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f6da:	83 c0 02             	add    $0x2,%eax
    f6dd:	0f b6 00             	movzbl (%eax),%eax
    f6e0:	0f b6 c0             	movzbl %al,%eax
    f6e3:	01 d0                	add    %edx,%eax
    f6e5:	c1 e0 08             	shl    $0x8,%eax
    f6e8:	89 c2                	mov    %eax,%edx
    f6ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    f6ed:	83 c0 03             	add    $0x3,%eax
    f6f0:	0f b6 00             	movzbl (%eax),%eax
    f6f3:	0f b6 c0             	movzbl %al,%eax
    f6f6:	01 c2                	add    %eax,%edx
    f6f8:	8b 45 08             	mov    0x8(%ebp),%eax
    f6fb:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    f701:	8b 45 0c             	mov    0xc(%ebp),%eax
    f704:	83 c0 04             	add    $0x4,%eax
    f707:	0f b6 00             	movzbl (%eax),%eax
    f70a:	0f b6 c0             	movzbl %al,%eax
    f70d:	c1 e0 08             	shl    $0x8,%eax
    f710:	89 c2                	mov    %eax,%edx
    f712:	8b 45 0c             	mov    0xc(%ebp),%eax
    f715:	83 c0 05             	add    $0x5,%eax
    f718:	0f b6 00             	movzbl (%eax),%eax
    f71b:	0f b6 c0             	movzbl %al,%eax
    f71e:	01 d0                	add    %edx,%eax
    f720:	c1 e0 08             	shl    $0x8,%eax
    f723:	89 c2                	mov    %eax,%edx
    f725:	8b 45 0c             	mov    0xc(%ebp),%eax
    f728:	83 c0 06             	add    $0x6,%eax
    f72b:	0f b6 00             	movzbl (%eax),%eax
    f72e:	0f b6 c0             	movzbl %al,%eax
    f731:	01 d0                	add    %edx,%eax
    f733:	c1 e0 08             	shl    $0x8,%eax
    f736:	89 c2                	mov    %eax,%edx
    f738:	8b 45 0c             	mov    0xc(%ebp),%eax
    f73b:	83 c0 07             	add    $0x7,%eax
    f73e:	0f b6 00             	movzbl (%eax),%eax
    f741:	0f b6 c0             	movzbl %al,%eax
    f744:	01 c2                	add    %eax,%edx
    f746:	8b 45 08             	mov    0x8(%ebp),%eax
    f749:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    f74f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f752:	83 c0 08             	add    $0x8,%eax
    f755:	0f b6 00             	movzbl (%eax),%eax
    f758:	0f b6 c0             	movzbl %al,%eax
    f75b:	c1 e0 08             	shl    $0x8,%eax
    f75e:	89 c2                	mov    %eax,%edx
    f760:	8b 45 0c             	mov    0xc(%ebp),%eax
    f763:	83 c0 09             	add    $0x9,%eax
    f766:	0f b6 00             	movzbl (%eax),%eax
    f769:	0f b6 c0             	movzbl %al,%eax
    f76c:	01 d0                	add    %edx,%eax
    f76e:	c1 e0 08             	shl    $0x8,%eax
    f771:	89 c2                	mov    %eax,%edx
    f773:	8b 45 0c             	mov    0xc(%ebp),%eax
    f776:	83 c0 0a             	add    $0xa,%eax
    f779:	0f b6 00             	movzbl (%eax),%eax
    f77c:	0f b6 c0             	movzbl %al,%eax
    f77f:	01 d0                	add    %edx,%eax
    f781:	c1 e0 08             	shl    $0x8,%eax
    f784:	89 c2                	mov    %eax,%edx
    f786:	8b 45 0c             	mov    0xc(%ebp),%eax
    f789:	83 c0 0b             	add    $0xb,%eax
    f78c:	0f b6 00             	movzbl (%eax),%eax
    f78f:	0f b6 c0             	movzbl %al,%eax
    f792:	01 c2                	add    %eax,%edx
    f794:	8b 45 08             	mov    0x8(%ebp),%eax
    f797:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f79d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7a0:	83 c0 0c             	add    $0xc,%eax
    f7a3:	0f b6 00             	movzbl (%eax),%eax
    f7a6:	0f b6 c0             	movzbl %al,%eax
    f7a9:	c1 e0 08             	shl    $0x8,%eax
    f7ac:	89 c2                	mov    %eax,%edx
    f7ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7b1:	83 c0 0d             	add    $0xd,%eax
    f7b4:	0f b6 00             	movzbl (%eax),%eax
    f7b7:	0f b6 c0             	movzbl %al,%eax
    f7ba:	01 d0                	add    %edx,%eax
    f7bc:	c1 e0 08             	shl    $0x8,%eax
    f7bf:	89 c2                	mov    %eax,%edx
    f7c1:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7c4:	83 c0 0e             	add    $0xe,%eax
    f7c7:	0f b6 00             	movzbl (%eax),%eax
    f7ca:	0f b6 c0             	movzbl %al,%eax
    f7cd:	01 d0                	add    %edx,%eax
    f7cf:	c1 e0 08             	shl    $0x8,%eax
    f7d2:	89 c2                	mov    %eax,%edx
    f7d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7d7:	83 c0 0f             	add    $0xf,%eax
    f7da:	0f b6 00             	movzbl (%eax),%eax
    f7dd:	0f b6 c0             	movzbl %al,%eax
    f7e0:	01 c2                	add    %eax,%edx
    f7e2:	8b 45 08             	mov    0x8(%ebp),%eax
    f7e5:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f7eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7ee:	83 c0 10             	add    $0x10,%eax
    f7f1:	0f b6 00             	movzbl (%eax),%eax
    f7f4:	0f b6 c0             	movzbl %al,%eax
    f7f7:	c1 e0 08             	shl    $0x8,%eax
    f7fa:	89 c2                	mov    %eax,%edx
    f7fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7ff:	83 c0 11             	add    $0x11,%eax
    f802:	0f b6 00             	movzbl (%eax),%eax
    f805:	0f b6 c0             	movzbl %al,%eax
    f808:	01 d0                	add    %edx,%eax
    f80a:	c1 e0 08             	shl    $0x8,%eax
    f80d:	89 c2                	mov    %eax,%edx
    f80f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f812:	83 c0 12             	add    $0x12,%eax
    f815:	0f b6 00             	movzbl (%eax),%eax
    f818:	0f b6 c0             	movzbl %al,%eax
    f81b:	01 d0                	add    %edx,%eax
    f81d:	c1 e0 08             	shl    $0x8,%eax
    f820:	89 c2                	mov    %eax,%edx
    f822:	8b 45 0c             	mov    0xc(%ebp),%eax
    f825:	83 c0 13             	add    $0x13,%eax
    f828:	0f b6 00             	movzbl (%eax),%eax
    f82b:	0f b6 c0             	movzbl %al,%eax
    f82e:	01 c2                	add    %eax,%edx
    f830:	8b 45 08             	mov    0x8(%ebp),%eax
    f833:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f839:	8b 45 0c             	mov    0xc(%ebp),%eax
    f83c:	83 c0 14             	add    $0x14,%eax
    f83f:	0f b6 00             	movzbl (%eax),%eax
    f842:	0f b6 c0             	movzbl %al,%eax
    f845:	c1 e0 08             	shl    $0x8,%eax
    f848:	89 c2                	mov    %eax,%edx
    f84a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f84d:	83 c0 15             	add    $0x15,%eax
    f850:	0f b6 00             	movzbl (%eax),%eax
    f853:	0f b6 c0             	movzbl %al,%eax
    f856:	01 d0                	add    %edx,%eax
    f858:	c1 e0 08             	shl    $0x8,%eax
    f85b:	89 c2                	mov    %eax,%edx
    f85d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f860:	83 c0 16             	add    $0x16,%eax
    f863:	0f b6 00             	movzbl (%eax),%eax
    f866:	0f b6 c0             	movzbl %al,%eax
    f869:	01 d0                	add    %edx,%eax
    f86b:	c1 e0 08             	shl    $0x8,%eax
    f86e:	89 c2                	mov    %eax,%edx
    f870:	8b 45 0c             	mov    0xc(%ebp),%eax
    f873:	83 c0 17             	add    $0x17,%eax
    f876:	0f b6 00             	movzbl (%eax),%eax
    f879:	0f b6 c0             	movzbl %al,%eax
    f87c:	01 c2                	add    %eax,%edx
    f87e:	8b 45 08             	mov    0x8(%ebp),%eax
    f881:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f887:	8b 45 0c             	mov    0xc(%ebp),%eax
    f88a:	83 c0 18             	add    $0x18,%eax
    f88d:	0f b6 00             	movzbl (%eax),%eax
    f890:	0f b6 c0             	movzbl %al,%eax
    f893:	c1 e0 08             	shl    $0x8,%eax
    f896:	89 c2                	mov    %eax,%edx
    f898:	8b 45 0c             	mov    0xc(%ebp),%eax
    f89b:	83 c0 19             	add    $0x19,%eax
    f89e:	0f b6 00             	movzbl (%eax),%eax
    f8a1:	0f b6 c0             	movzbl %al,%eax
    f8a4:	01 d0                	add    %edx,%eax
    f8a6:	c1 e0 08             	shl    $0x8,%eax
    f8a9:	89 c2                	mov    %eax,%edx
    f8ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    f8ae:	83 c0 1a             	add    $0x1a,%eax
    f8b1:	0f b6 00             	movzbl (%eax),%eax
    f8b4:	0f b6 c0             	movzbl %al,%eax
    f8b7:	01 d0                	add    %edx,%eax
    f8b9:	c1 e0 08             	shl    $0x8,%eax
    f8bc:	89 c2                	mov    %eax,%edx
    f8be:	8b 45 0c             	mov    0xc(%ebp),%eax
    f8c1:	83 c0 1b             	add    $0x1b,%eax
    f8c4:	0f b6 00             	movzbl (%eax),%eax
    f8c7:	0f b6 c0             	movzbl %al,%eax
    f8ca:	01 c2                	add    %eax,%edx
    f8cc:	8b 45 08             	mov    0x8(%ebp),%eax
    f8cf:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f8d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f8d8:	83 c0 1c             	add    $0x1c,%eax
    f8db:	0f b6 00             	movzbl (%eax),%eax
    f8de:	0f b6 c0             	movzbl %al,%eax
    f8e1:	c1 e0 08             	shl    $0x8,%eax
    f8e4:	89 c2                	mov    %eax,%edx
    f8e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f8e9:	83 c0 1d             	add    $0x1d,%eax
    f8ec:	0f b6 00             	movzbl (%eax),%eax
    f8ef:	0f b6 c0             	movzbl %al,%eax
    f8f2:	01 d0                	add    %edx,%eax
    f8f4:	c1 e0 08             	shl    $0x8,%eax
    f8f7:	89 c2                	mov    %eax,%edx
    f8f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f8fc:	83 c0 1e             	add    $0x1e,%eax
    f8ff:	0f b6 00             	movzbl (%eax),%eax
    f902:	0f b6 c0             	movzbl %al,%eax
    f905:	01 d0                	add    %edx,%eax
    f907:	c1 e0 08             	shl    $0x8,%eax
    f90a:	89 c2                	mov    %eax,%edx
    f90c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f90f:	83 c0 1f             	add    $0x1f,%eax
    f912:	0f b6 00             	movzbl (%eax),%eax
    f915:	0f b6 c0             	movzbl %al,%eax
    f918:	01 c2                	add    %eax,%edx
    f91a:	8b 45 08             	mov    0x8(%ebp),%eax
    f91d:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f923:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f928:	5d                   	pop    %ebp
    f929:	c3                   	ret    

0000f92a <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f92a:	55                   	push   %ebp
    f92b:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f92d:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f931:	74 07                	je     f93a <readChunk_sRGB+0x10>
    f933:	b8 62 00 00 00       	mov    $0x62,%eax
    f938:	eb 24                	jmp    f95e <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f93a:	8b 45 08             	mov    0x8(%ebp),%eax
    f93d:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f944:	00 00 00 
  info->srgb_intent = data[0];
    f947:	8b 45 0c             	mov    0xc(%ebp),%eax
    f94a:	0f b6 00             	movzbl (%eax),%eax
    f94d:	0f b6 d0             	movzbl %al,%edx
    f950:	8b 45 08             	mov    0x8(%ebp),%eax
    f953:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f959:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f95e:	5d                   	pop    %ebp
    f95f:	c3                   	ret    

0000f960 <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f960:	55                   	push   %ebp
    f961:	89 e5                	mov    %esp,%ebp
    f963:	53                   	push   %ebx
    f964:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f967:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f96e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f975:	8b 45 0c             	mov    0xc(%ebp),%eax
    f978:	8b 10                	mov    (%eax),%edx
    f97a:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f97d:	8b 50 04             	mov    0x4(%eax),%edx
    f980:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f983:	8b 50 08             	mov    0x8(%eax),%edx
    f986:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f989:	8b 50 0c             	mov    0xc(%eax),%edx
    f98c:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f98f:	8b 50 10             	mov    0x10(%eax),%edx
    f992:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f995:	8b 40 14             	mov    0x14(%eax),%eax
    f998:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f99b:	8b 45 08             	mov    0x8(%ebp),%eax
    f99e:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f9a5:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f9a8:	8b 45 08             	mov    0x8(%ebp),%eax
    f9ab:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f9b1:	85 c0                	test   %eax,%eax
    f9b3:	74 0e                	je     f9c3 <readChunk_iCCP+0x63>
    f9b5:	83 ec 0c             	sub    $0xc,%esp
    f9b8:	ff 75 08             	pushl  0x8(%ebp)
    f9bb:	e8 ca a6 ff ff       	call   a08a <lodepng_clear_icc>
    f9c0:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f9c3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f9ca:	eb 04                	jmp    f9d0 <readChunk_iCCP+0x70>
    f9cc:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f9d0:	8b 45 14             	mov    0x14(%ebp),%eax
    f9d3:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f9d6:	73 0f                	jae    f9e7 <readChunk_iCCP+0x87>
    f9d8:	8b 55 10             	mov    0x10(%ebp),%edx
    f9db:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f9de:	01 d0                	add    %edx,%eax
    f9e0:	0f b6 00             	movzbl (%eax),%eax
    f9e3:	84 c0                	test   %al,%al
    f9e5:	75 e5                	jne    f9cc <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f9e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f9ea:	8d 50 02             	lea    0x2(%eax),%edx
    f9ed:	8b 45 14             	mov    0x14(%ebp),%eax
    f9f0:	39 c2                	cmp    %eax,%edx
    f9f2:	72 0a                	jb     f9fe <readChunk_iCCP+0x9e>
    f9f4:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f9f9:	e9 46 01 00 00       	jmp    fb44 <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f9fe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    fa02:	74 06                	je     fa0a <readChunk_iCCP+0xaa>
    fa04:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    fa08:	76 0a                	jbe    fa14 <readChunk_iCCP+0xb4>
    fa0a:	b8 59 00 00 00       	mov    $0x59,%eax
    fa0f:	e9 30 01 00 00       	jmp    fb44 <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    fa14:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fa17:	83 c0 01             	add    $0x1,%eax
    fa1a:	83 ec 0c             	sub    $0xc,%esp
    fa1d:	50                   	push   %eax
    fa1e:	e8 1a 40 ff ff       	call   3a3d <lodepng_malloc>
    fa23:	83 c4 10             	add    $0x10,%esp
    fa26:	89 c2                	mov    %eax,%edx
    fa28:	8b 45 08             	mov    0x8(%ebp),%eax
    fa2b:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    fa31:	8b 45 08             	mov    0x8(%ebp),%eax
    fa34:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    fa3a:	85 c0                	test   %eax,%eax
    fa3c:	75 0a                	jne    fa48 <readChunk_iCCP+0xe8>
    fa3e:	b8 53 00 00 00       	mov    $0x53,%eax
    fa43:	e9 fc 00 00 00       	jmp    fb44 <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    fa48:	8b 45 08             	mov    0x8(%ebp),%eax
    fa4b:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    fa51:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fa54:	01 d0                	add    %edx,%eax
    fa56:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    fa59:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    fa60:	eb 1f                	jmp    fa81 <readChunk_iCCP+0x121>
    fa62:	8b 45 08             	mov    0x8(%ebp),%eax
    fa65:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    fa6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fa6e:	01 d0                	add    %edx,%eax
    fa70:	8b 4d 10             	mov    0x10(%ebp),%ecx
    fa73:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fa76:	01 ca                	add    %ecx,%edx
    fa78:	0f b6 12             	movzbl (%edx),%edx
    fa7b:	88 10                	mov    %dl,(%eax)
    fa7d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    fa81:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fa84:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    fa87:	75 d9                	jne    fa62 <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    fa89:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fa8c:	8d 50 01             	lea    0x1(%eax),%edx
    fa8f:	8b 45 10             	mov    0x10(%ebp),%eax
    fa92:	01 d0                	add    %edx,%eax
    fa94:	0f b6 00             	movzbl (%eax),%eax
    fa97:	84 c0                	test   %al,%al
    fa99:	74 0a                	je     faa5 <readChunk_iCCP+0x145>
    fa9b:	b8 48 00 00 00       	mov    $0x48,%eax
    faa0:	e9 9f 00 00 00       	jmp    fb44 <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    faa5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    faa8:	83 c0 02             	add    $0x2,%eax
    faab:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    faae:	8b 45 14             	mov    0x14(%ebp),%eax
    fab1:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    fab4:	76 0a                	jbe    fac0 <readChunk_iCCP+0x160>
    fab6:	b8 4b 00 00 00       	mov    $0x4b,%eax
    fabb:	e9 84 00 00 00       	jmp    fb44 <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    fac0:	8b 45 14             	mov    0x14(%ebp),%eax
    fac3:	2b 45 e8             	sub    -0x18(%ebp),%eax
    fac6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    fac9:	8b 45 0c             	mov    0xc(%ebp),%eax
    facc:	8b 40 34             	mov    0x34(%eax),%eax
    facf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    fad2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fad5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    fad8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fadb:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    fade:	8b 55 08             	mov    0x8(%ebp),%edx
    fae1:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    fae7:	83 ec 08             	sub    $0x8,%esp
    faea:	8d 55 cc             	lea    -0x34(%ebp),%edx
    faed:	52                   	push   %edx
    faee:	50                   	push   %eax
    faef:	53                   	push   %ebx
    faf0:	6a 00                	push   $0x0
    faf2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    faf5:	50                   	push   %eax
    faf6:	51                   	push   %ecx
    faf7:	e8 fc 89 ff ff       	call   84f8 <zlib_decompress>
    fafc:	83 c4 20             	add    $0x20,%esp
    faff:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    fb02:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fb06:	74 11                	je     fb19 <readChunk_iCCP+0x1b9>
    fb08:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fb0b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fb0e:	39 c2                	cmp    %eax,%edx
    fb10:	7d 07                	jge    fb19 <readChunk_iCCP+0x1b9>
    fb12:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    fb19:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fb1c:	89 c2                	mov    %eax,%edx
    fb1e:	8b 45 08             	mov    0x8(%ebp),%eax
    fb21:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    fb27:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fb2b:	75 14                	jne    fb41 <readChunk_iCCP+0x1e1>
    fb2d:	8b 45 08             	mov    0x8(%ebp),%eax
    fb30:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    fb36:	85 c0                	test   %eax,%eax
    fb38:	75 07                	jne    fb41 <readChunk_iCCP+0x1e1>
    fb3a:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    fb41:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    fb44:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    fb47:	c9                   	leave  
    fb48:	c3                   	ret    

0000fb49 <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    fb49:	55                   	push   %ebp
    fb4a:	89 e5                	mov    %esp,%ebp
    fb4c:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    fb4f:	8b 55 0c             	mov    0xc(%ebp),%edx
    fb52:	8b 45 10             	mov    0x10(%ebp),%eax
    fb55:	01 d0                	add    %edx,%eax
    fb57:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    fb5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    fb61:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    fb68:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb6b:	83 c0 04             	add    $0x4,%eax
    fb6e:	3b 45 14             	cmp    0x14(%ebp),%eax
    fb71:	7e 0a                	jle    fb7d <lodepng_inspect_chunk+0x34>
    fb73:	b8 1e 00 00 00       	mov    $0x1e,%eax
    fb78:	e9 43 03 00 00       	jmp    fec0 <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    fb7d:	ff 75 ec             	pushl  -0x14(%ebp)
    fb80:	e8 3a 8e ff ff       	call   89bf <lodepng_chunk_length>
    fb85:	83 c4 04             	add    $0x4,%esp
    fb88:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    fb8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fb8e:	85 c0                	test   %eax,%eax
    fb90:	79 0a                	jns    fb9c <lodepng_inspect_chunk+0x53>
    fb92:	b8 3f 00 00 00       	mov    $0x3f,%eax
    fb97:	e9 24 03 00 00       	jmp    fec0 <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    fb9c:	ff 75 ec             	pushl  -0x14(%ebp)
    fb9f:	e8 53 8f ff ff       	call   8af7 <lodepng_chunk_data_const>
    fba4:	83 c4 04             	add    $0x4,%esp
    fba7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    fbaa:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fbad:	8d 50 04             	lea    0x4(%eax),%edx
    fbb0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fbb3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    fbb6:	8b 55 14             	mov    0x14(%ebp),%edx
    fbb9:	8b 45 10             	mov    0x10(%ebp),%eax
    fbbc:	01 d0                	add    %edx,%eax
    fbbe:	39 c1                	cmp    %eax,%ecx
    fbc0:	76 0a                	jbe    fbcc <lodepng_inspect_chunk+0x83>
    fbc2:	b8 1e 00 00 00       	mov    $0x1e,%eax
    fbc7:	e9 f4 02 00 00       	jmp    fec0 <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    fbcc:	68 a8 a7 01 00       	push   $0x1a7a8
    fbd1:	ff 75 ec             	pushl  -0x14(%ebp)
    fbd4:	e8 33 8e ff ff       	call   8a0c <lodepng_chunk_type_equals>
    fbd9:	83 c4 08             	add    $0x8,%esp
    fbdc:	84 c0                	test   %al,%al
    fbde:	74 24                	je     fc04 <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    fbe0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fbe3:	8b 55 08             	mov    0x8(%ebp),%edx
    fbe6:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fbec:	83 ec 04             	sub    $0x4,%esp
    fbef:	50                   	push   %eax
    fbf0:	ff 75 e4             	pushl  -0x1c(%ebp)
    fbf3:	52                   	push   %edx
    fbf4:	e8 5b ee ff ff       	call   ea54 <readChunk_PLTE>
    fbf9:	83 c4 10             	add    $0x10,%esp
    fbfc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fbff:	e9 8a 02 00 00       	jmp    fe8e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fc04:	83 ec 08             	sub    $0x8,%esp
    fc07:	68 ad a7 01 00       	push   $0x1a7ad
    fc0c:	ff 75 ec             	pushl  -0x14(%ebp)
    fc0f:	e8 f8 8d ff ff       	call   8a0c <lodepng_chunk_type_equals>
    fc14:	83 c4 10             	add    $0x10,%esp
    fc17:	84 c0                	test   %al,%al
    fc19:	74 24                	je     fc3f <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    fc1b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fc1e:	8b 55 08             	mov    0x8(%ebp),%edx
    fc21:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fc27:	83 ec 04             	sub    $0x4,%esp
    fc2a:	50                   	push   %eax
    fc2b:	ff 75 e4             	pushl  -0x1c(%ebp)
    fc2e:	52                   	push   %edx
    fc2f:	e8 40 ef ff ff       	call   eb74 <readChunk_tRNS>
    fc34:	83 c4 10             	add    $0x10,%esp
    fc37:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fc3a:	e9 4f 02 00 00       	jmp    fe8e <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    fc3f:	83 ec 08             	sub    $0x8,%esp
    fc42:	68 b2 a7 01 00       	push   $0x1a7b2
    fc47:	ff 75 ec             	pushl  -0x14(%ebp)
    fc4a:	e8 bd 8d ff ff       	call   8a0c <lodepng_chunk_type_equals>
    fc4f:	83 c4 10             	add    $0x10,%esp
    fc52:	84 c0                	test   %al,%al
    fc54:	74 24                	je     fc7a <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fc56:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fc59:	8b 55 08             	mov    0x8(%ebp),%edx
    fc5c:	81 c2 98 00 00 00    	add    $0x98,%edx
    fc62:	83 ec 04             	sub    $0x4,%esp
    fc65:	50                   	push   %eax
    fc66:	ff 75 e4             	pushl  -0x1c(%ebp)
    fc69:	52                   	push   %edx
    fc6a:	e8 68 f0 ff ff       	call   ecd7 <readChunk_bKGD>
    fc6f:	83 c4 10             	add    $0x10,%esp
    fc72:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fc75:	e9 14 02 00 00       	jmp    fe8e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fc7a:	83 ec 08             	sub    $0x8,%esp
    fc7d:	68 b7 a7 01 00       	push   $0x1a7b7
    fc82:	ff 75 ec             	pushl  -0x14(%ebp)
    fc85:	e8 82 8d ff ff       	call   8a0c <lodepng_chunk_type_equals>
    fc8a:	83 c4 10             	add    $0x10,%esp
    fc8d:	84 c0                	test   %al,%al
    fc8f:	74 24                	je     fcb5 <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    fc91:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fc94:	8b 55 08             	mov    0x8(%ebp),%edx
    fc97:	81 c2 98 00 00 00    	add    $0x98,%edx
    fc9d:	83 ec 04             	sub    $0x4,%esp
    fca0:	50                   	push   %eax
    fca1:	ff 75 e4             	pushl  -0x1c(%ebp)
    fca4:	52                   	push   %edx
    fca5:	e8 b0 f1 ff ff       	call   ee5a <readChunk_tEXt>
    fcaa:	83 c4 10             	add    $0x10,%esp
    fcad:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fcb0:	e9 d9 01 00 00       	jmp    fe8e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    fcb5:	83 ec 08             	sub    $0x8,%esp
    fcb8:	68 bc a7 01 00       	push   $0x1a7bc
    fcbd:	ff 75 ec             	pushl  -0x14(%ebp)
    fcc0:	e8 47 8d ff ff       	call   8a0c <lodepng_chunk_type_equals>
    fcc5:	83 c4 10             	add    $0x10,%esp
    fcc8:	84 c0                	test   %al,%al
    fcca:	74 25                	je     fcf1 <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    fccc:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fccf:	8b 45 08             	mov    0x8(%ebp),%eax
    fcd2:	8b 4d 08             	mov    0x8(%ebp),%ecx
    fcd5:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fcdb:	52                   	push   %edx
    fcdc:	ff 75 e4             	pushl  -0x1c(%ebp)
    fcdf:	50                   	push   %eax
    fce0:	51                   	push   %ecx
    fce1:	e8 c0 f2 ff ff       	call   efa6 <readChunk_zTXt>
    fce6:	83 c4 10             	add    $0x10,%esp
    fce9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fcec:	e9 9d 01 00 00       	jmp    fe8e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    fcf1:	83 ec 08             	sub    $0x8,%esp
    fcf4:	68 c1 a7 01 00       	push   $0x1a7c1
    fcf9:	ff 75 ec             	pushl  -0x14(%ebp)
    fcfc:	e8 0b 8d ff ff       	call   8a0c <lodepng_chunk_type_equals>
    fd01:	83 c4 10             	add    $0x10,%esp
    fd04:	84 c0                	test   %al,%al
    fd06:	74 25                	je     fd2d <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    fd08:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fd0b:	8b 45 08             	mov    0x8(%ebp),%eax
    fd0e:	8b 4d 08             	mov    0x8(%ebp),%ecx
    fd11:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fd17:	52                   	push   %edx
    fd18:	ff 75 e4             	pushl  -0x1c(%ebp)
    fd1b:	50                   	push   %eax
    fd1c:	51                   	push   %ecx
    fd1d:	e8 40 f4 ff ff       	call   f162 <readChunk_iTXt>
    fd22:	83 c4 10             	add    $0x10,%esp
    fd25:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fd28:	e9 61 01 00 00       	jmp    fe8e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    fd2d:	83 ec 08             	sub    $0x8,%esp
    fd30:	68 c6 a7 01 00       	push   $0x1a7c6
    fd35:	ff 75 ec             	pushl  -0x14(%ebp)
    fd38:	e8 cf 8c ff ff       	call   8a0c <lodepng_chunk_type_equals>
    fd3d:	83 c4 10             	add    $0x10,%esp
    fd40:	84 c0                	test   %al,%al
    fd42:	74 24                	je     fd68 <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    fd44:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fd47:	8b 55 08             	mov    0x8(%ebp),%edx
    fd4a:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd50:	83 ec 04             	sub    $0x4,%esp
    fd53:	50                   	push   %eax
    fd54:	ff 75 e4             	pushl  -0x1c(%ebp)
    fd57:	52                   	push   %edx
    fd58:	e8 5b f7 ff ff       	call   f4b8 <readChunk_tIME>
    fd5d:	83 c4 10             	add    $0x10,%esp
    fd60:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fd63:	e9 26 01 00 00       	jmp    fe8e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    fd68:	83 ec 08             	sub    $0x8,%esp
    fd6b:	68 cb a7 01 00       	push   $0x1a7cb
    fd70:	ff 75 ec             	pushl  -0x14(%ebp)
    fd73:	e8 94 8c ff ff       	call   8a0c <lodepng_chunk_type_equals>
    fd78:	83 c4 10             	add    $0x10,%esp
    fd7b:	84 c0                	test   %al,%al
    fd7d:	74 24                	je     fda3 <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    fd7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fd82:	8b 55 08             	mov    0x8(%ebp),%edx
    fd85:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd8b:	83 ec 04             	sub    $0x4,%esp
    fd8e:	50                   	push   %eax
    fd8f:	ff 75 e4             	pushl  -0x1c(%ebp)
    fd92:	52                   	push   %edx
    fd93:	e8 c0 f7 ff ff       	call   f558 <readChunk_pHYs>
    fd98:	83 c4 10             	add    $0x10,%esp
    fd9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fd9e:	e9 eb 00 00 00       	jmp    fe8e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    fda3:	83 ec 08             	sub    $0x8,%esp
    fda6:	68 d0 a7 01 00       	push   $0x1a7d0
    fdab:	ff 75 ec             	pushl  -0x14(%ebp)
    fdae:	e8 59 8c ff ff       	call   8a0c <lodepng_chunk_type_equals>
    fdb3:	83 c4 10             	add    $0x10,%esp
    fdb6:	84 c0                	test   %al,%al
    fdb8:	74 24                	je     fdde <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    fdba:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fdbd:	8b 55 08             	mov    0x8(%ebp),%edx
    fdc0:	81 c2 98 00 00 00    	add    $0x98,%edx
    fdc6:	83 ec 04             	sub    $0x4,%esp
    fdc9:	50                   	push   %eax
    fdca:	ff 75 e4             	pushl  -0x1c(%ebp)
    fdcd:	52                   	push   %edx
    fdce:	e8 54 f8 ff ff       	call   f627 <readChunk_gAMA>
    fdd3:	83 c4 10             	add    $0x10,%esp
    fdd6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fdd9:	e9 b0 00 00 00       	jmp    fe8e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    fdde:	83 ec 08             	sub    $0x8,%esp
    fde1:	68 d5 a7 01 00       	push   $0x1a7d5
    fde6:	ff 75 ec             	pushl  -0x14(%ebp)
    fde9:	e8 1e 8c ff ff       	call   8a0c <lodepng_chunk_type_equals>
    fdee:	83 c4 10             	add    $0x10,%esp
    fdf1:	84 c0                	test   %al,%al
    fdf3:	74 21                	je     fe16 <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    fdf5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fdf8:	8b 55 08             	mov    0x8(%ebp),%edx
    fdfb:	81 c2 98 00 00 00    	add    $0x98,%edx
    fe01:	83 ec 04             	sub    $0x4,%esp
    fe04:	50                   	push   %eax
    fe05:	ff 75 e4             	pushl  -0x1c(%ebp)
    fe08:	52                   	push   %edx
    fe09:	e8 88 f8 ff ff       	call   f696 <readChunk_cHRM>
    fe0e:	83 c4 10             	add    $0x10,%esp
    fe11:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fe14:	eb 78                	jmp    fe8e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    fe16:	83 ec 08             	sub    $0x8,%esp
    fe19:	68 da a7 01 00       	push   $0x1a7da
    fe1e:	ff 75 ec             	pushl  -0x14(%ebp)
    fe21:	e8 e6 8b ff ff       	call   8a0c <lodepng_chunk_type_equals>
    fe26:	83 c4 10             	add    $0x10,%esp
    fe29:	84 c0                	test   %al,%al
    fe2b:	74 21                	je     fe4e <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    fe2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fe30:	8b 55 08             	mov    0x8(%ebp),%edx
    fe33:	81 c2 98 00 00 00    	add    $0x98,%edx
    fe39:	83 ec 04             	sub    $0x4,%esp
    fe3c:	50                   	push   %eax
    fe3d:	ff 75 e4             	pushl  -0x1c(%ebp)
    fe40:	52                   	push   %edx
    fe41:	e8 e4 fa ff ff       	call   f92a <readChunk_sRGB>
    fe46:	83 c4 10             	add    $0x10,%esp
    fe49:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fe4c:	eb 40                	jmp    fe8e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    fe4e:	83 ec 08             	sub    $0x8,%esp
    fe51:	68 df a7 01 00       	push   $0x1a7df
    fe56:	ff 75 ec             	pushl  -0x14(%ebp)
    fe59:	e8 ae 8b ff ff       	call   8a0c <lodepng_chunk_type_equals>
    fe5e:	83 c4 10             	add    $0x10,%esp
    fe61:	84 c0                	test   %al,%al
    fe63:	74 22                	je     fe87 <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    fe65:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fe68:	8b 45 08             	mov    0x8(%ebp),%eax
    fe6b:	8b 4d 08             	mov    0x8(%ebp),%ecx
    fe6e:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fe74:	52                   	push   %edx
    fe75:	ff 75 e4             	pushl  -0x1c(%ebp)
    fe78:	50                   	push   %eax
    fe79:	51                   	push   %ecx
    fe7a:	e8 e1 fa ff ff       	call   f960 <readChunk_iCCP>
    fe7f:	83 c4 10             	add    $0x10,%esp
    fe82:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fe85:	eb 07                	jmp    fe8e <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    fe87:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    fe8e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    fe92:	75 29                	jne    febd <lodepng_inspect_chunk+0x374>
    fe94:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fe98:	75 23                	jne    febd <lodepng_inspect_chunk+0x374>
    fe9a:	8b 45 08             	mov    0x8(%ebp),%eax
    fe9d:	8b 40 18             	mov    0x18(%eax),%eax
    fea0:	85 c0                	test   %eax,%eax
    fea2:	75 19                	jne    febd <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    fea4:	83 ec 0c             	sub    $0xc,%esp
    fea7:	ff 75 ec             	pushl  -0x14(%ebp)
    feaa:	e8 53 8c ff ff       	call   8b02 <lodepng_chunk_check_crc>
    feaf:	83 c4 10             	add    $0x10,%esp
    feb2:	85 c0                	test   %eax,%eax
    feb4:	74 07                	je     febd <lodepng_inspect_chunk+0x374>
    feb6:	b8 39 00 00 00       	mov    $0x39,%eax
    febb:	eb 03                	jmp    fec0 <lodepng_inspect_chunk+0x377>
  }

  return error;
    febd:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    fec0:	c9                   	leave  
    fec1:	c3                   	ret    

0000fec2 <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    fec2:	55                   	push   %ebp
    fec3:	89 e5                	mov    %esp,%ebp
    fec5:	56                   	push   %esi
    fec6:	53                   	push   %ebx
    fec7:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    feca:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    fece:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    fed5:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    fedc:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    fee3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    feea:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    fef1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    fef8:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    feff:	8b 45 08             	mov    0x8(%ebp),%eax
    ff02:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    ff08:	8b 45 10             	mov    0x10(%ebp),%eax
    ff0b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    ff11:	8b 45 10             	mov    0x10(%ebp),%eax
    ff14:	8b 10                	mov    (%eax),%edx
    ff16:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff19:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    ff1b:	83 ec 0c             	sub    $0xc,%esp
    ff1e:	ff 75 1c             	pushl  0x1c(%ebp)
    ff21:	ff 75 18             	pushl  0x18(%ebp)
    ff24:	ff 75 14             	pushl  0x14(%ebp)
    ff27:	ff 75 10             	pushl  0x10(%ebp)
    ff2a:	ff 75 0c             	pushl  0xc(%ebp)
    ff2d:	e8 d3 da ff ff       	call   da05 <lodepng_inspect>
    ff32:	83 c4 20             	add    $0x20,%esp
    ff35:	89 c2                	mov    %eax,%edx
    ff37:	8b 45 14             	mov    0x14(%ebp),%eax
    ff3a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    ff40:	8b 45 14             	mov    0x14(%ebp),%eax
    ff43:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff49:	85 c0                	test   %eax,%eax
    ff4b:	0f 85 24 0a 00 00    	jne    10975 <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    ff51:	8b 45 14             	mov    0x14(%ebp),%eax
    ff54:	8d 58 78             	lea    0x78(%eax),%ebx
    ff57:	8b 45 14             	mov    0x14(%ebp),%eax
    ff5a:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    ff60:	8b 45 10             	mov    0x10(%ebp),%eax
    ff63:	8b 10                	mov    (%eax),%edx
    ff65:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff68:	8b 00                	mov    (%eax),%eax
    ff6a:	53                   	push   %ebx
    ff6b:	51                   	push   %ecx
    ff6c:	52                   	push   %edx
    ff6d:	50                   	push   %eax
    ff6e:	e8 76 97 ff ff       	call   96e9 <lodepng_pixel_overflow>
    ff73:	83 c4 10             	add    $0x10,%esp
    ff76:	85 c0                	test   %eax,%eax
    ff78:	74 12                	je     ff8c <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    ff7a:	8b 45 14             	mov    0x14(%ebp),%eax
    ff7d:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    ff84:	00 00 00 
    ff87:	e9 ea 09 00 00       	jmp    10976 <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    ff8c:	83 ec 0c             	sub    $0xc,%esp
    ff8f:	ff 75 1c             	pushl  0x1c(%ebp)
    ff92:	e8 a6 3a ff ff       	call   3a3d <lodepng_malloc>
    ff97:	83 c4 10             	add    $0x10,%esp
    ff9a:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    ff9d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    ffa1:	75 12                	jne    ffb5 <decodeGeneric+0xf3>
    ffa3:	8b 45 14             	mov    0x14(%ebp),%eax
    ffa6:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    ffad:	00 00 00 
    ffb0:	e9 c1 09 00 00       	jmp    10976 <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    ffb5:	8b 45 18             	mov    0x18(%ebp),%eax
    ffb8:	83 c0 21             	add    $0x21,%eax
    ffbb:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    ffbe:	e9 81 06 00 00       	jmp    10644 <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    ffc3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ffc6:	8b 45 18             	mov    0x18(%ebp),%eax
    ffc9:	29 c2                	sub    %eax,%edx
    ffcb:	89 d0                	mov    %edx,%eax
    ffcd:	83 c0 0c             	add    $0xc,%eax
    ffd0:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ffd3:	7f 08                	jg     ffdd <decodeGeneric+0x11b>
    ffd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ffd8:	3b 45 18             	cmp    0x18(%ebp),%eax
    ffdb:	73 20                	jae    fffd <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ffdd:	8b 45 14             	mov    0x14(%ebp),%eax
    ffe0:	8b 40 20             	mov    0x20(%eax),%eax
    ffe3:	85 c0                	test   %eax,%eax
    ffe5:	0f 85 72 06 00 00    	jne    1065d <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    ffeb:	8b 45 14             	mov    0x14(%ebp),%eax
    ffee:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    fff5:	00 00 00 
    fff8:	e9 6a 06 00 00       	jmp    10667 <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    fffd:	83 ec 0c             	sub    $0xc,%esp
   10000:	ff 75 f0             	pushl  -0x10(%ebp)
   10003:	e8 b7 89 ff ff       	call   89bf <lodepng_chunk_length>
   10008:	83 c4 10             	add    $0x10,%esp
   1000b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
   1000e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10011:	85 c0                	test   %eax,%eax
   10013:	79 20                	jns    10035 <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   10015:	8b 45 14             	mov    0x14(%ebp),%eax
   10018:	8b 40 20             	mov    0x20(%eax),%eax
   1001b:	85 c0                	test   %eax,%eax
   1001d:	0f 85 3d 06 00 00    	jne    10660 <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
   10023:	8b 45 14             	mov    0x14(%ebp),%eax
   10026:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
   1002d:	00 00 00 
   10030:	e9 32 06 00 00       	jmp    10667 <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
   10035:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10038:	8b 45 18             	mov    0x18(%ebp),%eax
   1003b:	29 c2                	sub    %eax,%edx
   1003d:	89 d0                	mov    %edx,%eax
   1003f:	89 c2                	mov    %eax,%edx
   10041:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10044:	01 d0                	add    %edx,%eax
   10046:	83 c0 0c             	add    $0xc,%eax
   10049:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   1004c:	7f 10                	jg     1005e <decodeGeneric+0x19c>
   1004e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10051:	8d 50 0c             	lea    0xc(%eax),%edx
   10054:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10057:	01 d0                	add    %edx,%eax
   10059:	3b 45 18             	cmp    0x18(%ebp),%eax
   1005c:	73 12                	jae    10070 <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
   1005e:	8b 45 14             	mov    0x14(%ebp),%eax
   10061:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
   10068:	00 00 00 
   1006b:	e9 f7 05 00 00       	jmp    10667 <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
   10070:	83 ec 0c             	sub    $0xc,%esp
   10073:	ff 75 f0             	pushl  -0x10(%ebp)
   10076:	e8 7c 8a ff ff       	call   8af7 <lodepng_chunk_data_const>
   1007b:	83 c4 10             	add    $0x10,%esp
   1007e:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
   10081:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
   10088:	83 ec 08             	sub    $0x8,%esp
   1008b:	68 e4 a7 01 00       	push   $0x1a7e4
   10090:	ff 75 f0             	pushl  -0x10(%ebp)
   10093:	e8 74 89 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   10098:	83 c4 10             	add    $0x10,%esp
   1009b:	84 c0                	test   %al,%al
   1009d:	74 79                	je     10118 <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
   1009f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   100a2:	83 ec 04             	sub    $0x4,%esp
   100a5:	8d 55 bc             	lea    -0x44(%ebp),%edx
   100a8:	52                   	push   %edx
   100a9:	50                   	push   %eax
   100aa:	ff 75 ec             	pushl  -0x14(%ebp)
   100ad:	e8 4f 3a ff ff       	call   3b01 <lodepng_addofl>
   100b2:	83 c4 10             	add    $0x10,%esp
   100b5:	85 c0                	test   %eax,%eax
   100b7:	74 12                	je     100cb <decodeGeneric+0x209>
   100b9:	8b 45 14             	mov    0x14(%ebp),%eax
   100bc:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
   100c3:	00 00 00 
   100c6:	e9 9c 05 00 00       	jmp    10667 <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
   100cb:	8b 45 bc             	mov    -0x44(%ebp),%eax
   100ce:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   100d1:	7e 13                	jle    100e6 <decodeGeneric+0x224>
   100d3:	8b 45 14             	mov    0x14(%ebp),%eax
   100d6:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
   100dd:	00 00 00 
   100e0:	90                   	nop
   100e1:	e9 81 05 00 00       	jmp    10667 <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
   100e6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   100e9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   100ec:	8b 55 d8             	mov    -0x28(%ebp),%edx
   100ef:	01 ca                	add    %ecx,%edx
   100f1:	83 ec 04             	sub    $0x4,%esp
   100f4:	50                   	push   %eax
   100f5:	ff 75 d0             	pushl  -0x30(%ebp)
   100f8:	52                   	push   %edx
   100f9:	e8 7d 39 ff ff       	call   3a7b <lodepng_memcpy>
   100fe:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
   10101:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10104:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10107:	01 d0                	add    %edx,%eax
   10109:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
   1010c:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
   10113:	e9 db 04 00 00       	jmp    105f3 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
   10118:	83 ec 08             	sub    $0x8,%esp
   1011b:	68 e9 a7 01 00       	push   $0x1a7e9
   10120:	ff 75 f0             	pushl  -0x10(%ebp)
   10123:	e8 e4 88 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   10128:	83 c4 10             	add    $0x10,%esp
   1012b:	84 c0                	test   %al,%al
   1012d:	74 09                	je     10138 <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
   1012f:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
   10133:	e9 bb 04 00 00       	jmp    105f3 <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
   10138:	83 ec 08             	sub    $0x8,%esp
   1013b:	68 a8 a7 01 00       	push   $0x1a7a8
   10140:	ff 75 f0             	pushl  -0x10(%ebp)
   10143:	e8 c4 88 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   10148:	83 c4 10             	add    $0x10,%esp
   1014b:	84 c0                	test   %al,%al
   1014d:	74 44                	je     10193 <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
   1014f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10152:	8b 55 14             	mov    0x14(%ebp),%edx
   10155:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   1015b:	83 ec 04             	sub    $0x4,%esp
   1015e:	50                   	push   %eax
   1015f:	ff 75 d0             	pushl  -0x30(%ebp)
   10162:	52                   	push   %edx
   10163:	e8 ec e8 ff ff       	call   ea54 <readChunk_PLTE>
   10168:	83 c4 10             	add    $0x10,%esp
   1016b:	89 c2                	mov    %eax,%edx
   1016d:	8b 45 14             	mov    0x14(%ebp),%eax
   10170:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10176:	8b 45 14             	mov    0x14(%ebp),%eax
   10179:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1017f:	85 c0                	test   %eax,%eax
   10181:	0f 85 dc 04 00 00    	jne    10663 <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
   10187:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
   1018e:	e9 60 04 00 00       	jmp    105f3 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
   10193:	83 ec 08             	sub    $0x8,%esp
   10196:	68 ad a7 01 00       	push   $0x1a7ad
   1019b:	ff 75 f0             	pushl  -0x10(%ebp)
   1019e:	e8 69 88 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   101a3:	83 c4 10             	add    $0x10,%esp
   101a6:	84 c0                	test   %al,%al
   101a8:	74 3d                	je     101e7 <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
   101aa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   101ad:	8b 55 14             	mov    0x14(%ebp),%edx
   101b0:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   101b6:	83 ec 04             	sub    $0x4,%esp
   101b9:	50                   	push   %eax
   101ba:	ff 75 d0             	pushl  -0x30(%ebp)
   101bd:	52                   	push   %edx
   101be:	e8 b1 e9 ff ff       	call   eb74 <readChunk_tRNS>
   101c3:	83 c4 10             	add    $0x10,%esp
   101c6:	89 c2                	mov    %eax,%edx
   101c8:	8b 45 14             	mov    0x14(%ebp),%eax
   101cb:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   101d1:	8b 45 14             	mov    0x14(%ebp),%eax
   101d4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   101da:	85 c0                	test   %eax,%eax
   101dc:	0f 84 11 04 00 00    	je     105f3 <decodeGeneric+0x731>
   101e2:	e9 80 04 00 00       	jmp    10667 <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
   101e7:	83 ec 08             	sub    $0x8,%esp
   101ea:	68 b2 a7 01 00       	push   $0x1a7b2
   101ef:	ff 75 f0             	pushl  -0x10(%ebp)
   101f2:	e8 15 88 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   101f7:	83 c4 10             	add    $0x10,%esp
   101fa:	84 c0                	test   %al,%al
   101fc:	74 3d                	je     1023b <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
   101fe:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10201:	8b 55 14             	mov    0x14(%ebp),%edx
   10204:	81 c2 98 00 00 00    	add    $0x98,%edx
   1020a:	83 ec 04             	sub    $0x4,%esp
   1020d:	50                   	push   %eax
   1020e:	ff 75 d0             	pushl  -0x30(%ebp)
   10211:	52                   	push   %edx
   10212:	e8 c0 ea ff ff       	call   ecd7 <readChunk_bKGD>
   10217:	83 c4 10             	add    $0x10,%esp
   1021a:	89 c2                	mov    %eax,%edx
   1021c:	8b 45 14             	mov    0x14(%ebp),%eax
   1021f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10225:	8b 45 14             	mov    0x14(%ebp),%eax
   10228:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1022e:	85 c0                	test   %eax,%eax
   10230:	0f 84 bd 03 00 00    	je     105f3 <decodeGeneric+0x731>
   10236:	e9 2c 04 00 00       	jmp    10667 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
   1023b:	83 ec 08             	sub    $0x8,%esp
   1023e:	68 b7 a7 01 00       	push   $0x1a7b7
   10243:	ff 75 f0             	pushl  -0x10(%ebp)
   10246:	e8 c1 87 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   1024b:	83 c4 10             	add    $0x10,%esp
   1024e:	84 c0                	test   %al,%al
   10250:	74 4b                	je     1029d <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
   10252:	8b 45 14             	mov    0x14(%ebp),%eax
   10255:	8b 40 28             	mov    0x28(%eax),%eax
   10258:	85 c0                	test   %eax,%eax
   1025a:	0f 84 93 03 00 00    	je     105f3 <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
   10260:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10263:	8b 55 14             	mov    0x14(%ebp),%edx
   10266:	81 c2 98 00 00 00    	add    $0x98,%edx
   1026c:	83 ec 04             	sub    $0x4,%esp
   1026f:	50                   	push   %eax
   10270:	ff 75 d0             	pushl  -0x30(%ebp)
   10273:	52                   	push   %edx
   10274:	e8 e1 eb ff ff       	call   ee5a <readChunk_tEXt>
   10279:	83 c4 10             	add    $0x10,%esp
   1027c:	89 c2                	mov    %eax,%edx
   1027e:	8b 45 14             	mov    0x14(%ebp),%eax
   10281:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   10287:	8b 45 14             	mov    0x14(%ebp),%eax
   1028a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10290:	85 c0                	test   %eax,%eax
   10292:	0f 84 5b 03 00 00    	je     105f3 <decodeGeneric+0x731>
   10298:	e9 ca 03 00 00       	jmp    10667 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
   1029d:	83 ec 08             	sub    $0x8,%esp
   102a0:	68 bc a7 01 00       	push   $0x1a7bc
   102a5:	ff 75 f0             	pushl  -0x10(%ebp)
   102a8:	e8 5f 87 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   102ad:	83 c4 10             	add    $0x10,%esp
   102b0:	84 c0                	test   %al,%al
   102b2:	74 4c                	je     10300 <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
   102b4:	8b 45 14             	mov    0x14(%ebp),%eax
   102b7:	8b 40 28             	mov    0x28(%eax),%eax
   102ba:	85 c0                	test   %eax,%eax
   102bc:	0f 84 31 03 00 00    	je     105f3 <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
   102c2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   102c5:	8b 45 14             	mov    0x14(%ebp),%eax
   102c8:	8b 4d 14             	mov    0x14(%ebp),%ecx
   102cb:	81 c1 98 00 00 00    	add    $0x98,%ecx
   102d1:	52                   	push   %edx
   102d2:	ff 75 d0             	pushl  -0x30(%ebp)
   102d5:	50                   	push   %eax
   102d6:	51                   	push   %ecx
   102d7:	e8 ca ec ff ff       	call   efa6 <readChunk_zTXt>
   102dc:	83 c4 10             	add    $0x10,%esp
   102df:	89 c2                	mov    %eax,%edx
   102e1:	8b 45 14             	mov    0x14(%ebp),%eax
   102e4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   102ea:	8b 45 14             	mov    0x14(%ebp),%eax
   102ed:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   102f3:	85 c0                	test   %eax,%eax
   102f5:	0f 84 f8 02 00 00    	je     105f3 <decodeGeneric+0x731>
   102fb:	e9 67 03 00 00       	jmp    10667 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
   10300:	83 ec 08             	sub    $0x8,%esp
   10303:	68 c1 a7 01 00       	push   $0x1a7c1
   10308:	ff 75 f0             	pushl  -0x10(%ebp)
   1030b:	e8 fc 86 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   10310:	83 c4 10             	add    $0x10,%esp
   10313:	84 c0                	test   %al,%al
   10315:	74 4c                	je     10363 <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
   10317:	8b 45 14             	mov    0x14(%ebp),%eax
   1031a:	8b 40 28             	mov    0x28(%eax),%eax
   1031d:	85 c0                	test   %eax,%eax
   1031f:	0f 84 ce 02 00 00    	je     105f3 <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
   10325:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   10328:	8b 45 14             	mov    0x14(%ebp),%eax
   1032b:	8b 4d 14             	mov    0x14(%ebp),%ecx
   1032e:	81 c1 98 00 00 00    	add    $0x98,%ecx
   10334:	52                   	push   %edx
   10335:	ff 75 d0             	pushl  -0x30(%ebp)
   10338:	50                   	push   %eax
   10339:	51                   	push   %ecx
   1033a:	e8 23 ee ff ff       	call   f162 <readChunk_iTXt>
   1033f:	83 c4 10             	add    $0x10,%esp
   10342:	89 c2                	mov    %eax,%edx
   10344:	8b 45 14             	mov    0x14(%ebp),%eax
   10347:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   1034d:	8b 45 14             	mov    0x14(%ebp),%eax
   10350:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10356:	85 c0                	test   %eax,%eax
   10358:	0f 84 95 02 00 00    	je     105f3 <decodeGeneric+0x731>
   1035e:	e9 04 03 00 00       	jmp    10667 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
   10363:	83 ec 08             	sub    $0x8,%esp
   10366:	68 c6 a7 01 00       	push   $0x1a7c6
   1036b:	ff 75 f0             	pushl  -0x10(%ebp)
   1036e:	e8 99 86 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   10373:	83 c4 10             	add    $0x10,%esp
   10376:	84 c0                	test   %al,%al
   10378:	74 3d                	je     103b7 <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
   1037a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1037d:	8b 55 14             	mov    0x14(%ebp),%edx
   10380:	81 c2 98 00 00 00    	add    $0x98,%edx
   10386:	83 ec 04             	sub    $0x4,%esp
   10389:	50                   	push   %eax
   1038a:	ff 75 d0             	pushl  -0x30(%ebp)
   1038d:	52                   	push   %edx
   1038e:	e8 25 f1 ff ff       	call   f4b8 <readChunk_tIME>
   10393:	83 c4 10             	add    $0x10,%esp
   10396:	89 c2                	mov    %eax,%edx
   10398:	8b 45 14             	mov    0x14(%ebp),%eax
   1039b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   103a1:	8b 45 14             	mov    0x14(%ebp),%eax
   103a4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   103aa:	85 c0                	test   %eax,%eax
   103ac:	0f 84 41 02 00 00    	je     105f3 <decodeGeneric+0x731>
   103b2:	e9 b0 02 00 00       	jmp    10667 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
   103b7:	83 ec 08             	sub    $0x8,%esp
   103ba:	68 cb a7 01 00       	push   $0x1a7cb
   103bf:	ff 75 f0             	pushl  -0x10(%ebp)
   103c2:	e8 45 86 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   103c7:	83 c4 10             	add    $0x10,%esp
   103ca:	84 c0                	test   %al,%al
   103cc:	74 3d                	je     1040b <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
   103ce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   103d1:	8b 55 14             	mov    0x14(%ebp),%edx
   103d4:	81 c2 98 00 00 00    	add    $0x98,%edx
   103da:	83 ec 04             	sub    $0x4,%esp
   103dd:	50                   	push   %eax
   103de:	ff 75 d0             	pushl  -0x30(%ebp)
   103e1:	52                   	push   %edx
   103e2:	e8 71 f1 ff ff       	call   f558 <readChunk_pHYs>
   103e7:	83 c4 10             	add    $0x10,%esp
   103ea:	89 c2                	mov    %eax,%edx
   103ec:	8b 45 14             	mov    0x14(%ebp),%eax
   103ef:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   103f5:	8b 45 14             	mov    0x14(%ebp),%eax
   103f8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   103fe:	85 c0                	test   %eax,%eax
   10400:	0f 84 ed 01 00 00    	je     105f3 <decodeGeneric+0x731>
   10406:	e9 5c 02 00 00       	jmp    10667 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
   1040b:	83 ec 08             	sub    $0x8,%esp
   1040e:	68 d0 a7 01 00       	push   $0x1a7d0
   10413:	ff 75 f0             	pushl  -0x10(%ebp)
   10416:	e8 f1 85 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   1041b:	83 c4 10             	add    $0x10,%esp
   1041e:	84 c0                	test   %al,%al
   10420:	74 3d                	je     1045f <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
   10422:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10425:	8b 55 14             	mov    0x14(%ebp),%edx
   10428:	81 c2 98 00 00 00    	add    $0x98,%edx
   1042e:	83 ec 04             	sub    $0x4,%esp
   10431:	50                   	push   %eax
   10432:	ff 75 d0             	pushl  -0x30(%ebp)
   10435:	52                   	push   %edx
   10436:	e8 ec f1 ff ff       	call   f627 <readChunk_gAMA>
   1043b:	83 c4 10             	add    $0x10,%esp
   1043e:	89 c2                	mov    %eax,%edx
   10440:	8b 45 14             	mov    0x14(%ebp),%eax
   10443:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10449:	8b 45 14             	mov    0x14(%ebp),%eax
   1044c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10452:	85 c0                	test   %eax,%eax
   10454:	0f 84 99 01 00 00    	je     105f3 <decodeGeneric+0x731>
   1045a:	e9 08 02 00 00       	jmp    10667 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   1045f:	83 ec 08             	sub    $0x8,%esp
   10462:	68 d5 a7 01 00       	push   $0x1a7d5
   10467:	ff 75 f0             	pushl  -0x10(%ebp)
   1046a:	e8 9d 85 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   1046f:	83 c4 10             	add    $0x10,%esp
   10472:	84 c0                	test   %al,%al
   10474:	74 3d                	je     104b3 <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
   10476:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10479:	8b 55 14             	mov    0x14(%ebp),%edx
   1047c:	81 c2 98 00 00 00    	add    $0x98,%edx
   10482:	83 ec 04             	sub    $0x4,%esp
   10485:	50                   	push   %eax
   10486:	ff 75 d0             	pushl  -0x30(%ebp)
   10489:	52                   	push   %edx
   1048a:	e8 07 f2 ff ff       	call   f696 <readChunk_cHRM>
   1048f:	83 c4 10             	add    $0x10,%esp
   10492:	89 c2                	mov    %eax,%edx
   10494:	8b 45 14             	mov    0x14(%ebp),%eax
   10497:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   1049d:	8b 45 14             	mov    0x14(%ebp),%eax
   104a0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   104a6:	85 c0                	test   %eax,%eax
   104a8:	0f 84 45 01 00 00    	je     105f3 <decodeGeneric+0x731>
   104ae:	e9 b4 01 00 00       	jmp    10667 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   104b3:	83 ec 08             	sub    $0x8,%esp
   104b6:	68 da a7 01 00       	push   $0x1a7da
   104bb:	ff 75 f0             	pushl  -0x10(%ebp)
   104be:	e8 49 85 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   104c3:	83 c4 10             	add    $0x10,%esp
   104c6:	84 c0                	test   %al,%al
   104c8:	74 3d                	je     10507 <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
   104ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   104cd:	8b 55 14             	mov    0x14(%ebp),%edx
   104d0:	81 c2 98 00 00 00    	add    $0x98,%edx
   104d6:	83 ec 04             	sub    $0x4,%esp
   104d9:	50                   	push   %eax
   104da:	ff 75 d0             	pushl  -0x30(%ebp)
   104dd:	52                   	push   %edx
   104de:	e8 47 f4 ff ff       	call   f92a <readChunk_sRGB>
   104e3:	83 c4 10             	add    $0x10,%esp
   104e6:	89 c2                	mov    %eax,%edx
   104e8:	8b 45 14             	mov    0x14(%ebp),%eax
   104eb:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   104f1:	8b 45 14             	mov    0x14(%ebp),%eax
   104f4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   104fa:	85 c0                	test   %eax,%eax
   104fc:	0f 84 f1 00 00 00    	je     105f3 <decodeGeneric+0x731>
   10502:	e9 60 01 00 00       	jmp    10667 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   10507:	83 ec 08             	sub    $0x8,%esp
   1050a:	68 df a7 01 00       	push   $0x1a7df
   1050f:	ff 75 f0             	pushl  -0x10(%ebp)
   10512:	e8 f5 84 ff ff       	call   8a0c <lodepng_chunk_type_equals>
   10517:	83 c4 10             	add    $0x10,%esp
   1051a:	84 c0                	test   %al,%al
   1051c:	74 3e                	je     1055c <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   1051e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   10521:	8b 45 14             	mov    0x14(%ebp),%eax
   10524:	8b 4d 14             	mov    0x14(%ebp),%ecx
   10527:	81 c1 98 00 00 00    	add    $0x98,%ecx
   1052d:	52                   	push   %edx
   1052e:	ff 75 d0             	pushl  -0x30(%ebp)
   10531:	50                   	push   %eax
   10532:	51                   	push   %ecx
   10533:	e8 28 f4 ff ff       	call   f960 <readChunk_iCCP>
   10538:	83 c4 10             	add    $0x10,%esp
   1053b:	89 c2                	mov    %eax,%edx
   1053d:	8b 45 14             	mov    0x14(%ebp),%eax
   10540:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10546:	8b 45 14             	mov    0x14(%ebp),%eax
   10549:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1054f:	85 c0                	test   %eax,%eax
   10551:	0f 84 9c 00 00 00    	je     105f3 <decodeGeneric+0x731>
   10557:	e9 0b 01 00 00       	jmp    10667 <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
   1055c:	8b 45 14             	mov    0x14(%ebp),%eax
   1055f:	8b 40 1c             	mov    0x1c(%eax),%eax
   10562:	85 c0                	test   %eax,%eax
   10564:	75 24                	jne    1058a <decodeGeneric+0x6c8>
   10566:	83 ec 0c             	sub    $0xc,%esp
   10569:	ff 75 f0             	pushl  -0x10(%ebp)
   1056c:	e8 30 85 ff ff       	call   8aa1 <lodepng_chunk_ancillary>
   10571:	83 c4 10             	add    $0x10,%esp
   10574:	84 c0                	test   %al,%al
   10576:	75 12                	jne    1058a <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
   10578:	8b 45 14             	mov    0x14(%ebp),%eax
   1057b:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
   10582:	00 00 00 
   10585:	e9 dd 00 00 00       	jmp    10667 <decodeGeneric+0x7a5>
      }

      unknown = 1;
   1058a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
   10591:	8b 45 14             	mov    0x14(%ebp),%eax
   10594:	8b 40 2c             	mov    0x2c(%eax),%eax
   10597:	85 c0                	test   %eax,%eax
   10599:	74 58                	je     105f3 <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
   1059b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1059e:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
   105a1:	83 c0 58             	add    $0x58,%eax
   105a4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   105ab:	8b 45 14             	mov    0x14(%ebp),%eax
   105ae:	01 d0                	add    %edx,%eax
   105b0:	8d 50 10             	lea    0x10(%eax),%edx
   105b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   105b6:	83 e8 01             	sub    $0x1,%eax
   105b9:	83 c0 54             	add    $0x54,%eax
   105bc:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   105c3:	8b 45 14             	mov    0x14(%ebp),%eax
   105c6:	01 c8                	add    %ecx,%eax
   105c8:	83 c0 14             	add    $0x14,%eax
   105cb:	83 ec 04             	sub    $0x4,%esp
   105ce:	ff 75 f0             	pushl  -0x10(%ebp)
   105d1:	52                   	push   %edx
   105d2:	50                   	push   %eax
   105d3:	e8 15 88 ff ff       	call   8ded <lodepng_chunk_append>
   105d8:	83 c4 10             	add    $0x10,%esp
   105db:	89 c2                	mov    %eax,%edx
   105dd:	8b 45 14             	mov    0x14(%ebp),%eax
   105e0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   105e6:	8b 45 14             	mov    0x14(%ebp),%eax
   105e9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   105ef:	85 c0                	test   %eax,%eax
   105f1:	75 73                	jne    10666 <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
   105f3:	8b 45 14             	mov    0x14(%ebp),%eax
   105f6:	8b 40 18             	mov    0x18(%eax),%eax
   105f9:	85 c0                	test   %eax,%eax
   105fb:	75 27                	jne    10624 <decodeGeneric+0x762>
   105fd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10601:	75 21                	jne    10624 <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
   10603:	83 ec 0c             	sub    $0xc,%esp
   10606:	ff 75 f0             	pushl  -0x10(%ebp)
   10609:	e8 f4 84 ff ff       	call   8b02 <lodepng_chunk_check_crc>
   1060e:	83 c4 10             	add    $0x10,%esp
   10611:	85 c0                	test   %eax,%eax
   10613:	74 0f                	je     10624 <decodeGeneric+0x762>
   10615:	8b 45 14             	mov    0x14(%ebp),%eax
   10618:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
   1061f:	00 00 00 
   10622:	eb 43                	jmp    10667 <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
   10624:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   10628:	75 1a                	jne    10644 <decodeGeneric+0x782>
   1062a:	8b 55 1c             	mov    0x1c(%ebp),%edx
   1062d:	8b 45 18             	mov    0x18(%ebp),%eax
   10630:	01 d0                	add    %edx,%eax
   10632:	83 ec 08             	sub    $0x8,%esp
   10635:	50                   	push   %eax
   10636:	ff 75 f0             	pushl  -0x10(%ebp)
   10639:	e8 3f 86 ff ff       	call   8c7d <lodepng_chunk_next_const>
   1063e:	83 c4 10             	add    $0x10,%esp
   10641:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   10644:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   10648:	75 1d                	jne    10667 <decodeGeneric+0x7a5>
   1064a:	8b 45 14             	mov    0x14(%ebp),%eax
   1064d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10653:	85 c0                	test   %eax,%eax
   10655:	0f 84 68 f9 ff ff    	je     ffc3 <decodeGeneric+0x101>
   1065b:	eb 0a                	jmp    10667 <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   1065d:	90                   	nop
   1065e:	eb 07                	jmp    10667 <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   10660:	90                   	nop
   10661:	eb 04                	jmp    10667 <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
   10663:	90                   	nop
   10664:	eb 01                	jmp    10667 <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   10666:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
   10667:	8b 45 14             	mov    0x14(%ebp),%eax
   1066a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10670:	85 c0                	test   %eax,%eax
   10672:	75 28                	jne    1069c <decodeGeneric+0x7da>
   10674:	8b 45 14             	mov    0x14(%ebp),%eax
   10677:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   1067d:	83 f8 03             	cmp    $0x3,%eax
   10680:	75 1a                	jne    1069c <decodeGeneric+0x7da>
   10682:	8b 45 14             	mov    0x14(%ebp),%eax
   10685:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   1068b:	85 c0                	test   %eax,%eax
   1068d:	75 0d                	jne    1069c <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   1068f:	8b 45 14             	mov    0x14(%ebp),%eax
   10692:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   10699:	00 00 00 
  }

  if(!state->error) {
   1069c:	8b 45 14             	mov    0x14(%ebp),%eax
   1069f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   106a5:	85 c0                	test   %eax,%eax
   106a7:	0f 85 d2 01 00 00    	jne    1087f <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   106ad:	8b 45 14             	mov    0x14(%ebp),%eax
   106b0:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   106b6:	85 c0                	test   %eax,%eax
   106b8:	75 3a                	jne    106f4 <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   106ba:	8b 45 14             	mov    0x14(%ebp),%eax
   106bd:	05 a4 00 00 00       	add    $0xa4,%eax
   106c2:	83 ec 0c             	sub    $0xc,%esp
   106c5:	50                   	push   %eax
   106c6:	e8 8e 8e ff ff       	call   9559 <lodepng_get_bpp>
   106cb:	83 c4 10             	add    $0x10,%esp
   106ce:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   106d1:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   106d4:	8b 45 10             	mov    0x10(%ebp),%eax
   106d7:	8b 10                	mov    (%eax),%edx
   106d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   106dc:	8b 00                	mov    (%eax),%eax
   106de:	83 ec 04             	sub    $0x4,%esp
   106e1:	51                   	push   %ecx
   106e2:	52                   	push   %edx
   106e3:	50                   	push   %eax
   106e4:	e8 cf 8f ff ff       	call   96b8 <lodepng_get_raw_size_idat>
   106e9:	83 c4 10             	add    $0x10,%esp
   106ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
   106ef:	e9 60 01 00 00       	jmp    10854 <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   106f4:	8b 45 14             	mov    0x14(%ebp),%eax
   106f7:	05 a4 00 00 00       	add    $0xa4,%eax
   106fc:	83 ec 0c             	sub    $0xc,%esp
   106ff:	50                   	push   %eax
   10700:	e8 54 8e ff ff       	call   9559 <lodepng_get_bpp>
   10705:	83 c4 10             	add    $0x10,%esp
   10708:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   1070b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   10712:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10715:	8b 55 10             	mov    0x10(%ebp),%edx
   10718:	8b 12                	mov    (%edx),%edx
   1071a:	83 c2 07             	add    $0x7,%edx
   1071d:	89 d1                	mov    %edx,%ecx
   1071f:	c1 e9 03             	shr    $0x3,%ecx
   10722:	8b 55 0c             	mov    0xc(%ebp),%edx
   10725:	8b 12                	mov    (%edx),%edx
   10727:	83 c2 07             	add    $0x7,%edx
   1072a:	c1 ea 03             	shr    $0x3,%edx
   1072d:	83 ec 04             	sub    $0x4,%esp
   10730:	50                   	push   %eax
   10731:	51                   	push   %ecx
   10732:	52                   	push   %edx
   10733:	e8 80 8f ff ff       	call   96b8 <lodepng_get_raw_size_idat>
   10738:	83 c4 10             	add    $0x10,%esp
   1073b:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   1073e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10741:	8b 00                	mov    (%eax),%eax
   10743:	83 f8 04             	cmp    $0x4,%eax
   10746:	76 2c                	jbe    10774 <decodeGeneric+0x8b2>
   10748:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1074b:	8b 55 10             	mov    0x10(%ebp),%edx
   1074e:	8b 12                	mov    (%edx),%edx
   10750:	83 c2 07             	add    $0x7,%edx
   10753:	89 d1                	mov    %edx,%ecx
   10755:	c1 e9 03             	shr    $0x3,%ecx
   10758:	8b 55 0c             	mov    0xc(%ebp),%edx
   1075b:	8b 12                	mov    (%edx),%edx
   1075d:	83 c2 03             	add    $0x3,%edx
   10760:	c1 ea 03             	shr    $0x3,%edx
   10763:	83 ec 04             	sub    $0x4,%esp
   10766:	50                   	push   %eax
   10767:	51                   	push   %ecx
   10768:	52                   	push   %edx
   10769:	e8 4a 8f ff ff       	call   96b8 <lodepng_get_raw_size_idat>
   1076e:	83 c4 10             	add    $0x10,%esp
   10771:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   10774:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10777:	8b 55 10             	mov    0x10(%ebp),%edx
   1077a:	8b 12                	mov    (%edx),%edx
   1077c:	83 c2 03             	add    $0x3,%edx
   1077f:	89 d1                	mov    %edx,%ecx
   10781:	c1 e9 03             	shr    $0x3,%ecx
   10784:	8b 55 0c             	mov    0xc(%ebp),%edx
   10787:	8b 12                	mov    (%edx),%edx
   10789:	83 c2 03             	add    $0x3,%edx
   1078c:	c1 ea 02             	shr    $0x2,%edx
   1078f:	83 ec 04             	sub    $0x4,%esp
   10792:	50                   	push   %eax
   10793:	51                   	push   %ecx
   10794:	52                   	push   %edx
   10795:	e8 1e 8f ff ff       	call   96b8 <lodepng_get_raw_size_idat>
   1079a:	83 c4 10             	add    $0x10,%esp
   1079d:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   107a0:	8b 45 0c             	mov    0xc(%ebp),%eax
   107a3:	8b 00                	mov    (%eax),%eax
   107a5:	83 f8 02             	cmp    $0x2,%eax
   107a8:	76 2c                	jbe    107d6 <decodeGeneric+0x914>
   107aa:	8b 45 c8             	mov    -0x38(%ebp),%eax
   107ad:	8b 55 10             	mov    0x10(%ebp),%edx
   107b0:	8b 12                	mov    (%edx),%edx
   107b2:	83 c2 03             	add    $0x3,%edx
   107b5:	89 d1                	mov    %edx,%ecx
   107b7:	c1 e9 02             	shr    $0x2,%ecx
   107ba:	8b 55 0c             	mov    0xc(%ebp),%edx
   107bd:	8b 12                	mov    (%edx),%edx
   107bf:	83 c2 01             	add    $0x1,%edx
   107c2:	c1 ea 02             	shr    $0x2,%edx
   107c5:	83 ec 04             	sub    $0x4,%esp
   107c8:	50                   	push   %eax
   107c9:	51                   	push   %ecx
   107ca:	52                   	push   %edx
   107cb:	e8 e8 8e ff ff       	call   96b8 <lodepng_get_raw_size_idat>
   107d0:	83 c4 10             	add    $0x10,%esp
   107d3:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   107d6:	8b 45 c8             	mov    -0x38(%ebp),%eax
   107d9:	8b 55 10             	mov    0x10(%ebp),%edx
   107dc:	8b 12                	mov    (%edx),%edx
   107de:	83 c2 01             	add    $0x1,%edx
   107e1:	89 d1                	mov    %edx,%ecx
   107e3:	c1 e9 02             	shr    $0x2,%ecx
   107e6:	8b 55 0c             	mov    0xc(%ebp),%edx
   107e9:	8b 12                	mov    (%edx),%edx
   107eb:	83 c2 01             	add    $0x1,%edx
   107ee:	d1 ea                	shr    %edx
   107f0:	83 ec 04             	sub    $0x4,%esp
   107f3:	50                   	push   %eax
   107f4:	51                   	push   %ecx
   107f5:	52                   	push   %edx
   107f6:	e8 bd 8e ff ff       	call   96b8 <lodepng_get_raw_size_idat>
   107fb:	83 c4 10             	add    $0x10,%esp
   107fe:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   10801:	8b 45 0c             	mov    0xc(%ebp),%eax
   10804:	8b 00                	mov    (%eax),%eax
   10806:	83 f8 01             	cmp    $0x1,%eax
   10809:	76 27                	jbe    10832 <decodeGeneric+0x970>
   1080b:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1080e:	8b 55 10             	mov    0x10(%ebp),%edx
   10811:	8b 12                	mov    (%edx),%edx
   10813:	83 c2 01             	add    $0x1,%edx
   10816:	89 d1                	mov    %edx,%ecx
   10818:	d1 e9                	shr    %ecx
   1081a:	8b 55 0c             	mov    0xc(%ebp),%edx
   1081d:	8b 12                	mov    (%edx),%edx
   1081f:	d1 ea                	shr    %edx
   10821:	83 ec 04             	sub    $0x4,%esp
   10824:	50                   	push   %eax
   10825:	51                   	push   %ecx
   10826:	52                   	push   %edx
   10827:	e8 8c 8e ff ff       	call   96b8 <lodepng_get_raw_size_idat>
   1082c:	83 c4 10             	add    $0x10,%esp
   1082f:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   10832:	8b 55 c8             	mov    -0x38(%ebp),%edx
   10835:	8b 45 10             	mov    0x10(%ebp),%eax
   10838:	8b 00                	mov    (%eax),%eax
   1083a:	d1 e8                	shr    %eax
   1083c:	89 c1                	mov    %eax,%ecx
   1083e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10841:	8b 00                	mov    (%eax),%eax
   10843:	83 ec 04             	sub    $0x4,%esp
   10846:	52                   	push   %edx
   10847:	51                   	push   %ecx
   10848:	50                   	push   %eax
   10849:	e8 6a 8e ff ff       	call   96b8 <lodepng_get_raw_size_idat>
   1084e:	83 c4 10             	add    $0x10,%esp
   10851:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   10854:	8b 45 14             	mov    0x14(%ebp),%eax
   10857:	83 ec 08             	sub    $0x8,%esp
   1085a:	50                   	push   %eax
   1085b:	ff 75 ec             	pushl  -0x14(%ebp)
   1085e:	ff 75 d8             	pushl  -0x28(%ebp)
   10861:	ff 75 e8             	pushl  -0x18(%ebp)
   10864:	8d 45 c0             	lea    -0x40(%ebp),%eax
   10867:	50                   	push   %eax
   10868:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   1086b:	50                   	push   %eax
   1086c:	e8 87 7c ff ff       	call   84f8 <zlib_decompress>
   10871:	83 c4 20             	add    $0x20,%esp
   10874:	89 c2                	mov    %eax,%edx
   10876:	8b 45 14             	mov    0x14(%ebp),%eax
   10879:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   1087f:	8b 45 14             	mov    0x14(%ebp),%eax
   10882:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10888:	85 c0                	test   %eax,%eax
   1088a:	75 15                	jne    108a1 <decodeGeneric+0x9df>
   1088c:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1088f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   10892:	74 0d                	je     108a1 <decodeGeneric+0x9df>
   10894:	8b 45 14             	mov    0x14(%ebp),%eax
   10897:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   1089e:	00 00 00 
  lodepng_free(idat);
   108a1:	83 ec 0c             	sub    $0xc,%esp
   108a4:	ff 75 d8             	pushl  -0x28(%ebp)
   108a7:	e8 b2 31 ff ff       	call   3a5e <lodepng_free>
   108ac:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   108af:	8b 45 14             	mov    0x14(%ebp),%eax
   108b2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   108b8:	85 c0                	test   %eax,%eax
   108ba:	75 4f                	jne    1090b <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   108bc:	8b 45 14             	mov    0x14(%ebp),%eax
   108bf:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   108c5:	8b 45 10             	mov    0x10(%ebp),%eax
   108c8:	8b 10                	mov    (%eax),%edx
   108ca:	8b 45 0c             	mov    0xc(%ebp),%eax
   108cd:	8b 00                	mov    (%eax),%eax
   108cf:	83 ec 04             	sub    $0x4,%esp
   108d2:	51                   	push   %ecx
   108d3:	52                   	push   %edx
   108d4:	50                   	push   %eax
   108d5:	e8 be 8d ff ff       	call   9698 <lodepng_get_raw_size>
   108da:	83 c4 10             	add    $0x10,%esp
   108dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   108e0:	83 ec 0c             	sub    $0xc,%esp
   108e3:	ff 75 e4             	pushl  -0x1c(%ebp)
   108e6:	e8 52 31 ff ff       	call   3a3d <lodepng_malloc>
   108eb:	83 c4 10             	add    $0x10,%esp
   108ee:	89 c2                	mov    %eax,%edx
   108f0:	8b 45 08             	mov    0x8(%ebp),%eax
   108f3:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   108f5:	8b 45 08             	mov    0x8(%ebp),%eax
   108f8:	8b 00                	mov    (%eax),%eax
   108fa:	85 c0                	test   %eax,%eax
   108fc:	75 0d                	jne    1090b <decodeGeneric+0xa49>
   108fe:	8b 45 14             	mov    0x14(%ebp),%eax
   10901:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   10908:	00 00 00 
  }
  if(!state->error) {
   1090b:	8b 45 14             	mov    0x14(%ebp),%eax
   1090e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10914:	85 c0                	test   %eax,%eax
   10916:	75 4c                	jne    10964 <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   10918:	8b 45 08             	mov    0x8(%ebp),%eax
   1091b:	8b 00                	mov    (%eax),%eax
   1091d:	83 ec 04             	sub    $0x4,%esp
   10920:	ff 75 e4             	pushl  -0x1c(%ebp)
   10923:	6a 00                	push   $0x0
   10925:	50                   	push   %eax
   10926:	e8 83 31 ff ff       	call   3aae <lodepng_memset>
   1092b:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   1092e:	8b 45 14             	mov    0x14(%ebp),%eax
   10931:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   10937:	8b 45 10             	mov    0x10(%ebp),%eax
   1093a:	8b 18                	mov    (%eax),%ebx
   1093c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1093f:	8b 08                	mov    (%eax),%ecx
   10941:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   10944:	8b 45 08             	mov    0x8(%ebp),%eax
   10947:	8b 00                	mov    (%eax),%eax
   10949:	83 ec 0c             	sub    $0xc,%esp
   1094c:	56                   	push   %esi
   1094d:	53                   	push   %ebx
   1094e:	51                   	push   %ecx
   1094f:	52                   	push   %edx
   10950:	50                   	push   %eax
   10951:	e8 05 df ff ff       	call   e85b <postProcessScanlines>
   10956:	83 c4 20             	add    $0x20,%esp
   10959:	89 c2                	mov    %eax,%edx
   1095b:	8b 45 14             	mov    0x14(%ebp),%eax
   1095e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   10964:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10967:	83 ec 0c             	sub    $0xc,%esp
   1096a:	50                   	push   %eax
   1096b:	e8 ee 30 ff ff       	call   3a5e <lodepng_free>
   10970:	83 c4 10             	add    $0x10,%esp
   10973:	eb 01                	jmp    10976 <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   10975:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   10976:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10979:	5b                   	pop    %ebx
   1097a:	5e                   	pop    %esi
   1097b:	5d                   	pop    %ebp
   1097c:	c3                   	ret    

0001097d <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   1097d:	55                   	push   %ebp
   1097e:	89 e5                	mov    %esp,%ebp
   10980:	56                   	push   %esi
   10981:	53                   	push   %ebx
   10982:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   10985:	8b 45 08             	mov    0x8(%ebp),%eax
   10988:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   1098e:	83 ec 08             	sub    $0x8,%esp
   10991:	ff 75 1c             	pushl  0x1c(%ebp)
   10994:	ff 75 18             	pushl  0x18(%ebp)
   10997:	ff 75 14             	pushl  0x14(%ebp)
   1099a:	ff 75 10             	pushl  0x10(%ebp)
   1099d:	ff 75 0c             	pushl  0xc(%ebp)
   109a0:	ff 75 08             	pushl  0x8(%ebp)
   109a3:	e8 1a f5 ff ff       	call   fec2 <decodeGeneric>
   109a8:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   109ab:	8b 45 14             	mov    0x14(%ebp),%eax
   109ae:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   109b4:	85 c0                	test   %eax,%eax
   109b6:	74 0e                	je     109c6 <lodepng_decode+0x49>
   109b8:	8b 45 14             	mov    0x14(%ebp),%eax
   109bb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   109c1:	e9 55 01 00 00       	jmp    10b1b <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   109c6:	8b 45 14             	mov    0x14(%ebp),%eax
   109c9:	8b 40 24             	mov    0x24(%eax),%eax
   109cc:	85 c0                	test   %eax,%eax
   109ce:	74 20                	je     109f0 <lodepng_decode+0x73>
   109d0:	8b 45 14             	mov    0x14(%ebp),%eax
   109d3:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   109d9:	8b 45 14             	mov    0x14(%ebp),%eax
   109dc:	83 c0 78             	add    $0x78,%eax
   109df:	83 ec 08             	sub    $0x8,%esp
   109e2:	52                   	push   %edx
   109e3:	50                   	push   %eax
   109e4:	e8 56 89 ff ff       	call   933f <lodepng_color_mode_equal>
   109e9:	83 c4 10             	add    $0x10,%esp
   109ec:	85 c0                	test   %eax,%eax
   109ee:	74 54                	je     10a44 <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   109f0:	8b 45 14             	mov    0x14(%ebp),%eax
   109f3:	8b 40 24             	mov    0x24(%eax),%eax
   109f6:	85 c0                	test   %eax,%eax
   109f8:	0f 85 13 01 00 00    	jne    10b11 <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   109fe:	8b 45 14             	mov    0x14(%ebp),%eax
   10a01:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   10a07:	8b 45 14             	mov    0x14(%ebp),%eax
   10a0a:	83 c0 78             	add    $0x78,%eax
   10a0d:	83 ec 08             	sub    $0x8,%esp
   10a10:	52                   	push   %edx
   10a11:	50                   	push   %eax
   10a12:	e8 3f 88 ff ff       	call   9256 <lodepng_color_mode_copy>
   10a17:	83 c4 10             	add    $0x10,%esp
   10a1a:	89 c2                	mov    %eax,%edx
   10a1c:	8b 45 14             	mov    0x14(%ebp),%eax
   10a1f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   10a25:	8b 45 14             	mov    0x14(%ebp),%eax
   10a28:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10a2e:	85 c0                	test   %eax,%eax
   10a30:	0f 84 db 00 00 00    	je     10b11 <lodepng_decode+0x194>
   10a36:	8b 45 14             	mov    0x14(%ebp),%eax
   10a39:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10a3f:	e9 d7 00 00 00       	jmp    10b1b <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   10a44:	8b 45 08             	mov    0x8(%ebp),%eax
   10a47:	8b 00                	mov    (%eax),%eax
   10a49:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   10a4c:	8b 45 14             	mov    0x14(%ebp),%eax
   10a4f:	8b 40 78             	mov    0x78(%eax),%eax
   10a52:	83 f8 02             	cmp    $0x2,%eax
   10a55:	74 20                	je     10a77 <lodepng_decode+0xfa>
   10a57:	8b 45 14             	mov    0x14(%ebp),%eax
   10a5a:	8b 40 78             	mov    0x78(%eax),%eax
   10a5d:	83 f8 06             	cmp    $0x6,%eax
   10a60:	74 15                	je     10a77 <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   10a62:	8b 45 14             	mov    0x14(%ebp),%eax
   10a65:	8b 40 7c             	mov    0x7c(%eax),%eax
   10a68:	83 f8 08             	cmp    $0x8,%eax
   10a6b:	74 0a                	je     10a77 <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   10a6d:	b8 38 00 00 00       	mov    $0x38,%eax
   10a72:	e9 a4 00 00 00       	jmp    10b1b <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   10a77:	8b 45 14             	mov    0x14(%ebp),%eax
   10a7a:	8d 48 78             	lea    0x78(%eax),%ecx
   10a7d:	8b 45 10             	mov    0x10(%ebp),%eax
   10a80:	8b 10                	mov    (%eax),%edx
   10a82:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a85:	8b 00                	mov    (%eax),%eax
   10a87:	83 ec 04             	sub    $0x4,%esp
   10a8a:	51                   	push   %ecx
   10a8b:	52                   	push   %edx
   10a8c:	50                   	push   %eax
   10a8d:	e8 06 8c ff ff       	call   9698 <lodepng_get_raw_size>
   10a92:	83 c4 10             	add    $0x10,%esp
   10a95:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10a98:	83 ec 0c             	sub    $0xc,%esp
   10a9b:	ff 75 f0             	pushl  -0x10(%ebp)
   10a9e:	e8 9a 2f ff ff       	call   3a3d <lodepng_malloc>
   10aa3:	83 c4 10             	add    $0x10,%esp
   10aa6:	89 c2                	mov    %eax,%edx
   10aa8:	8b 45 08             	mov    0x8(%ebp),%eax
   10aab:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   10aad:	8b 45 08             	mov    0x8(%ebp),%eax
   10ab0:	8b 00                	mov    (%eax),%eax
   10ab2:	85 c0                	test   %eax,%eax
   10ab4:	75 0f                	jne    10ac5 <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   10ab6:	8b 45 14             	mov    0x14(%ebp),%eax
   10ab9:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   10ac0:	00 00 00 
   10ac3:	eb 3c                	jmp    10b01 <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   10ac5:	8b 45 10             	mov    0x10(%ebp),%eax
   10ac8:	8b 08                	mov    (%eax),%ecx
   10aca:	8b 45 0c             	mov    0xc(%ebp),%eax
   10acd:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   10acf:	8b 45 14             	mov    0x14(%ebp),%eax
   10ad2:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   10ad8:	8b 45 14             	mov    0x14(%ebp),%eax
   10adb:	8d 58 78             	lea    0x78(%eax),%ebx
   10ade:	8b 45 08             	mov    0x8(%ebp),%eax
   10ae1:	8b 00                	mov    (%eax),%eax
   10ae3:	83 ec 08             	sub    $0x8,%esp
   10ae6:	51                   	push   %ecx
   10ae7:	52                   	push   %edx
   10ae8:	56                   	push   %esi
   10ae9:	53                   	push   %ebx
   10aea:	ff 75 f4             	pushl  -0xc(%ebp)
   10aed:	50                   	push   %eax
   10aee:	e8 51 b6 ff ff       	call   c144 <lodepng_convert>
   10af3:	83 c4 20             	add    $0x20,%esp
   10af6:	89 c2                	mov    %eax,%edx
   10af8:	8b 45 14             	mov    0x14(%ebp),%eax
   10afb:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   10b01:	83 ec 0c             	sub    $0xc,%esp
   10b04:	ff 75 f4             	pushl  -0xc(%ebp)
   10b07:	e8 52 2f ff ff       	call   3a5e <lodepng_free>
   10b0c:	83 c4 10             	add    $0x10,%esp
   10b0f:	eb 01                	jmp    10b12 <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   10b11:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   10b12:	8b 45 14             	mov    0x14(%ebp),%eax
   10b15:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   10b1b:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10b1e:	5b                   	pop    %ebx
   10b1f:	5e                   	pop    %esi
   10b20:	5d                   	pop    %ebp
   10b21:	c3                   	ret    

00010b22 <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   10b22:	55                   	push   %ebp
   10b23:	89 e5                	mov    %esp,%ebp
   10b25:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   10b2b:	83 ec 0c             	sub    $0xc,%esp
   10b2e:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10b34:	50                   	push   %eax
   10b35:	e8 d9 01 00 00       	call   10d13 <lodepng_state_init>
   10b3a:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   10b3d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   10b40:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   10b46:	8b 45 20             	mov    0x20(%ebp),%eax
   10b49:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   10b4f:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   10b56:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   10b59:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   10b60:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   10b63:	83 ec 08             	sub    $0x8,%esp
   10b66:	ff 75 18             	pushl  0x18(%ebp)
   10b69:	ff 75 14             	pushl  0x14(%ebp)
   10b6c:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10b72:	50                   	push   %eax
   10b73:	ff 75 10             	pushl  0x10(%ebp)
   10b76:	ff 75 0c             	pushl  0xc(%ebp)
   10b79:	ff 75 08             	pushl  0x8(%ebp)
   10b7c:	e8 fc fd ff ff       	call   1097d <lodepng_decode>
   10b81:	83 c4 20             	add    $0x20,%esp
   10b84:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   10b87:	83 ec 0c             	sub    $0xc,%esp
   10b8a:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10b90:	50                   	push   %eax
   10b91:	e8 d7 01 00 00       	call   10d6d <lodepng_state_cleanup>
   10b96:	83 c4 10             	add    $0x10,%esp
  return error;
   10b99:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10b9c:	c9                   	leave  
   10b9d:	c3                   	ret    

00010b9e <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10b9e:	55                   	push   %ebp
   10b9f:	89 e5                	mov    %esp,%ebp
   10ba1:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   10ba4:	83 ec 04             	sub    $0x4,%esp
   10ba7:	6a 08                	push   $0x8
   10ba9:	6a 06                	push   $0x6
   10bab:	ff 75 18             	pushl  0x18(%ebp)
   10bae:	ff 75 14             	pushl  0x14(%ebp)
   10bb1:	ff 75 10             	pushl  0x10(%ebp)
   10bb4:	ff 75 0c             	pushl  0xc(%ebp)
   10bb7:	ff 75 08             	pushl  0x8(%ebp)
   10bba:	e8 63 ff ff ff       	call   10b22 <lodepng_decode_memory>
   10bbf:	83 c4 20             	add    $0x20,%esp
}
   10bc2:	c9                   	leave  
   10bc3:	c3                   	ret    

00010bc4 <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10bc4:	55                   	push   %ebp
   10bc5:	89 e5                	mov    %esp,%ebp
   10bc7:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   10bca:	83 ec 04             	sub    $0x4,%esp
   10bcd:	6a 08                	push   $0x8
   10bcf:	6a 02                	push   $0x2
   10bd1:	ff 75 18             	pushl  0x18(%ebp)
   10bd4:	ff 75 14             	pushl  0x14(%ebp)
   10bd7:	ff 75 10             	pushl  0x10(%ebp)
   10bda:	ff 75 0c             	pushl  0xc(%ebp)
   10bdd:	ff 75 08             	pushl  0x8(%ebp)
   10be0:	e8 3d ff ff ff       	call   10b22 <lodepng_decode_memory>
   10be5:	83 c4 20             	add    $0x20,%esp
}
   10be8:	c9                   	leave  
   10be9:	c3                   	ret    

00010bea <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   10bea:	55                   	push   %ebp
   10beb:	89 e5                	mov    %esp,%ebp
   10bed:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   10bf0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   10bf7:	8b 45 08             	mov    0x8(%ebp),%eax
   10bfa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   10c00:	8b 45 10             	mov    0x10(%ebp),%eax
   10c03:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   10c09:	8b 45 10             	mov    0x10(%ebp),%eax
   10c0c:	8b 10                	mov    (%eax),%edx
   10c0e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c11:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   10c13:	83 ec 04             	sub    $0x4,%esp
   10c16:	ff 75 14             	pushl  0x14(%ebp)
   10c19:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10c1c:	50                   	push   %eax
   10c1d:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10c20:	50                   	push   %eax
   10c21:	e8 70 32 ff ff       	call   3e96 <lodepng_load_file>
   10c26:	83 c4 10             	add    $0x10,%esp
   10c29:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   10c2c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10c30:	75 25                	jne    10c57 <lodepng_decode_file+0x6d>
   10c32:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10c35:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10c38:	83 ec 04             	sub    $0x4,%esp
   10c3b:	ff 75 1c             	pushl  0x1c(%ebp)
   10c3e:	ff 75 18             	pushl  0x18(%ebp)
   10c41:	52                   	push   %edx
   10c42:	50                   	push   %eax
   10c43:	ff 75 10             	pushl  0x10(%ebp)
   10c46:	ff 75 0c             	pushl  0xc(%ebp)
   10c49:	ff 75 08             	pushl  0x8(%ebp)
   10c4c:	e8 d1 fe ff ff       	call   10b22 <lodepng_decode_memory>
   10c51:	83 c4 20             	add    $0x20,%esp
   10c54:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   10c57:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10c5a:	83 ec 0c             	sub    $0xc,%esp
   10c5d:	50                   	push   %eax
   10c5e:	e8 fb 2d ff ff       	call   3a5e <lodepng_free>
   10c63:	83 c4 10             	add    $0x10,%esp
  return error;
   10c66:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10c69:	c9                   	leave  
   10c6a:	c3                   	ret    

00010c6b <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10c6b:	55                   	push   %ebp
   10c6c:	89 e5                	mov    %esp,%ebp
   10c6e:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   10c71:	83 ec 08             	sub    $0x8,%esp
   10c74:	6a 08                	push   $0x8
   10c76:	6a 06                	push   $0x6
   10c78:	ff 75 14             	pushl  0x14(%ebp)
   10c7b:	ff 75 10             	pushl  0x10(%ebp)
   10c7e:	ff 75 0c             	pushl  0xc(%ebp)
   10c81:	ff 75 08             	pushl  0x8(%ebp)
   10c84:	e8 61 ff ff ff       	call   10bea <lodepng_decode_file>
   10c89:	83 c4 20             	add    $0x20,%esp
}
   10c8c:	c9                   	leave  
   10c8d:	c3                   	ret    

00010c8e <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10c8e:	55                   	push   %ebp
   10c8f:	89 e5                	mov    %esp,%ebp
   10c91:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   10c94:	83 ec 08             	sub    $0x8,%esp
   10c97:	6a 08                	push   $0x8
   10c99:	6a 02                	push   $0x2
   10c9b:	ff 75 14             	pushl  0x14(%ebp)
   10c9e:	ff 75 10             	pushl  0x10(%ebp)
   10ca1:	ff 75 0c             	pushl  0xc(%ebp)
   10ca4:	ff 75 08             	pushl  0x8(%ebp)
   10ca7:	e8 3e ff ff ff       	call   10bea <lodepng_decode_file>
   10cac:	83 c4 20             	add    $0x20,%esp
}
   10caf:	c9                   	leave  
   10cb0:	c3                   	ret    

00010cb1 <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   10cb1:	55                   	push   %ebp
   10cb2:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   10cb4:	8b 45 08             	mov    0x8(%ebp),%eax
   10cb7:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   10cbe:	8b 45 08             	mov    0x8(%ebp),%eax
   10cc1:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   10cc8:	8b 45 08             	mov    0x8(%ebp),%eax
   10ccb:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   10cd2:	8b 45 08             	mov    0x8(%ebp),%eax
   10cd5:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   10cdc:	8b 45 08             	mov    0x8(%ebp),%eax
   10cdf:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   10ce6:	8b 45 08             	mov    0x8(%ebp),%eax
   10ce9:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   10cf0:	8b 45 08             	mov    0x8(%ebp),%eax
   10cf3:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   10cfa:	8b 45 08             	mov    0x8(%ebp),%eax
   10cfd:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   10d04:	8b 45 08             	mov    0x8(%ebp),%eax
   10d07:	50                   	push   %eax
   10d08:	e8 ff 7a ff ff       	call   880c <lodepng_decompress_settings_init>
   10d0d:	83 c4 04             	add    $0x4,%esp
}
   10d10:	90                   	nop
   10d11:	c9                   	leave  
   10d12:	c3                   	ret    

00010d13 <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   10d13:	55                   	push   %ebp
   10d14:	89 e5                	mov    %esp,%ebp
   10d16:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   10d19:	8b 45 08             	mov    0x8(%ebp),%eax
   10d1c:	50                   	push   %eax
   10d1d:	e8 8f ff ff ff       	call   10cb1 <lodepng_decoder_settings_init>
   10d22:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   10d25:	8b 45 08             	mov    0x8(%ebp),%eax
   10d28:	83 c0 38             	add    $0x38,%eax
   10d2b:	83 ec 0c             	sub    $0xc,%esp
   10d2e:	50                   	push   %eax
   10d2f:	e8 fc 30 00 00       	call   13e30 <lodepng_encoder_settings_init>
   10d34:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   10d37:	8b 45 08             	mov    0x8(%ebp),%eax
   10d3a:	83 c0 78             	add    $0x78,%eax
   10d3d:	83 ec 0c             	sub    $0xc,%esp
   10d40:	50                   	push   %eax
   10d41:	e8 06 84 ff ff       	call   914c <lodepng_color_mode_init>
   10d46:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   10d49:	8b 45 08             	mov    0x8(%ebp),%eax
   10d4c:	05 98 00 00 00       	add    $0x98,%eax
   10d51:	83 ec 0c             	sub    $0xc,%esp
   10d54:	50                   	push   %eax
   10d55:	e8 89 93 ff ff       	call   a0e3 <lodepng_info_init>
   10d5a:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   10d5d:	8b 45 08             	mov    0x8(%ebp),%eax
   10d60:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   10d67:	00 00 00 
}
   10d6a:	90                   	nop
   10d6b:	c9                   	leave  
   10d6c:	c3                   	ret    

00010d6d <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   10d6d:	55                   	push   %ebp
   10d6e:	89 e5                	mov    %esp,%ebp
   10d70:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   10d73:	8b 45 08             	mov    0x8(%ebp),%eax
   10d76:	83 c0 78             	add    $0x78,%eax
   10d79:	83 ec 0c             	sub    $0xc,%esp
   10d7c:	50                   	push   %eax
   10d7d:	e8 bd 84 ff ff       	call   923f <lodepng_color_mode_cleanup>
   10d82:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   10d85:	8b 45 08             	mov    0x8(%ebp),%eax
   10d88:	05 98 00 00 00       	add    $0x98,%eax
   10d8d:	83 ec 0c             	sub    $0xc,%esp
   10d90:	50                   	push   %eax
   10d91:	e8 2e 94 ff ff       	call   a1c4 <lodepng_info_cleanup>
   10d96:	83 c4 10             	add    $0x10,%esp
}
   10d99:	90                   	nop
   10d9a:	c9                   	leave  
   10d9b:	c3                   	ret    

00010d9c <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   10d9c:	55                   	push   %ebp
   10d9d:	89 e5                	mov    %esp,%ebp
   10d9f:	57                   	push   %edi
   10da0:	56                   	push   %esi
   10da1:	53                   	push   %ebx
   10da2:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   10da5:	83 ec 0c             	sub    $0xc,%esp
   10da8:	ff 75 08             	pushl  0x8(%ebp)
   10dab:	e8 bd ff ff ff       	call   10d6d <lodepng_state_cleanup>
   10db0:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   10db3:	8b 55 08             	mov    0x8(%ebp),%edx
   10db6:	8b 45 0c             	mov    0xc(%ebp),%eax
   10db9:	89 c3                	mov    %eax,%ebx
   10dbb:	b8 60 00 00 00       	mov    $0x60,%eax
   10dc0:	89 d7                	mov    %edx,%edi
   10dc2:	89 de                	mov    %ebx,%esi
   10dc4:	89 c1                	mov    %eax,%ecx
   10dc6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   10dc8:	8b 45 08             	mov    0x8(%ebp),%eax
   10dcb:	83 c0 78             	add    $0x78,%eax
   10dce:	83 ec 0c             	sub    $0xc,%esp
   10dd1:	50                   	push   %eax
   10dd2:	e8 75 83 ff ff       	call   914c <lodepng_color_mode_init>
   10dd7:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   10dda:	8b 45 08             	mov    0x8(%ebp),%eax
   10ddd:	05 98 00 00 00       	add    $0x98,%eax
   10de2:	83 ec 0c             	sub    $0xc,%esp
   10de5:	50                   	push   %eax
   10de6:	e8 f8 92 ff ff       	call   a0e3 <lodepng_info_init>
   10deb:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   10dee:	8b 45 0c             	mov    0xc(%ebp),%eax
   10df1:	8d 50 78             	lea    0x78(%eax),%edx
   10df4:	8b 45 08             	mov    0x8(%ebp),%eax
   10df7:	83 c0 78             	add    $0x78,%eax
   10dfa:	83 ec 08             	sub    $0x8,%esp
   10dfd:	52                   	push   %edx
   10dfe:	50                   	push   %eax
   10dff:	e8 52 84 ff ff       	call   9256 <lodepng_color_mode_copy>
   10e04:	83 c4 10             	add    $0x10,%esp
   10e07:	89 c2                	mov    %eax,%edx
   10e09:	8b 45 08             	mov    0x8(%ebp),%eax
   10e0c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10e12:	8b 45 08             	mov    0x8(%ebp),%eax
   10e15:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10e1b:	85 c0                	test   %eax,%eax
   10e1d:	75 36                	jne    10e55 <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   10e1f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e22:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   10e28:	8b 45 08             	mov    0x8(%ebp),%eax
   10e2b:	05 98 00 00 00       	add    $0x98,%eax
   10e30:	83 ec 08             	sub    $0x8,%esp
   10e33:	52                   	push   %edx
   10e34:	50                   	push   %eax
   10e35:	e8 dd 93 ff ff       	call   a217 <lodepng_info_copy>
   10e3a:	83 c4 10             	add    $0x10,%esp
   10e3d:	89 c2                	mov    %eax,%edx
   10e3f:	8b 45 08             	mov    0x8(%ebp),%eax
   10e42:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10e48:	8b 45 08             	mov    0x8(%ebp),%eax
   10e4b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10e51:	85 c0                	test   %eax,%eax
   10e53:	eb 01                	jmp    10e56 <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   10e55:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   10e56:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10e59:	5b                   	pop    %ebx
   10e5a:	5e                   	pop    %esi
   10e5b:	5f                   	pop    %edi
   10e5c:	5d                   	pop    %ebp
   10e5d:	c3                   	ret    

00010e5e <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   10e5e:	55                   	push   %ebp
   10e5f:	89 e5                	mov    %esp,%ebp
   10e61:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   10e64:	8b 45 08             	mov    0x8(%ebp),%eax
   10e67:	8b 40 04             	mov    0x4(%eax),%eax
   10e6a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   10e6d:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   10e71:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   10e75:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   10e79:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   10e7d:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   10e81:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   10e85:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   10e89:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   10e8d:	8b 45 08             	mov    0x8(%ebp),%eax
   10e90:	8b 40 04             	mov    0x4(%eax),%eax
   10e93:	83 c0 08             	add    $0x8,%eax
   10e96:	50                   	push   %eax
   10e97:	ff 75 08             	pushl  0x8(%ebp)
   10e9a:	e8 f8 2d ff ff       	call   3c97 <ucvector_resize>
   10e9f:	83 c4 08             	add    $0x8,%esp
   10ea2:	85 c0                	test   %eax,%eax
   10ea4:	75 07                	jne    10ead <writeSignature+0x4f>
   10ea6:	b8 53 00 00 00       	mov    $0x53,%eax
   10eab:	eb 1e                	jmp    10ecb <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   10ead:	8b 45 08             	mov    0x8(%ebp),%eax
   10eb0:	8b 10                	mov    (%eax),%edx
   10eb2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10eb5:	01 c2                	add    %eax,%edx
   10eb7:	6a 08                	push   $0x8
   10eb9:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10ebc:	50                   	push   %eax
   10ebd:	52                   	push   %edx
   10ebe:	e8 b8 2b ff ff       	call   3a7b <lodepng_memcpy>
   10ec3:	83 c4 0c             	add    $0xc,%esp
  return 0;
   10ec6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10ecb:	c9                   	leave  
   10ecc:	c3                   	ret    

00010ecd <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   10ecd:	55                   	push   %ebp
   10ece:	89 e5                	mov    %esp,%ebp
   10ed0:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   10ed3:	68 8c a7 01 00       	push   $0x1a78c
   10ed8:	6a 0d                	push   $0xd
   10eda:	ff 75 08             	pushl  0x8(%ebp)
   10edd:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10ee0:	50                   	push   %eax
   10ee1:	e8 cf 7f ff ff       	call   8eb5 <lodepng_chunk_init>
   10ee6:	83 c4 10             	add    $0x10,%esp
   10ee9:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10eec:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10ef0:	74 05                	je     10ef7 <addChunk_IHDR+0x2a>
   10ef2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10ef5:	eb 6d                	jmp    10f64 <addChunk_IHDR+0x97>
  data = chunk + 8;
   10ef7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10efa:	83 c0 08             	add    $0x8,%eax
   10efd:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   10f00:	ff 75 0c             	pushl  0xc(%ebp)
   10f03:	ff 75 f8             	pushl  -0x8(%ebp)
   10f06:	e8 f3 2e ff ff       	call   3dfe <lodepng_set32bitInt>
   10f0b:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   10f0e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10f11:	83 c0 04             	add    $0x4,%eax
   10f14:	ff 75 10             	pushl  0x10(%ebp)
   10f17:	50                   	push   %eax
   10f18:	e8 e1 2e ff ff       	call   3dfe <lodepng_set32bitInt>
   10f1d:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   10f20:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10f23:	83 c0 08             	add    $0x8,%eax
   10f26:	8b 55 18             	mov    0x18(%ebp),%edx
   10f29:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   10f2b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10f2e:	83 c0 09             	add    $0x9,%eax
   10f31:	8b 55 14             	mov    0x14(%ebp),%edx
   10f34:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   10f36:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10f39:	83 c0 0a             	add    $0xa,%eax
   10f3c:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   10f3f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10f42:	83 c0 0b             	add    $0xb,%eax
   10f45:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   10f48:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10f4b:	83 c0 0c             	add    $0xc,%eax
   10f4e:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10f51:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   10f53:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10f56:	50                   	push   %eax
   10f57:	e8 02 7c ff ff       	call   8b5e <lodepng_chunk_generate_crc>
   10f5c:	83 c4 04             	add    $0x4,%esp
  return 0;
   10f5f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10f64:	c9                   	leave  
   10f65:	c3                   	ret    

00010f66 <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   10f66:	55                   	push   %ebp
   10f67:	89 e5                	mov    %esp,%ebp
   10f69:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   10f6c:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   10f73:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f76:	8b 50 0c             	mov    0xc(%eax),%edx
   10f79:	89 d0                	mov    %edx,%eax
   10f7b:	01 c0                	add    %eax,%eax
   10f7d:	01 d0                	add    %edx,%eax
   10f7f:	68 a8 a7 01 00       	push   $0x1a7a8
   10f84:	50                   	push   %eax
   10f85:	ff 75 08             	pushl  0x8(%ebp)
   10f88:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10f8b:	50                   	push   %eax
   10f8c:	e8 24 7f ff ff       	call   8eb5 <lodepng_chunk_init>
   10f91:	83 c4 10             	add    $0x10,%esp
   10f94:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10f97:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10f9b:	74 08                	je     10fa5 <addChunk_PLTE+0x3f>
   10f9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10fa0:	e9 95 00 00 00       	jmp    1103a <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   10fa5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10fac:	eb 70                	jmp    1101e <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   10fae:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10fb1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10fb4:	8d 50 01             	lea    0x1(%eax),%edx
   10fb7:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10fba:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10fbd:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fc0:	8b 40 08             	mov    0x8(%eax),%eax
   10fc3:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10fc6:	c1 e1 02             	shl    $0x2,%ecx
   10fc9:	01 c8                	add    %ecx,%eax
   10fcb:	0f b6 00             	movzbl (%eax),%eax
   10fce:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   10fd0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10fd3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10fd6:	8d 50 01             	lea    0x1(%eax),%edx
   10fd9:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10fdc:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10fdf:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fe2:	8b 40 08             	mov    0x8(%eax),%eax
   10fe5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10fe8:	c1 e1 02             	shl    $0x2,%ecx
   10feb:	83 c1 01             	add    $0x1,%ecx
   10fee:	01 c8                	add    %ecx,%eax
   10ff0:	0f b6 00             	movzbl (%eax),%eax
   10ff3:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   10ff5:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10ff8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10ffb:	8d 50 01             	lea    0x1(%eax),%edx
   10ffe:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11001:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   11004:	8b 45 0c             	mov    0xc(%ebp),%eax
   11007:	8b 40 08             	mov    0x8(%eax),%eax
   1100a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   1100d:	c1 e1 02             	shl    $0x2,%ecx
   11010:	83 c1 02             	add    $0x2,%ecx
   11013:	01 c8                	add    %ecx,%eax
   11015:	0f b6 00             	movzbl (%eax),%eax
   11018:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   1101a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1101e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11021:	8b 40 0c             	mov    0xc(%eax),%eax
   11024:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   11027:	75 85                	jne    10fae <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   11029:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1102c:	50                   	push   %eax
   1102d:	e8 2c 7b ff ff       	call   8b5e <lodepng_chunk_generate_crc>
   11032:	83 c4 04             	add    $0x4,%esp
  return 0;
   11035:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1103a:	c9                   	leave  
   1103b:	c3                   	ret    

0001103c <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   1103c:	55                   	push   %ebp
   1103d:	89 e5                	mov    %esp,%ebp
   1103f:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   11042:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   11049:	8b 45 0c             	mov    0xc(%ebp),%eax
   1104c:	8b 00                	mov    (%eax),%eax
   1104e:	83 f8 03             	cmp    $0x3,%eax
   11051:	0f 85 ae 00 00 00    	jne    11105 <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   11057:	8b 45 0c             	mov    0xc(%ebp),%eax
   1105a:	8b 40 0c             	mov    0xc(%eax),%eax
   1105d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   11060:	8b 45 0c             	mov    0xc(%ebp),%eax
   11063:	8b 40 0c             	mov    0xc(%eax),%eax
   11066:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11069:	eb 23                	jmp    1108e <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   1106b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1106e:	8b 40 08             	mov    0x8(%eax),%eax
   11071:	8b 55 fc             	mov    -0x4(%ebp),%edx
   11074:	83 ea 01             	sub    $0x1,%edx
   11077:	c1 e2 02             	shl    $0x2,%edx
   1107a:	83 c2 03             	add    $0x3,%edx
   1107d:	01 d0                	add    %edx,%eax
   1107f:	0f b6 00             	movzbl (%eax),%eax
   11082:	3c ff                	cmp    $0xff,%al
   11084:	75 10                	jne    11096 <addChunk_tRNS+0x5a>
      --amount;
   11086:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   1108a:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   1108e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11092:	75 d7                	jne    1106b <addChunk_tRNS+0x2f>
   11094:	eb 01                	jmp    11097 <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   11096:	90                   	nop
      --amount;
    }
    if(amount) {
   11097:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   1109b:	0f 84 63 01 00 00    	je     11204 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   110a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   110a4:	68 ad a7 01 00       	push   $0x1a7ad
   110a9:	50                   	push   %eax
   110aa:	ff 75 08             	pushl  0x8(%ebp)
   110ad:	8d 45 e8             	lea    -0x18(%ebp),%eax
   110b0:	50                   	push   %eax
   110b1:	e8 ff 7d ff ff       	call   8eb5 <lodepng_chunk_init>
   110b6:	83 c4 10             	add    $0x10,%esp
   110b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
   110bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   110c0:	74 08                	je     110ca <addChunk_tRNS+0x8e>
   110c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   110c5:	e9 52 01 00 00       	jmp    1121c <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   110ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   110d1:	eb 25                	jmp    110f8 <addChunk_tRNS+0xbc>
   110d3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   110d6:	8b 55 fc             	mov    -0x4(%ebp),%edx
   110d9:	83 c2 08             	add    $0x8,%edx
   110dc:	01 c2                	add    %eax,%edx
   110de:	8b 45 0c             	mov    0xc(%ebp),%eax
   110e1:	8b 40 08             	mov    0x8(%eax),%eax
   110e4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   110e7:	c1 e1 02             	shl    $0x2,%ecx
   110ea:	83 c1 03             	add    $0x3,%ecx
   110ed:	01 c8                	add    %ecx,%eax
   110ef:	0f b6 00             	movzbl (%eax),%eax
   110f2:	88 02                	mov    %al,(%edx)
   110f4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   110f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   110fb:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   110fe:	75 d3                	jne    110d3 <addChunk_tRNS+0x97>
   11100:	e9 ff 00 00 00       	jmp    11204 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   11105:	8b 45 0c             	mov    0xc(%ebp),%eax
   11108:	8b 00                	mov    (%eax),%eax
   1110a:	85 c0                	test   %eax,%eax
   1110c:	75 59                	jne    11167 <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   1110e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11111:	8b 40 10             	mov    0x10(%eax),%eax
   11114:	85 c0                	test   %eax,%eax
   11116:	0f 84 e8 00 00 00    	je     11204 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   1111c:	68 ad a7 01 00       	push   $0x1a7ad
   11121:	6a 02                	push   $0x2
   11123:	ff 75 08             	pushl  0x8(%ebp)
   11126:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11129:	50                   	push   %eax
   1112a:	e8 86 7d ff ff       	call   8eb5 <lodepng_chunk_init>
   1112f:	83 c4 10             	add    $0x10,%esp
   11132:	89 45 f0             	mov    %eax,-0x10(%ebp)
   11135:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11139:	74 08                	je     11143 <addChunk_tRNS+0x107>
   1113b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1113e:	e9 d9 00 00 00       	jmp    1121c <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   11143:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11146:	8d 50 08             	lea    0x8(%eax),%edx
   11149:	8b 45 0c             	mov    0xc(%ebp),%eax
   1114c:	8b 40 14             	mov    0x14(%eax),%eax
   1114f:	c1 e8 08             	shr    $0x8,%eax
   11152:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   11154:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11157:	8d 50 09             	lea    0x9(%eax),%edx
   1115a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1115d:	8b 40 14             	mov    0x14(%eax),%eax
   11160:	88 02                	mov    %al,(%edx)
   11162:	e9 9d 00 00 00       	jmp    11204 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   11167:	8b 45 0c             	mov    0xc(%ebp),%eax
   1116a:	8b 00                	mov    (%eax),%eax
   1116c:	83 f8 02             	cmp    $0x2,%eax
   1116f:	0f 85 8f 00 00 00    	jne    11204 <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   11175:	8b 45 0c             	mov    0xc(%ebp),%eax
   11178:	8b 40 10             	mov    0x10(%eax),%eax
   1117b:	85 c0                	test   %eax,%eax
   1117d:	0f 84 81 00 00 00    	je     11204 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   11183:	68 ad a7 01 00       	push   $0x1a7ad
   11188:	6a 06                	push   $0x6
   1118a:	ff 75 08             	pushl  0x8(%ebp)
   1118d:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11190:	50                   	push   %eax
   11191:	e8 1f 7d ff ff       	call   8eb5 <lodepng_chunk_init>
   11196:	83 c4 10             	add    $0x10,%esp
   11199:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1119c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   111a0:	74 05                	je     111a7 <addChunk_tRNS+0x16b>
   111a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   111a5:	eb 75                	jmp    1121c <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   111a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   111aa:	8d 50 08             	lea    0x8(%eax),%edx
   111ad:	8b 45 0c             	mov    0xc(%ebp),%eax
   111b0:	8b 40 14             	mov    0x14(%eax),%eax
   111b3:	c1 e8 08             	shr    $0x8,%eax
   111b6:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   111b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   111bb:	8d 50 09             	lea    0x9(%eax),%edx
   111be:	8b 45 0c             	mov    0xc(%ebp),%eax
   111c1:	8b 40 14             	mov    0x14(%eax),%eax
   111c4:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   111c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   111c9:	8d 50 0a             	lea    0xa(%eax),%edx
   111cc:	8b 45 0c             	mov    0xc(%ebp),%eax
   111cf:	8b 40 18             	mov    0x18(%eax),%eax
   111d2:	c1 e8 08             	shr    $0x8,%eax
   111d5:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   111d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   111da:	8d 50 0b             	lea    0xb(%eax),%edx
   111dd:	8b 45 0c             	mov    0xc(%ebp),%eax
   111e0:	8b 40 18             	mov    0x18(%eax),%eax
   111e3:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   111e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   111e8:	8d 50 0c             	lea    0xc(%eax),%edx
   111eb:	8b 45 0c             	mov    0xc(%ebp),%eax
   111ee:	8b 40 1c             	mov    0x1c(%eax),%eax
   111f1:	c1 e8 08             	shr    $0x8,%eax
   111f4:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   111f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   111f9:	8d 50 0d             	lea    0xd(%eax),%edx
   111fc:	8b 45 0c             	mov    0xc(%ebp),%eax
   111ff:	8b 40 1c             	mov    0x1c(%eax),%eax
   11202:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   11204:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11207:	85 c0                	test   %eax,%eax
   11209:	74 0c                	je     11217 <addChunk_tRNS+0x1db>
   1120b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1120e:	50                   	push   %eax
   1120f:	e8 4a 79 ff ff       	call   8b5e <lodepng_chunk_generate_crc>
   11214:	83 c4 04             	add    $0x4,%esp
  return 0;
   11217:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1121c:	c9                   	leave  
   1121d:	c3                   	ret    

0001121e <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   1121e:	55                   	push   %ebp
   1121f:	89 e5                	mov    %esp,%ebp
   11221:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   11224:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   1122b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   11232:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   11239:	83 ec 0c             	sub    $0xc,%esp
   1123c:	ff 75 14             	pushl  0x14(%ebp)
   1123f:	ff 75 10             	pushl  0x10(%ebp)
   11242:	ff 75 0c             	pushl  0xc(%ebp)
   11245:	8d 45 ec             	lea    -0x14(%ebp),%eax
   11248:	50                   	push   %eax
   11249:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1124c:	50                   	push   %eax
   1124d:	e8 fb 74 ff ff       	call   874d <zlib_compress>
   11252:	83 c4 20             	add    $0x20,%esp
   11255:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   11258:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1125c:	75 1b                	jne    11279 <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   1125e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11261:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11264:	50                   	push   %eax
   11265:	68 e4 a7 01 00       	push   $0x1a7e4
   1126a:	52                   	push   %edx
   1126b:	ff 75 08             	pushl  0x8(%ebp)
   1126e:	e8 ea 7c ff ff       	call   8f5d <lodepng_chunk_createv>
   11273:	83 c4 10             	add    $0x10,%esp
   11276:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   11279:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1127c:	83 ec 0c             	sub    $0xc,%esp
   1127f:	50                   	push   %eax
   11280:	e8 d9 27 ff ff       	call   3a5e <lodepng_free>
   11285:	83 c4 10             	add    $0x10,%esp
  return error;
   11288:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1128b:	c9                   	leave  
   1128c:	c3                   	ret    

0001128d <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   1128d:	55                   	push   %ebp
   1128e:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   11290:	6a 00                	push   $0x0
   11292:	68 e9 a7 01 00       	push   $0x1a7e9
   11297:	6a 00                	push   $0x0
   11299:	ff 75 08             	pushl  0x8(%ebp)
   1129c:	e8 bc 7c ff ff       	call   8f5d <lodepng_chunk_createv>
   112a1:	83 c4 10             	add    $0x10,%esp
}
   112a4:	c9                   	leave  
   112a5:	c3                   	ret    

000112a6 <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   112a6:	55                   	push   %ebp
   112a7:	89 e5                	mov    %esp,%ebp
   112a9:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   112ac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   112b3:	ff 75 0c             	pushl  0xc(%ebp)
   112b6:	e8 1e 28 ff ff       	call   3ad9 <lodepng_strlen>
   112bb:	83 c4 04             	add    $0x4,%esp
   112be:	89 45 fc             	mov    %eax,-0x4(%ebp)
   112c1:	ff 75 10             	pushl  0x10(%ebp)
   112c4:	e8 10 28 ff ff       	call   3ad9 <lodepng_strlen>
   112c9:	83 c4 04             	add    $0x4,%esp
   112cc:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   112cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
   112d2:	8d 50 01             	lea    0x1(%eax),%edx
   112d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
   112d8:	01 d0                	add    %edx,%eax
   112da:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   112dd:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   112e1:	7e 06                	jle    112e9 <addChunk_tEXt+0x43>
   112e3:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   112e7:	7e 07                	jle    112f0 <addChunk_tEXt+0x4a>
   112e9:	b8 59 00 00 00       	mov    $0x59,%eax
   112ee:	eb 74                	jmp    11364 <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   112f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   112f3:	68 b7 a7 01 00       	push   $0x1a7b7
   112f8:	50                   	push   %eax
   112f9:	ff 75 08             	pushl  0x8(%ebp)
   112fc:	8d 45 ec             	lea    -0x14(%ebp),%eax
   112ff:	50                   	push   %eax
   11300:	e8 b0 7b ff ff       	call   8eb5 <lodepng_chunk_init>
   11305:	83 c4 10             	add    $0x10,%esp
   11308:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1130b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1130f:	74 05                	je     11316 <addChunk_tEXt+0x70>
   11311:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11314:	eb 4e                	jmp    11364 <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   11316:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11319:	83 c0 08             	add    $0x8,%eax
   1131c:	ff 75 fc             	pushl  -0x4(%ebp)
   1131f:	ff 75 0c             	pushl  0xc(%ebp)
   11322:	50                   	push   %eax
   11323:	e8 53 27 ff ff       	call   3a7b <lodepng_memcpy>
   11328:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   1132b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1132e:	8b 55 fc             	mov    -0x4(%ebp),%edx
   11331:	83 c2 08             	add    $0x8,%edx
   11334:	01 d0                	add    %edx,%eax
   11336:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   11339:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1133c:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1133f:	83 c2 09             	add    $0x9,%edx
   11342:	01 d0                	add    %edx,%eax
   11344:	ff 75 f8             	pushl  -0x8(%ebp)
   11347:	ff 75 10             	pushl  0x10(%ebp)
   1134a:	50                   	push   %eax
   1134b:	e8 2b 27 ff ff       	call   3a7b <lodepng_memcpy>
   11350:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   11353:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11356:	50                   	push   %eax
   11357:	e8 02 78 ff ff       	call   8b5e <lodepng_chunk_generate_crc>
   1135c:	83 c4 04             	add    $0x4,%esp
  return 0;
   1135f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11364:	c9                   	leave  
   11365:	c3                   	ret    

00011366 <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   11366:	55                   	push   %ebp
   11367:	89 e5                	mov    %esp,%ebp
   11369:	53                   	push   %ebx
   1136a:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   1136d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11374:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   1137b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   11382:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   11389:	ff 75 10             	pushl  0x10(%ebp)
   1138c:	e8 48 27 ff ff       	call   3ad9 <lodepng_strlen>
   11391:	83 c4 04             	add    $0x4,%esp
   11394:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   11397:	ff 75 0c             	pushl  0xc(%ebp)
   1139a:	e8 3a 27 ff ff       	call   3ad9 <lodepng_strlen>
   1139f:	83 c4 04             	add    $0x4,%esp
   113a2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   113a5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   113a9:	7e 06                	jle    113b1 <addChunk_zTXt+0x4b>
   113ab:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   113af:	7e 0a                	jle    113bb <addChunk_zTXt+0x55>
   113b1:	b8 59 00 00 00       	mov    $0x59,%eax
   113b6:	e9 c8 00 00 00       	jmp    11483 <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   113bb:	83 ec 0c             	sub    $0xc,%esp
   113be:	ff 75 14             	pushl  0x14(%ebp)
   113c1:	ff 75 f0             	pushl  -0x10(%ebp)
   113c4:	ff 75 10             	pushl  0x10(%ebp)
   113c7:	8d 45 dc             	lea    -0x24(%ebp),%eax
   113ca:	50                   	push   %eax
   113cb:	8d 45 e0             	lea    -0x20(%ebp),%eax
   113ce:	50                   	push   %eax
   113cf:	e8 79 73 ff ff       	call   874d <zlib_compress>
   113d4:	83 c4 20             	add    $0x20,%esp
   113d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   113da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   113de:	75 29                	jne    11409 <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   113e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   113e3:	8d 50 02             	lea    0x2(%eax),%edx
   113e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   113e9:	01 d0                	add    %edx,%eax
   113eb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   113ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
   113f1:	68 bc a7 01 00       	push   $0x1a7bc
   113f6:	50                   	push   %eax
   113f7:	ff 75 08             	pushl  0x8(%ebp)
   113fa:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   113fd:	50                   	push   %eax
   113fe:	e8 b2 7a ff ff       	call   8eb5 <lodepng_chunk_init>
   11403:	83 c4 10             	add    $0x10,%esp
   11406:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11409:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1140d:	75 62                	jne    11471 <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   1140f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11412:	83 c0 08             	add    $0x8,%eax
   11415:	83 ec 04             	sub    $0x4,%esp
   11418:	ff 75 ec             	pushl  -0x14(%ebp)
   1141b:	ff 75 0c             	pushl  0xc(%ebp)
   1141e:	50                   	push   %eax
   1141f:	e8 57 26 ff ff       	call   3a7b <lodepng_memcpy>
   11424:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   11427:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1142a:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1142d:	83 c2 08             	add    $0x8,%edx
   11430:	01 d0                	add    %edx,%eax
   11432:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   11435:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11438:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1143b:	83 c2 09             	add    $0x9,%edx
   1143e:	01 d0                	add    %edx,%eax
   11440:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11443:	8b 55 dc             	mov    -0x24(%ebp),%edx
   11446:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11449:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   1144c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   1144f:	83 c3 0a             	add    $0xa,%ebx
   11452:	01 d9                	add    %ebx,%ecx
   11454:	83 ec 04             	sub    $0x4,%esp
   11457:	52                   	push   %edx
   11458:	50                   	push   %eax
   11459:	51                   	push   %ecx
   1145a:	e8 1c 26 ff ff       	call   3a7b <lodepng_memcpy>
   1145f:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   11462:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11465:	83 ec 0c             	sub    $0xc,%esp
   11468:	50                   	push   %eax
   11469:	e8 f0 76 ff ff       	call   8b5e <lodepng_chunk_generate_crc>
   1146e:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11471:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11474:	83 ec 0c             	sub    $0xc,%esp
   11477:	50                   	push   %eax
   11478:	e8 e1 25 ff ff       	call   3a5e <lodepng_free>
   1147d:	83 c4 10             	add    $0x10,%esp
  return error;
   11480:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11483:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11486:	c9                   	leave  
   11487:	c3                   	ret    

00011488 <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   11488:	55                   	push   %ebp
   11489:	89 e5                	mov    %esp,%ebp
   1148b:	53                   	push   %ebx
   1148c:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   1148f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11496:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   1149d:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   114a4:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   114ab:	ff 75 1c             	pushl  0x1c(%ebp)
   114ae:	e8 26 26 ff ff       	call   3ad9 <lodepng_strlen>
   114b3:	83 c4 04             	add    $0x4,%esp
   114b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   114b9:	ff 75 10             	pushl  0x10(%ebp)
   114bc:	e8 18 26 ff ff       	call   3ad9 <lodepng_strlen>
   114c1:	83 c4 04             	add    $0x4,%esp
   114c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
   114c7:	ff 75 14             	pushl  0x14(%ebp)
   114ca:	e8 0a 26 ff ff       	call   3ad9 <lodepng_strlen>
   114cf:	83 c4 04             	add    $0x4,%esp
   114d2:	89 45 e8             	mov    %eax,-0x18(%ebp)
   114d5:	ff 75 18             	pushl  0x18(%ebp)
   114d8:	e8 fc 25 ff ff       	call   3ad9 <lodepng_strlen>
   114dd:	83 c4 04             	add    $0x4,%esp
   114e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   114e3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   114e7:	7e 06                	jle    114ef <addChunk_iTXt+0x67>
   114e9:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   114ed:	7e 0a                	jle    114f9 <addChunk_iTXt+0x71>
   114ef:	b8 59 00 00 00       	mov    $0x59,%eax
   114f4:	e9 9a 01 00 00       	jmp    11693 <addChunk_iTXt+0x20b>

  if(compress) {
   114f9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   114fd:	74 1f                	je     1151e <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   114ff:	83 ec 0c             	sub    $0xc,%esp
   11502:	ff 75 20             	pushl  0x20(%ebp)
   11505:	ff 75 f0             	pushl  -0x10(%ebp)
   11508:	ff 75 1c             	pushl  0x1c(%ebp)
   1150b:	8d 45 d0             	lea    -0x30(%ebp),%eax
   1150e:	50                   	push   %eax
   1150f:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   11512:	50                   	push   %eax
   11513:	e8 35 72 ff ff       	call   874d <zlib_compress>
   11518:	83 c4 20             	add    $0x20,%esp
   1151b:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   1151e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11522:	75 44                	jne    11568 <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   11524:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11527:	8d 50 03             	lea    0x3(%eax),%edx
   1152a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1152d:	01 d0                	add    %edx,%eax
   1152f:	8d 50 01             	lea    0x1(%eax),%edx
   11532:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11535:	01 d0                	add    %edx,%eax
   11537:	8d 50 01             	lea    0x1(%eax),%edx
   1153a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1153e:	74 05                	je     11545 <addChunk_iTXt+0xbd>
   11540:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11543:	eb 03                	jmp    11548 <addChunk_iTXt+0xc0>
   11545:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11548:	01 d0                	add    %edx,%eax
   1154a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   1154d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11550:	68 c1 a7 01 00       	push   $0x1a7c1
   11555:	50                   	push   %eax
   11556:	ff 75 08             	pushl  0x8(%ebp)
   11559:	8d 45 d8             	lea    -0x28(%ebp),%eax
   1155c:	50                   	push   %eax
   1155d:	e8 53 79 ff ff       	call   8eb5 <lodepng_chunk_init>
   11562:	83 c4 10             	add    $0x10,%esp
   11565:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11568:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1156c:	0f 85 0f 01 00 00    	jne    11681 <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   11572:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   11579:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1157c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1157f:	01 d0                	add    %edx,%eax
   11581:	83 ec 04             	sub    $0x4,%esp
   11584:	ff 75 ec             	pushl  -0x14(%ebp)
   11587:	ff 75 10             	pushl  0x10(%ebp)
   1158a:	50                   	push   %eax
   1158b:	e8 eb 24 ff ff       	call   3a7b <lodepng_memcpy>
   11590:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   11593:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11596:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11599:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1159c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1159f:	8d 50 01             	lea    0x1(%eax),%edx
   115a2:	89 55 dc             	mov    %edx,-0x24(%ebp)
   115a5:	01 c8                	add    %ecx,%eax
   115a7:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   115aa:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   115ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
   115b0:	8d 50 01             	lea    0x1(%eax),%edx
   115b3:	89 55 dc             	mov    %edx,-0x24(%ebp)
   115b6:	01 c8                	add    %ecx,%eax
   115b8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   115bc:	0f 95 c2             	setne  %dl
   115bf:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   115c1:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   115c4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   115c7:	8d 50 01             	lea    0x1(%eax),%edx
   115ca:	89 55 dc             	mov    %edx,-0x24(%ebp)
   115cd:	01 c8                	add    %ecx,%eax
   115cf:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   115d2:	8b 55 d8             	mov    -0x28(%ebp),%edx
   115d5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   115d8:	01 d0                	add    %edx,%eax
   115da:	83 ec 04             	sub    $0x4,%esp
   115dd:	ff 75 e8             	pushl  -0x18(%ebp)
   115e0:	ff 75 14             	pushl  0x14(%ebp)
   115e3:	50                   	push   %eax
   115e4:	e8 92 24 ff ff       	call   3a7b <lodepng_memcpy>
   115e9:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   115ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
   115ef:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   115f2:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   115f5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   115f8:	8d 50 01             	lea    0x1(%eax),%edx
   115fb:	89 55 dc             	mov    %edx,-0x24(%ebp)
   115fe:	01 c8                	add    %ecx,%eax
   11600:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   11603:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11606:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11609:	01 d0                	add    %edx,%eax
   1160b:	83 ec 04             	sub    $0x4,%esp
   1160e:	ff 75 e4             	pushl  -0x1c(%ebp)
   11611:	ff 75 18             	pushl  0x18(%ebp)
   11614:	50                   	push   %eax
   11615:	e8 61 24 ff ff       	call   3a7b <lodepng_memcpy>
   1161a:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   1161d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11620:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11623:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11626:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11629:	8d 50 01             	lea    0x1(%eax),%edx
   1162c:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1162f:	01 c8                	add    %ecx,%eax
   11631:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   11634:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11638:	74 1e                	je     11658 <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   1163a:	8b 55 d0             	mov    -0x30(%ebp),%edx
   1163d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   11640:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   11643:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   11646:	01 d9                	add    %ebx,%ecx
   11648:	83 ec 04             	sub    $0x4,%esp
   1164b:	52                   	push   %edx
   1164c:	50                   	push   %eax
   1164d:	51                   	push   %ecx
   1164e:	e8 28 24 ff ff       	call   3a7b <lodepng_memcpy>
   11653:	83 c4 10             	add    $0x10,%esp
   11656:	eb 1a                	jmp    11672 <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   11658:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1165b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1165e:	01 d0                	add    %edx,%eax
   11660:	83 ec 04             	sub    $0x4,%esp
   11663:	ff 75 f0             	pushl  -0x10(%ebp)
   11666:	ff 75 1c             	pushl  0x1c(%ebp)
   11669:	50                   	push   %eax
   1166a:	e8 0c 24 ff ff       	call   3a7b <lodepng_memcpy>
   1166f:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   11672:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11675:	83 ec 0c             	sub    $0xc,%esp
   11678:	50                   	push   %eax
   11679:	e8 e0 74 ff ff       	call   8b5e <lodepng_chunk_generate_crc>
   1167e:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11681:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   11684:	83 ec 0c             	sub    $0xc,%esp
   11687:	50                   	push   %eax
   11688:	e8 d1 23 ff ff       	call   3a5e <lodepng_free>
   1168d:	83 c4 10             	add    $0x10,%esp
  return error;
   11690:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11693:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11696:	c9                   	leave  
   11697:	c3                   	ret    

00011698 <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   11698:	55                   	push   %ebp
   11699:	89 e5                	mov    %esp,%ebp
   1169b:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   1169e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   116a5:	8b 45 0c             	mov    0xc(%ebp),%eax
   116a8:	8b 40 0c             	mov    0xc(%eax),%eax
   116ab:	85 c0                	test   %eax,%eax
   116ad:	74 0b                	je     116ba <addChunk_bKGD+0x22>
   116af:	8b 45 0c             	mov    0xc(%ebp),%eax
   116b2:	8b 40 0c             	mov    0xc(%eax),%eax
   116b5:	83 f8 04             	cmp    $0x4,%eax
   116b8:	75 4b                	jne    11705 <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   116ba:	68 b2 a7 01 00       	push   $0x1a7b2
   116bf:	6a 02                	push   $0x2
   116c1:	ff 75 08             	pushl  0x8(%ebp)
   116c4:	8d 45 f0             	lea    -0x10(%ebp),%eax
   116c7:	50                   	push   %eax
   116c8:	e8 e8 77 ff ff       	call   8eb5 <lodepng_chunk_init>
   116cd:	83 c4 10             	add    $0x10,%esp
   116d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
   116d3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   116d7:	74 08                	je     116e1 <addChunk_bKGD+0x49>
   116d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116dc:	e9 19 01 00 00       	jmp    117fa <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   116e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116e4:	8d 50 08             	lea    0x8(%eax),%edx
   116e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   116ea:	8b 40 30             	mov    0x30(%eax),%eax
   116ed:	c1 e8 08             	shr    $0x8,%eax
   116f0:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   116f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116f5:	8d 50 09             	lea    0x9(%eax),%edx
   116f8:	8b 45 0c             	mov    0xc(%ebp),%eax
   116fb:	8b 40 30             	mov    0x30(%eax),%eax
   116fe:	88 02                	mov    %al,(%edx)
   11700:	e9 dd 00 00 00       	jmp    117e2 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   11705:	8b 45 0c             	mov    0xc(%ebp),%eax
   11708:	8b 40 0c             	mov    0xc(%eax),%eax
   1170b:	83 f8 02             	cmp    $0x2,%eax
   1170e:	74 0f                	je     1171f <addChunk_bKGD+0x87>
   11710:	8b 45 0c             	mov    0xc(%ebp),%eax
   11713:	8b 40 0c             	mov    0xc(%eax),%eax
   11716:	83 f8 06             	cmp    $0x6,%eax
   11719:	0f 85 86 00 00 00    	jne    117a5 <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   1171f:	68 b2 a7 01 00       	push   $0x1a7b2
   11724:	6a 06                	push   $0x6
   11726:	ff 75 08             	pushl  0x8(%ebp)
   11729:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1172c:	50                   	push   %eax
   1172d:	e8 83 77 ff ff       	call   8eb5 <lodepng_chunk_init>
   11732:	83 c4 10             	add    $0x10,%esp
   11735:	89 45 f8             	mov    %eax,-0x8(%ebp)
   11738:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   1173c:	74 08                	je     11746 <addChunk_bKGD+0xae>
   1173e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11741:	e9 b4 00 00 00       	jmp    117fa <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   11746:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11749:	8d 50 08             	lea    0x8(%eax),%edx
   1174c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1174f:	8b 40 30             	mov    0x30(%eax),%eax
   11752:	c1 e8 08             	shr    $0x8,%eax
   11755:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   11757:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1175a:	8d 50 09             	lea    0x9(%eax),%edx
   1175d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11760:	8b 40 30             	mov    0x30(%eax),%eax
   11763:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   11765:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11768:	8d 50 0a             	lea    0xa(%eax),%edx
   1176b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1176e:	8b 40 34             	mov    0x34(%eax),%eax
   11771:	c1 e8 08             	shr    $0x8,%eax
   11774:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   11776:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11779:	8d 50 0b             	lea    0xb(%eax),%edx
   1177c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1177f:	8b 40 34             	mov    0x34(%eax),%eax
   11782:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   11784:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11787:	8d 50 0c             	lea    0xc(%eax),%edx
   1178a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1178d:	8b 40 38             	mov    0x38(%eax),%eax
   11790:	c1 e8 08             	shr    $0x8,%eax
   11793:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   11795:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11798:	8d 50 0d             	lea    0xd(%eax),%edx
   1179b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1179e:	8b 40 38             	mov    0x38(%eax),%eax
   117a1:	88 02                	mov    %al,(%edx)
   117a3:	eb 3d                	jmp    117e2 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   117a5:	8b 45 0c             	mov    0xc(%ebp),%eax
   117a8:	8b 40 0c             	mov    0xc(%eax),%eax
   117ab:	83 f8 03             	cmp    $0x3,%eax
   117ae:	75 32                	jne    117e2 <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   117b0:	68 b2 a7 01 00       	push   $0x1a7b2
   117b5:	6a 01                	push   $0x1
   117b7:	ff 75 08             	pushl  0x8(%ebp)
   117ba:	8d 45 f0             	lea    -0x10(%ebp),%eax
   117bd:	50                   	push   %eax
   117be:	e8 f2 76 ff ff       	call   8eb5 <lodepng_chunk_init>
   117c3:	83 c4 10             	add    $0x10,%esp
   117c6:	89 45 fc             	mov    %eax,-0x4(%ebp)
   117c9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   117cd:	74 05                	je     117d4 <addChunk_bKGD+0x13c>
   117cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
   117d2:	eb 26                	jmp    117fa <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   117d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   117d7:	8d 50 08             	lea    0x8(%eax),%edx
   117da:	8b 45 0c             	mov    0xc(%ebp),%eax
   117dd:	8b 40 30             	mov    0x30(%eax),%eax
   117e0:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   117e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   117e5:	85 c0                	test   %eax,%eax
   117e7:	74 0c                	je     117f5 <addChunk_bKGD+0x15d>
   117e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   117ec:	50                   	push   %eax
   117ed:	e8 6c 73 ff ff       	call   8b5e <lodepng_chunk_generate_crc>
   117f2:	83 c4 04             	add    $0x4,%esp
  return 0;
   117f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   117fa:	c9                   	leave  
   117fb:	c3                   	ret    

000117fc <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   117fc:	55                   	push   %ebp
   117fd:	89 e5                	mov    %esp,%ebp
   117ff:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   11802:	68 c6 a7 01 00       	push   $0x1a7c6
   11807:	6a 07                	push   $0x7
   11809:	ff 75 08             	pushl  0x8(%ebp)
   1180c:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1180f:	50                   	push   %eax
   11810:	e8 a0 76 ff ff       	call   8eb5 <lodepng_chunk_init>
   11815:	83 c4 10             	add    $0x10,%esp
   11818:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1181b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1181f:	74 05                	je     11826 <addChunk_tIME+0x2a>
   11821:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11824:	eb 74                	jmp    1189a <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   11826:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11829:	8d 50 08             	lea    0x8(%eax),%edx
   1182c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1182f:	8b 00                	mov    (%eax),%eax
   11831:	c1 e8 08             	shr    $0x8,%eax
   11834:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   11836:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11839:	8d 50 09             	lea    0x9(%eax),%edx
   1183c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1183f:	8b 00                	mov    (%eax),%eax
   11841:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   11843:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11846:	8d 50 0a             	lea    0xa(%eax),%edx
   11849:	8b 45 0c             	mov    0xc(%ebp),%eax
   1184c:	8b 40 04             	mov    0x4(%eax),%eax
   1184f:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   11851:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11854:	8d 50 0b             	lea    0xb(%eax),%edx
   11857:	8b 45 0c             	mov    0xc(%ebp),%eax
   1185a:	8b 40 08             	mov    0x8(%eax),%eax
   1185d:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   1185f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11862:	8d 50 0c             	lea    0xc(%eax),%edx
   11865:	8b 45 0c             	mov    0xc(%ebp),%eax
   11868:	8b 40 0c             	mov    0xc(%eax),%eax
   1186b:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   1186d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11870:	8d 50 0d             	lea    0xd(%eax),%edx
   11873:	8b 45 0c             	mov    0xc(%ebp),%eax
   11876:	8b 40 10             	mov    0x10(%eax),%eax
   11879:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   1187b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1187e:	8d 50 0e             	lea    0xe(%eax),%edx
   11881:	8b 45 0c             	mov    0xc(%ebp),%eax
   11884:	8b 40 14             	mov    0x14(%eax),%eax
   11887:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   11889:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1188c:	50                   	push   %eax
   1188d:	e8 cc 72 ff ff       	call   8b5e <lodepng_chunk_generate_crc>
   11892:	83 c4 04             	add    $0x4,%esp
  return 0;
   11895:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1189a:	c9                   	leave  
   1189b:	c3                   	ret    

0001189c <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   1189c:	55                   	push   %ebp
   1189d:	89 e5                	mov    %esp,%ebp
   1189f:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   118a2:	68 cb a7 01 00       	push   $0x1a7cb
   118a7:	6a 09                	push   $0x9
   118a9:	ff 75 08             	pushl  0x8(%ebp)
   118ac:	8d 45 f8             	lea    -0x8(%ebp),%eax
   118af:	50                   	push   %eax
   118b0:	e8 00 76 ff ff       	call   8eb5 <lodepng_chunk_init>
   118b5:	83 c4 10             	add    $0x10,%esp
   118b8:	89 45 fc             	mov    %eax,-0x4(%ebp)
   118bb:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   118bf:	74 05                	je     118c6 <addChunk_pHYs+0x2a>
   118c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   118c4:	eb 51                	jmp    11917 <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   118c6:	8b 45 0c             	mov    0xc(%ebp),%eax
   118c9:	8b 40 7c             	mov    0x7c(%eax),%eax
   118cc:	8b 55 f8             	mov    -0x8(%ebp),%edx
   118cf:	83 c2 08             	add    $0x8,%edx
   118d2:	50                   	push   %eax
   118d3:	52                   	push   %edx
   118d4:	e8 25 25 ff ff       	call   3dfe <lodepng_set32bitInt>
   118d9:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   118dc:	8b 45 0c             	mov    0xc(%ebp),%eax
   118df:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   118e5:	8b 55 f8             	mov    -0x8(%ebp),%edx
   118e8:	83 c2 0c             	add    $0xc,%edx
   118eb:	50                   	push   %eax
   118ec:	52                   	push   %edx
   118ed:	e8 0c 25 ff ff       	call   3dfe <lodepng_set32bitInt>
   118f2:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   118f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
   118f8:	8d 50 10             	lea    0x10(%eax),%edx
   118fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   118fe:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   11904:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   11906:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11909:	50                   	push   %eax
   1190a:	e8 4f 72 ff ff       	call   8b5e <lodepng_chunk_generate_crc>
   1190f:	83 c4 04             	add    $0x4,%esp
  return 0;
   11912:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11917:	c9                   	leave  
   11918:	c3                   	ret    

00011919 <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   11919:	55                   	push   %ebp
   1191a:	89 e5                	mov    %esp,%ebp
   1191c:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   1191f:	68 d0 a7 01 00       	push   $0x1a7d0
   11924:	6a 04                	push   $0x4
   11926:	ff 75 08             	pushl  0x8(%ebp)
   11929:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1192c:	50                   	push   %eax
   1192d:	e8 83 75 ff ff       	call   8eb5 <lodepng_chunk_init>
   11932:	83 c4 10             	add    $0x10,%esp
   11935:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11938:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1193c:	74 05                	je     11943 <addChunk_gAMA+0x2a>
   1193e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11941:	eb 2a                	jmp    1196d <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   11943:	8b 45 0c             	mov    0xc(%ebp),%eax
   11946:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   1194c:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1194f:	83 c2 08             	add    $0x8,%edx
   11952:	50                   	push   %eax
   11953:	52                   	push   %edx
   11954:	e8 a5 24 ff ff       	call   3dfe <lodepng_set32bitInt>
   11959:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   1195c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1195f:	50                   	push   %eax
   11960:	e8 f9 71 ff ff       	call   8b5e <lodepng_chunk_generate_crc>
   11965:	83 c4 04             	add    $0x4,%esp
  return 0;
   11968:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1196d:	c9                   	leave  
   1196e:	c3                   	ret    

0001196f <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   1196f:	55                   	push   %ebp
   11970:	89 e5                	mov    %esp,%ebp
   11972:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   11975:	68 d5 a7 01 00       	push   $0x1a7d5
   1197a:	6a 20                	push   $0x20
   1197c:	ff 75 08             	pushl  0x8(%ebp)
   1197f:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11982:	50                   	push   %eax
   11983:	e8 2d 75 ff ff       	call   8eb5 <lodepng_chunk_init>
   11988:	83 c4 10             	add    $0x10,%esp
   1198b:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1198e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11992:	74 08                	je     1199c <addChunk_cHRM+0x2d>
   11994:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11997:	e9 d9 00 00 00       	jmp    11a75 <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   1199c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1199f:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   119a5:	8b 55 f8             	mov    -0x8(%ebp),%edx
   119a8:	83 c2 08             	add    $0x8,%edx
   119ab:	50                   	push   %eax
   119ac:	52                   	push   %edx
   119ad:	e8 4c 24 ff ff       	call   3dfe <lodepng_set32bitInt>
   119b2:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   119b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   119b8:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   119be:	8b 55 f8             	mov    -0x8(%ebp),%edx
   119c1:	83 c2 0c             	add    $0xc,%edx
   119c4:	50                   	push   %eax
   119c5:	52                   	push   %edx
   119c6:	e8 33 24 ff ff       	call   3dfe <lodepng_set32bitInt>
   119cb:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   119ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   119d1:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   119d7:	8b 55 f8             	mov    -0x8(%ebp),%edx
   119da:	83 c2 10             	add    $0x10,%edx
   119dd:	50                   	push   %eax
   119de:	52                   	push   %edx
   119df:	e8 1a 24 ff ff       	call   3dfe <lodepng_set32bitInt>
   119e4:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   119e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   119ea:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   119f0:	8b 55 f8             	mov    -0x8(%ebp),%edx
   119f3:	83 c2 14             	add    $0x14,%edx
   119f6:	50                   	push   %eax
   119f7:	52                   	push   %edx
   119f8:	e8 01 24 ff ff       	call   3dfe <lodepng_set32bitInt>
   119fd:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   11a00:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a03:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   11a09:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11a0c:	83 c2 18             	add    $0x18,%edx
   11a0f:	50                   	push   %eax
   11a10:	52                   	push   %edx
   11a11:	e8 e8 23 ff ff       	call   3dfe <lodepng_set32bitInt>
   11a16:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   11a19:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a1c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   11a22:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11a25:	83 c2 1c             	add    $0x1c,%edx
   11a28:	50                   	push   %eax
   11a29:	52                   	push   %edx
   11a2a:	e8 cf 23 ff ff       	call   3dfe <lodepng_set32bitInt>
   11a2f:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   11a32:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a35:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   11a3b:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11a3e:	83 c2 20             	add    $0x20,%edx
   11a41:	50                   	push   %eax
   11a42:	52                   	push   %edx
   11a43:	e8 b6 23 ff ff       	call   3dfe <lodepng_set32bitInt>
   11a48:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   11a4b:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a4e:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   11a54:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11a57:	83 c2 24             	add    $0x24,%edx
   11a5a:	50                   	push   %eax
   11a5b:	52                   	push   %edx
   11a5c:	e8 9d 23 ff ff       	call   3dfe <lodepng_set32bitInt>
   11a61:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   11a64:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11a67:	50                   	push   %eax
   11a68:	e8 f1 70 ff ff       	call   8b5e <lodepng_chunk_generate_crc>
   11a6d:	83 c4 04             	add    $0x4,%esp
  return 0;
   11a70:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11a75:	c9                   	leave  
   11a76:	c3                   	ret    

00011a77 <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   11a77:	55                   	push   %ebp
   11a78:	89 e5                	mov    %esp,%ebp
   11a7a:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   11a7d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a80:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   11a86:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   11a89:	8d 45 ff             	lea    -0x1(%ebp),%eax
   11a8c:	50                   	push   %eax
   11a8d:	68 da a7 01 00       	push   $0x1a7da
   11a92:	6a 01                	push   $0x1
   11a94:	ff 75 08             	pushl  0x8(%ebp)
   11a97:	e8 c1 74 ff ff       	call   8f5d <lodepng_chunk_createv>
   11a9c:	83 c4 10             	add    $0x10,%esp
}
   11a9f:	c9                   	leave  
   11aa0:	c3                   	ret    

00011aa1 <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   11aa1:	55                   	push   %ebp
   11aa2:	89 e5                	mov    %esp,%ebp
   11aa4:	53                   	push   %ebx
   11aa5:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   11aa8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11aaf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   11ab6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   11abd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   11ac4:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ac7:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11acd:	50                   	push   %eax
   11ace:	e8 06 20 ff ff       	call   3ad9 <lodepng_strlen>
   11ad3:	83 c4 04             	add    $0x4,%esp
   11ad6:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11ad9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11add:	7e 06                	jle    11ae5 <addChunk_iCCP+0x44>
   11adf:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   11ae3:	7e 0a                	jle    11aef <addChunk_iCCP+0x4e>
   11ae5:	b8 59 00 00 00       	mov    $0x59,%eax
   11aea:	e9 df 00 00 00       	jmp    11bce <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   11aef:	8b 45 0c             	mov    0xc(%ebp),%eax
   11af2:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   11af8:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   11afa:	8b 45 0c             	mov    0xc(%ebp),%eax
   11afd:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   11b03:	83 ec 0c             	sub    $0xc,%esp
   11b06:	ff 75 10             	pushl  0x10(%ebp)
   11b09:	52                   	push   %edx
   11b0a:	50                   	push   %eax
   11b0b:	8d 45 e0             	lea    -0x20(%ebp),%eax
   11b0e:	50                   	push   %eax
   11b0f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   11b12:	50                   	push   %eax
   11b13:	e8 35 6c ff ff       	call   874d <zlib_compress>
   11b18:	83 c4 20             	add    $0x20,%esp
   11b1b:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   11b1e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11b22:	75 29                	jne    11b4d <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   11b24:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b27:	8d 50 02             	lea    0x2(%eax),%edx
   11b2a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11b2d:	01 d0                	add    %edx,%eax
   11b2f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   11b32:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b35:	68 df a7 01 00       	push   $0x1a7df
   11b3a:	50                   	push   %eax
   11b3b:	ff 75 08             	pushl  0x8(%ebp)
   11b3e:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11b41:	50                   	push   %eax
   11b42:	e8 6e 73 ff ff       	call   8eb5 <lodepng_chunk_init>
   11b47:	83 c4 10             	add    $0x10,%esp
   11b4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11b4d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11b51:	75 69                	jne    11bbc <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   11b53:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b56:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11b5c:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11b5f:	83 c2 08             	add    $0x8,%edx
   11b62:	83 ec 04             	sub    $0x4,%esp
   11b65:	ff 75 f0             	pushl  -0x10(%ebp)
   11b68:	50                   	push   %eax
   11b69:	52                   	push   %edx
   11b6a:	e8 0c 1f ff ff       	call   3a7b <lodepng_memcpy>
   11b6f:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   11b72:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b75:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11b78:	83 c2 08             	add    $0x8,%edx
   11b7b:	01 d0                	add    %edx,%eax
   11b7d:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   11b80:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b83:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11b86:	83 c2 09             	add    $0x9,%edx
   11b89:	01 d0                	add    %edx,%eax
   11b8b:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11b8e:	8b 55 e0             	mov    -0x20(%ebp),%edx
   11b91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b94:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   11b97:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   11b9a:	83 c3 0a             	add    $0xa,%ebx
   11b9d:	01 d9                	add    %ebx,%ecx
   11b9f:	83 ec 04             	sub    $0x4,%esp
   11ba2:	52                   	push   %edx
   11ba3:	50                   	push   %eax
   11ba4:	51                   	push   %ecx
   11ba5:	e8 d1 1e ff ff       	call   3a7b <lodepng_memcpy>
   11baa:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   11bad:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11bb0:	83 ec 0c             	sub    $0xc,%esp
   11bb3:	50                   	push   %eax
   11bb4:	e8 a5 6f ff ff       	call   8b5e <lodepng_chunk_generate_crc>
   11bb9:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11bbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11bbf:	83 ec 0c             	sub    $0xc,%esp
   11bc2:	50                   	push   %eax
   11bc3:	e8 96 1e ff ff       	call   3a5e <lodepng_free>
   11bc8:	83 c4 10             	add    $0x10,%esp
  return error;
   11bcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11bce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11bd1:	c9                   	leave  
   11bd2:	c3                   	ret    

00011bd3 <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   11bd3:	55                   	push   %ebp
   11bd4:	89 e5                	mov    %esp,%ebp
   11bd6:	56                   	push   %esi
   11bd7:	53                   	push   %ebx
   11bd8:	83 ec 14             	sub    $0x14,%esp
   11bdb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11bde:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   11be1:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   11be5:	83 f8 04             	cmp    $0x4,%eax
   11be8:	0f 87 41 03 00 00    	ja     11f2f <filterScanline+0x35c>
   11bee:	8b 04 85 f0 a7 01 00 	mov    0x1a7f0(,%eax,4),%eax
   11bf5:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   11bf7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11bfe:	eb 19                	jmp    11c19 <filterScanline+0x46>
   11c00:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11c03:	8b 45 08             	mov    0x8(%ebp),%eax
   11c06:	01 c2                	add    %eax,%edx
   11c08:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11c0b:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c0e:	01 c8                	add    %ecx,%eax
   11c10:	0f b6 00             	movzbl (%eax),%eax
   11c13:	88 02                	mov    %al,(%edx)
   11c15:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11c19:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c1c:	3b 45 14             	cmp    0x14(%ebp),%eax
   11c1f:	75 df                	jne    11c00 <filterScanline+0x2d>
      break;
   11c21:	e9 0a 03 00 00       	jmp    11f30 <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11c26:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11c2d:	eb 19                	jmp    11c48 <filterScanline+0x75>
   11c2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11c32:	8b 45 08             	mov    0x8(%ebp),%eax
   11c35:	01 c2                	add    %eax,%edx
   11c37:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11c3a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c3d:	01 c8                	add    %ecx,%eax
   11c3f:	0f b6 00             	movzbl (%eax),%eax
   11c42:	88 02                	mov    %al,(%edx)
   11c44:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11c48:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c4b:	3b 45 18             	cmp    0x18(%ebp),%eax
   11c4e:	75 df                	jne    11c2f <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   11c50:	8b 45 18             	mov    0x18(%ebp),%eax
   11c53:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11c56:	eb 2d                	jmp    11c85 <filterScanline+0xb2>
   11c58:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11c5b:	8b 45 08             	mov    0x8(%ebp),%eax
   11c5e:	01 c2                	add    %eax,%edx
   11c60:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11c63:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c66:	01 c8                	add    %ecx,%eax
   11c68:	0f b6 08             	movzbl (%eax),%ecx
   11c6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c6e:	2b 45 18             	sub    0x18(%ebp),%eax
   11c71:	89 c3                	mov    %eax,%ebx
   11c73:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c76:	01 d8                	add    %ebx,%eax
   11c78:	0f b6 00             	movzbl (%eax),%eax
   11c7b:	29 c1                	sub    %eax,%ecx
   11c7d:	89 c8                	mov    %ecx,%eax
   11c7f:	88 02                	mov    %al,(%edx)
   11c81:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11c85:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c88:	3b 45 14             	cmp    0x14(%ebp),%eax
   11c8b:	7c cb                	jl     11c58 <filterScanline+0x85>
      break;
   11c8d:	e9 9e 02 00 00       	jmp    11f30 <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   11c92:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11c96:	74 3e                	je     11cd6 <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   11c98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11c9f:	eb 28                	jmp    11cc9 <filterScanline+0xf6>
   11ca1:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11ca4:	8b 45 08             	mov    0x8(%ebp),%eax
   11ca7:	01 d0                	add    %edx,%eax
   11ca9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11cac:	8b 55 0c             	mov    0xc(%ebp),%edx
   11caf:	01 ca                	add    %ecx,%edx
   11cb1:	0f b6 0a             	movzbl (%edx),%ecx
   11cb4:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11cb7:	8b 55 10             	mov    0x10(%ebp),%edx
   11cba:	01 da                	add    %ebx,%edx
   11cbc:	0f b6 12             	movzbl (%edx),%edx
   11cbf:	29 d1                	sub    %edx,%ecx
   11cc1:	89 ca                	mov    %ecx,%edx
   11cc3:	88 10                	mov    %dl,(%eax)
   11cc5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11cc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ccc:	3b 45 14             	cmp    0x14(%ebp),%eax
   11ccf:	75 d0                	jne    11ca1 <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   11cd1:	e9 5a 02 00 00       	jmp    11f30 <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   11cd6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11cdd:	eb 19                	jmp    11cf8 <filterScanline+0x125>
   11cdf:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11ce2:	8b 45 08             	mov    0x8(%ebp),%eax
   11ce5:	01 c2                	add    %eax,%edx
   11ce7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11cea:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ced:	01 c8                	add    %ecx,%eax
   11cef:	0f b6 00             	movzbl (%eax),%eax
   11cf2:	88 02                	mov    %al,(%edx)
   11cf4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11cf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11cfb:	3b 45 14             	cmp    0x14(%ebp),%eax
   11cfe:	75 df                	jne    11cdf <filterScanline+0x10c>
      }
      break;
   11d00:	e9 2b 02 00 00       	jmp    11f30 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   11d05:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11d09:	0f 84 90 00 00 00    	je     11d9f <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   11d0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11d16:	eb 28                	jmp    11d40 <filterScanline+0x16d>
   11d18:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11d1b:	8b 45 08             	mov    0x8(%ebp),%eax
   11d1e:	01 d0                	add    %edx,%eax
   11d20:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11d23:	8b 55 0c             	mov    0xc(%ebp),%edx
   11d26:	01 ca                	add    %ecx,%edx
   11d28:	0f b6 12             	movzbl (%edx),%edx
   11d2b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11d2e:	8b 4d 10             	mov    0x10(%ebp),%ecx
   11d31:	01 d9                	add    %ebx,%ecx
   11d33:	0f b6 09             	movzbl (%ecx),%ecx
   11d36:	d0 e9                	shr    %cl
   11d38:	29 ca                	sub    %ecx,%edx
   11d3a:	88 10                	mov    %dl,(%eax)
   11d3c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11d40:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11d43:	3b 45 18             	cmp    0x18(%ebp),%eax
   11d46:	75 d0                	jne    11d18 <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   11d48:	8b 45 18             	mov    0x18(%ebp),%eax
   11d4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11d4e:	eb 42                	jmp    11d92 <filterScanline+0x1bf>
   11d50:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11d53:	8b 45 08             	mov    0x8(%ebp),%eax
   11d56:	01 c2                	add    %eax,%edx
   11d58:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11d5b:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d5e:	01 c8                	add    %ecx,%eax
   11d60:	0f b6 08             	movzbl (%eax),%ecx
   11d63:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11d66:	2b 45 18             	sub    0x18(%ebp),%eax
   11d69:	89 c3                	mov    %eax,%ebx
   11d6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d6e:	01 d8                	add    %ebx,%eax
   11d70:	0f b6 00             	movzbl (%eax),%eax
   11d73:	0f b6 d8             	movzbl %al,%ebx
   11d76:	8b 75 f4             	mov    -0xc(%ebp),%esi
   11d79:	8b 45 10             	mov    0x10(%ebp),%eax
   11d7c:	01 f0                	add    %esi,%eax
   11d7e:	0f b6 00             	movzbl (%eax),%eax
   11d81:	0f b6 c0             	movzbl %al,%eax
   11d84:	01 d8                	add    %ebx,%eax
   11d86:	d1 f8                	sar    %eax
   11d88:	29 c1                	sub    %eax,%ecx
   11d8a:	89 c8                	mov    %ecx,%eax
   11d8c:	88 02                	mov    %al,(%edx)
   11d8e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11d92:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11d95:	3b 45 14             	cmp    0x14(%ebp),%eax
   11d98:	7c b6                	jl     11d50 <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   11d9a:	e9 91 01 00 00       	jmp    11f30 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11d9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11da6:	eb 19                	jmp    11dc1 <filterScanline+0x1ee>
   11da8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11dab:	8b 45 08             	mov    0x8(%ebp),%eax
   11dae:	01 c2                	add    %eax,%edx
   11db0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11db3:	8b 45 0c             	mov    0xc(%ebp),%eax
   11db6:	01 c8                	add    %ecx,%eax
   11db8:	0f b6 00             	movzbl (%eax),%eax
   11dbb:	88 02                	mov    %al,(%edx)
   11dbd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11dc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11dc4:	3b 45 18             	cmp    0x18(%ebp),%eax
   11dc7:	75 df                	jne    11da8 <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   11dc9:	8b 45 18             	mov    0x18(%ebp),%eax
   11dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11dcf:	eb 2f                	jmp    11e00 <filterScanline+0x22d>
   11dd1:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11dd4:	8b 45 08             	mov    0x8(%ebp),%eax
   11dd7:	01 c2                	add    %eax,%edx
   11dd9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11ddc:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ddf:	01 c8                	add    %ecx,%eax
   11de1:	0f b6 08             	movzbl (%eax),%ecx
   11de4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11de7:	2b 45 18             	sub    0x18(%ebp),%eax
   11dea:	89 c3                	mov    %eax,%ebx
   11dec:	8b 45 0c             	mov    0xc(%ebp),%eax
   11def:	01 d8                	add    %ebx,%eax
   11df1:	0f b6 00             	movzbl (%eax),%eax
   11df4:	d0 e8                	shr    %al
   11df6:	29 c1                	sub    %eax,%ecx
   11df8:	89 c8                	mov    %ecx,%eax
   11dfa:	88 02                	mov    %al,(%edx)
   11dfc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11e00:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e03:	3b 45 14             	cmp    0x14(%ebp),%eax
   11e06:	7c c9                	jl     11dd1 <filterScanline+0x1fe>
      }
      break;
   11e08:	e9 23 01 00 00       	jmp    11f30 <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   11e0d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11e11:	0f 84 af 00 00 00    	je     11ec6 <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   11e17:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11e1e:	eb 28                	jmp    11e48 <filterScanline+0x275>
   11e20:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11e23:	8b 45 08             	mov    0x8(%ebp),%eax
   11e26:	01 d0                	add    %edx,%eax
   11e28:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11e2b:	8b 55 0c             	mov    0xc(%ebp),%edx
   11e2e:	01 ca                	add    %ecx,%edx
   11e30:	0f b6 0a             	movzbl (%edx),%ecx
   11e33:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11e36:	8b 55 10             	mov    0x10(%ebp),%edx
   11e39:	01 da                	add    %ebx,%edx
   11e3b:	0f b6 12             	movzbl (%edx),%edx
   11e3e:	29 d1                	sub    %edx,%ecx
   11e40:	89 ca                	mov    %ecx,%edx
   11e42:	88 10                	mov    %dl,(%eax)
   11e44:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11e48:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e4b:	3b 45 18             	cmp    0x18(%ebp),%eax
   11e4e:	75 d0                	jne    11e20 <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   11e50:	8b 45 18             	mov    0x18(%ebp),%eax
   11e53:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11e56:	eb 64                	jmp    11ebc <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   11e58:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11e5b:	8b 45 08             	mov    0x8(%ebp),%eax
   11e5e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   11e61:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11e64:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e67:	01 d0                	add    %edx,%eax
   11e69:	0f b6 00             	movzbl (%eax),%eax
   11e6c:	88 45 e7             	mov    %al,-0x19(%ebp)
   11e6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e72:	2b 45 18             	sub    0x18(%ebp),%eax
   11e75:	89 c2                	mov    %eax,%edx
   11e77:	8b 45 10             	mov    0x10(%ebp),%eax
   11e7a:	01 d0                	add    %edx,%eax
   11e7c:	0f b6 00             	movzbl (%eax),%eax
   11e7f:	0f b6 c8             	movzbl %al,%ecx
   11e82:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11e85:	8b 45 10             	mov    0x10(%ebp),%eax
   11e88:	01 d0                	add    %edx,%eax
   11e8a:	0f b6 00             	movzbl (%eax),%eax
   11e8d:	0f b6 d0             	movzbl %al,%edx
   11e90:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e93:	2b 45 18             	sub    0x18(%ebp),%eax
   11e96:	89 c6                	mov    %eax,%esi
   11e98:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e9b:	01 f0                	add    %esi,%eax
   11e9d:	0f b6 00             	movzbl (%eax),%eax
   11ea0:	0f b6 c0             	movzbl %al,%eax
   11ea3:	51                   	push   %ecx
   11ea4:	52                   	push   %edx
   11ea5:	50                   	push   %eax
   11ea6:	e8 49 b8 ff ff       	call   d6f4 <paethPredictor>
   11eab:	83 c4 0c             	add    $0xc,%esp
   11eae:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   11eb2:	29 c1                	sub    %eax,%ecx
   11eb4:	89 c8                	mov    %ecx,%eax
   11eb6:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   11eb8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11ebc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ebf:	3b 45 14             	cmp    0x14(%ebp),%eax
   11ec2:	7c 94                	jl     11e58 <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   11ec4:	eb 6a                	jmp    11f30 <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11ec6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11ecd:	eb 19                	jmp    11ee8 <filterScanline+0x315>
   11ecf:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11ed2:	8b 45 08             	mov    0x8(%ebp),%eax
   11ed5:	01 c2                	add    %eax,%edx
   11ed7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11eda:	8b 45 0c             	mov    0xc(%ebp),%eax
   11edd:	01 c8                	add    %ecx,%eax
   11edf:	0f b6 00             	movzbl (%eax),%eax
   11ee2:	88 02                	mov    %al,(%edx)
   11ee4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11ee8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11eeb:	3b 45 18             	cmp    0x18(%ebp),%eax
   11eee:	75 df                	jne    11ecf <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   11ef0:	8b 45 18             	mov    0x18(%ebp),%eax
   11ef3:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11ef6:	eb 2d                	jmp    11f25 <filterScanline+0x352>
   11ef8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11efb:	8b 45 08             	mov    0x8(%ebp),%eax
   11efe:	01 c2                	add    %eax,%edx
   11f00:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11f03:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f06:	01 c8                	add    %ecx,%eax
   11f08:	0f b6 08             	movzbl (%eax),%ecx
   11f0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f0e:	2b 45 18             	sub    0x18(%ebp),%eax
   11f11:	89 c3                	mov    %eax,%ebx
   11f13:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f16:	01 d8                	add    %ebx,%eax
   11f18:	0f b6 00             	movzbl (%eax),%eax
   11f1b:	29 c1                	sub    %eax,%ecx
   11f1d:	89 c8                	mov    %ecx,%eax
   11f1f:	88 02                	mov    %al,(%edx)
   11f21:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11f25:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f28:	3b 45 14             	cmp    0x14(%ebp),%eax
   11f2b:	7c cb                	jl     11ef8 <filterScanline+0x325>
      }
      break;
   11f2d:	eb 01                	jmp    11f30 <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   11f2f:	90                   	nop
  }
}
   11f30:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11f33:	5b                   	pop    %ebx
   11f34:	5e                   	pop    %esi
   11f35:	5d                   	pop    %ebp
   11f36:	c3                   	ret    

00011f37 <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   11f37:	55                   	push   %ebp
   11f38:	89 e5                	mov    %esp,%ebp
   11f3a:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   11f3d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   11f44:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   11f4b:	7e 08                	jle    11f55 <ilog2+0x1e>
   11f4d:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   11f51:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   11f55:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   11f5c:	7e 08                	jle    11f66 <ilog2+0x2f>
   11f5e:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   11f62:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   11f66:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   11f6a:	7e 08                	jle    11f74 <ilog2+0x3d>
   11f6c:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   11f70:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   11f74:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   11f78:	7e 08                	jle    11f82 <ilog2+0x4b>
   11f7a:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   11f7e:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   11f82:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   11f86:	7e 04                	jle    11f8c <ilog2+0x55>
   11f88:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   11f8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11f8f:	c9                   	leave  
   11f90:	c3                   	ret    

00011f91 <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   11f91:	55                   	push   %ebp
   11f92:	89 e5                	mov    %esp,%ebp
   11f94:	56                   	push   %esi
   11f95:	53                   	push   %ebx
   11f96:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   11f99:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11f9d:	75 07                	jne    11fa6 <ilog2i+0x15>
   11f9f:	b8 00 00 00 00       	mov    $0x0,%eax
   11fa4:	eb 30                	jmp    11fd6 <ilog2i+0x45>
  l = ilog2(i);
   11fa6:	ff 75 08             	pushl  0x8(%ebp)
   11fa9:	e8 89 ff ff ff       	call   11f37 <ilog2>
   11fae:	83 c4 04             	add    $0x4,%esp
   11fb1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   11fb4:	8b 45 08             	mov    0x8(%ebp),%eax
   11fb7:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   11fbb:	89 c3                	mov    %eax,%ebx
   11fbd:	8b 55 08             	mov    0x8(%ebp),%edx
   11fc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11fc3:	be 01 00 00 00       	mov    $0x1,%esi
   11fc8:	89 c1                	mov    %eax,%ecx
   11fca:	d3 e6                	shl    %cl,%esi
   11fcc:	89 f0                	mov    %esi,%eax
   11fce:	29 c2                	sub    %eax,%edx
   11fd0:	89 d0                	mov    %edx,%eax
   11fd2:	01 c0                	add    %eax,%eax
   11fd4:	01 d8                	add    %ebx,%eax
}
   11fd6:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11fd9:	5b                   	pop    %ebx
   11fda:	5e                   	pop    %esi
   11fdb:	5d                   	pop    %ebp
   11fdc:	c3                   	ret    

00011fdd <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   11fdd:	55                   	push   %ebp
   11fde:	89 e5                	mov    %esp,%ebp
   11fe0:	53                   	push   %ebx
   11fe1:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   11fe7:	ff 75 18             	pushl  0x18(%ebp)
   11fea:	e8 6a 75 ff ff       	call   9559 <lodepng_get_bpp>
   11fef:	83 c4 04             	add    $0x4,%esp
   11ff2:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   11ff5:	ff 75 b8             	pushl  -0x48(%ebp)
   11ff8:	6a 01                	push   $0x1
   11ffa:	ff 75 10             	pushl  0x10(%ebp)
   11ffd:	e8 b6 76 ff ff       	call   96b8 <lodepng_get_raw_size_idat>
   12002:	83 c4 0c             	add    $0xc,%esp
   12005:	83 e8 01             	sub    $0x1,%eax
   12008:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   1200b:	8b 45 b8             	mov    -0x48(%ebp),%eax
   1200e:	83 c0 07             	add    $0x7,%eax
   12011:	c1 e8 03             	shr    $0x3,%eax
   12014:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   12017:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   1201e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   12025:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12028:	8b 40 2c             	mov    0x2c(%eax),%eax
   1202b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   1202e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12031:	8b 40 28             	mov    0x28(%eax),%eax
   12034:	85 c0                	test   %eax,%eax
   12036:	74 1c                	je     12054 <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   12038:	8b 45 18             	mov    0x18(%ebp),%eax
   1203b:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   1203d:	83 f8 03             	cmp    $0x3,%eax
   12040:	74 0b                	je     1204d <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   12042:	8b 45 18             	mov    0x18(%ebp),%eax
   12045:	8b 40 04             	mov    0x4(%eax),%eax
   12048:	83 f8 07             	cmp    $0x7,%eax
   1204b:	77 07                	ja     12054 <filter+0x77>
   1204d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   12054:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   12058:	75 0a                	jne    12064 <filter+0x87>
   1205a:	b8 1f 00 00 00       	mov    $0x1f,%eax
   1205f:	e9 5b 07 00 00       	jmp    127bf <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   12064:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   12068:	77 7b                	ja     120e5 <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   1206a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1206d:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   12070:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12077:	eb 5f                	jmp    120d8 <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   12079:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1207c:	83 c0 01             	add    $0x1,%eax
   1207f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12083:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   12086:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12089:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1208d:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   12090:	8b 55 9c             	mov    -0x64(%ebp),%edx
   12093:	8b 45 08             	mov    0x8(%ebp),%eax
   12096:	01 c2                	add    %eax,%edx
   12098:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   1209c:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   1209e:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   120a2:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   120a5:	8b 55 0c             	mov    0xc(%ebp),%edx
   120a8:	01 d1                	add    %edx,%ecx
   120aa:	8b 55 9c             	mov    -0x64(%ebp),%edx
   120ad:	8d 5a 01             	lea    0x1(%edx),%ebx
   120b0:	8b 55 08             	mov    0x8(%ebp),%edx
   120b3:	01 da                	add    %ebx,%edx
   120b5:	50                   	push   %eax
   120b6:	ff 75 b0             	pushl  -0x50(%ebp)
   120b9:	ff 75 b4             	pushl  -0x4c(%ebp)
   120bc:	ff 75 f4             	pushl  -0xc(%ebp)
   120bf:	51                   	push   %ecx
   120c0:	52                   	push   %edx
   120c1:	e8 0d fb ff ff       	call   11bd3 <filterScanline>
   120c6:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   120c9:	8b 55 98             	mov    -0x68(%ebp),%edx
   120cc:	8b 45 0c             	mov    0xc(%ebp),%eax
   120cf:	01 d0                	add    %edx,%eax
   120d1:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   120d4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   120d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   120db:	3b 45 14             	cmp    0x14(%ebp),%eax
   120de:	75 99                	jne    12079 <filter+0x9c>
   120e0:	e9 d7 06 00 00       	jmp    127bc <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   120e5:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   120e9:	0f 85 e3 01 00 00    	jne    122d2 <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   120ef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   120f6:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   120fa:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   120fe:	eb 2d                	jmp    1212d <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   12100:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   12104:	83 ec 0c             	sub    $0xc,%esp
   12107:	ff 75 b4             	pushl  -0x4c(%ebp)
   1210a:	e8 2e 19 ff ff       	call   3a3d <lodepng_malloc>
   1210f:	83 c4 10             	add    $0x10,%esp
   12112:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   12116:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   1211a:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   1211e:	85 c0                	test   %eax,%eax
   12120:	75 07                	jne    12129 <filter+0x14c>
   12122:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   12129:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   1212d:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   12131:	75 cd                	jne    12100 <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   12133:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12137:	0f 85 6c 01 00 00    	jne    122a9 <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   1213d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12144:	e9 54 01 00 00       	jmp    1229d <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   12149:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   1214d:	e9 d5 00 00 00       	jmp    12227 <filter+0x24a>
          size_t sum = 0;
   12152:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   12159:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   1215d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12160:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12164:	89 c1                	mov    %eax,%ecx
   12166:	8b 45 0c             	mov    0xc(%ebp),%eax
   12169:	01 c1                	add    %eax,%ecx
   1216b:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   1216f:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   12173:	83 ec 08             	sub    $0x8,%esp
   12176:	52                   	push   %edx
   12177:	ff 75 b0             	pushl  -0x50(%ebp)
   1217a:	ff 75 b4             	pushl  -0x4c(%ebp)
   1217d:	ff 75 f4             	pushl  -0xc(%ebp)
   12180:	51                   	push   %ecx
   12181:	50                   	push   %eax
   12182:	e8 4c fa ff ff       	call   11bd3 <filterScanline>
   12187:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   1218a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   1218e:	75 2d                	jne    121bd <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   12190:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12197:	eb 1a                	jmp    121b3 <filter+0x1d6>
   12199:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   1219d:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   121a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   121a4:	01 d0                	add    %edx,%eax
   121a6:	0f b6 00             	movzbl (%eax),%eax
   121a9:	0f b6 c0             	movzbl %al,%eax
   121ac:	01 45 d8             	add    %eax,-0x28(%ebp)
   121af:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   121b3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   121b6:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   121b9:	75 de                	jne    12199 <filter+0x1bc>
   121bb:	eb 4b                	jmp    12208 <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   121bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   121c4:	eb 3a                	jmp    12200 <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   121c6:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   121ca:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   121ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
   121d1:	01 d0                	add    %edx,%eax
   121d3:	0f b6 00             	movzbl (%eax),%eax
   121d6:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   121d9:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   121dd:	84 c0                	test   %al,%al
   121df:	78 06                	js     121e7 <filter+0x20a>
   121e1:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   121e5:	eb 0d                	jmp    121f4 <filter+0x217>
   121e7:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   121eb:	ba ff 00 00 00       	mov    $0xff,%edx
   121f0:	29 c2                	sub    %eax,%edx
   121f2:	89 d0                	mov    %edx,%eax
   121f4:	8b 55 d8             	mov    -0x28(%ebp),%edx
   121f7:	01 d0                	add    %edx,%eax
   121f9:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   121fc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12200:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12203:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12206:	75 be                	jne    121c6 <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   12208:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   1220c:	74 08                	je     12216 <filter+0x239>
   1220e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12211:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   12214:	7d 0d                	jge    12223 <filter+0x246>
            bestType = type;
   12216:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   1221a:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   1221d:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12220:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   12223:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   12227:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   1222b:	0f 85 21 ff ff ff    	jne    12152 <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   12231:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12234:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12238:	89 c2                	mov    %eax,%edx
   1223a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1223d:	01 d0                	add    %edx,%eax
   1223f:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   12242:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12245:	83 c0 01             	add    $0x1,%eax
   12248:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1224c:	89 c2                	mov    %eax,%edx
   1224e:	8b 45 08             	mov    0x8(%ebp),%eax
   12251:	01 c2                	add    %eax,%edx
   12253:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   12257:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   12259:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12260:	eb 2f                	jmp    12291 <filter+0x2b4>
   12262:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12265:	83 c0 01             	add    $0x1,%eax
   12268:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1226c:	89 c2                	mov    %eax,%edx
   1226e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12271:	01 d0                	add    %edx,%eax
   12273:	8d 50 01             	lea    0x1(%eax),%edx
   12276:	8b 45 08             	mov    0x8(%ebp),%eax
   12279:	01 c2                	add    %eax,%edx
   1227b:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   1227f:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   12283:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12286:	01 c8                	add    %ecx,%eax
   12288:	0f b6 00             	movzbl (%eax),%eax
   1228b:	88 02                	mov    %al,(%edx)
   1228d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12291:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12294:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12297:	75 c9                	jne    12262 <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   12299:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1229d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   122a0:	3b 45 14             	cmp    0x14(%ebp),%eax
   122a3:	0f 85 a0 fe ff ff    	jne    12149 <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   122a9:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   122ad:	eb 18                	jmp    122c7 <filter+0x2ea>
   122af:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   122b3:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   122b7:	83 ec 0c             	sub    $0xc,%esp
   122ba:	50                   	push   %eax
   122bb:	e8 9e 17 ff ff       	call   3a5e <lodepng_free>
   122c0:	83 c4 10             	add    $0x10,%esp
   122c3:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   122c7:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   122cb:	75 e2                	jne    122af <filter+0x2d2>
   122cd:	e9 ea 04 00 00       	jmp    127bc <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   122d2:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   122d6:	0f 85 17 02 00 00    	jne    124f3 <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   122dc:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   122e3:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   122ea:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   122f1:	eb 33                	jmp    12326 <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   122f3:	83 ec 0c             	sub    $0xc,%esp
   122f6:	ff 75 b4             	pushl  -0x4c(%ebp)
   122f9:	e8 3f 17 ff ff       	call   3a3d <lodepng_malloc>
   122fe:	83 c4 10             	add    $0x10,%esp
   12301:	89 c2                	mov    %eax,%edx
   12303:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12306:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   1230d:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12310:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   12317:	85 c0                	test   %eax,%eax
   12319:	75 07                	jne    12322 <filter+0x345>
   1231b:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   12322:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   12326:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   1232a:	75 c7                	jne    122f3 <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   1232c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12330:	0f 85 8f 01 00 00    	jne    124c5 <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   12336:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1233d:	e9 77 01 00 00       	jmp    124b9 <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   12342:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   12349:	e9 f4 00 00 00       	jmp    12442 <filter+0x465>
          size_t sum = 0;
   1234e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   12355:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12358:	0f b6 d0             	movzbl %al,%edx
   1235b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1235e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12362:	89 c1                	mov    %eax,%ecx
   12364:	8b 45 0c             	mov    0xc(%ebp),%eax
   12367:	01 c1                	add    %eax,%ecx
   12369:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1236c:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   12373:	83 ec 08             	sub    $0x8,%esp
   12376:	52                   	push   %edx
   12377:	ff 75 b0             	pushl  -0x50(%ebp)
   1237a:	ff 75 b4             	pushl  -0x4c(%ebp)
   1237d:	ff 75 f4             	pushl  -0xc(%ebp)
   12380:	51                   	push   %ecx
   12381:	50                   	push   %eax
   12382:	e8 4c f8 ff ff       	call   11bd3 <filterScanline>
   12387:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   1238a:	83 ec 04             	sub    $0x4,%esp
   1238d:	68 00 04 00 00       	push   $0x400
   12392:	6a 00                	push   $0x0
   12394:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   1239a:	50                   	push   %eax
   1239b:	e8 0e 17 ff ff       	call   3aae <lodepng_memset>
   123a0:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   123a3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   123aa:	eb 2a                	jmp    123d6 <filter+0x3f9>
   123ac:	8b 45 d0             	mov    -0x30(%ebp),%eax
   123af:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   123b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   123b9:	01 d0                	add    %edx,%eax
   123bb:	0f b6 00             	movzbl (%eax),%eax
   123be:	0f b6 c0             	movzbl %al,%eax
   123c1:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   123c8:	83 c2 01             	add    $0x1,%edx
   123cb:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   123d2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   123d6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   123d9:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   123dc:	75 ce                	jne    123ac <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   123de:	8b 45 d0             	mov    -0x30(%ebp),%eax
   123e1:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   123e8:	8d 50 01             	lea    0x1(%eax),%edx
   123eb:	8b 45 d0             	mov    -0x30(%ebp),%eax
   123ee:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   123f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   123fc:	eb 1d                	jmp    1241b <filter+0x43e>
            sum += ilog2i(count[x]);
   123fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12401:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   12408:	83 ec 0c             	sub    $0xc,%esp
   1240b:	50                   	push   %eax
   1240c:	e8 80 fb ff ff       	call   11f91 <ilog2i>
   12411:	83 c4 10             	add    $0x10,%esp
   12414:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   12417:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1241b:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   12422:	75 da                	jne    123fe <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   12424:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   12428:	74 08                	je     12432 <filter+0x455>
   1242a:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1242d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   12430:	7e 0c                	jle    1243e <filter+0x461>
            bestType = type;
   12432:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12435:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   12438:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1243b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   1243e:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   12442:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   12446:	0f 85 02 ff ff ff    	jne    1234e <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   1244c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1244f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12453:	89 c2                	mov    %eax,%edx
   12455:	8b 45 0c             	mov    0xc(%ebp),%eax
   12458:	01 d0                	add    %edx,%eax
   1245a:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   1245d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12460:	83 c0 01             	add    $0x1,%eax
   12463:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12467:	89 c2                	mov    %eax,%edx
   12469:	8b 45 08             	mov    0x8(%ebp),%eax
   1246c:	01 d0                	add    %edx,%eax
   1246e:	8b 55 cc             	mov    -0x34(%ebp),%edx
   12471:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   12473:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1247a:	eb 31                	jmp    124ad <filter+0x4d0>
   1247c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1247f:	83 c0 01             	add    $0x1,%eax
   12482:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12486:	89 c2                	mov    %eax,%edx
   12488:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1248b:	01 d0                	add    %edx,%eax
   1248d:	8d 50 01             	lea    0x1(%eax),%edx
   12490:	8b 45 08             	mov    0x8(%ebp),%eax
   12493:	01 c2                	add    %eax,%edx
   12495:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12498:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   1249f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   124a2:	01 c8                	add    %ecx,%eax
   124a4:	0f b6 00             	movzbl (%eax),%eax
   124a7:	88 02                	mov    %al,(%edx)
   124a9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   124ad:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   124b0:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   124b3:	75 c7                	jne    1247c <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   124b5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   124b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   124bc:	3b 45 14             	cmp    0x14(%ebp),%eax
   124bf:	0f 85 7d fe ff ff    	jne    12342 <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   124c5:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   124cc:	eb 1a                	jmp    124e8 <filter+0x50b>
   124ce:	8b 45 d0             	mov    -0x30(%ebp),%eax
   124d1:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   124d8:	83 ec 0c             	sub    $0xc,%esp
   124db:	50                   	push   %eax
   124dc:	e8 7d 15 ff ff       	call   3a5e <lodepng_free>
   124e1:	83 c4 10             	add    $0x10,%esp
   124e4:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   124e8:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   124ec:	75 e0                	jne    124ce <filter+0x4f1>
   124ee:	e9 c9 02 00 00       	jmp    127bc <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   124f3:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   124f7:	0f 85 89 00 00 00    	jne    12586 <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   124fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12504:	eb 73                	jmp    12579 <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   12506:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12509:	83 c0 01             	add    $0x1,%eax
   1250c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12510:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   12513:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12516:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1251a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   1251d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12520:	8b 50 30             	mov    0x30(%eax),%edx
   12523:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12526:	01 d0                	add    %edx,%eax
   12528:	0f b6 00             	movzbl (%eax),%eax
   1252b:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   1252e:	8b 55 a8             	mov    -0x58(%ebp),%edx
   12531:	8b 45 08             	mov    0x8(%ebp),%eax
   12534:	01 c2                	add    %eax,%edx
   12536:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   1253a:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   1253c:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   12540:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   12543:	8b 55 0c             	mov    0xc(%ebp),%edx
   12546:	01 d1                	add    %edx,%ecx
   12548:	8b 55 a8             	mov    -0x58(%ebp),%edx
   1254b:	8d 5a 01             	lea    0x1(%edx),%ebx
   1254e:	8b 55 08             	mov    0x8(%ebp),%edx
   12551:	01 da                	add    %ebx,%edx
   12553:	83 ec 08             	sub    $0x8,%esp
   12556:	50                   	push   %eax
   12557:	ff 75 b0             	pushl  -0x50(%ebp)
   1255a:	ff 75 b4             	pushl  -0x4c(%ebp)
   1255d:	ff 75 f4             	pushl  -0xc(%ebp)
   12560:	51                   	push   %ecx
   12561:	52                   	push   %edx
   12562:	e8 6c f6 ff ff       	call   11bd3 <filterScanline>
   12567:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   1256a:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   1256d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12570:	01 d0                	add    %edx,%eax
   12572:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   12575:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12579:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1257c:	3b 45 14             	cmp    0x14(%ebp),%eax
   1257f:	75 85                	jne    12506 <filter+0x529>
   12581:	e9 36 02 00 00       	jmp    127bc <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   12586:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   1258a:	0f 85 25 02 00 00    	jne    127b5 <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   12590:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   12597:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   1259e:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   125a5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   125a8:	83 ec 04             	sub    $0x4,%esp
   125ab:	6a 24                	push   $0x24
   125ad:	50                   	push   %eax
   125ae:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   125b4:	50                   	push   %eax
   125b5:	e8 c1 14 ff ff       	call   3a7b <lodepng_memcpy>
   125ba:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   125bd:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   125c4:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   125c7:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   125ce:	00 00 00 
    zlibsettings.custom_deflate = 0;
   125d1:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   125d8:	00 00 00 
    for(type = 0; type != 5; ++type) {
   125db:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   125e2:	eb 33                	jmp    12617 <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   125e4:	83 ec 0c             	sub    $0xc,%esp
   125e7:	ff 75 b4             	pushl  -0x4c(%ebp)
   125ea:	e8 4e 14 ff ff       	call   3a3d <lodepng_malloc>
   125ef:	83 c4 10             	add    $0x10,%esp
   125f2:	89 c2                	mov    %eax,%edx
   125f4:	8b 45 c0             	mov    -0x40(%ebp),%eax
   125f7:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   125fe:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12601:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12608:	85 c0                	test   %eax,%eax
   1260a:	75 07                	jne    12613 <filter+0x636>
   1260c:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   12613:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12617:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   1261b:	75 c7                	jne    125e4 <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   1261d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12621:	0f 85 63 01 00 00    	jne    1278a <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   12627:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1262e:	e9 4b 01 00 00       	jmp    1277e <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   12633:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   1263a:	e9 c8 00 00 00       	jmp    12707 <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   1263f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12642:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   12645:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12648:	0f b6 d0             	movzbl %al,%edx
   1264b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1264e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12652:	89 c1                	mov    %eax,%ecx
   12654:	8b 45 0c             	mov    0xc(%ebp),%eax
   12657:	01 c1                	add    %eax,%ecx
   12659:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1265c:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12663:	83 ec 08             	sub    $0x8,%esp
   12666:	52                   	push   %edx
   12667:	ff 75 b0             	pushl  -0x50(%ebp)
   1266a:	ff 75 b4             	pushl  -0x4c(%ebp)
   1266d:	ff 75 f4             	pushl  -0xc(%ebp)
   12670:	51                   	push   %ecx
   12671:	50                   	push   %eax
   12672:	e8 5c f5 ff ff       	call   11bd3 <filterScanline>
   12677:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   1267a:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1267d:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   12684:	00 00 00 00 
          dummy = 0;
   12688:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   1268f:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   12692:	8b 55 ac             	mov    -0x54(%ebp),%edx
   12695:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12698:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   1269f:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   126a5:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   126a8:	c1 e3 02             	shl    $0x2,%ebx
   126ab:	01 cb                	add    %ecx,%ebx
   126ad:	83 ec 0c             	sub    $0xc,%esp
   126b0:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   126b6:	51                   	push   %ecx
   126b7:	52                   	push   %edx
   126b8:	50                   	push   %eax
   126b9:	53                   	push   %ebx
   126ba:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   126c0:	50                   	push   %eax
   126c1:	e8 87 60 ff ff       	call   874d <zlib_compress>
   126c6:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   126c9:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   126cf:	83 ec 0c             	sub    $0xc,%esp
   126d2:	50                   	push   %eax
   126d3:	e8 86 13 ff ff       	call   3a5e <lodepng_free>
   126d8:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   126db:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   126df:	74 0f                	je     126f0 <filter+0x713>
   126e1:	8b 45 c0             	mov    -0x40(%ebp),%eax
   126e4:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   126eb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   126ee:	7d 13                	jge    12703 <filter+0x726>
            bestType = type;
   126f0:	8b 45 c0             	mov    -0x40(%ebp),%eax
   126f3:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   126f6:	8b 45 c0             	mov    -0x40(%ebp),%eax
   126f9:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   12700:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   12703:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12707:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   1270b:	0f 85 2e ff ff ff    	jne    1263f <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   12711:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12714:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12718:	89 c2                	mov    %eax,%edx
   1271a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1271d:	01 d0                	add    %edx,%eax
   1271f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   12722:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12725:	83 c0 01             	add    $0x1,%eax
   12728:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1272c:	89 c2                	mov    %eax,%edx
   1272e:	8b 45 08             	mov    0x8(%ebp),%eax
   12731:	01 d0                	add    %edx,%eax
   12733:	8b 55 bc             	mov    -0x44(%ebp),%edx
   12736:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   12738:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1273f:	eb 31                	jmp    12772 <filter+0x795>
   12741:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12744:	83 c0 01             	add    $0x1,%eax
   12747:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1274b:	89 c2                	mov    %eax,%edx
   1274d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12750:	01 d0                	add    %edx,%eax
   12752:	8d 50 01             	lea    0x1(%eax),%edx
   12755:	8b 45 08             	mov    0x8(%ebp),%eax
   12758:	01 c2                	add    %eax,%edx
   1275a:	8b 45 bc             	mov    -0x44(%ebp),%eax
   1275d:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   12764:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12767:	01 c8                	add    %ecx,%eax
   12769:	0f b6 00             	movzbl (%eax),%eax
   1276c:	88 02                	mov    %al,(%edx)
   1276e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12772:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12775:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12778:	75 c7                	jne    12741 <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   1277a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1277e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12781:	3b 45 14             	cmp    0x14(%ebp),%eax
   12784:	0f 85 a9 fe ff ff    	jne    12633 <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   1278a:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12791:	eb 1a                	jmp    127ad <filter+0x7d0>
   12793:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12796:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   1279d:	83 ec 0c             	sub    $0xc,%esp
   127a0:	50                   	push   %eax
   127a1:	e8 b8 12 ff ff       	call   3a5e <lodepng_free>
   127a6:	83 c4 10             	add    $0x10,%esp
   127a9:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   127ad:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   127b1:	75 e0                	jne    12793 <filter+0x7b6>
   127b3:	eb 07                	jmp    127bc <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   127b5:	b8 58 00 00 00       	mov    $0x58,%eax
   127ba:	eb 03                	jmp    127bf <filter+0x7e2>

  return error;
   127bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   127bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   127c2:	c9                   	leave  
   127c3:	c3                   	ret    

000127c4 <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   127c4:	55                   	push   %ebp
   127c5:	89 e5                	mov    %esp,%ebp
   127c7:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   127ca:	8b 45 10             	mov    0x10(%ebp),%eax
   127cd:	2b 45 14             	sub    0x14(%ebp),%eax
   127d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   127d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   127da:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   127e1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   127e8:	eb 65                	jmp    1284f <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   127ea:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   127f1:	eb 2a                	jmp    1281d <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   127f3:	ff 75 0c             	pushl  0xc(%ebp)
   127f6:	8d 45 e8             	lea    -0x18(%ebp),%eax
   127f9:	50                   	push   %eax
   127fa:	e8 9d 60 ff ff       	call   889c <readBitFromReversedStream>
   127ff:	83 c4 08             	add    $0x8,%esp
   12802:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   12805:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   12809:	50                   	push   %eax
   1280a:	ff 75 08             	pushl  0x8(%ebp)
   1280d:	8d 45 ec             	lea    -0x14(%ebp),%eax
   12810:	50                   	push   %eax
   12811:	e8 08 61 ff ff       	call   891e <setBitOfReversedStream>
   12816:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   12819:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1281d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12820:	3b 45 14             	cmp    0x14(%ebp),%eax
   12823:	7c ce                	jl     127f3 <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   12825:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1282c:	eb 15                	jmp    12843 <addPaddingBits+0x7f>
   1282e:	6a 00                	push   $0x0
   12830:	ff 75 08             	pushl  0x8(%ebp)
   12833:	8d 45 ec             	lea    -0x14(%ebp),%eax
   12836:	50                   	push   %eax
   12837:	e8 e2 60 ff ff       	call   891e <setBitOfReversedStream>
   1283c:	83 c4 0c             	add    $0xc,%esp
   1283f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12843:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12846:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12849:	75 e3                	jne    1282e <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   1284b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1284f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12852:	3b 45 18             	cmp    0x18(%ebp),%eax
   12855:	75 93                	jne    127ea <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   12857:	90                   	nop
   12858:	c9                   	leave  
   12859:	c3                   	ret    

0001285a <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   1285a:	55                   	push   %ebp
   1285b:	89 e5                	mov    %esp,%ebp
   1285d:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   12863:	ff 75 18             	pushl  0x18(%ebp)
   12866:	ff 75 14             	pushl  0x14(%ebp)
   12869:	ff 75 10             	pushl  0x10(%ebp)
   1286c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   12872:	50                   	push   %eax
   12873:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   12879:	50                   	push   %eax
   1287a:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12880:	50                   	push   %eax
   12881:	8d 45 94             	lea    -0x6c(%ebp),%eax
   12884:	50                   	push   %eax
   12885:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12888:	50                   	push   %eax
   12889:	e8 fc ae ff ff       	call   d78a <Adam7_getpassvalues>
   1288e:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   12891:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   12895:	0f 86 0a 01 00 00    	jbe    129a5 <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   1289b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   128a2:	e9 ef 00 00 00       	jmp    12996 <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   128a7:	8b 45 18             	mov    0x18(%ebp),%eax
   128aa:	c1 e8 03             	shr    $0x3,%eax
   128ad:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   128b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   128b7:	e9 c6 00 00 00       	jmp    12982 <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   128bc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   128c3:	e9 a6 00 00 00       	jmp    1296e <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   128c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   128cb:	8b 14 85 38 a7 01 00 	mov    0x1a738(,%eax,4),%edx
   128d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   128d5:	8b 04 85 70 a7 01 00 	mov    0x1a770(,%eax,4),%eax
   128dc:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   128e0:	01 d0                	add    %edx,%eax
   128e2:	0f af 45 10          	imul   0x10(%ebp),%eax
   128e6:	89 c2                	mov    %eax,%edx
   128e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   128eb:	8b 04 85 54 a7 01 00 	mov    0x1a754(,%eax,4),%eax
   128f2:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   128f6:	01 c2                	add    %eax,%edx
   128f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   128fb:	8b 04 85 1c a7 01 00 	mov    0x1a71c(,%eax,4),%eax
   12902:	01 c2                	add    %eax,%edx
   12904:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12907:	0f af c2             	imul   %edx,%eax
   1290a:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   1290d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12910:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   12917:	89 c1                	mov    %eax,%ecx
   12919:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1291c:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12920:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   12924:	89 c2                	mov    %eax,%edx
   12926:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12929:	01 c2                	add    %eax,%edx
   1292b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1292e:	0f af c2             	imul   %edx,%eax
   12931:	01 c8                	add    %ecx,%eax
   12933:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   12936:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1293d:	eb 23                	jmp    12962 <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   1293f:	8b 55 d8             	mov    -0x28(%ebp),%edx
   12942:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12945:	01 c2                	add    %eax,%edx
   12947:	8b 45 08             	mov    0x8(%ebp),%eax
   1294a:	01 c2                	add    %eax,%edx
   1294c:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   1294f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12952:	01 c1                	add    %eax,%ecx
   12954:	8b 45 0c             	mov    0xc(%ebp),%eax
   12957:	01 c8                	add    %ecx,%eax
   12959:	0f b6 00             	movzbl (%eax),%eax
   1295c:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   1295e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12962:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12965:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12968:	72 d5                	jb     1293f <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   1296a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1296e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12971:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12975:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   12978:	0f 87 4a ff ff ff    	ja     128c8 <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   1297e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12982:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12985:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12989:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1298c:	0f 87 2a ff ff ff    	ja     128bc <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   12992:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12996:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   1299a:	0f 85 07 ff ff ff    	jne    128a7 <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   129a0:	e9 22 01 00 00       	jmp    12ac7 <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   129a5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   129ac:	e9 0c 01 00 00       	jmp    12abd <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   129b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   129b4:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   129b8:	0f af 45 18          	imul   0x18(%ebp),%eax
   129bc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   129bf:	8b 45 18             	mov    0x18(%ebp),%eax
   129c2:	0f af 45 10          	imul   0x10(%ebp),%eax
   129c6:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   129c9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   129d0:	e9 d4 00 00 00       	jmp    12aa9 <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   129d5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   129dc:	e9 b4 00 00 00       	jmp    12a95 <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   129e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   129e4:	8b 14 85 38 a7 01 00 	mov    0x1a738(,%eax,4),%edx
   129eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   129ee:	8b 04 85 70 a7 01 00 	mov    0x1a770(,%eax,4),%eax
   129f5:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   129f9:	01 d0                	add    %edx,%eax
   129fb:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   129ff:	89 c2                	mov    %eax,%edx
   12a01:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12a04:	8b 0c 85 1c a7 01 00 	mov    0x1a71c(,%eax,4),%ecx
   12a0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12a0e:	8b 04 85 54 a7 01 00 	mov    0x1a754(,%eax,4),%eax
   12a15:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12a19:	01 c8                	add    %ecx,%eax
   12a1b:	0f af 45 18          	imul   0x18(%ebp),%eax
   12a1f:	01 d0                	add    %edx,%eax
   12a21:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   12a27:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12a2a:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   12a31:	c1 e0 03             	shl    $0x3,%eax
   12a34:	89 c1                	mov    %eax,%ecx
   12a36:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12a39:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   12a3d:	89 c2                	mov    %eax,%edx
   12a3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12a42:	0f af 45 18          	imul   0x18(%ebp),%eax
   12a46:	01 d0                	add    %edx,%eax
   12a48:	01 c8                	add    %ecx,%eax
   12a4a:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   12a50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   12a57:	eb 30                	jmp    12a89 <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   12a59:	ff 75 0c             	pushl  0xc(%ebp)
   12a5c:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   12a62:	50                   	push   %eax
   12a63:	e8 34 5e ff ff       	call   889c <readBitFromReversedStream>
   12a68:	83 c4 08             	add    $0x8,%esp
   12a6b:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   12a6e:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   12a72:	50                   	push   %eax
   12a73:	ff 75 08             	pushl  0x8(%ebp)
   12a76:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   12a7c:	50                   	push   %eax
   12a7d:	e8 9c 5e ff ff       	call   891e <setBitOfReversedStream>
   12a82:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   12a85:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   12a89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12a8c:	3b 45 18             	cmp    0x18(%ebp),%eax
   12a8f:	72 c8                	jb     12a59 <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12a91:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12a95:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12a98:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12a9c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   12a9f:	0f 87 3c ff ff ff    	ja     129e1 <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   12aa5:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   12aa9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12aac:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12ab0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   12ab3:	0f 87 1c ff ff ff    	ja     129d5 <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   12ab9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12abd:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12ac1:	0f 85 ea fe ff ff    	jne    129b1 <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12ac7:	90                   	nop
   12ac8:	c9                   	leave  
   12ac9:	c3                   	ret    

00012aca <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   12aca:	55                   	push   %ebp
   12acb:	89 e5                	mov    %esp,%ebp
   12acd:	57                   	push   %edi
   12ace:	56                   	push   %esi
   12acf:	53                   	push   %ebx
   12ad0:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   12ad6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ad9:	83 c0 0c             	add    $0xc,%eax
   12adc:	50                   	push   %eax
   12add:	e8 77 6a ff ff       	call   9559 <lodepng_get_bpp>
   12ae2:	83 c4 04             	add    $0x4,%esp
   12ae5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   12ae8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   12aef:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12af2:	8b 40 08             	mov    0x8(%eax),%eax
   12af5:	85 c0                	test   %eax,%eax
   12af7:	0f 85 49 01 00 00    	jne    12c46 <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   12afd:	8b 45 14             	mov    0x14(%ebp),%eax
   12b00:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12b04:	83 c0 07             	add    $0x7,%eax
   12b07:	c1 e8 03             	shr    $0x3,%eax
   12b0a:	83 c0 01             	add    $0x1,%eax
   12b0d:	0f af 45 18          	imul   0x18(%ebp),%eax
   12b11:	89 c2                	mov    %eax,%edx
   12b13:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b16:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12b18:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b1b:	8b 00                	mov    (%eax),%eax
   12b1d:	83 ec 0c             	sub    $0xc,%esp
   12b20:	50                   	push   %eax
   12b21:	e8 17 0f ff ff       	call   3a3d <lodepng_malloc>
   12b26:	83 c4 10             	add    $0x10,%esp
   12b29:	89 c2                	mov    %eax,%edx
   12b2b:	8b 45 08             	mov    0x8(%ebp),%eax
   12b2e:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   12b30:	8b 45 08             	mov    0x8(%ebp),%eax
   12b33:	8b 00                	mov    (%eax),%eax
   12b35:	85 c0                	test   %eax,%eax
   12b37:	75 10                	jne    12b49 <preProcessScanlines+0x7f>
   12b39:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b3c:	8b 00                	mov    (%eax),%eax
   12b3e:	85 c0                	test   %eax,%eax
   12b40:	74 07                	je     12b49 <preProcessScanlines+0x7f>
   12b42:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   12b49:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12b4d:	0f 85 fb 02 00 00    	jne    12e4e <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   12b53:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   12b57:	0f 87 bd 00 00 00    	ja     12c1a <preProcessScanlines+0x150>
   12b5d:	8b 45 14             	mov    0x14(%ebp),%eax
   12b60:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12b64:	89 c2                	mov    %eax,%edx
   12b66:	8b 45 14             	mov    0x14(%ebp),%eax
   12b69:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12b6d:	83 c0 07             	add    $0x7,%eax
   12b70:	c1 e8 03             	shr    $0x3,%eax
   12b73:	c1 e0 03             	shl    $0x3,%eax
   12b76:	39 c2                	cmp    %eax,%edx
   12b78:	0f 84 9c 00 00 00    	je     12c1a <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   12b7e:	8b 45 14             	mov    0x14(%ebp),%eax
   12b81:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12b85:	83 c0 07             	add    $0x7,%eax
   12b88:	c1 e8 03             	shr    $0x3,%eax
   12b8b:	0f af 45 18          	imul   0x18(%ebp),%eax
   12b8f:	83 ec 0c             	sub    $0xc,%esp
   12b92:	50                   	push   %eax
   12b93:	e8 a5 0e ff ff       	call   3a3d <lodepng_malloc>
   12b98:	83 c4 10             	add    $0x10,%esp
   12b9b:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   12b9e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12ba2:	75 07                	jne    12bab <preProcessScanlines+0xe1>
   12ba4:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   12bab:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12baf:	75 56                	jne    12c07 <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   12bb1:	8b 45 14             	mov    0x14(%ebp),%eax
   12bb4:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12bb8:	89 c2                	mov    %eax,%edx
   12bba:	8b 45 14             	mov    0x14(%ebp),%eax
   12bbd:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12bc1:	83 c0 07             	add    $0x7,%eax
   12bc4:	c1 e8 03             	shr    $0x3,%eax
   12bc7:	c1 e0 03             	shl    $0x3,%eax
   12bca:	83 ec 0c             	sub    $0xc,%esp
   12bcd:	ff 75 18             	pushl  0x18(%ebp)
   12bd0:	52                   	push   %edx
   12bd1:	50                   	push   %eax
   12bd2:	ff 75 10             	pushl  0x10(%ebp)
   12bd5:	ff 75 d8             	pushl  -0x28(%ebp)
   12bd8:	e8 e7 fb ff ff       	call   127c4 <addPaddingBits>
   12bdd:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   12be0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12be3:	8d 50 0c             	lea    0xc(%eax),%edx
   12be6:	8b 45 08             	mov    0x8(%ebp),%eax
   12be9:	8b 00                	mov    (%eax),%eax
   12beb:	83 ec 08             	sub    $0x8,%esp
   12bee:	ff 75 20             	pushl  0x20(%ebp)
   12bf1:	52                   	push   %edx
   12bf2:	ff 75 18             	pushl  0x18(%ebp)
   12bf5:	ff 75 14             	pushl  0x14(%ebp)
   12bf8:	ff 75 d8             	pushl  -0x28(%ebp)
   12bfb:	50                   	push   %eax
   12bfc:	e8 dc f3 ff ff       	call   11fdd <filter>
   12c01:	83 c4 20             	add    $0x20,%esp
   12c04:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   12c07:	83 ec 0c             	sub    $0xc,%esp
   12c0a:	ff 75 d8             	pushl  -0x28(%ebp)
   12c0d:	e8 4c 0e ff ff       	call   3a5e <lodepng_free>
   12c12:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   12c15:	e9 34 02 00 00       	jmp    12e4e <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   12c1a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c1d:	8d 50 0c             	lea    0xc(%eax),%edx
   12c20:	8b 45 08             	mov    0x8(%ebp),%eax
   12c23:	8b 00                	mov    (%eax),%eax
   12c25:	83 ec 08             	sub    $0x8,%esp
   12c28:	ff 75 20             	pushl  0x20(%ebp)
   12c2b:	52                   	push   %edx
   12c2c:	ff 75 18             	pushl  0x18(%ebp)
   12c2f:	ff 75 14             	pushl  0x14(%ebp)
   12c32:	ff 75 10             	pushl  0x10(%ebp)
   12c35:	50                   	push   %eax
   12c36:	e8 a2 f3 ff ff       	call   11fdd <filter>
   12c3b:	83 c4 20             	add    $0x20,%esp
   12c3e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   12c41:	e9 08 02 00 00       	jmp    12e4e <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   12c46:	ff 75 dc             	pushl  -0x24(%ebp)
   12c49:	ff 75 18             	pushl  0x18(%ebp)
   12c4c:	ff 75 14             	pushl  0x14(%ebp)
   12c4f:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   12c55:	50                   	push   %eax
   12c56:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   12c5c:	50                   	push   %eax
   12c5d:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   12c63:	50                   	push   %eax
   12c64:	8d 45 98             	lea    -0x68(%ebp),%eax
   12c67:	50                   	push   %eax
   12c68:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   12c6b:	50                   	push   %eax
   12c6c:	e8 19 ab ff ff       	call   d78a <Adam7_getpassvalues>
   12c71:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   12c74:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   12c7a:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c7d:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12c7f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c82:	8b 00                	mov    (%eax),%eax
   12c84:	83 ec 0c             	sub    $0xc,%esp
   12c87:	50                   	push   %eax
   12c88:	e8 b0 0d ff ff       	call   3a3d <lodepng_malloc>
   12c8d:	83 c4 10             	add    $0x10,%esp
   12c90:	89 c2                	mov    %eax,%edx
   12c92:	8b 45 08             	mov    0x8(%ebp),%eax
   12c95:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   12c97:	8b 45 08             	mov    0x8(%ebp),%eax
   12c9a:	8b 00                	mov    (%eax),%eax
   12c9c:	85 c0                	test   %eax,%eax
   12c9e:	75 07                	jne    12ca7 <preProcessScanlines+0x1dd>
   12ca0:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   12ca7:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12caa:	83 ec 0c             	sub    $0xc,%esp
   12cad:	50                   	push   %eax
   12cae:	e8 8a 0d ff ff       	call   3a3d <lodepng_malloc>
   12cb3:	83 c4 10             	add    $0x10,%esp
   12cb6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   12cb9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12cbd:	75 0e                	jne    12ccd <preProcessScanlines+0x203>
   12cbf:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12cc2:	85 c0                	test   %eax,%eax
   12cc4:	74 07                	je     12ccd <preProcessScanlines+0x203>
   12cc6:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   12ccd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12cd1:	0f 85 69 01 00 00    	jne    12e40 <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   12cd7:	83 ec 0c             	sub    $0xc,%esp
   12cda:	ff 75 dc             	pushl  -0x24(%ebp)
   12cdd:	ff 75 18             	pushl  0x18(%ebp)
   12ce0:	ff 75 14             	pushl  0x14(%ebp)
   12ce3:	ff 75 10             	pushl  0x10(%ebp)
   12ce6:	ff 75 d4             	pushl  -0x2c(%ebp)
   12ce9:	e8 6c fb ff ff       	call   1285a <Adam7_interlace>
   12cee:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   12cf1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   12cf8:	e9 36 01 00 00       	jmp    12e33 <preProcessScanlines+0x369>
        if(bpp < 8) {
   12cfd:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   12d01:	0f 87 d6 00 00 00    	ja     12ddd <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   12d07:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12d0a:	83 c0 01             	add    $0x1,%eax
   12d0d:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   12d14:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12d17:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   12d1e:	29 c2                	sub    %eax,%edx
   12d20:	89 d0                	mov    %edx,%eax
   12d22:	83 ec 0c             	sub    $0xc,%esp
   12d25:	50                   	push   %eax
   12d26:	e8 12 0d ff ff       	call   3a3d <lodepng_malloc>
   12d2b:	83 c4 10             	add    $0x10,%esp
   12d2e:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   12d31:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   12d35:	75 0c                	jne    12d43 <preProcessScanlines+0x279>
   12d37:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   12d3e:	e9 fd 00 00 00       	jmp    12e40 <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   12d43:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12d46:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   12d4a:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12d4d:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12d51:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   12d55:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   12d57:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12d5a:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12d5e:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   12d62:	83 c2 07             	add    $0x7,%edx
   12d65:	c1 ea 03             	shr    $0x3,%edx
   12d68:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   12d6b:	89 d1                	mov    %edx,%ecx
   12d6d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12d70:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   12d77:	89 d6                	mov    %edx,%esi
   12d79:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   12d7c:	01 f2                	add    %esi,%edx
   12d7e:	83 ec 0c             	sub    $0xc,%esp
   12d81:	50                   	push   %eax
   12d82:	53                   	push   %ebx
   12d83:	51                   	push   %ecx
   12d84:	52                   	push   %edx
   12d85:	ff 75 d0             	pushl  -0x30(%ebp)
   12d88:	e8 37 fa ff ff       	call   127c4 <addPaddingBits>
   12d8d:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   12d90:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d93:	8d 58 0c             	lea    0xc(%eax),%ebx
   12d96:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12d99:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12d9d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12da0:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   12da4:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12da7:	8b 31                	mov    (%ecx),%esi
   12da9:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12dac:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12db3:	01 f1                	add    %esi,%ecx
   12db5:	83 ec 08             	sub    $0x8,%esp
   12db8:	ff 75 20             	pushl  0x20(%ebp)
   12dbb:	53                   	push   %ebx
   12dbc:	52                   	push   %edx
   12dbd:	50                   	push   %eax
   12dbe:	ff 75 d0             	pushl  -0x30(%ebp)
   12dc1:	51                   	push   %ecx
   12dc2:	e8 16 f2 ff ff       	call   11fdd <filter>
   12dc7:	83 c4 20             	add    $0x20,%esp
   12dca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   12dcd:	83 ec 0c             	sub    $0xc,%esp
   12dd0:	ff 75 d0             	pushl  -0x30(%ebp)
   12dd3:	e8 86 0c ff ff       	call   3a5e <lodepng_free>
   12dd8:	83 c4 10             	add    $0x10,%esp
   12ddb:	eb 4c                	jmp    12e29 <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   12ddd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12de0:	8d 70 0c             	lea    0xc(%eax),%esi
   12de3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12de6:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12dea:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12ded:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   12df1:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12df4:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   12dfb:	89 cb                	mov    %ecx,%ebx
   12dfd:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   12e00:	01 cb                	add    %ecx,%ebx
   12e02:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12e05:	8b 39                	mov    (%ecx),%edi
   12e07:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12e0a:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12e11:	01 f9                	add    %edi,%ecx
   12e13:	83 ec 08             	sub    $0x8,%esp
   12e16:	ff 75 20             	pushl  0x20(%ebp)
   12e19:	56                   	push   %esi
   12e1a:	52                   	push   %edx
   12e1b:	50                   	push   %eax
   12e1c:	53                   	push   %ebx
   12e1d:	51                   	push   %ecx
   12e1e:	e8 ba f1 ff ff       	call   11fdd <filter>
   12e23:	83 c4 20             	add    $0x20,%esp
   12e26:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12e29:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12e2d:	75 10                	jne    12e3f <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   12e2f:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   12e33:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   12e37:	0f 85 c0 fe ff ff    	jne    12cfd <preProcessScanlines+0x233>
   12e3d:	eb 01                	jmp    12e40 <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12e3f:	90                   	nop
      }
    }

    lodepng_free(adam7);
   12e40:	83 ec 0c             	sub    $0xc,%esp
   12e43:	ff 75 d4             	pushl  -0x2c(%ebp)
   12e46:	e8 13 0c ff ff       	call   3a5e <lodepng_free>
   12e4b:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   12e4e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   12e51:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12e54:	5b                   	pop    %ebx
   12e55:	5e                   	pop    %esi
   12e56:	5f                   	pop    %edi
   12e57:	5d                   	pop    %ebp
   12e58:	c3                   	ret    

00012e59 <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   12e59:	55                   	push   %ebp
   12e5a:	89 e5                	mov    %esp,%ebp
   12e5c:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   12e5f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12e62:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   12e65:	eb 47                	jmp    12eae <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   12e67:	8b 45 08             	mov    0x8(%ebp),%eax
   12e6a:	8d 50 04             	lea    0x4(%eax),%edx
   12e6d:	8b 45 08             	mov    0x8(%ebp),%eax
   12e70:	ff 75 fc             	pushl  -0x4(%ebp)
   12e73:	52                   	push   %edx
   12e74:	50                   	push   %eax
   12e75:	e8 73 5f ff ff       	call   8ded <lodepng_chunk_append>
   12e7a:	83 c4 0c             	add    $0xc,%esp
   12e7d:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12e80:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   12e84:	74 05                	je     12e8b <addUnknownChunks+0x32>
   12e86:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12e89:	eb 37                	jmp    12ec2 <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   12e8b:	8b 45 08             	mov    0x8(%ebp),%eax
   12e8e:	8b 50 04             	mov    0x4(%eax),%edx
   12e91:	8b 45 08             	mov    0x8(%ebp),%eax
   12e94:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   12e97:	8b 55 10             	mov    0x10(%ebp),%edx
   12e9a:	8b 45 0c             	mov    0xc(%ebp),%eax
   12e9d:	01 d0                	add    %edx,%eax
   12e9f:	50                   	push   %eax
   12ea0:	ff 75 fc             	pushl  -0x4(%ebp)
   12ea3:	e8 ff 5c ff ff       	call   8ba7 <lodepng_chunk_next>
   12ea8:	83 c4 08             	add    $0x8,%esp
   12eab:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   12eae:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12eb1:	8b 45 0c             	mov    0xc(%ebp),%eax
   12eb4:	29 c2                	sub    %eax,%edx
   12eb6:	89 d0                	mov    %edx,%eax
   12eb8:	3b 45 10             	cmp    0x10(%ebp),%eax
   12ebb:	7c aa                	jl     12e67 <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   12ebd:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12ec2:	c9                   	leave  
   12ec3:	c3                   	ret    

00012ec4 <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   12ec4:	55                   	push   %ebp
   12ec5:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   12ec7:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12ecb:	77 07                	ja     12ed4 <isGrayICCProfile+0x10>
   12ecd:	b8 00 00 00 00       	mov    $0x0,%eax
   12ed2:	eb 40                	jmp    12f14 <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   12ed4:	8b 45 08             	mov    0x8(%ebp),%eax
   12ed7:	83 c0 10             	add    $0x10,%eax
   12eda:	0f b6 00             	movzbl (%eax),%eax
   12edd:	3c 47                	cmp    $0x47,%al
   12edf:	75 2e                	jne    12f0f <isGrayICCProfile+0x4b>
   12ee1:	8b 45 08             	mov    0x8(%ebp),%eax
   12ee4:	83 c0 11             	add    $0x11,%eax
   12ee7:	0f b6 00             	movzbl (%eax),%eax
   12eea:	3c 52                	cmp    $0x52,%al
   12eec:	75 21                	jne    12f0f <isGrayICCProfile+0x4b>
   12eee:	8b 45 08             	mov    0x8(%ebp),%eax
   12ef1:	83 c0 12             	add    $0x12,%eax
   12ef4:	0f b6 00             	movzbl (%eax),%eax
   12ef7:	3c 41                	cmp    $0x41,%al
   12ef9:	75 14                	jne    12f0f <isGrayICCProfile+0x4b>
   12efb:	8b 45 08             	mov    0x8(%ebp),%eax
   12efe:	83 c0 13             	add    $0x13,%eax
   12f01:	0f b6 00             	movzbl (%eax),%eax
   12f04:	3c 59                	cmp    $0x59,%al
   12f06:	75 07                	jne    12f0f <isGrayICCProfile+0x4b>
   12f08:	b8 01 00 00 00       	mov    $0x1,%eax
   12f0d:	eb 05                	jmp    12f14 <isGrayICCProfile+0x50>
   12f0f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12f14:	5d                   	pop    %ebp
   12f15:	c3                   	ret    

00012f16 <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   12f16:	55                   	push   %ebp
   12f17:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   12f19:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12f1d:	77 07                	ja     12f26 <isRGBICCProfile+0x10>
   12f1f:	b8 00 00 00 00       	mov    $0x0,%eax
   12f24:	eb 40                	jmp    12f66 <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   12f26:	8b 45 08             	mov    0x8(%ebp),%eax
   12f29:	83 c0 10             	add    $0x10,%eax
   12f2c:	0f b6 00             	movzbl (%eax),%eax
   12f2f:	3c 52                	cmp    $0x52,%al
   12f31:	75 2e                	jne    12f61 <isRGBICCProfile+0x4b>
   12f33:	8b 45 08             	mov    0x8(%ebp),%eax
   12f36:	83 c0 11             	add    $0x11,%eax
   12f39:	0f b6 00             	movzbl (%eax),%eax
   12f3c:	3c 47                	cmp    $0x47,%al
   12f3e:	75 21                	jne    12f61 <isRGBICCProfile+0x4b>
   12f40:	8b 45 08             	mov    0x8(%ebp),%eax
   12f43:	83 c0 12             	add    $0x12,%eax
   12f46:	0f b6 00             	movzbl (%eax),%eax
   12f49:	3c 42                	cmp    $0x42,%al
   12f4b:	75 14                	jne    12f61 <isRGBICCProfile+0x4b>
   12f4d:	8b 45 08             	mov    0x8(%ebp),%eax
   12f50:	83 c0 13             	add    $0x13,%eax
   12f53:	0f b6 00             	movzbl (%eax),%eax
   12f56:	3c 20                	cmp    $0x20,%al
   12f58:	75 07                	jne    12f61 <isRGBICCProfile+0x4b>
   12f5a:	b8 01 00 00 00       	mov    $0x1,%eax
   12f5f:	eb 05                	jmp    12f66 <isRGBICCProfile+0x50>
   12f61:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12f66:	5d                   	pop    %ebp
   12f67:	c3                   	ret    

00012f68 <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   12f68:	55                   	push   %ebp
   12f69:	89 e5                	mov    %esp,%ebp
   12f6b:	57                   	push   %edi
   12f6c:	56                   	push   %esi
   12f6d:	53                   	push   %ebx
   12f6e:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   12f74:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   12f7b:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   12f82:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f85:	6a 00                	push   $0x0
   12f87:	6a 00                	push   $0x0
   12f89:	50                   	push   %eax
   12f8a:	e8 6f 0d ff ff       	call   3cfe <ucvector_init>
   12f8f:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   12f92:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f95:	05 98 00 00 00       	add    $0x98,%eax
   12f9a:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   12f9d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12fa3:	50                   	push   %eax
   12fa4:	e8 3a 71 ff ff       	call   a0e3 <lodepng_info_init>
   12fa9:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   12fac:	8b 45 08             	mov    0x8(%ebp),%eax
   12faf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   12fb5:	8b 45 0c             	mov    0xc(%ebp),%eax
   12fb8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   12fbe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fc1:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   12fc8:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   12fcb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12fce:	8b 40 0c             	mov    0xc(%eax),%eax
   12fd1:	83 f8 03             	cmp    $0x3,%eax
   12fd4:	74 0a                	je     12fe0 <lodepng_encode+0x78>
   12fd6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fd9:	8b 40 6c             	mov    0x6c(%eax),%eax
   12fdc:	85 c0                	test   %eax,%eax
   12fde:	74 29                	je     13009 <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   12fe0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12fe3:	8b 40 18             	mov    0x18(%eax),%eax
   12fe6:	85 c0                	test   %eax,%eax
   12fe8:	74 0d                	je     12ff7 <lodepng_encode+0x8f>
   12fea:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12fed:	8b 40 18             	mov    0x18(%eax),%eax
   12ff0:	3d 00 01 00 00       	cmp    $0x100,%eax
   12ff5:	7e 12                	jle    13009 <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   12ff7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ffa:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   13001:	00 00 00 
    goto cleanup;
   13004:	e9 78 0c 00 00       	jmp    13c81 <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   13009:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1300c:	8b 40 38             	mov    0x38(%eax),%eax
   1300f:	83 f8 02             	cmp    $0x2,%eax
   13012:	76 12                	jbe    13026 <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   13014:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13017:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   1301e:	00 00 00 
    goto cleanup;
   13021:	e9 5b 0c 00 00       	jmp    13c81 <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   13026:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13029:	8b 40 08             	mov    0x8(%eax),%eax
   1302c:	83 f8 01             	cmp    $0x1,%eax
   1302f:	76 12                	jbe    13043 <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   13031:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13034:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   1303b:	00 00 00 
    goto cleanup;
   1303e:	e9 3e 0c 00 00       	jmp    13c81 <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   13043:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13046:	8b 50 10             	mov    0x10(%eax),%edx
   13049:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1304c:	8b 40 0c             	mov    0xc(%eax),%eax
   1304f:	52                   	push   %edx
   13050:	50                   	push   %eax
   13051:	e8 a4 5f ff ff       	call   8ffa <checkColorValidity>
   13056:	83 c4 08             	add    $0x8,%esp
   13059:	89 c2                	mov    %eax,%edx
   1305b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1305e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13064:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13067:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1306d:	85 c0                	test   %eax,%eax
   1306f:	0f 85 c6 0b 00 00    	jne    13c3b <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   13075:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13078:	8b 50 7c             	mov    0x7c(%eax),%edx
   1307b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1307e:	8b 40 78             	mov    0x78(%eax),%eax
   13081:	52                   	push   %edx
   13082:	50                   	push   %eax
   13083:	e8 72 5f ff ff       	call   8ffa <checkColorValidity>
   13088:	83 c4 08             	add    $0x8,%esp
   1308b:	89 c2                	mov    %eax,%edx
   1308d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13090:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13096:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13099:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1309f:	85 c0                	test   %eax,%eax
   130a1:	0f 85 97 0b 00 00    	jne    13c3e <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   130a7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130aa:	05 98 00 00 00       	add    $0x98,%eax
   130af:	83 ec 08             	sub    $0x8,%esp
   130b2:	50                   	push   %eax
   130b3:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130b9:	50                   	push   %eax
   130ba:	e8 58 71 ff ff       	call   a217 <lodepng_info_copy>
   130bf:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   130c2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130c5:	8b 40 5c             	mov    0x5c(%eax),%eax
   130c8:	85 c0                	test   %eax,%eax
   130ca:	0f 84 3c 02 00 00    	je     1330c <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   130d0:	83 ec 0c             	sub    $0xc,%esp
   130d3:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   130d9:	50                   	push   %eax
   130da:	e8 5f 96 ff ff       	call   c73e <lodepng_color_stats_init>
   130df:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   130e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   130e5:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   130eb:	85 c0                	test   %eax,%eax
   130ed:	74 2d                	je     1311c <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   130ef:	8b 45 dc             	mov    -0x24(%ebp),%eax
   130f2:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   130f8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   130fb:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   13101:	83 ec 08             	sub    $0x8,%esp
   13104:	52                   	push   %edx
   13105:	50                   	push   %eax
   13106:	e8 b9 fd ff ff       	call   12ec4 <isGrayICCProfile>
   1310b:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   1310e:	85 c0                	test   %eax,%eax
   13110:	74 0a                	je     1311c <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   13112:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   13119:	00 00 00 
    }
    if(info_png->iccp_defined &&
   1311c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1311f:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   13125:	85 c0                	test   %eax,%eax
   13127:	74 2d                	je     13156 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   13129:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1312c:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   13132:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13135:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   1313b:	83 ec 08             	sub    $0x8,%esp
   1313e:	52                   	push   %edx
   1313f:	50                   	push   %eax
   13140:	e8 d1 fd ff ff       	call   12f16 <isRGBICCProfile>
   13145:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   13148:	85 c0                	test   %eax,%eax
   1314a:	74 0a                	je     13156 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   1314c:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   13153:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   13156:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13159:	83 c0 78             	add    $0x78,%eax
   1315c:	83 ec 0c             	sub    $0xc,%esp
   1315f:	50                   	push   %eax
   13160:	ff 75 18             	pushl  0x18(%ebp)
   13163:	ff 75 14             	pushl  0x14(%ebp)
   13166:	ff 75 10             	pushl  0x10(%ebp)
   13169:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   1316f:	50                   	push   %eax
   13170:	e8 e0 96 ff ff       	call   c855 <lodepng_compute_color_stats>
   13175:	83 c4 20             	add    $0x20,%esp
   13178:	89 c2                	mov    %eax,%edx
   1317a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1317d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13183:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13186:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1318c:	85 c0                	test   %eax,%eax
   1318e:	0f 85 ad 0a 00 00    	jne    13c41 <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   13194:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13197:	8b 40 2c             	mov    0x2c(%eax),%eax
   1319a:	85 c0                	test   %eax,%eax
   1319c:	0f 84 be 00 00 00    	je     13260 <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   131a2:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   131a9:	00 00 00 
   131ac:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   131b3:	00 00 00 
   131b6:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   131bd:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   131c0:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   131c6:	83 ec 04             	sub    $0x4,%esp
   131c9:	6a 10                	push   $0x10
   131cb:	6a 02                	push   $0x2
   131cd:	50                   	push   %eax
   131ce:	e8 15 61 ff ff       	call   92e8 <lodepng_color_mode_make>
   131d3:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   131d6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   131d9:	8d 58 0c             	lea    0xc(%eax),%ebx
   131dc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   131df:	8b 48 38             	mov    0x38(%eax),%ecx
   131e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   131e5:	8b 50 34             	mov    0x34(%eax),%edx
   131e8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   131eb:	8b 40 30             	mov    0x30(%eax),%eax
   131ee:	53                   	push   %ebx
   131ef:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   131f5:	53                   	push   %ebx
   131f6:	51                   	push   %ecx
   131f7:	52                   	push   %edx
   131f8:	50                   	push   %eax
   131f9:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   131ff:	50                   	push   %eax
   13200:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   13206:	50                   	push   %eax
   13207:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   1320d:	50                   	push   %eax
   1320e:	e8 8a 92 ff ff       	call   c49d <lodepng_convert_rgb>
   13213:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   13216:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   1321c:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   13222:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   13228:	83 ec 0c             	sub    $0xc,%esp
   1322b:	68 ff ff 00 00       	push   $0xffff
   13230:	51                   	push   %ecx
   13231:	52                   	push   %edx
   13232:	50                   	push   %eax
   13233:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   13239:	50                   	push   %eax
   1323a:	e8 26 a1 ff ff       	call   d365 <lodepng_color_stats_add>
   1323f:	83 c4 20             	add    $0x20,%esp
   13242:	89 c2                	mov    %eax,%edx
   13244:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13247:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1324d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13250:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13256:	85 c0                	test   %eax,%eax
   13258:	74 06                	je     13260 <lodepng_encode+0x2f8>
   1325a:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   1325b:	e9 e1 09 00 00       	jmp    13c41 <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   13260:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13263:	8d 50 78             	lea    0x78(%eax),%edx
   13266:	83 ec 04             	sub    $0x4,%esp
   13269:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   1326f:	50                   	push   %eax
   13270:	52                   	push   %edx
   13271:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13277:	83 c0 0c             	add    $0xc,%eax
   1327a:	50                   	push   %eax
   1327b:	e8 79 a1 ff ff       	call   d3f9 <auto_choose_color>
   13280:	83 c4 10             	add    $0x10,%esp
   13283:	89 c2                	mov    %eax,%edx
   13285:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13288:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1328e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13291:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13297:	85 c0                	test   %eax,%eax
   13299:	0f 85 a5 09 00 00    	jne    13c44 <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   1329f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   132a2:	8b 40 2c             	mov    0x2c(%eax),%eax
   132a5:	85 c0                	test   %eax,%eax
   132a7:	74 63                	je     1330c <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   132a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   132ac:	8d 58 0c             	lea    0xc(%eax),%ebx
   132af:	8b 45 dc             	mov    -0x24(%ebp),%eax
   132b2:	8b 48 38             	mov    0x38(%eax),%ecx
   132b5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   132b8:	8b 50 34             	mov    0x34(%eax),%edx
   132bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   132be:	8b 40 30             	mov    0x30(%eax),%eax
   132c1:	53                   	push   %ebx
   132c2:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   132c8:	83 c3 0c             	add    $0xc,%ebx
   132cb:	53                   	push   %ebx
   132cc:	51                   	push   %ecx
   132cd:	52                   	push   %edx
   132ce:	50                   	push   %eax
   132cf:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   132d5:	83 c0 38             	add    $0x38,%eax
   132d8:	50                   	push   %eax
   132d9:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   132df:	83 c0 34             	add    $0x34,%eax
   132e2:	50                   	push   %eax
   132e3:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   132e9:	83 c0 30             	add    $0x30,%eax
   132ec:	50                   	push   %eax
   132ed:	e8 ab 91 ff ff       	call   c49d <lodepng_convert_rgb>
   132f2:	83 c4 20             	add    $0x20,%esp
   132f5:	85 c0                	test   %eax,%eax
   132f7:	74 13                	je     1330c <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   132f9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132fc:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   13303:	00 00 00 
        goto cleanup;
   13306:	90                   	nop
   13307:	e9 75 09 00 00       	jmp    13c81 <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   1330c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1330f:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   13315:	85 c0                	test   %eax,%eax
   13317:	0f 84 b2 00 00 00    	je     133cf <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   1331d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13320:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   13326:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13329:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   1332f:	83 ec 08             	sub    $0x8,%esp
   13332:	52                   	push   %edx
   13333:	50                   	push   %eax
   13334:	e8 8b fb ff ff       	call   12ec4 <isGrayICCProfile>
   13339:	83 c4 10             	add    $0x10,%esp
   1333c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   1333f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13342:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   13348:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1334b:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   13351:	83 ec 08             	sub    $0x8,%esp
   13354:	52                   	push   %edx
   13355:	50                   	push   %eax
   13356:	e8 bb fb ff ff       	call   12f16 <isRGBICCProfile>
   1335b:	83 c4 10             	add    $0x10,%esp
   1335e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   13361:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13367:	85 c0                	test   %eax,%eax
   13369:	74 0b                	je     13376 <lodepng_encode+0x40e>
   1336b:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13371:	83 f8 04             	cmp    $0x4,%eax
   13374:	75 07                	jne    1337d <lodepng_encode+0x415>
   13376:	b8 01 00 00 00       	mov    $0x1,%eax
   1337b:	eb 05                	jmp    13382 <lodepng_encode+0x41a>
   1337d:	b8 00 00 00 00       	mov    $0x0,%eax
   13382:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   13385:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   13389:	75 18                	jne    133a3 <lodepng_encode+0x43b>
   1338b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   1338f:	75 12                	jne    133a3 <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   13391:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13394:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   1339b:	00 00 00 
      goto cleanup;
   1339e:	e9 de 08 00 00       	jmp    13c81 <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   133a3:	8b 45 d8             	mov    -0x28(%ebp),%eax
   133a6:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   133a9:	74 24                	je     133cf <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   133ab:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133ae:	8b 40 5c             	mov    0x5c(%eax),%eax
   133b1:	85 c0                	test   %eax,%eax
   133b3:	74 07                	je     133bc <lodepng_encode+0x454>
   133b5:	ba 66 00 00 00       	mov    $0x66,%edx
   133ba:	eb 05                	jmp    133c1 <lodepng_encode+0x459>
   133bc:	ba 65 00 00 00       	mov    $0x65,%edx
   133c1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133c4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   133ca:	e9 b2 08 00 00       	jmp    13c81 <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   133cf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133d2:	83 c0 78             	add    $0x78,%eax
   133d5:	83 ec 08             	sub    $0x8,%esp
   133d8:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   133de:	83 c2 0c             	add    $0xc,%edx
   133e1:	52                   	push   %edx
   133e2:	50                   	push   %eax
   133e3:	e8 57 5f ff ff       	call   933f <lodepng_color_mode_equal>
   133e8:	83 c4 10             	add    $0x10,%esp
   133eb:	85 c0                	test   %eax,%eax
   133ed:	0f 85 f8 00 00 00    	jne    134eb <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   133f3:	8b 55 14             	mov    0x14(%ebp),%edx
   133f6:	8b 45 18             	mov    0x18(%ebp),%eax
   133f9:	89 d3                	mov    %edx,%ebx
   133fb:	0f af d8             	imul   %eax,%ebx
   133fe:	83 ec 0c             	sub    $0xc,%esp
   13401:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13407:	83 c0 0c             	add    $0xc,%eax
   1340a:	50                   	push   %eax
   1340b:	e8 49 61 ff ff       	call   9559 <lodepng_get_bpp>
   13410:	83 c4 10             	add    $0x10,%esp
   13413:	0f af c3             	imul   %ebx,%eax
   13416:	83 c0 07             	add    $0x7,%eax
   13419:	c1 e8 03             	shr    $0x3,%eax
   1341c:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   1341f:	83 ec 0c             	sub    $0xc,%esp
   13422:	ff 75 cc             	pushl  -0x34(%ebp)
   13425:	e8 13 06 ff ff       	call   3a3d <lodepng_malloc>
   1342a:	83 c4 10             	add    $0x10,%esp
   1342d:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   13430:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   13434:	75 13                	jne    13449 <lodepng_encode+0x4e1>
   13436:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   1343a:	74 0d                	je     13449 <lodepng_encode+0x4e1>
   1343c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1343f:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   13446:	00 00 00 
    if(!state->error) {
   13449:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1344c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13452:	85 c0                	test   %eax,%eax
   13454:	75 33                	jne    13489 <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   13456:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13459:	83 c0 78             	add    $0x78,%eax
   1345c:	83 ec 08             	sub    $0x8,%esp
   1345f:	ff 75 18             	pushl  0x18(%ebp)
   13462:	ff 75 14             	pushl  0x14(%ebp)
   13465:	50                   	push   %eax
   13466:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1346c:	83 c0 0c             	add    $0xc,%eax
   1346f:	50                   	push   %eax
   13470:	ff 75 10             	pushl  0x10(%ebp)
   13473:	ff 75 c8             	pushl  -0x38(%ebp)
   13476:	e8 c9 8c ff ff       	call   c144 <lodepng_convert>
   1347b:	83 c4 20             	add    $0x20,%esp
   1347e:	89 c2                	mov    %eax,%edx
   13480:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13483:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   13489:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1348c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13492:	85 c0                	test   %eax,%eax
   13494:	75 35                	jne    134cb <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   13496:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13499:	83 c0 38             	add    $0x38,%eax
   1349c:	83 ec 04             	sub    $0x4,%esp
   1349f:	50                   	push   %eax
   134a0:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   134a6:	50                   	push   %eax
   134a7:	ff 75 18             	pushl  0x18(%ebp)
   134aa:	ff 75 14             	pushl  0x14(%ebp)
   134ad:	ff 75 c8             	pushl  -0x38(%ebp)
   134b0:	8d 45 bc             	lea    -0x44(%ebp),%eax
   134b3:	50                   	push   %eax
   134b4:	8d 45 c0             	lea    -0x40(%ebp),%eax
   134b7:	50                   	push   %eax
   134b8:	e8 0d f6 ff ff       	call   12aca <preProcessScanlines>
   134bd:	83 c4 20             	add    $0x20,%esp
   134c0:	89 c2                	mov    %eax,%edx
   134c2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134c5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   134cb:	83 ec 0c             	sub    $0xc,%esp
   134ce:	ff 75 c8             	pushl  -0x38(%ebp)
   134d1:	e8 88 05 ff ff       	call   3a5e <lodepng_free>
   134d6:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   134d9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134dc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134e2:	85 c0                	test   %eax,%eax
   134e4:	74 4b                	je     13531 <lodepng_encode+0x5c9>
   134e6:	e9 96 07 00 00       	jmp    13c81 <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   134eb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134ee:	83 c0 38             	add    $0x38,%eax
   134f1:	83 ec 04             	sub    $0x4,%esp
   134f4:	50                   	push   %eax
   134f5:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   134fb:	50                   	push   %eax
   134fc:	ff 75 18             	pushl  0x18(%ebp)
   134ff:	ff 75 14             	pushl  0x14(%ebp)
   13502:	ff 75 10             	pushl  0x10(%ebp)
   13505:	8d 45 bc             	lea    -0x44(%ebp),%eax
   13508:	50                   	push   %eax
   13509:	8d 45 c0             	lea    -0x40(%ebp),%eax
   1350c:	50                   	push   %eax
   1350d:	e8 b8 f5 ff ff       	call   12aca <preProcessScanlines>
   13512:	83 c4 20             	add    $0x20,%esp
   13515:	89 c2                	mov    %eax,%edx
   13517:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1351a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13520:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13523:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13529:	85 c0                	test   %eax,%eax
   1352b:	0f 85 16 07 00 00    	jne    13c47 <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   13531:	83 ec 0c             	sub    $0xc,%esp
   13534:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13537:	50                   	push   %eax
   13538:	e8 21 d9 ff ff       	call   10e5e <writeSignature>
   1353d:	83 c4 10             	add    $0x10,%esp
   13540:	89 c2                	mov    %eax,%edx
   13542:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13545:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1354b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1354e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13554:	85 c0                	test   %eax,%eax
   13556:	0f 85 ee 06 00 00    	jne    13c4a <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   1355c:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   13562:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   13568:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1356e:	83 ec 08             	sub    $0x8,%esp
   13571:	51                   	push   %ecx
   13572:	52                   	push   %edx
   13573:	50                   	push   %eax
   13574:	ff 75 18             	pushl  0x18(%ebp)
   13577:	ff 75 14             	pushl  0x14(%ebp)
   1357a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1357d:	50                   	push   %eax
   1357e:	e8 4a d9 ff ff       	call   10ecd <addChunk_IHDR>
   13583:	83 c4 20             	add    $0x20,%esp
   13586:	89 c2                	mov    %eax,%edx
   13588:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1358b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13591:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13594:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1359a:	85 c0                	test   %eax,%eax
   1359c:	0f 85 ab 06 00 00    	jne    13c4d <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   135a2:	8b 45 98             	mov    -0x68(%ebp),%eax
   135a5:	85 c0                	test   %eax,%eax
   135a7:	74 33                	je     135dc <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   135a9:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   135ac:	8b 45 98             	mov    -0x68(%ebp),%eax
   135af:	83 ec 04             	sub    $0x4,%esp
   135b2:	52                   	push   %edx
   135b3:	50                   	push   %eax
   135b4:	8d 45 b0             	lea    -0x50(%ebp),%eax
   135b7:	50                   	push   %eax
   135b8:	e8 9c f8 ff ff       	call   12e59 <addUnknownChunks>
   135bd:	83 c4 10             	add    $0x10,%esp
   135c0:	89 c2                	mov    %eax,%edx
   135c2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135c5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   135cb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135ce:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   135d4:	85 c0                	test   %eax,%eax
   135d6:	0f 85 74 06 00 00    	jne    13c50 <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   135dc:	8b 45 88             	mov    -0x78(%ebp),%eax
   135df:	85 c0                	test   %eax,%eax
   135e1:	74 39                	je     1361c <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   135e3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135e6:	83 c0 38             	add    $0x38,%eax
   135e9:	83 ec 04             	sub    $0x4,%esp
   135ec:	50                   	push   %eax
   135ed:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   135f3:	50                   	push   %eax
   135f4:	8d 45 b0             	lea    -0x50(%ebp),%eax
   135f7:	50                   	push   %eax
   135f8:	e8 a4 e4 ff ff       	call   11aa1 <addChunk_iCCP>
   135fd:	83 c4 10             	add    $0x10,%esp
   13600:	89 c2                	mov    %eax,%edx
   13602:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13605:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1360b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1360e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13614:	85 c0                	test   %eax,%eax
   13616:	0f 85 37 06 00 00    	jne    13c53 <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   1361c:	8b 45 80             	mov    -0x80(%ebp),%eax
   1361f:	85 c0                	test   %eax,%eax
   13621:	74 32                	je     13655 <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   13623:	83 ec 08             	sub    $0x8,%esp
   13626:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1362c:	50                   	push   %eax
   1362d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13630:	50                   	push   %eax
   13631:	e8 41 e4 ff ff       	call   11a77 <addChunk_sRGB>
   13636:	83 c4 10             	add    $0x10,%esp
   13639:	89 c2                	mov    %eax,%edx
   1363b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1363e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13644:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13647:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1364d:	85 c0                	test   %eax,%eax
   1364f:	0f 85 01 06 00 00    	jne    13c56 <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   13655:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   1365b:	85 c0                	test   %eax,%eax
   1365d:	74 32                	je     13691 <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   1365f:	83 ec 08             	sub    $0x8,%esp
   13662:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13668:	50                   	push   %eax
   13669:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1366c:	50                   	push   %eax
   1366d:	e8 a7 e2 ff ff       	call   11919 <addChunk_gAMA>
   13672:	83 c4 10             	add    $0x10,%esp
   13675:	89 c2                	mov    %eax,%edx
   13677:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1367a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13680:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13683:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13689:	85 c0                	test   %eax,%eax
   1368b:	0f 85 c8 05 00 00    	jne    13c59 <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   13691:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   13697:	85 c0                	test   %eax,%eax
   13699:	74 32                	je     136cd <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   1369b:	83 ec 08             	sub    $0x8,%esp
   1369e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   136a4:	50                   	push   %eax
   136a5:	8d 45 b0             	lea    -0x50(%ebp),%eax
   136a8:	50                   	push   %eax
   136a9:	e8 c1 e2 ff ff       	call   1196f <addChunk_cHRM>
   136ae:	83 c4 10             	add    $0x10,%esp
   136b1:	89 c2                	mov    %eax,%edx
   136b3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136b6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   136bc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136bf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   136c5:	85 c0                	test   %eax,%eax
   136c7:	0f 85 8f 05 00 00    	jne    13c5c <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   136cd:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   136d3:	83 f8 03             	cmp    $0x3,%eax
   136d6:	75 35                	jne    1370d <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   136d8:	83 ec 08             	sub    $0x8,%esp
   136db:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   136e1:	83 c0 0c             	add    $0xc,%eax
   136e4:	50                   	push   %eax
   136e5:	8d 45 b0             	lea    -0x50(%ebp),%eax
   136e8:	50                   	push   %eax
   136e9:	e8 78 d8 ff ff       	call   10f66 <addChunk_PLTE>
   136ee:	83 c4 10             	add    $0x10,%esp
   136f1:	89 c2                	mov    %eax,%edx
   136f3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136f6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   136fc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136ff:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13705:	85 c0                	test   %eax,%eax
   13707:	0f 85 52 05 00 00    	jne    13c5f <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   1370d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13710:	8b 40 6c             	mov    0x6c(%eax),%eax
   13713:	85 c0                	test   %eax,%eax
   13715:	74 4b                	je     13762 <lodepng_encode+0x7fa>
   13717:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1371d:	83 f8 02             	cmp    $0x2,%eax
   13720:	74 0b                	je     1372d <lodepng_encode+0x7c5>
   13722:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13728:	83 f8 06             	cmp    $0x6,%eax
   1372b:	75 35                	jne    13762 <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   1372d:	83 ec 08             	sub    $0x8,%esp
   13730:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13736:	83 c0 0c             	add    $0xc,%eax
   13739:	50                   	push   %eax
   1373a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1373d:	50                   	push   %eax
   1373e:	e8 23 d8 ff ff       	call   10f66 <addChunk_PLTE>
   13743:	83 c4 10             	add    $0x10,%esp
   13746:	89 c2                	mov    %eax,%edx
   13748:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1374b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13751:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13754:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1375a:	85 c0                	test   %eax,%eax
   1375c:	0f 85 00 05 00 00    	jne    13c62 <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   13762:	83 ec 08             	sub    $0x8,%esp
   13765:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1376b:	83 c0 0c             	add    $0xc,%eax
   1376e:	50                   	push   %eax
   1376f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13772:	50                   	push   %eax
   13773:	e8 c4 d8 ff ff       	call   1103c <addChunk_tRNS>
   13778:	83 c4 10             	add    $0x10,%esp
   1377b:	89 c2                	mov    %eax,%edx
   1377d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13780:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13786:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13789:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1378f:	85 c0                	test   %eax,%eax
   13791:	0f 85 ce 04 00 00    	jne    13c65 <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   13797:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   1379d:	85 c0                	test   %eax,%eax
   1379f:	74 32                	je     137d3 <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   137a1:	83 ec 08             	sub    $0x8,%esp
   137a4:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   137aa:	50                   	push   %eax
   137ab:	8d 45 b0             	lea    -0x50(%ebp),%eax
   137ae:	50                   	push   %eax
   137af:	e8 e4 de ff ff       	call   11698 <addChunk_bKGD>
   137b4:	83 c4 10             	add    $0x10,%esp
   137b7:	89 c2                	mov    %eax,%edx
   137b9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137bc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   137c2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137c5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   137cb:	85 c0                	test   %eax,%eax
   137cd:	0f 85 95 04 00 00    	jne    13c68 <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   137d3:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   137d9:	85 c0                	test   %eax,%eax
   137db:	74 32                	je     1380f <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   137dd:	83 ec 08             	sub    $0x8,%esp
   137e0:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   137e6:	50                   	push   %eax
   137e7:	8d 45 b0             	lea    -0x50(%ebp),%eax
   137ea:	50                   	push   %eax
   137eb:	e8 ac e0 ff ff       	call   1189c <addChunk_pHYs>
   137f0:	83 c4 10             	add    $0x10,%esp
   137f3:	89 c2                	mov    %eax,%edx
   137f5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137f8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   137fe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13801:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13807:	85 c0                	test   %eax,%eax
   13809:	0f 85 5c 04 00 00    	jne    13c6b <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   1380f:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13812:	85 c0                	test   %eax,%eax
   13814:	74 33                	je     13849 <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   13816:	8b 55 a8             	mov    -0x58(%ebp),%edx
   13819:	8b 45 9c             	mov    -0x64(%ebp),%eax
   1381c:	83 ec 04             	sub    $0x4,%esp
   1381f:	52                   	push   %edx
   13820:	50                   	push   %eax
   13821:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13824:	50                   	push   %eax
   13825:	e8 2f f6 ff ff       	call   12e59 <addUnknownChunks>
   1382a:	83 c4 10             	add    $0x10,%esp
   1382d:	89 c2                	mov    %eax,%edx
   1382f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13832:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13838:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1383b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13841:	85 c0                	test   %eax,%eax
   13843:	0f 85 25 04 00 00    	jne    13c6e <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   13849:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1384c:	8d 48 38             	lea    0x38(%eax),%ecx
   1384f:	8b 55 bc             	mov    -0x44(%ebp),%edx
   13852:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13855:	51                   	push   %ecx
   13856:	52                   	push   %edx
   13857:	50                   	push   %eax
   13858:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1385b:	50                   	push   %eax
   1385c:	e8 bd d9 ff ff       	call   1121e <addChunk_IDAT>
   13861:	83 c4 10             	add    $0x10,%esp
   13864:	89 c2                	mov    %eax,%edx
   13866:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13869:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1386f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13872:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13878:	85 c0                	test   %eax,%eax
   1387a:	0f 85 f1 03 00 00    	jne    13c71 <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   13880:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   13886:	85 c0                	test   %eax,%eax
   13888:	74 35                	je     138bf <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   1388a:	83 ec 08             	sub    $0x8,%esp
   1388d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13893:	83 c0 60             	add    $0x60,%eax
   13896:	50                   	push   %eax
   13897:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1389a:	50                   	push   %eax
   1389b:	e8 5c df ff ff       	call   117fc <addChunk_tIME>
   138a0:	83 c4 10             	add    $0x10,%esp
   138a3:	89 c2                	mov    %eax,%edx
   138a5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   138a8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   138ae:	8b 45 1c             	mov    0x1c(%ebp),%eax
   138b1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   138b7:	85 c0                	test   %eax,%eax
   138b9:	0f 85 b5 03 00 00    	jne    13c74 <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   138bf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   138c6:	e9 12 01 00 00       	jmp    139dd <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   138cb:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   138d1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   138d4:	c1 e2 02             	shl    $0x2,%edx
   138d7:	01 d0                	add    %edx,%eax
   138d9:	8b 00                	mov    (%eax),%eax
   138db:	83 ec 0c             	sub    $0xc,%esp
   138de:	50                   	push   %eax
   138df:	e8 f5 01 ff ff       	call   3ad9 <lodepng_strlen>
   138e4:	83 c4 10             	add    $0x10,%esp
   138e7:	83 f8 4f             	cmp    $0x4f,%eax
   138ea:	7e 12                	jle    138fe <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   138ec:	8b 45 1c             	mov    0x1c(%ebp),%eax
   138ef:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   138f6:	00 00 00 
        goto cleanup;
   138f9:	e9 83 03 00 00       	jmp    13c81 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   138fe:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13904:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13907:	c1 e2 02             	shl    $0x2,%edx
   1390a:	01 d0                	add    %edx,%eax
   1390c:	8b 00                	mov    (%eax),%eax
   1390e:	83 ec 0c             	sub    $0xc,%esp
   13911:	50                   	push   %eax
   13912:	e8 c2 01 ff ff       	call   3ad9 <lodepng_strlen>
   13917:	83 c4 10             	add    $0x10,%esp
   1391a:	85 c0                	test   %eax,%eax
   1391c:	7f 12                	jg     13930 <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   1391e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13921:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   13928:	00 00 00 
        goto cleanup;
   1392b:	e9 51 03 00 00       	jmp    13c81 <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   13930:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13933:	8b 40 74             	mov    0x74(%eax),%eax
   13936:	85 c0                	test   %eax,%eax
   13938:	74 52                	je     1398c <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   1393a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1393d:	8d 48 38             	lea    0x38(%eax),%ecx
   13940:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   13946:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13949:	c1 e2 02             	shl    $0x2,%edx
   1394c:	01 d0                	add    %edx,%eax
   1394e:	8b 10                	mov    (%eax),%edx
   13950:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13956:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   13959:	c1 e3 02             	shl    $0x2,%ebx
   1395c:	01 d8                	add    %ebx,%eax
   1395e:	8b 00                	mov    (%eax),%eax
   13960:	51                   	push   %ecx
   13961:	52                   	push   %edx
   13962:	50                   	push   %eax
   13963:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13966:	50                   	push   %eax
   13967:	e8 fa d9 ff ff       	call   11366 <addChunk_zTXt>
   1396c:	83 c4 10             	add    $0x10,%esp
   1396f:	89 c2                	mov    %eax,%edx
   13971:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13974:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   1397a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1397d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13983:	85 c0                	test   %eax,%eax
   13985:	74 52                	je     139d9 <lodepng_encode+0xa71>
   13987:	e9 f5 02 00 00       	jmp    13c81 <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   1398c:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   13992:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13995:	c1 e2 02             	shl    $0x2,%edx
   13998:	01 d0                	add    %edx,%eax
   1399a:	8b 10                	mov    (%eax),%edx
   1399c:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   139a2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   139a5:	c1 e1 02             	shl    $0x2,%ecx
   139a8:	01 c8                	add    %ecx,%eax
   139aa:	8b 00                	mov    (%eax),%eax
   139ac:	83 ec 04             	sub    $0x4,%esp
   139af:	52                   	push   %edx
   139b0:	50                   	push   %eax
   139b1:	8d 45 b0             	lea    -0x50(%ebp),%eax
   139b4:	50                   	push   %eax
   139b5:	e8 ec d8 ff ff       	call   112a6 <addChunk_tEXt>
   139ba:	83 c4 10             	add    $0x10,%esp
   139bd:	89 c2                	mov    %eax,%edx
   139bf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   139c2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   139c8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   139cb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   139d1:	85 c0                	test   %eax,%eax
   139d3:	0f 85 9e 02 00 00    	jne    13c77 <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   139d9:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   139dd:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   139e3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   139e6:	0f 85 df fe ff ff    	jne    138cb <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   139ec:	8b 45 1c             	mov    0x1c(%ebp),%eax
   139ef:	8b 40 70             	mov    0x70(%eax),%eax
   139f2:	85 c0                	test   %eax,%eax
   139f4:	0f 84 e3 00 00 00    	je     13add <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   139fa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   13a01:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13a08:	e9 85 00 00 00       	jmp    13a92 <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   13a0d:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13a13:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13a16:	c1 e2 02             	shl    $0x2,%edx
   13a19:	01 d0                	add    %edx,%eax
   13a1b:	8b 00                	mov    (%eax),%eax
   13a1d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13a20:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13a23:	0f b6 00             	movzbl (%eax),%eax
   13a26:	3c 4c                	cmp    $0x4c,%al
   13a28:	75 64                	jne    13a8e <lodepng_encode+0xb26>
   13a2a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13a2d:	83 c0 01             	add    $0x1,%eax
   13a30:	0f b6 00             	movzbl (%eax),%eax
   13a33:	3c 6f                	cmp    $0x6f,%al
   13a35:	75 57                	jne    13a8e <lodepng_encode+0xb26>
   13a37:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13a3a:	83 c0 02             	add    $0x2,%eax
   13a3d:	0f b6 00             	movzbl (%eax),%eax
   13a40:	3c 64                	cmp    $0x64,%al
   13a42:	75 4a                	jne    13a8e <lodepng_encode+0xb26>
   13a44:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13a47:	83 c0 03             	add    $0x3,%eax
   13a4a:	0f b6 00             	movzbl (%eax),%eax
   13a4d:	3c 65                	cmp    $0x65,%al
   13a4f:	75 3d                	jne    13a8e <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13a51:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13a54:	83 c0 04             	add    $0x4,%eax
   13a57:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13a5a:	3c 50                	cmp    $0x50,%al
   13a5c:	75 30                	jne    13a8e <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13a5e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13a61:	83 c0 05             	add    $0x5,%eax
   13a64:	0f b6 00             	movzbl (%eax),%eax
   13a67:	3c 4e                	cmp    $0x4e,%al
   13a69:	75 23                	jne    13a8e <lodepng_encode+0xb26>
   13a6b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13a6e:	83 c0 06             	add    $0x6,%eax
   13a71:	0f b6 00             	movzbl (%eax),%eax
   13a74:	3c 47                	cmp    $0x47,%al
   13a76:	75 16                	jne    13a8e <lodepng_encode+0xb26>
   13a78:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13a7b:	83 c0 07             	add    $0x7,%eax
   13a7e:	0f b6 00             	movzbl (%eax),%eax
   13a81:	84 c0                	test   %al,%al
   13a83:	75 09                	jne    13a8e <lodepng_encode+0xb26>
          already_added_id_text = 1;
   13a85:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   13a8c:	eb 13                	jmp    13aa1 <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   13a8e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13a92:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   13a98:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13a9b:	0f 85 6c ff ff ff    	jne    13a0d <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   13aa1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   13aa5:	75 36                	jne    13add <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   13aa7:	a1 80 e8 01 00       	mov    0x1e880,%eax
   13aac:	83 ec 04             	sub    $0x4,%esp
   13aaf:	50                   	push   %eax
   13ab0:	68 04 a8 01 00       	push   $0x1a804
   13ab5:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13ab8:	50                   	push   %eax
   13ab9:	e8 e8 d7 ff ff       	call   112a6 <addChunk_tEXt>
   13abe:	83 c4 10             	add    $0x10,%esp
   13ac1:	89 c2                	mov    %eax,%edx
   13ac3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13ac6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13acc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13acf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13ad5:	85 c0                	test   %eax,%eax
   13ad7:	0f 85 9d 01 00 00    	jne    13c7a <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13add:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13ae4:	e9 e6 00 00 00       	jmp    13bcf <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   13ae9:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13aef:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13af2:	c1 e2 02             	shl    $0x2,%edx
   13af5:	01 d0                	add    %edx,%eax
   13af7:	8b 00                	mov    (%eax),%eax
   13af9:	83 ec 0c             	sub    $0xc,%esp
   13afc:	50                   	push   %eax
   13afd:	e8 d7 ff fe ff       	call   3ad9 <lodepng_strlen>
   13b02:	83 c4 10             	add    $0x10,%esp
   13b05:	83 f8 4f             	cmp    $0x4f,%eax
   13b08:	7e 12                	jle    13b1c <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   13b0a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b0d:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   13b14:	00 00 00 
        goto cleanup;
   13b17:	e9 65 01 00 00       	jmp    13c81 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   13b1c:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13b22:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13b25:	c1 e2 02             	shl    $0x2,%edx
   13b28:	01 d0                	add    %edx,%eax
   13b2a:	8b 00                	mov    (%eax),%eax
   13b2c:	83 ec 0c             	sub    $0xc,%esp
   13b2f:	50                   	push   %eax
   13b30:	e8 a4 ff fe ff       	call   3ad9 <lodepng_strlen>
   13b35:	83 c4 10             	add    $0x10,%esp
   13b38:	85 c0                	test   %eax,%eax
   13b3a:	7f 12                	jg     13b4e <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   13b3c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b3f:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   13b46:	00 00 00 
        goto cleanup;
   13b49:	e9 33 01 00 00       	jmp    13c81 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   13b4e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b51:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13b54:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   13b5a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13b5d:	c1 e2 02             	shl    $0x2,%edx
   13b60:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13b62:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13b64:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   13b6a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13b6d:	c1 e2 02             	shl    $0x2,%edx
   13b70:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13b72:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13b74:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   13b7a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13b7d:	c1 e2 02             	shl    $0x2,%edx
   13b80:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13b82:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13b84:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13b8a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13b8d:	c1 e2 02             	shl    $0x2,%edx
   13b90:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13b92:	8b 10                	mov    (%eax),%edx
   13b94:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b97:	8b 40 74             	mov    0x74(%eax),%eax
   13b9a:	83 ec 04             	sub    $0x4,%esp
   13b9d:	57                   	push   %edi
   13b9e:	56                   	push   %esi
   13b9f:	53                   	push   %ebx
   13ba0:	51                   	push   %ecx
   13ba1:	52                   	push   %edx
   13ba2:	50                   	push   %eax
   13ba3:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13ba6:	50                   	push   %eax
   13ba7:	e8 dc d8 ff ff       	call   11488 <addChunk_iTXt>
   13bac:	83 c4 20             	add    $0x20,%esp
   13baf:	89 c2                	mov    %eax,%edx
   13bb1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13bb4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13bba:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13bbd:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13bc3:	85 c0                	test   %eax,%eax
   13bc5:	0f 85 b2 00 00 00    	jne    13c7d <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13bcb:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13bcf:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   13bd5:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13bd8:	0f 85 0b ff ff ff    	jne    13ae9 <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   13bde:	8b 45 a0             	mov    -0x60(%ebp),%eax
   13be1:	85 c0                	test   %eax,%eax
   13be3:	74 2f                	je     13c14 <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   13be5:	8b 55 ac             	mov    -0x54(%ebp),%edx
   13be8:	8b 45 a0             	mov    -0x60(%ebp),%eax
   13beb:	83 ec 04             	sub    $0x4,%esp
   13bee:	52                   	push   %edx
   13bef:	50                   	push   %eax
   13bf0:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13bf3:	50                   	push   %eax
   13bf4:	e8 60 f2 ff ff       	call   12e59 <addUnknownChunks>
   13bf9:	83 c4 10             	add    $0x10,%esp
   13bfc:	89 c2                	mov    %eax,%edx
   13bfe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13c01:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13c07:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13c0a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13c10:	85 c0                	test   %eax,%eax
   13c12:	75 6c                	jne    13c80 <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   13c14:	83 ec 0c             	sub    $0xc,%esp
   13c17:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13c1a:	50                   	push   %eax
   13c1b:	e8 6d d6 ff ff       	call   1128d <addChunk_IEND>
   13c20:	83 c4 10             	add    $0x10,%esp
   13c23:	89 c2                	mov    %eax,%edx
   13c25:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13c28:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13c2e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13c31:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13c37:	85 c0                	test   %eax,%eax
   13c39:	eb 46                	jmp    13c81 <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13c3b:	90                   	nop
   13c3c:	eb 43                	jmp    13c81 <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13c3e:	90                   	nop
   13c3f:	eb 40                	jmp    13c81 <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   13c41:	90                   	nop
   13c42:	eb 3d                	jmp    13c81 <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   13c44:	90                   	nop
   13c45:	eb 3a                	jmp    13c81 <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   13c47:	90                   	nop
   13c48:	eb 37                	jmp    13c81 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   13c4a:	90                   	nop
   13c4b:	eb 34                	jmp    13c81 <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   13c4d:	90                   	nop
   13c4e:	eb 31                	jmp    13c81 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   13c50:	90                   	nop
   13c51:	eb 2e                	jmp    13c81 <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13c53:	90                   	nop
   13c54:	eb 2b                	jmp    13c81 <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   13c56:	90                   	nop
   13c57:	eb 28                	jmp    13c81 <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   13c59:	90                   	nop
   13c5a:	eb 25                	jmp    13c81 <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   13c5c:	90                   	nop
   13c5d:	eb 22                	jmp    13c81 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13c5f:	90                   	nop
   13c60:	eb 1f                	jmp    13c81 <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13c62:	90                   	nop
   13c63:	eb 1c                	jmp    13c81 <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   13c65:	90                   	nop
   13c66:	eb 19                	jmp    13c81 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   13c68:	90                   	nop
   13c69:	eb 16                	jmp    13c81 <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   13c6b:	90                   	nop
   13c6c:	eb 13                	jmp    13c81 <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   13c6e:	90                   	nop
   13c6f:	eb 10                	jmp    13c81 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   13c71:	90                   	nop
   13c72:	eb 0d                	jmp    13c81 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   13c74:	90                   	nop
   13c75:	eb 0a                	jmp    13c81 <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   13c77:	90                   	nop
   13c78:	eb 07                	jmp    13c81 <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   13c7a:	90                   	nop
   13c7b:	eb 04                	jmp    13c81 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13c7d:	90                   	nop
   13c7e:	eb 01                	jmp    13c81 <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   13c80:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   13c81:	83 ec 0c             	sub    $0xc,%esp
   13c84:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13c8a:	50                   	push   %eax
   13c8b:	e8 34 65 ff ff       	call   a1c4 <lodepng_info_cleanup>
   13c90:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   13c93:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13c96:	83 ec 0c             	sub    $0xc,%esp
   13c99:	50                   	push   %eax
   13c9a:	e8 bf fd fe ff       	call   3a5e <lodepng_free>
   13c9f:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   13ca2:	8b 55 b0             	mov    -0x50(%ebp),%edx
   13ca5:	8b 45 08             	mov    0x8(%ebp),%eax
   13ca8:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   13caa:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   13cad:	8b 45 0c             	mov    0xc(%ebp),%eax
   13cb0:	89 10                	mov    %edx,(%eax)

  return state->error;
   13cb2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13cb5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   13cbb:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13cbe:	5b                   	pop    %ebx
   13cbf:	5e                   	pop    %esi
   13cc0:	5f                   	pop    %edi
   13cc1:	5d                   	pop    %ebp
   13cc2:	c3                   	ret    

00013cc3 <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   13cc3:	55                   	push   %ebp
   13cc4:	89 e5                	mov    %esp,%ebp
   13cc6:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   13ccc:	83 ec 0c             	sub    $0xc,%esp
   13ccf:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13cd5:	50                   	push   %eax
   13cd6:	e8 38 d0 ff ff       	call   10d13 <lodepng_state_init>
   13cdb:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   13cde:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13ce1:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   13ce7:	8b 45 20             	mov    0x20(%ebp),%eax
   13cea:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   13cf0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13cf3:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   13cf9:	8b 45 20             	mov    0x20(%ebp),%eax
   13cfc:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   13d02:	83 ec 08             	sub    $0x8,%esp
   13d05:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13d0b:	50                   	push   %eax
   13d0c:	ff 75 18             	pushl  0x18(%ebp)
   13d0f:	ff 75 14             	pushl  0x14(%ebp)
   13d12:	ff 75 10             	pushl  0x10(%ebp)
   13d15:	ff 75 0c             	pushl  0xc(%ebp)
   13d18:	ff 75 08             	pushl  0x8(%ebp)
   13d1b:	e8 48 f2 ff ff       	call   12f68 <lodepng_encode>
   13d20:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   13d23:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13d26:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   13d29:	83 ec 0c             	sub    $0xc,%esp
   13d2c:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13d32:	50                   	push   %eax
   13d33:	e8 35 d0 ff ff       	call   10d6d <lodepng_state_cleanup>
   13d38:	83 c4 10             	add    $0x10,%esp
  return error;
   13d3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13d3e:	c9                   	leave  
   13d3f:	c3                   	ret    

00013d40 <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13d40:	55                   	push   %ebp
   13d41:	89 e5                	mov    %esp,%ebp
   13d43:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   13d46:	83 ec 04             	sub    $0x4,%esp
   13d49:	6a 08                	push   $0x8
   13d4b:	6a 06                	push   $0x6
   13d4d:	ff 75 18             	pushl  0x18(%ebp)
   13d50:	ff 75 14             	pushl  0x14(%ebp)
   13d53:	ff 75 10             	pushl  0x10(%ebp)
   13d56:	ff 75 0c             	pushl  0xc(%ebp)
   13d59:	ff 75 08             	pushl  0x8(%ebp)
   13d5c:	e8 62 ff ff ff       	call   13cc3 <lodepng_encode_memory>
   13d61:	83 c4 20             	add    $0x20,%esp
}
   13d64:	c9                   	leave  
   13d65:	c3                   	ret    

00013d66 <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13d66:	55                   	push   %ebp
   13d67:	89 e5                	mov    %esp,%ebp
   13d69:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   13d6c:	83 ec 04             	sub    $0x4,%esp
   13d6f:	6a 08                	push   $0x8
   13d71:	6a 02                	push   $0x2
   13d73:	ff 75 18             	pushl  0x18(%ebp)
   13d76:	ff 75 14             	pushl  0x14(%ebp)
   13d79:	ff 75 10             	pushl  0x10(%ebp)
   13d7c:	ff 75 0c             	pushl  0xc(%ebp)
   13d7f:	ff 75 08             	pushl  0x8(%ebp)
   13d82:	e8 3c ff ff ff       	call   13cc3 <lodepng_encode_memory>
   13d87:	83 c4 20             	add    $0x20,%esp
}
   13d8a:	c9                   	leave  
   13d8b:	c3                   	ret    

00013d8c <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   13d8c:	55                   	push   %ebp
   13d8d:	89 e5                	mov    %esp,%ebp
   13d8f:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   13d92:	83 ec 04             	sub    $0x4,%esp
   13d95:	ff 75 1c             	pushl  0x1c(%ebp)
   13d98:	ff 75 18             	pushl  0x18(%ebp)
   13d9b:	ff 75 14             	pushl  0x14(%ebp)
   13d9e:	ff 75 10             	pushl  0x10(%ebp)
   13da1:	ff 75 0c             	pushl  0xc(%ebp)
   13da4:	8d 45 ec             	lea    -0x14(%ebp),%eax
   13da7:	50                   	push   %eax
   13da8:	8d 45 f0             	lea    -0x10(%ebp),%eax
   13dab:	50                   	push   %eax
   13dac:	e8 12 ff ff ff       	call   13cc3 <lodepng_encode_memory>
   13db1:	83 c4 20             	add    $0x20,%esp
   13db4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   13db7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13dbb:	75 19                	jne    13dd6 <lodepng_encode_file+0x4a>
   13dbd:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13dc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13dc3:	83 ec 04             	sub    $0x4,%esp
   13dc6:	ff 75 08             	pushl  0x8(%ebp)
   13dc9:	52                   	push   %edx
   13dca:	50                   	push   %eax
   13dcb:	e8 36 01 ff ff       	call   3f06 <lodepng_save_file>
   13dd0:	83 c4 10             	add    $0x10,%esp
   13dd3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   13dd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13dd9:	83 ec 0c             	sub    $0xc,%esp
   13ddc:	50                   	push   %eax
   13ddd:	e8 7c fc fe ff       	call   3a5e <lodepng_free>
   13de2:	83 c4 10             	add    $0x10,%esp
  return error;
   13de5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13de8:	c9                   	leave  
   13de9:	c3                   	ret    

00013dea <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   13dea:	55                   	push   %ebp
   13deb:	89 e5                	mov    %esp,%ebp
   13ded:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   13df0:	83 ec 08             	sub    $0x8,%esp
   13df3:	6a 08                	push   $0x8
   13df5:	6a 06                	push   $0x6
   13df7:	ff 75 14             	pushl  0x14(%ebp)
   13dfa:	ff 75 10             	pushl  0x10(%ebp)
   13dfd:	ff 75 0c             	pushl  0xc(%ebp)
   13e00:	ff 75 08             	pushl  0x8(%ebp)
   13e03:	e8 84 ff ff ff       	call   13d8c <lodepng_encode_file>
   13e08:	83 c4 20             	add    $0x20,%esp
}
   13e0b:	c9                   	leave  
   13e0c:	c3                   	ret    

00013e0d <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   13e0d:	55                   	push   %ebp
   13e0e:	89 e5                	mov    %esp,%ebp
   13e10:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   13e13:	83 ec 08             	sub    $0x8,%esp
   13e16:	6a 08                	push   $0x8
   13e18:	6a 02                	push   $0x2
   13e1a:	ff 75 14             	pushl  0x14(%ebp)
   13e1d:	ff 75 10             	pushl  0x10(%ebp)
   13e20:	ff 75 0c             	pushl  0xc(%ebp)
   13e23:	ff 75 08             	pushl  0x8(%ebp)
   13e26:	e8 61 ff ff ff       	call   13d8c <lodepng_encode_file>
   13e2b:	83 c4 20             	add    $0x20,%esp
}
   13e2e:	c9                   	leave  
   13e2f:	c3                   	ret    

00013e30 <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   13e30:	55                   	push   %ebp
   13e31:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   13e33:	8b 45 08             	mov    0x8(%ebp),%eax
   13e36:	50                   	push   %eax
   13e37:	e8 71 49 ff ff       	call   87ad <lodepng_compress_settings_init>
   13e3c:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   13e3f:	8b 45 08             	mov    0x8(%ebp),%eax
   13e42:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   13e49:	8b 45 08             	mov    0x8(%ebp),%eax
   13e4c:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   13e53:	8b 45 08             	mov    0x8(%ebp),%eax
   13e56:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   13e5d:	8b 45 08             	mov    0x8(%ebp),%eax
   13e60:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   13e67:	8b 45 08             	mov    0x8(%ebp),%eax
   13e6a:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   13e71:	8b 45 08             	mov    0x8(%ebp),%eax
   13e74:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   13e7b:	8b 45 08             	mov    0x8(%ebp),%eax
   13e7e:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   13e85:	90                   	nop
   13e86:	c9                   	leave  
   13e87:	c3                   	ret    

00013e88 <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   13e88:	55                   	push   %ebp
   13e89:	89 e5                	mov    %esp,%ebp
  switch(code) {
   13e8b:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   13e8f:	0f 87 c1 03 00 00    	ja     14256 <lodepng_error_text+0x3ce>
   13e95:	8b 45 08             	mov    0x8(%ebp),%eax
   13e98:	c1 e0 02             	shl    $0x2,%eax
   13e9b:	05 40 bb 01 00       	add    $0x1bb40,%eax
   13ea0:	8b 00                	mov    (%eax),%eax
   13ea2:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   13ea4:	b8 0c a8 01 00       	mov    $0x1a80c,%eax
   13ea9:	e9 ad 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   13eae:	b8 29 a8 01 00       	mov    $0x1a829,%eax
   13eb3:	e9 a3 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   13eb8:	b8 3c a8 01 00       	mov    $0x1a83c,%eax
   13ebd:	e9 99 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   13ec2:	b8 74 a8 01 00       	mov    $0x1a874,%eax
   13ec7:	e9 8f 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   13ecc:	b8 ac a8 01 00       	mov    $0x1a8ac,%eax
   13ed1:	e9 85 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   13ed6:	b8 ac a8 01 00       	mov    $0x1a8ac,%eax
   13edb:	e9 7b 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   13ee0:	b8 ac a8 01 00       	mov    $0x1a8ac,%eax
   13ee5:	e9 71 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   13eea:	b8 dc a8 01 00       	mov    $0x1a8dc,%eax
   13eef:	e9 67 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   13ef4:	b8 10 a9 01 00       	mov    $0x1a910,%eax
   13ef9:	e9 5d 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   13efe:	b8 44 a9 01 00       	mov    $0x1a944,%eax
   13f03:	e9 53 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   13f08:	b8 10 a9 01 00       	mov    $0x1a910,%eax
   13f0d:	e9 49 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   13f12:	b8 6c a9 01 00       	mov    $0x1a96c,%eax
   13f17:	e9 3f 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   13f1c:	b8 a4 a9 01 00       	mov    $0x1a9a4,%eax
   13f21:	e9 35 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   13f26:	b8 10 a9 01 00       	mov    $0x1a910,%eax
   13f2b:	e9 2b 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   13f30:	b8 dc a9 01 00       	mov    $0x1a9dc,%eax
   13f35:	e9 21 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   13f3a:	b8 0c aa 01 00       	mov    $0x1aa0c,%eax
   13f3f:	e9 17 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   13f44:	b8 2c aa 01 00       	mov    $0x1aa2c,%eax
   13f49:	e9 0d 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   13f4e:	b8 58 aa 01 00       	mov    $0x1aa58,%eax
   13f53:	e9 03 03 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   13f58:	b8 98 aa 01 00       	mov    $0x1aa98,%eax
   13f5d:	e9 f9 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   13f62:	b8 c0 aa 01 00       	mov    $0x1aac0,%eax
   13f67:	e9 ef 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   13f6c:	b8 f4 aa 01 00       	mov    $0x1aaf4,%eax
   13f71:	e9 e5 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   13f76:	b8 18 ab 01 00       	mov    $0x1ab18,%eax
   13f7b:	e9 db 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   13f80:	b8 50 ab 01 00       	mov    $0x1ab50,%eax
   13f85:	e9 d1 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   13f8a:	b8 70 ab 01 00       	mov    $0x1ab70,%eax
   13f8f:	e9 c7 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   13f94:	b8 8f ab 01 00       	mov    $0x1ab8f,%eax
   13f99:	e9 bd 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   13f9e:	b8 a9 ab 01 00       	mov    $0x1aba9,%eax
   13fa3:	e9 b3 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   13fa8:	b8 c8 ab 01 00       	mov    $0x1abc8,%eax
   13fad:	e9 a9 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   13fb2:	b8 04 ac 01 00       	mov    $0x1ac04,%eax
   13fb7:	e9 9f 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   13fbc:	b8 28 ac 01 00       	mov    $0x1ac28,%eax
   13fc1:	e9 95 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   13fc6:	b8 54 ac 01 00       	mov    $0x1ac54,%eax
   13fcb:	e9 8b 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   13fd0:	b8 78 ac 01 00       	mov    $0x1ac78,%eax
   13fd5:	e9 81 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   13fda:	b8 b8 ac 01 00       	mov    $0x1acb8,%eax
   13fdf:	e9 77 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   13fe4:	b8 e8 ac 01 00       	mov    $0x1ace8,%eax
   13fe9:	e9 6d 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   13fee:	b8 10 ad 01 00       	mov    $0x1ad10,%eax
   13ff3:	e9 63 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   13ff8:	b8 54 ad 01 00       	mov    $0x1ad54,%eax
   13ffd:	e9 59 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   14002:	b8 80 ad 01 00       	mov    $0x1ad80,%eax
   14007:	e9 4f 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   1400c:	b8 b0 ad 01 00       	mov    $0x1adb0,%eax
   14011:	e9 45 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   14016:	b8 d8 ad 01 00       	mov    $0x1add8,%eax
   1401b:	e9 3b 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   14020:	b8 20 ae 01 00       	mov    $0x1ae20,%eax
   14025:	e9 31 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   1402a:	b8 20 ae 01 00       	mov    $0x1ae20,%eax
   1402f:	e9 27 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   14034:	b8 5c ae 01 00       	mov    $0x1ae5c,%eax
   14039:	e9 1d 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   1403e:	b8 90 ae 01 00       	mov    $0x1ae90,%eax
   14043:	e9 13 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   14048:	b8 b3 ae 01 00       	mov    $0x1aeb3,%eax
   1404d:	e9 09 02 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   14052:	b8 d0 ae 01 00       	mov    $0x1aed0,%eax
   14057:	e9 ff 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   1405c:	b8 0c af 01 00       	mov    $0x1af0c,%eax
   14061:	e9 f5 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   14066:	b8 3c af 01 00       	mov    $0x1af3c,%eax
   1406b:	e9 eb 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   14070:	b8 88 af 01 00       	mov    $0x1af88,%eax
   14075:	e9 e1 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   1407a:	b8 c0 af 01 00       	mov    $0x1afc0,%eax
   1407f:	e9 d7 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   14084:	b8 00 b0 01 00       	mov    $0x1b000,%eax
   14089:	e9 cd 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   1408e:	b8 2c b0 01 00       	mov    $0x1b02c,%eax
   14093:	e9 c3 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   14098:	b8 78 b0 01 00       	mov    $0x1b078,%eax
   1409d:	e9 b9 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   140a2:	b8 cc b0 01 00       	mov    $0x1b0cc,%eax
   140a7:	e9 af 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   140ac:	b8 00 b1 01 00       	mov    $0x1b100,%eax
   140b1:	e9 a5 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   140b6:	b8 50 b1 01 00       	mov    $0x1b150,%eax
   140bb:	e9 9b 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   140c0:	b8 8c b1 01 00       	mov    $0x1b18c,%eax
   140c5:	e9 91 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   140ca:	b8 ec b1 01 00       	mov    $0x1b1ec,%eax
   140cf:	e9 87 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   140d4:	b8 4c b2 01 00       	mov    $0x1b24c,%eax
   140d9:	e9 7d 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   140de:	b8 a8 b2 01 00       	mov    $0x1b2a8,%eax
   140e3:	e9 73 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   140e8:	b8 ec b2 01 00       	mov    $0x1b2ec,%eax
   140ed:	e9 69 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   140f2:	b8 28 b3 01 00       	mov    $0x1b328,%eax
   140f7:	e9 5f 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   140fc:	b8 85 b3 01 00       	mov    $0x1b385,%eax
   14101:	e9 55 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   14106:	b8 9d b3 01 00       	mov    $0x1b39d,%eax
   1410b:	e9 4b 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   14110:	b8 b8 b3 01 00       	mov    $0x1b3b8,%eax
   14115:	e9 41 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   1411a:	b8 f4 b3 01 00       	mov    $0x1b3f4,%eax
   1411f:	e9 37 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   14124:	b8 24 b4 01 00       	mov    $0x1b424,%eax
   14129:	e9 2d 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   1412e:	b8 44 b4 01 00       	mov    $0x1b444,%eax
   14133:	e9 23 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   14138:	b8 64 b4 01 00       	mov    $0x1b464,%eax
   1413d:	e9 19 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   14142:	b8 84 b4 01 00       	mov    $0x1b484,%eax
   14147:	e9 0f 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   1414c:	b8 a8 b4 01 00       	mov    $0x1b4a8,%eax
   14151:	e9 05 01 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   14156:	b8 d0 b4 01 00       	mov    $0x1b4d0,%eax
   1415b:	e9 fb 00 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   14160:	b8 2d b5 01 00       	mov    $0x1b52d,%eax
   14165:	e9 f1 00 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   1416a:	b8 48 b5 01 00       	mov    $0x1b548,%eax
   1416f:	e9 e7 00 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   14174:	b8 84 b5 01 00       	mov    $0x1b584,%eax
   14179:	e9 dd 00 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   1417e:	b8 b8 b5 01 00       	mov    $0x1b5b8,%eax
   14183:	e9 d3 00 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   14188:	b8 0c b6 01 00       	mov    $0x1b60c,%eax
   1418d:	e9 c9 00 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   14192:	b8 58 b6 01 00       	mov    $0x1b658,%eax
   14197:	e9 bf 00 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   1419c:	b8 94 b6 01 00       	mov    $0x1b694,%eax
   141a1:	e9 b5 00 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   141a6:	b8 b8 b6 01 00       	mov    $0x1b6b8,%eax
   141ab:	e9 ab 00 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   141b0:	b8 d8 b6 01 00       	mov    $0x1b6d8,%eax
   141b5:	e9 a1 00 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   141ba:	b8 00 b7 01 00       	mov    $0x1b700,%eax
   141bf:	e9 97 00 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   141c4:	b8 20 b7 01 00       	mov    $0x1b720,%eax
   141c9:	e9 8d 00 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   141ce:	b8 4c b7 01 00       	mov    $0x1b74c,%eax
   141d3:	e9 83 00 00 00       	jmp    1425b <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   141d8:	b8 7b b7 01 00       	mov    $0x1b77b,%eax
   141dd:	eb 7c                	jmp    1425b <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   141df:	b8 93 b7 01 00       	mov    $0x1b793,%eax
   141e4:	eb 75                	jmp    1425b <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   141e6:	b8 ab b7 01 00       	mov    $0x1b7ab,%eax
   141eb:	eb 6e                	jmp    1425b <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   141ed:	b8 c3 b7 01 00       	mov    $0x1b7c3,%eax
   141f2:	eb 67                	jmp    1425b <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   141f4:	b8 e4 b7 01 00       	mov    $0x1b7e4,%eax
   141f9:	eb 60                	jmp    1425b <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   141fb:	b8 34 b8 01 00       	mov    $0x1b834,%eax
   14200:	eb 59                	jmp    1425b <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   14202:	b8 88 b8 01 00       	mov    $0x1b888,%eax
   14207:	eb 52                	jmp    1425b <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   14209:	b8 dc b8 01 00       	mov    $0x1b8dc,%eax
   1420e:	eb 4b                	jmp    1425b <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   14210:	b8 24 b9 01 00       	mov    $0x1b924,%eax
   14215:	eb 44                	jmp    1425b <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   14217:	b8 68 b9 01 00       	mov    $0x1b968,%eax
   1421c:	eb 3d                	jmp    1425b <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   1421e:	b8 84 b9 01 00       	mov    $0x1b984,%eax
   14223:	eb 36                	jmp    1425b <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   14225:	b8 bc b9 01 00       	mov    $0x1b9bc,%eax
   1422a:	eb 2f                	jmp    1425b <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   1422c:	b8 10 ba 01 00       	mov    $0x1ba10,%eax
   14231:	eb 28                	jmp    1425b <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   14233:	b8 40 ba 01 00       	mov    $0x1ba40,%eax
   14238:	eb 21                	jmp    1425b <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   1423a:	b8 90 ba 01 00       	mov    $0x1ba90,%eax
   1423f:	eb 1a                	jmp    1425b <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   14241:	b8 bc ba 01 00       	mov    $0x1babc,%eax
   14246:	eb 13                	jmp    1425b <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   14248:	b8 e8 ba 01 00       	mov    $0x1bae8,%eax
   1424d:	eb 0c                	jmp    1425b <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   1424f:	b8 0c bb 01 00       	mov    $0x1bb0c,%eax
   14254:	eb 05                	jmp    1425b <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   14256:	b8 2b bb 01 00       	mov    $0x1bb2b,%eax
}
   1425b:	5d                   	pop    %ebp
   1425c:	c3                   	ret    

0001425d <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   1425d:	55                   	push   %ebp
   1425e:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   14260:	8b 45 08             	mov    0x8(%ebp),%eax
   14263:	8b 40 28             	mov    0x28(%eax),%eax
   14266:	83 f8 01             	cmp    $0x1,%eax
   14269:	75 08                	jne    14273 <GetImage+0x16>
   1426b:	8b 45 08             	mov    0x8(%ebp),%eax
   1426e:	8b 40 54             	mov    0x54(%eax),%eax
   14271:	eb 09                	jmp    1427c <GetImage+0x1f>
   14273:	8b 45 08             	mov    0x8(%ebp),%eax
   14276:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   1427c:	5d                   	pop    %ebp
   1427d:	c3                   	ret    

0001427e <GetWidth>:

int GetWidth(Context* ctx){
   1427e:	55                   	push   %ebp
   1427f:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   14281:	8b 45 08             	mov    0x8(%ebp),%eax
   14284:	8b 40 10             	mov    0x10(%eax),%eax
}
   14287:	5d                   	pop    %ebp
   14288:	c3                   	ret    

00014289 <GetHeight>:

int GetHeight(Context* ctx){
   14289:	55                   	push   %ebp
   1428a:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   1428c:	8b 45 08             	mov    0x8(%ebp),%eax
   1428f:	8b 40 14             	mov    0x14(%eax),%eax
}
   14292:	5d                   	pop    %ebp
   14293:	c3                   	ret    

00014294 <GetImageSize>:

uint GetImageSize(Context* ctx){
   14294:	55                   	push   %ebp
   14295:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   14297:	8b 45 08             	mov    0x8(%ebp),%eax
   1429a:	8b 50 10             	mov    0x10(%eax),%edx
   1429d:	8b 45 08             	mov    0x8(%ebp),%eax
   142a0:	8b 40 14             	mov    0x14(%eax),%eax
   142a3:	0f af d0             	imul   %eax,%edx
   142a6:	8b 45 08             	mov    0x8(%ebp),%eax
   142a9:	8b 40 28             	mov    0x28(%eax),%eax
   142ac:	0f af c2             	imul   %edx,%eax
}
   142af:	5d                   	pop    %ebp
   142b0:	c3                   	ret    

000142b1 <_Clip>:

uchar _Clip(const int x){
   142b1:	55                   	push   %ebp
   142b2:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   142b4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   142b8:	78 15                	js     142cf <_Clip+0x1e>
   142ba:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   142c1:	7f 05                	jg     142c8 <_Clip+0x17>
   142c3:	8b 45 08             	mov    0x8(%ebp),%eax
   142c6:	eb 0c                	jmp    142d4 <_Clip+0x23>
   142c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   142cd:	eb 05                	jmp    142d4 <_Clip+0x23>
   142cf:	b8 00 00 00 00       	mov    $0x0,%eax
}
   142d4:	5d                   	pop    %ebp
   142d5:	c3                   	ret    

000142d6 <_Skip>:

void _Skip(Context* ctx, int c){
   142d6:	55                   	push   %ebp
   142d7:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   142d9:	8b 45 08             	mov    0x8(%ebp),%eax
   142dc:	8b 50 04             	mov    0x4(%eax),%edx
   142df:	8b 45 0c             	mov    0xc(%ebp),%eax
   142e2:	01 c2                	add    %eax,%edx
   142e4:	8b 45 08             	mov    0x8(%ebp),%eax
   142e7:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   142ea:	8b 45 08             	mov    0x8(%ebp),%eax
   142ed:	8b 40 08             	mov    0x8(%eax),%eax
   142f0:	2b 45 0c             	sub    0xc(%ebp),%eax
   142f3:	89 c2                	mov    %eax,%edx
   142f5:	8b 45 08             	mov    0x8(%ebp),%eax
   142f8:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   142fb:	8b 45 08             	mov    0x8(%ebp),%eax
   142fe:	8b 40 0c             	mov    0xc(%eax),%eax
   14301:	2b 45 0c             	sub    0xc(%ebp),%eax
   14304:	89 c2                	mov    %eax,%edx
   14306:	8b 45 08             	mov    0x8(%ebp),%eax
   14309:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   1430c:	8b 45 08             	mov    0x8(%ebp),%eax
   1430f:	8b 40 08             	mov    0x8(%eax),%eax
   14312:	85 c0                	test   %eax,%eax
   14314:	79 09                	jns    1431f <_Skip+0x49>
   14316:	8b 45 08             	mov    0x8(%ebp),%eax
   14319:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   1431f:	90                   	nop
   14320:	5d                   	pop    %ebp
   14321:	c3                   	ret    

00014322 <_DecodeLength>:

void _DecodeLength(Context* ctx){
   14322:	55                   	push   %ebp
   14323:	89 e5                	mov    %esp,%ebp
   14325:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   14328:	8b 45 08             	mov    0x8(%ebp),%eax
   1432b:	8b 40 08             	mov    0x8(%eax),%eax
   1432e:	83 f8 01             	cmp    $0x1,%eax
   14331:	7f 0b                	jg     1433e <_DecodeLength+0x1c>
   14333:	8b 45 08             	mov    0x8(%ebp),%eax
   14336:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1433c:	eb 45                	jmp    14383 <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   1433e:	8b 45 08             	mov    0x8(%ebp),%eax
   14341:	8b 40 04             	mov    0x4(%eax),%eax
   14344:	83 ec 0c             	sub    $0xc,%esp
   14347:	50                   	push   %eax
   14348:	e8 38 00 00 00       	call   14385 <_Decode2Bytes>
   1434d:	83 c4 10             	add    $0x10,%esp
   14350:	89 c2                	mov    %eax,%edx
   14352:	8b 45 08             	mov    0x8(%ebp),%eax
   14355:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   14358:	8b 45 08             	mov    0x8(%ebp),%eax
   1435b:	8b 50 0c             	mov    0xc(%eax),%edx
   1435e:	8b 45 08             	mov    0x8(%ebp),%eax
   14361:	8b 40 08             	mov    0x8(%eax),%eax
   14364:	39 c2                	cmp    %eax,%edx
   14366:	7e 0b                	jle    14373 <_DecodeLength+0x51>
   14368:	8b 45 08             	mov    0x8(%ebp),%eax
   1436b:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14371:	eb 10                	jmp    14383 <_DecodeLength+0x61>
    _Skip(ctx, 2);
   14373:	83 ec 08             	sub    $0x8,%esp
   14376:	6a 02                	push   $0x2
   14378:	ff 75 08             	pushl  0x8(%ebp)
   1437b:	e8 56 ff ff ff       	call   142d6 <_Skip>
   14380:	83 c4 10             	add    $0x10,%esp
}
   14383:	c9                   	leave  
   14384:	c3                   	ret    

00014385 <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   14385:	55                   	push   %ebp
   14386:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   14388:	8b 45 08             	mov    0x8(%ebp),%eax
   1438b:	0f b6 00             	movzbl (%eax),%eax
   1438e:	0f b6 c0             	movzbl %al,%eax
   14391:	c1 e0 08             	shl    $0x8,%eax
   14394:	89 c2                	mov    %eax,%edx
   14396:	8b 45 08             	mov    0x8(%ebp),%eax
   14399:	83 c0 01             	add    $0x1,%eax
   1439c:	0f b6 00             	movzbl (%eax),%eax
   1439f:	0f b6 c0             	movzbl %al,%eax
   143a2:	09 d0                	or     %edx,%eax
}
   143a4:	5d                   	pop    %ebp
   143a5:	c3                   	ret    

000143a6 <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   143a6:	55                   	push   %ebp
   143a7:	89 e5                	mov    %esp,%ebp
   143a9:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   143ac:	8b 45 08             	mov    0x8(%ebp),%eax
   143af:	8b 55 10             	mov    0x10(%ebp),%edx
   143b2:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   143b5:	8b 45 14             	mov    0x14(%ebp),%eax
   143b8:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   143bd:	89 c2                	mov    %eax,%edx
   143bf:	8b 45 08             	mov    0x8(%ebp),%eax
   143c2:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   143c5:	8b 45 08             	mov    0x8(%ebp),%eax
   143c8:	8b 40 08             	mov    0x8(%eax),%eax
   143cb:	83 f8 01             	cmp    $0x1,%eax
   143ce:	7e 1d                	jle    143ed <_DecodeJPEG+0x47>
   143d0:	8b 45 08             	mov    0x8(%ebp),%eax
   143d3:	8b 40 04             	mov    0x4(%eax),%eax
   143d6:	0f b6 00             	movzbl (%eax),%eax
   143d9:	3c ff                	cmp    $0xff,%al
   143db:	75 10                	jne    143ed <_DecodeJPEG+0x47>
   143dd:	8b 45 08             	mov    0x8(%ebp),%eax
   143e0:	8b 40 04             	mov    0x4(%eax),%eax
   143e3:	83 c0 01             	add    $0x1,%eax
   143e6:	0f b6 00             	movzbl (%eax),%eax
   143e9:	3c d8                	cmp    $0xd8,%al
   143eb:	74 0a                	je     143f7 <_DecodeJPEG+0x51>
   143ed:	b8 01 00 00 00       	mov    $0x1,%eax
   143f2:	e9 56 01 00 00       	jmp    1454d <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   143f7:	6a 02                	push   $0x2
   143f9:	ff 75 08             	pushl  0x8(%ebp)
   143fc:	e8 d5 fe ff ff       	call   142d6 <_Skip>
   14401:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   14404:	e9 0a 01 00 00       	jmp    14513 <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   14409:	8b 45 08             	mov    0x8(%ebp),%eax
   1440c:	8b 40 08             	mov    0x8(%eax),%eax
   1440f:	85 c0                	test   %eax,%eax
   14411:	78 0d                	js     14420 <_DecodeJPEG+0x7a>
   14413:	8b 45 08             	mov    0x8(%ebp),%eax
   14416:	8b 40 04             	mov    0x4(%eax),%eax
   14419:	0f b6 00             	movzbl (%eax),%eax
   1441c:	3c ff                	cmp    $0xff,%al
   1441e:	74 0a                	je     1442a <_DecodeJPEG+0x84>
   14420:	b8 05 00 00 00       	mov    $0x5,%eax
   14425:	e9 23 01 00 00       	jmp    1454d <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   1442a:	6a 02                	push   $0x2
   1442c:	ff 75 08             	pushl  0x8(%ebp)
   1442f:	e8 a2 fe ff ff       	call   142d6 <_Skip>
   14434:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   14437:	8b 45 08             	mov    0x8(%ebp),%eax
   1443a:	8b 40 04             	mov    0x4(%eax),%eax
   1443d:	83 e8 01             	sub    $0x1,%eax
   14440:	0f b6 00             	movzbl (%eax),%eax
   14443:	0f b6 c0             	movzbl %al,%eax
   14446:	3d da 00 00 00       	cmp    $0xda,%eax
   1444b:	74 71                	je     144be <_DecodeJPEG+0x118>
   1444d:	3d da 00 00 00       	cmp    $0xda,%eax
   14452:	7f 10                	jg     14464 <_DecodeJPEG+0xbe>
   14454:	3d c0 00 00 00       	cmp    $0xc0,%eax
   14459:	74 20                	je     1447b <_DecodeJPEG+0xd5>
   1445b:	3d c4 00 00 00       	cmp    $0xc4,%eax
   14460:	74 2c                	je     1448e <_DecodeJPEG+0xe8>
   14462:	eb 7d                	jmp    144e1 <_DecodeJPEG+0x13b>
   14464:	3d dd 00 00 00       	cmp    $0xdd,%eax
   14469:	74 43                	je     144ae <_DecodeJPEG+0x108>
   1446b:	3d fe 00 00 00       	cmp    $0xfe,%eax
   14470:	74 5f                	je     144d1 <_DecodeJPEG+0x12b>
   14472:	3d db 00 00 00       	cmp    $0xdb,%eax
   14477:	74 25                	je     1449e <_DecodeJPEG+0xf8>
   14479:	eb 66                	jmp    144e1 <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   1447b:	83 ec 0c             	sub    $0xc,%esp
   1447e:	ff 75 08             	pushl  0x8(%ebp)
   14481:	e8 c9 00 00 00       	call   1454f <_DecodeSOF>
   14486:	83 c4 10             	add    $0x10,%esp
   14489:	e9 85 00 00 00       	jmp    14513 <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   1448e:	83 ec 0c             	sub    $0xc,%esp
   14491:	ff 75 08             	pushl  0x8(%ebp)
   14494:	e8 28 05 00 00       	call   149c1 <_DecodeDHT>
   14499:	83 c4 10             	add    $0x10,%esp
   1449c:	eb 75                	jmp    14513 <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   1449e:	83 ec 0c             	sub    $0xc,%esp
   144a1:	ff 75 08             	pushl  0x8(%ebp)
   144a4:	e8 05 07 00 00       	call   14bae <_DecodeDQT>
   144a9:	83 c4 10             	add    $0x10,%esp
   144ac:	eb 65                	jmp    14513 <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   144ae:	83 ec 0c             	sub    $0xc,%esp
   144b1:	ff 75 08             	pushl  0x8(%ebp)
   144b4:	e8 ff 07 00 00       	call   14cb8 <_DecodeDRI>
   144b9:	83 c4 10             	add    $0x10,%esp
   144bc:	eb 55                	jmp    14513 <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   144be:	83 ec 08             	sub    $0x8,%esp
   144c1:	ff 75 0c             	pushl  0xc(%ebp)
   144c4:	ff 75 08             	pushl  0x8(%ebp)
   144c7:	e8 56 08 00 00       	call   14d22 <_DecodeSOS>
   144cc:	83 c4 10             	add    $0x10,%esp
   144cf:	eb 42                	jmp    14513 <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   144d1:	83 ec 0c             	sub    $0xc,%esp
   144d4:	ff 75 08             	pushl  0x8(%ebp)
   144d7:	e8 a8 15 00 00       	call   15a84 <_SkipMarker>
   144dc:	83 c4 10             	add    $0x10,%esp
   144df:	eb 32                	jmp    14513 <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   144e1:	8b 45 08             	mov    0x8(%ebp),%eax
   144e4:	8b 40 04             	mov    0x4(%eax),%eax
   144e7:	83 e8 01             	sub    $0x1,%eax
   144ea:	0f b6 00             	movzbl (%eax),%eax
   144ed:	0f b6 c0             	movzbl %al,%eax
   144f0:	25 f0 00 00 00       	and    $0xf0,%eax
   144f5:	3d e0 00 00 00       	cmp    $0xe0,%eax
   144fa:	75 10                	jne    1450c <_DecodeJPEG+0x166>
   144fc:	83 ec 0c             	sub    $0xc,%esp
   144ff:	ff 75 08             	pushl  0x8(%ebp)
   14502:	e8 7d 15 00 00       	call   15a84 <_SkipMarker>
   14507:	83 c4 10             	add    $0x10,%esp
   1450a:	eb 07                	jmp    14513 <_DecodeJPEG+0x16d>
                else return Unsupported;
   1450c:	b8 02 00 00 00       	mov    $0x2,%eax
   14511:	eb 3a                	jmp    1454d <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   14513:	8b 45 08             	mov    0x8(%ebp),%eax
   14516:	8b 00                	mov    (%eax),%eax
   14518:	85 c0                	test   %eax,%eax
   1451a:	0f 84 e9 fe ff ff    	je     14409 <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   14520:	8b 45 08             	mov    0x8(%ebp),%eax
   14523:	8b 00                	mov    (%eax),%eax
   14525:	83 f8 06             	cmp    $0x6,%eax
   14528:	74 07                	je     14531 <_DecodeJPEG+0x18b>
   1452a:	8b 45 08             	mov    0x8(%ebp),%eax
   1452d:	8b 00                	mov    (%eax),%eax
   1452f:	eb 1c                	jmp    1454d <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   14531:	8b 45 08             	mov    0x8(%ebp),%eax
   14534:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   1453a:	83 ec 0c             	sub    $0xc,%esp
   1453d:	ff 75 08             	pushl  0x8(%ebp)
   14540:	e8 6b 15 00 00       	call   15ab0 <_Convert>
   14545:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   14548:	8b 45 08             	mov    0x8(%ebp),%eax
   1454b:	8b 00                	mov    (%eax),%eax
 }
   1454d:	c9                   	leave  
   1454e:	c3                   	ret    

0001454f <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   1454f:	55                   	push   %ebp
   14550:	89 e5                	mov    %esp,%ebp
   14552:	53                   	push   %ebx
   14553:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   14556:	83 ec 0c             	sub    $0xc,%esp
   14559:	ff 75 08             	pushl  0x8(%ebp)
   1455c:	e8 c1 fd ff ff       	call   14322 <_DecodeLength>
   14561:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   14564:	8b 45 08             	mov    0x8(%ebp),%eax
   14567:	8b 00                	mov    (%eax),%eax
   14569:	85 c0                	test   %eax,%eax
   1456b:	0f 85 4a 04 00 00    	jne    149bb <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   14571:	8b 45 08             	mov    0x8(%ebp),%eax
   14574:	8b 40 0c             	mov    0xc(%eax),%eax
   14577:	83 f8 08             	cmp    $0x8,%eax
   1457a:	7f 0e                	jg     1458a <_DecodeSOF+0x3b>
   1457c:	8b 45 08             	mov    0x8(%ebp),%eax
   1457f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14585:	e9 32 04 00 00       	jmp    149bc <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   1458a:	8b 45 08             	mov    0x8(%ebp),%eax
   1458d:	8b 40 04             	mov    0x4(%eax),%eax
   14590:	0f b6 00             	movzbl (%eax),%eax
   14593:	3c 08                	cmp    $0x8,%al
   14595:	74 0e                	je     145a5 <_DecodeSOF+0x56>
   14597:	8b 45 08             	mov    0x8(%ebp),%eax
   1459a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   145a0:	e9 17 04 00 00       	jmp    149bc <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   145a5:	8b 45 08             	mov    0x8(%ebp),%eax
   145a8:	8b 40 04             	mov    0x4(%eax),%eax
   145ab:	83 c0 01             	add    $0x1,%eax
   145ae:	83 ec 0c             	sub    $0xc,%esp
   145b1:	50                   	push   %eax
   145b2:	e8 ce fd ff ff       	call   14385 <_Decode2Bytes>
   145b7:	83 c4 10             	add    $0x10,%esp
   145ba:	89 c2                	mov    %eax,%edx
   145bc:	8b 45 08             	mov    0x8(%ebp),%eax
   145bf:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   145c2:	8b 45 08             	mov    0x8(%ebp),%eax
   145c5:	8b 40 04             	mov    0x4(%eax),%eax
   145c8:	83 c0 03             	add    $0x3,%eax
   145cb:	83 ec 0c             	sub    $0xc,%esp
   145ce:	50                   	push   %eax
   145cf:	e8 b1 fd ff ff       	call   14385 <_Decode2Bytes>
   145d4:	83 c4 10             	add    $0x10,%esp
   145d7:	89 c2                	mov    %eax,%edx
   145d9:	8b 45 08             	mov    0x8(%ebp),%eax
   145dc:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   145df:	8b 45 08             	mov    0x8(%ebp),%eax
   145e2:	8b 40 04             	mov    0x4(%eax),%eax
   145e5:	83 c0 05             	add    $0x5,%eax
   145e8:	0f b6 00             	movzbl (%eax),%eax
   145eb:	0f b6 d0             	movzbl %al,%edx
   145ee:	8b 45 08             	mov    0x8(%ebp),%eax
   145f1:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   145f4:	83 ec 08             	sub    $0x8,%esp
   145f7:	6a 06                	push   $0x6
   145f9:	ff 75 08             	pushl  0x8(%ebp)
   145fc:	e8 d5 fc ff ff       	call   142d6 <_Skip>
   14601:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   14604:	8b 45 08             	mov    0x8(%ebp),%eax
   14607:	8b 40 28             	mov    0x28(%eax),%eax
   1460a:	83 f8 01             	cmp    $0x1,%eax
   1460d:	74 13                	je     14622 <_DecodeSOF+0xd3>
   1460f:	83 f8 03             	cmp    $0x3,%eax
   14612:	74 0e                	je     14622 <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   14614:	8b 45 08             	mov    0x8(%ebp),%eax
   14617:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1461d:	e9 9a 03 00 00       	jmp    149bc <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   14622:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   14623:	8b 45 08             	mov    0x8(%ebp),%eax
   14626:	8b 48 0c             	mov    0xc(%eax),%ecx
   14629:	8b 45 08             	mov    0x8(%ebp),%eax
   1462c:	8b 50 28             	mov    0x28(%eax),%edx
   1462f:	89 d0                	mov    %edx,%eax
   14631:	01 c0                	add    %eax,%eax
   14633:	01 d0                	add    %edx,%eax
   14635:	39 c1                	cmp    %eax,%ecx
   14637:	7d 0e                	jge    14647 <_DecodeSOF+0xf8>
   14639:	8b 45 08             	mov    0x8(%ebp),%eax
   1463c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14642:	e9 75 03 00 00       	jmp    149bc <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   14647:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1464e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14655:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1465c:	8b 45 08             	mov    0x8(%ebp),%eax
   1465f:	83 c0 2c             	add    $0x2c,%eax
   14662:	89 45 e8             	mov    %eax,-0x18(%ebp)
   14665:	e9 50 01 00 00       	jmp    147ba <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   1466a:	8b 45 08             	mov    0x8(%ebp),%eax
   1466d:	8b 40 04             	mov    0x4(%eax),%eax
   14670:	0f b6 00             	movzbl (%eax),%eax
   14673:	0f b6 d0             	movzbl %al,%edx
   14676:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14679:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   1467b:	8b 45 08             	mov    0x8(%ebp),%eax
   1467e:	8b 40 04             	mov    0x4(%eax),%eax
   14681:	83 c0 01             	add    $0x1,%eax
   14684:	0f b6 00             	movzbl (%eax),%eax
   14687:	c0 e8 04             	shr    $0x4,%al
   1468a:	0f b6 d0             	movzbl %al,%edx
   1468d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14690:	89 50 04             	mov    %edx,0x4(%eax)
   14693:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14696:	8b 40 04             	mov    0x4(%eax),%eax
   14699:	85 c0                	test   %eax,%eax
   1469b:	75 0e                	jne    146ab <_DecodeSOF+0x15c>
   1469d:	8b 45 08             	mov    0x8(%ebp),%eax
   146a0:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146a6:	e9 11 03 00 00       	jmp    149bc <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   146ab:	8b 45 08             	mov    0x8(%ebp),%eax
   146ae:	8b 40 04             	mov    0x4(%eax),%eax
   146b1:	83 c0 01             	add    $0x1,%eax
   146b4:	0f b6 00             	movzbl (%eax),%eax
   146b7:	0f b6 c0             	movzbl %al,%eax
   146ba:	83 e0 0f             	and    $0xf,%eax
   146bd:	89 c2                	mov    %eax,%edx
   146bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146c2:	89 50 08             	mov    %edx,0x8(%eax)
   146c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146c8:	8b 40 08             	mov    0x8(%eax),%eax
   146cb:	85 c0                	test   %eax,%eax
   146cd:	75 0e                	jne    146dd <_DecodeSOF+0x18e>
   146cf:	8b 45 08             	mov    0x8(%ebp),%eax
   146d2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146d8:	e9 df 02 00 00       	jmp    149bc <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   146dd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146e0:	8b 50 04             	mov    0x4(%eax),%edx
   146e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146e6:	8b 40 04             	mov    0x4(%eax),%eax
   146e9:	83 e8 01             	sub    $0x1,%eax
   146ec:	21 d0                	and    %edx,%eax
   146ee:	85 c0                	test   %eax,%eax
   146f0:	74 0e                	je     14700 <_DecodeSOF+0x1b1>
   146f2:	8b 45 08             	mov    0x8(%ebp),%eax
   146f5:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   146fb:	e9 bc 02 00 00       	jmp    149bc <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   14700:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14703:	8b 50 08             	mov    0x8(%eax),%edx
   14706:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14709:	8b 40 08             	mov    0x8(%eax),%eax
   1470c:	83 e8 01             	sub    $0x1,%eax
   1470f:	21 d0                	and    %edx,%eax
   14711:	85 c0                	test   %eax,%eax
   14713:	74 0e                	je     14723 <_DecodeSOF+0x1d4>
   14715:	8b 45 08             	mov    0x8(%ebp),%eax
   14718:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1471e:	e9 99 02 00 00       	jmp    149bc <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   14723:	8b 45 08             	mov    0x8(%ebp),%eax
   14726:	8b 40 04             	mov    0x4(%eax),%eax
   14729:	83 c0 02             	add    $0x2,%eax
   1472c:	0f b6 00             	movzbl (%eax),%eax
   1472f:	0f b6 d0             	movzbl %al,%edx
   14732:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14735:	89 50 18             	mov    %edx,0x18(%eax)
   14738:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1473b:	8b 40 18             	mov    0x18(%eax),%eax
   1473e:	25 fc 00 00 00       	and    $0xfc,%eax
   14743:	85 c0                	test   %eax,%eax
   14745:	74 0e                	je     14755 <_DecodeSOF+0x206>
   14747:	8b 45 08             	mov    0x8(%ebp),%eax
   1474a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14750:	e9 67 02 00 00       	jmp    149bc <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   14755:	83 ec 08             	sub    $0x8,%esp
   14758:	6a 03                	push   $0x3
   1475a:	ff 75 08             	pushl  0x8(%ebp)
   1475d:	e8 74 fb ff ff       	call   142d6 <_Skip>
   14762:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   14765:	8b 45 08             	mov    0x8(%ebp),%eax
   14768:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   1476e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14771:	8b 40 18             	mov    0x18(%eax),%eax
   14774:	bb 01 00 00 00       	mov    $0x1,%ebx
   14779:	89 c1                	mov    %eax,%ecx
   1477b:	d3 e3                	shl    %cl,%ebx
   1477d:	89 d8                	mov    %ebx,%eax
   1477f:	09 c2                	or     %eax,%edx
   14781:	8b 45 08             	mov    0x8(%ebp),%eax
   14784:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   1478a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1478d:	8b 40 04             	mov    0x4(%eax),%eax
   14790:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14793:	7e 09                	jle    1479e <_DecodeSOF+0x24f>
   14795:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14798:	8b 40 04             	mov    0x4(%eax),%eax
   1479b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   1479e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   147a1:	8b 40 08             	mov    0x8(%eax),%eax
   147a4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   147a7:	7e 09                	jle    147b2 <_DecodeSOF+0x263>
   147a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   147ac:	8b 40 08             	mov    0x8(%eax),%eax
   147af:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   147b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   147b6:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   147ba:	8b 45 08             	mov    0x8(%ebp),%eax
   147bd:	8b 40 28             	mov    0x28(%eax),%eax
   147c0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   147c3:	0f 8f a1 fe ff ff    	jg     1466a <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   147c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   147cc:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   147d3:	8b 45 08             	mov    0x8(%ebp),%eax
   147d6:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   147d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147dc:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   147e3:	8b 45 08             	mov    0x8(%ebp),%eax
   147e6:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   147e9:	8b 45 08             	mov    0x8(%ebp),%eax
   147ec:	8b 50 10             	mov    0x10(%eax),%edx
   147ef:	8b 45 08             	mov    0x8(%ebp),%eax
   147f2:	8b 40 20             	mov    0x20(%eax),%eax
   147f5:	01 d0                	add    %edx,%eax
   147f7:	8d 48 ff             	lea    -0x1(%eax),%ecx
   147fa:	8b 45 08             	mov    0x8(%ebp),%eax
   147fd:	8b 58 20             	mov    0x20(%eax),%ebx
   14800:	89 c8                	mov    %ecx,%eax
   14802:	99                   	cltd   
   14803:	f7 fb                	idiv   %ebx
   14805:	89 c2                	mov    %eax,%edx
   14807:	8b 45 08             	mov    0x8(%ebp),%eax
   1480a:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   1480d:	8b 45 08             	mov    0x8(%ebp),%eax
   14810:	8b 50 14             	mov    0x14(%eax),%edx
   14813:	8b 45 08             	mov    0x8(%ebp),%eax
   14816:	8b 40 24             	mov    0x24(%eax),%eax
   14819:	01 d0                	add    %edx,%eax
   1481b:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1481e:	8b 45 08             	mov    0x8(%ebp),%eax
   14821:	8b 58 24             	mov    0x24(%eax),%ebx
   14824:	89 c8                	mov    %ecx,%eax
   14826:	99                   	cltd   
   14827:	f7 fb                	idiv   %ebx
   14829:	89 c2                	mov    %eax,%edx
   1482b:	8b 45 08             	mov    0x8(%ebp),%eax
   1482e:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   14831:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14838:	8b 45 08             	mov    0x8(%ebp),%eax
   1483b:	83 c0 2c             	add    $0x2c,%eax
   1483e:	89 45 e8             	mov    %eax,-0x18(%ebp)
   14841:	e9 fd 00 00 00       	jmp    14943 <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   14846:	8b 45 08             	mov    0x8(%ebp),%eax
   14849:	8b 50 10             	mov    0x10(%eax),%edx
   1484c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1484f:	8b 40 04             	mov    0x4(%eax),%eax
   14852:	0f af d0             	imul   %eax,%edx
   14855:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14858:	01 d0                	add    %edx,%eax
   1485a:	83 e8 01             	sub    $0x1,%eax
   1485d:	99                   	cltd   
   1485e:	f7 7d ec             	idivl  -0x14(%ebp)
   14861:	89 c2                	mov    %eax,%edx
   14863:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14866:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   14869:	8b 45 08             	mov    0x8(%ebp),%eax
   1486c:	8b 50 14             	mov    0x14(%eax),%edx
   1486f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14872:	8b 40 08             	mov    0x8(%eax),%eax
   14875:	0f af d0             	imul   %eax,%edx
   14878:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1487b:	01 d0                	add    %edx,%eax
   1487d:	83 e8 01             	sub    $0x1,%eax
   14880:	99                   	cltd   
   14881:	f7 7d f0             	idivl  -0x10(%ebp)
   14884:	89 c2                	mov    %eax,%edx
   14886:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14889:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   1488c:	8b 45 08             	mov    0x8(%ebp),%eax
   1488f:	8b 50 18             	mov    0x18(%eax),%edx
   14892:	8b 45 08             	mov    0x8(%ebp),%eax
   14895:	8b 40 20             	mov    0x20(%eax),%eax
   14898:	0f af d0             	imul   %eax,%edx
   1489b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1489e:	8b 40 04             	mov    0x4(%eax),%eax
   148a1:	0f af c2             	imul   %edx,%eax
   148a4:	99                   	cltd   
   148a5:	f7 7d ec             	idivl  -0x14(%ebp)
   148a8:	89 c2                	mov    %eax,%edx
   148aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   148ad:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   148b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   148b3:	8b 40 0c             	mov    0xc(%eax),%eax
   148b6:	83 f8 02             	cmp    $0x2,%eax
   148b9:	7f 0b                	jg     148c6 <_DecodeSOF+0x377>
   148bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   148be:	8b 40 04             	mov    0x4(%eax),%eax
   148c1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   148c4:	75 16                	jne    148dc <_DecodeSOF+0x38d>
   148c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   148c9:	8b 40 10             	mov    0x10(%eax),%eax
   148cc:	83 f8 02             	cmp    $0x2,%eax
   148cf:	7f 19                	jg     148ea <_DecodeSOF+0x39b>
   148d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   148d4:	8b 40 08             	mov    0x8(%eax),%eax
   148d7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   148da:	74 0e                	je     148ea <_DecodeSOF+0x39b>
   148dc:	8b 45 08             	mov    0x8(%ebp),%eax
   148df:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   148e5:	e9 d2 00 00 00       	jmp    149bc <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   148ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
   148ed:	8b 48 14             	mov    0x14(%eax),%ecx
   148f0:	8b 45 08             	mov    0x8(%ebp),%eax
   148f3:	8b 50 1c             	mov    0x1c(%eax),%edx
   148f6:	8b 45 08             	mov    0x8(%ebp),%eax
   148f9:	8b 40 24             	mov    0x24(%eax),%eax
   148fc:	0f af d0             	imul   %eax,%edx
   148ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14902:	8b 40 08             	mov    0x8(%eax),%eax
   14905:	0f af c2             	imul   %edx,%eax
   14908:	99                   	cltd   
   14909:	f7 7d f0             	idivl  -0x10(%ebp)
   1490c:	0f af c1             	imul   %ecx,%eax
   1490f:	83 ec 0c             	sub    $0xc,%esp
   14912:	50                   	push   %eax
   14913:	e8 45 c5 fe ff       	call   e5d <malloc>
   14918:	83 c4 10             	add    $0x10,%esp
   1491b:	89 c2                	mov    %eax,%edx
   1491d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14920:	89 50 28             	mov    %edx,0x28(%eax)
   14923:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14926:	8b 40 28             	mov    0x28(%eax),%eax
   14929:	85 c0                	test   %eax,%eax
   1492b:	75 0e                	jne    1493b <_DecodeSOF+0x3ec>
   1492d:	8b 45 08             	mov    0x8(%ebp),%eax
   14930:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   14936:	e9 81 00 00 00       	jmp    149bc <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   1493b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1493f:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   14943:	8b 45 08             	mov    0x8(%ebp),%eax
   14946:	8b 40 28             	mov    0x28(%eax),%eax
   14949:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1494c:	0f 8f f4 fe ff ff    	jg     14846 <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   14952:	8b 45 08             	mov    0x8(%ebp),%eax
   14955:	8b 40 28             	mov    0x28(%eax),%eax
   14958:	83 f8 03             	cmp    $0x3,%eax
   1495b:	75 47                	jne    149a4 <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   1495d:	8b 45 08             	mov    0x8(%ebp),%eax
   14960:	8b 50 10             	mov    0x10(%eax),%edx
   14963:	8b 45 08             	mov    0x8(%ebp),%eax
   14966:	8b 40 14             	mov    0x14(%eax),%eax
   14969:	0f af d0             	imul   %eax,%edx
   1496c:	8b 45 08             	mov    0x8(%ebp),%eax
   1496f:	8b 40 28             	mov    0x28(%eax),%eax
   14972:	0f af c2             	imul   %edx,%eax
   14975:	83 ec 0c             	sub    $0xc,%esp
   14978:	50                   	push   %eax
   14979:	e8 df c4 fe ff       	call   e5d <malloc>
   1497e:	83 c4 10             	add    $0x10,%esp
   14981:	89 c2                	mov    %eax,%edx
   14983:	8b 45 08             	mov    0x8(%ebp),%eax
   14986:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   1498c:	8b 45 08             	mov    0x8(%ebp),%eax
   1498f:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   14995:	85 c0                	test   %eax,%eax
   14997:	75 0b                	jne    149a4 <_DecodeSOF+0x455>
   14999:	8b 45 08             	mov    0x8(%ebp),%eax
   1499c:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   149a2:	eb 18                	jmp    149bc <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   149a4:	8b 45 08             	mov    0x8(%ebp),%eax
   149a7:	8b 40 0c             	mov    0xc(%eax),%eax
   149aa:	83 ec 08             	sub    $0x8,%esp
   149ad:	50                   	push   %eax
   149ae:	ff 75 08             	pushl  0x8(%ebp)
   149b1:	e8 20 f9 ff ff       	call   142d6 <_Skip>
   149b6:	83 c4 10             	add    $0x10,%esp
   149b9:	eb 01                	jmp    149bc <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   149bb:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   149bc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   149bf:	c9                   	leave  
   149c0:	c3                   	ret    

000149c1 <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   149c1:	55                   	push   %ebp
   149c2:	89 e5                	mov    %esp,%ebp
   149c4:	53                   	push   %ebx
   149c5:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   149c8:	83 ec 0c             	sub    $0xc,%esp
   149cb:	ff 75 08             	pushl  0x8(%ebp)
   149ce:	e8 4f f9 ff ff       	call   14322 <_DecodeLength>
   149d3:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   149d6:	8b 45 08             	mov    0x8(%ebp),%eax
   149d9:	8b 00                	mov    (%eax),%eax
   149db:	85 c0                	test   %eax,%eax
   149dd:	0f 85 c5 01 00 00    	jne    14ba8 <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   149e3:	e9 9c 01 00 00       	jmp    14b84 <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   149e8:	8b 45 08             	mov    0x8(%ebp),%eax
   149eb:	8b 40 04             	mov    0x4(%eax),%eax
   149ee:	0f b6 00             	movzbl (%eax),%eax
   149f1:	0f b6 c0             	movzbl %al,%eax
   149f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   149f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   149fa:	25 ec 00 00 00       	and    $0xec,%eax
   149ff:	85 c0                	test   %eax,%eax
   14a01:	74 0e                	je     14a11 <_DecodeDHT+0x50>
   14a03:	8b 45 08             	mov    0x8(%ebp),%eax
   14a06:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a0c:	e9 98 01 00 00       	jmp    14ba9 <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   14a11:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a14:	83 e0 02             	and    $0x2,%eax
   14a17:	85 c0                	test   %eax,%eax
   14a19:	74 0e                	je     14a29 <_DecodeDHT+0x68>
   14a1b:	8b 45 08             	mov    0x8(%ebp),%eax
   14a1e:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14a24:	e9 80 01 00 00       	jmp    14ba9 <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   14a29:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a2c:	c1 f8 03             	sar    $0x3,%eax
   14a2f:	0b 45 f4             	or     -0xc(%ebp),%eax
   14a32:	83 e0 03             	and    $0x3,%eax
   14a35:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   14a38:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14a3f:	eb 1c                	jmp    14a5d <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   14a41:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14a44:	8d 50 ff             	lea    -0x1(%eax),%edx
   14a47:	8b 45 08             	mov    0x8(%ebp),%eax
   14a4a:	8b 48 04             	mov    0x4(%eax),%ecx
   14a4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14a50:	01 c8                	add    %ecx,%eax
   14a52:	0f b6 00             	movzbl (%eax),%eax
   14a55:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   14a59:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14a5d:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14a61:	7e de                	jle    14a41 <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   14a63:	83 ec 08             	sub    $0x8,%esp
   14a66:	6a 11                	push   $0x11
   14a68:	ff 75 08             	pushl  0x8(%ebp)
   14a6b:	e8 66 f8 ff ff       	call   142d6 <_Skip>
   14a70:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   14a73:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a76:	c1 e0 11             	shl    $0x11,%eax
   14a79:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14a7f:	8b 45 08             	mov    0x8(%ebp),%eax
   14a82:	01 d0                	add    %edx,%eax
   14a84:	83 c0 08             	add    $0x8,%eax
   14a87:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   14a8a:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   14a91:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14a94:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   14a97:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14a9e:	e9 be 00 00 00       	jmp    14b61 <_DecodeDHT+0x1a0>
            spread >>= 1;
   14aa3:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   14aa6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14aa9:	83 e8 01             	sub    $0x1,%eax
   14aac:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   14ab1:	0f b6 c0             	movzbl %al,%eax
   14ab4:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   14ab7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14abb:	0f 84 9b 00 00 00    	je     14b5c <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   14ac1:	8b 45 08             	mov    0x8(%ebp),%eax
   14ac4:	8b 40 0c             	mov    0xc(%eax),%eax
   14ac7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   14aca:	7d 0e                	jge    14ada <_DecodeDHT+0x119>
   14acc:	8b 45 08             	mov    0x8(%ebp),%eax
   14acf:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14ad5:	e9 cf 00 00 00       	jmp    14ba9 <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   14ada:	b8 10 00 00 00       	mov    $0x10,%eax
   14adf:	2b 45 f0             	sub    -0x10(%ebp),%eax
   14ae2:	8b 55 e0             	mov    -0x20(%ebp),%edx
   14ae5:	89 c1                	mov    %eax,%ecx
   14ae7:	d3 e2                	shl    %cl,%edx
   14ae9:	89 d0                	mov    %edx,%eax
   14aeb:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   14aee:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14af2:	79 0e                	jns    14b02 <_DecodeDHT+0x141>
   14af4:	8b 45 08             	mov    0x8(%ebp),%eax
   14af7:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14afd:	e9 a7 00 00 00       	jmp    14ba9 <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   14b02:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14b09:	eb 36                	jmp    14b41 <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   14b0b:	8b 45 08             	mov    0x8(%ebp),%eax
   14b0e:	8b 50 04             	mov    0x4(%eax),%edx
   14b11:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b14:	01 d0                	add    %edx,%eax
   14b16:	0f b6 00             	movzbl (%eax),%eax
   14b19:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   14b1b:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   14b1e:	eb 14                	jmp    14b34 <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   14b20:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14b23:	89 c2                	mov    %eax,%edx
   14b25:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14b28:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   14b2a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14b2d:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   14b30:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   14b34:	89 d8                	mov    %ebx,%eax
   14b36:	8d 58 ff             	lea    -0x1(%eax),%ebx
   14b39:	85 c0                	test   %eax,%eax
   14b3b:	75 e3                	jne    14b20 <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   14b3d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14b41:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b44:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   14b47:	7c c2                	jl     14b0b <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   14b49:	83 ec 08             	sub    $0x8,%esp
   14b4c:	ff 75 e0             	pushl  -0x20(%ebp)
   14b4f:	ff 75 08             	pushl  0x8(%ebp)
   14b52:	e8 7f f7 ff ff       	call   142d6 <_Skip>
   14b57:	83 c4 10             	add    $0x10,%esp
   14b5a:	eb 01                	jmp    14b5d <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   14b5c:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   14b5d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14b61:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14b65:	0f 8e 38 ff ff ff    	jle    14aa3 <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14b6b:	eb 0a                	jmp    14b77 <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   14b6d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14b70:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   14b73:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14b77:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14b7a:	8d 50 ff             	lea    -0x1(%eax),%edx
   14b7d:	89 55 ec             	mov    %edx,-0x14(%ebp)
   14b80:	85 c0                	test   %eax,%eax
   14b82:	75 e9                	jne    14b6d <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   14b84:	8b 45 08             	mov    0x8(%ebp),%eax
   14b87:	8b 40 0c             	mov    0xc(%eax),%eax
   14b8a:	83 f8 10             	cmp    $0x10,%eax
   14b8d:	0f 8f 55 fe ff ff    	jg     149e8 <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14b93:	8b 45 08             	mov    0x8(%ebp),%eax
   14b96:	8b 40 0c             	mov    0xc(%eax),%eax
   14b99:	85 c0                	test   %eax,%eax
   14b9b:	74 0c                	je     14ba9 <_DecodeDHT+0x1e8>
   14b9d:	8b 45 08             	mov    0x8(%ebp),%eax
   14ba0:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14ba6:	eb 01                	jmp    14ba9 <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   14ba8:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14ba9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14bac:	c9                   	leave  
   14bad:	c3                   	ret    

00014bae <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   14bae:	55                   	push   %ebp
   14baf:	89 e5                	mov    %esp,%ebp
   14bb1:	53                   	push   %ebx
   14bb2:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   14bb5:	83 ec 0c             	sub    $0xc,%esp
   14bb8:	ff 75 08             	pushl  0x8(%ebp)
   14bbb:	e8 62 f7 ff ff       	call   14322 <_DecodeLength>
   14bc0:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14bc3:	8b 45 08             	mov    0x8(%ebp),%eax
   14bc6:	8b 00                	mov    (%eax),%eax
   14bc8:	85 c0                	test   %eax,%eax
   14bca:	0f 85 e2 00 00 00    	jne    14cb2 <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   14bd0:	e9 b8 00 00 00       	jmp    14c8d <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   14bd5:	8b 45 08             	mov    0x8(%ebp),%eax
   14bd8:	8b 40 04             	mov    0x4(%eax),%eax
   14bdb:	0f b6 00             	movzbl (%eax),%eax
   14bde:	0f b6 c0             	movzbl %al,%eax
   14be1:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   14be4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14be7:	25 ec 00 00 00       	and    $0xec,%eax
   14bec:	85 c0                	test   %eax,%eax
   14bee:	74 0e                	je     14bfe <_DecodeDQT+0x50>
   14bf0:	8b 45 08             	mov    0x8(%ebp),%eax
   14bf3:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14bf9:	e9 b5 00 00 00       	jmp    14cb3 <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   14bfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14c01:	83 e0 10             	and    $0x10,%eax
   14c04:	85 c0                	test   %eax,%eax
   14c06:	74 0e                	je     14c16 <_DecodeDQT+0x68>
   14c08:	8b 45 08             	mov    0x8(%ebp),%eax
   14c0b:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14c11:	e9 9d 00 00 00       	jmp    14cb3 <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   14c16:	8b 45 08             	mov    0x8(%ebp),%eax
   14c19:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   14c1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14c22:	bb 01 00 00 00       	mov    $0x1,%ebx
   14c27:	89 c1                	mov    %eax,%ecx
   14c29:	d3 e3                	shl    %cl,%ebx
   14c2b:	89 d8                	mov    %ebx,%eax
   14c2d:	09 c2                	or     %eax,%edx
   14c2f:	8b 45 08             	mov    0x8(%ebp),%eax
   14c32:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   14c38:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14c3b:	c1 e0 06             	shl    $0x6,%eax
   14c3e:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   14c44:	8b 45 08             	mov    0x8(%ebp),%eax
   14c47:	01 d0                	add    %edx,%eax
   14c49:	83 c0 08             	add    $0x8,%eax
   14c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   14c4f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14c56:	eb 1f                	jmp    14c77 <_DecodeDQT+0xc9>
   14c58:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14c5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c5e:	01 c2                	add    %eax,%edx
   14c60:	8b 45 08             	mov    0x8(%ebp),%eax
   14c63:	8b 40 04             	mov    0x4(%eax),%eax
   14c66:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14c69:	83 c1 01             	add    $0x1,%ecx
   14c6c:	01 c8                	add    %ecx,%eax
   14c6e:	0f b6 00             	movzbl (%eax),%eax
   14c71:	88 02                	mov    %al,(%edx)
   14c73:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14c77:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14c7b:	7e db                	jle    14c58 <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   14c7d:	83 ec 08             	sub    $0x8,%esp
   14c80:	6a 41                	push   $0x41
   14c82:	ff 75 08             	pushl  0x8(%ebp)
   14c85:	e8 4c f6 ff ff       	call   142d6 <_Skip>
   14c8a:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   14c8d:	8b 45 08             	mov    0x8(%ebp),%eax
   14c90:	8b 40 0c             	mov    0xc(%eax),%eax
   14c93:	83 f8 40             	cmp    $0x40,%eax
   14c96:	0f 8f 39 ff ff ff    	jg     14bd5 <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14c9c:	8b 45 08             	mov    0x8(%ebp),%eax
   14c9f:	8b 40 0c             	mov    0xc(%eax),%eax
   14ca2:	85 c0                	test   %eax,%eax
   14ca4:	74 0d                	je     14cb3 <_DecodeDQT+0x105>
   14ca6:	8b 45 08             	mov    0x8(%ebp),%eax
   14ca9:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14caf:	90                   	nop
   14cb0:	eb 01                	jmp    14cb3 <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   14cb2:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14cb3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14cb6:	c9                   	leave  
   14cb7:	c3                   	ret    

00014cb8 <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   14cb8:	55                   	push   %ebp
   14cb9:	89 e5                	mov    %esp,%ebp
   14cbb:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   14cbe:	83 ec 0c             	sub    $0xc,%esp
   14cc1:	ff 75 08             	pushl  0x8(%ebp)
   14cc4:	e8 59 f6 ff ff       	call   14322 <_DecodeLength>
   14cc9:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14ccc:	8b 45 08             	mov    0x8(%ebp),%eax
   14ccf:	8b 00                	mov    (%eax),%eax
   14cd1:	85 c0                	test   %eax,%eax
   14cd3:	75 4a                	jne    14d1f <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   14cd5:	8b 45 08             	mov    0x8(%ebp),%eax
   14cd8:	8b 40 0c             	mov    0xc(%eax),%eax
   14cdb:	83 f8 01             	cmp    $0x1,%eax
   14cde:	7f 0b                	jg     14ceb <_DecodeDRI+0x33>
   14ce0:	8b 45 08             	mov    0x8(%ebp),%eax
   14ce3:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14ce9:	eb 35                	jmp    14d20 <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   14ceb:	8b 45 08             	mov    0x8(%ebp),%eax
   14cee:	8b 40 04             	mov    0x4(%eax),%eax
   14cf1:	83 ec 0c             	sub    $0xc,%esp
   14cf4:	50                   	push   %eax
   14cf5:	e8 8b f6 ff ff       	call   14385 <_Decode2Bytes>
   14cfa:	83 c4 10             	add    $0x10,%esp
   14cfd:	89 c2                	mov    %eax,%edx
   14cff:	8b 45 08             	mov    0x8(%ebp),%eax
   14d02:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   14d08:	8b 45 08             	mov    0x8(%ebp),%eax
   14d0b:	8b 40 0c             	mov    0xc(%eax),%eax
   14d0e:	83 ec 08             	sub    $0x8,%esp
   14d11:	50                   	push   %eax
   14d12:	ff 75 08             	pushl  0x8(%ebp)
   14d15:	e8 bc f5 ff ff       	call   142d6 <_Skip>
   14d1a:	83 c4 10             	add    $0x10,%esp
   14d1d:	eb 01                	jmp    14d20 <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   14d1f:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   14d20:	c9                   	leave  
   14d21:	c3                   	ret    

00014d22 <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   14d22:	55                   	push   %ebp
   14d23:	89 e5                	mov    %esp,%ebp
   14d25:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   14d28:	8b 45 08             	mov    0x8(%ebp),%eax
   14d2b:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14d31:	89 45 e0             	mov    %eax,-0x20(%ebp)
   14d34:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   14d3b:	83 ec 0c             	sub    $0xc,%esp
   14d3e:	ff 75 08             	pushl  0x8(%ebp)
   14d41:	e8 dc f5 ff ff       	call   14322 <_DecodeLength>
   14d46:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14d49:	8b 45 08             	mov    0x8(%ebp),%eax
   14d4c:	8b 00                	mov    (%eax),%eax
   14d4e:	85 c0                	test   %eax,%eax
   14d50:	0f 85 c2 02 00 00    	jne    15018 <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   14d56:	8b 45 08             	mov    0x8(%ebp),%eax
   14d59:	8b 50 0c             	mov    0xc(%eax),%edx
   14d5c:	8b 45 08             	mov    0x8(%ebp),%eax
   14d5f:	8b 40 28             	mov    0x28(%eax),%eax
   14d62:	83 c0 02             	add    $0x2,%eax
   14d65:	01 c0                	add    %eax,%eax
   14d67:	39 c2                	cmp    %eax,%edx
   14d69:	7c 16                	jl     14d81 <_DecodeSOS+0x5f>
   14d6b:	8b 45 08             	mov    0x8(%ebp),%eax
   14d6e:	8b 40 04             	mov    0x4(%eax),%eax
   14d71:	0f b6 00             	movzbl (%eax),%eax
   14d74:	0f b6 d0             	movzbl %al,%edx
   14d77:	8b 45 08             	mov    0x8(%ebp),%eax
   14d7a:	8b 40 28             	mov    0x28(%eax),%eax
   14d7d:	39 c2                	cmp    %eax,%edx
   14d7f:	74 0e                	je     14d8f <_DecodeSOS+0x6d>
   14d81:	8b 45 08             	mov    0x8(%ebp),%eax
   14d84:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14d8a:	e9 8d 02 00 00       	jmp    1501c <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   14d8f:	83 ec 08             	sub    $0x8,%esp
   14d92:	6a 01                	push   $0x1
   14d94:	ff 75 08             	pushl  0x8(%ebp)
   14d97:	e8 3a f5 ff ff       	call   142d6 <_Skip>
   14d9c:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14d9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14da6:	8b 45 08             	mov    0x8(%ebp),%eax
   14da9:	83 c0 2c             	add    $0x2c,%eax
   14dac:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14daf:	e9 ba 00 00 00       	jmp    14e6e <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   14db4:	8b 45 08             	mov    0x8(%ebp),%eax
   14db7:	8b 40 04             	mov    0x4(%eax),%eax
   14dba:	0f b6 00             	movzbl (%eax),%eax
   14dbd:	0f b6 d0             	movzbl %al,%edx
   14dc0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14dc3:	8b 00                	mov    (%eax),%eax
   14dc5:	39 c2                	cmp    %eax,%edx
   14dc7:	74 0e                	je     14dd7 <_DecodeSOS+0xb5>
   14dc9:	8b 45 08             	mov    0x8(%ebp),%eax
   14dcc:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14dd2:	e9 45 02 00 00       	jmp    1501c <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   14dd7:	8b 45 08             	mov    0x8(%ebp),%eax
   14dda:	8b 40 04             	mov    0x4(%eax),%eax
   14ddd:	83 c0 01             	add    $0x1,%eax
   14de0:	0f b6 00             	movzbl (%eax),%eax
   14de3:	0f b6 c0             	movzbl %al,%eax
   14de6:	25 ec 00 00 00       	and    $0xec,%eax
   14deb:	85 c0                	test   %eax,%eax
   14ded:	74 0e                	je     14dfd <_DecodeSOS+0xdb>
   14def:	8b 45 08             	mov    0x8(%ebp),%eax
   14df2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14df8:	e9 1f 02 00 00       	jmp    1501c <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   14dfd:	8b 45 08             	mov    0x8(%ebp),%eax
   14e00:	8b 40 04             	mov    0x4(%eax),%eax
   14e03:	83 c0 01             	add    $0x1,%eax
   14e06:	0f b6 00             	movzbl (%eax),%eax
   14e09:	0f b6 c0             	movzbl %al,%eax
   14e0c:	83 e0 02             	and    $0x2,%eax
   14e0f:	85 c0                	test   %eax,%eax
   14e11:	74 0e                	je     14e21 <_DecodeSOS+0xff>
   14e13:	8b 45 08             	mov    0x8(%ebp),%eax
   14e16:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14e1c:	e9 fb 01 00 00       	jmp    1501c <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   14e21:	8b 45 08             	mov    0x8(%ebp),%eax
   14e24:	8b 40 04             	mov    0x4(%eax),%eax
   14e27:	83 c0 01             	add    $0x1,%eax
   14e2a:	0f b6 00             	movzbl (%eax),%eax
   14e2d:	c0 e8 04             	shr    $0x4,%al
   14e30:	0f b6 d0             	movzbl %al,%edx
   14e33:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14e36:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   14e39:	8b 45 08             	mov    0x8(%ebp),%eax
   14e3c:	8b 40 04             	mov    0x4(%eax),%eax
   14e3f:	83 c0 01             	add    $0x1,%eax
   14e42:	0f b6 00             	movzbl (%eax),%eax
   14e45:	0f b6 c0             	movzbl %al,%eax
   14e48:	83 e0 01             	and    $0x1,%eax
   14e4b:	83 c8 02             	or     $0x2,%eax
   14e4e:	89 c2                	mov    %eax,%edx
   14e50:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14e53:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   14e56:	83 ec 08             	sub    $0x8,%esp
   14e59:	6a 02                	push   $0x2
   14e5b:	ff 75 08             	pushl  0x8(%ebp)
   14e5e:	e8 73 f4 ff ff       	call   142d6 <_Skip>
   14e63:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14e66:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14e6a:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14e6e:	8b 45 08             	mov    0x8(%ebp),%eax
   14e71:	8b 40 28             	mov    0x28(%eax),%eax
   14e74:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14e77:	0f 8f 37 ff ff ff    	jg     14db4 <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   14e7d:	8b 45 08             	mov    0x8(%ebp),%eax
   14e80:	8b 40 04             	mov    0x4(%eax),%eax
   14e83:	0f b6 00             	movzbl (%eax),%eax
   14e86:	84 c0                	test   %al,%al
   14e88:	75 10                	jne    14e9a <_DecodeSOS+0x178>
   14e8a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e8d:	8b 40 04             	mov    0x4(%eax),%eax
   14e90:	83 c0 01             	add    $0x1,%eax
   14e93:	0f b6 00             	movzbl (%eax),%eax
   14e96:	3c 3f                	cmp    $0x3f,%al
   14e98:	74 0e                	je     14ea8 <_DecodeSOS+0x186>
   14e9a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e9d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14ea3:	e9 74 01 00 00       	jmp    1501c <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   14ea8:	8b 45 08             	mov    0x8(%ebp),%eax
   14eab:	8b 40 04             	mov    0x4(%eax),%eax
   14eae:	83 c0 02             	add    $0x2,%eax
   14eb1:	0f b6 00             	movzbl (%eax),%eax
   14eb4:	84 c0                	test   %al,%al
   14eb6:	74 0e                	je     14ec6 <_DecodeSOS+0x1a4>
   14eb8:	8b 45 08             	mov    0x8(%ebp),%eax
   14ebb:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14ec1:	e9 56 01 00 00       	jmp    1501c <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   14ec6:	8b 45 08             	mov    0x8(%ebp),%eax
   14ec9:	8b 40 0c             	mov    0xc(%eax),%eax
   14ecc:	83 ec 08             	sub    $0x8,%esp
   14ecf:	50                   	push   %eax
   14ed0:	ff 75 08             	pushl  0x8(%ebp)
   14ed3:	e8 fe f3 ff ff       	call   142d6 <_Skip>
   14ed8:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   14edb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   14ee2:	e9 17 01 00 00       	jmp    14ffe <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14ee7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14eee:	e9 f8 00 00 00       	jmp    14feb <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14ef3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14efa:	8b 45 08             	mov    0x8(%ebp),%eax
   14efd:	83 c0 2c             	add    $0x2c,%eax
   14f00:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14f03:	e9 8d 00 00 00       	jmp    14f95 <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   14f08:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   14f0f:	eb 71                	jmp    14f82 <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14f11:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   14f18:	eb 59                	jmp    14f73 <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   14f1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f1d:	8b 50 28             	mov    0x28(%eax),%edx
   14f20:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f23:	8b 40 08             	mov    0x8(%eax),%eax
   14f26:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   14f2a:	89 c1                	mov    %eax,%ecx
   14f2c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14f2f:	01 c1                	add    %eax,%ecx
   14f31:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f34:	8b 40 14             	mov    0x14(%eax),%eax
   14f37:	0f af c8             	imul   %eax,%ecx
   14f3a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f3d:	8b 40 04             	mov    0x4(%eax),%eax
   14f40:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14f44:	01 c1                	add    %eax,%ecx
   14f46:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f49:	01 c8                	add    %ecx,%eax
   14f4b:	c1 e0 03             	shl    $0x3,%eax
   14f4e:	01 d0                	add    %edx,%eax
   14f50:	50                   	push   %eax
   14f51:	ff 75 dc             	pushl  -0x24(%ebp)
   14f54:	ff 75 0c             	pushl  0xc(%ebp)
   14f57:	ff 75 08             	pushl  0x8(%ebp)
   14f5a:	e8 bf 00 00 00       	call   1501e <_DecodeBlock>
   14f5f:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   14f62:	8b 45 08             	mov    0x8(%ebp),%eax
   14f65:	8b 00                	mov    (%eax),%eax
   14f67:	85 c0                	test   %eax,%eax
   14f69:	0f 85 ac 00 00 00    	jne    1501b <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14f6f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   14f73:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f76:	8b 40 04             	mov    0x4(%eax),%eax
   14f79:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   14f7c:	7f 9c                	jg     14f1a <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   14f7e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   14f82:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f85:	8b 40 08             	mov    0x8(%eax),%eax
   14f88:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   14f8b:	7f 84                	jg     14f11 <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14f8d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14f91:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14f95:	8b 45 08             	mov    0x8(%ebp),%eax
   14f98:	8b 40 28             	mov    0x28(%eax),%eax
   14f9b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14f9e:	0f 8f 64 ff ff ff    	jg     14f08 <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   14fa4:	8b 45 08             	mov    0x8(%ebp),%eax
   14fa7:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14fad:	85 c0                	test   %eax,%eax
   14faf:	74 36                	je     14fe7 <_DecodeSOS+0x2c5>
   14fb1:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   14fb5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14fb9:	75 2c                	jne    14fe7 <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   14fbb:	83 ec 0c             	sub    $0xc,%esp
   14fbe:	ff 75 08             	pushl  0x8(%ebp)
   14fc1:	e8 9f 0a 00 00       	call   15a65 <_ByteAlign>
   14fc6:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   14fc9:	83 ec 08             	sub    $0x8,%esp
   14fcc:	6a 10                	push   $0x10
   14fce:	ff 75 08             	pushl  0x8(%ebp)
   14fd1:	e8 ce 04 00 00       	call   154a4 <_GetBits>
   14fd6:	83 c4 10             	add    $0x10,%esp
   14fd9:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   14fdc:	8b 45 08             	mov    0x8(%ebp),%eax
   14fdf:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14fe5:	eb 35                	jmp    1501c <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14fe7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14feb:	8b 45 08             	mov    0x8(%ebp),%eax
   14fee:	8b 40 18             	mov    0x18(%eax),%eax
   14ff1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14ff4:	0f 8f f9 fe ff ff    	jg     14ef3 <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   14ffa:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   14ffe:	8b 45 08             	mov    0x8(%ebp),%eax
   15001:	8b 40 1c             	mov    0x1c(%eax),%eax
   15004:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   15007:	0f 8f da fe ff ff    	jg     14ee7 <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   1500d:	8b 45 08             	mov    0x8(%ebp),%eax
   15010:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   15016:	eb 04                	jmp    1501c <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   15018:	90                   	nop
   15019:	eb 01                	jmp    1501c <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   1501b:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   1501c:	c9                   	leave  
   1501d:	c3                   	ret    

0001501e <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   1501e:	55                   	push   %ebp
   1501f:	89 e5                	mov    %esp,%ebp
   15021:	53                   	push   %ebx
   15022:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   15025:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   1502c:	8b 45 08             	mov    0x8(%ebp),%eax
   1502f:	05 c0 01 08 00       	add    $0x801c0,%eax
   15034:	83 ec 04             	sub    $0x4,%esp
   15037:	68 00 01 00 00       	push   $0x100
   1503c:	6a 00                	push   $0x0
   1503e:	50                   	push   %eax
   1503f:	e8 04 b8 fe ff       	call   848 <memset>
   15044:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   15047:	8b 45 10             	mov    0x10(%ebp),%eax
   1504a:	8b 40 20             	mov    0x20(%eax),%eax
   1504d:	c1 e0 11             	shl    $0x11,%eax
   15050:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   15056:	8b 45 08             	mov    0x8(%ebp),%eax
   15059:	01 d0                	add    %edx,%eax
   1505b:	83 c0 08             	add    $0x8,%eax
   1505e:	83 ec 04             	sub    $0x4,%esp
   15061:	6a 00                	push   $0x0
   15063:	50                   	push   %eax
   15064:	ff 75 08             	pushl  0x8(%ebp)
   15067:	e8 86 01 00 00       	call   151f2 <_GetVLC>
   1506c:	83 c4 10             	add    $0x10,%esp
   1506f:	89 c2                	mov    %eax,%edx
   15071:	8b 45 10             	mov    0x10(%ebp),%eax
   15074:	8b 40 24             	mov    0x24(%eax),%eax
   15077:	01 c2                	add    %eax,%edx
   15079:	8b 45 10             	mov    0x10(%ebp),%eax
   1507c:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   1507f:	8b 45 10             	mov    0x10(%ebp),%eax
   15082:	8b 50 24             	mov    0x24(%eax),%edx
   15085:	8b 45 10             	mov    0x10(%ebp),%eax
   15088:	8b 48 18             	mov    0x18(%eax),%ecx
   1508b:	8b 45 08             	mov    0x8(%ebp),%eax
   1508e:	c1 e1 06             	shl    $0x6,%ecx
   15091:	01 c8                	add    %ecx,%eax
   15093:	05 b8 00 00 00       	add    $0xb8,%eax
   15098:	0f b6 00             	movzbl (%eax),%eax
   1509b:	0f b6 c0             	movzbl %al,%eax
   1509e:	0f af d0             	imul   %eax,%edx
   150a1:	8b 45 08             	mov    0x8(%ebp),%eax
   150a4:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   150aa:	8b 45 10             	mov    0x10(%ebp),%eax
   150ad:	8b 40 1c             	mov    0x1c(%eax),%eax
   150b0:	c1 e0 11             	shl    $0x11,%eax
   150b3:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   150b9:	8b 45 08             	mov    0x8(%ebp),%eax
   150bc:	01 d0                	add    %edx,%eax
   150be:	8d 50 08             	lea    0x8(%eax),%edx
   150c1:	83 ec 04             	sub    $0x4,%esp
   150c4:	8d 45 ef             	lea    -0x11(%ebp),%eax
   150c7:	50                   	push   %eax
   150c8:	52                   	push   %edx
   150c9:	ff 75 08             	pushl  0x8(%ebp)
   150cc:	e8 21 01 00 00       	call   151f2 <_GetVLC>
   150d1:	83 c4 10             	add    $0x10,%esp
   150d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   150d7:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   150db:	84 c0                	test   %al,%al
   150dd:	0f 84 92 00 00 00    	je     15175 <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   150e3:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   150e7:	0f b6 c0             	movzbl %al,%eax
   150ea:	83 e0 0f             	and    $0xf,%eax
   150ed:	85 c0                	test   %eax,%eax
   150ef:	75 16                	jne    15107 <_DecodeBlock+0xe9>
   150f1:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   150f5:	3c f0                	cmp    $0xf0,%al
   150f7:	74 0e                	je     15107 <_DecodeBlock+0xe9>
   150f9:	8b 45 08             	mov    0x8(%ebp),%eax
   150fc:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15102:	e9 e6 00 00 00       	jmp    151ed <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   15107:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   1510b:	c0 e8 04             	shr    $0x4,%al
   1510e:	0f b6 c0             	movzbl %al,%eax
   15111:	83 c0 01             	add    $0x1,%eax
   15114:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   15117:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   1511b:	7e 0e                	jle    1512b <_DecodeBlock+0x10d>
   1511d:	8b 45 08             	mov    0x8(%ebp),%eax
   15120:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15126:	e9 c2 00 00 00       	jmp    151ed <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   1512b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1512e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15131:	01 d0                	add    %edx,%eax
   15133:	0f b6 00             	movzbl (%eax),%eax
   15136:	0f be c8             	movsbl %al,%ecx
   15139:	8b 45 10             	mov    0x10(%ebp),%eax
   1513c:	8b 50 18             	mov    0x18(%eax),%edx
   1513f:	8b 45 08             	mov    0x8(%ebp),%eax
   15142:	c1 e2 06             	shl    $0x6,%edx
   15145:	01 c2                	add    %eax,%edx
   15147:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1514a:	01 d0                	add    %edx,%eax
   1514c:	05 b8 00 00 00       	add    $0xb8,%eax
   15151:	0f b6 00             	movzbl (%eax),%eax
   15154:	0f b6 c0             	movzbl %al,%eax
   15157:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   1515b:	89 c2                	mov    %eax,%edx
   1515d:	8b 45 08             	mov    0x8(%ebp),%eax
   15160:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   15166:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   15169:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   1516d:	0f 8e 37 ff ff ff    	jle    150aa <_DecodeBlock+0x8c>
   15173:	eb 01                	jmp    15176 <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   15175:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   15176:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1517d:	eb 24                	jmp    151a3 <_DecodeBlock+0x185>
   1517f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15182:	05 70 00 02 00       	add    $0x20070,%eax
   15187:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1518e:	8b 45 08             	mov    0x8(%ebp),%eax
   15191:	01 d0                	add    %edx,%eax
   15193:	83 ec 0c             	sub    $0xc,%esp
   15196:	50                   	push   %eax
   15197:	e8 32 03 00 00       	call   154ce <_RowIDCT>
   1519c:	83 c4 10             	add    $0x10,%esp
   1519f:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   151a3:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   151a7:	7e d6                	jle    1517f <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   151a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   151b0:	eb 35                	jmp    151e7 <_DecodeBlock+0x1c9>
   151b2:	8b 45 10             	mov    0x10(%ebp),%eax
   151b5:	8b 40 14             	mov    0x14(%eax),%eax
   151b8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   151bb:	8b 55 14             	mov    0x14(%ebp),%edx
   151be:	01 d1                	add    %edx,%ecx
   151c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   151c3:	81 c2 70 00 02 00    	add    $0x20070,%edx
   151c9:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   151d0:	8b 55 08             	mov    0x8(%ebp),%edx
   151d3:	01 da                	add    %ebx,%edx
   151d5:	83 ec 04             	sub    $0x4,%esp
   151d8:	50                   	push   %eax
   151d9:	51                   	push   %ecx
   151da:	52                   	push   %edx
   151db:	e8 7b 05 00 00       	call   1575b <_ColIDCT>
   151e0:	83 c4 10             	add    $0x10,%esp
   151e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   151e7:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   151eb:	7e c5                	jle    151b2 <_DecodeBlock+0x194>
}
   151ed:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   151f0:	c9                   	leave  
   151f1:	c3                   	ret    

000151f2 <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   151f2:	55                   	push   %ebp
   151f3:	89 e5                	mov    %esp,%ebp
   151f5:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   151f8:	83 ec 08             	sub    $0x8,%esp
   151fb:	6a 10                	push   $0x10
   151fd:	ff 75 08             	pushl  0x8(%ebp)
   15200:	e8 c2 00 00 00       	call   152c7 <_ShowBits>
   15205:	83 c4 10             	add    $0x10,%esp
   15208:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   1520b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1520e:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15211:	8b 45 0c             	mov    0xc(%ebp),%eax
   15214:	01 d0                	add    %edx,%eax
   15216:	0f b6 00             	movzbl (%eax),%eax
   15219:	0f b6 c0             	movzbl %al,%eax
   1521c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   1521f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15223:	75 13                	jne    15238 <_GetVLC+0x46>
   15225:	8b 45 08             	mov    0x8(%ebp),%eax
   15228:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1522e:	b8 00 00 00 00       	mov    $0x0,%eax
   15233:	e9 8d 00 00 00       	jmp    152c5 <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   15238:	83 ec 08             	sub    $0x8,%esp
   1523b:	ff 75 f0             	pushl  -0x10(%ebp)
   1523e:	ff 75 08             	pushl  0x8(%ebp)
   15241:	e8 25 02 00 00       	call   1546b <_SkipBits>
   15246:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   15249:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1524c:	8d 14 00             	lea    (%eax,%eax,1),%edx
   1524f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15252:	01 d0                	add    %edx,%eax
   15254:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   15258:	0f b6 c0             	movzbl %al,%eax
   1525b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   1525e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   15262:	74 0a                	je     1526e <_GetVLC+0x7c>
   15264:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15267:	89 c2                	mov    %eax,%edx
   15269:	8b 45 10             	mov    0x10(%ebp),%eax
   1526c:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   1526e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15271:	83 e0 0f             	and    $0xf,%eax
   15274:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   15277:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1527b:	75 07                	jne    15284 <_GetVLC+0x92>
   1527d:	b8 00 00 00 00       	mov    $0x0,%eax
   15282:	eb 41                	jmp    152c5 <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   15284:	83 ec 08             	sub    $0x8,%esp
   15287:	ff 75 f0             	pushl  -0x10(%ebp)
   1528a:	ff 75 08             	pushl  0x8(%ebp)
   1528d:	e8 12 02 00 00       	call   154a4 <_GetBits>
   15292:	83 c4 10             	add    $0x10,%esp
   15295:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   15298:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1529b:	83 e8 01             	sub    $0x1,%eax
   1529e:	ba 01 00 00 00       	mov    $0x1,%edx
   152a3:	89 c1                	mov    %eax,%ecx
   152a5:	d3 e2                	shl    %cl,%edx
   152a7:	89 d0                	mov    %edx,%eax
   152a9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   152ac:	7e 14                	jle    152c2 <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   152ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152b1:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   152b6:	89 c1                	mov    %eax,%ecx
   152b8:	d3 e2                	shl    %cl,%edx
   152ba:	89 d0                	mov    %edx,%eax
   152bc:	83 c0 01             	add    $0x1,%eax
   152bf:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   152c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   152c5:	c9                   	leave  
   152c6:	c3                   	ret    

000152c7 <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   152c7:	55                   	push   %ebp
   152c8:	89 e5                	mov    %esp,%ebp
   152ca:	53                   	push   %ebx
   152cb:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   152ce:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   152d2:	0f 85 4f 01 00 00    	jne    15427 <_ShowBits+0x160>
   152d8:	b8 00 00 00 00       	mov    $0x0,%eax
   152dd:	e9 83 01 00 00       	jmp    15465 <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   152e2:	8b 45 08             	mov    0x8(%ebp),%eax
   152e5:	8b 40 08             	mov    0x8(%eax),%eax
   152e8:	85 c0                	test   %eax,%eax
   152ea:	7f 33                	jg     1531f <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   152ec:	8b 45 08             	mov    0x8(%ebp),%eax
   152ef:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   152f5:	c1 e0 08             	shl    $0x8,%eax
   152f8:	0c ff                	or     $0xff,%al
   152fa:	89 c2                	mov    %eax,%edx
   152fc:	8b 45 08             	mov    0x8(%ebp),%eax
   152ff:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   15305:	8b 45 08             	mov    0x8(%ebp),%eax
   15308:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1530e:	8d 50 08             	lea    0x8(%eax),%edx
   15311:	8b 45 08             	mov    0x8(%ebp),%eax
   15314:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   1531a:	e9 08 01 00 00       	jmp    15427 <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   1531f:	8b 45 08             	mov    0x8(%ebp),%eax
   15322:	8b 40 04             	mov    0x4(%eax),%eax
   15325:	8d 48 01             	lea    0x1(%eax),%ecx
   15328:	8b 55 08             	mov    0x8(%ebp),%edx
   1532b:	89 4a 04             	mov    %ecx,0x4(%edx)
   1532e:	0f b6 00             	movzbl (%eax),%eax
   15331:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   15334:	8b 45 08             	mov    0x8(%ebp),%eax
   15337:	8b 40 08             	mov    0x8(%eax),%eax
   1533a:	8d 50 ff             	lea    -0x1(%eax),%edx
   1533d:	8b 45 08             	mov    0x8(%ebp),%eax
   15340:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   15343:	8b 45 08             	mov    0x8(%ebp),%eax
   15346:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1534c:	8d 50 08             	lea    0x8(%eax),%edx
   1534f:	8b 45 08             	mov    0x8(%ebp),%eax
   15352:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   15358:	8b 45 08             	mov    0x8(%ebp),%eax
   1535b:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   15361:	c1 e0 08             	shl    $0x8,%eax
   15364:	89 c2                	mov    %eax,%edx
   15366:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   1536a:	09 c2                	or     %eax,%edx
   1536c:	8b 45 08             	mov    0x8(%ebp),%eax
   1536f:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   15375:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   15379:	0f 85 a8 00 00 00    	jne    15427 <_ShowBits+0x160>
            if(ctx->size){
   1537f:	8b 45 08             	mov    0x8(%ebp),%eax
   15382:	8b 40 08             	mov    0x8(%eax),%eax
   15385:	85 c0                	test   %eax,%eax
   15387:	0f 84 91 00 00 00    	je     1541e <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   1538d:	8b 45 08             	mov    0x8(%ebp),%eax
   15390:	8b 40 04             	mov    0x4(%eax),%eax
   15393:	8d 48 01             	lea    0x1(%eax),%ecx
   15396:	8b 55 08             	mov    0x8(%ebp),%edx
   15399:	89 4a 04             	mov    %ecx,0x4(%edx)
   1539c:	0f b6 00             	movzbl (%eax),%eax
   1539f:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   153a2:	8b 45 08             	mov    0x8(%ebp),%eax
   153a5:	8b 40 08             	mov    0x8(%eax),%eax
   153a8:	8d 50 ff             	lea    -0x1(%eax),%edx
   153ab:	8b 45 08             	mov    0x8(%ebp),%eax
   153ae:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   153b1:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   153b5:	85 c0                	test   %eax,%eax
   153b7:	74 62                	je     1541b <_ShowBits+0x154>
   153b9:	3d d9 00 00 00       	cmp    $0xd9,%eax
   153be:	75 0c                	jne    153cc <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   153c0:	8b 45 08             	mov    0x8(%ebp),%eax
   153c3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   153ca:	eb 5b                	jmp    15427 <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   153cc:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   153d0:	25 f8 00 00 00       	and    $0xf8,%eax
   153d5:	3d d0 00 00 00       	cmp    $0xd0,%eax
   153da:	74 0b                	je     153e7 <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   153dc:	8b 45 08             	mov    0x8(%ebp),%eax
   153df:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   153e5:	eb 40                	jmp    15427 <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   153e7:	8b 45 08             	mov    0x8(%ebp),%eax
   153ea:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   153f0:	c1 e0 08             	shl    $0x8,%eax
   153f3:	89 c2                	mov    %eax,%edx
   153f5:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   153f9:	09 c2                	or     %eax,%edx
   153fb:	8b 45 08             	mov    0x8(%ebp),%eax
   153fe:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   15404:	8b 45 08             	mov    0x8(%ebp),%eax
   15407:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1540d:	8d 50 08             	lea    0x8(%eax),%edx
   15410:	8b 45 08             	mov    0x8(%ebp),%eax
   15413:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   15419:	eb 0c                	jmp    15427 <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   1541b:	90                   	nop
   1541c:	eb 09                	jmp    15427 <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   1541e:	8b 45 08             	mov    0x8(%ebp),%eax
   15421:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   15427:	8b 45 08             	mov    0x8(%ebp),%eax
   1542a:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15430:	3b 45 0c             	cmp    0xc(%ebp),%eax
   15433:	0f 8c a9 fe ff ff    	jl     152e2 <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   15439:	8b 45 08             	mov    0x8(%ebp),%eax
   1543c:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   15442:	8b 45 08             	mov    0x8(%ebp),%eax
   15445:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1544b:	2b 45 0c             	sub    0xc(%ebp),%eax
   1544e:	89 c1                	mov    %eax,%ecx
   15450:	d3 fa                	sar    %cl,%edx
   15452:	8b 45 0c             	mov    0xc(%ebp),%eax
   15455:	bb 01 00 00 00       	mov    $0x1,%ebx
   1545a:	89 c1                	mov    %eax,%ecx
   1545c:	d3 e3                	shl    %cl,%ebx
   1545e:	89 d8                	mov    %ebx,%eax
   15460:	83 e8 01             	sub    $0x1,%eax
   15463:	21 d0                	and    %edx,%eax
}
   15465:	83 c4 10             	add    $0x10,%esp
   15468:	5b                   	pop    %ebx
   15469:	5d                   	pop    %ebp
   1546a:	c3                   	ret    

0001546b <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   1546b:	55                   	push   %ebp
   1546c:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   1546e:	8b 45 08             	mov    0x8(%ebp),%eax
   15471:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15477:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1547a:	7d 0e                	jge    1548a <_SkipBits+0x1f>
   1547c:	ff 75 0c             	pushl  0xc(%ebp)
   1547f:	ff 75 08             	pushl  0x8(%ebp)
   15482:	e8 40 fe ff ff       	call   152c7 <_ShowBits>
   15487:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   1548a:	8b 45 08             	mov    0x8(%ebp),%eax
   1548d:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15493:	2b 45 0c             	sub    0xc(%ebp),%eax
   15496:	89 c2                	mov    %eax,%edx
   15498:	8b 45 08             	mov    0x8(%ebp),%eax
   1549b:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   154a1:	90                   	nop
   154a2:	c9                   	leave  
   154a3:	c3                   	ret    

000154a4 <_GetBits>:

int _GetBits(Context* ctx, int bits){
   154a4:	55                   	push   %ebp
   154a5:	89 e5                	mov    %esp,%ebp
   154a7:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   154aa:	ff 75 0c             	pushl  0xc(%ebp)
   154ad:	ff 75 08             	pushl  0x8(%ebp)
   154b0:	e8 12 fe ff ff       	call   152c7 <_ShowBits>
   154b5:	83 c4 08             	add    $0x8,%esp
   154b8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   154bb:	ff 75 0c             	pushl  0xc(%ebp)
   154be:	ff 75 08             	pushl  0x8(%ebp)
   154c1:	e8 a5 ff ff ff       	call   1546b <_SkipBits>
   154c6:	83 c4 08             	add    $0x8,%esp
    return res;
   154c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   154cc:	c9                   	leave  
   154cd:	c3                   	ret    

000154ce <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   154ce:	55                   	push   %ebp
   154cf:	89 e5                	mov    %esp,%ebp
   154d1:	57                   	push   %edi
   154d2:	56                   	push   %esi
   154d3:	53                   	push   %ebx
   154d4:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   154d7:	8b 45 08             	mov    0x8(%ebp),%eax
   154da:	83 c0 10             	add    $0x10,%eax
   154dd:	8b 00                	mov    (%eax),%eax
   154df:	c1 e0 0b             	shl    $0xb,%eax
   154e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   154e5:	8b 45 08             	mov    0x8(%ebp),%eax
   154e8:	8b 40 18             	mov    0x18(%eax),%eax
   154eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
   154ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
   154f1:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   154f4:	8b 55 08             	mov    0x8(%ebp),%edx
   154f7:	8b 52 08             	mov    0x8(%edx),%edx
   154fa:	89 55 e8             	mov    %edx,-0x18(%ebp)
   154fd:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   15500:	8b 55 08             	mov    0x8(%ebp),%edx
   15503:	8b 52 04             	mov    0x4(%edx),%edx
   15506:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   15509:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   1550c:	8b 55 08             	mov    0x8(%ebp),%edx
   1550f:	8b 52 1c             	mov    0x1c(%edx),%edx
   15512:	89 55 e0             	mov    %edx,-0x20(%ebp)
   15515:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   15518:	8b 55 08             	mov    0x8(%ebp),%edx
   1551b:	8b 52 14             	mov    0x14(%edx),%edx
   1551e:	89 55 dc             	mov    %edx,-0x24(%ebp)
   15521:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   15524:	8b 55 08             	mov    0x8(%ebp),%edx
   15527:	8b 52 0c             	mov    0xc(%edx),%edx
   1552a:	89 55 d8             	mov    %edx,-0x28(%ebp)
   1552d:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   15530:	85 c0                	test   %eax,%eax
   15532:	75 68                	jne    1559c <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   15534:	8b 45 08             	mov    0x8(%ebp),%eax
   15537:	8d 48 04             	lea    0x4(%eax),%ecx
   1553a:	8b 45 08             	mov    0x8(%ebp),%eax
   1553d:	8d 58 08             	lea    0x8(%eax),%ebx
   15540:	8b 45 08             	mov    0x8(%ebp),%eax
   15543:	8d 70 0c             	lea    0xc(%eax),%esi
   15546:	8b 45 08             	mov    0x8(%ebp),%eax
   15549:	8d 78 10             	lea    0x10(%eax),%edi
   1554c:	8b 45 08             	mov    0x8(%ebp),%eax
   1554f:	83 c0 14             	add    $0x14,%eax
   15552:	89 45 c0             	mov    %eax,-0x40(%ebp)
   15555:	8b 45 08             	mov    0x8(%ebp),%eax
   15558:	83 c0 18             	add    $0x18,%eax
   1555b:	89 45 bc             	mov    %eax,-0x44(%ebp)
   1555e:	8b 45 08             	mov    0x8(%ebp),%eax
   15561:	8d 50 1c             	lea    0x1c(%eax),%edx
   15564:	8b 45 08             	mov    0x8(%ebp),%eax
   15567:	8b 00                	mov    (%eax),%eax
   15569:	c1 e0 03             	shl    $0x3,%eax
   1556c:	89 02                	mov    %eax,(%edx)
   1556e:	8b 02                	mov    (%edx),%eax
   15570:	8b 55 bc             	mov    -0x44(%ebp),%edx
   15573:	89 02                	mov    %eax,(%edx)
   15575:	89 d0                	mov    %edx,%eax
   15577:	8b 00                	mov    (%eax),%eax
   15579:	8b 55 c0             	mov    -0x40(%ebp),%edx
   1557c:	89 02                	mov    %eax,(%edx)
   1557e:	89 d0                	mov    %edx,%eax
   15580:	8b 00                	mov    (%eax),%eax
   15582:	89 07                	mov    %eax,(%edi)
   15584:	8b 07                	mov    (%edi),%eax
   15586:	89 06                	mov    %eax,(%esi)
   15588:	8b 06                	mov    (%esi),%eax
   1558a:	89 03                	mov    %eax,(%ebx)
   1558c:	8b 03                	mov    (%ebx),%eax
   1558e:	89 01                	mov    %eax,(%ecx)
   15590:	8b 11                	mov    (%ecx),%edx
   15592:	8b 45 08             	mov    0x8(%ebp),%eax
   15595:	89 10                	mov    %edx,(%eax)
        return;
   15597:	e9 b7 01 00 00       	jmp    15753 <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   1559c:	8b 45 08             	mov    0x8(%ebp),%eax
   1559f:	8b 00                	mov    (%eax),%eax
   155a1:	c1 e0 0b             	shl    $0xb,%eax
   155a4:	83 e8 80             	sub    $0xffffff80,%eax
   155a7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   155aa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   155ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
   155b0:	01 d0                	add    %edx,%eax
   155b2:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   155b8:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   155bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   155be:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   155c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
   155c7:	01 d0                	add    %edx,%eax
   155c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   155cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
   155cf:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   155d5:	8b 45 d0             	mov    -0x30(%ebp),%eax
   155d8:	01 d0                	add    %edx,%eax
   155da:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   155dd:	8b 55 dc             	mov    -0x24(%ebp),%edx
   155e0:	8b 45 d8             	mov    -0x28(%ebp),%eax
   155e3:	01 d0                	add    %edx,%eax
   155e5:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   155eb:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   155ee:	8b 45 dc             	mov    -0x24(%ebp),%eax
   155f1:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   155f7:	8b 45 d0             	mov    -0x30(%ebp),%eax
   155fa:	01 d0                	add    %edx,%eax
   155fc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   155ff:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15602:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   15608:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1560b:	01 d0                	add    %edx,%eax
   1560d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   15610:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   15613:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15616:	01 d0                	add    %edx,%eax
   15618:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   1561b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1561e:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   15621:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15624:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15627:	01 d0                	add    %edx,%eax
   15629:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   1562f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   15632:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15635:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   1563b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1563e:	01 d0                	add    %edx,%eax
   15640:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   15643:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15646:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   1564c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1564f:	01 d0                	add    %edx,%eax
   15651:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   15654:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15657:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1565a:	01 d0                	add    %edx,%eax
   1565c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   1565f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15662:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   15665:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15668:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1566b:	01 d0                	add    %edx,%eax
   1566d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   15670:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15673:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   15676:	8b 55 d0             	mov    -0x30(%ebp),%edx
   15679:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1567c:	01 d0                	add    %edx,%eax
   1567e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   15681:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15684:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   15687:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   1568a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1568d:	01 d0                	add    %edx,%eax
   1568f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   15692:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15695:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   15698:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1569b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1569e:	01 d0                	add    %edx,%eax
   156a0:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   156a6:	83 e8 80             	sub    $0xffffff80,%eax
   156a9:	c1 f8 08             	sar    $0x8,%eax
   156ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   156af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   156b2:	2b 45 e0             	sub    -0x20(%ebp),%eax
   156b5:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   156bb:	83 e8 80             	sub    $0xffffff80,%eax
   156be:	c1 f8 08             	sar    $0x8,%eax
   156c1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   156c4:	8b 55 d8             	mov    -0x28(%ebp),%edx
   156c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   156ca:	01 d0                	add    %edx,%eax
   156cc:	c1 f8 08             	sar    $0x8,%eax
   156cf:	89 c2                	mov    %eax,%edx
   156d1:	8b 45 08             	mov    0x8(%ebp),%eax
   156d4:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   156d6:	8b 45 08             	mov    0x8(%ebp),%eax
   156d9:	83 c0 04             	add    $0x4,%eax
   156dc:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   156df:	8b 55 ec             	mov    -0x14(%ebp),%edx
   156e2:	01 ca                	add    %ecx,%edx
   156e4:	c1 fa 08             	sar    $0x8,%edx
   156e7:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   156e9:	8b 45 08             	mov    0x8(%ebp),%eax
   156ec:	83 c0 08             	add    $0x8,%eax
   156ef:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   156f2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   156f5:	01 ca                	add    %ecx,%edx
   156f7:	c1 fa 08             	sar    $0x8,%edx
   156fa:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   156fc:	8b 45 08             	mov    0x8(%ebp),%eax
   156ff:	83 c0 0c             	add    $0xc,%eax
   15702:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   15705:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15708:	01 ca                	add    %ecx,%edx
   1570a:	c1 fa 08             	sar    $0x8,%edx
   1570d:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   1570f:	8b 45 08             	mov    0x8(%ebp),%eax
   15712:	8d 50 10             	lea    0x10(%eax),%edx
   15715:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15718:	2b 45 dc             	sub    -0x24(%ebp),%eax
   1571b:	c1 f8 08             	sar    $0x8,%eax
   1571e:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   15720:	8b 45 08             	mov    0x8(%ebp),%eax
   15723:	8d 50 14             	lea    0x14(%eax),%edx
   15726:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   15729:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   1572c:	c1 f8 08             	sar    $0x8,%eax
   1572f:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   15731:	8b 45 08             	mov    0x8(%ebp),%eax
   15734:	8d 50 18             	lea    0x18(%eax),%edx
   15737:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1573a:	2b 45 ec             	sub    -0x14(%ebp),%eax
   1573d:	c1 f8 08             	sar    $0x8,%eax
   15740:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   15742:	8b 45 08             	mov    0x8(%ebp),%eax
   15745:	8d 50 1c             	lea    0x1c(%eax),%edx
   15748:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1574b:	2b 45 f0             	sub    -0x10(%ebp),%eax
   1574e:	c1 f8 08             	sar    $0x8,%eax
   15751:	89 02                	mov    %eax,(%edx)
}
   15753:	83 c4 38             	add    $0x38,%esp
   15756:	5b                   	pop    %ebx
   15757:	5e                   	pop    %esi
   15758:	5f                   	pop    %edi
   15759:	5d                   	pop    %ebp
   1575a:	c3                   	ret    

0001575b <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   1575b:	55                   	push   %ebp
   1575c:	89 e5                	mov    %esp,%ebp
   1575e:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   15761:	8b 45 08             	mov    0x8(%ebp),%eax
   15764:	83 e8 80             	sub    $0xffffff80,%eax
   15767:	8b 00                	mov    (%eax),%eax
   15769:	c1 e0 08             	shl    $0x8,%eax
   1576c:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   1576f:	8b 45 08             	mov    0x8(%ebp),%eax
   15772:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   15778:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1577b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1577e:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   15781:	8b 55 08             	mov    0x8(%ebp),%edx
   15784:	8b 52 40             	mov    0x40(%edx),%edx
   15787:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1578a:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   1578d:	8b 55 08             	mov    0x8(%ebp),%edx
   15790:	8b 52 20             	mov    0x20(%edx),%edx
   15793:	89 55 ec             	mov    %edx,-0x14(%ebp)
   15796:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   15799:	8b 55 08             	mov    0x8(%ebp),%edx
   1579c:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   157a2:	89 55 e8             	mov    %edx,-0x18(%ebp)
   157a5:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   157a8:	8b 55 08             	mov    0x8(%ebp),%edx
   157ab:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   157b1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   157b4:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   157b7:	8b 55 08             	mov    0x8(%ebp),%edx
   157ba:	8b 52 60             	mov    0x60(%edx),%edx
   157bd:	89 55 e0             	mov    %edx,-0x20(%ebp)
   157c0:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   157c3:	85 c0                	test   %eax,%eax
   157c5:	75 45                	jne    1580c <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   157c7:	8b 45 08             	mov    0x8(%ebp),%eax
   157ca:	8b 00                	mov    (%eax),%eax
   157cc:	83 c0 20             	add    $0x20,%eax
   157cf:	c1 f8 06             	sar    $0x6,%eax
   157d2:	83 e8 80             	sub    $0xffffff80,%eax
   157d5:	50                   	push   %eax
   157d6:	e8 d6 ea ff ff       	call   142b1 <_Clip>
   157db:	83 c4 04             	add    $0x4,%esp
   157de:	0f b6 c0             	movzbl %al,%eax
   157e1:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   157e4:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   157eb:	eb 14                	jmp    15801 <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   157ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
   157f0:	89 c2                	mov    %eax,%edx
   157f2:	8b 45 0c             	mov    0xc(%ebp),%eax
   157f5:	88 10                	mov    %dl,(%eax)
            out += stride;
   157f7:	8b 45 10             	mov    0x10(%ebp),%eax
   157fa:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   157fd:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   15801:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   15805:	75 e6                	jne    157ed <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   15807:	e9 57 02 00 00       	jmp    15a63 <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   1580c:	8b 45 08             	mov    0x8(%ebp),%eax
   1580f:	8b 00                	mov    (%eax),%eax
   15811:	c1 e0 08             	shl    $0x8,%eax
   15814:	05 00 20 00 00       	add    $0x2000,%eax
   15819:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   1581c:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1581f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15822:	01 d0                	add    %edx,%eax
   15824:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   1582a:	83 c0 04             	add    $0x4,%eax
   1582d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   15830:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15833:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   15839:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1583c:	01 d0                	add    %edx,%eax
   1583e:	c1 f8 03             	sar    $0x3,%eax
   15841:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   15844:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15847:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   1584d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15850:	01 d0                	add    %edx,%eax
   15852:	c1 f8 03             	sar    $0x3,%eax
   15855:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   15858:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1585b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1585e:	01 d0                	add    %edx,%eax
   15860:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   15866:	83 c0 04             	add    $0x4,%eax
   15869:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   1586c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1586f:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   15875:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15878:	01 d0                	add    %edx,%eax
   1587a:	c1 f8 03             	sar    $0x3,%eax
   1587d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   15880:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15883:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   15889:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1588c:	01 d0                	add    %edx,%eax
   1588e:	c1 f8 03             	sar    $0x3,%eax
   15891:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   15894:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15897:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1589a:	01 d0                	add    %edx,%eax
   1589c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   1589f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   158a2:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   158a5:	8b 55 f0             	mov    -0x10(%ebp),%edx
   158a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158ab:	01 d0                	add    %edx,%eax
   158ad:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   158b3:	83 c0 04             	add    $0x4,%eax
   158b6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   158b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158bc:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   158c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   158c5:	01 d0                	add    %edx,%eax
   158c7:	c1 f8 03             	sar    $0x3,%eax
   158ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   158cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158d0:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   158d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   158d9:	01 d0                	add    %edx,%eax
   158db:	c1 f8 03             	sar    $0x3,%eax
   158de:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   158e1:	8b 55 ec             	mov    -0x14(%ebp),%edx
   158e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   158e7:	01 d0                	add    %edx,%eax
   158e9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   158ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   158ef:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   158f2:	8b 55 e8             	mov    -0x18(%ebp),%edx
   158f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   158f8:	01 d0                	add    %edx,%eax
   158fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   158fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15900:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   15903:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15906:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15909:	01 d0                	add    %edx,%eax
   1590b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   1590e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15911:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   15914:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15917:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1591a:	01 d0                	add    %edx,%eax
   1591c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   1591f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15922:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   15925:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15928:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1592b:	01 d0                	add    %edx,%eax
   1592d:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15933:	83 e8 80             	sub    $0xffffff80,%eax
   15936:	c1 f8 08             	sar    $0x8,%eax
   15939:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   1593c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1593f:	2b 45 e8             	sub    -0x18(%ebp),%eax
   15942:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15948:	83 e8 80             	sub    $0xffffff80,%eax
   1594b:	c1 f8 08             	sar    $0x8,%eax
   1594e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   15951:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15954:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15957:	01 d0                	add    %edx,%eax
   15959:	c1 f8 0e             	sar    $0xe,%eax
   1595c:	83 e8 80             	sub    $0xffffff80,%eax
   1595f:	50                   	push   %eax
   15960:	e8 4c e9 ff ff       	call   142b1 <_Clip>
   15965:	83 c4 04             	add    $0x4,%esp
   15968:	89 c2                	mov    %eax,%edx
   1596a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1596d:	88 10                	mov    %dl,(%eax)
   1596f:	8b 45 10             	mov    0x10(%ebp),%eax
   15972:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   15975:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15978:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1597b:	01 d0                	add    %edx,%eax
   1597d:	c1 f8 0e             	sar    $0xe,%eax
   15980:	83 e8 80             	sub    $0xffffff80,%eax
   15983:	50                   	push   %eax
   15984:	e8 28 e9 ff ff       	call   142b1 <_Clip>
   15989:	83 c4 04             	add    $0x4,%esp
   1598c:	89 c2                	mov    %eax,%edx
   1598e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15991:	88 10                	mov    %dl,(%eax)
   15993:	8b 45 10             	mov    0x10(%ebp),%eax
   15996:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   15999:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1599c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1599f:	01 d0                	add    %edx,%eax
   159a1:	c1 f8 0e             	sar    $0xe,%eax
   159a4:	83 e8 80             	sub    $0xffffff80,%eax
   159a7:	50                   	push   %eax
   159a8:	e8 04 e9 ff ff       	call   142b1 <_Clip>
   159ad:	83 c4 04             	add    $0x4,%esp
   159b0:	89 c2                	mov    %eax,%edx
   159b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   159b5:	88 10                	mov    %dl,(%eax)
   159b7:	8b 45 10             	mov    0x10(%ebp),%eax
   159ba:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   159bd:	8b 55 dc             	mov    -0x24(%ebp),%edx
   159c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   159c3:	01 d0                	add    %edx,%eax
   159c5:	c1 f8 0e             	sar    $0xe,%eax
   159c8:	83 e8 80             	sub    $0xffffff80,%eax
   159cb:	50                   	push   %eax
   159cc:	e8 e0 e8 ff ff       	call   142b1 <_Clip>
   159d1:	83 c4 04             	add    $0x4,%esp
   159d4:	89 c2                	mov    %eax,%edx
   159d6:	8b 45 0c             	mov    0xc(%ebp),%eax
   159d9:	88 10                	mov    %dl,(%eax)
   159db:	8b 45 10             	mov    0x10(%ebp),%eax
   159de:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   159e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   159e4:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   159e7:	c1 f8 0e             	sar    $0xe,%eax
   159ea:	83 e8 80             	sub    $0xffffff80,%eax
   159ed:	50                   	push   %eax
   159ee:	e8 be e8 ff ff       	call   142b1 <_Clip>
   159f3:	83 c4 04             	add    $0x4,%esp
   159f6:	89 c2                	mov    %eax,%edx
   159f8:	8b 45 0c             	mov    0xc(%ebp),%eax
   159fb:	88 10                	mov    %dl,(%eax)
   159fd:	8b 45 10             	mov    0x10(%ebp),%eax
   15a00:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   15a03:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15a06:	2b 45 ec             	sub    -0x14(%ebp),%eax
   15a09:	c1 f8 0e             	sar    $0xe,%eax
   15a0c:	83 e8 80             	sub    $0xffffff80,%eax
   15a0f:	50                   	push   %eax
   15a10:	e8 9c e8 ff ff       	call   142b1 <_Clip>
   15a15:	83 c4 04             	add    $0x4,%esp
   15a18:	89 c2                	mov    %eax,%edx
   15a1a:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a1d:	88 10                	mov    %dl,(%eax)
   15a1f:	8b 45 10             	mov    0x10(%ebp),%eax
   15a22:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   15a25:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a28:	2b 45 f4             	sub    -0xc(%ebp),%eax
   15a2b:	c1 f8 0e             	sar    $0xe,%eax
   15a2e:	83 e8 80             	sub    $0xffffff80,%eax
   15a31:	50                   	push   %eax
   15a32:	e8 7a e8 ff ff       	call   142b1 <_Clip>
   15a37:	83 c4 04             	add    $0x4,%esp
   15a3a:	89 c2                	mov    %eax,%edx
   15a3c:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a3f:	88 10                	mov    %dl,(%eax)
   15a41:	8b 45 10             	mov    0x10(%ebp),%eax
   15a44:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   15a47:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15a4a:	2b 45 f8             	sub    -0x8(%ebp),%eax
   15a4d:	c1 f8 0e             	sar    $0xe,%eax
   15a50:	83 e8 80             	sub    $0xffffff80,%eax
   15a53:	50                   	push   %eax
   15a54:	e8 58 e8 ff ff       	call   142b1 <_Clip>
   15a59:	83 c4 04             	add    $0x4,%esp
   15a5c:	89 c2                	mov    %eax,%edx
   15a5e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a61:	88 10                	mov    %dl,(%eax)
}
   15a63:	c9                   	leave  
   15a64:	c3                   	ret    

00015a65 <_ByteAlign>:

void _ByteAlign(Context* ctx){
   15a65:	55                   	push   %ebp
   15a66:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   15a68:	8b 45 08             	mov    0x8(%ebp),%eax
   15a6b:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15a71:	25 f8 00 00 00       	and    $0xf8,%eax
   15a76:	89 c2                	mov    %eax,%edx
   15a78:	8b 45 08             	mov    0x8(%ebp),%eax
   15a7b:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   15a81:	90                   	nop
   15a82:	5d                   	pop    %ebp
   15a83:	c3                   	ret    

00015a84 <_SkipMarker>:

void _SkipMarker(Context* ctx){
   15a84:	55                   	push   %ebp
   15a85:	89 e5                	mov    %esp,%ebp
   15a87:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   15a8a:	83 ec 0c             	sub    $0xc,%esp
   15a8d:	ff 75 08             	pushl  0x8(%ebp)
   15a90:	e8 8d e8 ff ff       	call   14322 <_DecodeLength>
   15a95:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   15a98:	8b 45 08             	mov    0x8(%ebp),%eax
   15a9b:	8b 40 0c             	mov    0xc(%eax),%eax
   15a9e:	83 ec 08             	sub    $0x8,%esp
   15aa1:	50                   	push   %eax
   15aa2:	ff 75 08             	pushl  0x8(%ebp)
   15aa5:	e8 2c e8 ff ff       	call   142d6 <_Skip>
   15aaa:	83 c4 10             	add    $0x10,%esp
}
   15aad:	90                   	nop
   15aae:	c9                   	leave  
   15aaf:	c3                   	ret    

00015ab0 <_Convert>:

void _Convert(Context* ctx){
   15ab0:	55                   	push   %ebp
   15ab1:	89 e5                	mov    %esp,%ebp
   15ab3:	57                   	push   %edi
   15ab4:	56                   	push   %esi
   15ab5:	53                   	push   %ebx
   15ab6:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15ab9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   15ac0:	8b 45 08             	mov    0x8(%ebp),%eax
   15ac3:	83 c0 2c             	add    $0x2c,%eax
   15ac6:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15ac9:	e9 b2 00 00 00       	jmp    15b80 <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   15ace:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15ad1:	8b 50 0c             	mov    0xc(%eax),%edx
   15ad4:	8b 45 08             	mov    0x8(%ebp),%eax
   15ad7:	8b 40 10             	mov    0x10(%eax),%eax
   15ada:	39 c2                	cmp    %eax,%edx
   15adc:	7d 11                	jge    15aef <_Convert+0x3f>
   15ade:	83 ec 08             	sub    $0x8,%esp
   15ae1:	ff 75 e0             	pushl  -0x20(%ebp)
   15ae4:	ff 75 08             	pushl  0x8(%ebp)
   15ae7:	e8 79 02 00 00       	call   15d65 <_UpsampleH>
   15aec:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15aef:	8b 45 08             	mov    0x8(%ebp),%eax
   15af2:	8b 00                	mov    (%eax),%eax
   15af4:	85 c0                	test   %eax,%eax
   15af6:	0f 85 5d 02 00 00    	jne    15d59 <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   15afc:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15aff:	8b 50 10             	mov    0x10(%eax),%edx
   15b02:	8b 45 08             	mov    0x8(%ebp),%eax
   15b05:	8b 40 14             	mov    0x14(%eax),%eax
   15b08:	39 c2                	cmp    %eax,%edx
   15b0a:	7d 11                	jge    15b1d <_Convert+0x6d>
   15b0c:	83 ec 08             	sub    $0x8,%esp
   15b0f:	ff 75 e0             	pushl  -0x20(%ebp)
   15b12:	ff 75 08             	pushl  0x8(%ebp)
   15b15:	e8 db 05 00 00       	call   160f5 <_UpsampleV>
   15b1a:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15b1d:	8b 45 08             	mov    0x8(%ebp),%eax
   15b20:	8b 00                	mov    (%eax),%eax
   15b22:	85 c0                	test   %eax,%eax
   15b24:	0f 85 32 02 00 00    	jne    15d5c <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   15b2a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b2d:	8b 50 0c             	mov    0xc(%eax),%edx
   15b30:	8b 45 08             	mov    0x8(%ebp),%eax
   15b33:	8b 40 10             	mov    0x10(%eax),%eax
   15b36:	39 c2                	cmp    %eax,%edx
   15b38:	7c 94                	jl     15ace <_Convert+0x1e>
   15b3a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b3d:	8b 50 10             	mov    0x10(%eax),%edx
   15b40:	8b 45 08             	mov    0x8(%ebp),%eax
   15b43:	8b 40 14             	mov    0x14(%eax),%eax
   15b46:	39 c2                	cmp    %eax,%edx
   15b48:	7c 84                	jl     15ace <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   15b4a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b4d:	8b 50 0c             	mov    0xc(%eax),%edx
   15b50:	8b 45 08             	mov    0x8(%ebp),%eax
   15b53:	8b 40 10             	mov    0x10(%eax),%eax
   15b56:	39 c2                	cmp    %eax,%edx
   15b58:	7c 10                	jl     15b6a <_Convert+0xba>
   15b5a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b5d:	8b 50 10             	mov    0x10(%eax),%edx
   15b60:	8b 45 08             	mov    0x8(%ebp),%eax
   15b63:	8b 40 14             	mov    0x14(%eax),%eax
   15b66:	39 c2                	cmp    %eax,%edx
   15b68:	7d 0e                	jge    15b78 <_Convert+0xc8>
   15b6a:	8b 45 08             	mov    0x8(%ebp),%eax
   15b6d:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   15b73:	e9 e5 01 00 00       	jmp    15d5d <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15b78:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   15b7c:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   15b80:	8b 45 08             	mov    0x8(%ebp),%eax
   15b83:	8b 40 28             	mov    0x28(%eax),%eax
   15b86:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15b89:	7f 9f                	jg     15b2a <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   15b8b:	8b 45 08             	mov    0x8(%ebp),%eax
   15b8e:	8b 40 28             	mov    0x28(%eax),%eax
   15b91:	83 f8 03             	cmp    $0x3,%eax
   15b94:	0f 85 3d 01 00 00    	jne    15cd7 <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   15b9a:	8b 45 08             	mov    0x8(%ebp),%eax
   15b9d:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   15ba3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   15ba6:	8b 45 08             	mov    0x8(%ebp),%eax
   15ba9:	8b 40 54             	mov    0x54(%eax),%eax
   15bac:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   15baf:	8b 45 08             	mov    0x8(%ebp),%eax
   15bb2:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   15bb8:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   15bbb:	8b 45 08             	mov    0x8(%ebp),%eax
   15bbe:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   15bc4:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   15bc7:	8b 45 08             	mov    0x8(%ebp),%eax
   15bca:	8b 40 14             	mov    0x14(%eax),%eax
   15bcd:	89 45 d8             	mov    %eax,-0x28(%ebp)
   15bd0:	e9 f3 00 00 00       	jmp    15cc8 <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   15bd5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   15bdc:	e9 b6 00 00 00       	jmp    15c97 <_Convert+0x1e7>
                register int y = py[x] << 8;
   15be1:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15be4:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15be7:	01 d0                	add    %edx,%eax
   15be9:	0f b6 00             	movzbl (%eax),%eax
   15bec:	0f b6 c0             	movzbl %al,%eax
   15bef:	c1 e0 08             	shl    $0x8,%eax
   15bf2:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   15bf4:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15bf7:	8b 45 cc             	mov    -0x34(%ebp),%eax
   15bfa:	01 d0                	add    %edx,%eax
   15bfc:	0f b6 00             	movzbl (%eax),%eax
   15bff:	0f b6 c0             	movzbl %al,%eax
   15c02:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   15c05:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15c08:	8b 45 c8             	mov    -0x38(%ebp),%eax
   15c0b:	01 d0                	add    %edx,%eax
   15c0d:	0f b6 00             	movzbl (%eax),%eax
   15c10:	0f b6 c0             	movzbl %al,%eax
   15c13:	83 c0 80             	add    $0xffffff80,%eax
   15c16:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   15c18:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15c1b:	8d 46 01             	lea    0x1(%esi),%eax
   15c1e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15c21:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   15c24:	89 c8                	mov    %ecx,%eax
   15c26:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   15c2c:	01 d8                	add    %ebx,%eax
   15c2e:	83 e8 80             	sub    $0xffffff80,%eax
   15c31:	c1 f8 08             	sar    $0x8,%eax
   15c34:	83 ec 0c             	sub    $0xc,%esp
   15c37:	50                   	push   %eax
   15c38:	e8 74 e6 ff ff       	call   142b1 <_Clip>
   15c3d:	83 c4 10             	add    $0x10,%esp
   15c40:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   15c42:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15c45:	8d 46 01             	lea    0x1(%esi),%eax
   15c48:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15c4b:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   15c4e:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   15c51:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   15c58:	01 d0                	add    %edx,%eax
   15c5a:	83 e8 80             	sub    $0xffffff80,%eax
   15c5d:	c1 f8 08             	sar    $0x8,%eax
   15c60:	83 ec 0c             	sub    $0xc,%esp
   15c63:	50                   	push   %eax
   15c64:	e8 48 e6 ff ff       	call   142b1 <_Clip>
   15c69:	83 c4 10             	add    $0x10,%esp
   15c6c:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   15c6e:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15c71:	8d 46 01             	lea    0x1(%esi),%eax
   15c74:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15c77:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   15c7d:	01 d8                	add    %ebx,%eax
   15c7f:	83 e8 80             	sub    $0xffffff80,%eax
   15c82:	c1 f8 08             	sar    $0x8,%eax
   15c85:	83 ec 0c             	sub    $0xc,%esp
   15c88:	50                   	push   %eax
   15c89:	e8 23 e6 ff ff       	call   142b1 <_Clip>
   15c8e:	83 c4 10             	add    $0x10,%esp
   15c91:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   15c93:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   15c97:	8b 45 08             	mov    0x8(%ebp),%eax
   15c9a:	8b 40 10             	mov    0x10(%eax),%eax
   15c9d:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   15ca0:	0f 8f 3b ff ff ff    	jg     15be1 <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   15ca6:	8b 45 08             	mov    0x8(%ebp),%eax
   15ca9:	8b 40 40             	mov    0x40(%eax),%eax
   15cac:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   15caf:	8b 45 08             	mov    0x8(%ebp),%eax
   15cb2:	8b 40 6c             	mov    0x6c(%eax),%eax
   15cb5:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   15cb8:	8b 45 08             	mov    0x8(%ebp),%eax
   15cbb:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   15cc1:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   15cc4:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   15cc8:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15ccc:	0f 85 03 ff ff ff    	jne    15bd5 <_Convert+0x125>
   15cd2:	e9 86 00 00 00       	jmp    15d5d <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   15cd7:	8b 45 08             	mov    0x8(%ebp),%eax
   15cda:	8b 50 38             	mov    0x38(%eax),%edx
   15cdd:	8b 45 08             	mov    0x8(%ebp),%eax
   15ce0:	8b 40 40             	mov    0x40(%eax),%eax
   15ce3:	39 c2                	cmp    %eax,%edx
   15ce5:	74 76                	je     15d5d <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   15ce7:	8b 45 08             	mov    0x8(%ebp),%eax
   15cea:	8b 50 54             	mov    0x54(%eax),%edx
   15ced:	8b 45 08             	mov    0x8(%ebp),%eax
   15cf0:	8b 40 40             	mov    0x40(%eax),%eax
   15cf3:	01 d0                	add    %edx,%eax
   15cf5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   15cf8:	8b 45 08             	mov    0x8(%ebp),%eax
   15cfb:	8b 50 54             	mov    0x54(%eax),%edx
   15cfe:	8b 45 08             	mov    0x8(%ebp),%eax
   15d01:	8b 40 38             	mov    0x38(%eax),%eax
   15d04:	01 d0                	add    %edx,%eax
   15d06:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   15d09:	8b 45 08             	mov    0x8(%ebp),%eax
   15d0c:	8b 40 3c             	mov    0x3c(%eax),%eax
   15d0f:	83 e8 01             	sub    $0x1,%eax
   15d12:	89 45 bc             	mov    %eax,-0x44(%ebp)
   15d15:	eb 2e                	jmp    15d45 <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   15d17:	8b 45 08             	mov    0x8(%ebp),%eax
   15d1a:	8b 40 38             	mov    0x38(%eax),%eax
   15d1d:	83 ec 04             	sub    $0x4,%esp
   15d20:	50                   	push   %eax
   15d21:	ff 75 c4             	pushl  -0x3c(%ebp)
   15d24:	ff 75 c0             	pushl  -0x40(%ebp)
   15d27:	e8 72 ac fe ff       	call   99e <memmove>
   15d2c:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   15d2f:	8b 45 08             	mov    0x8(%ebp),%eax
   15d32:	8b 40 40             	mov    0x40(%eax),%eax
   15d35:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   15d38:	8b 45 08             	mov    0x8(%ebp),%eax
   15d3b:	8b 40 38             	mov    0x38(%eax),%eax
   15d3e:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   15d41:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   15d45:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   15d49:	75 cc                	jne    15d17 <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   15d4b:	8b 45 08             	mov    0x8(%ebp),%eax
   15d4e:	8b 50 38             	mov    0x38(%eax),%edx
   15d51:	8b 45 08             	mov    0x8(%ebp),%eax
   15d54:	89 50 40             	mov    %edx,0x40(%eax)
   15d57:	eb 04                	jmp    15d5d <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   15d59:	90                   	nop
   15d5a:	eb 01                	jmp    15d5d <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   15d5c:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   15d5d:	8d 65 f4             	lea    -0xc(%ebp),%esp
   15d60:	5b                   	pop    %ebx
   15d61:	5e                   	pop    %esi
   15d62:	5f                   	pop    %edi
   15d63:	5d                   	pop    %ebp
   15d64:	c3                   	ret    

00015d65 <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   15d65:	55                   	push   %ebp
   15d66:	89 e5                	mov    %esp,%ebp
   15d68:	53                   	push   %ebx
   15d69:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   15d6c:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d6f:	8b 40 0c             	mov    0xc(%eax),%eax
   15d72:	83 e8 03             	sub    $0x3,%eax
   15d75:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15d78:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d7b:	8b 50 0c             	mov    0xc(%eax),%edx
   15d7e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d81:	8b 40 10             	mov    0x10(%eax),%eax
   15d84:	0f af c2             	imul   %edx,%eax
   15d87:	01 c0                	add    %eax,%eax
   15d89:	83 ec 0c             	sub    $0xc,%esp
   15d8c:	50                   	push   %eax
   15d8d:	e8 cb b0 fe ff       	call   e5d <malloc>
   15d92:	83 c4 10             	add    $0x10,%esp
   15d95:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15d98:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15d9c:	75 0e                	jne    15dac <_UpsampleH+0x47>
   15d9e:	8b 45 08             	mov    0x8(%ebp),%eax
   15da1:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15da7:	e9 44 03 00 00       	jmp    160f0 <_UpsampleH+0x38b>
    lin = c->pixels;
   15dac:	8b 45 0c             	mov    0xc(%ebp),%eax
   15daf:	8b 40 28             	mov    0x28(%eax),%eax
   15db2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   15db5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15db8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   15dbb:	8b 45 0c             	mov    0xc(%ebp),%eax
   15dbe:	8b 40 10             	mov    0x10(%eax),%eax
   15dc1:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   15dc4:	e9 e0 02 00 00       	jmp    160a9 <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   15dc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dcc:	0f b6 00             	movzbl (%eax),%eax
   15dcf:	0f b6 c0             	movzbl %al,%eax
   15dd2:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15dd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ddb:	83 c0 01             	add    $0x1,%eax
   15dde:	0f b6 00             	movzbl (%eax),%eax
   15de1:	0f b6 c0             	movzbl %al,%eax
   15de4:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15de7:	01 d0                	add    %edx,%eax
   15de9:	83 ec 0c             	sub    $0xc,%esp
   15dec:	50                   	push   %eax
   15ded:	e8 c4 06 00 00       	call   164b6 <CF>
   15df2:	83 c4 10             	add    $0x10,%esp
   15df5:	89 c2                	mov    %eax,%edx
   15df7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15dfa:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   15dfc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15dff:	8d 58 01             	lea    0x1(%eax),%ebx
   15e02:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e05:	0f b6 00             	movzbl (%eax),%eax
   15e08:	0f b6 c0             	movzbl %al,%eax
   15e0b:	6b c8 68             	imul   $0x68,%eax,%ecx
   15e0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e11:	83 c0 01             	add    $0x1,%eax
   15e14:	0f b6 00             	movzbl (%eax),%eax
   15e17:	0f b6 d0             	movzbl %al,%edx
   15e1a:	89 d0                	mov    %edx,%eax
   15e1c:	01 c0                	add    %eax,%eax
   15e1e:	01 d0                	add    %edx,%eax
   15e20:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15e27:	01 d0                	add    %edx,%eax
   15e29:	01 c1                	add    %eax,%ecx
   15e2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e2e:	83 c0 02             	add    $0x2,%eax
   15e31:	0f b6 00             	movzbl (%eax),%eax
   15e34:	0f b6 d0             	movzbl %al,%edx
   15e37:	89 d0                	mov    %edx,%eax
   15e39:	01 c0                	add    %eax,%eax
   15e3b:	01 d0                	add    %edx,%eax
   15e3d:	f7 d8                	neg    %eax
   15e3f:	01 c8                	add    %ecx,%eax
   15e41:	83 ec 0c             	sub    $0xc,%esp
   15e44:	50                   	push   %eax
   15e45:	e8 6c 06 00 00       	call   164b6 <CF>
   15e4a:	83 c4 10             	add    $0x10,%esp
   15e4d:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   15e4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e52:	8d 58 02             	lea    0x2(%eax),%ebx
   15e55:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e58:	0f b6 00             	movzbl (%eax),%eax
   15e5b:	0f b6 c0             	movzbl %al,%eax
   15e5e:	c1 e0 02             	shl    $0x2,%eax
   15e61:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15e68:	29 c2                	sub    %eax,%edx
   15e6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e6d:	83 c0 01             	add    $0x1,%eax
   15e70:	0f b6 00             	movzbl (%eax),%eax
   15e73:	0f b6 c0             	movzbl %al,%eax
   15e76:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15e79:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15e7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e7f:	83 c0 02             	add    $0x2,%eax
   15e82:	0f b6 00             	movzbl (%eax),%eax
   15e85:	0f b6 d0             	movzbl %al,%edx
   15e88:	89 d0                	mov    %edx,%eax
   15e8a:	c1 e0 03             	shl    $0x3,%eax
   15e8d:	01 d0                	add    %edx,%eax
   15e8f:	f7 d8                	neg    %eax
   15e91:	01 c8                	add    %ecx,%eax
   15e93:	83 ec 0c             	sub    $0xc,%esp
   15e96:	50                   	push   %eax
   15e97:	e8 1a 06 00 00       	call   164b6 <CF>
   15e9c:	83 c4 10             	add    $0x10,%esp
   15e9f:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   15ea1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15ea8:	e9 fa 00 00 00       	jmp    15fa7 <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   15ead:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15eb0:	01 c0                	add    %eax,%eax
   15eb2:	8d 50 03             	lea    0x3(%eax),%edx
   15eb5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15eb8:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15ebb:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15ebe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ec1:	01 d0                	add    %edx,%eax
   15ec3:	0f b6 00             	movzbl (%eax),%eax
   15ec6:	0f b6 d0             	movzbl %al,%edx
   15ec9:	89 d0                	mov    %edx,%eax
   15ecb:	c1 e0 03             	shl    $0x3,%eax
   15ece:	01 d0                	add    %edx,%eax
   15ed0:	f7 d8                	neg    %eax
   15ed2:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15ed5:	8d 4a 01             	lea    0x1(%edx),%ecx
   15ed8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15edb:	01 ca                	add    %ecx,%edx
   15edd:	0f b6 12             	movzbl (%edx),%edx
   15ee0:	0f b6 d2             	movzbl %dl,%edx
   15ee3:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15ee6:	01 c2                	add    %eax,%edx
   15ee8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15eeb:	8d 48 02             	lea    0x2(%eax),%ecx
   15eee:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ef1:	01 c8                	add    %ecx,%eax
   15ef3:	0f b6 00             	movzbl (%eax),%eax
   15ef6:	0f b6 c0             	movzbl %al,%eax
   15ef9:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15efc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15eff:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15f02:	8d 50 03             	lea    0x3(%eax),%edx
   15f05:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f08:	01 d0                	add    %edx,%eax
   15f0a:	0f b6 00             	movzbl (%eax),%eax
   15f0d:	0f b6 d0             	movzbl %al,%edx
   15f10:	89 d0                	mov    %edx,%eax
   15f12:	01 c0                	add    %eax,%eax
   15f14:	01 d0                	add    %edx,%eax
   15f16:	f7 d8                	neg    %eax
   15f18:	01 c8                	add    %ecx,%eax
   15f1a:	83 ec 0c             	sub    $0xc,%esp
   15f1d:	50                   	push   %eax
   15f1e:	e8 93 05 00 00       	call   164b6 <CF>
   15f23:	83 c4 10             	add    $0x10,%esp
   15f26:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   15f28:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15f2b:	01 c0                	add    %eax,%eax
   15f2d:	8d 50 04             	lea    0x4(%eax),%edx
   15f30:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15f33:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15f36:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15f39:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f3c:	01 d0                	add    %edx,%eax
   15f3e:	0f b6 00             	movzbl (%eax),%eax
   15f41:	0f b6 d0             	movzbl %al,%edx
   15f44:	89 d0                	mov    %edx,%eax
   15f46:	01 c0                	add    %eax,%eax
   15f48:	01 d0                	add    %edx,%eax
   15f4a:	f7 d8                	neg    %eax
   15f4c:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15f4f:	8d 4a 01             	lea    0x1(%edx),%ecx
   15f52:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15f55:	01 ca                	add    %ecx,%edx
   15f57:	0f b6 12             	movzbl (%edx),%edx
   15f5a:	0f b6 d2             	movzbl %dl,%edx
   15f5d:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15f60:	01 c2                	add    %eax,%edx
   15f62:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15f65:	8d 48 02             	lea    0x2(%eax),%ecx
   15f68:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f6b:	01 c8                	add    %ecx,%eax
   15f6d:	0f b6 00             	movzbl (%eax),%eax
   15f70:	0f b6 c0             	movzbl %al,%eax
   15f73:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15f76:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15f79:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15f7c:	8d 50 03             	lea    0x3(%eax),%edx
   15f7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f82:	01 d0                	add    %edx,%eax
   15f84:	0f b6 00             	movzbl (%eax),%eax
   15f87:	0f b6 d0             	movzbl %al,%edx
   15f8a:	89 d0                	mov    %edx,%eax
   15f8c:	c1 e0 03             	shl    $0x3,%eax
   15f8f:	01 d0                	add    %edx,%eax
   15f91:	f7 d8                	neg    %eax
   15f93:	01 c8                	add    %ecx,%eax
   15f95:	83 ec 0c             	sub    $0xc,%esp
   15f98:	50                   	push   %eax
   15f99:	e8 18 05 00 00       	call   164b6 <CF>
   15f9e:	83 c4 10             	add    $0x10,%esp
   15fa1:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   15fa3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15fa7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15faa:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15fad:	0f 8c fa fe ff ff    	jl     15ead <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   15fb3:	8b 45 0c             	mov    0xc(%ebp),%eax
   15fb6:	8b 40 14             	mov    0x14(%eax),%eax
   15fb9:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   15fbc:	8b 45 0c             	mov    0xc(%ebp),%eax
   15fbf:	8b 40 0c             	mov    0xc(%eax),%eax
   15fc2:	01 c0                	add    %eax,%eax
   15fc4:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   15fc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15fca:	8d 58 fd             	lea    -0x3(%eax),%ebx
   15fcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15fd0:	83 e8 01             	sub    $0x1,%eax
   15fd3:	0f b6 00             	movzbl (%eax),%eax
   15fd6:	0f b6 c0             	movzbl %al,%eax
   15fd9:	c1 e0 02             	shl    $0x2,%eax
   15fdc:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15fe3:	29 c2                	sub    %eax,%edx
   15fe5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15fe8:	83 e8 02             	sub    $0x2,%eax
   15feb:	0f b6 00             	movzbl (%eax),%eax
   15fee:	0f b6 c0             	movzbl %al,%eax
   15ff1:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15ff4:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15ff7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ffa:	83 e8 03             	sub    $0x3,%eax
   15ffd:	0f b6 00             	movzbl (%eax),%eax
   16000:	0f b6 d0             	movzbl %al,%edx
   16003:	89 d0                	mov    %edx,%eax
   16005:	c1 e0 03             	shl    $0x3,%eax
   16008:	01 d0                	add    %edx,%eax
   1600a:	f7 d8                	neg    %eax
   1600c:	01 c8                	add    %ecx,%eax
   1600e:	83 ec 0c             	sub    $0xc,%esp
   16011:	50                   	push   %eax
   16012:	e8 9f 04 00 00       	call   164b6 <CF>
   16017:	83 c4 10             	add    $0x10,%esp
   1601a:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   1601c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1601f:	8d 58 fe             	lea    -0x2(%eax),%ebx
   16022:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16025:	83 e8 01             	sub    $0x1,%eax
   16028:	0f b6 00             	movzbl (%eax),%eax
   1602b:	0f b6 c0             	movzbl %al,%eax
   1602e:	6b c8 68             	imul   $0x68,%eax,%ecx
   16031:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16034:	83 e8 02             	sub    $0x2,%eax
   16037:	0f b6 00             	movzbl (%eax),%eax
   1603a:	0f b6 d0             	movzbl %al,%edx
   1603d:	89 d0                	mov    %edx,%eax
   1603f:	01 c0                	add    %eax,%eax
   16041:	01 d0                	add    %edx,%eax
   16043:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1604a:	01 d0                	add    %edx,%eax
   1604c:	01 c1                	add    %eax,%ecx
   1604e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16051:	83 e8 03             	sub    $0x3,%eax
   16054:	0f b6 00             	movzbl (%eax),%eax
   16057:	0f b6 d0             	movzbl %al,%edx
   1605a:	89 d0                	mov    %edx,%eax
   1605c:	01 c0                	add    %eax,%eax
   1605e:	01 d0                	add    %edx,%eax
   16060:	f7 d8                	neg    %eax
   16062:	01 c8                	add    %ecx,%eax
   16064:	83 ec 0c             	sub    $0xc,%esp
   16067:	50                   	push   %eax
   16068:	e8 49 04 00 00       	call   164b6 <CF>
   1606d:	83 c4 10             	add    $0x10,%esp
   16070:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   16072:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16075:	8d 58 ff             	lea    -0x1(%eax),%ebx
   16078:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1607b:	83 e8 01             	sub    $0x1,%eax
   1607e:	0f b6 00             	movzbl (%eax),%eax
   16081:	0f b6 c0             	movzbl %al,%eax
   16084:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   1608a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1608d:	83 e8 02             	sub    $0x2,%eax
   16090:	0f b6 00             	movzbl (%eax),%eax
   16093:	0f b6 c0             	movzbl %al,%eax
   16096:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   16099:	01 d0                	add    %edx,%eax
   1609b:	83 ec 0c             	sub    $0xc,%esp
   1609e:	50                   	push   %eax
   1609f:	e8 12 04 00 00       	call   164b6 <CF>
   160a4:	83 c4 10             	add    $0x10,%esp
   160a7:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   160a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   160ac:	8d 50 ff             	lea    -0x1(%eax),%edx
   160af:	89 55 e8             	mov    %edx,-0x18(%ebp)
   160b2:	85 c0                	test   %eax,%eax
   160b4:	0f 85 0f fd ff ff    	jne    15dc9 <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   160ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   160bd:	8b 40 0c             	mov    0xc(%eax),%eax
   160c0:	8d 14 00             	lea    (%eax,%eax,1),%edx
   160c3:	8b 45 0c             	mov    0xc(%ebp),%eax
   160c6:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   160c9:	8b 45 0c             	mov    0xc(%ebp),%eax
   160cc:	8b 50 0c             	mov    0xc(%eax),%edx
   160cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   160d2:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   160d5:	8b 45 0c             	mov    0xc(%ebp),%eax
   160d8:	8b 40 28             	mov    0x28(%eax),%eax
   160db:	83 ec 0c             	sub    $0xc,%esp
   160de:	50                   	push   %eax
   160df:	e8 37 ac fe ff       	call   d1b <free>
   160e4:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   160e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   160ea:	8b 55 e0             	mov    -0x20(%ebp),%edx
   160ed:	89 50 28             	mov    %edx,0x28(%eax)
}
   160f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   160f3:	c9                   	leave  
   160f4:	c3                   	ret    

000160f5 <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   160f5:	55                   	push   %ebp
   160f6:	89 e5                	mov    %esp,%ebp
   160f8:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   160fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   160fe:	8b 40 0c             	mov    0xc(%eax),%eax
   16101:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   16104:	8b 45 0c             	mov    0xc(%ebp),%eax
   16107:	8b 40 14             	mov    0x14(%eax),%eax
   1610a:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1610d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16110:	01 c0                	add    %eax,%eax
   16112:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   16115:	8b 45 0c             	mov    0xc(%ebp),%eax
   16118:	8b 50 0c             	mov    0xc(%eax),%edx
   1611b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1611e:	8b 40 10             	mov    0x10(%eax),%eax
   16121:	0f af c2             	imul   %edx,%eax
   16124:	01 c0                	add    %eax,%eax
   16126:	83 ec 0c             	sub    $0xc,%esp
   16129:	50                   	push   %eax
   1612a:	e8 2e ad fe ff       	call   e5d <malloc>
   1612f:	83 c4 10             	add    $0x10,%esp
   16132:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   16135:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   16139:	75 0e                	jne    16149 <_UpsampleV+0x54>
   1613b:	8b 45 08             	mov    0x8(%ebp),%eax
   1613e:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   16144:	e9 6b 03 00 00       	jmp    164b4 <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   16149:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   16150:	e9 1d 03 00 00       	jmp    16472 <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   16155:	8b 45 0c             	mov    0xc(%ebp),%eax
   16158:	8b 50 28             	mov    0x28(%eax),%edx
   1615b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1615e:	01 d0                	add    %edx,%eax
   16160:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   16163:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16166:	8b 45 d8             	mov    -0x28(%ebp),%eax
   16169:	01 d0                	add    %edx,%eax
   1616b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   1616e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16171:	0f b6 00             	movzbl (%eax),%eax
   16174:	0f b6 c0             	movzbl %al,%eax
   16177:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   1617d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   16180:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16183:	01 c8                	add    %ecx,%eax
   16185:	0f b6 00             	movzbl (%eax),%eax
   16188:	0f b6 c0             	movzbl %al,%eax
   1618b:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   1618e:	01 d0                	add    %edx,%eax
   16190:	83 ec 0c             	sub    $0xc,%esp
   16193:	50                   	push   %eax
   16194:	e8 1d 03 00 00       	call   164b6 <CF>
   16199:	83 c4 10             	add    $0x10,%esp
   1619c:	89 c2                	mov    %eax,%edx
   1619e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   161a1:	88 10                	mov    %dl,(%eax)
   161a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   161a6:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   161a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   161ac:	0f b6 00             	movzbl (%eax),%eax
   161af:	0f b6 c0             	movzbl %al,%eax
   161b2:	6b c8 68             	imul   $0x68,%eax,%ecx
   161b5:	8b 55 e0             	mov    -0x20(%ebp),%edx
   161b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   161bb:	01 d0                	add    %edx,%eax
   161bd:	0f b6 00             	movzbl (%eax),%eax
   161c0:	0f b6 d0             	movzbl %al,%edx
   161c3:	89 d0                	mov    %edx,%eax
   161c5:	01 c0                	add    %eax,%eax
   161c7:	01 d0                	add    %edx,%eax
   161c9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   161d0:	01 d0                	add    %edx,%eax
   161d2:	01 c1                	add    %eax,%ecx
   161d4:	8b 55 dc             	mov    -0x24(%ebp),%edx
   161d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   161da:	01 d0                	add    %edx,%eax
   161dc:	0f b6 00             	movzbl (%eax),%eax
   161df:	0f b6 d0             	movzbl %al,%edx
   161e2:	89 d0                	mov    %edx,%eax
   161e4:	01 c0                	add    %eax,%eax
   161e6:	01 d0                	add    %edx,%eax
   161e8:	f7 d8                	neg    %eax
   161ea:	01 c8                	add    %ecx,%eax
   161ec:	83 ec 0c             	sub    $0xc,%esp
   161ef:	50                   	push   %eax
   161f0:	e8 c1 02 00 00       	call   164b6 <CF>
   161f5:	83 c4 10             	add    $0x10,%esp
   161f8:	89 c2                	mov    %eax,%edx
   161fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
   161fd:	88 10                	mov    %dl,(%eax)
   161ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16202:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   16205:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16208:	0f b6 00             	movzbl (%eax),%eax
   1620b:	0f b6 c0             	movzbl %al,%eax
   1620e:	c1 e0 02             	shl    $0x2,%eax
   16211:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16218:	89 d1                	mov    %edx,%ecx
   1621a:	29 c1                	sub    %eax,%ecx
   1621c:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1621f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16222:	01 d0                	add    %edx,%eax
   16224:	0f b6 00             	movzbl (%eax),%eax
   16227:	0f b6 c0             	movzbl %al,%eax
   1622a:	6b c0 6d             	imul   $0x6d,%eax,%eax
   1622d:	01 c1                	add    %eax,%ecx
   1622f:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16232:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16235:	01 d0                	add    %edx,%eax
   16237:	0f b6 00             	movzbl (%eax),%eax
   1623a:	0f b6 d0             	movzbl %al,%edx
   1623d:	89 d0                	mov    %edx,%eax
   1623f:	c1 e0 03             	shl    $0x3,%eax
   16242:	01 d0                	add    %edx,%eax
   16244:	f7 d8                	neg    %eax
   16246:	01 c8                	add    %ecx,%eax
   16248:	83 ec 0c             	sub    $0xc,%esp
   1624b:	50                   	push   %eax
   1624c:	e8 65 02 00 00       	call   164b6 <CF>
   16251:	83 c4 10             	add    $0x10,%esp
   16254:	89 c2                	mov    %eax,%edx
   16256:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16259:	88 10                	mov    %dl,(%eax)
   1625b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1625e:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   16261:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16264:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   16267:	8b 45 0c             	mov    0xc(%ebp),%eax
   1626a:	8b 40 10             	mov    0x10(%eax),%eax
   1626d:	83 e8 03             	sub    $0x3,%eax
   16270:	89 45 e8             	mov    %eax,-0x18(%ebp)
   16273:	e9 e6 00 00 00       	jmp    1635e <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   16278:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1627b:	f7 d8                	neg    %eax
   1627d:	89 c2                	mov    %eax,%edx
   1627f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16282:	01 d0                	add    %edx,%eax
   16284:	0f b6 00             	movzbl (%eax),%eax
   16287:	0f b6 d0             	movzbl %al,%edx
   1628a:	89 d0                	mov    %edx,%eax
   1628c:	c1 e0 03             	shl    $0x3,%eax
   1628f:	01 d0                	add    %edx,%eax
   16291:	f7 d8                	neg    %eax
   16293:	8b 55 f4             	mov    -0xc(%ebp),%edx
   16296:	0f b6 12             	movzbl (%edx),%edx
   16299:	0f b6 d2             	movzbl %dl,%edx
   1629c:	6b d2 6f             	imul   $0x6f,%edx,%edx
   1629f:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   162a2:	8b 55 e0             	mov    -0x20(%ebp),%edx
   162a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   162a8:	01 d0                	add    %edx,%eax
   162aa:	0f b6 00             	movzbl (%eax),%eax
   162ad:	0f b6 c0             	movzbl %al,%eax
   162b0:	6b c0 1d             	imul   $0x1d,%eax,%eax
   162b3:	01 c1                	add    %eax,%ecx
   162b5:	8b 55 dc             	mov    -0x24(%ebp),%edx
   162b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   162bb:	01 d0                	add    %edx,%eax
   162bd:	0f b6 00             	movzbl (%eax),%eax
   162c0:	0f b6 d0             	movzbl %al,%edx
   162c3:	89 d0                	mov    %edx,%eax
   162c5:	01 c0                	add    %eax,%eax
   162c7:	01 d0                	add    %edx,%eax
   162c9:	f7 d8                	neg    %eax
   162cb:	01 c8                	add    %ecx,%eax
   162cd:	83 ec 0c             	sub    $0xc,%esp
   162d0:	50                   	push   %eax
   162d1:	e8 e0 01 00 00       	call   164b6 <CF>
   162d6:	83 c4 10             	add    $0x10,%esp
   162d9:	89 c2                	mov    %eax,%edx
   162db:	8b 45 f0             	mov    -0x10(%ebp),%eax
   162de:	88 10                	mov    %dl,(%eax)
   162e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   162e3:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   162e6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   162e9:	f7 d8                	neg    %eax
   162eb:	89 c2                	mov    %eax,%edx
   162ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
   162f0:	01 d0                	add    %edx,%eax
   162f2:	0f b6 00             	movzbl (%eax),%eax
   162f5:	0f b6 d0             	movzbl %al,%edx
   162f8:	89 d0                	mov    %edx,%eax
   162fa:	01 c0                	add    %eax,%eax
   162fc:	01 d0                	add    %edx,%eax
   162fe:	f7 d8                	neg    %eax
   16300:	8b 55 f4             	mov    -0xc(%ebp),%edx
   16303:	0f b6 12             	movzbl (%edx),%edx
   16306:	0f b6 d2             	movzbl %dl,%edx
   16309:	6b d2 1d             	imul   $0x1d,%edx,%edx
   1630c:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   1630f:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16312:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16315:	01 d0                	add    %edx,%eax
   16317:	0f b6 00             	movzbl (%eax),%eax
   1631a:	0f b6 c0             	movzbl %al,%eax
   1631d:	6b c0 6f             	imul   $0x6f,%eax,%eax
   16320:	01 c1                	add    %eax,%ecx
   16322:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16325:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16328:	01 d0                	add    %edx,%eax
   1632a:	0f b6 00             	movzbl (%eax),%eax
   1632d:	0f b6 d0             	movzbl %al,%edx
   16330:	89 d0                	mov    %edx,%eax
   16332:	c1 e0 03             	shl    $0x3,%eax
   16335:	01 d0                	add    %edx,%eax
   16337:	f7 d8                	neg    %eax
   16339:	01 c8                	add    %ecx,%eax
   1633b:	83 ec 0c             	sub    $0xc,%esp
   1633e:	50                   	push   %eax
   1633f:	e8 72 01 00 00       	call   164b6 <CF>
   16344:	83 c4 10             	add    $0x10,%esp
   16347:	89 c2                	mov    %eax,%edx
   16349:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1634c:	88 10                	mov    %dl,(%eax)
   1634e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16351:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   16354:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16357:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   1635a:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   1635e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   16362:	0f 85 10 ff ff ff    	jne    16278 <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   16368:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1636b:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   1636e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16371:	0f b6 00             	movzbl (%eax),%eax
   16374:	0f b6 c0             	movzbl %al,%eax
   16377:	c1 e0 02             	shl    $0x2,%eax
   1637a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16381:	29 c2                	sub    %eax,%edx
   16383:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16386:	f7 d8                	neg    %eax
   16388:	89 c1                	mov    %eax,%ecx
   1638a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1638d:	01 c8                	add    %ecx,%eax
   1638f:	0f b6 00             	movzbl (%eax),%eax
   16392:	0f b6 c0             	movzbl %al,%eax
   16395:	6b c0 6d             	imul   $0x6d,%eax,%eax
   16398:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1639b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1639e:	f7 d8                	neg    %eax
   163a0:	89 c2                	mov    %eax,%edx
   163a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   163a5:	01 d0                	add    %edx,%eax
   163a7:	0f b6 00             	movzbl (%eax),%eax
   163aa:	0f b6 d0             	movzbl %al,%edx
   163ad:	89 d0                	mov    %edx,%eax
   163af:	c1 e0 03             	shl    $0x3,%eax
   163b2:	01 d0                	add    %edx,%eax
   163b4:	f7 d8                	neg    %eax
   163b6:	01 c8                	add    %ecx,%eax
   163b8:	83 ec 0c             	sub    $0xc,%esp
   163bb:	50                   	push   %eax
   163bc:	e8 f5 00 00 00       	call   164b6 <CF>
   163c1:	83 c4 10             	add    $0x10,%esp
   163c4:	89 c2                	mov    %eax,%edx
   163c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   163c9:	88 10                	mov    %dl,(%eax)
   163cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   163ce:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   163d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   163d4:	0f b6 00             	movzbl (%eax),%eax
   163d7:	0f b6 c0             	movzbl %al,%eax
   163da:	6b c8 68             	imul   $0x68,%eax,%ecx
   163dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   163e0:	f7 d8                	neg    %eax
   163e2:	89 c2                	mov    %eax,%edx
   163e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   163e7:	01 d0                	add    %edx,%eax
   163e9:	0f b6 00             	movzbl (%eax),%eax
   163ec:	0f b6 d0             	movzbl %al,%edx
   163ef:	89 d0                	mov    %edx,%eax
   163f1:	01 c0                	add    %eax,%eax
   163f3:	01 d0                	add    %edx,%eax
   163f5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   163fc:	01 d0                	add    %edx,%eax
   163fe:	01 c1                	add    %eax,%ecx
   16400:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16403:	f7 d8                	neg    %eax
   16405:	89 c2                	mov    %eax,%edx
   16407:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1640a:	01 d0                	add    %edx,%eax
   1640c:	0f b6 00             	movzbl (%eax),%eax
   1640f:	0f b6 d0             	movzbl %al,%edx
   16412:	89 d0                	mov    %edx,%eax
   16414:	01 c0                	add    %eax,%eax
   16416:	01 d0                	add    %edx,%eax
   16418:	f7 d8                	neg    %eax
   1641a:	01 c8                	add    %ecx,%eax
   1641c:	83 ec 0c             	sub    $0xc,%esp
   1641f:	50                   	push   %eax
   16420:	e8 91 00 00 00       	call   164b6 <CF>
   16425:	83 c4 10             	add    $0x10,%esp
   16428:	89 c2                	mov    %eax,%edx
   1642a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1642d:	88 10                	mov    %dl,(%eax)
   1642f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16432:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   16435:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16438:	0f b6 00             	movzbl (%eax),%eax
   1643b:	0f b6 c0             	movzbl %al,%eax
   1643e:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   16444:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16447:	f7 d8                	neg    %eax
   16449:	89 c1                	mov    %eax,%ecx
   1644b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1644e:	01 c8                	add    %ecx,%eax
   16450:	0f b6 00             	movzbl (%eax),%eax
   16453:	0f b6 c0             	movzbl %al,%eax
   16456:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   16459:	01 d0                	add    %edx,%eax
   1645b:	83 ec 0c             	sub    $0xc,%esp
   1645e:	50                   	push   %eax
   1645f:	e8 52 00 00 00       	call   164b6 <CF>
   16464:	83 c4 10             	add    $0x10,%esp
   16467:	89 c2                	mov    %eax,%edx
   16469:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1646c:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   1646e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   16472:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16475:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   16478:	0f 8c d7 fc ff ff    	jl     16155 <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   1647e:	8b 45 0c             	mov    0xc(%ebp),%eax
   16481:	8b 40 10             	mov    0x10(%eax),%eax
   16484:	8d 14 00             	lea    (%eax,%eax,1),%edx
   16487:	8b 45 0c             	mov    0xc(%ebp),%eax
   1648a:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   1648d:	8b 45 0c             	mov    0xc(%ebp),%eax
   16490:	8b 50 0c             	mov    0xc(%eax),%edx
   16493:	8b 45 0c             	mov    0xc(%ebp),%eax
   16496:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   16499:	8b 45 0c             	mov    0xc(%ebp),%eax
   1649c:	8b 40 28             	mov    0x28(%eax),%eax
   1649f:	83 ec 0c             	sub    $0xc,%esp
   164a2:	50                   	push   %eax
   164a3:	e8 73 a8 fe ff       	call   d1b <free>
   164a8:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   164ab:	8b 45 0c             	mov    0xc(%ebp),%eax
   164ae:	8b 55 d8             	mov    -0x28(%ebp),%edx
   164b1:	89 50 28             	mov    %edx,0x28(%eax)
}
   164b4:	c9                   	leave  
   164b5:	c3                   	ret    

000164b6 <CF>:

uchar CF(const int x){
   164b6:	55                   	push   %ebp
   164b7:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   164b9:	8b 45 08             	mov    0x8(%ebp),%eax
   164bc:	83 c0 40             	add    $0x40,%eax
   164bf:	c1 f8 07             	sar    $0x7,%eax
   164c2:	50                   	push   %eax
   164c3:	e8 e9 dd ff ff       	call   142b1 <_Clip>
   164c8:	83 c4 04             	add    $0x4,%esp
}
   164cb:	c9                   	leave  
   164cc:	c3                   	ret    
