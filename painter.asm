
_painter：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <isMouseInButton>:

Window wnd;

int flag = 0;

int isMouseInButton(int x, int y) {
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
    if (420 < x && x < 490 && 260 < y && y < 290) {
       3:	81 7d 08 a4 01 00 00 	cmpl   $0x1a4,0x8(%ebp)
       a:	7e 22                	jle    2e <isMouseInButton+0x2e>
       c:	81 7d 08 e9 01 00 00 	cmpl   $0x1e9,0x8(%ebp)
      13:	7f 19                	jg     2e <isMouseInButton+0x2e>
      15:	81 7d 0c 04 01 00 00 	cmpl   $0x104,0xc(%ebp)
      1c:	7e 10                	jle    2e <isMouseInButton+0x2e>
      1e:	81 7d 0c 21 01 00 00 	cmpl   $0x121,0xc(%ebp)
      25:	7f 07                	jg     2e <isMouseInButton+0x2e>
        return 1;
      27:	b8 01 00 00 00       	mov    $0x1,%eax
      2c:	eb 05                	jmp    33 <isMouseInButton+0x33>
    }
    else {
        return 0;
      2e:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
      33:	5d                   	pop    %ebp
      34:	c3                   	ret    

00000035 <isMouseInContent>:

int isMouseInContent(int x, int y) {
      35:	55                   	push   %ebp
      36:	89 e5                	mov    %esp,%ebp
   if (10 < x && x < 490 && 40 < y && y < 290){
      38:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
      3c:	7e 1f                	jle    5d <isMouseInContent+0x28>
      3e:	81 7d 08 e9 01 00 00 	cmpl   $0x1e9,0x8(%ebp)
      45:	7f 16                	jg     5d <isMouseInContent+0x28>
      47:	83 7d 0c 28          	cmpl   $0x28,0xc(%ebp)
      4b:	7e 10                	jle    5d <isMouseInContent+0x28>
      4d:	81 7d 0c 21 01 00 00 	cmpl   $0x121,0xc(%ebp)
      54:	7f 07                	jg     5d <isMouseInContent+0x28>
       return 1;
      56:	b8 01 00 00 00       	mov    $0x1,%eax
      5b:	eb 05                	jmp    62 <isMouseInContent+0x2d>
   }
   else {
        return 0;
      5d:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
      62:	5d                   	pop    %ebp
      63:	c3                   	ret    

00000064 <MsgProc>:

void MsgProc(struct message *msg) {
      64:	55                   	push   %ebp
      65:	89 e5                	mov    %esp,%ebp
      67:	81 ec 98 00 00 00    	sub    $0x98,%esp
    static int mouseDown = 0;
    static int isPencil = 1;
    switch (msg->msg_type) {
      6d:	8b 45 08             	mov    0x8(%ebp),%eax
      70:	8b 00                	mov    (%eax),%eax
      72:	83 e8 03             	sub    $0x3,%eax
      75:	83 f8 07             	cmp    $0x7,%eax
      78:	0f 87 9e 04 00 00    	ja     51c <MsgProc+0x4b8>
      7e:	8b 04 85 54 63 01 00 	mov    0x16354(,%eax,4),%eax
      85:	ff e0                	jmp    *%eax
        case M_MOUSE_DOWN:
            if (isMouseInContent(msg->params[0], msg->params[1]) && !isMouseInButton(msg->params[0], msg->params[1])) {
      87:	8b 45 08             	mov    0x8(%ebp),%eax
      8a:	8b 50 08             	mov    0x8(%eax),%edx
      8d:	8b 45 08             	mov    0x8(%ebp),%eax
      90:	8b 40 04             	mov    0x4(%eax),%eax
      93:	52                   	push   %edx
      94:	50                   	push   %eax
      95:	e8 9b ff ff ff       	call   35 <isMouseInContent>
      9a:	83 c4 08             	add    $0x8,%esp
      9d:	85 c0                	test   %eax,%eax
      9f:	0f 84 70 04 00 00    	je     515 <MsgProc+0x4b1>
      a5:	8b 45 08             	mov    0x8(%ebp),%eax
      a8:	8b 50 08             	mov    0x8(%eax),%edx
      ab:	8b 45 08             	mov    0x8(%ebp),%eax
      ae:	8b 40 04             	mov    0x4(%eax),%eax
      b1:	52                   	push   %edx
      b2:	50                   	push   %eax
      b3:	e8 48 ff ff ff       	call   0 <isMouseInButton>
      b8:	83 c4 08             	add    $0x8,%esp
      bb:	85 c0                	test   %eax,%eax
      bd:	0f 85 52 04 00 00    	jne    515 <MsgProc+0x4b1>
                mouseDown = 1;
      c3:	c7 05 24 eb 01 00 01 	movl   $0x1,0x1eb24
      ca:	00 00 00 
                if (isPencil) {
      cd:	a1 e0 e6 01 00       	mov    0x1e6e0,%eax
      d2:	85 c0                	test   %eax,%eax
      d4:	0f 84 a9 00 00 00    	je     183 <MsgProc+0x11f>
                    api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
                                 (Size) {pointSize, pointSize}, (RGB) {0, 0, 0});
      da:	c6 85 69 ff ff ff 00 	movb   $0x0,-0x97(%ebp)
      e1:	c6 85 6a ff ff ff 00 	movb   $0x0,-0x96(%ebp)
      e8:	c6 85 6b ff ff ff 00 	movb   $0x0,-0x95(%ebp)
      ef:	b8 0f 00 00 00       	mov    $0xf,%eax
      f4:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
      fa:	b8 0f 00 00 00       	mov    $0xf,%eax
      ff:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
    switch (msg->msg_type) {
        case M_MOUSE_DOWN:
            if (isMouseInContent(msg->params[0], msg->params[1]) && !isMouseInButton(msg->params[0], msg->params[1])) {
                mouseDown = 1;
                if (isPencil) {
                    api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
     105:	8b 45 08             	mov    0x8(%ebp),%eax
     108:	8b 40 04             	mov    0x4(%eax),%eax
     10b:	ba 0f 00 00 00       	mov    $0xf,%edx
     110:	89 d1                	mov    %edx,%ecx
     112:	c1 e9 1f             	shr    $0x1f,%ecx
     115:	01 ca                	add    %ecx,%edx
     117:	d1 fa                	sar    %edx
     119:	29 d0                	sub    %edx,%eax
     11b:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
     121:	8b 45 08             	mov    0x8(%ebp),%eax
     124:	8b 40 08             	mov    0x8(%eax),%eax
     127:	ba 0f 00 00 00       	mov    $0xf,%edx
     12c:	89 d1                	mov    %edx,%ecx
     12e:	c1 e9 1f             	shr    $0x1f,%ecx
     131:	01 ca                	add    %ecx,%edx
     133:	d1 fa                	sar    %edx
     135:	29 d0                	sub    %edx,%eax
     137:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
     13d:	83 ec 08             	sub    $0x8,%esp
     140:	83 ec 04             	sub    $0x4,%esp
     143:	89 e0                	mov    %esp,%eax
     145:	0f b7 95 69 ff ff ff 	movzwl -0x97(%ebp),%edx
     14c:	66 89 10             	mov    %dx,(%eax)
     14f:	0f b6 95 6b ff ff ff 	movzbl -0x95(%ebp),%edx
     156:	88 50 02             	mov    %dl,0x2(%eax)
     159:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
     15f:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
     165:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
     16b:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
     171:	68 60 eb 01 00       	push   $0x1eb60
     176:	e8 c2 17 00 00       	call   193d <api_drawRect>
     17b:	83 c4 20             	add    $0x20,%esp
     17e:	e9 8c 00 00 00       	jmp    20f <MsgProc+0x1ab>
                                 (Size) {pointSize, pointSize}, (RGB) {0, 0, 0});
                }
                else {
                    api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
                                 (Size) {pointSize, pointSize}, (RGB) {255, 255, 255});
     183:	c6 85 7d ff ff ff ff 	movb   $0xff,-0x83(%ebp)
     18a:	c6 85 7e ff ff ff ff 	movb   $0xff,-0x82(%ebp)
     191:	c6 85 7f ff ff ff ff 	movb   $0xff,-0x81(%ebp)
     198:	b8 0f 00 00 00       	mov    $0xf,%eax
     19d:	89 45 80             	mov    %eax,-0x80(%ebp)
     1a0:	b8 0f 00 00 00       	mov    $0xf,%eax
     1a5:	89 45 84             	mov    %eax,-0x7c(%ebp)
                if (isPencil) {
                    api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
                                 (Size) {pointSize, pointSize}, (RGB) {0, 0, 0});
                }
                else {
                    api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
     1a8:	8b 45 08             	mov    0x8(%ebp),%eax
     1ab:	8b 40 04             	mov    0x4(%eax),%eax
     1ae:	ba 0f 00 00 00       	mov    $0xf,%edx
     1b3:	89 d1                	mov    %edx,%ecx
     1b5:	c1 e9 1f             	shr    $0x1f,%ecx
     1b8:	01 ca                	add    %ecx,%edx
     1ba:	d1 fa                	sar    %edx
     1bc:	29 d0                	sub    %edx,%eax
     1be:	89 45 88             	mov    %eax,-0x78(%ebp)
     1c1:	8b 45 08             	mov    0x8(%ebp),%eax
     1c4:	8b 40 08             	mov    0x8(%eax),%eax
     1c7:	ba 0f 00 00 00       	mov    $0xf,%edx
     1cc:	89 d1                	mov    %edx,%ecx
     1ce:	c1 e9 1f             	shr    $0x1f,%ecx
     1d1:	01 ca                	add    %ecx,%edx
     1d3:	d1 fa                	sar    %edx
     1d5:	29 d0                	sub    %edx,%eax
     1d7:	89 45 8c             	mov    %eax,-0x74(%ebp)
     1da:	83 ec 08             	sub    $0x8,%esp
     1dd:	83 ec 04             	sub    $0x4,%esp
     1e0:	89 e0                	mov    %esp,%eax
     1e2:	0f b7 95 7d ff ff ff 	movzwl -0x83(%ebp),%edx
     1e9:	66 89 10             	mov    %dx,(%eax)
     1ec:	0f b6 95 7f ff ff ff 	movzbl -0x81(%ebp),%edx
     1f3:	88 50 02             	mov    %dl,0x2(%eax)
     1f6:	ff 75 84             	pushl  -0x7c(%ebp)
     1f9:	ff 75 80             	pushl  -0x80(%ebp)
     1fc:	ff 75 8c             	pushl  -0x74(%ebp)
     1ff:	ff 75 88             	pushl  -0x78(%ebp)
     202:	68 60 eb 01 00       	push   $0x1eb60
     207:	e8 31 17 00 00       	call   193d <api_drawRect>
     20c:	83 c4 20             	add    $0x20,%esp
                                 (Size) {pointSize, pointSize}, (RGB) {255, 255, 255});
                }
                api_update(&wnd, (Rect){msg->params[0] - pointSize / 2, msg->params[1] - pointSize /2, pointSize, pointSize});
     20f:	8b 45 08             	mov    0x8(%ebp),%eax
     212:	8b 40 04             	mov    0x4(%eax),%eax
     215:	ba 0f 00 00 00       	mov    $0xf,%edx
     21a:	89 d1                	mov    %edx,%ecx
     21c:	c1 e9 1f             	shr    $0x1f,%ecx
     21f:	01 ca                	add    %ecx,%edx
     221:	d1 fa                	sar    %edx
     223:	29 d0                	sub    %edx,%eax
     225:	89 45 90             	mov    %eax,-0x70(%ebp)
     228:	8b 45 08             	mov    0x8(%ebp),%eax
     22b:	8b 40 08             	mov    0x8(%eax),%eax
     22e:	ba 0f 00 00 00       	mov    $0xf,%edx
     233:	89 d1                	mov    %edx,%ecx
     235:	c1 e9 1f             	shr    $0x1f,%ecx
     238:	01 ca                	add    %ecx,%edx
     23a:	d1 fa                	sar    %edx
     23c:	29 d0                	sub    %edx,%eax
     23e:	89 45 94             	mov    %eax,-0x6c(%ebp)
     241:	b8 0f 00 00 00       	mov    $0xf,%eax
     246:	89 45 98             	mov    %eax,-0x68(%ebp)
     249:	b8 0f 00 00 00       	mov    $0xf,%eax
     24e:	89 45 9c             	mov    %eax,-0x64(%ebp)
     251:	83 ec 0c             	sub    $0xc,%esp
     254:	ff 75 9c             	pushl  -0x64(%ebp)
     257:	ff 75 98             	pushl  -0x68(%ebp)
     25a:	ff 75 94             	pushl  -0x6c(%ebp)
     25d:	ff 75 90             	pushl  -0x70(%ebp)
     260:	68 60 eb 01 00       	push   $0x1eb60
     265:	e8 44 16 00 00       	call   18ae <api_update>
     26a:	83 c4 20             	add    $0x20,%esp
            }
            break;
     26d:	e9 a3 02 00 00       	jmp    515 <MsgProc+0x4b1>
        case M_MOUSE_MOVE:
            if (isMouseInContent(msg->params[0], msg->params[1]) && !isMouseInButton(msg->params[0], msg->params[1]) && mouseDown) {
     272:	8b 45 08             	mov    0x8(%ebp),%eax
     275:	8b 50 08             	mov    0x8(%eax),%edx
     278:	8b 45 08             	mov    0x8(%ebp),%eax
     27b:	8b 40 04             	mov    0x4(%eax),%eax
     27e:	83 ec 08             	sub    $0x8,%esp
     281:	52                   	push   %edx
     282:	50                   	push   %eax
     283:	e8 ad fd ff ff       	call   35 <isMouseInContent>
     288:	83 c4 10             	add    $0x10,%esp
     28b:	85 c0                	test   %eax,%eax
     28d:	0f 84 85 02 00 00    	je     518 <MsgProc+0x4b4>
     293:	8b 45 08             	mov    0x8(%ebp),%eax
     296:	8b 50 08             	mov    0x8(%eax),%edx
     299:	8b 45 08             	mov    0x8(%ebp),%eax
     29c:	8b 40 04             	mov    0x4(%eax),%eax
     29f:	83 ec 08             	sub    $0x8,%esp
     2a2:	52                   	push   %edx
     2a3:	50                   	push   %eax
     2a4:	e8 57 fd ff ff       	call   0 <isMouseInButton>
     2a9:	83 c4 10             	add    $0x10,%esp
     2ac:	85 c0                	test   %eax,%eax
     2ae:	0f 85 64 02 00 00    	jne    518 <MsgProc+0x4b4>
     2b4:	a1 24 eb 01 00       	mov    0x1eb24,%eax
     2b9:	85 c0                	test   %eax,%eax
     2bb:	0f 84 57 02 00 00    	je     518 <MsgProc+0x4b4>
                if (isPencil) {
     2c1:	a1 e0 e6 01 00       	mov    0x1e6e0,%eax
     2c6:	85 c0                	test   %eax,%eax
     2c8:	74 7f                	je     349 <MsgProc+0x2e5>
                    api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
                                 (Size) {pointSize, pointSize}, (RGB) {0, 0, 0});
     2ca:	c6 45 a1 00          	movb   $0x0,-0x5f(%ebp)
     2ce:	c6 45 a2 00          	movb   $0x0,-0x5e(%ebp)
     2d2:	c6 45 a3 00          	movb   $0x0,-0x5d(%ebp)
     2d6:	b8 0f 00 00 00       	mov    $0xf,%eax
     2db:	89 45 a4             	mov    %eax,-0x5c(%ebp)
     2de:	b8 0f 00 00 00       	mov    $0xf,%eax
     2e3:	89 45 a8             	mov    %eax,-0x58(%ebp)
            }
            break;
        case M_MOUSE_MOVE:
            if (isMouseInContent(msg->params[0], msg->params[1]) && !isMouseInButton(msg->params[0], msg->params[1]) && mouseDown) {
                if (isPencil) {
                    api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
     2e6:	8b 45 08             	mov    0x8(%ebp),%eax
     2e9:	8b 40 04             	mov    0x4(%eax),%eax
     2ec:	ba 0f 00 00 00       	mov    $0xf,%edx
     2f1:	89 d1                	mov    %edx,%ecx
     2f3:	c1 e9 1f             	shr    $0x1f,%ecx
     2f6:	01 ca                	add    %ecx,%edx
     2f8:	d1 fa                	sar    %edx
     2fa:	29 d0                	sub    %edx,%eax
     2fc:	89 45 ac             	mov    %eax,-0x54(%ebp)
     2ff:	8b 45 08             	mov    0x8(%ebp),%eax
     302:	8b 40 08             	mov    0x8(%eax),%eax
     305:	ba 0f 00 00 00       	mov    $0xf,%edx
     30a:	89 d1                	mov    %edx,%ecx
     30c:	c1 e9 1f             	shr    $0x1f,%ecx
     30f:	01 ca                	add    %ecx,%edx
     311:	d1 fa                	sar    %edx
     313:	29 d0                	sub    %edx,%eax
     315:	89 45 b0             	mov    %eax,-0x50(%ebp)
     318:	83 ec 08             	sub    $0x8,%esp
     31b:	83 ec 04             	sub    $0x4,%esp
     31e:	89 e0                	mov    %esp,%eax
     320:	0f b7 55 a1          	movzwl -0x5f(%ebp),%edx
     324:	66 89 10             	mov    %dx,(%eax)
     327:	0f b6 55 a3          	movzbl -0x5d(%ebp),%edx
     32b:	88 50 02             	mov    %dl,0x2(%eax)
     32e:	ff 75 a8             	pushl  -0x58(%ebp)
     331:	ff 75 a4             	pushl  -0x5c(%ebp)
     334:	ff 75 b0             	pushl  -0x50(%ebp)
     337:	ff 75 ac             	pushl  -0x54(%ebp)
     33a:	68 60 eb 01 00       	push   $0x1eb60
     33f:	e8 f9 15 00 00       	call   193d <api_drawRect>
     344:	83 c4 20             	add    $0x20,%esp
     347:	eb 7d                	jmp    3c6 <MsgProc+0x362>
                                 (Size) {pointSize, pointSize}, (RGB) {0, 0, 0});
                }
                else {
                    api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
                                 (Size) {pointSize, pointSize}, (RGB) {255, 255, 255});
     349:	c6 45 b5 ff          	movb   $0xff,-0x4b(%ebp)
     34d:	c6 45 b6 ff          	movb   $0xff,-0x4a(%ebp)
     351:	c6 45 b7 ff          	movb   $0xff,-0x49(%ebp)
     355:	b8 0f 00 00 00       	mov    $0xf,%eax
     35a:	89 45 b8             	mov    %eax,-0x48(%ebp)
     35d:	b8 0f 00 00 00       	mov    $0xf,%eax
     362:	89 45 bc             	mov    %eax,-0x44(%ebp)
                if (isPencil) {
                    api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
                                 (Size) {pointSize, pointSize}, (RGB) {0, 0, 0});
                }
                else {
                    api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
     365:	8b 45 08             	mov    0x8(%ebp),%eax
     368:	8b 40 04             	mov    0x4(%eax),%eax
     36b:	ba 0f 00 00 00       	mov    $0xf,%edx
     370:	89 d1                	mov    %edx,%ecx
     372:	c1 e9 1f             	shr    $0x1f,%ecx
     375:	01 ca                	add    %ecx,%edx
     377:	d1 fa                	sar    %edx
     379:	29 d0                	sub    %edx,%eax
     37b:	89 45 c0             	mov    %eax,-0x40(%ebp)
     37e:	8b 45 08             	mov    0x8(%ebp),%eax
     381:	8b 40 08             	mov    0x8(%eax),%eax
     384:	ba 0f 00 00 00       	mov    $0xf,%edx
     389:	89 d1                	mov    %edx,%ecx
     38b:	c1 e9 1f             	shr    $0x1f,%ecx
     38e:	01 ca                	add    %ecx,%edx
     390:	d1 fa                	sar    %edx
     392:	29 d0                	sub    %edx,%eax
     394:	89 45 c4             	mov    %eax,-0x3c(%ebp)
     397:	83 ec 08             	sub    $0x8,%esp
     39a:	83 ec 04             	sub    $0x4,%esp
     39d:	89 e0                	mov    %esp,%eax
     39f:	0f b7 55 b5          	movzwl -0x4b(%ebp),%edx
     3a3:	66 89 10             	mov    %dx,(%eax)
     3a6:	0f b6 55 b7          	movzbl -0x49(%ebp),%edx
     3aa:	88 50 02             	mov    %dl,0x2(%eax)
     3ad:	ff 75 bc             	pushl  -0x44(%ebp)
     3b0:	ff 75 b8             	pushl  -0x48(%ebp)
     3b3:	ff 75 c4             	pushl  -0x3c(%ebp)
     3b6:	ff 75 c0             	pushl  -0x40(%ebp)
     3b9:	68 60 eb 01 00       	push   $0x1eb60
     3be:	e8 7a 15 00 00       	call   193d <api_drawRect>
     3c3:	83 c4 20             	add    $0x20,%esp
                                 (Size) {pointSize, pointSize}, (RGB) {255, 255, 255});
                }
                api_update(&wnd, (Rect){msg->params[0] - pointSize / 2, msg->params[1] - pointSize /2, pointSize, pointSize});
     3c6:	8b 45 08             	mov    0x8(%ebp),%eax
     3c9:	8b 40 04             	mov    0x4(%eax),%eax
     3cc:	ba 0f 00 00 00       	mov    $0xf,%edx
     3d1:	89 d1                	mov    %edx,%ecx
     3d3:	c1 e9 1f             	shr    $0x1f,%ecx
     3d6:	01 ca                	add    %ecx,%edx
     3d8:	d1 fa                	sar    %edx
     3da:	29 d0                	sub    %edx,%eax
     3dc:	89 45 c8             	mov    %eax,-0x38(%ebp)
     3df:	8b 45 08             	mov    0x8(%ebp),%eax
     3e2:	8b 40 08             	mov    0x8(%eax),%eax
     3e5:	ba 0f 00 00 00       	mov    $0xf,%edx
     3ea:	89 d1                	mov    %edx,%ecx
     3ec:	c1 e9 1f             	shr    $0x1f,%ecx
     3ef:	01 ca                	add    %ecx,%edx
     3f1:	d1 fa                	sar    %edx
     3f3:	29 d0                	sub    %edx,%eax
     3f5:	89 45 cc             	mov    %eax,-0x34(%ebp)
     3f8:	b8 0f 00 00 00       	mov    $0xf,%eax
     3fd:	89 45 d0             	mov    %eax,-0x30(%ebp)
     400:	b8 0f 00 00 00       	mov    $0xf,%eax
     405:	89 45 d4             	mov    %eax,-0x2c(%ebp)
     408:	83 ec 0c             	sub    $0xc,%esp
     40b:	ff 75 d4             	pushl  -0x2c(%ebp)
     40e:	ff 75 d0             	pushl  -0x30(%ebp)
     411:	ff 75 cc             	pushl  -0x34(%ebp)
     414:	ff 75 c8             	pushl  -0x38(%ebp)
     417:	68 60 eb 01 00       	push   $0x1eb60
     41c:	e8 8d 14 00 00       	call   18ae <api_update>
     421:	83 c4 20             	add    $0x20,%esp
            }
            break;
     424:	e9 ef 00 00 00       	jmp    518 <MsgProc+0x4b4>
        case M_MOUSE_UP:
            mouseDown = 0;
     429:	c7 05 24 eb 01 00 00 	movl   $0x0,0x1eb24
     430:	00 00 00 
            break;
     433:	e9 e4 00 00 00       	jmp    51c <MsgProc+0x4b8>
        case M_MOUSE_LEFT_CLICK:
            if (isMouseInButton(msg->params[0], msg->params[1])) {
     438:	8b 45 08             	mov    0x8(%ebp),%eax
     43b:	8b 50 08             	mov    0x8(%eax),%edx
     43e:	8b 45 08             	mov    0x8(%ebp),%eax
     441:	8b 40 04             	mov    0x4(%eax),%eax
     444:	83 ec 08             	sub    $0x8,%esp
     447:	52                   	push   %edx
     448:	50                   	push   %eax
     449:	e8 b2 fb ff ff       	call   0 <isMouseInButton>
     44e:	83 c4 10             	add    $0x10,%esp
     451:	85 c0                	test   %eax,%eax
     453:	0f 84 c2 00 00 00    	je     51b <MsgProc+0x4b7>
                if (isPencil) {
     459:	a1 e0 e6 01 00       	mov    0x1e6e0,%eax
     45e:	85 c0                	test   %eax,%eax
     460:	74 3f                	je     4a1 <MsgProc+0x43d>
                    api_drawButton(&wnd, (Point) {420, 260}, (Size) {30, 70}, "eraser");
     462:	c7 45 d8 1e 00 00 00 	movl   $0x1e,-0x28(%ebp)
     469:	c7 45 dc 46 00 00 00 	movl   $0x46,-0x24(%ebp)
     470:	c7 45 e0 a4 01 00 00 	movl   $0x1a4,-0x20(%ebp)
     477:	c7 45 e4 04 01 00 00 	movl   $0x104,-0x1c(%ebp)
     47e:	83 ec 08             	sub    $0x8,%esp
     481:	68 44 63 01 00       	push   $0x16344
     486:	ff 75 dc             	pushl  -0x24(%ebp)
     489:	ff 75 d8             	pushl  -0x28(%ebp)
     48c:	ff 75 e4             	pushl  -0x1c(%ebp)
     48f:	ff 75 e0             	pushl  -0x20(%ebp)
     492:	68 60 eb 01 00       	push   $0x1eb60
     497:	e8 6d 15 00 00       	call   1a09 <api_drawButton>
     49c:	83 c4 20             	add    $0x20,%esp
     49f:	eb 3d                	jmp    4de <MsgProc+0x47a>
                }
                else {
                    api_drawButton(&wnd, (Point) {420, 260}, (Size) {30, 70}, "pencil");
     4a1:	c7 45 e8 1e 00 00 00 	movl   $0x1e,-0x18(%ebp)
     4a8:	c7 45 ec 46 00 00 00 	movl   $0x46,-0x14(%ebp)
     4af:	c7 45 f0 a4 01 00 00 	movl   $0x1a4,-0x10(%ebp)
     4b6:	c7 45 f4 04 01 00 00 	movl   $0x104,-0xc(%ebp)
     4bd:	83 ec 08             	sub    $0x8,%esp
     4c0:	68 4b 63 01 00       	push   $0x1634b
     4c5:	ff 75 ec             	pushl  -0x14(%ebp)
     4c8:	ff 75 e8             	pushl  -0x18(%ebp)
     4cb:	ff 75 f4             	pushl  -0xc(%ebp)
     4ce:	ff 75 f0             	pushl  -0x10(%ebp)
     4d1:	68 60 eb 01 00       	push   $0x1eb60
     4d6:	e8 2e 15 00 00       	call   1a09 <api_drawButton>
     4db:	83 c4 20             	add    $0x20,%esp
                }
                isPencil = 1 - isPencil;
     4de:	a1 e0 e6 01 00       	mov    0x1e6e0,%eax
     4e3:	ba 01 00 00 00       	mov    $0x1,%edx
     4e8:	29 c2                	sub    %eax,%edx
     4ea:	89 d0                	mov    %edx,%eax
     4ec:	a3 e0 e6 01 00       	mov    %eax,0x1e6e0
                api_repaint(&wnd);
     4f1:	83 ec 0c             	sub    $0xc,%esp
     4f4:	68 60 eb 01 00       	push   $0x1eb60
     4f9:	e8 92 13 00 00       	call   1890 <api_repaint>
     4fe:	83 c4 10             	add    $0x10,%esp
            }
            break;
     501:	eb 18                	jmp    51b <MsgProc+0x4b7>
       case M_CLOSE_WINDOW:
            api_destroywindow(&wnd);
     503:	83 ec 0c             	sub    $0xc,%esp
     506:	68 60 eb 01 00       	push   $0x1eb60
     50b:	e8 23 16 00 00       	call   1b33 <api_destroywindow>
     510:	83 c4 10             	add    $0x10,%esp
            break;
     513:	eb 07                	jmp    51c <MsgProc+0x4b8>
                    api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
                                 (Size) {pointSize, pointSize}, (RGB) {255, 255, 255});
                }
                api_update(&wnd, (Rect){msg->params[0] - pointSize / 2, msg->params[1] - pointSize /2, pointSize, pointSize});
            }
            break;
     515:	90                   	nop
     516:	eb 04                	jmp    51c <MsgProc+0x4b8>
                    api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
                                 (Size) {pointSize, pointSize}, (RGB) {255, 255, 255});
                }
                api_update(&wnd, (Rect){msg->params[0] - pointSize / 2, msg->params[1] - pointSize /2, pointSize, pointSize});
            }
            break;
     518:	90                   	nop
     519:	eb 01                	jmp    51c <MsgProc+0x4b8>
                    api_drawButton(&wnd, (Point) {420, 260}, (Size) {30, 70}, "pencil");
                }
                isPencil = 1 - isPencil;
                api_repaint(&wnd);
            }
            break;
     51b:	90                   	nop
       case M_CLOSE_WINDOW:
            api_destroywindow(&wnd);
            break;
    }
}
     51c:	90                   	nop
     51d:	c9                   	leave  
     51e:	c3                   	ret    

0000051f <main>:

int
main(void) {
     51f:	8d 4c 24 04          	lea    0x4(%esp),%ecx
     523:	83 e4 f0             	and    $0xfffffff0,%esp
     526:	ff 71 fc             	pushl  -0x4(%ecx)
     529:	55                   	push   %ebp
     52a:	89 e5                	mov    %esp,%ebp
     52c:	51                   	push   %ecx
     52d:	83 ec 14             	sub    $0x14,%esp
    wnd.pos.x = 100;
     530:	c7 05 64 eb 01 00 64 	movl   $0x64,0x1eb64
     537:	00 00 00 
    wnd.pos.y = 100;
     53a:	c7 05 68 eb 01 00 64 	movl   $0x64,0x1eb68
     541:	00 00 00 
    wnd.size.w = 500;
     544:	c7 05 70 eb 01 00 f4 	movl   $0x1f4,0x1eb70
     54b:	01 00 00 
    wnd.size.h = 300;
     54e:	c7 05 6c eb 01 00 2c 	movl   $0x12c,0x1eb6c
     555:	01 00 00 
    wnd.title = "DrawerApp";
     558:	c7 05 74 eb 01 00 74 	movl   $0x16374,0x1eb74
     55f:	63 01 00 

    int h, w;
    api_createwindow(&wnd);
     562:	83 ec 0c             	sub    $0xc,%esp
     565:	68 60 eb 01 00       	push   $0x1eb60
     56a:	e8 8f 11 00 00       	call   16fe <api_createwindow>
     56f:	83 c4 10             	add    $0x10,%esp

    api_drawButton(&wnd, (Point) {420, 260}, (Size) {30, 70}, "pencil");
     572:	c7 45 e8 1e 00 00 00 	movl   $0x1e,-0x18(%ebp)
     579:	c7 45 ec 46 00 00 00 	movl   $0x46,-0x14(%ebp)
     580:	c7 45 f0 a4 01 00 00 	movl   $0x1a4,-0x10(%ebp)
     587:	c7 45 f4 04 01 00 00 	movl   $0x104,-0xc(%ebp)
     58e:	83 ec 08             	sub    $0x8,%esp
     591:	68 4b 63 01 00       	push   $0x1634b
     596:	ff 75 ec             	pushl  -0x14(%ebp)
     599:	ff 75 e8             	pushl  -0x18(%ebp)
     59c:	ff 75 f4             	pushl  -0xc(%ebp)
     59f:	ff 75 f0             	pushl  -0x10(%ebp)
     5a2:	68 60 eb 01 00       	push   $0x1eb60
     5a7:	e8 5d 14 00 00       	call   1a09 <api_drawButton>
     5ac:	83 c4 20             	add    $0x20,%esp
    api_repaint(&wnd);
     5af:	83 ec 0c             	sub    $0xc,%esp
     5b2:	68 60 eb 01 00       	push   $0x1eb60
     5b7:	e8 d4 12 00 00       	call   1890 <api_repaint>
     5bc:	83 c4 10             	add    $0x10,%esp
    printf(1, "safe here\n");
     5bf:	83 ec 08             	sub    $0x8,%esp
     5c2:	68 7e 63 01 00       	push   $0x1637e
     5c7:	6a 01                	push   $0x1
     5c9:	e8 23 04 00 00       	call   9f1 <printf>
     5ce:	83 c4 10             	add    $0x10,%esp
    api_exec(&wnd, &MsgProc);
     5d1:	83 ec 08             	sub    $0x8,%esp
     5d4:	68 64 00 00 00       	push   $0x64
     5d9:	68 60 eb 01 00       	push   $0x1eb60
     5de:	e8 fd 12 00 00       	call   18e0 <api_exec>
     5e3:	83 c4 10             	add    $0x10,%esp
    return 0;
     5e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
     5eb:	8b 4d fc             	mov    -0x4(%ebp),%ecx
     5ee:	c9                   	leave  
     5ef:	8d 61 fc             	lea    -0x4(%ecx),%esp
     5f2:	c3                   	ret    

000005f3 <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
     5f3:	55                   	push   %ebp
     5f4:	89 e5                	mov    %esp,%ebp
     5f6:	57                   	push   %edi
     5f7:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
     5f8:	8b 4d 08             	mov    0x8(%ebp),%ecx
     5fb:	8b 55 10             	mov    0x10(%ebp),%edx
     5fe:	8b 45 0c             	mov    0xc(%ebp),%eax
     601:	89 cb                	mov    %ecx,%ebx
     603:	89 df                	mov    %ebx,%edi
     605:	89 d1                	mov    %edx,%ecx
     607:	fc                   	cld    
     608:	f3 aa                	rep stos %al,%es:(%edi)
     60a:	89 ca                	mov    %ecx,%edx
     60c:	89 fb                	mov    %edi,%ebx
     60e:	89 5d 08             	mov    %ebx,0x8(%ebp)
     611:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
     614:	90                   	nop
     615:	5b                   	pop    %ebx
     616:	5f                   	pop    %edi
     617:	5d                   	pop    %ebp
     618:	c3                   	ret    

00000619 <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
     619:	55                   	push   %ebp
     61a:	89 e5                	mov    %esp,%ebp
     61c:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
     61f:	8b 45 08             	mov    0x8(%ebp),%eax
     622:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
     625:	90                   	nop
     626:	8b 45 08             	mov    0x8(%ebp),%eax
     629:	8d 50 01             	lea    0x1(%eax),%edx
     62c:	89 55 08             	mov    %edx,0x8(%ebp)
     62f:	8b 55 0c             	mov    0xc(%ebp),%edx
     632:	8d 4a 01             	lea    0x1(%edx),%ecx
     635:	89 4d 0c             	mov    %ecx,0xc(%ebp)
     638:	0f b6 12             	movzbl (%edx),%edx
     63b:	88 10                	mov    %dl,(%eax)
     63d:	0f b6 00             	movzbl (%eax),%eax
     640:	84 c0                	test   %al,%al
     642:	75 e2                	jne    626 <strcpy+0xd>
    ;
  return os;
     644:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     647:	c9                   	leave  
     648:	c3                   	ret    

00000649 <strcmp>:

int
strcmp(const char *p, const char *q)
{
     649:	55                   	push   %ebp
     64a:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
     64c:	eb 08                	jmp    656 <strcmp+0xd>
    p++, q++;
     64e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     652:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
     656:	8b 45 08             	mov    0x8(%ebp),%eax
     659:	0f b6 00             	movzbl (%eax),%eax
     65c:	84 c0                	test   %al,%al
     65e:	74 10                	je     670 <strcmp+0x27>
     660:	8b 45 08             	mov    0x8(%ebp),%eax
     663:	0f b6 10             	movzbl (%eax),%edx
     666:	8b 45 0c             	mov    0xc(%ebp),%eax
     669:	0f b6 00             	movzbl (%eax),%eax
     66c:	38 c2                	cmp    %al,%dl
     66e:	74 de                	je     64e <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
     670:	8b 45 08             	mov    0x8(%ebp),%eax
     673:	0f b6 00             	movzbl (%eax),%eax
     676:	0f b6 d0             	movzbl %al,%edx
     679:	8b 45 0c             	mov    0xc(%ebp),%eax
     67c:	0f b6 00             	movzbl (%eax),%eax
     67f:	0f b6 c0             	movzbl %al,%eax
     682:	29 c2                	sub    %eax,%edx
     684:	89 d0                	mov    %edx,%eax
}
     686:	5d                   	pop    %ebp
     687:	c3                   	ret    

00000688 <strlen>:

uint
strlen(char *s)
{
     688:	55                   	push   %ebp
     689:	89 e5                	mov    %esp,%ebp
     68b:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     68e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     695:	eb 04                	jmp    69b <strlen+0x13>
     697:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     69b:	8b 55 fc             	mov    -0x4(%ebp),%edx
     69e:	8b 45 08             	mov    0x8(%ebp),%eax
     6a1:	01 d0                	add    %edx,%eax
     6a3:	0f b6 00             	movzbl (%eax),%eax
     6a6:	84 c0                	test   %al,%al
     6a8:	75 ed                	jne    697 <strlen+0xf>
    ;
  return n;
     6aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     6ad:	c9                   	leave  
     6ae:	c3                   	ret    

000006af <memset>:

void*
memset(void *dst, int c, uint n)
{
     6af:	55                   	push   %ebp
     6b0:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     6b2:	8b 45 10             	mov    0x10(%ebp),%eax
     6b5:	50                   	push   %eax
     6b6:	ff 75 0c             	pushl  0xc(%ebp)
     6b9:	ff 75 08             	pushl  0x8(%ebp)
     6bc:	e8 32 ff ff ff       	call   5f3 <stosb>
     6c1:	83 c4 0c             	add    $0xc,%esp
  return dst;
     6c4:	8b 45 08             	mov    0x8(%ebp),%eax
}
     6c7:	c9                   	leave  
     6c8:	c3                   	ret    

000006c9 <strchr>:

char*
strchr(const char *s, char c)
{
     6c9:	55                   	push   %ebp
     6ca:	89 e5                	mov    %esp,%ebp
     6cc:	83 ec 04             	sub    $0x4,%esp
     6cf:	8b 45 0c             	mov    0xc(%ebp),%eax
     6d2:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     6d5:	eb 14                	jmp    6eb <strchr+0x22>
    if(*s == c)
     6d7:	8b 45 08             	mov    0x8(%ebp),%eax
     6da:	0f b6 00             	movzbl (%eax),%eax
     6dd:	3a 45 fc             	cmp    -0x4(%ebp),%al
     6e0:	75 05                	jne    6e7 <strchr+0x1e>
      return (char*)s;
     6e2:	8b 45 08             	mov    0x8(%ebp),%eax
     6e5:	eb 13                	jmp    6fa <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     6e7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     6eb:	8b 45 08             	mov    0x8(%ebp),%eax
     6ee:	0f b6 00             	movzbl (%eax),%eax
     6f1:	84 c0                	test   %al,%al
     6f3:	75 e2                	jne    6d7 <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     6f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
     6fa:	c9                   	leave  
     6fb:	c3                   	ret    

000006fc <gets>:

char*
gets(char *buf, int max)
{
     6fc:	55                   	push   %ebp
     6fd:	89 e5                	mov    %esp,%ebp
     6ff:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     702:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     709:	eb 42                	jmp    74d <gets+0x51>
    cc = read(0, &c, 1);
     70b:	83 ec 04             	sub    $0x4,%esp
     70e:	6a 01                	push   $0x1
     710:	8d 45 ef             	lea    -0x11(%ebp),%eax
     713:	50                   	push   %eax
     714:	6a 00                	push   $0x0
     716:	e8 47 01 00 00       	call   862 <read>
     71b:	83 c4 10             	add    $0x10,%esp
     71e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     721:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     725:	7e 33                	jle    75a <gets+0x5e>
      break;
    buf[i++] = c;
     727:	8b 45 f4             	mov    -0xc(%ebp),%eax
     72a:	8d 50 01             	lea    0x1(%eax),%edx
     72d:	89 55 f4             	mov    %edx,-0xc(%ebp)
     730:	89 c2                	mov    %eax,%edx
     732:	8b 45 08             	mov    0x8(%ebp),%eax
     735:	01 c2                	add    %eax,%edx
     737:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     73b:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     73d:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     741:	3c 0a                	cmp    $0xa,%al
     743:	74 16                	je     75b <gets+0x5f>
     745:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     749:	3c 0d                	cmp    $0xd,%al
     74b:	74 0e                	je     75b <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     74d:	8b 45 f4             	mov    -0xc(%ebp),%eax
     750:	83 c0 01             	add    $0x1,%eax
     753:	3b 45 0c             	cmp    0xc(%ebp),%eax
     756:	7c b3                	jl     70b <gets+0xf>
     758:	eb 01                	jmp    75b <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     75a:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     75b:	8b 55 f4             	mov    -0xc(%ebp),%edx
     75e:	8b 45 08             	mov    0x8(%ebp),%eax
     761:	01 d0                	add    %edx,%eax
     763:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     766:	8b 45 08             	mov    0x8(%ebp),%eax
}
     769:	c9                   	leave  
     76a:	c3                   	ret    

0000076b <stat>:

int
stat(char *n, struct stat *st)
{
     76b:	55                   	push   %ebp
     76c:	89 e5                	mov    %esp,%ebp
     76e:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     771:	83 ec 08             	sub    $0x8,%esp
     774:	6a 00                	push   $0x0
     776:	ff 75 08             	pushl  0x8(%ebp)
     779:	e8 0c 01 00 00       	call   88a <open>
     77e:	83 c4 10             	add    $0x10,%esp
     781:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     784:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     788:	79 07                	jns    791 <stat+0x26>
    return -1;
     78a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     78f:	eb 25                	jmp    7b6 <stat+0x4b>
  r = fstat(fd, st);
     791:	83 ec 08             	sub    $0x8,%esp
     794:	ff 75 0c             	pushl  0xc(%ebp)
     797:	ff 75 f4             	pushl  -0xc(%ebp)
     79a:	e8 03 01 00 00       	call   8a2 <fstat>
     79f:	83 c4 10             	add    $0x10,%esp
     7a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     7a5:	83 ec 0c             	sub    $0xc,%esp
     7a8:	ff 75 f4             	pushl  -0xc(%ebp)
     7ab:	e8 c2 00 00 00       	call   872 <close>
     7b0:	83 c4 10             	add    $0x10,%esp
  return r;
     7b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     7b6:	c9                   	leave  
     7b7:	c3                   	ret    

000007b8 <atoi>:

int
atoi(const char *s)
{
     7b8:	55                   	push   %ebp
     7b9:	89 e5                	mov    %esp,%ebp
     7bb:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     7be:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     7c5:	eb 25                	jmp    7ec <atoi+0x34>
    n = n*10 + *s++ - '0';
     7c7:	8b 55 fc             	mov    -0x4(%ebp),%edx
     7ca:	89 d0                	mov    %edx,%eax
     7cc:	c1 e0 02             	shl    $0x2,%eax
     7cf:	01 d0                	add    %edx,%eax
     7d1:	01 c0                	add    %eax,%eax
     7d3:	89 c1                	mov    %eax,%ecx
     7d5:	8b 45 08             	mov    0x8(%ebp),%eax
     7d8:	8d 50 01             	lea    0x1(%eax),%edx
     7db:	89 55 08             	mov    %edx,0x8(%ebp)
     7de:	0f b6 00             	movzbl (%eax),%eax
     7e1:	0f be c0             	movsbl %al,%eax
     7e4:	01 c8                	add    %ecx,%eax
     7e6:	83 e8 30             	sub    $0x30,%eax
     7e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     7ec:	8b 45 08             	mov    0x8(%ebp),%eax
     7ef:	0f b6 00             	movzbl (%eax),%eax
     7f2:	3c 2f                	cmp    $0x2f,%al
     7f4:	7e 0a                	jle    800 <atoi+0x48>
     7f6:	8b 45 08             	mov    0x8(%ebp),%eax
     7f9:	0f b6 00             	movzbl (%eax),%eax
     7fc:	3c 39                	cmp    $0x39,%al
     7fe:	7e c7                	jle    7c7 <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     800:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     803:	c9                   	leave  
     804:	c3                   	ret    

00000805 <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     805:	55                   	push   %ebp
     806:	89 e5                	mov    %esp,%ebp
     808:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     80b:	8b 45 08             	mov    0x8(%ebp),%eax
     80e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     811:	8b 45 0c             	mov    0xc(%ebp),%eax
     814:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     817:	eb 17                	jmp    830 <memmove+0x2b>
    *dst++ = *src++;
     819:	8b 45 fc             	mov    -0x4(%ebp),%eax
     81c:	8d 50 01             	lea    0x1(%eax),%edx
     81f:	89 55 fc             	mov    %edx,-0x4(%ebp)
     822:	8b 55 f8             	mov    -0x8(%ebp),%edx
     825:	8d 4a 01             	lea    0x1(%edx),%ecx
     828:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     82b:	0f b6 12             	movzbl (%edx),%edx
     82e:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     830:	8b 45 10             	mov    0x10(%ebp),%eax
     833:	8d 50 ff             	lea    -0x1(%eax),%edx
     836:	89 55 10             	mov    %edx,0x10(%ebp)
     839:	85 c0                	test   %eax,%eax
     83b:	7f dc                	jg     819 <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     83d:	8b 45 08             	mov    0x8(%ebp),%eax
}
     840:	c9                   	leave  
     841:	c3                   	ret    

00000842 <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     842:	b8 01 00 00 00       	mov    $0x1,%eax
     847:	cd 40                	int    $0x40
     849:	c3                   	ret    

0000084a <exit>:
SYSCALL(exit)
     84a:	b8 02 00 00 00       	mov    $0x2,%eax
     84f:	cd 40                	int    $0x40
     851:	c3                   	ret    

00000852 <wait>:
SYSCALL(wait)
     852:	b8 03 00 00 00       	mov    $0x3,%eax
     857:	cd 40                	int    $0x40
     859:	c3                   	ret    

0000085a <pipe>:
SYSCALL(pipe)
     85a:	b8 04 00 00 00       	mov    $0x4,%eax
     85f:	cd 40                	int    $0x40
     861:	c3                   	ret    

00000862 <read>:
SYSCALL(read)
     862:	b8 05 00 00 00       	mov    $0x5,%eax
     867:	cd 40                	int    $0x40
     869:	c3                   	ret    

0000086a <write>:
SYSCALL(write)
     86a:	b8 10 00 00 00       	mov    $0x10,%eax
     86f:	cd 40                	int    $0x40
     871:	c3                   	ret    

00000872 <close>:
SYSCALL(close)
     872:	b8 15 00 00 00       	mov    $0x15,%eax
     877:	cd 40                	int    $0x40
     879:	c3                   	ret    

0000087a <kill>:
SYSCALL(kill)
     87a:	b8 06 00 00 00       	mov    $0x6,%eax
     87f:	cd 40                	int    $0x40
     881:	c3                   	ret    

00000882 <exec>:
SYSCALL(exec)
     882:	b8 07 00 00 00       	mov    $0x7,%eax
     887:	cd 40                	int    $0x40
     889:	c3                   	ret    

0000088a <open>:
SYSCALL(open)
     88a:	b8 0f 00 00 00       	mov    $0xf,%eax
     88f:	cd 40                	int    $0x40
     891:	c3                   	ret    

00000892 <mknod>:
SYSCALL(mknod)
     892:	b8 11 00 00 00       	mov    $0x11,%eax
     897:	cd 40                	int    $0x40
     899:	c3                   	ret    

0000089a <unlink>:
SYSCALL(unlink)
     89a:	b8 12 00 00 00       	mov    $0x12,%eax
     89f:	cd 40                	int    $0x40
     8a1:	c3                   	ret    

000008a2 <fstat>:
SYSCALL(fstat)
     8a2:	b8 08 00 00 00       	mov    $0x8,%eax
     8a7:	cd 40                	int    $0x40
     8a9:	c3                   	ret    

000008aa <link>:
SYSCALL(link)
     8aa:	b8 13 00 00 00       	mov    $0x13,%eax
     8af:	cd 40                	int    $0x40
     8b1:	c3                   	ret    

000008b2 <mkdir>:
SYSCALL(mkdir)
     8b2:	b8 14 00 00 00       	mov    $0x14,%eax
     8b7:	cd 40                	int    $0x40
     8b9:	c3                   	ret    

000008ba <chdir>:
SYSCALL(chdir)
     8ba:	b8 09 00 00 00       	mov    $0x9,%eax
     8bf:	cd 40                	int    $0x40
     8c1:	c3                   	ret    

000008c2 <dup>:
SYSCALL(dup)
     8c2:	b8 0a 00 00 00       	mov    $0xa,%eax
     8c7:	cd 40                	int    $0x40
     8c9:	c3                   	ret    

000008ca <getpid>:
SYSCALL(getpid)
     8ca:	b8 0b 00 00 00       	mov    $0xb,%eax
     8cf:	cd 40                	int    $0x40
     8d1:	c3                   	ret    

000008d2 <sbrk>:
SYSCALL(sbrk)
     8d2:	b8 0c 00 00 00       	mov    $0xc,%eax
     8d7:	cd 40                	int    $0x40
     8d9:	c3                   	ret    

000008da <sleep>:
SYSCALL(sleep)
     8da:	b8 0d 00 00 00       	mov    $0xd,%eax
     8df:	cd 40                	int    $0x40
     8e1:	c3                   	ret    

000008e2 <uptime>:
SYSCALL(uptime)
     8e2:	b8 0e 00 00 00       	mov    $0xe,%eax
     8e7:	cd 40                	int    $0x40
     8e9:	c3                   	ret    

000008ea <createwindow>:
SYSCALL(createwindow)
     8ea:	b8 16 00 00 00       	mov    $0x16,%eax
     8ef:	cd 40                	int    $0x40
     8f1:	c3                   	ret    

000008f2 <repaintwindow>:
SYSCALL(repaintwindow)
     8f2:	b8 17 00 00 00       	mov    $0x17,%eax
     8f7:	cd 40                	int    $0x40
     8f9:	c3                   	ret    

000008fa <getmessage>:
SYSCALL(getmessage)
     8fa:	b8 18 00 00 00       	mov    $0x18,%eax
     8ff:	cd 40                	int    $0x40
     901:	c3                   	ret    

00000902 <settimer>:
SYSCALL(settimer)
     902:	b8 19 00 00 00       	mov    $0x19,%eax
     907:	cd 40                	int    $0x40
     909:	c3                   	ret    

0000090a <updatewindow>:
SYSCALL(updatewindow)
     90a:	b8 1a 00 00 00       	mov    $0x1a,%eax
     90f:	cd 40                	int    $0x40
     911:	c3                   	ret    

00000912 <destroywindow>:
SYSCALL(destroywindow)
     912:	b8 1b 00 00 00       	mov    $0x1b,%eax
     917:	cd 40                	int    $0x40
     919:	c3                   	ret    

0000091a <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     91a:	55                   	push   %ebp
     91b:	89 e5                	mov    %esp,%ebp
     91d:	83 ec 18             	sub    $0x18,%esp
     920:	8b 45 0c             	mov    0xc(%ebp),%eax
     923:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     926:	83 ec 04             	sub    $0x4,%esp
     929:	6a 01                	push   $0x1
     92b:	8d 45 f4             	lea    -0xc(%ebp),%eax
     92e:	50                   	push   %eax
     92f:	ff 75 08             	pushl  0x8(%ebp)
     932:	e8 33 ff ff ff       	call   86a <write>
     937:	83 c4 10             	add    $0x10,%esp
}
     93a:	90                   	nop
     93b:	c9                   	leave  
     93c:	c3                   	ret    

0000093d <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     93d:	55                   	push   %ebp
     93e:	89 e5                	mov    %esp,%ebp
     940:	53                   	push   %ebx
     941:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     944:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     94b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     94f:	74 17                	je     968 <printint+0x2b>
     951:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     955:	79 11                	jns    968 <printint+0x2b>
    neg = 1;
     957:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     95e:	8b 45 0c             	mov    0xc(%ebp),%eax
     961:	f7 d8                	neg    %eax
     963:	89 45 ec             	mov    %eax,-0x14(%ebp)
     966:	eb 06                	jmp    96e <printint+0x31>
  } else {
    x = xx;
     968:	8b 45 0c             	mov    0xc(%ebp),%eax
     96b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     96e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     975:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     978:	8d 41 01             	lea    0x1(%ecx),%eax
     97b:	89 45 f4             	mov    %eax,-0xc(%ebp)
     97e:	8b 5d 10             	mov    0x10(%ebp),%ebx
     981:	8b 45 ec             	mov    -0x14(%ebp),%eax
     984:	ba 00 00 00 00       	mov    $0x0,%edx
     989:	f7 f3                	div    %ebx
     98b:	89 d0                	mov    %edx,%eax
     98d:	0f b6 80 e4 e6 01 00 	movzbl 0x1e6e4(%eax),%eax
     994:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     998:	8b 5d 10             	mov    0x10(%ebp),%ebx
     99b:	8b 45 ec             	mov    -0x14(%ebp),%eax
     99e:	ba 00 00 00 00       	mov    $0x0,%edx
     9a3:	f7 f3                	div    %ebx
     9a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
     9a8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     9ac:	75 c7                	jne    975 <printint+0x38>
  if(neg)
     9ae:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     9b2:	74 2d                	je     9e1 <printint+0xa4>
    buf[i++] = '-';
     9b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
     9b7:	8d 50 01             	lea    0x1(%eax),%edx
     9ba:	89 55 f4             	mov    %edx,-0xc(%ebp)
     9bd:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     9c2:	eb 1d                	jmp    9e1 <printint+0xa4>
    putc(fd, buf[i]);
     9c4:	8d 55 dc             	lea    -0x24(%ebp),%edx
     9c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
     9ca:	01 d0                	add    %edx,%eax
     9cc:	0f b6 00             	movzbl (%eax),%eax
     9cf:	0f be c0             	movsbl %al,%eax
     9d2:	83 ec 08             	sub    $0x8,%esp
     9d5:	50                   	push   %eax
     9d6:	ff 75 08             	pushl  0x8(%ebp)
     9d9:	e8 3c ff ff ff       	call   91a <putc>
     9de:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     9e1:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     9e5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     9e9:	79 d9                	jns    9c4 <printint+0x87>
    putc(fd, buf[i]);
}
     9eb:	90                   	nop
     9ec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     9ef:	c9                   	leave  
     9f0:	c3                   	ret    

000009f1 <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     9f1:	55                   	push   %ebp
     9f2:	89 e5                	mov    %esp,%ebp
     9f4:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     9f7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     9fe:	8d 45 0c             	lea    0xc(%ebp),%eax
     a01:	83 c0 04             	add    $0x4,%eax
     a04:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     a07:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     a0e:	e9 59 01 00 00       	jmp    b6c <printf+0x17b>
    c = fmt[i] & 0xff;
     a13:	8b 55 0c             	mov    0xc(%ebp),%edx
     a16:	8b 45 f0             	mov    -0x10(%ebp),%eax
     a19:	01 d0                	add    %edx,%eax
     a1b:	0f b6 00             	movzbl (%eax),%eax
     a1e:	0f be c0             	movsbl %al,%eax
     a21:	25 ff 00 00 00       	and    $0xff,%eax
     a26:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     a29:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     a2d:	75 2c                	jne    a5b <printf+0x6a>
      if(c == '%'){
     a2f:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     a33:	75 0c                	jne    a41 <printf+0x50>
        state = '%';
     a35:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     a3c:	e9 27 01 00 00       	jmp    b68 <printf+0x177>
      } else {
        putc(fd, c);
     a41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     a44:	0f be c0             	movsbl %al,%eax
     a47:	83 ec 08             	sub    $0x8,%esp
     a4a:	50                   	push   %eax
     a4b:	ff 75 08             	pushl  0x8(%ebp)
     a4e:	e8 c7 fe ff ff       	call   91a <putc>
     a53:	83 c4 10             	add    $0x10,%esp
     a56:	e9 0d 01 00 00       	jmp    b68 <printf+0x177>
      }
    } else if(state == '%'){
     a5b:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     a5f:	0f 85 03 01 00 00    	jne    b68 <printf+0x177>
      if(c == 'd'){
     a65:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     a69:	75 1e                	jne    a89 <printf+0x98>
        printint(fd, *ap, 10, 1);
     a6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
     a6e:	8b 00                	mov    (%eax),%eax
     a70:	6a 01                	push   $0x1
     a72:	6a 0a                	push   $0xa
     a74:	50                   	push   %eax
     a75:	ff 75 08             	pushl  0x8(%ebp)
     a78:	e8 c0 fe ff ff       	call   93d <printint>
     a7d:	83 c4 10             	add    $0x10,%esp
        ap++;
     a80:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     a84:	e9 d8 00 00 00       	jmp    b61 <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     a89:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     a8d:	74 06                	je     a95 <printf+0xa4>
     a8f:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     a93:	75 1e                	jne    ab3 <printf+0xc2>
        printint(fd, *ap, 16, 0);
     a95:	8b 45 e8             	mov    -0x18(%ebp),%eax
     a98:	8b 00                	mov    (%eax),%eax
     a9a:	6a 00                	push   $0x0
     a9c:	6a 10                	push   $0x10
     a9e:	50                   	push   %eax
     a9f:	ff 75 08             	pushl  0x8(%ebp)
     aa2:	e8 96 fe ff ff       	call   93d <printint>
     aa7:	83 c4 10             	add    $0x10,%esp
        ap++;
     aaa:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     aae:	e9 ae 00 00 00       	jmp    b61 <printf+0x170>
      } else if(c == 's'){
     ab3:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     ab7:	75 43                	jne    afc <printf+0x10b>
        s = (char*)*ap;
     ab9:	8b 45 e8             	mov    -0x18(%ebp),%eax
     abc:	8b 00                	mov    (%eax),%eax
     abe:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     ac1:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     ac5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     ac9:	75 25                	jne    af0 <printf+0xff>
          s = "(null)";
     acb:	c7 45 f4 89 63 01 00 	movl   $0x16389,-0xc(%ebp)
        while(*s != 0){
     ad2:	eb 1c                	jmp    af0 <printf+0xff>
          putc(fd, *s);
     ad4:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ad7:	0f b6 00             	movzbl (%eax),%eax
     ada:	0f be c0             	movsbl %al,%eax
     add:	83 ec 08             	sub    $0x8,%esp
     ae0:	50                   	push   %eax
     ae1:	ff 75 08             	pushl  0x8(%ebp)
     ae4:	e8 31 fe ff ff       	call   91a <putc>
     ae9:	83 c4 10             	add    $0x10,%esp
          s++;
     aec:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     af0:	8b 45 f4             	mov    -0xc(%ebp),%eax
     af3:	0f b6 00             	movzbl (%eax),%eax
     af6:	84 c0                	test   %al,%al
     af8:	75 da                	jne    ad4 <printf+0xe3>
     afa:	eb 65                	jmp    b61 <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     afc:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     b00:	75 1d                	jne    b1f <printf+0x12e>
        putc(fd, *ap);
     b02:	8b 45 e8             	mov    -0x18(%ebp),%eax
     b05:	8b 00                	mov    (%eax),%eax
     b07:	0f be c0             	movsbl %al,%eax
     b0a:	83 ec 08             	sub    $0x8,%esp
     b0d:	50                   	push   %eax
     b0e:	ff 75 08             	pushl  0x8(%ebp)
     b11:	e8 04 fe ff ff       	call   91a <putc>
     b16:	83 c4 10             	add    $0x10,%esp
        ap++;
     b19:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     b1d:	eb 42                	jmp    b61 <printf+0x170>
      } else if(c == '%'){
     b1f:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     b23:	75 17                	jne    b3c <printf+0x14b>
        putc(fd, c);
     b25:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     b28:	0f be c0             	movsbl %al,%eax
     b2b:	83 ec 08             	sub    $0x8,%esp
     b2e:	50                   	push   %eax
     b2f:	ff 75 08             	pushl  0x8(%ebp)
     b32:	e8 e3 fd ff ff       	call   91a <putc>
     b37:	83 c4 10             	add    $0x10,%esp
     b3a:	eb 25                	jmp    b61 <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     b3c:	83 ec 08             	sub    $0x8,%esp
     b3f:	6a 25                	push   $0x25
     b41:	ff 75 08             	pushl  0x8(%ebp)
     b44:	e8 d1 fd ff ff       	call   91a <putc>
     b49:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     b4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     b4f:	0f be c0             	movsbl %al,%eax
     b52:	83 ec 08             	sub    $0x8,%esp
     b55:	50                   	push   %eax
     b56:	ff 75 08             	pushl  0x8(%ebp)
     b59:	e8 bc fd ff ff       	call   91a <putc>
     b5e:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     b61:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     b68:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     b6c:	8b 55 0c             	mov    0xc(%ebp),%edx
     b6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
     b72:	01 d0                	add    %edx,%eax
     b74:	0f b6 00             	movzbl (%eax),%eax
     b77:	84 c0                	test   %al,%al
     b79:	0f 85 94 fe ff ff    	jne    a13 <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     b7f:	90                   	nop
     b80:	c9                   	leave  
     b81:	c3                   	ret    

00000b82 <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     b82:	55                   	push   %ebp
     b83:	89 e5                	mov    %esp,%ebp
     b85:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     b88:	8b 45 08             	mov    0x8(%ebp),%eax
     b8b:	83 e8 08             	sub    $0x8,%eax
     b8e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     b91:	a1 30 eb 01 00       	mov    0x1eb30,%eax
     b96:	89 45 fc             	mov    %eax,-0x4(%ebp)
     b99:	eb 24                	jmp    bbf <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     b9b:	8b 45 fc             	mov    -0x4(%ebp),%eax
     b9e:	8b 00                	mov    (%eax),%eax
     ba0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     ba3:	77 12                	ja     bb7 <free+0x35>
     ba5:	8b 45 f8             	mov    -0x8(%ebp),%eax
     ba8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     bab:	77 24                	ja     bd1 <free+0x4f>
     bad:	8b 45 fc             	mov    -0x4(%ebp),%eax
     bb0:	8b 00                	mov    (%eax),%eax
     bb2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     bb5:	77 1a                	ja     bd1 <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     bb7:	8b 45 fc             	mov    -0x4(%ebp),%eax
     bba:	8b 00                	mov    (%eax),%eax
     bbc:	89 45 fc             	mov    %eax,-0x4(%ebp)
     bbf:	8b 45 f8             	mov    -0x8(%ebp),%eax
     bc2:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     bc5:	76 d4                	jbe    b9b <free+0x19>
     bc7:	8b 45 fc             	mov    -0x4(%ebp),%eax
     bca:	8b 00                	mov    (%eax),%eax
     bcc:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     bcf:	76 ca                	jbe    b9b <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     bd1:	8b 45 f8             	mov    -0x8(%ebp),%eax
     bd4:	8b 40 04             	mov    0x4(%eax),%eax
     bd7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     bde:	8b 45 f8             	mov    -0x8(%ebp),%eax
     be1:	01 c2                	add    %eax,%edx
     be3:	8b 45 fc             	mov    -0x4(%ebp),%eax
     be6:	8b 00                	mov    (%eax),%eax
     be8:	39 c2                	cmp    %eax,%edx
     bea:	75 24                	jne    c10 <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     bec:	8b 45 f8             	mov    -0x8(%ebp),%eax
     bef:	8b 50 04             	mov    0x4(%eax),%edx
     bf2:	8b 45 fc             	mov    -0x4(%ebp),%eax
     bf5:	8b 00                	mov    (%eax),%eax
     bf7:	8b 40 04             	mov    0x4(%eax),%eax
     bfa:	01 c2                	add    %eax,%edx
     bfc:	8b 45 f8             	mov    -0x8(%ebp),%eax
     bff:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     c02:	8b 45 fc             	mov    -0x4(%ebp),%eax
     c05:	8b 00                	mov    (%eax),%eax
     c07:	8b 10                	mov    (%eax),%edx
     c09:	8b 45 f8             	mov    -0x8(%ebp),%eax
     c0c:	89 10                	mov    %edx,(%eax)
     c0e:	eb 0a                	jmp    c1a <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     c10:	8b 45 fc             	mov    -0x4(%ebp),%eax
     c13:	8b 10                	mov    (%eax),%edx
     c15:	8b 45 f8             	mov    -0x8(%ebp),%eax
     c18:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     c1a:	8b 45 fc             	mov    -0x4(%ebp),%eax
     c1d:	8b 40 04             	mov    0x4(%eax),%eax
     c20:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     c27:	8b 45 fc             	mov    -0x4(%ebp),%eax
     c2a:	01 d0                	add    %edx,%eax
     c2c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     c2f:	75 20                	jne    c51 <free+0xcf>
    p->s.size += bp->s.size;
     c31:	8b 45 fc             	mov    -0x4(%ebp),%eax
     c34:	8b 50 04             	mov    0x4(%eax),%edx
     c37:	8b 45 f8             	mov    -0x8(%ebp),%eax
     c3a:	8b 40 04             	mov    0x4(%eax),%eax
     c3d:	01 c2                	add    %eax,%edx
     c3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
     c42:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     c45:	8b 45 f8             	mov    -0x8(%ebp),%eax
     c48:	8b 10                	mov    (%eax),%edx
     c4a:	8b 45 fc             	mov    -0x4(%ebp),%eax
     c4d:	89 10                	mov    %edx,(%eax)
     c4f:	eb 08                	jmp    c59 <free+0xd7>
  } else
    p->s.ptr = bp;
     c51:	8b 45 fc             	mov    -0x4(%ebp),%eax
     c54:	8b 55 f8             	mov    -0x8(%ebp),%edx
     c57:	89 10                	mov    %edx,(%eax)
  freep = p;
     c59:	8b 45 fc             	mov    -0x4(%ebp),%eax
     c5c:	a3 30 eb 01 00       	mov    %eax,0x1eb30
}
     c61:	90                   	nop
     c62:	c9                   	leave  
     c63:	c3                   	ret    

00000c64 <morecore>:

static Header*
morecore(uint nu)
{
     c64:	55                   	push   %ebp
     c65:	89 e5                	mov    %esp,%ebp
     c67:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     c6a:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     c71:	77 07                	ja     c7a <morecore+0x16>
    nu = 4096;
     c73:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     c7a:	8b 45 08             	mov    0x8(%ebp),%eax
     c7d:	c1 e0 03             	shl    $0x3,%eax
     c80:	83 ec 0c             	sub    $0xc,%esp
     c83:	50                   	push   %eax
     c84:	e8 49 fc ff ff       	call   8d2 <sbrk>
     c89:	83 c4 10             	add    $0x10,%esp
     c8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     c8f:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     c93:	75 07                	jne    c9c <morecore+0x38>
    return 0;
     c95:	b8 00 00 00 00       	mov    $0x0,%eax
     c9a:	eb 26                	jmp    cc2 <morecore+0x5e>
  hp = (Header*)p;
     c9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
     c9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     ca2:	8b 45 f0             	mov    -0x10(%ebp),%eax
     ca5:	8b 55 08             	mov    0x8(%ebp),%edx
     ca8:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     cab:	8b 45 f0             	mov    -0x10(%ebp),%eax
     cae:	83 c0 08             	add    $0x8,%eax
     cb1:	83 ec 0c             	sub    $0xc,%esp
     cb4:	50                   	push   %eax
     cb5:	e8 c8 fe ff ff       	call   b82 <free>
     cba:	83 c4 10             	add    $0x10,%esp
  return freep;
     cbd:	a1 30 eb 01 00       	mov    0x1eb30,%eax
}
     cc2:	c9                   	leave  
     cc3:	c3                   	ret    

00000cc4 <malloc>:

void*
malloc(uint nbytes)
{
     cc4:	55                   	push   %ebp
     cc5:	89 e5                	mov    %esp,%ebp
     cc7:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     cca:	8b 45 08             	mov    0x8(%ebp),%eax
     ccd:	83 c0 07             	add    $0x7,%eax
     cd0:	c1 e8 03             	shr    $0x3,%eax
     cd3:	83 c0 01             	add    $0x1,%eax
     cd6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     cd9:	a1 30 eb 01 00       	mov    0x1eb30,%eax
     cde:	89 45 f0             	mov    %eax,-0x10(%ebp)
     ce1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     ce5:	75 23                	jne    d0a <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     ce7:	c7 45 f0 28 eb 01 00 	movl   $0x1eb28,-0x10(%ebp)
     cee:	8b 45 f0             	mov    -0x10(%ebp),%eax
     cf1:	a3 30 eb 01 00       	mov    %eax,0x1eb30
     cf6:	a1 30 eb 01 00       	mov    0x1eb30,%eax
     cfb:	a3 28 eb 01 00       	mov    %eax,0x1eb28
    base.s.size = 0;
     d00:	c7 05 2c eb 01 00 00 	movl   $0x0,0x1eb2c
     d07:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     d0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
     d0d:	8b 00                	mov    (%eax),%eax
     d0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     d12:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d15:	8b 40 04             	mov    0x4(%eax),%eax
     d18:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     d1b:	72 4d                	jb     d6a <malloc+0xa6>
      if(p->s.size == nunits)
     d1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d20:	8b 40 04             	mov    0x4(%eax),%eax
     d23:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     d26:	75 0c                	jne    d34 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     d28:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d2b:	8b 10                	mov    (%eax),%edx
     d2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
     d30:	89 10                	mov    %edx,(%eax)
     d32:	eb 26                	jmp    d5a <malloc+0x96>
      else {
        p->s.size -= nunits;
     d34:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d37:	8b 40 04             	mov    0x4(%eax),%eax
     d3a:	2b 45 ec             	sub    -0x14(%ebp),%eax
     d3d:	89 c2                	mov    %eax,%edx
     d3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d42:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     d45:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d48:	8b 40 04             	mov    0x4(%eax),%eax
     d4b:	c1 e0 03             	shl    $0x3,%eax
     d4e:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     d51:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d54:	8b 55 ec             	mov    -0x14(%ebp),%edx
     d57:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     d5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
     d5d:	a3 30 eb 01 00       	mov    %eax,0x1eb30
      return (void*)(p + 1);
     d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d65:	83 c0 08             	add    $0x8,%eax
     d68:	eb 3b                	jmp    da5 <malloc+0xe1>
    }
    if(p == freep)
     d6a:	a1 30 eb 01 00       	mov    0x1eb30,%eax
     d6f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     d72:	75 1e                	jne    d92 <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     d74:	83 ec 0c             	sub    $0xc,%esp
     d77:	ff 75 ec             	pushl  -0x14(%ebp)
     d7a:	e8 e5 fe ff ff       	call   c64 <morecore>
     d7f:	83 c4 10             	add    $0x10,%esp
     d82:	89 45 f4             	mov    %eax,-0xc(%ebp)
     d85:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     d89:	75 07                	jne    d92 <malloc+0xce>
        return 0;
     d8b:	b8 00 00 00 00       	mov    $0x0,%eax
     d90:	eb 13                	jmp    da5 <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     d92:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d95:	89 45 f0             	mov    %eax,-0x10(%ebp)
     d98:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d9b:	8b 00                	mov    (%eax),%eax
     d9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     da0:	e9 6d ff ff ff       	jmp    d12 <malloc+0x4e>
}
     da5:	c9                   	leave  
     da6:	c3                   	ret    

00000da7 <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     da7:	55                   	push   %ebp
     da8:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     daa:	a1 34 eb 01 00       	mov    0x1eb34,%eax
     daf:	83 c0 01             	add    $0x1,%eax
     db2:	a3 34 eb 01 00       	mov    %eax,0x1eb34
    g_seed = (214013*g_seed+2531011);
     db7:	a1 34 eb 01 00       	mov    0x1eb34,%eax
     dbc:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     dc2:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     dc7:	a3 34 eb 01 00       	mov    %eax,0x1eb34
    return (g_seed>>16)&0x7FFF;
     dcc:	a1 34 eb 01 00       	mov    0x1eb34,%eax
     dd1:	c1 e8 10             	shr    $0x10,%eax
     dd4:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     dd9:	5d                   	pop    %ebp
     dda:	c3                   	ret    

00000ddb <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     ddb:	55                   	push   %ebp
     ddc:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     dde:	d9 45 08             	flds   0x8(%ebp)
     de1:	d9 ee                	fldz   
     de3:	d9 c9                	fxch   %st(1)
     de5:	df e9                	fucomip %st(1),%st
     de7:	dd d8                	fstp   %st(0)
     de9:	76 05                	jbe    df0 <abs+0x15>
     deb:	d9 45 08             	flds   0x8(%ebp)
     dee:	eb 05                	jmp    df5 <abs+0x1a>
	return -x;
     df0:	d9 45 08             	flds   0x8(%ebp)
     df3:	d9 e0                	fchs   
}
     df5:	5d                   	pop    %ebp
     df6:	c3                   	ret    

00000df7 <pow>:

float pow(float a, int b)
{
     df7:	55                   	push   %ebp
     df8:	89 e5                	mov    %esp,%ebp
     dfa:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     dfd:	d9 45 08             	flds   0x8(%ebp)
     e00:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     e03:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     e07:	7e 17                	jle    e20 <pow+0x29>
		while (--b)
     e09:	eb 09                	jmp    e14 <pow+0x1d>
			r *= a;
     e0b:	d9 45 fc             	flds   -0x4(%ebp)
     e0e:	d8 4d 08             	fmuls  0x8(%ebp)
     e11:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     e14:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     e18:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     e1c:	75 ed                	jne    e0b <pow+0x14>
     e1e:	eb 2a                	jmp    e4a <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     e20:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     e24:	79 1f                	jns    e45 <pow+0x4e>
		while (++b)
     e26:	eb 09                	jmp    e31 <pow+0x3a>
			r *= a;
     e28:	d9 45 fc             	flds   -0x4(%ebp)
     e2b:	d8 4d 08             	fmuls  0x8(%ebp)
     e2e:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     e31:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     e35:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     e39:	75 ed                	jne    e28 <pow+0x31>
			r *= a;
		r = 1.0 / r;
     e3b:	d9 e8                	fld1   
     e3d:	d8 75 fc             	fdivs  -0x4(%ebp)
     e40:	d9 5d fc             	fstps  -0x4(%ebp)
     e43:	eb 05                	jmp    e4a <pow+0x53>
	}
	else r = 0;
     e45:	d9 ee                	fldz   
     e47:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     e4a:	d9 45 fc             	flds   -0x4(%ebp)
}
     e4d:	c9                   	leave  
     e4e:	c3                   	ret    

00000e4f <sqrt>:

float sqrt(float number) {
     e4f:	55                   	push   %ebp
     e50:	89 e5                	mov    %esp,%ebp
     e52:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     e55:	d9 ee                	fldz   
     e57:	d9 45 08             	flds   0x8(%ebp)
     e5a:	d9 c9                	fxch   %st(1)
     e5c:	df e9                	fucomip %st(1),%st
     e5e:	dd d8                	fstp   %st(0)
     e60:	76 06                	jbe    e68 <sqrt+0x19>
		return -1;
     e62:	d9 e8                	fld1   
     e64:	d9 e0                	fchs   
     e66:	eb 3a                	jmp    ea2 <sqrt+0x53>
	}

	new_guess = 1;
     e68:	d9 e8                	fld1   
     e6a:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
     e6d:	d9 45 fc             	flds   -0x4(%ebp)
     e70:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
     e73:	d9 45 08             	flds   0x8(%ebp)
     e76:	d8 75 f8             	fdivs  -0x8(%ebp)
     e79:	d8 45 f8             	fadds  -0x8(%ebp)
     e7c:	d9 05 90 63 01 00    	flds   0x16390
     e82:	de f9                	fdivrp %st,%st(1)
     e84:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
     e87:	d9 45 fc             	flds   -0x4(%ebp)
     e8a:	d9 45 f8             	flds   -0x8(%ebp)
     e8d:	df e9                	fucomip %st(1),%st
     e8f:	dd d8                	fstp   %st(0)
     e91:	7a da                	jp     e6d <sqrt+0x1e>
     e93:	d9 45 fc             	flds   -0x4(%ebp)
     e96:	d9 45 f8             	flds   -0x8(%ebp)
     e99:	df e9                	fucomip %st(1),%st
     e9b:	dd d8                	fstp   %st(0)
     e9d:	75 ce                	jne    e6d <sqrt+0x1e>

	return new_guess;
     e9f:	d9 45 fc             	flds   -0x4(%ebp)
}
     ea2:	c9                   	leave  
     ea3:	c3                   	ret    

00000ea4 <cos>:

float cos(float x)
{
     ea4:	55                   	push   %ebp
     ea5:	89 e5                	mov    %esp,%ebp
     ea7:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     eaa:	d9 e8                	fld1   
     eac:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     eaf:	d9 45 08             	flds   0x8(%ebp)
     eb2:	dd 05 98 63 01 00    	fldl   0x16398
     eb8:	d9 c9                	fxch   %st(1)
     eba:	df e9                	fucomip %st(1),%st
     ebc:	dd d8                	fstp   %st(0)
     ebe:	77 0f                	ja     ecf <cos+0x2b>
     ec0:	d9 45 08             	flds   0x8(%ebp)
     ec3:	dd 05 a0 63 01 00    	fldl   0x163a0
     ec9:	df e9                	fucomip %st(1),%st
     ecb:	dd d8                	fstp   %st(0)
     ecd:	76 3c                	jbe    f0b <cos+0x67>
     ecf:	d9 45 08             	flds   0x8(%ebp)
     ed2:	d9 45 08             	flds   0x8(%ebp)
     ed5:	dd 05 98 63 01 00    	fldl   0x16398
     edb:	de f9                	fdivrp %st,%st(1)
     edd:	d9 7d e2             	fnstcw -0x1e(%ebp)
     ee0:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     ee4:	b4 0c                	mov    $0xc,%ah
     ee6:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     eea:	d9 6d e0             	fldcw  -0x20(%ebp)
     eed:	db 5d dc             	fistpl -0x24(%ebp)
     ef0:	d9 6d e2             	fldcw  -0x1e(%ebp)
     ef3:	8b 45 dc             	mov    -0x24(%ebp),%eax
     ef6:	01 c0                	add    %eax,%eax
     ef8:	89 45 d8             	mov    %eax,-0x28(%ebp)
     efb:	db 45 d8             	fildl  -0x28(%ebp)
     efe:	dd 05 a8 63 01 00    	fldl   0x163a8
     f04:	de c9                	fmulp  %st,%st(1)
     f06:	de e9                	fsubrp %st,%st(1)
     f08:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     f0b:	d9 45 08             	flds   0x8(%ebp)
     f0e:	dd 05 a8 63 01 00    	fldl   0x163a8
     f14:	d9 c9                	fxch   %st(1)
     f16:	df e9                	fucomip %st(1),%st
     f18:	dd d8                	fstp   %st(0)
     f1a:	76 0e                	jbe    f2a <cos+0x86>
     f1c:	d9 45 08             	flds   0x8(%ebp)
     f1f:	dd 05 98 63 01 00    	fldl   0x16398
     f25:	de e9                	fsubrp %st,%st(1)
     f27:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     f2a:	d9 45 08             	flds   0x8(%ebp)
     f2d:	dd 05 b0 63 01 00    	fldl   0x163b0
     f33:	df e9                	fucomip %st(1),%st
     f35:	dd d8                	fstp   %st(0)
     f37:	76 0e                	jbe    f47 <cos+0xa3>
     f39:	d9 45 08             	flds   0x8(%ebp)
     f3c:	dd 05 98 63 01 00    	fldl   0x16398
     f42:	de c1                	faddp  %st,%st(1)
     f44:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     f47:	d9 45 08             	flds   0x8(%ebp)
     f4a:	dd 05 b8 63 01 00    	fldl   0x163b8
     f50:	d9 c9                	fxch   %st(1)
     f52:	df e9                	fucomip %st(1),%st
     f54:	dd d8                	fstp   %st(0)
     f56:	76 16                	jbe    f6e <cos+0xca>
    {
        x -= PI;
     f58:	d9 45 08             	flds   0x8(%ebp)
     f5b:	dd 05 a8 63 01 00    	fldl   0x163a8
     f61:	de e9                	fsubrp %st,%st(1)
     f63:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     f66:	d9 45 f4             	flds   -0xc(%ebp)
     f69:	d9 e0                	fchs   
     f6b:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     f6e:	d9 45 08             	flds   0x8(%ebp)
     f71:	dd 05 c0 63 01 00    	fldl   0x163c0
     f77:	df e9                	fucomip %st(1),%st
     f79:	dd d8                	fstp   %st(0)
     f7b:	76 16                	jbe    f93 <cos+0xef>
    {
        x += PI;
     f7d:	d9 45 08             	flds   0x8(%ebp)
     f80:	dd 05 a8 63 01 00    	fldl   0x163a8
     f86:	de c1                	faddp  %st,%st(1)
     f88:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     f8b:	d9 45 f4             	flds   -0xc(%ebp)
     f8e:	d9 e0                	fchs   
     f90:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
     f93:	d9 45 08             	flds   0x8(%ebp)
     f96:	dd 05 c8 63 01 00    	fldl   0x163c8
     f9c:	d9 c9                	fxch   %st(1)
     f9e:	df e9                	fucomip %st(1),%st
     fa0:	dd d8                	fstp   %st(0)
     fa2:	76 28                	jbe    fcc <cos+0x128>
     fa4:	d9 45 08             	flds   0x8(%ebp)
     fa7:	dd 05 b8 63 01 00    	fldl   0x163b8
     fad:	de e1                	fsubp  %st,%st(1)
     faf:	d9 5d e4             	fstps  -0x1c(%ebp)
     fb2:	d9 45 e4             	flds   -0x1c(%ebp)
     fb5:	83 ec 0c             	sub    $0xc,%esp
     fb8:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     fbc:	d9 1c 24             	fstps  (%esp)
     fbf:	e8 83 00 00 00       	call   1047 <sin>
     fc4:	83 c4 10             	add    $0x10,%esp
     fc7:	d8 4d f4             	fmuls  -0xc(%ebp)
     fca:	eb 79                	jmp    1045 <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
     fcc:	83 ec 08             	sub    $0x8,%esp
     fcf:	6a 02                	push   $0x2
     fd1:	ff 75 08             	pushl  0x8(%ebp)
     fd4:	e8 1e fe ff ff       	call   df7 <pow>
     fd9:	83 c4 10             	add    $0x10,%esp
     fdc:	d9 05 90 63 01 00    	flds   0x16390
     fe2:	de f9                	fdivrp %st,%st(1)
     fe4:	d9 e8                	fld1   
     fe6:	de e1                	fsubp  %st,%st(1)
     fe8:	d9 5d d8             	fstps  -0x28(%ebp)
     feb:	83 ec 08             	sub    $0x8,%esp
     fee:	6a 04                	push   $0x4
     ff0:	ff 75 08             	pushl  0x8(%ebp)
     ff3:	e8 ff fd ff ff       	call   df7 <pow>
     ff8:	83 c4 10             	add    $0x10,%esp
     ffb:	d9 05 d0 63 01 00    	flds   0x163d0
    1001:	de f9                	fdivrp %st,%st(1)
    1003:	d8 45 d8             	fadds  -0x28(%ebp)
    1006:	d9 5d d8             	fstps  -0x28(%ebp)
    1009:	83 ec 08             	sub    $0x8,%esp
    100c:	6a 06                	push   $0x6
    100e:	ff 75 08             	pushl  0x8(%ebp)
    1011:	e8 e1 fd ff ff       	call   df7 <pow>
    1016:	83 c4 10             	add    $0x10,%esp
    1019:	d9 05 d4 63 01 00    	flds   0x163d4
    101f:	de f9                	fdivrp %st,%st(1)
    1021:	d8 6d d8             	fsubrs -0x28(%ebp)
    1024:	d9 5d d8             	fstps  -0x28(%ebp)
    1027:	83 ec 08             	sub    $0x8,%esp
    102a:	6a 08                	push   $0x8
    102c:	ff 75 08             	pushl  0x8(%ebp)
    102f:	e8 c3 fd ff ff       	call   df7 <pow>
    1034:	83 c4 10             	add    $0x10,%esp
    1037:	d9 05 d8 63 01 00    	flds   0x163d8
    103d:	de f9                	fdivrp %st,%st(1)
    103f:	d8 45 d8             	fadds  -0x28(%ebp)
    1042:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    1045:	c9                   	leave  
    1046:	c3                   	ret    

00001047 <sin>:

float sin(float x)
{
    1047:	55                   	push   %ebp
    1048:	89 e5                	mov    %esp,%ebp
    104a:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
    104d:	d9 e8                	fld1   
    104f:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
    1052:	d9 45 08             	flds   0x8(%ebp)
    1055:	dd 05 98 63 01 00    	fldl   0x16398
    105b:	d9 c9                	fxch   %st(1)
    105d:	df e9                	fucomip %st(1),%st
    105f:	dd d8                	fstp   %st(0)
    1061:	77 0f                	ja     1072 <sin+0x2b>
    1063:	d9 45 08             	flds   0x8(%ebp)
    1066:	dd 05 a0 63 01 00    	fldl   0x163a0
    106c:	df e9                	fucomip %st(1),%st
    106e:	dd d8                	fstp   %st(0)
    1070:	76 3c                	jbe    10ae <sin+0x67>
    1072:	d9 45 08             	flds   0x8(%ebp)
    1075:	d9 45 08             	flds   0x8(%ebp)
    1078:	dd 05 98 63 01 00    	fldl   0x16398
    107e:	de f9                	fdivrp %st,%st(1)
    1080:	d9 7d e2             	fnstcw -0x1e(%ebp)
    1083:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
    1087:	b4 0c                	mov    $0xc,%ah
    1089:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    108d:	d9 6d e0             	fldcw  -0x20(%ebp)
    1090:	db 5d dc             	fistpl -0x24(%ebp)
    1093:	d9 6d e2             	fldcw  -0x1e(%ebp)
    1096:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1099:	01 c0                	add    %eax,%eax
    109b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    109e:	db 45 d8             	fildl  -0x28(%ebp)
    10a1:	dd 05 a8 63 01 00    	fldl   0x163a8
    10a7:	de c9                	fmulp  %st,%st(1)
    10a9:	de e9                	fsubrp %st,%st(1)
    10ab:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
    10ae:	d9 45 08             	flds   0x8(%ebp)
    10b1:	dd 05 a8 63 01 00    	fldl   0x163a8
    10b7:	d9 c9                	fxch   %st(1)
    10b9:	df e9                	fucomip %st(1),%st
    10bb:	dd d8                	fstp   %st(0)
    10bd:	76 0e                	jbe    10cd <sin+0x86>
    10bf:	d9 45 08             	flds   0x8(%ebp)
    10c2:	dd 05 98 63 01 00    	fldl   0x16398
    10c8:	de e9                	fsubrp %st,%st(1)
    10ca:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
    10cd:	d9 45 08             	flds   0x8(%ebp)
    10d0:	dd 05 b0 63 01 00    	fldl   0x163b0
    10d6:	df e9                	fucomip %st(1),%st
    10d8:	dd d8                	fstp   %st(0)
    10da:	76 0e                	jbe    10ea <sin+0xa3>
    10dc:	d9 45 08             	flds   0x8(%ebp)
    10df:	dd 05 98 63 01 00    	fldl   0x16398
    10e5:	de c1                	faddp  %st,%st(1)
    10e7:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
    10ea:	d9 45 08             	flds   0x8(%ebp)
    10ed:	dd 05 b8 63 01 00    	fldl   0x163b8
    10f3:	d9 c9                	fxch   %st(1)
    10f5:	df e9                	fucomip %st(1),%st
    10f7:	dd d8                	fstp   %st(0)
    10f9:	76 16                	jbe    1111 <sin+0xca>
    {
        x -= PI;
    10fb:	d9 45 08             	flds   0x8(%ebp)
    10fe:	dd 05 a8 63 01 00    	fldl   0x163a8
    1104:	de e9                	fsubrp %st,%st(1)
    1106:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    1109:	d9 45 f4             	flds   -0xc(%ebp)
    110c:	d9 e0                	fchs   
    110e:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
    1111:	d9 45 08             	flds   0x8(%ebp)
    1114:	dd 05 c0 63 01 00    	fldl   0x163c0
    111a:	df e9                	fucomip %st(1),%st
    111c:	dd d8                	fstp   %st(0)
    111e:	76 16                	jbe    1136 <sin+0xef>
    {
        x += PI;
    1120:	d9 45 08             	flds   0x8(%ebp)
    1123:	dd 05 a8 63 01 00    	fldl   0x163a8
    1129:	de c1                	faddp  %st,%st(1)
    112b:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    112e:	d9 45 f4             	flds   -0xc(%ebp)
    1131:	d9 e0                	fchs   
    1133:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
    1136:	d9 ee                	fldz   
    1138:	d9 45 08             	flds   0x8(%ebp)
    113b:	d9 c9                	fxch   %st(1)
    113d:	df e9                	fucomip %st(1),%st
    113f:	dd d8                	fstp   %st(0)
    1141:	76 10                	jbe    1153 <sin+0x10c>
    {
        x *= -1;
    1143:	d9 45 08             	flds   0x8(%ebp)
    1146:	d9 e0                	fchs   
    1148:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    114b:	d9 45 f4             	flds   -0xc(%ebp)
    114e:	d9 e0                	fchs   
    1150:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
    1153:	d9 45 08             	flds   0x8(%ebp)
    1156:	dd 05 c8 63 01 00    	fldl   0x163c8
    115c:	d9 c9                	fxch   %st(1)
    115e:	df e9                	fucomip %st(1),%st
    1160:	dd d8                	fstp   %st(0)
    1162:	76 28                	jbe    118c <sin+0x145>
    1164:	d9 45 08             	flds   0x8(%ebp)
    1167:	dd 05 b8 63 01 00    	fldl   0x163b8
    116d:	de e1                	fsubp  %st,%st(1)
    116f:	d9 5d e4             	fstps  -0x1c(%ebp)
    1172:	d9 45 e4             	flds   -0x1c(%ebp)
    1175:	83 ec 0c             	sub    $0xc,%esp
    1178:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    117c:	d9 1c 24             	fstps  (%esp)
    117f:	e8 20 fd ff ff       	call   ea4 <cos>
    1184:	83 c4 10             	add    $0x10,%esp
    1187:	d8 4d f4             	fmuls  -0xc(%ebp)
    118a:	eb 7a                	jmp    1206 <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
    118c:	83 ec 08             	sub    $0x8,%esp
    118f:	6a 03                	push   $0x3
    1191:	ff 75 08             	pushl  0x8(%ebp)
    1194:	e8 5e fc ff ff       	call   df7 <pow>
    1199:	83 c4 10             	add    $0x10,%esp
    119c:	d9 05 dc 63 01 00    	flds   0x163dc
    11a2:	de f9                	fdivrp %st,%st(1)
    11a4:	d9 45 08             	flds   0x8(%ebp)
    11a7:	de e1                	fsubp  %st,%st(1)
    11a9:	d9 5d d8             	fstps  -0x28(%ebp)
    11ac:	83 ec 08             	sub    $0x8,%esp
    11af:	6a 05                	push   $0x5
    11b1:	ff 75 08             	pushl  0x8(%ebp)
    11b4:	e8 3e fc ff ff       	call   df7 <pow>
    11b9:	83 c4 10             	add    $0x10,%esp
    11bc:	d9 05 e0 63 01 00    	flds   0x163e0
    11c2:	de f9                	fdivrp %st,%st(1)
    11c4:	d8 45 d8             	fadds  -0x28(%ebp)
    11c7:	d9 5d d8             	fstps  -0x28(%ebp)
    11ca:	83 ec 08             	sub    $0x8,%esp
    11cd:	6a 07                	push   $0x7
    11cf:	ff 75 08             	pushl  0x8(%ebp)
    11d2:	e8 20 fc ff ff       	call   df7 <pow>
    11d7:	83 c4 10             	add    $0x10,%esp
    11da:	d9 05 e4 63 01 00    	flds   0x163e4
    11e0:	de f9                	fdivrp %st,%st(1)
    11e2:	d8 6d d8             	fsubrs -0x28(%ebp)
    11e5:	d9 5d d8             	fstps  -0x28(%ebp)
    11e8:	83 ec 08             	sub    $0x8,%esp
    11eb:	6a 09                	push   $0x9
    11ed:	ff 75 08             	pushl  0x8(%ebp)
    11f0:	e8 02 fc ff ff       	call   df7 <pow>
    11f5:	83 c4 10             	add    $0x10,%esp
    11f8:	d9 05 e8 63 01 00    	flds   0x163e8
    11fe:	de f9                	fdivrp %st,%st(1)
    1200:	d8 45 d8             	fadds  -0x28(%ebp)
    1203:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    1206:	c9                   	leave  
    1207:	c3                   	ret    

00001208 <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
    1208:	55                   	push   %ebp
    1209:	89 e5                	mov    %esp,%ebp
    120b:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    120e:	83 ec 04             	sub    $0x4,%esp
    1211:	6a 0e                	push   $0xe
    1213:	ff 75 0c             	pushl  0xc(%ebp)
    1216:	ff 75 08             	pushl  0x8(%ebp)
    1219:	e8 44 f6 ff ff       	call   862 <read>
    121e:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1221:	83 ec 04             	sub    $0x4,%esp
    1224:	6a 28                	push   $0x28
    1226:	ff 75 10             	pushl  0x10(%ebp)
    1229:	ff 75 08             	pushl  0x8(%ebp)
    122c:	e8 31 f6 ff ff       	call   862 <read>
    1231:	83 c4 10             	add    $0x10,%esp
}
    1234:	90                   	nop
    1235:	c9                   	leave  
    1236:	c3                   	ret    

00001237 <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
    1237:	55                   	push   %ebp
    1238:	89 e5                	mov    %esp,%ebp
    123a:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    1240:	83 ec 08             	sub    $0x8,%esp
    1243:	6a 00                	push   $0x0
    1245:	ff 75 08             	pushl  0x8(%ebp)
    1248:	e8 3d f6 ff ff       	call   88a <open>
    124d:	83 c4 10             	add    $0x10,%esp
    1250:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    1253:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1257:	79 0a                	jns    1263 <readBitmapFile+0x2c>
        return -1;
    1259:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    125e:	e9 6e 01 00 00       	jmp    13d1 <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    1263:	83 ec 04             	sub    $0x4,%esp
    1266:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    1269:	50                   	push   %eax
    126a:	8d 45 ca             	lea    -0x36(%ebp),%eax
    126d:	50                   	push   %eax
    126e:	ff 75 ec             	pushl  -0x14(%ebp)
    1271:	e8 92 ff ff ff       	call   1208 <readBitmapHeader>
    1276:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    1279:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    127c:	83 e8 36             	sub    $0x36,%eax
    127f:	83 ec 04             	sub    $0x4,%esp
    1282:	50                   	push   %eax
    1283:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    1289:	50                   	push   %eax
    128a:	ff 75 ec             	pushl  -0x14(%ebp)
    128d:	e8 d0 f5 ff ff       	call   862 <read>
    1292:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    1295:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    1298:	8b 45 14             	mov    0x14(%ebp),%eax
    129b:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    129d:	8b 55 aa             	mov    -0x56(%ebp),%edx
    12a0:	8b 45 10             	mov    0x10(%ebp),%eax
    12a3:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    12a5:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    12a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    12ab:	8b 45 aa             	mov    -0x56(%ebp),%eax
    12ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    12b1:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    12b5:	0f b7 c0             	movzwl %ax,%eax
    12b8:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    12bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    12be:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    12c2:	8d 50 07             	lea    0x7(%eax),%edx
    12c5:	85 c0                	test   %eax,%eax
    12c7:	0f 48 c2             	cmovs  %edx,%eax
    12ca:	c1 f8 03             	sar    $0x3,%eax
    12cd:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    12d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    12d3:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    12d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    12d9:	83 e8 01             	sub    $0x1,%eax
    12dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    12df:	e9 d0 00 00 00       	jmp    13b4 <readBitmapFile+0x17d>
        if (bits == 32) {
    12e4:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
    12e8:	75 22                	jne    130c <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    12ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    12ed:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    12f1:	89 c2                	mov    %eax,%edx
    12f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
    12f6:	01 d0                	add    %edx,%eax
    12f8:	83 ec 04             	sub    $0x4,%esp
    12fb:	ff 75 dc             	pushl  -0x24(%ebp)
    12fe:	50                   	push   %eax
    12ff:	ff 75 ec             	pushl  -0x14(%ebp)
    1302:	e8 5b f5 ff ff       	call   862 <read>
    1307:	83 c4 10             	add    $0x10,%esp
    130a:	eb 65                	jmp    1371 <readBitmapFile+0x13a>
        } else {
            int j = 0;
    130c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    1313:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    131a:	eb 4d                	jmp    1369 <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
    131c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    131f:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    1323:	c1 e0 02             	shl    $0x2,%eax
    1326:	89 c2                	mov    %eax,%edx
    1328:	8b 45 f0             	mov    -0x10(%ebp),%eax
    132b:	c1 e0 02             	shl    $0x2,%eax
    132e:	01 c2                	add    %eax,%edx
    1330:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1333:	01 d0                	add    %edx,%eax
    1335:	83 ec 04             	sub    $0x4,%esp
    1338:	6a 03                	push   $0x3
    133a:	50                   	push   %eax
    133b:	ff 75 ec             	pushl  -0x14(%ebp)
    133e:	e8 1f f5 ff ff       	call   862 <read>
    1343:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
    1346:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1349:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    134d:	c1 e0 02             	shl    $0x2,%eax
    1350:	89 c2                	mov    %eax,%edx
    1352:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1355:	c1 e0 02             	shl    $0x2,%eax
    1358:	01 d0                	add    %edx,%eax
    135a:	8d 50 03             	lea    0x3(%eax),%edx
    135d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1360:	01 d0                	add    %edx,%eax
    1362:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    1365:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1369:	8b 45 f0             	mov    -0x10(%ebp),%eax
    136c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    136f:	7c ab                	jl     131c <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
    1371:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1374:	99                   	cltd   
    1375:	c1 ea 1e             	shr    $0x1e,%edx
    1378:	01 d0                	add    %edx,%eax
    137a:	83 e0 03             	and    $0x3,%eax
    137d:	29 d0                	sub    %edx,%eax
    137f:	85 c0                	test   %eax,%eax
    1381:	7e 2d                	jle    13b0 <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1383:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1386:	99                   	cltd   
    1387:	c1 ea 1e             	shr    $0x1e,%edx
    138a:	01 d0                	add    %edx,%eax
    138c:	83 e0 03             	and    $0x3,%eax
    138f:	29 d0                	sub    %edx,%eax
    1391:	ba 04 00 00 00       	mov    $0x4,%edx
    1396:	29 c2                	sub    %eax,%edx
    1398:	89 d0                	mov    %edx,%eax
    139a:	83 ec 04             	sub    $0x4,%esp
    139d:	50                   	push   %eax
    139e:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    13a4:	50                   	push   %eax
    13a5:	ff 75 ec             	pushl  -0x14(%ebp)
    13a8:	e8 b5 f4 ff ff       	call   862 <read>
    13ad:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    13b0:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    13b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    13b8:	0f 89 26 ff ff ff    	jns    12e4 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    13be:	83 ec 0c             	sub    $0xc,%esp
    13c1:	ff 75 ec             	pushl  -0x14(%ebp)
    13c4:	e8 a9 f4 ff ff       	call   872 <close>
    13c9:	83 c4 10             	add    $0x10,%esp
    return 0;
    13cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13d1:	c9                   	leave  
    13d2:	c3                   	ret    

000013d3 <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
    13d3:	55                   	push   %ebp
    13d4:	89 e5                	mov    %esp,%ebp
    13d6:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    13dc:	83 ec 08             	sub    $0x8,%esp
    13df:	6a 00                	push   $0x0
    13e1:	ff 75 08             	pushl  0x8(%ebp)
    13e4:	e8 a1 f4 ff ff       	call   88a <open>
    13e9:	83 c4 10             	add    $0x10,%esp
    13ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    13ef:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    13f3:	79 0a                	jns    13ff <read24BitmapFile+0x2c>
        return -1;
    13f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    13fa:	e9 66 01 00 00       	jmp    1565 <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    13ff:	83 ec 04             	sub    $0x4,%esp
    1402:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    1405:	50                   	push   %eax
    1406:	8d 45 ca             	lea    -0x36(%ebp),%eax
    1409:	50                   	push   %eax
    140a:	ff 75 ec             	pushl  -0x14(%ebp)
    140d:	e8 f6 fd ff ff       	call   1208 <readBitmapHeader>
    1412:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    1415:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    1418:	83 e8 36             	sub    $0x36,%eax
    141b:	83 ec 04             	sub    $0x4,%esp
    141e:	50                   	push   %eax
    141f:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    1425:	50                   	push   %eax
    1426:	ff 75 ec             	pushl  -0x14(%ebp)
    1429:	e8 34 f4 ff ff       	call   862 <read>
    142e:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    1431:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    1434:	8b 45 14             	mov    0x14(%ebp),%eax
    1437:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    1439:	8b 55 aa             	mov    -0x56(%ebp),%edx
    143c:	8b 45 10             	mov    0x10(%ebp),%eax
    143f:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    1441:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    1444:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    1447:	8b 45 aa             	mov    -0x56(%ebp),%eax
    144a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    144d:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    1451:	0f b7 c0             	movzwl %ax,%eax
    1454:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
    1457:	8b 55 e8             	mov    -0x18(%ebp),%edx
    145a:	89 d0                	mov    %edx,%eax
    145c:	01 c0                	add    %eax,%eax
    145e:	01 d0                	add    %edx,%eax
    1460:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    1463:	8b 45 0c             	mov    0xc(%ebp),%eax
    1466:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    1469:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    146c:	83 e8 01             	sub    $0x1,%eax
    146f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1472:	e9 d1 00 00 00       	jmp    1548 <read24BitmapFile+0x175>
        if (bits == 24) {
    1477:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
    147b:	75 22                	jne    149f <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    147d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1480:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    1484:	89 c2                	mov    %eax,%edx
    1486:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1489:	01 d0                	add    %edx,%eax
    148b:	83 ec 04             	sub    $0x4,%esp
    148e:	ff 75 dc             	pushl  -0x24(%ebp)
    1491:	50                   	push   %eax
    1492:	ff 75 ec             	pushl  -0x14(%ebp)
    1495:	e8 c8 f3 ff ff       	call   862 <read>
    149a:	83 c4 10             	add    $0x10,%esp
    149d:	eb 66                	jmp    1505 <read24BitmapFile+0x132>
        } else {
            int j = 0;
    149f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    14a6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    14ad:	eb 4e                	jmp    14fd <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
    14af:	8b 45 f4             	mov    -0xc(%ebp),%eax
    14b2:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    14b6:	89 c2                	mov    %eax,%edx
    14b8:	89 d0                	mov    %edx,%eax
    14ba:	01 c0                	add    %eax,%eax
    14bc:	01 d0                	add    %edx,%eax
    14be:	89 c1                	mov    %eax,%ecx
    14c0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    14c3:	89 d0                	mov    %edx,%eax
    14c5:	01 c0                	add    %eax,%eax
    14c7:	01 d0                	add    %edx,%eax
    14c9:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    14cc:	8b 45 d8             	mov    -0x28(%ebp),%eax
    14cf:	01 d0                	add    %edx,%eax
    14d1:	83 ec 04             	sub    $0x4,%esp
    14d4:	6a 03                	push   $0x3
    14d6:	50                   	push   %eax
    14d7:	ff 75 ec             	pushl  -0x14(%ebp)
    14da:	e8 83 f3 ff ff       	call   862 <read>
    14df:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
    14e2:	83 ec 04             	sub    $0x4,%esp
    14e5:	6a 01                	push   $0x1
    14e7:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    14ed:	50                   	push   %eax
    14ee:	ff 75 ec             	pushl  -0x14(%ebp)
    14f1:	e8 6c f3 ff ff       	call   862 <read>
    14f6:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    14f9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    14fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1500:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    1503:	7c aa                	jl     14af <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    1505:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1508:	99                   	cltd   
    1509:	c1 ea 1e             	shr    $0x1e,%edx
    150c:	01 d0                	add    %edx,%eax
    150e:	83 e0 03             	and    $0x3,%eax
    1511:	29 d0                	sub    %edx,%eax
    1513:	85 c0                	test   %eax,%eax
    1515:	7e 2d                	jle    1544 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1517:	8b 45 dc             	mov    -0x24(%ebp),%eax
    151a:	99                   	cltd   
    151b:	c1 ea 1e             	shr    $0x1e,%edx
    151e:	01 d0                	add    %edx,%eax
    1520:	83 e0 03             	and    $0x3,%eax
    1523:	29 d0                	sub    %edx,%eax
    1525:	ba 04 00 00 00       	mov    $0x4,%edx
    152a:	29 c2                	sub    %eax,%edx
    152c:	89 d0                	mov    %edx,%eax
    152e:	83 ec 04             	sub    $0x4,%esp
    1531:	50                   	push   %eax
    1532:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    1538:	50                   	push   %eax
    1539:	ff 75 ec             	pushl  -0x14(%ebp)
    153c:	e8 21 f3 ff ff       	call   862 <read>
    1541:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    1544:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1548:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    154c:	0f 89 25 ff ff ff    	jns    1477 <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1552:	83 ec 0c             	sub    $0xc,%esp
    1555:	ff 75 ec             	pushl  -0x14(%ebp)
    1558:	e8 15 f3 ff ff       	call   872 <close>
    155d:	83 c4 10             	add    $0x10,%esp
    return 0;
    1560:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1565:	c9                   	leave  
    1566:	c3                   	ret    

00001567 <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    1567:	55                   	push   %ebp
    1568:	89 e5                	mov    %esp,%ebp
    156a:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    156d:	8b 55 10             	mov    0x10(%ebp),%edx
    1570:	89 d0                	mov    %edx,%eax
    1572:	01 c0                	add    %eax,%eax
    1574:	01 d0                	add    %edx,%eax
    1576:	c1 e0 03             	shl    $0x3,%eax
    1579:	83 c0 1f             	add    $0x1f,%eax
    157c:	8d 50 1f             	lea    0x1f(%eax),%edx
    157f:	85 c0                	test   %eax,%eax
    1581:	0f 48 c2             	cmovs  %edx,%eax
    1584:	c1 f8 05             	sar    $0x5,%eax
    1587:	c1 e0 02             	shl    $0x2,%eax
    158a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    158d:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    1593:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1596:	0f af 45 0c          	imul   0xc(%ebp),%eax
    159a:	83 c0 36             	add    $0x36,%eax
    159d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    15a0:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    15a6:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    15ac:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    15b3:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    15ba:	8b 45 10             	mov    0x10(%ebp),%eax
    15bd:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    15c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    15c3:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    15c6:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    15cc:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    15d2:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    15d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    15dc:	0f af 45 0c          	imul   0xc(%ebp),%eax
    15e0:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    15e3:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    15ea:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    15f1:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    15f8:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    15ff:	83 ec 04             	sub    $0x4,%esp
    1602:	6a 0e                	push   $0xe
    1604:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    1607:	50                   	push   %eax
    1608:	ff 75 08             	pushl  0x8(%ebp)
    160b:	e8 5a f2 ff ff       	call   86a <write>
    1610:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1613:	83 ec 04             	sub    $0x4,%esp
    1616:	6a 28                	push   $0x28
    1618:	8d 45 be             	lea    -0x42(%ebp),%eax
    161b:	50                   	push   %eax
    161c:	ff 75 08             	pushl  0x8(%ebp)
    161f:	e8 46 f2 ff ff       	call   86a <write>
    1624:	83 c4 10             	add    $0x10,%esp
}
    1627:	90                   	nop
    1628:	c9                   	leave  
    1629:	c3                   	ret    

0000162a <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    162a:	55                   	push   %ebp
    162b:	89 e5                	mov    %esp,%ebp
    162d:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    1630:	83 ec 08             	sub    $0x8,%esp
    1633:	68 02 02 00 00       	push   $0x202
    1638:	ff 75 08             	pushl  0x8(%ebp)
    163b:	e8 4a f2 ff ff       	call   88a <open>
    1640:	83 c4 10             	add    $0x10,%esp
    1643:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    1646:	8b 55 14             	mov    0x14(%ebp),%edx
    1649:	89 d0                	mov    %edx,%eax
    164b:	01 c0                	add    %eax,%eax
    164d:	01 d0                	add    %edx,%eax
    164f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    1652:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    1656:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    165a:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    165e:	83 ec 04             	sub    $0x4,%esp
    1661:	ff 75 14             	pushl  0x14(%ebp)
    1664:	ff 75 10             	pushl  0x10(%ebp)
    1667:	ff 75 f0             	pushl  -0x10(%ebp)
    166a:	e8 f8 fe ff ff       	call   1567 <write24BitmapFileHeader>
    166f:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    1672:	8b 45 10             	mov    0x10(%ebp),%eax
    1675:	83 e8 01             	sub    $0x1,%eax
    1678:	89 45 f4             	mov    %eax,-0xc(%ebp)
    167b:	eb 66                	jmp    16e3 <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    167d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1680:	0f af 45 14          	imul   0x14(%ebp),%eax
    1684:	89 c2                	mov    %eax,%edx
    1686:	89 d0                	mov    %edx,%eax
    1688:	01 c0                	add    %eax,%eax
    168a:	01 c2                	add    %eax,%edx
    168c:	8b 45 0c             	mov    0xc(%ebp),%eax
    168f:	01 d0                	add    %edx,%eax
    1691:	83 ec 04             	sub    $0x4,%esp
    1694:	ff 75 ec             	pushl  -0x14(%ebp)
    1697:	50                   	push   %eax
    1698:	ff 75 f0             	pushl  -0x10(%ebp)
    169b:	e8 ca f1 ff ff       	call   86a <write>
    16a0:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    16a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    16a6:	99                   	cltd   
    16a7:	c1 ea 1e             	shr    $0x1e,%edx
    16aa:	01 d0                	add    %edx,%eax
    16ac:	83 e0 03             	and    $0x3,%eax
    16af:	29 d0                	sub    %edx,%eax
    16b1:	85 c0                	test   %eax,%eax
    16b3:	7e 2a                	jle    16df <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    16b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    16b8:	99                   	cltd   
    16b9:	c1 ea 1e             	shr    $0x1e,%edx
    16bc:	01 d0                	add    %edx,%eax
    16be:	83 e0 03             	and    $0x3,%eax
    16c1:	29 d0                	sub    %edx,%eax
    16c3:	ba 04 00 00 00       	mov    $0x4,%edx
    16c8:	29 c2                	sub    %eax,%edx
    16ca:	89 d0                	mov    %edx,%eax
    16cc:	83 ec 04             	sub    $0x4,%esp
    16cf:	50                   	push   %eax
    16d0:	8d 45 e9             	lea    -0x17(%ebp),%eax
    16d3:	50                   	push   %eax
    16d4:	ff 75 f0             	pushl  -0x10(%ebp)
    16d7:	e8 8e f1 ff ff       	call   86a <write>
    16dc:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    16df:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    16e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    16e7:	79 94                	jns    167d <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    16e9:	83 ec 0c             	sub    $0xc,%esp
    16ec:	ff 75 f0             	pushl  -0x10(%ebp)
    16ef:	e8 7e f1 ff ff       	call   872 <close>
    16f4:	83 c4 10             	add    $0x10,%esp
    return 0;
    16f7:	b8 00 00 00 00       	mov    $0x0,%eax
    16fc:	c9                   	leave  
    16fd:	c3                   	ret    

000016fe <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    16fe:	55                   	push   %ebp
    16ff:	89 e5                	mov    %esp,%ebp
    1701:	57                   	push   %edi
    1702:	56                   	push   %esi
    1703:	53                   	push   %ebx
    1704:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    1707:	8b 45 08             	mov    0x8(%ebp),%eax
    170a:	8b 50 10             	mov    0x10(%eax),%edx
    170d:	8b 40 0c             	mov    0xc(%eax),%eax
    1710:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1713:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    1716:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1719:	8b 55 e0             	mov    -0x20(%ebp),%edx
    171c:	83 c2 1e             	add    $0x1e,%edx
    171f:	0f af d0             	imul   %eax,%edx
    1722:	89 d0                	mov    %edx,%eax
    1724:	01 c0                	add    %eax,%eax
    1726:	01 d0                	add    %edx,%eax
    1728:	83 ec 0c             	sub    $0xc,%esp
    172b:	50                   	push   %eax
    172c:	e8 93 f5 ff ff       	call   cc4 <malloc>
    1731:	83 c4 10             	add    $0x10,%esp
    1734:	89 c2                	mov    %eax,%edx
    1736:	8b 45 08             	mov    0x8(%ebp),%eax
    1739:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    173c:	8b 45 08             	mov    0x8(%ebp),%eax
    173f:	8b 40 1c             	mov    0x1c(%eax),%eax
    1742:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    1745:	6b d2 5a             	imul   $0x5a,%edx,%edx
    1748:	01 c2                	add    %eax,%edx
    174a:	8b 45 08             	mov    0x8(%ebp),%eax
    174d:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    1750:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    1753:	8b 45 e0             	mov    -0x20(%ebp),%eax
    1756:	0f af d0             	imul   %eax,%edx
    1759:	89 d0                	mov    %edx,%eax
    175b:	01 c0                	add    %eax,%eax
    175d:	01 d0                	add    %edx,%eax
    175f:	89 c2                	mov    %eax,%edx
    1761:	8b 45 08             	mov    0x8(%ebp),%eax
    1764:	8b 40 18             	mov    0x18(%eax),%eax
    1767:	83 ec 04             	sub    $0x4,%esp
    176a:	52                   	push   %edx
    176b:	68 ff 00 00 00       	push   $0xff
    1770:	50                   	push   %eax
    1771:	e8 39 ef ff ff       	call   6af <memset>
    1776:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    1779:	8b 45 08             	mov    0x8(%ebp),%eax
    177c:	8b 78 1c             	mov    0x1c(%eax),%edi
    177f:	8b 45 08             	mov    0x8(%ebp),%eax
    1782:	8b 70 14             	mov    0x14(%eax),%esi
    1785:	8b 45 08             	mov    0x8(%ebp),%eax
    1788:	8b 58 0c             	mov    0xc(%eax),%ebx
    178b:	8b 45 08             	mov    0x8(%ebp),%eax
    178e:	8b 48 10             	mov    0x10(%eax),%ecx
    1791:	8b 45 08             	mov    0x8(%ebp),%eax
    1794:	8b 50 08             	mov    0x8(%eax),%edx
    1797:	8b 45 08             	mov    0x8(%ebp),%eax
    179a:	8b 40 04             	mov    0x4(%eax),%eax
    179d:	83 ec 08             	sub    $0x8,%esp
    17a0:	57                   	push   %edi
    17a1:	56                   	push   %esi
    17a2:	53                   	push   %ebx
    17a3:	51                   	push   %ecx
    17a4:	52                   	push   %edx
    17a5:	50                   	push   %eax
    17a6:	e8 3f f1 ff ff       	call   8ea <createwindow>
    17ab:	83 c4 20             	add    $0x20,%esp
    17ae:	89 c2                	mov    %eax,%edx
    17b0:	8b 45 08             	mov    0x8(%ebp),%eax
    17b3:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    17b5:	8b 45 08             	mov    0x8(%ebp),%eax
    17b8:	8b 00                	mov    (%eax),%eax
}
    17ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
    17bd:	5b                   	pop    %ebx
    17be:	5e                   	pop    %esi
    17bf:	5f                   	pop    %edi
    17c0:	5d                   	pop    %ebp
    17c1:	c3                   	ret    

000017c2 <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    17c2:	55                   	push   %ebp
    17c3:	89 e5                	mov    %esp,%ebp
    17c5:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    17c8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    17cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    17d6:	8b 45 08             	mov    0x8(%ebp),%eax
    17d9:	8b 40 18             	mov    0x18(%eax),%eax
    17dc:	ff 75 1c             	pushl  0x1c(%ebp)
    17df:	ff 75 18             	pushl  0x18(%ebp)
    17e2:	ff 75 1c             	pushl  0x1c(%ebp)
    17e5:	ff 75 18             	pushl  0x18(%ebp)
    17e8:	8b 55 08             	mov    0x8(%ebp),%edx
    17eb:	ff 72 10             	pushl  0x10(%edx)
    17ee:	ff 72 0c             	pushl  0xc(%edx)
    17f1:	ff 75 f4             	pushl  -0xc(%ebp)
    17f4:	ff 75 f0             	pushl  -0x10(%ebp)
    17f7:	ff 75 14             	pushl  0x14(%ebp)
    17fa:	ff 75 10             	pushl  0x10(%ebp)
    17fd:	ff 75 0c             	pushl  0xc(%ebp)
    1800:	50                   	push   %eax
    1801:	e8 d5 07 00 00       	call   1fdb <drawBitmap>
    1806:	83 c4 30             	add    $0x30,%esp
    return 0;
    1809:	b8 00 00 00 00       	mov    $0x0,%eax
}
    180e:	c9                   	leave  
    180f:	c3                   	ret    

00001810 <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    1810:	55                   	push   %ebp
    1811:	89 e5                	mov    %esp,%ebp
    1813:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1816:	8b 45 08             	mov    0x8(%ebp),%eax
    1819:	8b 40 18             	mov    0x18(%eax),%eax
    181c:	ff 75 2c             	pushl  0x2c(%ebp)
    181f:	ff 75 28             	pushl  0x28(%ebp)
    1822:	ff 75 24             	pushl  0x24(%ebp)
    1825:	ff 75 20             	pushl  0x20(%ebp)
    1828:	8b 55 08             	mov    0x8(%ebp),%edx
    182b:	ff 72 10             	pushl  0x10(%edx)
    182e:	ff 72 0c             	pushl  0xc(%edx)
    1831:	ff 75 1c             	pushl  0x1c(%ebp)
    1834:	ff 75 18             	pushl  0x18(%ebp)
    1837:	ff 75 14             	pushl  0x14(%ebp)
    183a:	ff 75 10             	pushl  0x10(%ebp)
    183d:	ff 75 0c             	pushl  0xc(%ebp)
    1840:	50                   	push   %eax
    1841:	e8 95 07 00 00       	call   1fdb <drawBitmap>
    1846:	83 c4 30             	add    $0x30,%esp
    return 0;
    1849:	b8 00 00 00 00       	mov    $0x0,%eax
}
    184e:	c9                   	leave  
    184f:	c3                   	ret    

00001850 <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    1850:	55                   	push   %ebp
    1851:	89 e5                	mov    %esp,%ebp
    1853:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1856:	8b 45 08             	mov    0x8(%ebp),%eax
    1859:	8b 40 18             	mov    0x18(%eax),%eax
    185c:	ff 75 2c             	pushl  0x2c(%ebp)
    185f:	ff 75 28             	pushl  0x28(%ebp)
    1862:	ff 75 24             	pushl  0x24(%ebp)
    1865:	ff 75 20             	pushl  0x20(%ebp)
    1868:	8b 55 08             	mov    0x8(%ebp),%edx
    186b:	ff 72 10             	pushl  0x10(%edx)
    186e:	ff 72 0c             	pushl  0xc(%edx)
    1871:	ff 75 1c             	pushl  0x1c(%ebp)
    1874:	ff 75 18             	pushl  0x18(%ebp)
    1877:	ff 75 14             	pushl  0x14(%ebp)
    187a:	ff 75 10             	pushl  0x10(%ebp)
    187d:	ff 75 0c             	pushl  0xc(%ebp)
    1880:	50                   	push   %eax
    1881:	e8 75 08 00 00       	call   20fb <drawTransparentBitmap>
    1886:	83 c4 30             	add    $0x30,%esp
    return 0;
    1889:	b8 00 00 00 00       	mov    $0x0,%eax
}
    188e:	c9                   	leave  
    188f:	c3                   	ret    

00001890 <api_repaint>:

int api_repaint(Window* wnd)
{
    1890:	55                   	push   %ebp
    1891:	89 e5                	mov    %esp,%ebp
    1893:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    1896:	8b 45 08             	mov    0x8(%ebp),%eax
    1899:	8b 00                	mov    (%eax),%eax
    189b:	83 ec 0c             	sub    $0xc,%esp
    189e:	50                   	push   %eax
    189f:	e8 4e f0 ff ff       	call   8f2 <repaintwindow>
    18a4:	83 c4 10             	add    $0x10,%esp
    return 0;
    18a7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    18ac:	c9                   	leave  
    18ad:	c3                   	ret    

000018ae <api_update>:

int api_update(Window* wnd, Rect rect)
{
    18ae:	55                   	push   %ebp
    18af:	89 e5                	mov    %esp,%ebp
    18b1:	56                   	push   %esi
    18b2:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    18b3:	8b 75 18             	mov    0x18(%ebp),%esi
    18b6:	8b 5d 14             	mov    0x14(%ebp),%ebx
    18b9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    18bc:	8b 55 0c             	mov    0xc(%ebp),%edx
    18bf:	8b 45 08             	mov    0x8(%ebp),%eax
    18c2:	8b 00                	mov    (%eax),%eax
    18c4:	83 ec 0c             	sub    $0xc,%esp
    18c7:	56                   	push   %esi
    18c8:	53                   	push   %ebx
    18c9:	51                   	push   %ecx
    18ca:	52                   	push   %edx
    18cb:	50                   	push   %eax
    18cc:	e8 39 f0 ff ff       	call   90a <updatewindow>
    18d1:	83 c4 20             	add    $0x20,%esp
    return 0;
    18d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    18d9:	8d 65 f8             	lea    -0x8(%ebp),%esp
    18dc:	5b                   	pop    %ebx
    18dd:	5e                   	pop    %esi
    18de:	5d                   	pop    %ebp
    18df:	c3                   	ret    

000018e0 <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    18e0:	55                   	push   %ebp
    18e1:	89 e5                	mov    %esp,%ebp
    18e3:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    18e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    18ed:	8b 45 08             	mov    0x8(%ebp),%eax
    18f0:	8b 00                	mov    (%eax),%eax
    18f2:	83 ec 08             	sub    $0x8,%esp
    18f5:	8d 55 c8             	lea    -0x38(%ebp),%edx
    18f8:	52                   	push   %edx
    18f9:	50                   	push   %eax
    18fa:	e8 fb ef ff ff       	call   8fa <getmessage>
    18ff:	83 c4 10             	add    $0x10,%esp
    1902:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    1905:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1909:	74 e2                	je     18ed <api_exec+0xd>
        {
            pf(&msg);
    190b:	83 ec 0c             	sub    $0xc,%esp
    190e:	8d 45 c8             	lea    -0x38(%ebp),%eax
    1911:	50                   	push   %eax
    1912:	8b 45 0c             	mov    0xc(%ebp),%eax
    1915:	ff d0                	call   *%eax
    1917:	83 c4 10             	add    $0x10,%esp
        }
    }
    191a:	eb d1                	jmp    18ed <api_exec+0xd>

0000191c <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    191c:	55                   	push   %ebp
    191d:	89 e5                	mov    %esp,%ebp
    191f:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    1922:	8b 45 08             	mov    0x8(%ebp),%eax
    1925:	8b 00                	mov    (%eax),%eax
    1927:	83 ec 08             	sub    $0x8,%esp
    192a:	ff 75 0c             	pushl  0xc(%ebp)
    192d:	50                   	push   %eax
    192e:	e8 cf ef ff ff       	call   902 <settimer>
    1933:	83 c4 10             	add    $0x10,%esp
    return 0;
    1936:	b8 00 00 00 00       	mov    $0x0,%eax
}
    193b:	c9                   	leave  
    193c:	c3                   	ret    

0000193d <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    193d:	55                   	push   %ebp
    193e:	89 e5                	mov    %esp,%ebp
    1940:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    1943:	8b 45 08             	mov    0x8(%ebp),%eax
    1946:	8b 50 18             	mov    0x18(%eax),%edx
    1949:	ff 75 18             	pushl  0x18(%ebp)
    194c:	ff 75 14             	pushl  0x14(%ebp)
    194f:	83 ec 04             	sub    $0x4,%esp
    1952:	89 e0                	mov    %esp,%eax
    1954:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    1958:	66 89 08             	mov    %cx,(%eax)
    195b:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    195f:	88 48 02             	mov    %cl,0x2(%eax)
    1962:	8b 45 08             	mov    0x8(%ebp),%eax
    1965:	ff 70 10             	pushl  0x10(%eax)
    1968:	ff 70 0c             	pushl  0xc(%eax)
    196b:	ff 75 10             	pushl  0x10(%ebp)
    196e:	ff 75 0c             	pushl  0xc(%ebp)
    1971:	52                   	push   %edx
    1972:	e8 6f 04 00 00       	call   1de6 <drawRect>
    1977:	83 c4 20             	add    $0x20,%esp
    return 0;
    197a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    197f:	c9                   	leave  
    1980:	c3                   	ret    

00001981 <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    1981:	55                   	push   %ebp
    1982:	89 e5                	mov    %esp,%ebp
    1984:	83 ec 28             	sub    $0x28,%esp
    1987:	8b 45 14             	mov    0x14(%ebp),%eax
    198a:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    198d:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    1991:	8b 45 0c             	mov    0xc(%ebp),%eax
    1994:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1997:	8b 45 10             	mov    0x10(%ebp),%eax
    199a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    199d:	8b 45 08             	mov    0x8(%ebp),%eax
    19a0:	8b 40 18             	mov    0x18(%eax),%eax
    19a3:	83 ec 04             	sub    $0x4,%esp
    19a6:	ff 75 18             	pushl  0x18(%ebp)
    19a9:	52                   	push   %edx
    19aa:	8b 55 08             	mov    0x8(%ebp),%edx
    19ad:	ff 72 10             	pushl  0x10(%edx)
    19b0:	ff 72 0c             	pushl  0xc(%edx)
    19b3:	ff 75 f4             	pushl  -0xc(%ebp)
    19b6:	ff 75 f0             	pushl  -0x10(%ebp)
    19b9:	50                   	push   %eax
    19ba:	e8 d4 02 00 00       	call   1c93 <drawCharacter>
    19bf:	83 c4 20             	add    $0x20,%esp
    return 0;
    19c2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    19c7:	c9                   	leave  
    19c8:	c3                   	ret    

000019c9 <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    19c9:	55                   	push   %ebp
    19ca:	89 e5                	mov    %esp,%ebp
    19cc:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    19cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    19d2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    19d5:	8b 45 10             	mov    0x10(%ebp),%eax
    19d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    19db:	8b 45 08             	mov    0x8(%ebp),%eax
    19de:	8b 40 18             	mov    0x18(%eax),%eax
    19e1:	83 ec 04             	sub    $0x4,%esp
    19e4:	ff 75 18             	pushl  0x18(%ebp)
    19e7:	ff 75 14             	pushl  0x14(%ebp)
    19ea:	8b 55 08             	mov    0x8(%ebp),%edx
    19ed:	ff 72 10             	pushl  0x10(%edx)
    19f0:	ff 72 0c             	pushl  0xc(%edx)
    19f3:	ff 75 f4             	pushl  -0xc(%ebp)
    19f6:	ff 75 f0             	pushl  -0x10(%ebp)
    19f9:	50                   	push   %eax
    19fa:	e8 8e 03 00 00       	call   1d8d <drawString>
    19ff:	83 c4 20             	add    $0x20,%esp
    return 0;
    1a02:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1a07:	c9                   	leave  
    1a08:	c3                   	ret    

00001a09 <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    1a09:	55                   	push   %ebp
    1a0a:	89 e5                	mov    %esp,%ebp
    1a0c:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    1a0f:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    1a13:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    1a17:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    1a1b:	83 ec 08             	sub    $0x8,%esp
    1a1e:	83 ec 04             	sub    $0x4,%esp
    1a21:	89 e0                	mov    %esp,%eax
    1a23:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    1a27:	66 89 10             	mov    %dx,(%eax)
    1a2a:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    1a2e:	88 50 02             	mov    %dl,0x2(%eax)
    1a31:	ff 75 18             	pushl  0x18(%ebp)
    1a34:	ff 75 14             	pushl  0x14(%ebp)
    1a37:	ff 75 10             	pushl  0x10(%ebp)
    1a3a:	ff 75 0c             	pushl  0xc(%ebp)
    1a3d:	ff 75 08             	pushl  0x8(%ebp)
    1a40:	e8 f8 fe ff ff       	call   193d <api_drawRect>
    1a45:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    1a48:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    1a4c:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    1a50:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    1a54:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    1a58:	8b 45 10             	mov    0x10(%ebp),%eax
    1a5b:	8d 50 0a             	lea    0xa(%eax),%edx
    1a5e:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a61:	83 c0 0a             	add    $0xa,%eax
    1a64:	83 ec 0c             	sub    $0xc,%esp
    1a67:	ff 75 f4             	pushl  -0xc(%ebp)
    1a6a:	ff 75 1c             	pushl  0x1c(%ebp)
    1a6d:	52                   	push   %edx
    1a6e:	50                   	push   %eax
    1a6f:	ff 75 08             	pushl  0x8(%ebp)
    1a72:	e8 52 ff ff ff       	call   19c9 <api_drawString>
    1a77:	83 c4 20             	add    $0x20,%esp
    return 0;
    1a7a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1a7f:	c9                   	leave  
    1a80:	c3                   	ret    

00001a81 <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    1a81:	55                   	push   %ebp
    1a82:	89 e5                	mov    %esp,%ebp
    1a84:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    1a87:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1a8e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1a95:	8b 45 08             	mov    0x8(%ebp),%eax
    1a98:	8b 40 18             	mov    0x18(%eax),%eax
    1a9b:	ff 75 1c             	pushl  0x1c(%ebp)
    1a9e:	ff 75 18             	pushl  0x18(%ebp)
    1aa1:	ff 75 1c             	pushl  0x1c(%ebp)
    1aa4:	ff 75 18             	pushl  0x18(%ebp)
    1aa7:	8b 55 08             	mov    0x8(%ebp),%edx
    1aaa:	ff 72 10             	pushl  0x10(%edx)
    1aad:	ff 72 0c             	pushl  0xc(%edx)
    1ab0:	ff 75 f4             	pushl  -0xc(%ebp)
    1ab3:	ff 75 f0             	pushl  -0x10(%ebp)
    1ab6:	ff 75 14             	pushl  0x14(%ebp)
    1ab9:	ff 75 10             	pushl  0x10(%ebp)
    1abc:	ff 75 0c             	pushl  0xc(%ebp)
    1abf:	50                   	push   %eax
    1ac0:	e8 16 05 00 00       	call   1fdb <drawBitmap>
    1ac5:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    1ac8:	8b 45 08             	mov    0x8(%ebp),%eax
    1acb:	8b 40 18             	mov    0x18(%eax),%eax
    1ace:	ff 75 28             	pushl  0x28(%ebp)
    1ad1:	ff 75 1c             	pushl  0x1c(%ebp)
    1ad4:	ff 75 18             	pushl  0x18(%ebp)
    1ad7:	8b 55 08             	mov    0x8(%ebp),%edx
    1ada:	ff 72 10             	pushl  0x10(%edx)
    1add:	ff 72 0c             	pushl  0xc(%edx)
    1ae0:	ff 75 14             	pushl  0x14(%ebp)
    1ae3:	ff 75 10             	pushl  0x10(%ebp)
    1ae6:	50                   	push   %eax
    1ae7:	e8 99 07 00 00       	call   2285 <colorShift>
    1aec:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    1aef:	8b 45 08             	mov    0x8(%ebp),%eax
    1af2:	8b 50 18             	mov    0x18(%eax),%edx
    1af5:	83 ec 0c             	sub    $0xc,%esp
    1af8:	ff 75 20             	pushl  0x20(%ebp)
    1afb:	ff 75 1c             	pushl  0x1c(%ebp)
    1afe:	ff 75 18             	pushl  0x18(%ebp)
    1b01:	83 ec 04             	sub    $0x4,%esp
    1b04:	89 e0                	mov    %esp,%eax
    1b06:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    1b0a:	66 89 08             	mov    %cx,(%eax)
    1b0d:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    1b11:	88 48 02             	mov    %cl,0x2(%eax)
    1b14:	8b 45 08             	mov    0x8(%ebp),%eax
    1b17:	ff 70 10             	pushl  0x10(%eax)
    1b1a:	ff 70 0c             	pushl  0xc(%eax)
    1b1d:	ff 75 14             	pushl  0x14(%ebp)
    1b20:	ff 75 10             	pushl  0x10(%ebp)
    1b23:	52                   	push   %edx
    1b24:	e8 6d 03 00 00       	call   1e96 <drawBorder>
    1b29:	83 c4 30             	add    $0x30,%esp
    return 0;
    1b2c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1b31:	c9                   	leave  
    1b32:	c3                   	ret    

00001b33 <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    1b33:	55                   	push   %ebp
    1b34:	89 e5                	mov    %esp,%ebp
    1b36:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    1b39:	8b 45 08             	mov    0x8(%ebp),%eax
    1b3c:	8b 00                	mov    (%eax),%eax
    1b3e:	83 ec 0c             	sub    $0xc,%esp
    1b41:	50                   	push   %eax
    1b42:	e8 cb ed ff ff       	call   912 <destroywindow>
    1b47:	83 c4 10             	add    $0x10,%esp
    return 0;
    1b4a:	b8 00 00 00 00       	mov    $0x0,%eax
    1b4f:	c9                   	leave  
    1b50:	c3                   	ret    

00001b51 <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    1b51:	55                   	push   %ebp
    1b52:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    1b54:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    1b58:	8b 45 08             	mov    0x8(%ebp),%eax
    1b5b:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    1b5e:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    1b62:	8b 45 08             	mov    0x8(%ebp),%eax
    1b65:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    1b68:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    1b6c:	8b 45 08             	mov    0x8(%ebp),%eax
    1b6f:	88 10                	mov    %dl,(%eax)
}
    1b71:	90                   	nop
    1b72:	5d                   	pop    %ebp
    1b73:	c3                   	ret    

00001b74 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    1b74:	55                   	push   %ebp
    1b75:	89 e5                	mov    %esp,%ebp
    1b77:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    1b7a:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1b7e:	3c ff                	cmp    $0xff,%al
    1b80:	75 22                	jne    1ba4 <drawPointAlpha+0x30>
        color->R = origin.R;
    1b82:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    1b86:	8b 45 08             	mov    0x8(%ebp),%eax
    1b89:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    1b8c:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    1b90:	8b 45 08             	mov    0x8(%ebp),%eax
    1b93:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    1b96:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    1b9a:	8b 45 08             	mov    0x8(%ebp),%eax
    1b9d:	88 10                	mov    %dl,(%eax)
        return;
    1b9f:	e9 ed 00 00 00       	jmp    1c91 <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    1ba4:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1ba8:	84 c0                	test   %al,%al
    1baa:	0f 84 e0 00 00 00    	je     1c90 <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    1bb0:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1bb4:	0f b6 c0             	movzbl %al,%eax
    1bb7:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    1bbb:	df 45 e4             	fild   -0x1c(%ebp)
    1bbe:	d9 05 40 a2 01 00    	flds   0x1a240
    1bc4:	de f9                	fdivrp %st,%st(1)
    1bc6:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    1bc9:	8b 45 08             	mov    0x8(%ebp),%eax
    1bcc:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1bd0:	0f b6 c0             	movzbl %al,%eax
    1bd3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1bd6:	db 45 e4             	fildl  -0x1c(%ebp)
    1bd9:	d9 e8                	fld1   
    1bdb:	d8 65 fc             	fsubs  -0x4(%ebp)
    1bde:	de c9                	fmulp  %st,%st(1)
    1be0:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    1be4:	0f b6 c0             	movzbl %al,%eax
    1be7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1bea:	db 45 e4             	fildl  -0x1c(%ebp)
    1bed:	d8 4d fc             	fmuls  -0x4(%ebp)
    1bf0:	de c1                	faddp  %st,%st(1)
    1bf2:	d9 7d ee             	fnstcw -0x12(%ebp)
    1bf5:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    1bf9:	b4 0c                	mov    $0xc,%ah
    1bfb:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    1bff:	d9 6d ec             	fldcw  -0x14(%ebp)
    1c02:	df 5d ea             	fistp  -0x16(%ebp)
    1c05:	d9 6d ee             	fldcw  -0x12(%ebp)
    1c08:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1c0c:	89 c2                	mov    %eax,%edx
    1c0e:	8b 45 08             	mov    0x8(%ebp),%eax
    1c11:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    1c14:	8b 45 08             	mov    0x8(%ebp),%eax
    1c17:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1c1b:	0f b6 c0             	movzbl %al,%eax
    1c1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1c21:	db 45 e4             	fildl  -0x1c(%ebp)
    1c24:	d9 e8                	fld1   
    1c26:	d8 65 fc             	fsubs  -0x4(%ebp)
    1c29:	de c9                	fmulp  %st,%st(1)
    1c2b:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    1c2f:	0f b6 c0             	movzbl %al,%eax
    1c32:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1c35:	db 45 e4             	fildl  -0x1c(%ebp)
    1c38:	d8 4d fc             	fmuls  -0x4(%ebp)
    1c3b:	de c1                	faddp  %st,%st(1)
    1c3d:	d9 6d ec             	fldcw  -0x14(%ebp)
    1c40:	df 5d ea             	fistp  -0x16(%ebp)
    1c43:	d9 6d ee             	fldcw  -0x12(%ebp)
    1c46:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1c4a:	89 c2                	mov    %eax,%edx
    1c4c:	8b 45 08             	mov    0x8(%ebp),%eax
    1c4f:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    1c52:	8b 45 08             	mov    0x8(%ebp),%eax
    1c55:	0f b6 00             	movzbl (%eax),%eax
    1c58:	0f b6 c0             	movzbl %al,%eax
    1c5b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1c5e:	db 45 e4             	fildl  -0x1c(%ebp)
    1c61:	d9 e8                	fld1   
    1c63:	d8 65 fc             	fsubs  -0x4(%ebp)
    1c66:	de c9                	fmulp  %st,%st(1)
    1c68:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    1c6c:	0f b6 c0             	movzbl %al,%eax
    1c6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1c72:	db 45 e4             	fildl  -0x1c(%ebp)
    1c75:	d8 4d fc             	fmuls  -0x4(%ebp)
    1c78:	de c1                	faddp  %st,%st(1)
    1c7a:	d9 6d ec             	fldcw  -0x14(%ebp)
    1c7d:	df 5d ea             	fistp  -0x16(%ebp)
    1c80:	d9 6d ee             	fldcw  -0x12(%ebp)
    1c83:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1c87:	89 c2                	mov    %eax,%edx
    1c89:	8b 45 08             	mov    0x8(%ebp),%eax
    1c8c:	88 10                	mov    %dl,(%eax)
    1c8e:	eb 01                	jmp    1c91 <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    1c90:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    1c91:	c9                   	leave  
    1c92:	c3                   	ret    

00001c93 <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    1c93:	55                   	push   %ebp
    1c94:	89 e5                	mov    %esp,%ebp
    1c96:	83 ec 14             	sub    $0x14,%esp
    1c99:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1c9c:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    1c9f:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    1ca3:	83 e8 20             	sub    $0x20,%eax
    1ca6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    1ca9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1cad:	0f 88 d7 00 00 00    	js     1d8a <drawCharacter+0xf7>
    1cb3:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    1cb7:	0f 8f cd 00 00 00    	jg     1d8a <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1cbd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1cc4:	e9 b5 00 00 00       	jmp    1d7e <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    1cc9:	8b 55 10             	mov    0x10(%ebp),%edx
    1ccc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1ccf:	01 c2                	add    %eax,%edx
    1cd1:	8b 45 14             	mov    0x14(%ebp),%eax
    1cd4:	39 c2                	cmp    %eax,%edx
    1cd6:	0f 8f af 00 00 00    	jg     1d8b <drawCharacter+0xf8>
    1cdc:	8b 55 10             	mov    0x10(%ebp),%edx
    1cdf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1ce2:	01 d0                	add    %edx,%eax
    1ce4:	85 c0                	test   %eax,%eax
    1ce6:	0f 88 9f 00 00 00    	js     1d8b <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1cec:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1cf3:	eb 7b                	jmp    1d70 <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    1cf5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1cf8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    1cfb:	89 d0                	mov    %edx,%eax
    1cfd:	c1 e0 03             	shl    $0x3,%eax
    1d00:	01 d0                	add    %edx,%eax
    1d02:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    1d08:	01 c2                	add    %eax,%edx
    1d0a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1d0d:	01 d0                	add    %edx,%eax
    1d0f:	05 20 66 01 00       	add    $0x16620,%eax
    1d14:	0f b6 00             	movzbl (%eax),%eax
    1d17:	3c 01                	cmp    $0x1,%al
    1d19:	75 51                	jne    1d6c <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    1d1b:	8b 55 0c             	mov    0xc(%ebp),%edx
    1d1e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1d21:	01 c2                	add    %eax,%edx
    1d23:	8b 45 18             	mov    0x18(%ebp),%eax
    1d26:	39 c2                	cmp    %eax,%edx
    1d28:	7f 50                	jg     1d7a <drawCharacter+0xe7>
    1d2a:	8b 55 0c             	mov    0xc(%ebp),%edx
    1d2d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1d30:	01 d0                	add    %edx,%eax
    1d32:	85 c0                	test   %eax,%eax
    1d34:	78 44                	js     1d7a <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    1d36:	8b 55 10             	mov    0x10(%ebp),%edx
    1d39:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1d3c:	01 c2                	add    %eax,%edx
    1d3e:	8b 45 18             	mov    0x18(%ebp),%eax
    1d41:	0f af c2             	imul   %edx,%eax
    1d44:	89 c2                	mov    %eax,%edx
    1d46:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d49:	01 c2                	add    %eax,%edx
    1d4b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1d4e:	01 c2                	add    %eax,%edx
    1d50:	89 d0                	mov    %edx,%eax
    1d52:	01 c0                	add    %eax,%eax
    1d54:	01 c2                	add    %eax,%edx
    1d56:	8b 45 08             	mov    0x8(%ebp),%eax
    1d59:	01 d0                	add    %edx,%eax
    1d5b:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    1d5e:	ff 75 20             	pushl  0x20(%ebp)
    1d61:	ff 75 f0             	pushl  -0x10(%ebp)
    1d64:	e8 0b fe ff ff       	call   1b74 <drawPointAlpha>
    1d69:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1d6c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    1d70:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    1d74:	0f 8e 7b ff ff ff    	jle    1cf5 <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1d7a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    1d7e:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    1d82:	0f 8e 41 ff ff ff    	jle    1cc9 <drawCharacter+0x36>
    1d88:	eb 01                	jmp    1d8b <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    1d8a:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    1d8b:	c9                   	leave  
    1d8c:	c3                   	ret    

00001d8d <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    1d8d:	55                   	push   %ebp
    1d8e:	89 e5                	mov    %esp,%ebp
    1d90:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    1d93:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    1d9a:	eb 3d                	jmp    1dd9 <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    1d9c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1d9f:	0f b6 00             	movzbl (%eax),%eax
    1da2:	0f be c0             	movsbl %al,%eax
    1da5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1da8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1dab:	01 ca                	add    %ecx,%edx
    1dad:	89 55 f4             	mov    %edx,-0xc(%ebp)
    1db0:	8b 55 10             	mov    0x10(%ebp),%edx
    1db3:	89 55 f8             	mov    %edx,-0x8(%ebp)
    1db6:	ff 75 20             	pushl  0x20(%ebp)
    1db9:	50                   	push   %eax
    1dba:	ff 75 18             	pushl  0x18(%ebp)
    1dbd:	ff 75 14             	pushl  0x14(%ebp)
    1dc0:	ff 75 f8             	pushl  -0x8(%ebp)
    1dc3:	ff 75 f4             	pushl  -0xc(%ebp)
    1dc6:	ff 75 08             	pushl  0x8(%ebp)
    1dc9:	e8 c5 fe ff ff       	call   1c93 <drawCharacter>
    1dce:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    1dd1:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    1dd5:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    1dd9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1ddc:	0f b6 00             	movzbl (%eax),%eax
    1ddf:	84 c0                	test   %al,%al
    1de1:	75 b9                	jne    1d9c <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    1de3:	90                   	nop
    1de4:	c9                   	leave  
    1de5:	c3                   	ret    

00001de6 <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    1de6:	55                   	push   %ebp
    1de7:	89 e5                	mov    %esp,%ebp
    1de9:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1dec:	8b 45 20             	mov    0x20(%ebp),%eax
    1def:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1df2:	8b 45 24             	mov    0x24(%ebp),%eax
    1df5:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1df8:	8b 55 14             	mov    0x14(%ebp),%edx
    1dfb:	8b 45 10             	mov    0x10(%ebp),%eax
    1dfe:	29 c2                	sub    %eax,%edx
    1e00:	89 d0                	mov    %edx,%eax
    1e02:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1e05:	7d 0d                	jge    1e14 <drawRect+0x2e>
        draw_h = s.h - p.y;
    1e07:	8b 55 14             	mov    0x14(%ebp),%edx
    1e0a:	8b 45 10             	mov    0x10(%ebp),%eax
    1e0d:	29 c2                	sub    %eax,%edx
    1e0f:	89 d0                	mov    %edx,%eax
    1e11:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1e14:	8b 55 18             	mov    0x18(%ebp),%edx
    1e17:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e1a:	29 c2                	sub    %eax,%edx
    1e1c:	89 d0                	mov    %edx,%eax
    1e1e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1e21:	7d 0d                	jge    1e30 <drawRect+0x4a>
        draw_w = s.w - p.x;
    1e23:	8b 55 18             	mov    0x18(%ebp),%edx
    1e26:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e29:	29 c2                	sub    %eax,%edx
    1e2b:	89 d0                	mov    %edx,%eax
    1e2d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1e30:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1e37:	eb 52                	jmp    1e8b <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    1e39:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1e40:	eb 3d                	jmp    1e7f <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    1e42:	8b 55 10             	mov    0x10(%ebp),%edx
    1e45:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e48:	01 c2                	add    %eax,%edx
    1e4a:	8b 45 18             	mov    0x18(%ebp),%eax
    1e4d:	0f af c2             	imul   %edx,%eax
    1e50:	89 c2                	mov    %eax,%edx
    1e52:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e55:	01 c2                	add    %eax,%edx
    1e57:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e5a:	01 c2                	add    %eax,%edx
    1e5c:	89 d0                	mov    %edx,%eax
    1e5e:	01 c0                	add    %eax,%eax
    1e60:	01 c2                	add    %eax,%edx
    1e62:	8b 45 08             	mov    0x8(%ebp),%eax
    1e65:	01 d0                	add    %edx,%eax
    1e67:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    1e6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e6d:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1e71:	66 89 10             	mov    %dx,(%eax)
    1e74:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1e78:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1e7b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1e7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e82:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1e85:	7c bb                	jl     1e42 <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1e87:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1e8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e8e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1e91:	7c a6                	jl     1e39 <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    1e93:	90                   	nop
    1e94:	c9                   	leave  
    1e95:	c3                   	ret    

00001e96 <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    1e96:	55                   	push   %ebp
    1e97:	89 e5                	mov    %esp,%ebp
    1e99:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    1e9c:	8b 45 28             	mov    0x28(%ebp),%eax
    1e9f:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1ea2:	8b 45 24             	mov    0x24(%ebp),%eax
    1ea5:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1ea8:	ff 75 cc             	pushl  -0x34(%ebp)
    1eab:	ff 75 c8             	pushl  -0x38(%ebp)
    1eae:	83 ec 04             	sub    $0x4,%esp
    1eb1:	89 e0                	mov    %esp,%eax
    1eb3:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1eb7:	66 89 10             	mov    %dx,(%eax)
    1eba:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1ebe:	88 50 02             	mov    %dl,0x2(%eax)
    1ec1:	ff 75 18             	pushl  0x18(%ebp)
    1ec4:	ff 75 14             	pushl  0x14(%ebp)
    1ec7:	ff 75 10             	pushl  0x10(%ebp)
    1eca:	ff 75 0c             	pushl  0xc(%ebp)
    1ecd:	ff 75 08             	pushl  0x8(%ebp)
    1ed0:	e8 11 ff ff ff       	call   1de6 <drawRect>
    1ed5:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    1ed8:	8b 45 28             	mov    0x28(%ebp),%eax
    1edb:	89 45 d0             	mov    %eax,-0x30(%ebp)
    1ede:	8b 45 24             	mov    0x24(%ebp),%eax
    1ee1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1ee4:	8b 45 0c             	mov    0xc(%ebp),%eax
    1ee7:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1eea:	8b 55 10             	mov    0x10(%ebp),%edx
    1eed:	8b 45 20             	mov    0x20(%ebp),%eax
    1ef0:	01 d0                	add    %edx,%eax
    1ef2:	2b 45 28             	sub    0x28(%ebp),%eax
    1ef5:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1ef8:	ff 75 d4             	pushl  -0x2c(%ebp)
    1efb:	ff 75 d0             	pushl  -0x30(%ebp)
    1efe:	83 ec 04             	sub    $0x4,%esp
    1f01:	89 e0                	mov    %esp,%eax
    1f03:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1f07:	66 89 10             	mov    %dx,(%eax)
    1f0a:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1f0e:	88 50 02             	mov    %dl,0x2(%eax)
    1f11:	ff 75 18             	pushl  0x18(%ebp)
    1f14:	ff 75 14             	pushl  0x14(%ebp)
    1f17:	ff 75 dc             	pushl  -0x24(%ebp)
    1f1a:	ff 75 d8             	pushl  -0x28(%ebp)
    1f1d:	ff 75 08             	pushl  0x8(%ebp)
    1f20:	e8 c1 fe ff ff       	call   1de6 <drawRect>
    1f25:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1f28:	8b 45 20             	mov    0x20(%ebp),%eax
    1f2b:	8b 55 28             	mov    0x28(%ebp),%edx
    1f2e:	01 d2                	add    %edx,%edx
    1f30:	29 d0                	sub    %edx,%eax
    1f32:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1f35:	8b 45 28             	mov    0x28(%ebp),%eax
    1f38:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1f3b:	8b 45 0c             	mov    0xc(%ebp),%eax
    1f3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1f41:	8b 55 10             	mov    0x10(%ebp),%edx
    1f44:	8b 45 28             	mov    0x28(%ebp),%eax
    1f47:	01 d0                	add    %edx,%eax
    1f49:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1f4c:	ff 75 e4             	pushl  -0x1c(%ebp)
    1f4f:	ff 75 e0             	pushl  -0x20(%ebp)
    1f52:	83 ec 04             	sub    $0x4,%esp
    1f55:	89 e0                	mov    %esp,%eax
    1f57:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1f5b:	66 89 10             	mov    %dx,(%eax)
    1f5e:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1f62:	88 50 02             	mov    %dl,0x2(%eax)
    1f65:	ff 75 18             	pushl  0x18(%ebp)
    1f68:	ff 75 14             	pushl  0x14(%ebp)
    1f6b:	ff 75 ec             	pushl  -0x14(%ebp)
    1f6e:	ff 75 e8             	pushl  -0x18(%ebp)
    1f71:	ff 75 08             	pushl  0x8(%ebp)
    1f74:	e8 6d fe ff ff       	call   1de6 <drawRect>
    1f79:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1f7c:	8b 45 20             	mov    0x20(%ebp),%eax
    1f7f:	8b 55 28             	mov    0x28(%ebp),%edx
    1f82:	01 d2                	add    %edx,%edx
    1f84:	29 d0                	sub    %edx,%eax
    1f86:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1f89:	8b 45 28             	mov    0x28(%ebp),%eax
    1f8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1f8f:	8b 55 0c             	mov    0xc(%ebp),%edx
    1f92:	8b 45 24             	mov    0x24(%ebp),%eax
    1f95:	01 d0                	add    %edx,%eax
    1f97:	2b 45 28             	sub    0x28(%ebp),%eax
    1f9a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    1f9d:	8b 55 10             	mov    0x10(%ebp),%edx
    1fa0:	8b 45 28             	mov    0x28(%ebp),%eax
    1fa3:	01 d0                	add    %edx,%eax
    1fa5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1fa8:	ff 75 f4             	pushl  -0xc(%ebp)
    1fab:	ff 75 f0             	pushl  -0x10(%ebp)
    1fae:	83 ec 04             	sub    $0x4,%esp
    1fb1:	89 e0                	mov    %esp,%eax
    1fb3:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1fb7:	66 89 10             	mov    %dx,(%eax)
    1fba:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1fbe:	88 50 02             	mov    %dl,0x2(%eax)
    1fc1:	ff 75 18             	pushl  0x18(%ebp)
    1fc4:	ff 75 14             	pushl  0x14(%ebp)
    1fc7:	ff 75 fc             	pushl  -0x4(%ebp)
    1fca:	ff 75 f8             	pushl  -0x8(%ebp)
    1fcd:	ff 75 08             	pushl  0x8(%ebp)
    1fd0:	e8 11 fe ff ff       	call   1de6 <drawRect>
    1fd5:	83 c4 20             	add    $0x20,%esp
}
    1fd8:	90                   	nop
    1fd9:	c9                   	leave  
    1fda:	c3                   	ret    

00001fdb <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1fdb:	55                   	push   %ebp
    1fdc:	89 e5                	mov    %esp,%ebp
    1fde:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1fe1:	8b 45 30             	mov    0x30(%ebp),%eax
    1fe4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    1fe7:	8b 45 34             	mov    0x34(%ebp),%eax
    1fea:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    1fed:	8b 55 20             	mov    0x20(%ebp),%edx
    1ff0:	8b 45 14             	mov    0x14(%ebp),%eax
    1ff3:	29 c2                	sub    %eax,%edx
    1ff5:	89 d0                	mov    %edx,%eax
    1ff7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1ffa:	7d 0d                	jge    2009 <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    1ffc:	8b 55 20             	mov    0x20(%ebp),%edx
    1fff:	8b 45 14             	mov    0x14(%ebp),%eax
    2002:	29 c2                	sub    %eax,%edx
    2004:	89 d0                	mov    %edx,%eax
    2006:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    2009:	8b 55 28             	mov    0x28(%ebp),%edx
    200c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    200f:	29 c2                	sub    %eax,%edx
    2011:	89 d0                	mov    %edx,%eax
    2013:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2016:	7d 0d                	jge    2025 <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    2018:	8b 55 28             	mov    0x28(%ebp),%edx
    201b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    201e:	29 c2                	sub    %eax,%edx
    2020:	89 d0                	mov    %edx,%eax
    2022:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    2025:	8b 55 24             	mov    0x24(%ebp),%edx
    2028:	8b 45 10             	mov    0x10(%ebp),%eax
    202b:	29 c2                	sub    %eax,%edx
    202d:	89 d0                	mov    %edx,%eax
    202f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2032:	7d 0d                	jge    2041 <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    2034:	8b 55 24             	mov    0x24(%ebp),%edx
    2037:	8b 45 10             	mov    0x10(%ebp),%eax
    203a:	29 c2                	sub    %eax,%edx
    203c:	89 d0                	mov    %edx,%eax
    203e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    2041:	8b 55 2c             	mov    0x2c(%ebp),%edx
    2044:	8b 45 18             	mov    0x18(%ebp),%eax
    2047:	29 c2                	sub    %eax,%edx
    2049:	89 d0                	mov    %edx,%eax
    204b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    204e:	7d 0d                	jge    205d <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    2050:	8b 55 2c             	mov    0x2c(%ebp),%edx
    2053:	8b 45 18             	mov    0x18(%ebp),%eax
    2056:	29 c2                	sub    %eax,%edx
    2058:	89 d0                	mov    %edx,%eax
    205a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    205d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    2064:	e9 83 00 00 00       	jmp    20ec <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    2069:	8b 55 14             	mov    0x14(%ebp),%edx
    206c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    206f:	01 d0                	add    %edx,%eax
    2071:	85 c0                	test   %eax,%eax
    2073:	78 72                	js     20e7 <drawBitmap+0x10c>
    2075:	8b 55 14             	mov    0x14(%ebp),%edx
    2078:	8b 45 ec             	mov    -0x14(%ebp),%eax
    207b:	01 c2                	add    %eax,%edx
    207d:	8b 45 20             	mov    0x20(%ebp),%eax
    2080:	39 c2                	cmp    %eax,%edx
    2082:	7d 63                	jge    20e7 <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    2084:	8b 55 14             	mov    0x14(%ebp),%edx
    2087:	8b 45 ec             	mov    -0x14(%ebp),%eax
    208a:	01 c2                	add    %eax,%edx
    208c:	8b 45 24             	mov    0x24(%ebp),%eax
    208f:	0f af c2             	imul   %edx,%eax
    2092:	89 c2                	mov    %eax,%edx
    2094:	8b 45 10             	mov    0x10(%ebp),%eax
    2097:	01 c2                	add    %eax,%edx
    2099:	89 d0                	mov    %edx,%eax
    209b:	01 c0                	add    %eax,%eax
    209d:	01 c2                	add    %eax,%edx
    209f:	8b 45 08             	mov    0x8(%ebp),%eax
    20a2:	01 d0                	add    %edx,%eax
    20a4:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    20a7:	8b 55 1c             	mov    0x1c(%ebp),%edx
    20aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    20ad:	01 c2                	add    %eax,%edx
    20af:	8b 45 2c             	mov    0x2c(%ebp),%eax
    20b2:	0f af c2             	imul   %edx,%eax
    20b5:	89 c2                	mov    %eax,%edx
    20b7:	8b 45 18             	mov    0x18(%ebp),%eax
    20ba:	01 c2                	add    %eax,%edx
    20bc:	89 d0                	mov    %edx,%eax
    20be:	01 c0                	add    %eax,%eax
    20c0:	01 c2                	add    %eax,%edx
    20c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    20c5:	01 d0                	add    %edx,%eax
    20c7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    20ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
    20cd:	89 d0                	mov    %edx,%eax
    20cf:	01 c0                	add    %eax,%eax
    20d1:	01 d0                	add    %edx,%eax
    20d3:	83 ec 04             	sub    $0x4,%esp
    20d6:	50                   	push   %eax
    20d7:	ff 75 e4             	pushl  -0x1c(%ebp)
    20da:	ff 75 e8             	pushl  -0x18(%ebp)
    20dd:	e8 23 e7 ff ff       	call   805 <memmove>
    20e2:	83 c4 10             	add    $0x10,%esp
    20e5:	eb 01                	jmp    20e8 <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    20e7:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    20e8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    20ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
    20ef:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    20f2:	0f 8c 71 ff ff ff    	jl     2069 <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    20f8:	90                   	nop
    20f9:	c9                   	leave  
    20fa:	c3                   	ret    

000020fb <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    20fb:	55                   	push   %ebp
    20fc:	89 e5                	mov    %esp,%ebp
    20fe:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    2101:	8b 45 30             	mov    0x30(%ebp),%eax
    2104:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    2107:	8b 45 34             	mov    0x34(%ebp),%eax
    210a:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    210d:	8b 55 20             	mov    0x20(%ebp),%edx
    2110:	8b 45 14             	mov    0x14(%ebp),%eax
    2113:	29 c2                	sub    %eax,%edx
    2115:	89 d0                	mov    %edx,%eax
    2117:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    211a:	7d 0d                	jge    2129 <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    211c:	8b 55 20             	mov    0x20(%ebp),%edx
    211f:	8b 45 14             	mov    0x14(%ebp),%eax
    2122:	29 c2                	sub    %eax,%edx
    2124:	89 d0                	mov    %edx,%eax
    2126:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    2129:	8b 55 28             	mov    0x28(%ebp),%edx
    212c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    212f:	29 c2                	sub    %eax,%edx
    2131:	89 d0                	mov    %edx,%eax
    2133:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2136:	7d 0d                	jge    2145 <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    2138:	8b 55 28             	mov    0x28(%ebp),%edx
    213b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    213e:	29 c2                	sub    %eax,%edx
    2140:	89 d0                	mov    %edx,%eax
    2142:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    2145:	8b 55 24             	mov    0x24(%ebp),%edx
    2148:	8b 45 10             	mov    0x10(%ebp),%eax
    214b:	29 c2                	sub    %eax,%edx
    214d:	89 d0                	mov    %edx,%eax
    214f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2152:	7d 0d                	jge    2161 <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    2154:	8b 55 24             	mov    0x24(%ebp),%edx
    2157:	8b 45 10             	mov    0x10(%ebp),%eax
    215a:	29 c2                	sub    %eax,%edx
    215c:	89 d0                	mov    %edx,%eax
    215e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    2161:	8b 55 2c             	mov    0x2c(%ebp),%edx
    2164:	8b 45 18             	mov    0x18(%ebp),%eax
    2167:	29 c2                	sub    %eax,%edx
    2169:	89 d0                	mov    %edx,%eax
    216b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    216e:	7d 0d                	jge    217d <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    2170:	8b 55 2c             	mov    0x2c(%ebp),%edx
    2173:	8b 45 18             	mov    0x18(%ebp),%eax
    2176:	29 c2                	sub    %eax,%edx
    2178:	89 d0                	mov    %edx,%eax
    217a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    217d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2184:	e9 b8 00 00 00       	jmp    2241 <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    2189:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2190:	e9 9c 00 00 00       	jmp    2231 <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    2195:	8b 55 14             	mov    0x14(%ebp),%edx
    2198:	8b 45 f4             	mov    -0xc(%ebp),%eax
    219b:	01 c2                	add    %eax,%edx
    219d:	8b 45 24             	mov    0x24(%ebp),%eax
    21a0:	0f af c2             	imul   %edx,%eax
    21a3:	89 c2                	mov    %eax,%edx
    21a5:	8b 45 10             	mov    0x10(%ebp),%eax
    21a8:	01 c2                	add    %eax,%edx
    21aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
    21ad:	01 c2                	add    %eax,%edx
    21af:	89 d0                	mov    %edx,%eax
    21b1:	01 c0                	add    %eax,%eax
    21b3:	01 c2                	add    %eax,%edx
    21b5:	8b 45 08             	mov    0x8(%ebp),%eax
    21b8:	01 d0                	add    %edx,%eax
    21ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    21bd:	8b 55 1c             	mov    0x1c(%ebp),%edx
    21c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    21c3:	01 c2                	add    %eax,%edx
    21c5:	8b 45 2c             	mov    0x2c(%ebp),%eax
    21c8:	0f af c2             	imul   %edx,%eax
    21cb:	89 c2                	mov    %eax,%edx
    21cd:	8b 45 18             	mov    0x18(%ebp),%eax
    21d0:	01 c2                	add    %eax,%edx
    21d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    21d5:	01 c2                	add    %eax,%edx
    21d7:	89 d0                	mov    %edx,%eax
    21d9:	01 c0                	add    %eax,%eax
    21db:	01 c2                	add    %eax,%edx
    21dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    21e0:	01 d0                	add    %edx,%eax
    21e2:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    21e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    21e8:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    21ec:	3c ff                	cmp    $0xff,%al
    21ee:	75 15                	jne    2205 <drawTransparentBitmap+0x10a>
    21f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    21f3:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    21f7:	3c ff                	cmp    $0xff,%al
    21f9:	75 0a                	jne    2205 <drawTransparentBitmap+0x10a>
    21fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    21fe:	0f b6 00             	movzbl (%eax),%eax
    2201:	3c ff                	cmp    $0xff,%al
    2203:	74 27                	je     222c <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    2205:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2208:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    220c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    220f:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    2212:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2215:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    2219:	8b 45 ec             	mov    -0x14(%ebp),%eax
    221c:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    221f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2222:	0f b6 10             	movzbl (%eax),%edx
    2225:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2228:	88 10                	mov    %dl,(%eax)
    222a:	eb 01                	jmp    222d <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    222c:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    222d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2231:	8b 45 34             	mov    0x34(%ebp),%eax
    2234:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2237:	0f 8f 58 ff ff ff    	jg     2195 <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    223d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2241:	8b 45 30             	mov    0x30(%ebp),%eax
    2244:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2247:	0f 8f 3c ff ff ff    	jg     2189 <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    224d:	90                   	nop
    224e:	c9                   	leave  
    224f:	c3                   	ret    

00002250 <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    2250:	55                   	push   %ebp
    2251:	89 e5                	mov    %esp,%ebp
    2253:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    2256:	ff 75 24             	pushl  0x24(%ebp)
    2259:	ff 75 20             	pushl  0x20(%ebp)
    225c:	ff 75 1c             	pushl  0x1c(%ebp)
    225f:	ff 75 18             	pushl  0x18(%ebp)
    2262:	ff 75 1c             	pushl  0x1c(%ebp)
    2265:	ff 75 18             	pushl  0x18(%ebp)
    2268:	ff 75 14             	pushl  0x14(%ebp)
    226b:	ff 75 10             	pushl  0x10(%ebp)
    226e:	ff 75 14             	pushl  0x14(%ebp)
    2271:	ff 75 10             	pushl  0x10(%ebp)
    2274:	ff 75 0c             	pushl  0xc(%ebp)
    2277:	ff 75 08             	pushl  0x8(%ebp)
    227a:	e8 5c fd ff ff       	call   1fdb <drawBitmap>
    227f:	83 c4 30             	add    $0x30,%esp
}
    2282:	90                   	nop
    2283:	c9                   	leave  
    2284:	c3                   	ret    

00002285 <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    2285:	55                   	push   %ebp
    2286:	89 e5                	mov    %esp,%ebp
    2288:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    228b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    228e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    2291:	8b 45 20             	mov    0x20(%ebp),%eax
    2294:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    2297:	8b 55 14             	mov    0x14(%ebp),%edx
    229a:	8b 45 10             	mov    0x10(%ebp),%eax
    229d:	29 c2                	sub    %eax,%edx
    229f:	89 d0                	mov    %edx,%eax
    22a1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    22a4:	7d 0d                	jge    22b3 <colorShift+0x2e>
        draw_h = s.h - p.y;
    22a6:	8b 55 14             	mov    0x14(%ebp),%edx
    22a9:	8b 45 10             	mov    0x10(%ebp),%eax
    22ac:	29 c2                	sub    %eax,%edx
    22ae:	89 d0                	mov    %edx,%eax
    22b0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    22b3:	8b 55 18             	mov    0x18(%ebp),%edx
    22b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    22b9:	29 c2                	sub    %eax,%edx
    22bb:	89 d0                	mov    %edx,%eax
    22bd:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    22c0:	7d 0d                	jge    22cf <colorShift+0x4a>
        draw_w = s.w - p.x;
    22c2:	8b 55 18             	mov    0x18(%ebp),%edx
    22c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    22c8:	29 c2                	sub    %eax,%edx
    22ca:	89 d0                	mov    %edx,%eax
    22cc:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    22cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    22d6:	e9 fc 00 00 00       	jmp    23d7 <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    22db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    22e2:	e9 e0 00 00 00       	jmp    23c7 <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    22e7:	8b 55 10             	mov    0x10(%ebp),%edx
    22ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    22ed:	01 c2                	add    %eax,%edx
    22ef:	8b 45 18             	mov    0x18(%ebp),%eax
    22f2:	0f af c2             	imul   %edx,%eax
    22f5:	89 c2                	mov    %eax,%edx
    22f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    22fa:	01 c2                	add    %eax,%edx
    22fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    22ff:	01 c2                	add    %eax,%edx
    2301:	89 d0                	mov    %edx,%eax
    2303:	01 c0                	add    %eax,%eax
    2305:	01 c2                	add    %eax,%edx
    2307:	8b 45 08             	mov    0x8(%ebp),%eax
    230a:	01 d0                	add    %edx,%eax
    230c:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    230f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2312:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2316:	3c c8                	cmp    $0xc8,%al
    2318:	0f 86 a5 00 00 00    	jbe    23c3 <colorShift+0x13e>
    231e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2321:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2325:	3c c8                	cmp    $0xc8,%al
    2327:	0f 86 96 00 00 00    	jbe    23c3 <colorShift+0x13e>
    232d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2330:	0f b6 00             	movzbl (%eax),%eax
    2333:	3c c8                	cmp    $0xc8,%al
    2335:	0f 86 88 00 00 00    	jbe    23c3 <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    233b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    233e:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2342:	0f b6 d0             	movzbl %al,%edx
    2345:	8b 45 24             	mov    0x24(%ebp),%eax
    2348:	01 d0                	add    %edx,%eax
    234a:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    2350:	89 d0                	mov    %edx,%eax
    2352:	c1 f8 1f             	sar    $0x1f,%eax
    2355:	c1 e8 18             	shr    $0x18,%eax
    2358:	01 c2                	add    %eax,%edx
    235a:	0f b6 d2             	movzbl %dl,%edx
    235d:	29 c2                	sub    %eax,%edx
    235f:	89 d0                	mov    %edx,%eax
    2361:	89 c2                	mov    %eax,%edx
    2363:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2366:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    2369:	8b 45 ec             	mov    -0x14(%ebp),%eax
    236c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2370:	0f b6 d0             	movzbl %al,%edx
    2373:	8b 45 24             	mov    0x24(%ebp),%eax
    2376:	01 d0                	add    %edx,%eax
    2378:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    237e:	89 d0                	mov    %edx,%eax
    2380:	c1 f8 1f             	sar    $0x1f,%eax
    2383:	c1 e8 18             	shr    $0x18,%eax
    2386:	01 c2                	add    %eax,%edx
    2388:	0f b6 d2             	movzbl %dl,%edx
    238b:	29 c2                	sub    %eax,%edx
    238d:	89 d0                	mov    %edx,%eax
    238f:	89 c2                	mov    %eax,%edx
    2391:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2394:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    2397:	8b 45 ec             	mov    -0x14(%ebp),%eax
    239a:	0f b6 00             	movzbl (%eax),%eax
    239d:	0f b6 d0             	movzbl %al,%edx
    23a0:	8b 45 24             	mov    0x24(%ebp),%eax
    23a3:	01 d0                	add    %edx,%eax
    23a5:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    23ab:	89 d0                	mov    %edx,%eax
    23ad:	c1 f8 1f             	sar    $0x1f,%eax
    23b0:	c1 e8 18             	shr    $0x18,%eax
    23b3:	01 c2                	add    %eax,%edx
    23b5:	0f b6 d2             	movzbl %dl,%edx
    23b8:	29 c2                	sub    %eax,%edx
    23ba:	89 d0                	mov    %edx,%eax
    23bc:	89 c2                	mov    %eax,%edx
    23be:	8b 45 ec             	mov    -0x14(%ebp),%eax
    23c1:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    23c3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    23c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    23ca:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    23cd:	0f 8c 14 ff ff ff    	jl     22e7 <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    23d3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    23d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    23da:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    23dd:	0f 8c f8 fe ff ff    	jl     22db <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    23e3:	90                   	nop
    23e4:	c9                   	leave  
    23e5:	c3                   	ret    

000023e6 <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    23e6:	55                   	push   %ebp
    23e7:	89 e5                	mov    %esp,%ebp
    23e9:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    23ec:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    23f3:	e9 fb 00 00 00       	jmp    24f3 <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    23f8:	8b 55 14             	mov    0x14(%ebp),%edx
    23fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    23fe:	01 c2                	add    %eax,%edx
    2400:	0f b7 05 42 eb 01 00 	movzwl 0x1eb42,%eax
    2407:	0f b7 c0             	movzwl %ax,%eax
    240a:	39 c2                	cmp    %eax,%edx
    240c:	0f 8f eb 00 00 00    	jg     24fd <drawMouse+0x117>
    2412:	8b 55 14             	mov    0x14(%ebp),%edx
    2415:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2418:	01 d0                	add    %edx,%eax
    241a:	85 c0                	test   %eax,%eax
    241c:	0f 88 db 00 00 00    	js     24fd <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    2422:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2429:	e9 b7 00 00 00       	jmp    24e5 <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    242e:	8b 55 10             	mov    0x10(%ebp),%edx
    2431:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2434:	01 c2                	add    %eax,%edx
    2436:	0f b7 05 40 eb 01 00 	movzwl 0x1eb40,%eax
    243d:	0f b7 c0             	movzwl %ax,%eax
    2440:	39 c2                	cmp    %eax,%edx
    2442:	0f 8f a7 00 00 00    	jg     24ef <drawMouse+0x109>
    2448:	8b 55 10             	mov    0x10(%ebp),%edx
    244b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    244e:	01 d0                	add    %edx,%eax
    2450:	85 c0                	test   %eax,%eax
    2452:	0f 88 97 00 00 00    	js     24ef <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    2458:	8b 55 fc             	mov    -0x4(%ebp),%edx
    245b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    245e:	89 d0                	mov    %edx,%eax
    2460:	c1 e0 04             	shl    $0x4,%eax
    2463:	29 d0                	sub    %edx,%eax
    2465:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    246b:	01 c2                	add    %eax,%edx
    246d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2470:	01 d0                	add    %edx,%eax
    2472:	05 00 64 01 00       	add    $0x16400,%eax
    2477:	0f b6 00             	movzbl (%eax),%eax
    247a:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    247d:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    2481:	74 5e                	je     24e1 <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    2483:	8b 55 14             	mov    0x14(%ebp),%edx
    2486:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2489:	01 c2                	add    %eax,%edx
    248b:	0f b7 05 40 eb 01 00 	movzwl 0x1eb40,%eax
    2492:	0f b7 c0             	movzwl %ax,%eax
    2495:	0f af c2             	imul   %edx,%eax
    2498:	89 c2                	mov    %eax,%edx
    249a:	8b 45 10             	mov    0x10(%ebp),%eax
    249d:	01 c2                	add    %eax,%edx
    249f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    24a2:	01 c2                	add    %eax,%edx
    24a4:	89 d0                	mov    %edx,%eax
    24a6:	01 c0                	add    %eax,%eax
    24a8:	01 c2                	add    %eax,%edx
    24aa:	8b 45 08             	mov    0x8(%ebp),%eax
    24ad:	01 d0                	add    %edx,%eax
    24af:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    24b2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    24b6:	8d 50 ff             	lea    -0x1(%eax),%edx
    24b9:	89 d0                	mov    %edx,%eax
    24bb:	01 c0                	add    %eax,%eax
    24bd:	01 d0                	add    %edx,%eax
    24bf:	05 84 eb 01 00       	add    $0x1eb84,%eax
    24c4:	83 ec 04             	sub    $0x4,%esp
    24c7:	89 e2                	mov    %esp,%edx
    24c9:	0f b7 08             	movzwl (%eax),%ecx
    24cc:	66 89 0a             	mov    %cx,(%edx)
    24cf:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    24d3:	88 42 02             	mov    %al,0x2(%edx)
    24d6:	ff 75 f0             	pushl  -0x10(%ebp)
    24d9:	e8 73 f6 ff ff       	call   1b51 <drawPoint>
    24de:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    24e1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    24e5:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    24e9:	0f 8e 3f ff ff ff    	jle    242e <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    24ef:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    24f3:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    24f7:	0f 8e fb fe ff ff    	jle    23f8 <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    24fd:	90                   	nop
    24fe:	c9                   	leave  
    24ff:	c3                   	ret    

00002500 <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    2500:	55                   	push   %ebp
    2501:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    2503:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    2507:	78 1b                	js     2524 <getColor+0x24>
    2509:	8b 45 08             	mov    0x8(%ebp),%eax
    250c:	8b 40 04             	mov    0x4(%eax),%eax
    250f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    2512:	7c 10                	jl     2524 <getColor+0x24>
    2514:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    2518:	78 0a                	js     2524 <getColor+0x24>
    251a:	8b 45 08             	mov    0x8(%ebp),%eax
    251d:	8b 00                	mov    (%eax),%eax
    251f:	3b 45 10             	cmp    0x10(%ebp),%eax
    2522:	7d 10                	jge    2534 <getColor+0x34>
    {
        *isInPic = 1;
    2524:	8b 45 14             	mov    0x14(%ebp),%eax
    2527:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    252d:	b8 f5 e6 01 00       	mov    $0x1e6f5,%eax
    2532:	eb 44                	jmp    2578 <getColor+0x78>
    }

    if (y == pic->height)
    2534:	8b 45 08             	mov    0x8(%ebp),%eax
    2537:	8b 40 04             	mov    0x4(%eax),%eax
    253a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    253d:	75 04                	jne    2543 <getColor+0x43>
        y--;
    253f:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    2543:	8b 45 08             	mov    0x8(%ebp),%eax
    2546:	8b 00                	mov    (%eax),%eax
    2548:	3b 45 10             	cmp    0x10(%ebp),%eax
    254b:	75 04                	jne    2551 <getColor+0x51>
        x--;
    254d:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    2551:	8b 45 14             	mov    0x14(%ebp),%eax
    2554:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    255a:	8b 45 08             	mov    0x8(%ebp),%eax
    255d:	8b 48 08             	mov    0x8(%eax),%ecx
    2560:	8b 45 08             	mov    0x8(%ebp),%eax
    2563:	8b 00                	mov    (%eax),%eax
    2565:	0f af 45 0c          	imul   0xc(%ebp),%eax
    2569:	89 c2                	mov    %eax,%edx
    256b:	8b 45 10             	mov    0x10(%ebp),%eax
    256e:	01 c2                	add    %eax,%edx
    2570:	89 d0                	mov    %edx,%eax
    2572:	01 c0                	add    %eax,%eax
    2574:	01 d0                	add    %edx,%eax
    2576:	01 c8                	add    %ecx,%eax
}
    2578:	5d                   	pop    %ebp
    2579:	c3                   	ret    

0000257a <setColor>:

int setColor(RGB *src, RGB *dst)
{
    257a:	55                   	push   %ebp
    257b:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    257d:	8b 45 08             	mov    0x8(%ebp),%eax
    2580:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    2584:	8b 45 0c             	mov    0xc(%ebp),%eax
    2587:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    258a:	8b 45 08             	mov    0x8(%ebp),%eax
    258d:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    2591:	8b 45 0c             	mov    0xc(%ebp),%eax
    2594:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    2597:	8b 45 08             	mov    0x8(%ebp),%eax
    259a:	0f b6 10             	movzbl (%eax),%edx
    259d:	8b 45 0c             	mov    0xc(%ebp),%eax
    25a0:	88 10                	mov    %dl,(%eax)

    return 1;
    25a2:	b8 01 00 00 00       	mov    $0x1,%eax
}
    25a7:	5d                   	pop    %ebp
    25a8:	c3                   	ret    

000025a9 <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    25a9:	55                   	push   %ebp
    25aa:	89 e5                	mov    %esp,%ebp
    25ac:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    25af:	d9 45 10             	flds   0x10(%ebp)
    25b2:	d9 7d be             	fnstcw -0x42(%ebp)
    25b5:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    25b9:	b4 0c                	mov    $0xc,%ah
    25bb:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    25bf:	d9 6d bc             	fldcw  -0x44(%ebp)
    25c2:	db 5d fc             	fistpl -0x4(%ebp)
    25c5:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    25c8:	d9 45 0c             	flds   0xc(%ebp)
    25cb:	d9 6d bc             	fldcw  -0x44(%ebp)
    25ce:	db 5d f8             	fistpl -0x8(%ebp)
    25d1:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    25d4:	db 45 fc             	fildl  -0x4(%ebp)
    25d7:	d9 45 10             	flds   0x10(%ebp)
    25da:	d9 c9                	fxch   %st(1)
    25dc:	df e9                	fucomip %st(1),%st
    25de:	dd d8                	fstp   %st(0)
    25e0:	76 04                	jbe    25e6 <mixColor+0x3d>
        x--;
    25e2:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    25e6:	db 45 f8             	fildl  -0x8(%ebp)
    25e9:	d9 45 0c             	flds   0xc(%ebp)
    25ec:	d9 c9                	fxch   %st(1)
    25ee:	df e9                	fucomip %st(1),%st
    25f0:	dd d8                	fstp   %st(0)
    25f2:	76 04                	jbe    25f8 <mixColor+0x4f>
        y--;
    25f4:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    25f8:	8d 45 c0             	lea    -0x40(%ebp),%eax
    25fb:	50                   	push   %eax
    25fc:	ff 75 fc             	pushl  -0x4(%ebp)
    25ff:	ff 75 f8             	pushl  -0x8(%ebp)
    2602:	ff 75 08             	pushl  0x8(%ebp)
    2605:	e8 f6 fe ff ff       	call   2500 <getColor>
    260a:	83 c4 10             	add    $0x10,%esp
    260d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    2610:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2613:	83 c0 01             	add    $0x1,%eax
    2616:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2619:	83 c2 04             	add    $0x4,%edx
    261c:	52                   	push   %edx
    261d:	ff 75 fc             	pushl  -0x4(%ebp)
    2620:	50                   	push   %eax
    2621:	ff 75 08             	pushl  0x8(%ebp)
    2624:	e8 d7 fe ff ff       	call   2500 <getColor>
    2629:	83 c4 10             	add    $0x10,%esp
    262c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    262f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2632:	83 c0 01             	add    $0x1,%eax
    2635:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2638:	83 c2 08             	add    $0x8,%edx
    263b:	52                   	push   %edx
    263c:	50                   	push   %eax
    263d:	ff 75 f8             	pushl  -0x8(%ebp)
    2640:	ff 75 08             	pushl  0x8(%ebp)
    2643:	e8 b8 fe ff ff       	call   2500 <getColor>
    2648:	83 c4 10             	add    $0x10,%esp
    264b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    264e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2651:	8d 50 01             	lea    0x1(%eax),%edx
    2654:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2657:	83 c0 01             	add    $0x1,%eax
    265a:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    265d:	83 c1 0c             	add    $0xc,%ecx
    2660:	51                   	push   %ecx
    2661:	52                   	push   %edx
    2662:	50                   	push   %eax
    2663:	ff 75 08             	pushl  0x8(%ebp)
    2666:	e8 95 fe ff ff       	call   2500 <getColor>
    266b:	83 c4 10             	add    $0x10,%esp
    266e:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    2671:	db 45 fc             	fildl  -0x4(%ebp)
    2674:	d9 45 10             	flds   0x10(%ebp)
    2677:	de e1                	fsubp  %st,%st(1)
    2679:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    267c:	db 45 f8             	fildl  -0x8(%ebp)
    267f:	d9 45 0c             	flds   0xc(%ebp)
    2682:	de e1                	fsubp  %st,%st(1)
    2684:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    2687:	d9 45 e4             	flds   -0x1c(%ebp)
    268a:	d8 4d e0             	fmuls  -0x20(%ebp)
    268d:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    2690:	d9 e8                	fld1   
    2692:	d8 65 e0             	fsubs  -0x20(%ebp)
    2695:	d8 4d e4             	fmuls  -0x1c(%ebp)
    2698:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    269b:	d9 e8                	fld1   
    269d:	d8 65 e4             	fsubs  -0x1c(%ebp)
    26a0:	d8 4d e0             	fmuls  -0x20(%ebp)
    26a3:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    26a6:	d9 e8                	fld1   
    26a8:	d8 65 e4             	fsubs  -0x1c(%ebp)
    26ab:	d9 e8                	fld1   
    26ad:	d8 65 e0             	fsubs  -0x20(%ebp)
    26b0:	de c9                	fmulp  %st,%st(1)
    26b2:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    26b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    26b8:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    26bc:	0f b6 c0             	movzbl %al,%eax
    26bf:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    26c2:	db 45 b4             	fildl  -0x4c(%ebp)
    26c5:	d8 4d d0             	fmuls  -0x30(%ebp)
    26c8:	8b 45 c0             	mov    -0x40(%ebp),%eax
    26cb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    26ce:	db 45 b4             	fildl  -0x4c(%ebp)
    26d1:	de c9                	fmulp  %st,%st(1)
    26d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    26d6:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    26da:	0f b6 c0             	movzbl %al,%eax
    26dd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    26e0:	db 45 b4             	fildl  -0x4c(%ebp)
    26e3:	d8 4d d4             	fmuls  -0x2c(%ebp)
    26e6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    26e9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    26ec:	db 45 b4             	fildl  -0x4c(%ebp)
    26ef:	de c9                	fmulp  %st,%st(1)
    26f1:	de c1                	faddp  %st,%st(1)
    26f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    26f6:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    26fa:	0f b6 c0             	movzbl %al,%eax
    26fd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2700:	db 45 b4             	fildl  -0x4c(%ebp)
    2703:	d8 4d d8             	fmuls  -0x28(%ebp)
    2706:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2709:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    270c:	db 45 b4             	fildl  -0x4c(%ebp)
    270f:	de c9                	fmulp  %st,%st(1)
    2711:	de c1                	faddp  %st,%st(1)
    2713:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2716:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    271a:	0f b6 c0             	movzbl %al,%eax
    271d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2720:	db 45 b4             	fildl  -0x4c(%ebp)
    2723:	d8 4d dc             	fmuls  -0x24(%ebp)
    2726:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2729:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    272c:	db 45 b4             	fildl  -0x4c(%ebp)
    272f:	de c9                	fmulp  %st,%st(1)
    2731:	de c1                	faddp  %st,%st(1)
    2733:	d9 7d be             	fnstcw -0x42(%ebp)
    2736:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    273a:	b4 0c                	mov    $0xc,%ah
    273c:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    2740:	d9 6d bc             	fldcw  -0x44(%ebp)
    2743:	db 5d b8             	fistpl -0x48(%ebp)
    2746:	d9 6d be             	fldcw  -0x42(%ebp)
    2749:	8b 45 b8             	mov    -0x48(%ebp),%eax
    274c:	89 c2                	mov    %eax,%edx
    274e:	8b 45 14             	mov    0x14(%ebp),%eax
    2751:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    2754:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2757:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    275b:	0f b6 c0             	movzbl %al,%eax
    275e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2761:	db 45 b4             	fildl  -0x4c(%ebp)
    2764:	d8 4d d0             	fmuls  -0x30(%ebp)
    2767:	8b 45 c0             	mov    -0x40(%ebp),%eax
    276a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    276d:	db 45 b4             	fildl  -0x4c(%ebp)
    2770:	de c9                	fmulp  %st,%st(1)
    2772:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2775:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2779:	0f b6 c0             	movzbl %al,%eax
    277c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    277f:	db 45 b4             	fildl  -0x4c(%ebp)
    2782:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2785:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2788:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    278b:	db 45 b4             	fildl  -0x4c(%ebp)
    278e:	de c9                	fmulp  %st,%st(1)
    2790:	de c1                	faddp  %st,%st(1)
    2792:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2795:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2799:	0f b6 c0             	movzbl %al,%eax
    279c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    279f:	db 45 b4             	fildl  -0x4c(%ebp)
    27a2:	d8 4d d8             	fmuls  -0x28(%ebp)
    27a5:	8b 45 c8             	mov    -0x38(%ebp),%eax
    27a8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    27ab:	db 45 b4             	fildl  -0x4c(%ebp)
    27ae:	de c9                	fmulp  %st,%st(1)
    27b0:	de c1                	faddp  %st,%st(1)
    27b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    27b5:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    27b9:	0f b6 c0             	movzbl %al,%eax
    27bc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    27bf:	db 45 b4             	fildl  -0x4c(%ebp)
    27c2:	d8 4d dc             	fmuls  -0x24(%ebp)
    27c5:	8b 45 cc             	mov    -0x34(%ebp),%eax
    27c8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    27cb:	db 45 b4             	fildl  -0x4c(%ebp)
    27ce:	de c9                	fmulp  %st,%st(1)
    27d0:	de c1                	faddp  %st,%st(1)
    27d2:	d9 6d bc             	fldcw  -0x44(%ebp)
    27d5:	db 5d b8             	fistpl -0x48(%ebp)
    27d8:	d9 6d be             	fldcw  -0x42(%ebp)
    27db:	8b 45 b8             	mov    -0x48(%ebp),%eax
    27de:	89 c2                	mov    %eax,%edx
    27e0:	8b 45 14             	mov    0x14(%ebp),%eax
    27e3:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    27e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    27e9:	0f b6 00             	movzbl (%eax),%eax
    27ec:	0f b6 c0             	movzbl %al,%eax
    27ef:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    27f2:	db 45 b4             	fildl  -0x4c(%ebp)
    27f5:	d8 4d d0             	fmuls  -0x30(%ebp)
    27f8:	8b 45 c0             	mov    -0x40(%ebp),%eax
    27fb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    27fe:	db 45 b4             	fildl  -0x4c(%ebp)
    2801:	de c9                	fmulp  %st,%st(1)
    2803:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2806:	0f b6 00             	movzbl (%eax),%eax
    2809:	0f b6 c0             	movzbl %al,%eax
    280c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    280f:	db 45 b4             	fildl  -0x4c(%ebp)
    2812:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2815:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2818:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    281b:	db 45 b4             	fildl  -0x4c(%ebp)
    281e:	de c9                	fmulp  %st,%st(1)
    2820:	de c1                	faddp  %st,%st(1)
    2822:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2825:	0f b6 00             	movzbl (%eax),%eax
    2828:	0f b6 c0             	movzbl %al,%eax
    282b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    282e:	db 45 b4             	fildl  -0x4c(%ebp)
    2831:	d8 4d d8             	fmuls  -0x28(%ebp)
    2834:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2837:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    283a:	db 45 b4             	fildl  -0x4c(%ebp)
    283d:	de c9                	fmulp  %st,%st(1)
    283f:	de c1                	faddp  %st,%st(1)
    2841:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2844:	0f b6 00             	movzbl (%eax),%eax
    2847:	0f b6 c0             	movzbl %al,%eax
    284a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    284d:	db 45 b4             	fildl  -0x4c(%ebp)
    2850:	d8 4d dc             	fmuls  -0x24(%ebp)
    2853:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2856:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2859:	db 45 b4             	fildl  -0x4c(%ebp)
    285c:	de c9                	fmulp  %st,%st(1)
    285e:	de c1                	faddp  %st,%st(1)
    2860:	d9 6d bc             	fldcw  -0x44(%ebp)
    2863:	db 5d b8             	fistpl -0x48(%ebp)
    2866:	d9 6d be             	fldcw  -0x42(%ebp)
    2869:	8b 45 b8             	mov    -0x48(%ebp),%eax
    286c:	89 c2                	mov    %eax,%edx
    286e:	8b 45 14             	mov    0x14(%ebp),%eax
    2871:	88 10                	mov    %dl,(%eax)

    return 1;
    2873:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2878:	c9                   	leave  
    2879:	c3                   	ret    

0000287a <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    287a:	55                   	push   %ebp
    287b:	89 e5                	mov    %esp,%ebp
    287d:	53                   	push   %ebx
    287e:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    2881:	8b 45 10             	mov    0x10(%ebp),%eax
    2884:	c1 f8 10             	sar    $0x10,%eax
    2887:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    288a:	8b 45 0c             	mov    0xc(%ebp),%eax
    288d:	c1 f8 10             	sar    $0x10,%eax
    2890:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2893:	8d 45 bc             	lea    -0x44(%ebp),%eax
    2896:	50                   	push   %eax
    2897:	ff 75 f8             	pushl  -0x8(%ebp)
    289a:	ff 75 f4             	pushl  -0xc(%ebp)
    289d:	ff 75 08             	pushl  0x8(%ebp)
    28a0:	e8 5b fc ff ff       	call   2500 <getColor>
    28a5:	83 c4 10             	add    $0x10,%esp
    28a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    28ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    28ae:	83 c0 01             	add    $0x1,%eax
    28b1:	8d 55 bc             	lea    -0x44(%ebp),%edx
    28b4:	83 c2 04             	add    $0x4,%edx
    28b7:	52                   	push   %edx
    28b8:	ff 75 f8             	pushl  -0x8(%ebp)
    28bb:	50                   	push   %eax
    28bc:	ff 75 08             	pushl  0x8(%ebp)
    28bf:	e8 3c fc ff ff       	call   2500 <getColor>
    28c4:	83 c4 10             	add    $0x10,%esp
    28c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    28ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    28cd:	83 c0 01             	add    $0x1,%eax
    28d0:	8d 55 bc             	lea    -0x44(%ebp),%edx
    28d3:	83 c2 08             	add    $0x8,%edx
    28d6:	52                   	push   %edx
    28d7:	50                   	push   %eax
    28d8:	ff 75 f4             	pushl  -0xc(%ebp)
    28db:	ff 75 08             	pushl  0x8(%ebp)
    28de:	e8 1d fc ff ff       	call   2500 <getColor>
    28e3:	83 c4 10             	add    $0x10,%esp
    28e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    28e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    28ec:	8d 50 01             	lea    0x1(%eax),%edx
    28ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    28f2:	83 c0 01             	add    $0x1,%eax
    28f5:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    28f8:	83 c1 0c             	add    $0xc,%ecx
    28fb:	51                   	push   %ecx
    28fc:	52                   	push   %edx
    28fd:	50                   	push   %eax
    28fe:	ff 75 08             	pushl  0x8(%ebp)
    2901:	e8 fa fb ff ff       	call   2500 <getColor>
    2906:	83 c4 10             	add    $0x10,%esp
    2909:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    290c:	8b 45 10             	mov    0x10(%ebp),%eax
    290f:	0f b7 c0             	movzwl %ax,%eax
    2912:	c1 f8 08             	sar    $0x8,%eax
    2915:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    2918:	8b 45 0c             	mov    0xc(%ebp),%eax
    291b:	0f b7 c0             	movzwl %ax,%eax
    291e:	c1 f8 08             	sar    $0x8,%eax
    2921:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    2924:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2927:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    292b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    292e:	b8 ff 00 00 00       	mov    $0xff,%eax
    2933:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2936:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    293a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    293d:	b8 ff 00 00 00       	mov    $0xff,%eax
    2942:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2945:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    2949:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    294c:	b8 ff 00 00 00       	mov    $0xff,%eax
    2951:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2954:	89 c2                	mov    %eax,%edx
    2956:	b8 ff 00 00 00       	mov    $0xff,%eax
    295b:	2b 45 dc             	sub    -0x24(%ebp),%eax
    295e:	0f af c2             	imul   %edx,%eax
    2961:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    2964:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2967:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    296b:	0f b6 c0             	movzbl %al,%eax
    296e:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2972:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2975:	0f af d0             	imul   %eax,%edx
    2978:	8b 45 ec             	mov    -0x14(%ebp),%eax
    297b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    297f:	0f b6 c0             	movzbl %al,%eax
    2982:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2986:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2989:	0f af c1             	imul   %ecx,%eax
    298c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    298f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2992:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2996:	0f b6 c0             	movzbl %al,%eax
    2999:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    299d:	8b 55 c8             	mov    -0x38(%ebp),%edx
    29a0:	0f af d0             	imul   %eax,%edx
    29a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    29a6:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    29aa:	0f b6 c0             	movzbl %al,%eax
    29ad:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    29b1:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    29b4:	0f af c1             	imul   %ecx,%eax
    29b7:	01 d0                	add    %edx,%eax
    29b9:	01 d8                	add    %ebx,%eax
    29bb:	c1 e8 10             	shr    $0x10,%eax
    29be:	89 c2                	mov    %eax,%edx
    29c0:	8b 45 14             	mov    0x14(%ebp),%eax
    29c3:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    29c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    29c9:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    29cd:	0f b6 c0             	movzbl %al,%eax
    29d0:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    29d4:	8b 55 bc             	mov    -0x44(%ebp),%edx
    29d7:	0f af d0             	imul   %eax,%edx
    29da:	8b 45 ec             	mov    -0x14(%ebp),%eax
    29dd:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    29e1:	0f b6 c0             	movzbl %al,%eax
    29e4:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    29e8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    29eb:	0f af c1             	imul   %ecx,%eax
    29ee:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    29f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    29f4:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    29f8:	0f b6 c0             	movzbl %al,%eax
    29fb:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    29ff:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2a02:	0f af d0             	imul   %eax,%edx
    2a05:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2a08:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2a0c:	0f b6 c0             	movzbl %al,%eax
    2a0f:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2a13:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2a16:	0f af c1             	imul   %ecx,%eax
    2a19:	01 d0                	add    %edx,%eax
    2a1b:	01 d8                	add    %ebx,%eax
    2a1d:	c1 e8 10             	shr    $0x10,%eax
    2a20:	89 c2                	mov    %eax,%edx
    2a22:	8b 45 14             	mov    0x14(%ebp),%eax
    2a25:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    2a28:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2a2b:	0f b6 00             	movzbl (%eax),%eax
    2a2e:	0f b6 c0             	movzbl %al,%eax
    2a31:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2a35:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2a38:	0f af d0             	imul   %eax,%edx
    2a3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2a3e:	0f b6 00             	movzbl (%eax),%eax
    2a41:	0f b6 c0             	movzbl %al,%eax
    2a44:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2a48:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2a4b:	0f af c1             	imul   %ecx,%eax
    2a4e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2a51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2a54:	0f b6 00             	movzbl (%eax),%eax
    2a57:	0f b6 c0             	movzbl %al,%eax
    2a5a:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2a5e:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2a61:	0f af d0             	imul   %eax,%edx
    2a64:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2a67:	0f b6 00             	movzbl (%eax),%eax
    2a6a:	0f b6 c0             	movzbl %al,%eax
    2a6d:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2a71:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2a74:	0f af c1             	imul   %ecx,%eax
    2a77:	01 d0                	add    %edx,%eax
    2a79:	01 d8                	add    %ebx,%eax
    2a7b:	c1 e8 10             	shr    $0x10,%eax
    2a7e:	89 c2                	mov    %eax,%edx
    2a80:	8b 45 14             	mov    0x14(%ebp),%eax
    2a83:	88 10                	mov    %dl,(%eax)
}
    2a85:	90                   	nop
    2a86:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2a89:	c9                   	leave  
    2a8a:	c3                   	ret    

00002a8b <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    2a8b:	55                   	push   %ebp
    2a8c:	89 e5                	mov    %esp,%ebp
    2a8e:	53                   	push   %ebx
    2a8f:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    2a92:	8b 45 08             	mov    0x8(%ebp),%eax
    2a95:	8b 00                	mov    (%eax),%eax
    2a97:	c1 e0 10             	shl    $0x10,%eax
    2a9a:	89 c1                	mov    %eax,%ecx
    2a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a9f:	8b 18                	mov    (%eax),%ebx
    2aa1:	89 c8                	mov    %ecx,%eax
    2aa3:	99                   	cltd   
    2aa4:	f7 fb                	idiv   %ebx
    2aa6:	83 c0 01             	add    $0x1,%eax
    2aa9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    2aac:	8b 45 08             	mov    0x8(%ebp),%eax
    2aaf:	8b 40 04             	mov    0x4(%eax),%eax
    2ab2:	c1 e0 10             	shl    $0x10,%eax
    2ab5:	89 c1                	mov    %eax,%ecx
    2ab7:	8b 45 0c             	mov    0xc(%ebp),%eax
    2aba:	8b 58 04             	mov    0x4(%eax),%ebx
    2abd:	89 c8                	mov    %ecx,%eax
    2abf:	99                   	cltd   
    2ac0:	f7 fb                	idiv   %ebx
    2ac2:	83 c0 01             	add    $0x1,%eax
    2ac5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    2ac8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2acb:	d1 f8                	sar    %eax
    2acd:	2d 00 80 00 00       	sub    $0x8000,%eax
    2ad2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    2ad5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2ad8:	d1 f8                	sar    %eax
    2ada:	2d 00 80 00 00       	sub    $0x8000,%eax
    2adf:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    2ae2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2ae5:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    2ae8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2aef:	eb 5d                	jmp    2b4e <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    2af1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2af4:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    2af7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    2afe:	eb 3a                	jmp    2b3a <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    2b00:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b03:	8b 48 08             	mov    0x8(%eax),%ecx
    2b06:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b09:	8b 00                	mov    (%eax),%eax
    2b0b:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2b0f:	89 c2                	mov    %eax,%edx
    2b11:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2b14:	01 c2                	add    %eax,%edx
    2b16:	89 d0                	mov    %edx,%eax
    2b18:	01 c0                	add    %eax,%eax
    2b1a:	01 d0                	add    %edx,%eax
    2b1c:	01 c8                	add    %ecx,%eax
    2b1e:	50                   	push   %eax
    2b1f:	ff 75 f0             	pushl  -0x10(%ebp)
    2b22:	ff 75 f8             	pushl  -0x8(%ebp)
    2b25:	ff 75 08             	pushl  0x8(%ebp)
    2b28:	e8 4d fd ff ff       	call   287a <mixColorInt>
    2b2d:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    2b30:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2b33:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    2b36:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    2b3a:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b3d:	8b 00                	mov    (%eax),%eax
    2b3f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2b42:	7f bc                	jg     2b00 <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    2b44:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2b47:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    2b4a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2b4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b51:	8b 40 04             	mov    0x4(%eax),%eax
    2b54:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2b57:	7f 98                	jg     2af1 <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    2b59:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2b5e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2b61:	c9                   	leave  
    2b62:	c3                   	ret    

00002b63 <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    2b63:	55                   	push   %ebp
    2b64:	89 e5                	mov    %esp,%ebp
    2b66:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    2b69:	8b 45 08             	mov    0x8(%ebp),%eax
    2b6c:	8b 00                	mov    (%eax),%eax
    2b6e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2b71:	db 45 e4             	fildl  -0x1c(%ebp)
    2b74:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b77:	8b 00                	mov    (%eax),%eax
    2b79:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2b7c:	db 45 e4             	fildl  -0x1c(%ebp)
    2b7f:	de f9                	fdivrp %st,%st(1)
    2b81:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    2b84:	8b 45 08             	mov    0x8(%ebp),%eax
    2b87:	8b 40 04             	mov    0x4(%eax),%eax
    2b8a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2b8d:	db 45 e4             	fildl  -0x1c(%ebp)
    2b90:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b93:	8b 40 04             	mov    0x4(%eax),%eax
    2b96:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2b99:	db 45 e4             	fildl  -0x1c(%ebp)
    2b9c:	de f9                	fdivrp %st,%st(1)
    2b9e:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    2ba1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    2ba8:	eb 5e                	jmp    2c08 <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    2baa:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2bb1:	eb 47                	jmp    2bfa <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    2bb3:	db 45 f8             	fildl  -0x8(%ebp)
    2bb6:	d8 4d f4             	fmuls  -0xc(%ebp)
    2bb9:	d9 7d ee             	fnstcw -0x12(%ebp)
    2bbc:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    2bc0:	b4 0c                	mov    $0xc,%ah
    2bc2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    2bc6:	d9 6d ec             	fldcw  -0x14(%ebp)
    2bc9:	db 5d e8             	fistpl -0x18(%ebp)
    2bcc:	d9 6d ee             	fldcw  -0x12(%ebp)
    2bcf:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2bd2:	db 45 fc             	fildl  -0x4(%ebp)
    2bd5:	d8 4d f0             	fmuls  -0x10(%ebp)
    2bd8:	d9 6d ec             	fldcw  -0x14(%ebp)
    2bdb:	db 5d e8             	fistpl -0x18(%ebp)
    2bde:	d9 6d ee             	fldcw  -0x12(%ebp)
    2be1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2be4:	6a 00                	push   $0x0
    2be6:	52                   	push   %edx
    2be7:	50                   	push   %eax
    2be8:	ff 75 08             	pushl  0x8(%ebp)
    2beb:	e8 10 f9 ff ff       	call   2500 <getColor>
    2bf0:	83 c4 10             	add    $0x10,%esp
    2bf3:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    2bf6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2bfa:	8b 45 0c             	mov    0xc(%ebp),%eax
    2bfd:	8b 00                	mov    (%eax),%eax
    2bff:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2c02:	7f af                	jg     2bb3 <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    2c04:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2c08:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c0b:	8b 40 04             	mov    0x4(%eax),%eax
    2c0e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2c11:	7f 97                	jg     2baa <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    2c13:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2c18:	c9                   	leave  
    2c19:	c3                   	ret    

00002c1a <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    2c1a:	55                   	push   %ebp
    2c1b:	89 e5                	mov    %esp,%ebp
    2c1d:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    2c20:	8b 45 08             	mov    0x8(%ebp),%eax
    2c23:	8b 00                	mov    (%eax),%eax
    2c25:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2c28:	db 45 e0             	fildl  -0x20(%ebp)
    2c2b:	d9 5d e0             	fstps  -0x20(%ebp)
    2c2e:	83 ec 0c             	sub    $0xc,%esp
    2c31:	ff 75 10             	pushl  0x10(%ebp)
    2c34:	e8 6b e2 ff ff       	call   ea4 <cos>
    2c39:	83 c4 10             	add    $0x10,%esp
    2c3c:	d9 5d dc             	fstps  -0x24(%ebp)
    2c3f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2c42:	83 ec 0c             	sub    $0xc,%esp
    2c45:	50                   	push   %eax
    2c46:	e8 90 e1 ff ff       	call   ddb <abs>
    2c4b:	83 c4 10             	add    $0x10,%esp
    2c4e:	d8 4d e0             	fmuls  -0x20(%ebp)
    2c51:	d9 5d e0             	fstps  -0x20(%ebp)
    2c54:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c57:	8b 00                	mov    (%eax),%eax
    2c59:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2c5c:	db 45 dc             	fildl  -0x24(%ebp)
    2c5f:	d9 5d dc             	fstps  -0x24(%ebp)
    2c62:	83 ec 0c             	sub    $0xc,%esp
    2c65:	ff 75 10             	pushl  0x10(%ebp)
    2c68:	e8 da e3 ff ff       	call   1047 <sin>
    2c6d:	83 c4 10             	add    $0x10,%esp
    2c70:	d9 5d d8             	fstps  -0x28(%ebp)
    2c73:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2c76:	83 ec 0c             	sub    $0xc,%esp
    2c79:	50                   	push   %eax
    2c7a:	e8 5c e1 ff ff       	call   ddb <abs>
    2c7f:	83 c4 10             	add    $0x10,%esp
    2c82:	d8 4d dc             	fmuls  -0x24(%ebp)
    2c85:	d8 45 e0             	fadds  -0x20(%ebp)
    2c88:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2c8b:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    2c8f:	b4 0c                	mov    $0xc,%ah
    2c91:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2c95:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2c98:	db 5d f4             	fistpl -0xc(%ebp)
    2c9b:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    2c9e:	8b 45 08             	mov    0x8(%ebp),%eax
    2ca1:	8b 00                	mov    (%eax),%eax
    2ca3:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2ca6:	db 45 e0             	fildl  -0x20(%ebp)
    2ca9:	d9 5d e0             	fstps  -0x20(%ebp)
    2cac:	83 ec 0c             	sub    $0xc,%esp
    2caf:	ff 75 10             	pushl  0x10(%ebp)
    2cb2:	e8 90 e3 ff ff       	call   1047 <sin>
    2cb7:	83 c4 10             	add    $0x10,%esp
    2cba:	d9 5d dc             	fstps  -0x24(%ebp)
    2cbd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2cc0:	83 ec 0c             	sub    $0xc,%esp
    2cc3:	50                   	push   %eax
    2cc4:	e8 12 e1 ff ff       	call   ddb <abs>
    2cc9:	83 c4 10             	add    $0x10,%esp
    2ccc:	d8 4d e0             	fmuls  -0x20(%ebp)
    2ccf:	d9 5d e0             	fstps  -0x20(%ebp)
    2cd2:	8b 45 0c             	mov    0xc(%ebp),%eax
    2cd5:	8b 00                	mov    (%eax),%eax
    2cd7:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2cda:	db 45 dc             	fildl  -0x24(%ebp)
    2cdd:	d9 5d dc             	fstps  -0x24(%ebp)
    2ce0:	83 ec 0c             	sub    $0xc,%esp
    2ce3:	ff 75 10             	pushl  0x10(%ebp)
    2ce6:	e8 b9 e1 ff ff       	call   ea4 <cos>
    2ceb:	83 c4 10             	add    $0x10,%esp
    2cee:	d9 5d d8             	fstps  -0x28(%ebp)
    2cf1:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2cf4:	83 ec 0c             	sub    $0xc,%esp
    2cf7:	50                   	push   %eax
    2cf8:	e8 de e0 ff ff       	call   ddb <abs>
    2cfd:	83 c4 10             	add    $0x10,%esp
    2d00:	d8 4d dc             	fmuls  -0x24(%ebp)
    2d03:	d8 45 e0             	fadds  -0x20(%ebp)
    2d06:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2d09:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    2d0d:	b4 0c                	mov    $0xc,%ah
    2d0f:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2d13:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2d16:	db 5d f0             	fistpl -0x10(%ebp)
    2d19:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    2d1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d1f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2d22:	89 10                	mov    %edx,(%eax)
    *width = w;
    2d24:	8b 45 08             	mov    0x8(%ebp),%eax
    2d27:	8b 55 f4             	mov    -0xc(%ebp),%edx
    2d2a:	89 10                	mov    %edx,(%eax)
    return 1;
    2d2c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2d31:	c9                   	leave  
    2d32:	c3                   	ret    

00002d33 <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    2d33:	55                   	push   %ebp
    2d34:	89 e5                	mov    %esp,%ebp
    2d36:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    2d39:	8b 45 08             	mov    0x8(%ebp),%eax
    2d3c:	8b 40 04             	mov    0x4(%eax),%eax
    2d3f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2d42:	db 45 c4             	fildl  -0x3c(%ebp)
    2d45:	d9 05 44 a2 01 00    	flds   0x1a244
    2d4b:	de f9                	fdivrp %st,%st(1)
    2d4d:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    2d50:	8b 45 08             	mov    0x8(%ebp),%eax
    2d53:	8b 00                	mov    (%eax),%eax
    2d55:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2d58:	db 45 c4             	fildl  -0x3c(%ebp)
    2d5b:	d9 05 44 a2 01 00    	flds   0x1a244
    2d61:	de f9                	fdivrp %st,%st(1)
    2d63:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    2d66:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d69:	8b 50 04             	mov    0x4(%eax),%edx
    2d6c:	8b 45 08             	mov    0x8(%ebp),%eax
    2d6f:	8b 40 04             	mov    0x4(%eax),%eax
    2d72:	29 c2                	sub    %eax,%edx
    2d74:	89 d0                	mov    %edx,%eax
    2d76:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2d79:	db 45 c4             	fildl  -0x3c(%ebp)
    2d7c:	d9 05 44 a2 01 00    	flds   0x1a244
    2d82:	de f9                	fdivrp %st,%st(1)
    2d84:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    2d87:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d8a:	8b 10                	mov    (%eax),%edx
    2d8c:	8b 45 08             	mov    0x8(%ebp),%eax
    2d8f:	8b 00                	mov    (%eax),%eax
    2d91:	29 c2                	sub    %eax,%edx
    2d93:	89 d0                	mov    %edx,%eax
    2d95:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2d98:	db 45 c4             	fildl  -0x3c(%ebp)
    2d9b:	d9 05 44 a2 01 00    	flds   0x1a244
    2da1:	de f9                	fdivrp %st,%st(1)
    2da3:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    2da6:	d9 45 10             	flds   0x10(%ebp)
    2da9:	d9 e0                	fchs   
    2dab:	83 ec 0c             	sub    $0xc,%esp
    2dae:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2db2:	d9 1c 24             	fstps  (%esp)
    2db5:	e8 ea e0 ff ff       	call   ea4 <cos>
    2dba:	83 c4 10             	add    $0x10,%esp
    2dbd:	d9 5d c4             	fstps  -0x3c(%ebp)
    2dc0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2dc3:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    2dc6:	d9 45 10             	flds   0x10(%ebp)
    2dc9:	d9 e0                	fchs   
    2dcb:	83 ec 0c             	sub    $0xc,%esp
    2dce:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2dd2:	d9 1c 24             	fstps  (%esp)
    2dd5:	e8 6d e2 ff ff       	call   1047 <sin>
    2dda:	83 c4 10             	add    $0x10,%esp
    2ddd:	d9 5d c4             	fstps  -0x3c(%ebp)
    2de0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2de3:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    2de6:	d9 ee                	fldz   
    2de8:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    2deb:	d9 ee                	fldz   
    2ded:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    2df0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2df7:	e9 28 01 00 00       	jmp    2f24 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    2dfc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2e03:	e9 0a 01 00 00       	jmp    2f12 <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    2e08:	db 45 f4             	fildl  -0xc(%ebp)
    2e0b:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2e0e:	d8 65 ec             	fsubs  -0x14(%ebp)
    2e11:	d8 4d dc             	fmuls  -0x24(%ebp)
    2e14:	db 45 f0             	fildl  -0x10(%ebp)
    2e17:	d8 65 e0             	fsubs  -0x20(%ebp)
    2e1a:	d8 65 e8             	fsubs  -0x18(%ebp)
    2e1d:	d8 4d d8             	fmuls  -0x28(%ebp)
    2e20:	de c1                	faddp  %st,%st(1)
    2e22:	d8 45 ec             	fadds  -0x14(%ebp)
    2e25:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    2e28:	db 45 f0             	fildl  -0x10(%ebp)
    2e2b:	d8 65 e0             	fsubs  -0x20(%ebp)
    2e2e:	d8 65 e8             	fsubs  -0x18(%ebp)
    2e31:	d8 4d dc             	fmuls  -0x24(%ebp)
    2e34:	db 45 f4             	fildl  -0xc(%ebp)
    2e37:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2e3a:	d8 65 ec             	fsubs  -0x14(%ebp)
    2e3d:	d8 4d d8             	fmuls  -0x28(%ebp)
    2e40:	de e9                	fsubrp %st,%st(1)
    2e42:	d8 45 e8             	fadds  -0x18(%ebp)
    2e45:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    2e48:	d9 45 d4             	flds   -0x2c(%ebp)
    2e4b:	d9 ee                	fldz   
    2e4d:	d9 c9                	fxch   %st(1)
    2e4f:	df e9                	fucomip %st(1),%st
    2e51:	dd d8                	fstp   %st(0)
    2e53:	0f 93 c0             	setae  %al
    2e56:	83 f0 01             	xor    $0x1,%eax
    2e59:	84 c0                	test   %al,%al
    2e5b:	75 52                	jne    2eaf <picTurn+0x17c>
    2e5d:	8b 45 08             	mov    0x8(%ebp),%eax
    2e60:	8b 40 04             	mov    0x4(%eax),%eax
    2e63:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2e66:	db 45 c4             	fildl  -0x3c(%ebp)
    2e69:	d9 45 d4             	flds   -0x2c(%ebp)
    2e6c:	d9 c9                	fxch   %st(1)
    2e6e:	df e9                	fucomip %st(1),%st
    2e70:	dd d8                	fstp   %st(0)
    2e72:	0f 97 c0             	seta   %al
    2e75:	83 f0 01             	xor    $0x1,%eax
    2e78:	84 c0                	test   %al,%al
    2e7a:	75 33                	jne    2eaf <picTurn+0x17c>
    2e7c:	d9 45 d0             	flds   -0x30(%ebp)
    2e7f:	d9 ee                	fldz   
    2e81:	d9 c9                	fxch   %st(1)
    2e83:	df e9                	fucomip %st(1),%st
    2e85:	dd d8                	fstp   %st(0)
    2e87:	0f 93 c0             	setae  %al
    2e8a:	83 f0 01             	xor    $0x1,%eax
    2e8d:	84 c0                	test   %al,%al
    2e8f:	75 1e                	jne    2eaf <picTurn+0x17c>
    2e91:	8b 45 08             	mov    0x8(%ebp),%eax
    2e94:	8b 00                	mov    (%eax),%eax
    2e96:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2e99:	db 45 c4             	fildl  -0x3c(%ebp)
    2e9c:	d9 45 d0             	flds   -0x30(%ebp)
    2e9f:	d9 c9                	fxch   %st(1)
    2ea1:	df e9                	fucomip %st(1),%st
    2ea3:	dd d8                	fstp   %st(0)
    2ea5:	0f 97 c0             	seta   %al
    2ea8:	83 f0 01             	xor    $0x1,%eax
    2eab:	84 c0                	test   %al,%al
    2ead:	74 2f                	je     2ede <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    2eaf:	8b 45 0c             	mov    0xc(%ebp),%eax
    2eb2:	8b 48 08             	mov    0x8(%eax),%ecx
    2eb5:	8b 45 0c             	mov    0xc(%ebp),%eax
    2eb8:	8b 00                	mov    (%eax),%eax
    2eba:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2ebe:	89 c2                	mov    %eax,%edx
    2ec0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2ec3:	01 c2                	add    %eax,%edx
    2ec5:	89 d0                	mov    %edx,%eax
    2ec7:	01 c0                	add    %eax,%eax
    2ec9:	01 d0                	add    %edx,%eax
    2ecb:	01 c8                	add    %ecx,%eax
    2ecd:	83 ec 08             	sub    $0x8,%esp
    2ed0:	50                   	push   %eax
    2ed1:	68 f5 e6 01 00       	push   $0x1e6f5
    2ed6:	e8 9f f6 ff ff       	call   257a <setColor>
    2edb:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    2ede:	8b 45 0c             	mov    0xc(%ebp),%eax
    2ee1:	8b 48 08             	mov    0x8(%eax),%ecx
    2ee4:	8b 45 0c             	mov    0xc(%ebp),%eax
    2ee7:	8b 00                	mov    (%eax),%eax
    2ee9:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2eed:	89 c2                	mov    %eax,%edx
    2eef:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2ef2:	01 c2                	add    %eax,%edx
    2ef4:	89 d0                	mov    %edx,%eax
    2ef6:	01 c0                	add    %eax,%eax
    2ef8:	01 d0                	add    %edx,%eax
    2efa:	01 c8                	add    %ecx,%eax
    2efc:	50                   	push   %eax
    2efd:	ff 75 d0             	pushl  -0x30(%ebp)
    2f00:	ff 75 d4             	pushl  -0x2c(%ebp)
    2f03:	ff 75 08             	pushl  0x8(%ebp)
    2f06:	e8 9e f6 ff ff       	call   25a9 <mixColor>
    2f0b:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    2f0e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2f12:	8b 45 0c             	mov    0xc(%ebp),%eax
    2f15:	8b 00                	mov    (%eax),%eax
    2f17:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2f1a:	0f 8f e8 fe ff ff    	jg     2e08 <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    2f20:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2f24:	8b 45 0c             	mov    0xc(%ebp),%eax
    2f27:	8b 40 04             	mov    0x4(%eax),%eax
    2f2a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2f2d:	0f 8f c9 fe ff ff    	jg     2dfc <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    2f33:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2f38:	c9                   	leave  
    2f39:	c3                   	ret    

00002f3a <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    2f3a:	55                   	push   %ebp
    2f3b:	89 e5                	mov    %esp,%ebp
    2f3d:	53                   	push   %ebx
    2f3e:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2f41:	8b 45 08             	mov    0x8(%ebp),%eax
    2f44:	8b 10                	mov    (%eax),%edx
    2f46:	8b 45 0c             	mov    0xc(%ebp),%eax
    2f49:	8b 00                	mov    (%eax),%eax
    2f4b:	39 c2                	cmp    %eax,%edx
    2f4d:	75 10                	jne    2f5f <picRollingOver+0x25>
    2f4f:	8b 45 08             	mov    0x8(%ebp),%eax
    2f52:	8b 50 04             	mov    0x4(%eax),%edx
    2f55:	8b 45 0c             	mov    0xc(%ebp),%eax
    2f58:	8b 40 04             	mov    0x4(%eax),%eax
    2f5b:	39 c2                	cmp    %eax,%edx
    2f5d:	74 0a                	je     2f69 <picRollingOver+0x2f>
        return 0;
    2f5f:	b8 00 00 00 00       	mov    $0x0,%eax
    2f64:	e9 88 00 00 00       	jmp    2ff1 <picRollingOver+0xb7>

    int h = src->height;
    2f69:	8b 45 08             	mov    0x8(%ebp),%eax
    2f6c:	8b 40 04             	mov    0x4(%eax),%eax
    2f6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2f72:	8b 45 08             	mov    0x8(%ebp),%eax
    2f75:	8b 00                	mov    (%eax),%eax
    2f77:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2f7a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2f81:	eb 61                	jmp    2fe4 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    2f83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2f8a:	eb 4c                	jmp    2fd8 <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    2f8c:	8b 45 0c             	mov    0xc(%ebp),%eax
    2f8f:	8b 48 08             	mov    0x8(%eax),%ecx
    2f92:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2f95:	2b 45 f8             	sub    -0x8(%ebp),%eax
    2f98:	83 e8 01             	sub    $0x1,%eax
    2f9b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2f9f:	89 c2                	mov    %eax,%edx
    2fa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2fa4:	01 c2                	add    %eax,%edx
    2fa6:	89 d0                	mov    %edx,%eax
    2fa8:	01 c0                	add    %eax,%eax
    2faa:	01 d0                	add    %edx,%eax
    2fac:	01 c1                	add    %eax,%ecx
    2fae:	8b 45 08             	mov    0x8(%ebp),%eax
    2fb1:	8b 58 08             	mov    0x8(%eax),%ebx
    2fb4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2fb7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2fbb:	89 c2                	mov    %eax,%edx
    2fbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2fc0:	01 c2                	add    %eax,%edx
    2fc2:	89 d0                	mov    %edx,%eax
    2fc4:	01 c0                	add    %eax,%eax
    2fc6:	01 d0                	add    %edx,%eax
    2fc8:	01 d8                	add    %ebx,%eax
    2fca:	51                   	push   %ecx
    2fcb:	50                   	push   %eax
    2fcc:	e8 a9 f5 ff ff       	call   257a <setColor>
    2fd1:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2fd4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2fd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2fdb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2fde:	7c ac                	jl     2f8c <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2fe0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2fe4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2fe7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2fea:	7c 97                	jl     2f83 <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    2fec:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2ff1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2ff4:	c9                   	leave  
    2ff5:	c3                   	ret    

00002ff6 <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    2ff6:	55                   	push   %ebp
    2ff7:	89 e5                	mov    %esp,%ebp
    2ff9:	53                   	push   %ebx
    2ffa:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2ffd:	8b 45 08             	mov    0x8(%ebp),%eax
    3000:	8b 10                	mov    (%eax),%edx
    3002:	8b 45 0c             	mov    0xc(%ebp),%eax
    3005:	8b 00                	mov    (%eax),%eax
    3007:	39 c2                	cmp    %eax,%edx
    3009:	75 10                	jne    301b <picTurnAround+0x25>
    300b:	8b 45 08             	mov    0x8(%ebp),%eax
    300e:	8b 50 04             	mov    0x4(%eax),%edx
    3011:	8b 45 0c             	mov    0xc(%ebp),%eax
    3014:	8b 40 04             	mov    0x4(%eax),%eax
    3017:	39 c2                	cmp    %eax,%edx
    3019:	74 0a                	je     3025 <picTurnAround+0x2f>
        return 0;
    301b:	b8 00 00 00 00       	mov    $0x0,%eax
    3020:	e9 88 00 00 00       	jmp    30ad <picTurnAround+0xb7>

    int h = src->height;
    3025:	8b 45 08             	mov    0x8(%ebp),%eax
    3028:	8b 40 04             	mov    0x4(%eax),%eax
    302b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    302e:	8b 45 08             	mov    0x8(%ebp),%eax
    3031:	8b 00                	mov    (%eax),%eax
    3033:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    3036:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    303d:	eb 61                	jmp    30a0 <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    303f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3046:	eb 4c                	jmp    3094 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    3048:	8b 45 0c             	mov    0xc(%ebp),%eax
    304b:	8b 48 08             	mov    0x8(%eax),%ecx
    304e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3051:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    3055:	89 c2                	mov    %eax,%edx
    3057:	8b 45 ec             	mov    -0x14(%ebp),%eax
    305a:	2b 45 f4             	sub    -0xc(%ebp),%eax
    305d:	01 c2                	add    %eax,%edx
    305f:	89 d0                	mov    %edx,%eax
    3061:	01 c0                	add    %eax,%eax
    3063:	01 d0                	add    %edx,%eax
    3065:	83 e8 03             	sub    $0x3,%eax
    3068:	01 c1                	add    %eax,%ecx
    306a:	8b 45 08             	mov    0x8(%ebp),%eax
    306d:	8b 58 08             	mov    0x8(%eax),%ebx
    3070:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3073:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    3077:	89 c2                	mov    %eax,%edx
    3079:	8b 45 f4             	mov    -0xc(%ebp),%eax
    307c:	01 c2                	add    %eax,%edx
    307e:	89 d0                	mov    %edx,%eax
    3080:	01 c0                	add    %eax,%eax
    3082:	01 d0                	add    %edx,%eax
    3084:	01 d8                	add    %ebx,%eax
    3086:	51                   	push   %ecx
    3087:	50                   	push   %eax
    3088:	e8 ed f4 ff ff       	call   257a <setColor>
    308d:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    3090:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3094:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3097:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    309a:	7c ac                	jl     3048 <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    309c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    30a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    30a3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    30a6:	7c 97                	jl     303f <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    30a8:	b8 01 00 00 00       	mov    $0x1,%eax
}
    30ad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    30b0:	c9                   	leave  
    30b1:	c3                   	ret    

000030b2 <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    30b2:	55                   	push   %ebp
    30b3:	89 e5                	mov    %esp,%ebp
    30b5:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    30b8:	83 ec 0c             	sub    $0xc,%esp
    30bb:	ff 75 08             	pushl  0x8(%ebp)
    30be:	e8 c5 d5 ff ff       	call   688 <strlen>
    30c3:	83 c4 10             	add    $0x10,%esp
    30c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    30c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    30cc:	8d 50 ff             	lea    -0x1(%eax),%edx
    30cf:	8b 45 08             	mov    0x8(%ebp),%eax
    30d2:	01 d0                	add    %edx,%eax
    30d4:	0f b6 00             	movzbl (%eax),%eax
    30d7:	3c 67                	cmp    $0x67,%al
    30d9:	75 2b                	jne    3106 <type+0x54>
    30db:	8b 45 f4             	mov    -0xc(%ebp),%eax
    30de:	8d 50 fe             	lea    -0x2(%eax),%edx
    30e1:	8b 45 08             	mov    0x8(%ebp),%eax
    30e4:	01 d0                	add    %edx,%eax
    30e6:	0f b6 00             	movzbl (%eax),%eax
    30e9:	3c 70                	cmp    $0x70,%al
    30eb:	75 19                	jne    3106 <type+0x54>
    30ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    30f0:	8d 50 fd             	lea    -0x3(%eax),%edx
    30f3:	8b 45 08             	mov    0x8(%ebp),%eax
    30f6:	01 d0                	add    %edx,%eax
    30f8:	0f b6 00             	movzbl (%eax),%eax
    30fb:	3c 6a                	cmp    $0x6a,%al
    30fd:	75 07                	jne    3106 <type+0x54>
    30ff:	b8 00 00 00 00       	mov    $0x0,%eax
    3104:	eb 7f                	jmp    3185 <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    3106:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3109:	8d 50 ff             	lea    -0x1(%eax),%edx
    310c:	8b 45 08             	mov    0x8(%ebp),%eax
    310f:	01 d0                	add    %edx,%eax
    3111:	0f b6 00             	movzbl (%eax),%eax
    3114:	3c 70                	cmp    $0x70,%al
    3116:	75 2b                	jne    3143 <type+0x91>
    3118:	8b 45 f4             	mov    -0xc(%ebp),%eax
    311b:	8d 50 fe             	lea    -0x2(%eax),%edx
    311e:	8b 45 08             	mov    0x8(%ebp),%eax
    3121:	01 d0                	add    %edx,%eax
    3123:	0f b6 00             	movzbl (%eax),%eax
    3126:	3c 6d                	cmp    $0x6d,%al
    3128:	75 19                	jne    3143 <type+0x91>
    312a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    312d:	8d 50 fd             	lea    -0x3(%eax),%edx
    3130:	8b 45 08             	mov    0x8(%ebp),%eax
    3133:	01 d0                	add    %edx,%eax
    3135:	0f b6 00             	movzbl (%eax),%eax
    3138:	3c 62                	cmp    $0x62,%al
    313a:	75 07                	jne    3143 <type+0x91>
    313c:	b8 01 00 00 00       	mov    $0x1,%eax
    3141:	eb 42                	jmp    3185 <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    3143:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3146:	8d 50 ff             	lea    -0x1(%eax),%edx
    3149:	8b 45 08             	mov    0x8(%ebp),%eax
    314c:	01 d0                	add    %edx,%eax
    314e:	0f b6 00             	movzbl (%eax),%eax
    3151:	3c 67                	cmp    $0x67,%al
    3153:	75 2b                	jne    3180 <type+0xce>
    3155:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3158:	8d 50 fe             	lea    -0x2(%eax),%edx
    315b:	8b 45 08             	mov    0x8(%ebp),%eax
    315e:	01 d0                	add    %edx,%eax
    3160:	0f b6 00             	movzbl (%eax),%eax
    3163:	3c 6e                	cmp    $0x6e,%al
    3165:	75 19                	jne    3180 <type+0xce>
    3167:	8b 45 f4             	mov    -0xc(%ebp),%eax
    316a:	8d 50 fd             	lea    -0x3(%eax),%edx
    316d:	8b 45 08             	mov    0x8(%ebp),%eax
    3170:	01 d0                	add    %edx,%eax
    3172:	0f b6 00             	movzbl (%eax),%eax
    3175:	3c 70                	cmp    $0x70,%al
    3177:	75 07                	jne    3180 <type+0xce>
    3179:	b8 02 00 00 00       	mov    $0x2,%eax
    317e:	eb 05                	jmp    3185 <type+0xd3>
    else return NONE;
    3180:	b8 03 00 00 00       	mov    $0x3,%eax
}
    3185:	c9                   	leave  
    3186:	c3                   	ret    

00003187 <LoadBmp>:

PBitmap LoadBmp(char* filename){
    3187:	55                   	push   %ebp
    3188:	89 e5                	mov    %esp,%ebp
    318a:	56                   	push   %esi
    318b:	53                   	push   %ebx
    318c:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    318f:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    3196:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    319d:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    31a4:	83 ec 08             	sub    $0x8,%esp
    31a7:	6a 00                	push   $0x0
    31a9:	ff 75 0c             	pushl  0xc(%ebp)
    31ac:	e8 d9 d6 ff ff       	call   88a <open>
    31b1:	83 c4 10             	add    $0x10,%esp
    31b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    31b7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    31bb:	79 2c                	jns    31e9 <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    31bd:	83 ec 08             	sub    $0x8,%esp
    31c0:	ff 75 0c             	pushl  0xc(%ebp)
    31c3:	68 48 a2 01 00       	push   $0x1a248
    31c8:	e8 24 d8 ff ff       	call   9f1 <printf>
    31cd:	83 c4 10             	add    $0x10,%esp
        return bmp;
    31d0:	8b 45 08             	mov    0x8(%ebp),%eax
    31d3:	8b 55 b8             	mov    -0x48(%ebp),%edx
    31d6:	89 10                	mov    %edx,(%eax)
    31d8:	8b 55 bc             	mov    -0x44(%ebp),%edx
    31db:	89 50 04             	mov    %edx,0x4(%eax)
    31de:	8b 55 c0             	mov    -0x40(%ebp),%edx
    31e1:	89 50 08             	mov    %edx,0x8(%eax)
    31e4:	e9 2d 02 00 00       	jmp    3416 <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    31e9:	83 ec 04             	sub    $0x4,%esp
    31ec:	6a 0e                	push   $0xe
    31ee:	8d 45 aa             	lea    -0x56(%ebp),%eax
    31f1:	50                   	push   %eax
    31f2:	ff 75 ec             	pushl  -0x14(%ebp)
    31f5:	e8 68 d6 ff ff       	call   862 <read>
    31fa:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    31fd:	83 ec 04             	sub    $0x4,%esp
    3200:	6a 28                	push   $0x28
    3202:	8d 45 82             	lea    -0x7e(%ebp),%eax
    3205:	50                   	push   %eax
    3206:	ff 75 ec             	pushl  -0x14(%ebp)
    3209:	e8 54 d6 ff ff       	call   862 <read>
    320e:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    3211:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    3215:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    3218:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    321c:	0f b7 d8             	movzwl %ax,%ebx
    321f:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    3222:	8b 55 ac             	mov    -0x54(%ebp),%edx
    3225:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    3229:	0f b7 c0             	movzwl %ax,%eax
    322c:	83 ec 04             	sub    $0x4,%esp
    322f:	6a 36                	push   $0x36
    3231:	56                   	push   %esi
    3232:	53                   	push   %ebx
    3233:	51                   	push   %ecx
    3234:	52                   	push   %edx
    3235:	50                   	push   %eax
    3236:	68 58 a2 01 00       	push   $0x1a258
    323b:	e8 b1 d7 ff ff       	call   9f1 <printf>
    3240:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    3243:	8b 45 86             	mov    -0x7a(%ebp),%eax
    3246:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    3249:	8b 45 8a             	mov    -0x76(%ebp),%eax
    324c:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    324f:	8b 55 b8             	mov    -0x48(%ebp),%edx
    3252:	8b 45 bc             	mov    -0x44(%ebp),%eax
    3255:	0f af c2             	imul   %edx,%eax
    3258:	89 c2                	mov    %eax,%edx
    325a:	89 d0                	mov    %edx,%eax
    325c:	01 c0                	add    %eax,%eax
    325e:	01 d0                	add    %edx,%eax
    3260:	83 ec 0c             	sub    $0xc,%esp
    3263:	50                   	push   %eax
    3264:	e8 5b da ff ff       	call   cc4 <malloc>
    3269:	83 c4 10             	add    $0x10,%esp
    326c:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    326f:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    3273:	0f b7 c0             	movzwl %ax,%eax
    3276:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    3279:	8b 45 b8             	mov    -0x48(%ebp),%eax
    327c:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    3280:	83 c0 1f             	add    $0x1f,%eax
    3283:	c1 f8 05             	sar    $0x5,%eax
    3286:	c1 e0 02             	shl    $0x2,%eax
    3289:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    328c:	8b 45 bc             	mov    -0x44(%ebp),%eax
    328f:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    3293:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    3296:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3299:	8b 45 b8             	mov    -0x48(%ebp),%eax
    329c:	83 ec 08             	sub    $0x8,%esp
    329f:	52                   	push   %edx
    32a0:	50                   	push   %eax
    32a1:	ff 75 e8             	pushl  -0x18(%ebp)
    32a4:	ff 75 e0             	pushl  -0x20(%ebp)
    32a7:	ff 75 e4             	pushl  -0x1c(%ebp)
    32aa:	68 80 a2 01 00       	push   $0x1a280
    32af:	e8 3d d7 ff ff       	call   9f1 <printf>
    32b4:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    32b7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    32ba:	83 e8 36             	sub    $0x36,%eax
    32bd:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    32c0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    32c3:	83 ec 0c             	sub    $0xc,%esp
    32c6:	50                   	push   %eax
    32c7:	e8 f8 d9 ff ff       	call   cc4 <malloc>
    32cc:	83 c4 10             	add    $0x10,%esp
    32cf:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    32d2:	83 ec 04             	sub    $0x4,%esp
    32d5:	ff 75 dc             	pushl  -0x24(%ebp)
    32d8:	ff 75 d8             	pushl  -0x28(%ebp)
    32db:	ff 75 ec             	pushl  -0x14(%ebp)
    32de:	e8 7f d5 ff ff       	call   862 <read>
    32e3:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    32e6:	8b 45 ac             	mov    -0x54(%ebp),%eax
    32e9:	83 ec 0c             	sub    $0xc,%esp
    32ec:	50                   	push   %eax
    32ed:	e8 d2 d9 ff ff       	call   cc4 <malloc>
    32f2:	83 c4 10             	add    $0x10,%esp
    32f5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    32f8:	8b 45 ac             	mov    -0x54(%ebp),%eax
    32fb:	83 ec 04             	sub    $0x4,%esp
    32fe:	50                   	push   %eax
    32ff:	ff 75 d4             	pushl  -0x2c(%ebp)
    3302:	ff 75 ec             	pushl  -0x14(%ebp)
    3305:	e8 58 d5 ff ff       	call   862 <read>
    330a:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    330d:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    3311:	66 c1 e8 03          	shr    $0x3,%ax
    3315:	0f b7 c0             	movzwl %ax,%eax
    3318:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    331b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3322:	e9 c1 00 00 00       	jmp    33e8 <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    3327:	8b 45 bc             	mov    -0x44(%ebp),%eax
    332a:	2b 45 f4             	sub    -0xc(%ebp),%eax
    332d:	8d 50 ff             	lea    -0x1(%eax),%edx
    3330:	8b 45 b8             	mov    -0x48(%ebp),%eax
    3333:	0f af c2             	imul   %edx,%eax
    3336:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    3339:	8b 45 f4             	mov    -0xc(%ebp),%eax
    333c:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    3340:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    3343:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    334a:	e9 89 00 00 00       	jmp    33d8 <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    334f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3352:	83 c0 01             	add    $0x1,%eax
    3355:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    3359:	89 c2                	mov    %eax,%edx
    335b:	8b 45 c8             	mov    -0x38(%ebp),%eax
    335e:	01 d0                	add    %edx,%eax
    3360:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    3363:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3366:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    3369:	8b 45 f0             	mov    -0x10(%ebp),%eax
    336c:	01 c8                	add    %ecx,%eax
    336e:	89 c1                	mov    %eax,%ecx
    3370:	89 c8                	mov    %ecx,%eax
    3372:	01 c0                	add    %eax,%eax
    3374:	01 c8                	add    %ecx,%eax
    3376:	01 c2                	add    %eax,%edx
    3378:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    337b:	8d 48 ff             	lea    -0x1(%eax),%ecx
    337e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    3381:	01 c8                	add    %ecx,%eax
    3383:	0f b6 00             	movzbl (%eax),%eax
    3386:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    3389:	8b 55 c0             	mov    -0x40(%ebp),%edx
    338c:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    338f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3392:	01 c8                	add    %ecx,%eax
    3394:	89 c1                	mov    %eax,%ecx
    3396:	89 c8                	mov    %ecx,%eax
    3398:	01 c0                	add    %eax,%eax
    339a:	01 c8                	add    %ecx,%eax
    339c:	01 c2                	add    %eax,%edx
    339e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    33a1:	8d 48 fe             	lea    -0x2(%eax),%ecx
    33a4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    33a7:	01 c8                	add    %ecx,%eax
    33a9:	0f b6 00             	movzbl (%eax),%eax
    33ac:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    33af:	8b 55 c0             	mov    -0x40(%ebp),%edx
    33b2:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    33b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    33b8:	01 c8                	add    %ecx,%eax
    33ba:	89 c1                	mov    %eax,%ecx
    33bc:	89 c8                	mov    %ecx,%eax
    33be:	01 c0                	add    %eax,%eax
    33c0:	01 c8                	add    %ecx,%eax
    33c2:	01 c2                	add    %eax,%edx
    33c4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    33c7:	8d 48 fd             	lea    -0x3(%eax),%ecx
    33ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    33cd:	01 c8                	add    %ecx,%eax
    33cf:	0f b6 00             	movzbl (%eax),%eax
    33d2:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    33d4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    33d8:	8b 45 b8             	mov    -0x48(%ebp),%eax
    33db:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    33de:	0f 8f 6b ff ff ff    	jg     334f <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    33e4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    33e8:	8b 45 bc             	mov    -0x44(%ebp),%eax
    33eb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    33ee:	0f 8f 33 ff ff ff    	jg     3327 <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    33f4:	83 ec 0c             	sub    $0xc,%esp
    33f7:	ff 75 ec             	pushl  -0x14(%ebp)
    33fa:	e8 73 d4 ff ff       	call   872 <close>
    33ff:	83 c4 10             	add    $0x10,%esp
    return bmp;
    3402:	8b 45 08             	mov    0x8(%ebp),%eax
    3405:	8b 55 b8             	mov    -0x48(%ebp),%edx
    3408:	89 10                	mov    %edx,(%eax)
    340a:	8b 55 bc             	mov    -0x44(%ebp),%edx
    340d:	89 50 04             	mov    %edx,0x4(%eax)
    3410:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3413:	89 50 08             	mov    %edx,0x8(%eax)
}
    3416:	8b 45 08             	mov    0x8(%ebp),%eax
    3419:	8d 65 f8             	lea    -0x8(%ebp),%esp
    341c:	5b                   	pop    %ebx
    341d:	5e                   	pop    %esi
    341e:	5d                   	pop    %ebp
    341f:	c2 04 00             	ret    $0x4

00003422 <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    3422:	55                   	push   %ebp
    3423:	89 e5                	mov    %esp,%ebp
    3425:	53                   	push   %ebx
    3426:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    3429:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    342d:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    3431:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    3435:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    3439:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    343d:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    3441:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    3445:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    3449:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    344d:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    3451:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    3455:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    3459:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    345d:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    3461:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    3465:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    3469:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    346d:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    3471:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    3475:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    3479:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    347d:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    3481:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    3485:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    3489:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    348d:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    3491:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    3495:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    3499:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    349d:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    34a1:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    34a5:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    34a9:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    34ad:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    34b1:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    34b5:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    34b9:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    34bd:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    34c1:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    34c5:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    34c9:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    34cd:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    34d1:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    34d5:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    34d9:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    34dd:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    34e1:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    34e5:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    34e9:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    34ed:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    34f1:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    34f5:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    34f9:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    34fd:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    3501:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    3505:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    3509:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    350d:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    3511:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    3515:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    3519:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    351d:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    3521:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    3525:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    3529:	83 ec 0c             	sub    $0xc,%esp
    352c:	68 c8 02 08 00       	push   $0x802c8
    3531:	e8 8e d7 ff ff       	call   cc4 <malloc>
    3536:	83 c4 10             	add    $0x10,%esp
    3539:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    353c:	83 ec 04             	sub    $0x4,%esp
    353f:	68 c8 02 08 00       	push   $0x802c8
    3544:	6a 00                	push   $0x0
    3546:	ff 75 f0             	pushl  -0x10(%ebp)
    3549:	e8 61 d1 ff ff       	call   6af <memset>
    354e:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    3551:	83 ec 08             	sub    $0x8,%esp
    3554:	6a 00                	push   $0x0
    3556:	ff 75 0c             	pushl  0xc(%ebp)
    3559:	e8 2c d3 ff ff       	call   88a <open>
    355e:	83 c4 10             	add    $0x10,%esp
    3561:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    3564:	83 ec 0c             	sub    $0xc,%esp
    3567:	68 40 42 0f 00       	push   $0xf4240
    356c:	e8 53 d7 ff ff       	call   cc4 <malloc>
    3571:	83 c4 10             	add    $0x10,%esp
    3574:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    3577:	83 ec 04             	sub    $0x4,%esp
    357a:	68 40 42 0f 00       	push   $0xf4240
    357f:	ff 75 e8             	pushl  -0x18(%ebp)
    3582:	ff 75 ec             	pushl  -0x14(%ebp)
    3585:	e8 d8 d2 ff ff       	call   862 <read>
    358a:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    358d:	83 ec 0c             	sub    $0xc,%esp
    3590:	ff 75 ec             	pushl  -0x14(%ebp)
    3593:	e8 da d2 ff ff       	call   872 <close>
    3598:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    359b:	68 40 42 0f 00       	push   $0xf4240
    35a0:	ff 75 e8             	pushl  -0x18(%ebp)
    35a3:	8d 45 9c             	lea    -0x64(%ebp),%eax
    35a6:	50                   	push   %eax
    35a7:	ff 75 f0             	pushl  -0x10(%ebp)
    35aa:	e8 5e 0c 01 00       	call   1420d <_DecodeJPEG>
    35af:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    35b2:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    35b9:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    35c0:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    35c7:	83 ec 0c             	sub    $0xc,%esp
    35ca:	ff 75 f0             	pushl  -0x10(%ebp)
    35cd:	e8 29 0b 01 00       	call   140fb <GetImageSize>
    35d2:	83 c4 10             	add    $0x10,%esp
    35d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    35d8:	83 ec 0c             	sub    $0xc,%esp
    35db:	ff 75 f0             	pushl  -0x10(%ebp)
    35de:	e8 e1 0a 01 00       	call   140c4 <GetImage>
    35e3:	83 c4 10             	add    $0x10,%esp
    35e6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    35e9:	83 ec 0c             	sub    $0xc,%esp
    35ec:	ff 75 f0             	pushl  -0x10(%ebp)
    35ef:	e8 f1 0a 01 00       	call   140e5 <GetWidth>
    35f4:	83 c4 10             	add    $0x10,%esp
    35f7:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    35fa:	83 ec 0c             	sub    $0xc,%esp
    35fd:	ff 75 f0             	pushl  -0x10(%ebp)
    3600:	e8 eb 0a 01 00       	call   140f0 <GetHeight>
    3605:	83 c4 10             	add    $0x10,%esp
    3608:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    360b:	8b 55 90             	mov    -0x70(%ebp),%edx
    360e:	8b 45 94             	mov    -0x6c(%ebp),%eax
    3611:	0f af c2             	imul   %edx,%eax
    3614:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    3617:	8b 55 dc             	mov    -0x24(%ebp),%edx
    361a:	89 d0                	mov    %edx,%eax
    361c:	01 c0                	add    %eax,%eax
    361e:	01 d0                	add    %edx,%eax
    3620:	83 ec 0c             	sub    $0xc,%esp
    3623:	50                   	push   %eax
    3624:	e8 9b d6 ff ff       	call   cc4 <malloc>
    3629:	83 c4 10             	add    $0x10,%esp
    362c:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    362f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3636:	e9 9c 00 00 00       	jmp    36d7 <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    363b:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    363e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3641:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3646:	89 c8                	mov    %ecx,%eax
    3648:	f7 ea                	imul   %edx
    364a:	89 c8                	mov    %ecx,%eax
    364c:	c1 f8 1f             	sar    $0x1f,%eax
    364f:	29 c2                	sub    %eax,%edx
    3651:	89 d0                	mov    %edx,%eax
    3653:	89 c2                	mov    %eax,%edx
    3655:	89 d0                	mov    %edx,%eax
    3657:	01 c0                	add    %eax,%eax
    3659:	01 d0                	add    %edx,%eax
    365b:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    365e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3661:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3664:	01 c8                	add    %ecx,%eax
    3666:	0f b6 00             	movzbl (%eax),%eax
    3669:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    366c:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    366f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3672:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3677:	89 c8                	mov    %ecx,%eax
    3679:	f7 ea                	imul   %edx
    367b:	89 c8                	mov    %ecx,%eax
    367d:	c1 f8 1f             	sar    $0x1f,%eax
    3680:	29 c2                	sub    %eax,%edx
    3682:	89 d0                	mov    %edx,%eax
    3684:	89 c2                	mov    %eax,%edx
    3686:	89 d0                	mov    %edx,%eax
    3688:	01 c0                	add    %eax,%eax
    368a:	01 d0                	add    %edx,%eax
    368c:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    368f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3692:	8d 48 01             	lea    0x1(%eax),%ecx
    3695:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3698:	01 c8                	add    %ecx,%eax
    369a:	0f b6 00             	movzbl (%eax),%eax
    369d:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    36a0:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    36a3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    36a6:	ba 56 55 55 55       	mov    $0x55555556,%edx
    36ab:	89 c8                	mov    %ecx,%eax
    36ad:	f7 ea                	imul   %edx
    36af:	89 c8                	mov    %ecx,%eax
    36b1:	c1 f8 1f             	sar    $0x1f,%eax
    36b4:	29 c2                	sub    %eax,%edx
    36b6:	89 d0                	mov    %edx,%eax
    36b8:	89 c2                	mov    %eax,%edx
    36ba:	89 d0                	mov    %edx,%eax
    36bc:	01 c0                	add    %eax,%eax
    36be:	01 d0                	add    %edx,%eax
    36c0:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    36c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    36c6:	8d 48 02             	lea    0x2(%eax),%ecx
    36c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    36cc:	01 c8                	add    %ecx,%eax
    36ce:	0f b6 00             	movzbl (%eax),%eax
    36d1:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    36d3:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    36d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    36da:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    36dd:	0f 8c 58 ff ff ff    	jl     363b <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    36e3:	8b 45 08             	mov    0x8(%ebp),%eax
    36e6:	8b 55 90             	mov    -0x70(%ebp),%edx
    36e9:	89 10                	mov    %edx,(%eax)
    36eb:	8b 55 94             	mov    -0x6c(%ebp),%edx
    36ee:	89 50 04             	mov    %edx,0x4(%eax)
    36f1:	8b 55 98             	mov    -0x68(%ebp),%edx
    36f4:	89 50 08             	mov    %edx,0x8(%eax)
}
    36f7:	8b 45 08             	mov    0x8(%ebp),%eax
    36fa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    36fd:	c9                   	leave  
    36fe:	c2 04 00             	ret    $0x4

00003701 <LoadPng>:

PBitmap LoadPng(char* filename){
    3701:	55                   	push   %ebp
    3702:	89 e5                	mov    %esp,%ebp
    3704:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    3707:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    370e:	ff 75 0c             	pushl  0xc(%ebp)
    3711:	8d 45 e0             	lea    -0x20(%ebp),%eax
    3714:	50                   	push   %eax
    3715:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    3718:	50                   	push   %eax
    3719:	8d 45 e8             	lea    -0x18(%ebp),%eax
    371c:	50                   	push   %eax
    371d:	e8 d3 d3 00 00       	call   10af5 <lodepng_decode24_file>
    3722:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    3725:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3728:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    372b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    372e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    3731:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    3738:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    373b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    373e:	0f af c2             	imul   %edx,%eax
    3741:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    3744:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3747:	89 d0                	mov    %edx,%eax
    3749:	01 c0                	add    %eax,%eax
    374b:	01 d0                	add    %edx,%eax
    374d:	83 ec 0c             	sub    $0xc,%esp
    3750:	50                   	push   %eax
    3751:	e8 6e d5 ff ff       	call   cc4 <malloc>
    3756:	83 c4 10             	add    $0x10,%esp
    3759:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    375c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3763:	e9 87 00 00 00       	jmp    37ef <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    3768:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    376b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    376e:	89 d0                	mov    %edx,%eax
    3770:	01 c0                	add    %eax,%eax
    3772:	01 d0                	add    %edx,%eax
    3774:	01 c8                	add    %ecx,%eax
    3776:	0f b6 00             	movzbl (%eax),%eax
    3779:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    377c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    377f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3782:	89 d0                	mov    %edx,%eax
    3784:	01 c0                	add    %eax,%eax
    3786:	01 d0                	add    %edx,%eax
    3788:	83 c0 01             	add    $0x1,%eax
    378b:	01 c8                	add    %ecx,%eax
    378d:	0f b6 00             	movzbl (%eax),%eax
    3790:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    3793:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3796:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3799:	89 d0                	mov    %edx,%eax
    379b:	01 c0                	add    %eax,%eax
    379d:	01 d0                	add    %edx,%eax
    379f:	83 c0 02             	add    $0x2,%eax
    37a2:	01 c8                	add    %ecx,%eax
    37a4:	0f b6 00             	movzbl (%eax),%eax
    37a7:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    37aa:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    37ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
    37b0:	89 d0                	mov    %edx,%eax
    37b2:	01 c0                	add    %eax,%eax
    37b4:	01 d0                	add    %edx,%eax
    37b6:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    37b9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    37bd:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    37c0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    37c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    37c6:	89 d0                	mov    %edx,%eax
    37c8:	01 c0                	add    %eax,%eax
    37ca:	01 d0                	add    %edx,%eax
    37cc:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    37cf:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    37d3:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    37d6:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    37d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    37dc:	89 d0                	mov    %edx,%eax
    37de:	01 c0                	add    %eax,%eax
    37e0:	01 d0                	add    %edx,%eax
    37e2:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    37e5:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    37e9:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    37eb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    37ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    37f2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    37f5:	0f 8c 6d ff ff ff    	jl     3768 <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    37fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    37fe:	83 ec 0c             	sub    $0xc,%esp
    3801:	50                   	push   %eax
    3802:	e8 7b d3 ff ff       	call   b82 <free>
    3807:	83 c4 10             	add    $0x10,%esp
    return bmp;
    380a:	8b 45 08             	mov    0x8(%ebp),%eax
    380d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3810:	89 10                	mov    %edx,(%eax)
    3812:	8b 55 d8             	mov    -0x28(%ebp),%edx
    3815:	89 50 04             	mov    %edx,0x4(%eax)
    3818:	8b 55 dc             	mov    -0x24(%ebp),%edx
    381b:	89 50 08             	mov    %edx,0x8(%eax)

}
    381e:	8b 45 08             	mov    0x8(%ebp),%eax
    3821:	c9                   	leave  
    3822:	c2 04 00             	ret    $0x4

00003825 <LoadImg>:

PBitmap LoadImg(char* filename){
    3825:	55                   	push   %ebp
    3826:	89 e5                	mov    %esp,%ebp
    3828:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    382b:	83 ec 0c             	sub    $0xc,%esp
    382e:	ff 75 0c             	pushl  0xc(%ebp)
    3831:	e8 7c f8 ff ff       	call   30b2 <type>
    3836:	83 c4 10             	add    $0x10,%esp
    3839:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    383c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    383f:	83 f8 01             	cmp    $0x1,%eax
    3842:	74 1d                	je     3861 <LoadImg+0x3c>
    3844:	83 f8 02             	cmp    $0x2,%eax
    3847:	74 2c                	je     3875 <LoadImg+0x50>
    3849:	85 c0                	test   %eax,%eax
    384b:	75 3c                	jne    3889 <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    384d:	8b 45 08             	mov    0x8(%ebp),%eax
    3850:	83 ec 08             	sub    $0x8,%esp
    3853:	ff 75 0c             	pushl  0xc(%ebp)
    3856:	50                   	push   %eax
    3857:	e8 c6 fb ff ff       	call   3422 <LoadJpeg>
    385c:	83 c4 0c             	add    $0xc,%esp
    385f:	eb 3c                	jmp    389d <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    3861:	8b 45 08             	mov    0x8(%ebp),%eax
    3864:	83 ec 08             	sub    $0x8,%esp
    3867:	ff 75 0c             	pushl  0xc(%ebp)
    386a:	50                   	push   %eax
    386b:	e8 17 f9 ff ff       	call   3187 <LoadBmp>
    3870:	83 c4 0c             	add    $0xc,%esp
    3873:	eb 28                	jmp    389d <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    3875:	8b 45 08             	mov    0x8(%ebp),%eax
    3878:	83 ec 08             	sub    $0x8,%esp
    387b:	ff 75 0c             	pushl  0xc(%ebp)
    387e:	50                   	push   %eax
    387f:	e8 7d fe ff ff       	call   3701 <LoadPng>
    3884:	83 c4 0c             	add    $0xc,%esp
    3887:	eb 14                	jmp    389d <LoadImg+0x78>

        default: return bmp;
    3889:	8b 45 08             	mov    0x8(%ebp),%eax
    388c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    388f:	89 10                	mov    %edx,(%eax)
    3891:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3894:	89 50 04             	mov    %edx,0x4(%eax)
    3897:	8b 55 f0             	mov    -0x10(%ebp),%edx
    389a:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    389d:	8b 45 08             	mov    0x8(%ebp),%eax
    38a0:	c9                   	leave  
    38a1:	c2 04 00             	ret    $0x4

000038a4 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    38a4:	55                   	push   %ebp
    38a5:	89 e5                	mov    %esp,%ebp
    38a7:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    38aa:	8b 45 08             	mov    0x8(%ebp),%eax
    38ad:	83 ec 0c             	sub    $0xc,%esp
    38b0:	50                   	push   %eax
    38b1:	e8 0e d4 ff ff       	call   cc4 <malloc>
    38b6:	83 c4 10             	add    $0x10,%esp
}
    38b9:	c9                   	leave  
    38ba:	c3                   	ret    

000038bb <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    38bb:	55                   	push   %ebp
    38bc:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    38be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    38c3:	5d                   	pop    %ebp
    38c4:	c3                   	ret    

000038c5 <lodepng_free>:

static void lodepng_free(void* ptr) {
    38c5:	55                   	push   %ebp
    38c6:	89 e5                	mov    %esp,%ebp
    38c8:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    38cb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    38cf:	74 0e                	je     38df <lodepng_free+0x1a>
    free(ptr);
    38d1:	83 ec 0c             	sub    $0xc,%esp
    38d4:	ff 75 08             	pushl  0x8(%ebp)
    38d7:	e8 a6 d2 ff ff       	call   b82 <free>
    38dc:	83 c4 10             	add    $0x10,%esp
}
    38df:	90                   	nop
    38e0:	c9                   	leave  
    38e1:	c3                   	ret    

000038e2 <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    38e2:	55                   	push   %ebp
    38e3:	89 e5                	mov    %esp,%ebp
    38e5:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    38e8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    38ef:	eb 19                	jmp    390a <lodepng_memcpy+0x28>
    38f1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    38f4:	8b 45 08             	mov    0x8(%ebp),%eax
    38f7:	01 c2                	add    %eax,%edx
    38f9:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    38fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    38ff:	01 c8                	add    %ecx,%eax
    3901:	0f b6 00             	movzbl (%eax),%eax
    3904:	88 02                	mov    %al,(%edx)
    3906:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    390a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    390d:	3b 45 10             	cmp    0x10(%ebp),%eax
    3910:	7c df                	jl     38f1 <lodepng_memcpy+0xf>
}
    3912:	90                   	nop
    3913:	c9                   	leave  
    3914:	c3                   	ret    

00003915 <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    3915:	55                   	push   %ebp
    3916:	89 e5                	mov    %esp,%ebp
    3918:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    391b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3922:	eb 11                	jmp    3935 <lodepng_memset+0x20>
    3924:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3927:	8b 45 08             	mov    0x8(%ebp),%eax
    392a:	01 d0                	add    %edx,%eax
    392c:	8b 55 0c             	mov    0xc(%ebp),%edx
    392f:	88 10                	mov    %dl,(%eax)
    3931:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3935:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3938:	3b 45 10             	cmp    0x10(%ebp),%eax
    393b:	7c e7                	jl     3924 <lodepng_memset+0xf>
}
    393d:	90                   	nop
    393e:	c9                   	leave  
    393f:	c3                   	ret    

00003940 <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    3940:	55                   	push   %ebp
    3941:	89 e5                	mov    %esp,%ebp
    3943:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    3946:	8b 45 08             	mov    0x8(%ebp),%eax
    3949:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    394c:	eb 04                	jmp    3952 <lodepng_strlen+0x12>
    394e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    3952:	8b 45 08             	mov    0x8(%ebp),%eax
    3955:	0f b6 00             	movzbl (%eax),%eax
    3958:	84 c0                	test   %al,%al
    395a:	75 f2                	jne    394e <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    395c:	8b 55 08             	mov    0x8(%ebp),%edx
    395f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3962:	29 c2                	sub    %eax,%edx
    3964:	89 d0                	mov    %edx,%eax
}
    3966:	c9                   	leave  
    3967:	c3                   	ret    

00003968 <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    3968:	55                   	push   %ebp
    3969:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    396b:	8b 55 08             	mov    0x8(%ebp),%edx
    396e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3971:	01 c2                	add    %eax,%edx
    3973:	8b 45 10             	mov    0x10(%ebp),%eax
    3976:	89 10                	mov    %edx,(%eax)
  return *result < a;
    3978:	8b 45 10             	mov    0x10(%ebp),%eax
    397b:	8b 00                	mov    (%eax),%eax
    397d:	3b 45 08             	cmp    0x8(%ebp),%eax
    3980:	0f 9c c0             	setl   %al
    3983:	0f b6 c0             	movzbl %al,%eax
}
    3986:	5d                   	pop    %ebp
    3987:	c3                   	ret    

00003988 <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    3988:	55                   	push   %ebp
    3989:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    398b:	8b 45 08             	mov    0x8(%ebp),%eax
    398e:	0f af 45 0c          	imul   0xc(%ebp),%eax
    3992:	89 c2                	mov    %eax,%edx
    3994:	8b 45 10             	mov    0x10(%ebp),%eax
    3997:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    3999:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    399d:	74 15                	je     39b4 <lodepng_mulofl+0x2c>
    399f:	8b 45 10             	mov    0x10(%ebp),%eax
    39a2:	8b 00                	mov    (%eax),%eax
    39a4:	99                   	cltd   
    39a5:	f7 7d 08             	idivl  0x8(%ebp)
    39a8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    39ab:	74 07                	je     39b4 <lodepng_mulofl+0x2c>
    39ad:	b8 01 00 00 00       	mov    $0x1,%eax
    39b2:	eb 05                	jmp    39b9 <lodepng_mulofl+0x31>
    39b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    39b9:	5d                   	pop    %ebp
    39ba:	c3                   	ret    

000039bb <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    39bb:	55                   	push   %ebp
    39bc:	89 e5                	mov    %esp,%ebp
    39be:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    39c1:	8d 45 fc             	lea    -0x4(%ebp),%eax
    39c4:	50                   	push   %eax
    39c5:	ff 75 0c             	pushl  0xc(%ebp)
    39c8:	ff 75 08             	pushl  0x8(%ebp)
    39cb:	e8 98 ff ff ff       	call   3968 <lodepng_addofl>
    39d0:	83 c4 0c             	add    $0xc,%esp
    39d3:	85 c0                	test   %eax,%eax
    39d5:	74 07                	je     39de <lodepng_gtofl+0x23>
    39d7:	b8 01 00 00 00       	mov    $0x1,%eax
    39dc:	eb 0c                	jmp    39ea <lodepng_gtofl+0x2f>
  return d > c;
    39de:	8b 45 fc             	mov    -0x4(%ebp),%eax
    39e1:	3b 45 10             	cmp    0x10(%ebp),%eax
    39e4:	0f 9f c0             	setg   %al
    39e7:	0f b6 c0             	movzbl %al,%eax
}
    39ea:	c9                   	leave  
    39eb:	c3                   	ret    

000039ec <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    39ec:	55                   	push   %ebp
    39ed:	89 e5                	mov    %esp,%ebp
    39ef:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    39f2:	8b 45 08             	mov    0x8(%ebp),%eax
    39f5:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    39fc:	8b 45 08             	mov    0x8(%ebp),%eax
    39ff:	8b 50 08             	mov    0x8(%eax),%edx
    3a02:	8b 45 08             	mov    0x8(%ebp),%eax
    3a05:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    3a08:	8b 45 08             	mov    0x8(%ebp),%eax
    3a0b:	8b 00                	mov    (%eax),%eax
    3a0d:	83 ec 0c             	sub    $0xc,%esp
    3a10:	50                   	push   %eax
    3a11:	e8 af fe ff ff       	call   38c5 <lodepng_free>
    3a16:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    3a19:	8b 45 08             	mov    0x8(%ebp),%eax
    3a1c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3a22:	90                   	nop
    3a23:	c9                   	leave  
    3a24:	c3                   	ret    

00003a25 <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    3a25:	55                   	push   %ebp
    3a26:	89 e5                	mov    %esp,%ebp
    3a28:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    3a2b:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a2e:	c1 e0 02             	shl    $0x2,%eax
    3a31:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    3a34:	8b 45 08             	mov    0x8(%ebp),%eax
    3a37:	8b 40 08             	mov    0x8(%eax),%eax
    3a3a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    3a3d:	7d 46                	jge    3a85 <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    3a3f:	8b 45 08             	mov    0x8(%ebp),%eax
    3a42:	8b 40 08             	mov    0x8(%eax),%eax
    3a45:	d1 f8                	sar    %eax
    3a47:	89 c2                	mov    %eax,%edx
    3a49:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3a4c:	01 d0                	add    %edx,%eax
    3a4e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    3a51:	8b 45 08             	mov    0x8(%ebp),%eax
    3a54:	8b 00                	mov    (%eax),%eax
    3a56:	ff 75 f8             	pushl  -0x8(%ebp)
    3a59:	50                   	push   %eax
    3a5a:	e8 5c fe ff ff       	call   38bb <lodepng_realloc>
    3a5f:	83 c4 08             	add    $0x8,%esp
    3a62:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    3a65:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3a69:	74 13                	je     3a7e <uivector_resize+0x59>
      p->allocsize = newsize;
    3a6b:	8b 45 08             	mov    0x8(%ebp),%eax
    3a6e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3a71:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    3a74:	8b 45 08             	mov    0x8(%ebp),%eax
    3a77:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3a7a:	89 10                	mov    %edx,(%eax)
    3a7c:	eb 07                	jmp    3a85 <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    3a7e:	b8 00 00 00 00       	mov    $0x0,%eax
    3a83:	eb 0e                	jmp    3a93 <uivector_resize+0x6e>
  }
  p->size = size;
    3a85:	8b 45 08             	mov    0x8(%ebp),%eax
    3a88:	8b 55 0c             	mov    0xc(%ebp),%edx
    3a8b:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    3a8e:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3a93:	c9                   	leave  
    3a94:	c3                   	ret    

00003a95 <uivector_init>:

static void uivector_init(uivector* p) {
    3a95:	55                   	push   %ebp
    3a96:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    3a98:	8b 45 08             	mov    0x8(%ebp),%eax
    3a9b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    3aa1:	8b 45 08             	mov    0x8(%ebp),%eax
    3aa4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    3aab:	8b 45 08             	mov    0x8(%ebp),%eax
    3aae:	8b 50 08             	mov    0x8(%eax),%edx
    3ab1:	8b 45 08             	mov    0x8(%ebp),%eax
    3ab4:	89 50 04             	mov    %edx,0x4(%eax)
}
    3ab7:	90                   	nop
    3ab8:	5d                   	pop    %ebp
    3ab9:	c3                   	ret    

00003aba <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    3aba:	55                   	push   %ebp
    3abb:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    3abd:	8b 45 08             	mov    0x8(%ebp),%eax
    3ac0:	8b 40 04             	mov    0x4(%eax),%eax
    3ac3:	83 c0 01             	add    $0x1,%eax
    3ac6:	50                   	push   %eax
    3ac7:	ff 75 08             	pushl  0x8(%ebp)
    3aca:	e8 56 ff ff ff       	call   3a25 <uivector_resize>
    3acf:	83 c4 08             	add    $0x8,%esp
    3ad2:	85 c0                	test   %eax,%eax
    3ad4:	75 07                	jne    3add <uivector_push_back+0x23>
    3ad6:	b8 00 00 00 00       	mov    $0x0,%eax
    3adb:	eb 1f                	jmp    3afc <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    3add:	8b 45 08             	mov    0x8(%ebp),%eax
    3ae0:	8b 10                	mov    (%eax),%edx
    3ae2:	8b 45 08             	mov    0x8(%ebp),%eax
    3ae5:	8b 40 04             	mov    0x4(%eax),%eax
    3ae8:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    3aed:	c1 e0 02             	shl    $0x2,%eax
    3af0:	01 c2                	add    %eax,%edx
    3af2:	8b 45 0c             	mov    0xc(%ebp),%eax
    3af5:	89 02                	mov    %eax,(%edx)
  return 1;
    3af7:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3afc:	c9                   	leave  
    3afd:	c3                   	ret    

00003afe <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    3afe:	55                   	push   %ebp
    3aff:	89 e5                	mov    %esp,%ebp
    3b01:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    3b04:	8b 45 08             	mov    0x8(%ebp),%eax
    3b07:	8b 40 08             	mov    0x8(%eax),%eax
    3b0a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    3b0d:	7d 46                	jge    3b55 <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    3b0f:	8b 45 08             	mov    0x8(%ebp),%eax
    3b12:	8b 40 08             	mov    0x8(%eax),%eax
    3b15:	d1 f8                	sar    %eax
    3b17:	89 c2                	mov    %eax,%edx
    3b19:	8b 45 0c             	mov    0xc(%ebp),%eax
    3b1c:	01 d0                	add    %edx,%eax
    3b1e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    3b21:	8b 45 08             	mov    0x8(%ebp),%eax
    3b24:	8b 00                	mov    (%eax),%eax
    3b26:	ff 75 fc             	pushl  -0x4(%ebp)
    3b29:	50                   	push   %eax
    3b2a:	e8 8c fd ff ff       	call   38bb <lodepng_realloc>
    3b2f:	83 c4 08             	add    $0x8,%esp
    3b32:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    3b35:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    3b39:	74 13                	je     3b4e <ucvector_resize+0x50>
      p->allocsize = newsize;
    3b3b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b3e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3b41:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    3b44:	8b 45 08             	mov    0x8(%ebp),%eax
    3b47:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3b4a:	89 10                	mov    %edx,(%eax)
    3b4c:	eb 07                	jmp    3b55 <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    3b4e:	b8 00 00 00 00       	mov    $0x0,%eax
    3b53:	eb 0e                	jmp    3b63 <ucvector_resize+0x65>
  }
  p->size = size;
    3b55:	8b 45 08             	mov    0x8(%ebp),%eax
    3b58:	8b 55 0c             	mov    0xc(%ebp),%edx
    3b5b:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    3b5e:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3b63:	c9                   	leave  
    3b64:	c3                   	ret    

00003b65 <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    3b65:	55                   	push   %ebp
    3b66:	89 e5                	mov    %esp,%ebp
    3b68:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    3b6b:	8b 45 0c             	mov    0xc(%ebp),%eax
    3b6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    3b71:	8b 45 10             	mov    0x10(%ebp),%eax
    3b74:	89 45 f8             	mov    %eax,-0x8(%ebp)
    3b77:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3b7a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    3b7d:	8b 45 08             	mov    0x8(%ebp),%eax
    3b80:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3b83:	89 10                	mov    %edx,(%eax)
    3b85:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3b88:	89 50 04             	mov    %edx,0x4(%eax)
    3b8b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3b8e:	89 50 08             	mov    %edx,0x8(%eax)
}
    3b91:	8b 45 08             	mov    0x8(%ebp),%eax
    3b94:	c9                   	leave  
    3b95:	c2 04 00             	ret    $0x4

00003b98 <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    3b98:	55                   	push   %ebp
    3b99:	89 e5                	mov    %esp,%ebp
    3b9b:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    3b9e:	8b 45 08             	mov    0x8(%ebp),%eax
    3ba1:	8b 00                	mov    (%eax),%eax
    3ba3:	83 ec 0c             	sub    $0xc,%esp
    3ba6:	50                   	push   %eax
    3ba7:	e8 19 fd ff ff       	call   38c5 <lodepng_free>
    3bac:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    3baf:	8b 45 08             	mov    0x8(%ebp),%eax
    3bb2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3bb8:	90                   	nop
    3bb9:	c9                   	leave  
    3bba:	c3                   	ret    

00003bbb <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    3bbb:	55                   	push   %ebp
    3bbc:	89 e5                	mov    %esp,%ebp
    3bbe:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    3bc1:	8b 45 0c             	mov    0xc(%ebp),%eax
    3bc4:	83 c0 01             	add    $0x1,%eax
    3bc7:	83 ec 0c             	sub    $0xc,%esp
    3bca:	50                   	push   %eax
    3bcb:	e8 d4 fc ff ff       	call   38a4 <lodepng_malloc>
    3bd0:	83 c4 10             	add    $0x10,%esp
    3bd3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    3bd6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3bda:	74 1f                	je     3bfb <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    3bdc:	83 ec 04             	sub    $0x4,%esp
    3bdf:	ff 75 0c             	pushl  0xc(%ebp)
    3be2:	ff 75 08             	pushl  0x8(%ebp)
    3be5:	ff 75 f4             	pushl  -0xc(%ebp)
    3be8:	e8 f5 fc ff ff       	call   38e2 <lodepng_memcpy>
    3bed:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    3bf0:	8b 55 0c             	mov    0xc(%ebp),%edx
    3bf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3bf6:	01 d0                	add    %edx,%eax
    3bf8:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    3bfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3bfe:	c9                   	leave  
    3bff:	c3                   	ret    

00003c00 <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    3c00:	55                   	push   %ebp
    3c01:	89 e5                	mov    %esp,%ebp
    3c03:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    3c06:	ff 75 08             	pushl  0x8(%ebp)
    3c09:	e8 32 fd ff ff       	call   3940 <lodepng_strlen>
    3c0e:	83 c4 04             	add    $0x4,%esp
    3c11:	83 ec 08             	sub    $0x8,%esp
    3c14:	50                   	push   %eax
    3c15:	ff 75 08             	pushl  0x8(%ebp)
    3c18:	e8 9e ff ff ff       	call   3bbb <alloc_string_sized>
    3c1d:	83 c4 10             	add    $0x10,%esp
}
    3c20:	c9                   	leave  
    3c21:	c3                   	ret    

00003c22 <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    3c22:	55                   	push   %ebp
    3c23:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3c25:	8b 45 08             	mov    0x8(%ebp),%eax
    3c28:	0f b6 00             	movzbl (%eax),%eax
    3c2b:	0f b6 c0             	movzbl %al,%eax
    3c2e:	c1 e0 18             	shl    $0x18,%eax
    3c31:	89 c2                	mov    %eax,%edx
    3c33:	8b 45 08             	mov    0x8(%ebp),%eax
    3c36:	83 c0 01             	add    $0x1,%eax
    3c39:	0f b6 00             	movzbl (%eax),%eax
    3c3c:	0f b6 c0             	movzbl %al,%eax
    3c3f:	c1 e0 10             	shl    $0x10,%eax
    3c42:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    3c44:	8b 45 08             	mov    0x8(%ebp),%eax
    3c47:	83 c0 02             	add    $0x2,%eax
    3c4a:	0f b6 00             	movzbl (%eax),%eax
    3c4d:	0f b6 c0             	movzbl %al,%eax
    3c50:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3c53:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    3c55:	8b 45 08             	mov    0x8(%ebp),%eax
    3c58:	83 c0 03             	add    $0x3,%eax
    3c5b:	0f b6 00             	movzbl (%eax),%eax
    3c5e:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3c61:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    3c63:	5d                   	pop    %ebp
    3c64:	c3                   	ret    

00003c65 <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    3c65:	55                   	push   %ebp
    3c66:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    3c68:	8b 45 0c             	mov    0xc(%ebp),%eax
    3c6b:	c1 e8 18             	shr    $0x18,%eax
    3c6e:	89 c2                	mov    %eax,%edx
    3c70:	8b 45 08             	mov    0x8(%ebp),%eax
    3c73:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    3c75:	8b 45 08             	mov    0x8(%ebp),%eax
    3c78:	83 c0 01             	add    $0x1,%eax
    3c7b:	8b 55 0c             	mov    0xc(%ebp),%edx
    3c7e:	c1 ea 10             	shr    $0x10,%edx
    3c81:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    3c83:	8b 45 08             	mov    0x8(%ebp),%eax
    3c86:	83 c0 02             	add    $0x2,%eax
    3c89:	8b 55 0c             	mov    0xc(%ebp),%edx
    3c8c:	c1 ea 08             	shr    $0x8,%edx
    3c8f:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    3c91:	8b 45 08             	mov    0x8(%ebp),%eax
    3c94:	83 c0 03             	add    $0x3,%eax
    3c97:	8b 55 0c             	mov    0xc(%ebp),%edx
    3c9a:	88 10                	mov    %dl,(%eax)
}
    3c9c:	90                   	nop
    3c9d:	5d                   	pop    %ebp
    3c9e:	c3                   	ret    

00003c9f <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    3c9f:	55                   	push   %ebp
    3ca0:	89 e5                	mov    %esp,%ebp
    3ca2:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    3ca5:	83 ec 08             	sub    $0x8,%esp
    3ca8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    3cab:	50                   	push   %eax
    3cac:	ff 75 08             	pushl  0x8(%ebp)
    3caf:	e8 b7 ca ff ff       	call   76b <stat>
    3cb4:	83 c4 10             	add    $0x10,%esp
  return s.size;
    3cb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3cba:	c9                   	leave  
    3cbb:	c3                   	ret    

00003cbc <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    3cbc:	55                   	push   %ebp
    3cbd:	89 e5                	mov    %esp,%ebp
    3cbf:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    3cc2:	83 ec 08             	sub    $0x8,%esp
    3cc5:	6a 00                	push   $0x0
    3cc7:	ff 75 10             	pushl  0x10(%ebp)
    3cca:	e8 bb cb ff ff       	call   88a <open>
    3ccf:	83 c4 10             	add    $0x10,%esp
    3cd2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    3cd5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3cd9:	79 07                	jns    3ce2 <lodepng_buffer_file+0x26>
  {
      return -1;
    3cdb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    3ce0:	eb 19                	jmp    3cfb <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    3ce2:	83 ec 04             	sub    $0x4,%esp
    3ce5:	ff 75 0c             	pushl  0xc(%ebp)
    3ce8:	ff 75 08             	pushl  0x8(%ebp)
    3ceb:	ff 75 f4             	pushl  -0xc(%ebp)
    3cee:	e8 6f cb ff ff       	call   862 <read>
    3cf3:	83 c4 10             	add    $0x10,%esp
  return 0;
    3cf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3cfb:	c9                   	leave  
    3cfc:	c3                   	ret    

00003cfd <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    3cfd:	55                   	push   %ebp
    3cfe:	89 e5                	mov    %esp,%ebp
    3d00:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    3d03:	83 ec 0c             	sub    $0xc,%esp
    3d06:	ff 75 10             	pushl  0x10(%ebp)
    3d09:	e8 91 ff ff ff       	call   3c9f <lodepng_filesize>
    3d0e:	83 c4 10             	add    $0x10,%esp
    3d11:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    3d14:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3d18:	79 07                	jns    3d21 <lodepng_load_file+0x24>
    3d1a:	b8 4e 00 00 00       	mov    $0x4e,%eax
    3d1f:	eb 4a                	jmp    3d6b <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    3d21:	8b 45 0c             	mov    0xc(%ebp),%eax
    3d24:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3d27:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    3d29:	83 ec 0c             	sub    $0xc,%esp
    3d2c:	ff 75 f4             	pushl  -0xc(%ebp)
    3d2f:	e8 70 fb ff ff       	call   38a4 <lodepng_malloc>
    3d34:	83 c4 10             	add    $0x10,%esp
    3d37:	89 c2                	mov    %eax,%edx
    3d39:	8b 45 08             	mov    0x8(%ebp),%eax
    3d3c:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    3d3e:	8b 45 08             	mov    0x8(%ebp),%eax
    3d41:	8b 00                	mov    (%eax),%eax
    3d43:	85 c0                	test   %eax,%eax
    3d45:	75 0d                	jne    3d54 <lodepng_load_file+0x57>
    3d47:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3d4b:	7e 07                	jle    3d54 <lodepng_load_file+0x57>
    3d4d:	b8 53 00 00 00       	mov    $0x53,%eax
    3d52:	eb 17                	jmp    3d6b <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    3d54:	8b 45 08             	mov    0x8(%ebp),%eax
    3d57:	8b 00                	mov    (%eax),%eax
    3d59:	83 ec 04             	sub    $0x4,%esp
    3d5c:	ff 75 10             	pushl  0x10(%ebp)
    3d5f:	ff 75 f4             	pushl  -0xc(%ebp)
    3d62:	50                   	push   %eax
    3d63:	e8 54 ff ff ff       	call   3cbc <lodepng_buffer_file>
    3d68:	83 c4 10             	add    $0x10,%esp
}
    3d6b:	c9                   	leave  
    3d6c:	c3                   	ret    

00003d6d <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    3d6d:	55                   	push   %ebp
    3d6e:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    3d70:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3d75:	5d                   	pop    %ebp
    3d76:	c3                   	ret    

00003d77 <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    3d77:	55                   	push   %ebp
    3d78:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    3d7a:	8b 45 08             	mov    0x8(%ebp),%eax
    3d7d:	8b 55 0c             	mov    0xc(%ebp),%edx
    3d80:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    3d82:	8b 45 08             	mov    0x8(%ebp),%eax
    3d85:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    3d89:	90                   	nop
    3d8a:	5d                   	pop    %ebp
    3d8b:	c3                   	ret    

00003d8c <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3d8c:	55                   	push   %ebp
    3d8d:	89 e5                	mov    %esp,%ebp
    3d8f:	56                   	push   %esi
    3d90:	53                   	push   %ebx
    3d91:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    3d94:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    3d98:	0f 85 aa 00 00 00    	jne    3e48 <writeBits+0xbc>
    WRITEBIT(writer, value);
    3d9e:	8b 45 08             	mov    0x8(%ebp),%eax
    3da1:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3da5:	0f b6 c0             	movzbl %al,%eax
    3da8:	83 e0 07             	and    $0x7,%eax
    3dab:	85 c0                	test   %eax,%eax
    3dad:	75 39                	jne    3de8 <writeBits+0x5c>
    3daf:	8b 45 08             	mov    0x8(%ebp),%eax
    3db2:	8b 00                	mov    (%eax),%eax
    3db4:	8b 40 04             	mov    0x4(%eax),%eax
    3db7:	8d 50 01             	lea    0x1(%eax),%edx
    3dba:	8b 45 08             	mov    0x8(%ebp),%eax
    3dbd:	8b 00                	mov    (%eax),%eax
    3dbf:	52                   	push   %edx
    3dc0:	50                   	push   %eax
    3dc1:	e8 38 fd ff ff       	call   3afe <ucvector_resize>
    3dc6:	83 c4 08             	add    $0x8,%esp
    3dc9:	85 c0                	test   %eax,%eax
    3dcb:	0f 84 44 01 00 00    	je     3f15 <writeBits+0x189>
    3dd1:	8b 45 08             	mov    0x8(%ebp),%eax
    3dd4:	8b 00                	mov    (%eax),%eax
    3dd6:	8b 10                	mov    (%eax),%edx
    3dd8:	8b 45 08             	mov    0x8(%ebp),%eax
    3ddb:	8b 00                	mov    (%eax),%eax
    3ddd:	8b 40 04             	mov    0x4(%eax),%eax
    3de0:	83 e8 01             	sub    $0x1,%eax
    3de3:	01 d0                	add    %edx,%eax
    3de5:	c6 00 00             	movb   $0x0,(%eax)
    3de8:	8b 45 08             	mov    0x8(%ebp),%eax
    3deb:	8b 00                	mov    (%eax),%eax
    3ded:	8b 10                	mov    (%eax),%edx
    3def:	8b 45 08             	mov    0x8(%ebp),%eax
    3df2:	8b 00                	mov    (%eax),%eax
    3df4:	8b 40 04             	mov    0x4(%eax),%eax
    3df7:	83 e8 01             	sub    $0x1,%eax
    3dfa:	01 c2                	add    %eax,%edx
    3dfc:	8b 45 08             	mov    0x8(%ebp),%eax
    3dff:	8b 00                	mov    (%eax),%eax
    3e01:	8b 08                	mov    (%eax),%ecx
    3e03:	8b 45 08             	mov    0x8(%ebp),%eax
    3e06:	8b 00                	mov    (%eax),%eax
    3e08:	8b 40 04             	mov    0x4(%eax),%eax
    3e0b:	83 e8 01             	sub    $0x1,%eax
    3e0e:	01 c8                	add    %ecx,%eax
    3e10:	0f b6 00             	movzbl (%eax),%eax
    3e13:	88 45 e7             	mov    %al,-0x19(%ebp)
    3e16:	8b 45 08             	mov    0x8(%ebp),%eax
    3e19:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3e1d:	0f b6 c0             	movzbl %al,%eax
    3e20:	83 e0 07             	and    $0x7,%eax
    3e23:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3e26:	89 de                	mov    %ebx,%esi
    3e28:	89 c1                	mov    %eax,%ecx
    3e2a:	d3 e6                	shl    %cl,%esi
    3e2c:	89 f0                	mov    %esi,%eax
    3e2e:	0a 45 e7             	or     -0x19(%ebp),%al
    3e31:	88 02                	mov    %al,(%edx)
    3e33:	8b 45 08             	mov    0x8(%ebp),%eax
    3e36:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3e3a:	8d 50 01             	lea    0x1(%eax),%edx
    3e3d:	8b 45 08             	mov    0x8(%ebp),%eax
    3e40:	88 50 04             	mov    %dl,0x4(%eax)
    3e43:	e9 d1 00 00 00       	jmp    3f19 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3e48:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3e4f:	e9 b3 00 00 00       	jmp    3f07 <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3e54:	8b 45 08             	mov    0x8(%ebp),%eax
    3e57:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3e5b:	0f b6 c0             	movzbl %al,%eax
    3e5e:	83 e0 07             	and    $0x7,%eax
    3e61:	85 c0                	test   %eax,%eax
    3e63:	75 39                	jne    3e9e <writeBits+0x112>
    3e65:	8b 45 08             	mov    0x8(%ebp),%eax
    3e68:	8b 00                	mov    (%eax),%eax
    3e6a:	8b 40 04             	mov    0x4(%eax),%eax
    3e6d:	8d 50 01             	lea    0x1(%eax),%edx
    3e70:	8b 45 08             	mov    0x8(%ebp),%eax
    3e73:	8b 00                	mov    (%eax),%eax
    3e75:	52                   	push   %edx
    3e76:	50                   	push   %eax
    3e77:	e8 82 fc ff ff       	call   3afe <ucvector_resize>
    3e7c:	83 c4 08             	add    $0x8,%esp
    3e7f:	85 c0                	test   %eax,%eax
    3e81:	0f 84 91 00 00 00    	je     3f18 <writeBits+0x18c>
    3e87:	8b 45 08             	mov    0x8(%ebp),%eax
    3e8a:	8b 00                	mov    (%eax),%eax
    3e8c:	8b 10                	mov    (%eax),%edx
    3e8e:	8b 45 08             	mov    0x8(%ebp),%eax
    3e91:	8b 00                	mov    (%eax),%eax
    3e93:	8b 40 04             	mov    0x4(%eax),%eax
    3e96:	83 e8 01             	sub    $0x1,%eax
    3e99:	01 d0                	add    %edx,%eax
    3e9b:	c6 00 00             	movb   $0x0,(%eax)
    3e9e:	8b 45 08             	mov    0x8(%ebp),%eax
    3ea1:	8b 00                	mov    (%eax),%eax
    3ea3:	8b 10                	mov    (%eax),%edx
    3ea5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ea8:	8b 00                	mov    (%eax),%eax
    3eaa:	8b 40 04             	mov    0x4(%eax),%eax
    3ead:	83 e8 01             	sub    $0x1,%eax
    3eb0:	01 c2                	add    %eax,%edx
    3eb2:	8b 45 08             	mov    0x8(%ebp),%eax
    3eb5:	8b 00                	mov    (%eax),%eax
    3eb7:	8b 08                	mov    (%eax),%ecx
    3eb9:	8b 45 08             	mov    0x8(%ebp),%eax
    3ebc:	8b 00                	mov    (%eax),%eax
    3ebe:	8b 40 04             	mov    0x4(%eax),%eax
    3ec1:	83 e8 01             	sub    $0x1,%eax
    3ec4:	01 c8                	add    %ecx,%eax
    3ec6:	0f b6 00             	movzbl (%eax),%eax
    3ec9:	89 c6                	mov    %eax,%esi
    3ecb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3ece:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3ed1:	89 c1                	mov    %eax,%ecx
    3ed3:	d3 eb                	shr    %cl,%ebx
    3ed5:	89 d8                	mov    %ebx,%eax
    3ed7:	83 e0 01             	and    $0x1,%eax
    3eda:	89 c3                	mov    %eax,%ebx
    3edc:	8b 45 08             	mov    0x8(%ebp),%eax
    3edf:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3ee3:	0f b6 c0             	movzbl %al,%eax
    3ee6:	83 e0 07             	and    $0x7,%eax
    3ee9:	89 c1                	mov    %eax,%ecx
    3eeb:	d3 e3                	shl    %cl,%ebx
    3eed:	89 d8                	mov    %ebx,%eax
    3eef:	09 f0                	or     %esi,%eax
    3ef1:	88 02                	mov    %al,(%edx)
    3ef3:	8b 45 08             	mov    0x8(%ebp),%eax
    3ef6:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3efa:	8d 50 01             	lea    0x1(%eax),%edx
    3efd:	8b 45 08             	mov    0x8(%ebp),%eax
    3f00:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3f03:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3f07:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3f0a:	3b 45 10             	cmp    0x10(%ebp),%eax
    3f0d:	0f 85 41 ff ff ff    	jne    3e54 <writeBits+0xc8>
    3f13:	eb 04                	jmp    3f19 <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    3f15:	90                   	nop
    3f16:	eb 01                	jmp    3f19 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3f18:	90                   	nop
    }
  }
}
    3f19:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3f1c:	5b                   	pop    %ebx
    3f1d:	5e                   	pop    %esi
    3f1e:	5d                   	pop    %ebp
    3f1f:	c3                   	ret    

00003f20 <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3f20:	55                   	push   %ebp
    3f21:	89 e5                	mov    %esp,%ebp
    3f23:	56                   	push   %esi
    3f24:	53                   	push   %ebx
    3f25:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3f28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3f2f:	e9 bd 00 00 00       	jmp    3ff1 <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3f34:	8b 45 08             	mov    0x8(%ebp),%eax
    3f37:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3f3b:	0f b6 c0             	movzbl %al,%eax
    3f3e:	83 e0 07             	and    $0x7,%eax
    3f41:	85 c0                	test   %eax,%eax
    3f43:	75 39                	jne    3f7e <writeBitsReversed+0x5e>
    3f45:	8b 45 08             	mov    0x8(%ebp),%eax
    3f48:	8b 00                	mov    (%eax),%eax
    3f4a:	8b 40 04             	mov    0x4(%eax),%eax
    3f4d:	8d 50 01             	lea    0x1(%eax),%edx
    3f50:	8b 45 08             	mov    0x8(%ebp),%eax
    3f53:	8b 00                	mov    (%eax),%eax
    3f55:	52                   	push   %edx
    3f56:	50                   	push   %eax
    3f57:	e8 a2 fb ff ff       	call   3afe <ucvector_resize>
    3f5c:	83 c4 08             	add    $0x8,%esp
    3f5f:	85 c0                	test   %eax,%eax
    3f61:	0f 84 98 00 00 00    	je     3fff <writeBitsReversed+0xdf>
    3f67:	8b 45 08             	mov    0x8(%ebp),%eax
    3f6a:	8b 00                	mov    (%eax),%eax
    3f6c:	8b 10                	mov    (%eax),%edx
    3f6e:	8b 45 08             	mov    0x8(%ebp),%eax
    3f71:	8b 00                	mov    (%eax),%eax
    3f73:	8b 40 04             	mov    0x4(%eax),%eax
    3f76:	83 e8 01             	sub    $0x1,%eax
    3f79:	01 d0                	add    %edx,%eax
    3f7b:	c6 00 00             	movb   $0x0,(%eax)
    3f7e:	8b 45 08             	mov    0x8(%ebp),%eax
    3f81:	8b 00                	mov    (%eax),%eax
    3f83:	8b 10                	mov    (%eax),%edx
    3f85:	8b 45 08             	mov    0x8(%ebp),%eax
    3f88:	8b 00                	mov    (%eax),%eax
    3f8a:	8b 40 04             	mov    0x4(%eax),%eax
    3f8d:	83 e8 01             	sub    $0x1,%eax
    3f90:	01 c2                	add    %eax,%edx
    3f92:	8b 45 08             	mov    0x8(%ebp),%eax
    3f95:	8b 00                	mov    (%eax),%eax
    3f97:	8b 08                	mov    (%eax),%ecx
    3f99:	8b 45 08             	mov    0x8(%ebp),%eax
    3f9c:	8b 00                	mov    (%eax),%eax
    3f9e:	8b 40 04             	mov    0x4(%eax),%eax
    3fa1:	83 e8 01             	sub    $0x1,%eax
    3fa4:	01 c8                	add    %ecx,%eax
    3fa6:	0f b6 00             	movzbl (%eax),%eax
    3fa9:	89 c6                	mov    %eax,%esi
    3fab:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3fae:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3fb1:	29 c1                	sub    %eax,%ecx
    3fb3:	89 c8                	mov    %ecx,%eax
    3fb5:	83 e8 01             	sub    $0x1,%eax
    3fb8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3fbb:	89 c1                	mov    %eax,%ecx
    3fbd:	d3 eb                	shr    %cl,%ebx
    3fbf:	89 d8                	mov    %ebx,%eax
    3fc1:	83 e0 01             	and    $0x1,%eax
    3fc4:	89 c3                	mov    %eax,%ebx
    3fc6:	8b 45 08             	mov    0x8(%ebp),%eax
    3fc9:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3fcd:	0f b6 c0             	movzbl %al,%eax
    3fd0:	83 e0 07             	and    $0x7,%eax
    3fd3:	89 c1                	mov    %eax,%ecx
    3fd5:	d3 e3                	shl    %cl,%ebx
    3fd7:	89 d8                	mov    %ebx,%eax
    3fd9:	09 f0                	or     %esi,%eax
    3fdb:	88 02                	mov    %al,(%edx)
    3fdd:	8b 45 08             	mov    0x8(%ebp),%eax
    3fe0:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3fe4:	8d 50 01             	lea    0x1(%eax),%edx
    3fe7:	8b 45 08             	mov    0x8(%ebp),%eax
    3fea:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3fed:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3ff1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3ff4:	3b 45 10             	cmp    0x10(%ebp),%eax
    3ff7:	0f 85 37 ff ff ff    	jne    3f34 <writeBitsReversed+0x14>
    3ffd:	eb 01                	jmp    4000 <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3fff:	90                   	nop
  }
}
    4000:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4003:	5b                   	pop    %ebx
    4004:	5e                   	pop    %esi
    4005:	5d                   	pop    %ebp
    4006:	c3                   	ret    

00004007 <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    4007:	55                   	push   %ebp
    4008:	89 e5                	mov    %esp,%ebp
    400a:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    400d:	8b 45 08             	mov    0x8(%ebp),%eax
    4010:	8b 55 0c             	mov    0xc(%ebp),%edx
    4013:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    4015:	8b 45 08             	mov    0x8(%ebp),%eax
    4018:	8b 55 10             	mov    0x10(%ebp),%edx
    401b:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    401e:	8b 45 08             	mov    0x8(%ebp),%eax
    4021:	83 c0 08             	add    $0x8,%eax
    4024:	50                   	push   %eax
    4025:	6a 08                	push   $0x8
    4027:	ff 75 10             	pushl  0x10(%ebp)
    402a:	e8 59 f9 ff ff       	call   3988 <lodepng_mulofl>
    402f:	83 c4 0c             	add    $0xc,%esp
    4032:	85 c0                	test   %eax,%eax
    4034:	74 07                	je     403d <LodePNGBitReader_init+0x36>
    4036:	b8 69 00 00 00       	mov    $0x69,%eax
    403b:	eb 39                	jmp    4076 <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    403d:	8b 45 08             	mov    0x8(%ebp),%eax
    4040:	8b 40 08             	mov    0x8(%eax),%eax
    4043:	8d 55 fc             	lea    -0x4(%ebp),%edx
    4046:	52                   	push   %edx
    4047:	6a 40                	push   $0x40
    4049:	50                   	push   %eax
    404a:	e8 19 f9 ff ff       	call   3968 <lodepng_addofl>
    404f:	83 c4 0c             	add    $0xc,%esp
    4052:	85 c0                	test   %eax,%eax
    4054:	74 07                	je     405d <LodePNGBitReader_init+0x56>
    4056:	b8 69 00 00 00       	mov    $0x69,%eax
    405b:	eb 19                	jmp    4076 <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    405d:	8b 45 08             	mov    0x8(%ebp),%eax
    4060:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    4067:	8b 45 08             	mov    0x8(%ebp),%eax
    406a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    4071:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4076:	c9                   	leave  
    4077:	c3                   	ret    

00004078 <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    4078:	55                   	push   %ebp
    4079:	89 e5                	mov    %esp,%ebp
    407b:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    407e:	8b 45 08             	mov    0x8(%ebp),%eax
    4081:	8b 40 0c             	mov    0xc(%eax),%eax
    4084:	c1 f8 03             	sar    $0x3,%eax
    4087:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    408a:	8b 45 08             	mov    0x8(%ebp),%eax
    408d:	8b 40 04             	mov    0x4(%eax),%eax
    4090:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    4093:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4096:	8d 50 01             	lea    0x1(%eax),%edx
    4099:	8b 45 f8             	mov    -0x8(%ebp),%eax
    409c:	39 c2                	cmp    %eax,%edx
    409e:	73 4e                	jae    40ee <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    40a0:	8b 45 08             	mov    0x8(%ebp),%eax
    40a3:	8b 10                	mov    (%eax),%edx
    40a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    40a8:	01 d0                	add    %edx,%eax
    40aa:	0f b6 00             	movzbl (%eax),%eax
    40ad:	0f b6 d0             	movzbl %al,%edx
    40b0:	8b 45 08             	mov    0x8(%ebp),%eax
    40b3:	8b 00                	mov    (%eax),%eax
    40b5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    40b8:	83 c1 01             	add    $0x1,%ecx
    40bb:	01 c8                	add    %ecx,%eax
    40bd:	0f b6 00             	movzbl (%eax),%eax
    40c0:	0f b6 c0             	movzbl %al,%eax
    40c3:	c1 e0 08             	shl    $0x8,%eax
    40c6:	09 c2                	or     %eax,%edx
    40c8:	8b 45 08             	mov    0x8(%ebp),%eax
    40cb:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    40ce:	8b 45 08             	mov    0x8(%ebp),%eax
    40d1:	8b 50 10             	mov    0x10(%eax),%edx
    40d4:	8b 45 08             	mov    0x8(%ebp),%eax
    40d7:	8b 40 0c             	mov    0xc(%eax),%eax
    40da:	83 e0 07             	and    $0x7,%eax
    40dd:	89 c1                	mov    %eax,%ecx
    40df:	d3 ea                	shr    %cl,%edx
    40e1:	8b 45 08             	mov    0x8(%ebp),%eax
    40e4:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    40e7:	b8 01 00 00 00       	mov    $0x1,%eax
    40ec:	eb 64                	jmp    4152 <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    40ee:	8b 45 08             	mov    0x8(%ebp),%eax
    40f1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    40f8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    40fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    40fe:	39 c2                	cmp    %eax,%edx
    4100:	73 1e                	jae    4120 <ensureBits9+0xa8>
    4102:	8b 45 08             	mov    0x8(%ebp),%eax
    4105:	8b 50 10             	mov    0x10(%eax),%edx
    4108:	8b 45 08             	mov    0x8(%ebp),%eax
    410b:	8b 08                	mov    (%eax),%ecx
    410d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4110:	01 c8                	add    %ecx,%eax
    4112:	0f b6 00             	movzbl (%eax),%eax
    4115:	0f b6 c0             	movzbl %al,%eax
    4118:	09 c2                	or     %eax,%edx
    411a:	8b 45 08             	mov    0x8(%ebp),%eax
    411d:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4120:	8b 45 08             	mov    0x8(%ebp),%eax
    4123:	8b 50 10             	mov    0x10(%eax),%edx
    4126:	8b 45 08             	mov    0x8(%ebp),%eax
    4129:	8b 40 0c             	mov    0xc(%eax),%eax
    412c:	83 e0 07             	and    $0x7,%eax
    412f:	89 c1                	mov    %eax,%ecx
    4131:	d3 ea                	shr    %cl,%edx
    4133:	8b 45 08             	mov    0x8(%ebp),%eax
    4136:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4139:	8b 45 08             	mov    0x8(%ebp),%eax
    413c:	8b 50 0c             	mov    0xc(%eax),%edx
    413f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4142:	01 c2                	add    %eax,%edx
    4144:	8b 45 08             	mov    0x8(%ebp),%eax
    4147:	8b 40 08             	mov    0x8(%eax),%eax
    414a:	39 c2                	cmp    %eax,%edx
    414c:	0f 9e c0             	setle  %al
    414f:	0f b6 c0             	movzbl %al,%eax
  }
}
    4152:	c9                   	leave  
    4153:	c3                   	ret    

00004154 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    4154:	55                   	push   %ebp
    4155:	89 e5                	mov    %esp,%ebp
    4157:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    415a:	8b 45 08             	mov    0x8(%ebp),%eax
    415d:	8b 40 0c             	mov    0xc(%eax),%eax
    4160:	c1 f8 03             	sar    $0x3,%eax
    4163:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    4166:	8b 45 08             	mov    0x8(%ebp),%eax
    4169:	8b 40 04             	mov    0x4(%eax),%eax
    416c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    416f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4172:	8d 50 02             	lea    0x2(%eax),%edx
    4175:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4178:	39 c2                	cmp    %eax,%edx
    417a:	73 6d                	jae    41e9 <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    417c:	8b 45 08             	mov    0x8(%ebp),%eax
    417f:	8b 10                	mov    (%eax),%edx
    4181:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4184:	01 d0                	add    %edx,%eax
    4186:	0f b6 00             	movzbl (%eax),%eax
    4189:	0f b6 d0             	movzbl %al,%edx
    418c:	8b 45 08             	mov    0x8(%ebp),%eax
    418f:	8b 00                	mov    (%eax),%eax
    4191:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4194:	83 c1 01             	add    $0x1,%ecx
    4197:	01 c8                	add    %ecx,%eax
    4199:	0f b6 00             	movzbl (%eax),%eax
    419c:	0f b6 c0             	movzbl %al,%eax
    419f:	c1 e0 08             	shl    $0x8,%eax
    41a2:	89 d1                	mov    %edx,%ecx
    41a4:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    41a6:	8b 45 08             	mov    0x8(%ebp),%eax
    41a9:	8b 00                	mov    (%eax),%eax
    41ab:	8b 55 fc             	mov    -0x4(%ebp),%edx
    41ae:	83 c2 02             	add    $0x2,%edx
    41b1:	01 d0                	add    %edx,%eax
    41b3:	0f b6 00             	movzbl (%eax),%eax
    41b6:	0f b6 c0             	movzbl %al,%eax
    41b9:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    41bc:	09 c1                	or     %eax,%ecx
    41be:	89 ca                	mov    %ecx,%edx
    41c0:	8b 45 08             	mov    0x8(%ebp),%eax
    41c3:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    41c6:	8b 45 08             	mov    0x8(%ebp),%eax
    41c9:	8b 50 10             	mov    0x10(%eax),%edx
    41cc:	8b 45 08             	mov    0x8(%ebp),%eax
    41cf:	8b 40 0c             	mov    0xc(%eax),%eax
    41d2:	83 e0 07             	and    $0x7,%eax
    41d5:	89 c1                	mov    %eax,%ecx
    41d7:	d3 ea                	shr    %cl,%edx
    41d9:	8b 45 08             	mov    0x8(%ebp),%eax
    41dc:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    41df:	b8 01 00 00 00       	mov    $0x1,%eax
    41e4:	e9 95 00 00 00       	jmp    427e <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    41e9:	8b 45 08             	mov    0x8(%ebp),%eax
    41ec:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    41f3:	8b 55 fc             	mov    -0x4(%ebp),%edx
    41f6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    41f9:	39 c2                	cmp    %eax,%edx
    41fb:	73 1e                	jae    421b <ensureBits17+0xc7>
    41fd:	8b 45 08             	mov    0x8(%ebp),%eax
    4200:	8b 50 10             	mov    0x10(%eax),%edx
    4203:	8b 45 08             	mov    0x8(%ebp),%eax
    4206:	8b 08                	mov    (%eax),%ecx
    4208:	8b 45 fc             	mov    -0x4(%ebp),%eax
    420b:	01 c8                	add    %ecx,%eax
    420d:	0f b6 00             	movzbl (%eax),%eax
    4210:	0f b6 c0             	movzbl %al,%eax
    4213:	09 c2                	or     %eax,%edx
    4215:	8b 45 08             	mov    0x8(%ebp),%eax
    4218:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    421b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    421e:	8d 50 01             	lea    0x1(%eax),%edx
    4221:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4224:	39 c2                	cmp    %eax,%edx
    4226:	73 24                	jae    424c <ensureBits17+0xf8>
    4228:	8b 45 08             	mov    0x8(%ebp),%eax
    422b:	8b 50 10             	mov    0x10(%eax),%edx
    422e:	8b 45 08             	mov    0x8(%ebp),%eax
    4231:	8b 00                	mov    (%eax),%eax
    4233:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4236:	83 c1 01             	add    $0x1,%ecx
    4239:	01 c8                	add    %ecx,%eax
    423b:	0f b6 00             	movzbl (%eax),%eax
    423e:	0f b6 c0             	movzbl %al,%eax
    4241:	c1 e0 08             	shl    $0x8,%eax
    4244:	09 c2                	or     %eax,%edx
    4246:	8b 45 08             	mov    0x8(%ebp),%eax
    4249:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    424c:	8b 45 08             	mov    0x8(%ebp),%eax
    424f:	8b 50 10             	mov    0x10(%eax),%edx
    4252:	8b 45 08             	mov    0x8(%ebp),%eax
    4255:	8b 40 0c             	mov    0xc(%eax),%eax
    4258:	83 e0 07             	and    $0x7,%eax
    425b:	89 c1                	mov    %eax,%ecx
    425d:	d3 ea                	shr    %cl,%edx
    425f:	8b 45 08             	mov    0x8(%ebp),%eax
    4262:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4265:	8b 45 08             	mov    0x8(%ebp),%eax
    4268:	8b 50 0c             	mov    0xc(%eax),%edx
    426b:	8b 45 0c             	mov    0xc(%ebp),%eax
    426e:	01 c2                	add    %eax,%edx
    4270:	8b 45 08             	mov    0x8(%ebp),%eax
    4273:	8b 40 08             	mov    0x8(%eax),%eax
    4276:	39 c2                	cmp    %eax,%edx
    4278:	0f 9e c0             	setle  %al
    427b:	0f b6 c0             	movzbl %al,%eax
  }
}
    427e:	c9                   	leave  
    427f:	c3                   	ret    

00004280 <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    4280:	55                   	push   %ebp
    4281:	89 e5                	mov    %esp,%ebp
    4283:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4286:	8b 45 08             	mov    0x8(%ebp),%eax
    4289:	8b 40 0c             	mov    0xc(%eax),%eax
    428c:	c1 f8 03             	sar    $0x3,%eax
    428f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    4292:	8b 45 08             	mov    0x8(%ebp),%eax
    4295:	8b 40 04             	mov    0x4(%eax),%eax
    4298:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    429b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    429e:	8d 50 03             	lea    0x3(%eax),%edx
    42a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    42a4:	39 c2                	cmp    %eax,%edx
    42a6:	0f 83 85 00 00 00    	jae    4331 <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    42ac:	8b 45 08             	mov    0x8(%ebp),%eax
    42af:	8b 10                	mov    (%eax),%edx
    42b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    42b4:	01 d0                	add    %edx,%eax
    42b6:	0f b6 00             	movzbl (%eax),%eax
    42b9:	0f b6 d0             	movzbl %al,%edx
    42bc:	8b 45 08             	mov    0x8(%ebp),%eax
    42bf:	8b 00                	mov    (%eax),%eax
    42c1:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    42c4:	83 c1 01             	add    $0x1,%ecx
    42c7:	01 c8                	add    %ecx,%eax
    42c9:	0f b6 00             	movzbl (%eax),%eax
    42cc:	0f b6 c0             	movzbl %al,%eax
    42cf:	c1 e0 08             	shl    $0x8,%eax
    42d2:	89 d1                	mov    %edx,%ecx
    42d4:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    42d6:	8b 45 08             	mov    0x8(%ebp),%eax
    42d9:	8b 00                	mov    (%eax),%eax
    42db:	8b 55 fc             	mov    -0x4(%ebp),%edx
    42de:	83 c2 02             	add    $0x2,%edx
    42e1:	01 d0                	add    %edx,%eax
    42e3:	0f b6 00             	movzbl (%eax),%eax
    42e6:	0f b6 c0             	movzbl %al,%eax
    42e9:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    42ec:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    42ee:	8b 45 08             	mov    0x8(%ebp),%eax
    42f1:	8b 00                	mov    (%eax),%eax
    42f3:	8b 55 fc             	mov    -0x4(%ebp),%edx
    42f6:	83 c2 03             	add    $0x3,%edx
    42f9:	01 d0                	add    %edx,%eax
    42fb:	0f b6 00             	movzbl (%eax),%eax
    42fe:	0f b6 c0             	movzbl %al,%eax
    4301:	c1 e0 18             	shl    $0x18,%eax
    4304:	09 c1                	or     %eax,%ecx
    4306:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4308:	8b 45 08             	mov    0x8(%ebp),%eax
    430b:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    430e:	8b 45 08             	mov    0x8(%ebp),%eax
    4311:	8b 50 10             	mov    0x10(%eax),%edx
    4314:	8b 45 08             	mov    0x8(%ebp),%eax
    4317:	8b 40 0c             	mov    0xc(%eax),%eax
    431a:	83 e0 07             	and    $0x7,%eax
    431d:	89 c1                	mov    %eax,%ecx
    431f:	d3 ea                	shr    %cl,%edx
    4321:	8b 45 08             	mov    0x8(%ebp),%eax
    4324:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    4327:	b8 01 00 00 00       	mov    $0x1,%eax
    432c:	e9 c6 00 00 00       	jmp    43f7 <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    4331:	8b 45 08             	mov    0x8(%ebp),%eax
    4334:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    433b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    433e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4341:	39 c2                	cmp    %eax,%edx
    4343:	73 1e                	jae    4363 <ensureBits25+0xe3>
    4345:	8b 45 08             	mov    0x8(%ebp),%eax
    4348:	8b 50 10             	mov    0x10(%eax),%edx
    434b:	8b 45 08             	mov    0x8(%ebp),%eax
    434e:	8b 08                	mov    (%eax),%ecx
    4350:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4353:	01 c8                	add    %ecx,%eax
    4355:	0f b6 00             	movzbl (%eax),%eax
    4358:	0f b6 c0             	movzbl %al,%eax
    435b:	09 c2                	or     %eax,%edx
    435d:	8b 45 08             	mov    0x8(%ebp),%eax
    4360:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    4363:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4366:	8d 50 01             	lea    0x1(%eax),%edx
    4369:	8b 45 f8             	mov    -0x8(%ebp),%eax
    436c:	39 c2                	cmp    %eax,%edx
    436e:	73 24                	jae    4394 <ensureBits25+0x114>
    4370:	8b 45 08             	mov    0x8(%ebp),%eax
    4373:	8b 50 10             	mov    0x10(%eax),%edx
    4376:	8b 45 08             	mov    0x8(%ebp),%eax
    4379:	8b 00                	mov    (%eax),%eax
    437b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    437e:	83 c1 01             	add    $0x1,%ecx
    4381:	01 c8                	add    %ecx,%eax
    4383:	0f b6 00             	movzbl (%eax),%eax
    4386:	0f b6 c0             	movzbl %al,%eax
    4389:	c1 e0 08             	shl    $0x8,%eax
    438c:	09 c2                	or     %eax,%edx
    438e:	8b 45 08             	mov    0x8(%ebp),%eax
    4391:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    4394:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4397:	8d 50 02             	lea    0x2(%eax),%edx
    439a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    439d:	39 c2                	cmp    %eax,%edx
    439f:	73 24                	jae    43c5 <ensureBits25+0x145>
    43a1:	8b 45 08             	mov    0x8(%ebp),%eax
    43a4:	8b 50 10             	mov    0x10(%eax),%edx
    43a7:	8b 45 08             	mov    0x8(%ebp),%eax
    43aa:	8b 00                	mov    (%eax),%eax
    43ac:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    43af:	83 c1 02             	add    $0x2,%ecx
    43b2:	01 c8                	add    %ecx,%eax
    43b4:	0f b6 00             	movzbl (%eax),%eax
    43b7:	0f b6 c0             	movzbl %al,%eax
    43ba:	c1 e0 10             	shl    $0x10,%eax
    43bd:	09 c2                	or     %eax,%edx
    43bf:	8b 45 08             	mov    0x8(%ebp),%eax
    43c2:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    43c5:	8b 45 08             	mov    0x8(%ebp),%eax
    43c8:	8b 50 10             	mov    0x10(%eax),%edx
    43cb:	8b 45 08             	mov    0x8(%ebp),%eax
    43ce:	8b 40 0c             	mov    0xc(%eax),%eax
    43d1:	83 e0 07             	and    $0x7,%eax
    43d4:	89 c1                	mov    %eax,%ecx
    43d6:	d3 ea                	shr    %cl,%edx
    43d8:	8b 45 08             	mov    0x8(%ebp),%eax
    43db:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    43de:	8b 45 08             	mov    0x8(%ebp),%eax
    43e1:	8b 50 0c             	mov    0xc(%eax),%edx
    43e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    43e7:	01 c2                	add    %eax,%edx
    43e9:	8b 45 08             	mov    0x8(%ebp),%eax
    43ec:	8b 40 08             	mov    0x8(%eax),%eax
    43ef:	39 c2                	cmp    %eax,%edx
    43f1:	0f 9e c0             	setle  %al
    43f4:	0f b6 c0             	movzbl %al,%eax
  }
}
    43f7:	c9                   	leave  
    43f8:	c3                   	ret    

000043f9 <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    43f9:	55                   	push   %ebp
    43fa:	89 e5                	mov    %esp,%ebp
    43fc:	53                   	push   %ebx
    43fd:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4400:	8b 45 08             	mov    0x8(%ebp),%eax
    4403:	8b 40 0c             	mov    0xc(%eax),%eax
    4406:	c1 f8 03             	sar    $0x3,%eax
    4409:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    440c:	8b 45 08             	mov    0x8(%ebp),%eax
    440f:	8b 40 04             	mov    0x4(%eax),%eax
    4412:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    4415:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4418:	8d 50 04             	lea    0x4(%eax),%edx
    441b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    441e:	39 c2                	cmp    %eax,%edx
    4420:	0f 83 c3 00 00 00    	jae    44e9 <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4426:	8b 45 08             	mov    0x8(%ebp),%eax
    4429:	8b 10                	mov    (%eax),%edx
    442b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    442e:	01 d0                	add    %edx,%eax
    4430:	0f b6 00             	movzbl (%eax),%eax
    4433:	0f b6 d0             	movzbl %al,%edx
    4436:	8b 45 08             	mov    0x8(%ebp),%eax
    4439:	8b 00                	mov    (%eax),%eax
    443b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    443e:	83 c1 01             	add    $0x1,%ecx
    4441:	01 c8                	add    %ecx,%eax
    4443:	0f b6 00             	movzbl (%eax),%eax
    4446:	0f b6 c0             	movzbl %al,%eax
    4449:	c1 e0 08             	shl    $0x8,%eax
    444c:	89 d1                	mov    %edx,%ecx
    444e:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4450:	8b 45 08             	mov    0x8(%ebp),%eax
    4453:	8b 00                	mov    (%eax),%eax
    4455:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4458:	83 c2 02             	add    $0x2,%edx
    445b:	01 d0                	add    %edx,%eax
    445d:	0f b6 00             	movzbl (%eax),%eax
    4460:	0f b6 c0             	movzbl %al,%eax
    4463:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4466:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4468:	8b 45 08             	mov    0x8(%ebp),%eax
    446b:	8b 00                	mov    (%eax),%eax
    446d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4470:	83 c2 03             	add    $0x3,%edx
    4473:	01 d0                	add    %edx,%eax
    4475:	0f b6 00             	movzbl (%eax),%eax
    4478:	0f b6 c0             	movzbl %al,%eax
    447b:	c1 e0 18             	shl    $0x18,%eax
    447e:	09 c1                	or     %eax,%ecx
    4480:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4482:	8b 45 08             	mov    0x8(%ebp),%eax
    4485:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    4488:	8b 45 08             	mov    0x8(%ebp),%eax
    448b:	8b 50 10             	mov    0x10(%eax),%edx
    448e:	8b 45 08             	mov    0x8(%ebp),%eax
    4491:	8b 40 0c             	mov    0xc(%eax),%eax
    4494:	83 e0 07             	and    $0x7,%eax
    4497:	89 c1                	mov    %eax,%ecx
    4499:	d3 ea                	shr    %cl,%edx
    449b:	8b 45 08             	mov    0x8(%ebp),%eax
    449e:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    44a1:	8b 45 08             	mov    0x8(%ebp),%eax
    44a4:	8b 50 10             	mov    0x10(%eax),%edx
    44a7:	8b 45 08             	mov    0x8(%ebp),%eax
    44aa:	8b 00                	mov    (%eax),%eax
    44ac:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    44af:	83 c1 04             	add    $0x4,%ecx
    44b2:	01 c8                	add    %ecx,%eax
    44b4:	0f b6 00             	movzbl (%eax),%eax
    44b7:	0f b6 c0             	movzbl %al,%eax
    44ba:	c1 e0 18             	shl    $0x18,%eax
    44bd:	89 c3                	mov    %eax,%ebx
    44bf:	8b 45 08             	mov    0x8(%ebp),%eax
    44c2:	8b 40 0c             	mov    0xc(%eax),%eax
    44c5:	83 e0 07             	and    $0x7,%eax
    44c8:	b9 08 00 00 00       	mov    $0x8,%ecx
    44cd:	29 c1                	sub    %eax,%ecx
    44cf:	89 c8                	mov    %ecx,%eax
    44d1:	89 c1                	mov    %eax,%ecx
    44d3:	d3 e3                	shl    %cl,%ebx
    44d5:	89 d8                	mov    %ebx,%eax
    44d7:	09 c2                	or     %eax,%edx
    44d9:	8b 45 08             	mov    0x8(%ebp),%eax
    44dc:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    44df:	b8 01 00 00 00       	mov    $0x1,%eax
    44e4:	e9 f7 00 00 00       	jmp    45e0 <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    44e9:	8b 45 08             	mov    0x8(%ebp),%eax
    44ec:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    44f3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    44f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    44f9:	39 c2                	cmp    %eax,%edx
    44fb:	73 1e                	jae    451b <ensureBits32+0x122>
    44fd:	8b 45 08             	mov    0x8(%ebp),%eax
    4500:	8b 50 10             	mov    0x10(%eax),%edx
    4503:	8b 45 08             	mov    0x8(%ebp),%eax
    4506:	8b 08                	mov    (%eax),%ecx
    4508:	8b 45 f8             	mov    -0x8(%ebp),%eax
    450b:	01 c8                	add    %ecx,%eax
    450d:	0f b6 00             	movzbl (%eax),%eax
    4510:	0f b6 c0             	movzbl %al,%eax
    4513:	09 c2                	or     %eax,%edx
    4515:	8b 45 08             	mov    0x8(%ebp),%eax
    4518:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    451b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    451e:	8d 50 01             	lea    0x1(%eax),%edx
    4521:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4524:	39 c2                	cmp    %eax,%edx
    4526:	73 24                	jae    454c <ensureBits32+0x153>
    4528:	8b 45 08             	mov    0x8(%ebp),%eax
    452b:	8b 50 10             	mov    0x10(%eax),%edx
    452e:	8b 45 08             	mov    0x8(%ebp),%eax
    4531:	8b 00                	mov    (%eax),%eax
    4533:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4536:	83 c1 01             	add    $0x1,%ecx
    4539:	01 c8                	add    %ecx,%eax
    453b:	0f b6 00             	movzbl (%eax),%eax
    453e:	0f b6 c0             	movzbl %al,%eax
    4541:	c1 e0 08             	shl    $0x8,%eax
    4544:	09 c2                	or     %eax,%edx
    4546:	8b 45 08             	mov    0x8(%ebp),%eax
    4549:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    454c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    454f:	8d 50 02             	lea    0x2(%eax),%edx
    4552:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4555:	39 c2                	cmp    %eax,%edx
    4557:	73 24                	jae    457d <ensureBits32+0x184>
    4559:	8b 45 08             	mov    0x8(%ebp),%eax
    455c:	8b 50 10             	mov    0x10(%eax),%edx
    455f:	8b 45 08             	mov    0x8(%ebp),%eax
    4562:	8b 00                	mov    (%eax),%eax
    4564:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4567:	83 c1 02             	add    $0x2,%ecx
    456a:	01 c8                	add    %ecx,%eax
    456c:	0f b6 00             	movzbl (%eax),%eax
    456f:	0f b6 c0             	movzbl %al,%eax
    4572:	c1 e0 10             	shl    $0x10,%eax
    4575:	09 c2                	or     %eax,%edx
    4577:	8b 45 08             	mov    0x8(%ebp),%eax
    457a:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    457d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4580:	8d 50 03             	lea    0x3(%eax),%edx
    4583:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4586:	39 c2                	cmp    %eax,%edx
    4588:	73 24                	jae    45ae <ensureBits32+0x1b5>
    458a:	8b 45 08             	mov    0x8(%ebp),%eax
    458d:	8b 50 10             	mov    0x10(%eax),%edx
    4590:	8b 45 08             	mov    0x8(%ebp),%eax
    4593:	8b 00                	mov    (%eax),%eax
    4595:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4598:	83 c1 03             	add    $0x3,%ecx
    459b:	01 c8                	add    %ecx,%eax
    459d:	0f b6 00             	movzbl (%eax),%eax
    45a0:	0f b6 c0             	movzbl %al,%eax
    45a3:	c1 e0 18             	shl    $0x18,%eax
    45a6:	09 c2                	or     %eax,%edx
    45a8:	8b 45 08             	mov    0x8(%ebp),%eax
    45ab:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    45ae:	8b 45 08             	mov    0x8(%ebp),%eax
    45b1:	8b 50 10             	mov    0x10(%eax),%edx
    45b4:	8b 45 08             	mov    0x8(%ebp),%eax
    45b7:	8b 40 0c             	mov    0xc(%eax),%eax
    45ba:	83 e0 07             	and    $0x7,%eax
    45bd:	89 c1                	mov    %eax,%ecx
    45bf:	d3 ea                	shr    %cl,%edx
    45c1:	8b 45 08             	mov    0x8(%ebp),%eax
    45c4:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    45c7:	8b 45 08             	mov    0x8(%ebp),%eax
    45ca:	8b 50 0c             	mov    0xc(%eax),%edx
    45cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    45d0:	01 c2                	add    %eax,%edx
    45d2:	8b 45 08             	mov    0x8(%ebp),%eax
    45d5:	8b 40 08             	mov    0x8(%eax),%eax
    45d8:	39 c2                	cmp    %eax,%edx
    45da:	0f 9e c0             	setle  %al
    45dd:	0f b6 c0             	movzbl %al,%eax
  }
}
    45e0:	83 c4 10             	add    $0x10,%esp
    45e3:	5b                   	pop    %ebx
    45e4:	5d                   	pop    %ebp
    45e5:	c3                   	ret    

000045e6 <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    45e6:	55                   	push   %ebp
    45e7:	89 e5                	mov    %esp,%ebp
    45e9:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    45ea:	8b 45 08             	mov    0x8(%ebp),%eax
    45ed:	8b 50 10             	mov    0x10(%eax),%edx
    45f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    45f3:	bb 01 00 00 00       	mov    $0x1,%ebx
    45f8:	89 c1                	mov    %eax,%ecx
    45fa:	d3 e3                	shl    %cl,%ebx
    45fc:	89 d8                	mov    %ebx,%eax
    45fe:	83 e8 01             	sub    $0x1,%eax
    4601:	21 d0                	and    %edx,%eax
}
    4603:	5b                   	pop    %ebx
    4604:	5d                   	pop    %ebp
    4605:	c3                   	ret    

00004606 <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    4606:	55                   	push   %ebp
    4607:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    4609:	8b 45 08             	mov    0x8(%ebp),%eax
    460c:	8b 50 10             	mov    0x10(%eax),%edx
    460f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4612:	89 c1                	mov    %eax,%ecx
    4614:	d3 ea                	shr    %cl,%edx
    4616:	8b 45 08             	mov    0x8(%ebp),%eax
    4619:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    461c:	8b 45 08             	mov    0x8(%ebp),%eax
    461f:	8b 50 0c             	mov    0xc(%eax),%edx
    4622:	8b 45 0c             	mov    0xc(%ebp),%eax
    4625:	01 c2                	add    %eax,%edx
    4627:	8b 45 08             	mov    0x8(%ebp),%eax
    462a:	89 50 0c             	mov    %edx,0xc(%eax)
}
    462d:	90                   	nop
    462e:	5d                   	pop    %ebp
    462f:	c3                   	ret    

00004630 <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    4630:	55                   	push   %ebp
    4631:	89 e5                	mov    %esp,%ebp
    4633:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    4636:	ff 75 0c             	pushl  0xc(%ebp)
    4639:	ff 75 08             	pushl  0x8(%ebp)
    463c:	e8 a5 ff ff ff       	call   45e6 <peekBits>
    4641:	83 c4 08             	add    $0x8,%esp
    4644:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    4647:	ff 75 0c             	pushl  0xc(%ebp)
    464a:	ff 75 08             	pushl  0x8(%ebp)
    464d:	e8 b4 ff ff ff       	call   4606 <advanceBits>
    4652:	83 c4 08             	add    $0x8,%esp
  return result;
    4655:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    4658:	c9                   	leave  
    4659:	c3                   	ret    

0000465a <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    465a:	55                   	push   %ebp
    465b:	89 e5                	mov    %esp,%ebp
    465d:	53                   	push   %ebx
    465e:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    4661:	ff 75 0c             	pushl  0xc(%ebp)
    4664:	ff 75 08             	pushl  0x8(%ebp)
    4667:	8d 45 d8             	lea    -0x28(%ebp),%eax
    466a:	50                   	push   %eax
    466b:	e8 97 f9 ff ff       	call   4007 <LodePNGBitReader_init>
    4670:	83 c4 0c             	add    $0xc,%esp
    4673:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    4676:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    467a:	74 0a                	je     4686 <lode_png_test_bitreader+0x2c>
    467c:	b8 00 00 00 00       	mov    $0x0,%eax
    4681:	e9 c3 00 00 00       	jmp    4749 <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    4686:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    468d:	e9 a6 00 00 00       	jmp    4738 <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    4692:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4695:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    469c:	8b 45 14             	mov    0x14(%ebp),%eax
    469f:	01 d0                	add    %edx,%eax
    46a1:	8b 00                	mov    (%eax),%eax
    46a3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    46a6:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    46aa:	7e 14                	jle    46c0 <lode_png_test_bitreader+0x66>
    46ac:	ff 75 ec             	pushl  -0x14(%ebp)
    46af:	8d 45 d8             	lea    -0x28(%ebp),%eax
    46b2:	50                   	push   %eax
    46b3:	e8 41 fd ff ff       	call   43f9 <ensureBits32>
    46b8:	83 c4 08             	add    $0x8,%esp
    46bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    46be:	eb 46                	jmp    4706 <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    46c0:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    46c4:	7e 14                	jle    46da <lode_png_test_bitreader+0x80>
    46c6:	ff 75 ec             	pushl  -0x14(%ebp)
    46c9:	8d 45 d8             	lea    -0x28(%ebp),%eax
    46cc:	50                   	push   %eax
    46cd:	e8 ae fb ff ff       	call   4280 <ensureBits25>
    46d2:	83 c4 08             	add    $0x8,%esp
    46d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    46d8:	eb 2c                	jmp    4706 <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    46da:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    46de:	7e 14                	jle    46f4 <lode_png_test_bitreader+0x9a>
    46e0:	ff 75 ec             	pushl  -0x14(%ebp)
    46e3:	8d 45 d8             	lea    -0x28(%ebp),%eax
    46e6:	50                   	push   %eax
    46e7:	e8 68 fa ff ff       	call   4154 <ensureBits17>
    46ec:	83 c4 08             	add    $0x8,%esp
    46ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    46f2:	eb 12                	jmp    4706 <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    46f4:	ff 75 ec             	pushl  -0x14(%ebp)
    46f7:	8d 45 d8             	lea    -0x28(%ebp),%eax
    46fa:	50                   	push   %eax
    46fb:	e8 78 f9 ff ff       	call   4078 <ensureBits9>
    4700:	83 c4 08             	add    $0x8,%esp
    4703:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    4706:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    470a:	75 07                	jne    4713 <lode_png_test_bitreader+0xb9>
    470c:	b8 00 00 00 00       	mov    $0x0,%eax
    4711:	eb 36                	jmp    4749 <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    4713:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4716:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    471d:	8b 45 18             	mov    0x18(%ebp),%eax
    4720:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    4723:	ff 75 ec             	pushl  -0x14(%ebp)
    4726:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4729:	50                   	push   %eax
    472a:	e8 01 ff ff ff       	call   4630 <readBits>
    472f:	83 c4 08             	add    $0x8,%esp
    4732:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    4734:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4738:	8b 45 f8             	mov    -0x8(%ebp),%eax
    473b:	3b 45 10             	cmp    0x10(%ebp),%eax
    473e:	0f 8c 4e ff ff ff    	jl     4692 <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    4744:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4749:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    474c:	c9                   	leave  
    474d:	c3                   	ret    

0000474e <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    474e:	55                   	push   %ebp
    474f:	89 e5                	mov    %esp,%ebp
    4751:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    4754:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    475b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    4762:	eb 27                	jmp    478b <reverseBits+0x3d>
    4764:	8b 45 0c             	mov    0xc(%ebp),%eax
    4767:	2b 45 fc             	sub    -0x4(%ebp),%eax
    476a:	83 e8 01             	sub    $0x1,%eax
    476d:	8b 55 08             	mov    0x8(%ebp),%edx
    4770:	89 c1                	mov    %eax,%ecx
    4772:	d3 ea                	shr    %cl,%edx
    4774:	89 d0                	mov    %edx,%eax
    4776:	83 e0 01             	and    $0x1,%eax
    4779:	89 c2                	mov    %eax,%edx
    477b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    477e:	89 c1                	mov    %eax,%ecx
    4780:	d3 e2                	shl    %cl,%edx
    4782:	89 d0                	mov    %edx,%eax
    4784:	09 45 f8             	or     %eax,-0x8(%ebp)
    4787:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    478b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    478e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4791:	72 d1                	jb     4764 <reverseBits+0x16>
  return result;
    4793:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    4796:	c9                   	leave  
    4797:	c3                   	ret    

00004798 <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    4798:	55                   	push   %ebp
    4799:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    479b:	8b 45 08             	mov    0x8(%ebp),%eax
    479e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    47a4:	8b 45 08             	mov    0x8(%ebp),%eax
    47a7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    47ae:	8b 45 08             	mov    0x8(%ebp),%eax
    47b1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    47b8:	8b 45 08             	mov    0x8(%ebp),%eax
    47bb:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    47c2:	90                   	nop
    47c3:	5d                   	pop    %ebp
    47c4:	c3                   	ret    

000047c5 <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    47c5:	55                   	push   %ebp
    47c6:	89 e5                	mov    %esp,%ebp
    47c8:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    47cb:	8b 45 08             	mov    0x8(%ebp),%eax
    47ce:	8b 00                	mov    (%eax),%eax
    47d0:	83 ec 0c             	sub    $0xc,%esp
    47d3:	50                   	push   %eax
    47d4:	e8 ec f0 ff ff       	call   38c5 <lodepng_free>
    47d9:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    47dc:	8b 45 08             	mov    0x8(%ebp),%eax
    47df:	8b 40 04             	mov    0x4(%eax),%eax
    47e2:	83 ec 0c             	sub    $0xc,%esp
    47e5:	50                   	push   %eax
    47e6:	e8 da f0 ff ff       	call   38c5 <lodepng_free>
    47eb:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    47ee:	8b 45 08             	mov    0x8(%ebp),%eax
    47f1:	8b 40 10             	mov    0x10(%eax),%eax
    47f4:	83 ec 0c             	sub    $0xc,%esp
    47f7:	50                   	push   %eax
    47f8:	e8 c8 f0 ff ff       	call   38c5 <lodepng_free>
    47fd:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    4800:	8b 45 08             	mov    0x8(%ebp),%eax
    4803:	8b 40 14             	mov    0x14(%eax),%eax
    4806:	83 ec 0c             	sub    $0xc,%esp
    4809:	50                   	push   %eax
    480a:	e8 b6 f0 ff ff       	call   38c5 <lodepng_free>
    480f:	83 c4 10             	add    $0x10,%esp
}
    4812:	90                   	nop
    4813:	c9                   	leave  
    4814:	c3                   	ret    

00004815 <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    4815:	55                   	push   %ebp
    4816:	89 e5                	mov    %esp,%ebp
    4818:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    481b:	a1 68 bb 01 00       	mov    0x1bb68,%eax
    4820:	c1 e0 02             	shl    $0x2,%eax
    4823:	83 ec 0c             	sub    $0xc,%esp
    4826:	50                   	push   %eax
    4827:	e8 78 f0 ff ff       	call   38a4 <lodepng_malloc>
    482c:	83 c4 10             	add    $0x10,%esp
    482f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    4832:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    4836:	75 0a                	jne    4842 <HuffmanTree_makeTable+0x2d>
    4838:	b8 53 00 00 00       	mov    $0x53,%eax
    483d:	e9 61 04 00 00       	jmp    4ca3 <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    4842:	a1 68 bb 01 00       	mov    0x1bb68,%eax
    4847:	c1 e0 02             	shl    $0x2,%eax
    484a:	83 ec 04             	sub    $0x4,%esp
    484d:	50                   	push   %eax
    484e:	6a 00                	push   $0x0
    4850:	ff 75 dc             	pushl  -0x24(%ebp)
    4853:	e8 bd f0 ff ff       	call   3915 <lodepng_memset>
    4858:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    485b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4862:	eb 7d                	jmp    48e1 <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    4864:	8b 45 08             	mov    0x8(%ebp),%eax
    4867:	8b 00                	mov    (%eax),%eax
    4869:	8b 55 f4             	mov    -0xc(%ebp),%edx
    486c:	c1 e2 02             	shl    $0x2,%edx
    486f:	01 d0                	add    %edx,%eax
    4871:	8b 00                	mov    (%eax),%eax
    4873:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    4876:	8b 45 08             	mov    0x8(%ebp),%eax
    4879:	8b 40 04             	mov    0x4(%eax),%eax
    487c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    487f:	c1 e2 02             	shl    $0x2,%edx
    4882:	01 d0                	add    %edx,%eax
    4884:	8b 00                	mov    (%eax),%eax
    4886:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    4889:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    488d:	76 4d                	jbe    48dc <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    488f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4892:	83 e8 09             	sub    $0x9,%eax
    4895:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4898:	89 c1                	mov    %eax,%ecx
    489a:	d3 ea                	shr    %cl,%edx
    489c:	89 d0                	mov    %edx,%eax
    489e:	83 ec 08             	sub    $0x8,%esp
    48a1:	6a 09                	push   $0x9
    48a3:	50                   	push   %eax
    48a4:	e8 a5 fe ff ff       	call   474e <reverseBits>
    48a9:	83 c4 10             	add    $0x10,%esp
    48ac:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    48af:	8b 45 d0             	mov    -0x30(%ebp),%eax
    48b2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    48b9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    48bc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    48bf:	8b 45 d0             	mov    -0x30(%ebp),%eax
    48c2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    48c9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    48cc:	01 d0                	add    %edx,%eax
    48ce:	8b 10                	mov    (%eax),%edx
    48d0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    48d3:	39 c2                	cmp    %eax,%edx
    48d5:	0f 43 c2             	cmovae %edx,%eax
    48d8:	89 01                	mov    %eax,(%ecx)
    48da:	eb 01                	jmp    48dd <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    48dc:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    48dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    48e1:	8b 45 08             	mov    0x8(%ebp),%eax
    48e4:	8b 50 0c             	mov    0xc(%eax),%edx
    48e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    48ea:	39 c2                	cmp    %eax,%edx
    48ec:	0f 87 72 ff ff ff    	ja     4864 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    48f2:	a1 68 bb 01 00       	mov    0x1bb68,%eax
    48f7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    48fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4901:	eb 35                	jmp    4938 <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    4903:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4906:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    490d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4910:	01 d0                	add    %edx,%eax
    4912:	8b 00                	mov    (%eax),%eax
    4914:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    4917:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    491b:	76 17                	jbe    4934 <HuffmanTree_makeTable+0x11f>
    491d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    4920:	83 e8 09             	sub    $0x9,%eax
    4923:	ba 01 00 00 00       	mov    $0x1,%edx
    4928:	89 c1                	mov    %eax,%ecx
    492a:	d3 e2                	shl    %cl,%edx
    492c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    492f:	01 d0                	add    %edx,%eax
    4931:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    4934:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4938:	8b 55 f4             	mov    -0xc(%ebp),%edx
    493b:	a1 68 bb 01 00       	mov    0x1bb68,%eax
    4940:	39 c2                	cmp    %eax,%edx
    4942:	72 bf                	jb     4903 <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    4944:	83 ec 0c             	sub    $0xc,%esp
    4947:	ff 75 e8             	pushl  -0x18(%ebp)
    494a:	e8 55 ef ff ff       	call   38a4 <lodepng_malloc>
    494f:	83 c4 10             	add    $0x10,%esp
    4952:	89 c2                	mov    %eax,%edx
    4954:	8b 45 08             	mov    0x8(%ebp),%eax
    4957:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    495a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    495d:	01 c0                	add    %eax,%eax
    495f:	83 ec 0c             	sub    $0xc,%esp
    4962:	50                   	push   %eax
    4963:	e8 3c ef ff ff       	call   38a4 <lodepng_malloc>
    4968:	83 c4 10             	add    $0x10,%esp
    496b:	89 c2                	mov    %eax,%edx
    496d:	8b 45 08             	mov    0x8(%ebp),%eax
    4970:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    4973:	8b 45 08             	mov    0x8(%ebp),%eax
    4976:	8b 40 10             	mov    0x10(%eax),%eax
    4979:	85 c0                	test   %eax,%eax
    497b:	74 0a                	je     4987 <HuffmanTree_makeTable+0x172>
    497d:	8b 45 08             	mov    0x8(%ebp),%eax
    4980:	8b 40 14             	mov    0x14(%eax),%eax
    4983:	85 c0                	test   %eax,%eax
    4985:	75 18                	jne    499f <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    4987:	83 ec 0c             	sub    $0xc,%esp
    498a:	ff 75 dc             	pushl  -0x24(%ebp)
    498d:	e8 33 ef ff ff       	call   38c5 <lodepng_free>
    4992:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    4995:	b8 53 00 00 00       	mov    $0x53,%eax
    499a:	e9 04 03 00 00       	jmp    4ca3 <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    499f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    49a6:	eb 12                	jmp    49ba <HuffmanTree_makeTable+0x1a5>
    49a8:	8b 45 08             	mov    0x8(%ebp),%eax
    49ab:	8b 50 10             	mov    0x10(%eax),%edx
    49ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49b1:	01 d0                	add    %edx,%eax
    49b3:	c6 00 10             	movb   $0x10,(%eax)
    49b6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    49ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49bd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    49c0:	7c e6                	jl     49a8 <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    49c2:	a1 68 bb 01 00       	mov    0x1bb68,%eax
    49c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    49ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    49d1:	eb 5b                	jmp    4a2e <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    49d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49d6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    49dd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    49e0:	01 d0                	add    %edx,%eax
    49e2:	8b 00                	mov    (%eax),%eax
    49e4:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    49e7:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    49eb:	76 3c                	jbe    4a29 <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    49ed:	8b 45 08             	mov    0x8(%ebp),%eax
    49f0:	8b 50 10             	mov    0x10(%eax),%edx
    49f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49f6:	01 d0                	add    %edx,%eax
    49f8:	8b 55 c8             	mov    -0x38(%ebp),%edx
    49fb:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    49fd:	8b 45 08             	mov    0x8(%ebp),%eax
    4a00:	8b 40 14             	mov    0x14(%eax),%eax
    4a03:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4a06:	01 d2                	add    %edx,%edx
    4a08:	01 d0                	add    %edx,%eax
    4a0a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4a0d:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    4a10:	8b 45 c8             	mov    -0x38(%ebp),%eax
    4a13:	83 e8 09             	sub    $0x9,%eax
    4a16:	ba 01 00 00 00       	mov    $0x1,%edx
    4a1b:	89 c1                	mov    %eax,%ecx
    4a1d:	d3 e2                	shl    %cl,%edx
    4a1f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4a22:	01 d0                	add    %edx,%eax
    4a24:	89 45 ec             	mov    %eax,-0x14(%ebp)
    4a27:	eb 01                	jmp    4a2a <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    4a29:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    4a2a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4a2e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4a31:	a1 68 bb 01 00       	mov    0x1bb68,%eax
    4a36:	39 c2                	cmp    %eax,%edx
    4a38:	72 99                	jb     49d3 <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    4a3a:	83 ec 0c             	sub    $0xc,%esp
    4a3d:	ff 75 dc             	pushl  -0x24(%ebp)
    4a40:	e8 80 ee ff ff       	call   38c5 <lodepng_free>
    4a45:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    4a48:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    4a4f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4a56:	e9 9d 01 00 00       	jmp    4bf8 <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    4a5b:	8b 45 08             	mov    0x8(%ebp),%eax
    4a5e:	8b 40 04             	mov    0x4(%eax),%eax
    4a61:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4a64:	c1 e2 02             	shl    $0x2,%edx
    4a67:	01 d0                	add    %edx,%eax
    4a69:	8b 00                	mov    (%eax),%eax
    4a6b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    4a6e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a71:	8b 00                	mov    (%eax),%eax
    4a73:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4a76:	c1 e2 02             	shl    $0x2,%edx
    4a79:	01 d0                	add    %edx,%eax
    4a7b:	8b 00                	mov    (%eax),%eax
    4a7d:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    4a80:	83 ec 08             	sub    $0x8,%esp
    4a83:	ff 75 c4             	pushl  -0x3c(%ebp)
    4a86:	ff 75 c0             	pushl  -0x40(%ebp)
    4a89:	e8 c0 fc ff ff       	call   474e <reverseBits>
    4a8e:	83 c4 10             	add    $0x10,%esp
    4a91:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    4a94:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    4a98:	0f 84 55 01 00 00    	je     4bf3 <HuffmanTree_makeTable+0x3de>
    numpresent++;
    4a9e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    4aa2:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    4aa6:	0f 87 81 00 00 00    	ja     4b2d <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    4aac:	b8 09 00 00 00       	mov    $0x9,%eax
    4ab1:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    4ab4:	ba 01 00 00 00       	mov    $0x1,%edx
    4ab9:	89 c1                	mov    %eax,%ecx
    4abb:	d3 e2                	shl    %cl,%edx
    4abd:	89 d0                	mov    %edx,%eax
    4abf:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    4ac2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    4ac9:	eb 55                	jmp    4b20 <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    4acb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4ace:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4ad1:	89 c1                	mov    %eax,%ecx
    4ad3:	d3 e2                	shl    %cl,%edx
    4ad5:	89 d0                	mov    %edx,%eax
    4ad7:	0b 45 bc             	or     -0x44(%ebp),%eax
    4ada:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    4add:	8b 45 08             	mov    0x8(%ebp),%eax
    4ae0:	8b 50 10             	mov    0x10(%eax),%edx
    4ae3:	8b 45 98             	mov    -0x68(%ebp),%eax
    4ae6:	01 d0                	add    %edx,%eax
    4ae8:	0f b6 00             	movzbl (%eax),%eax
    4aeb:	3c 10                	cmp    $0x10,%al
    4aed:	74 0a                	je     4af9 <HuffmanTree_makeTable+0x2e4>
    4aef:	b8 37 00 00 00       	mov    $0x37,%eax
    4af4:	e9 aa 01 00 00       	jmp    4ca3 <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    4af9:	8b 45 08             	mov    0x8(%ebp),%eax
    4afc:	8b 50 10             	mov    0x10(%eax),%edx
    4aff:	8b 45 98             	mov    -0x68(%ebp),%eax
    4b02:	01 d0                	add    %edx,%eax
    4b04:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4b07:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    4b09:	8b 45 08             	mov    0x8(%ebp),%eax
    4b0c:	8b 40 14             	mov    0x14(%eax),%eax
    4b0f:	8b 55 98             	mov    -0x68(%ebp),%edx
    4b12:	01 d2                	add    %edx,%edx
    4b14:	01 d0                	add    %edx,%eax
    4b16:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4b19:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    4b1c:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    4b20:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4b23:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    4b26:	72 a3                	jb     4acb <HuffmanTree_makeTable+0x2b6>
    4b28:	e9 c7 00 00 00       	jmp    4bf4 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    4b2d:	a1 6c bb 01 00       	mov    0x1bb6c,%eax
    4b32:	23 45 bc             	and    -0x44(%ebp),%eax
    4b35:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    4b38:	8b 45 08             	mov    0x8(%ebp),%eax
    4b3b:	8b 50 10             	mov    0x10(%eax),%edx
    4b3e:	8b 45 b8             	mov    -0x48(%ebp),%eax
    4b41:	01 d0                	add    %edx,%eax
    4b43:	0f b6 00             	movzbl (%eax),%eax
    4b46:	0f b6 c0             	movzbl %al,%eax
    4b49:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    4b4c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    4b4f:	83 e8 09             	sub    $0x9,%eax
    4b52:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    4b55:	8b 45 08             	mov    0x8(%ebp),%eax
    4b58:	8b 40 14             	mov    0x14(%eax),%eax
    4b5b:	8b 55 b8             	mov    -0x48(%ebp),%edx
    4b5e:	01 d2                	add    %edx,%edx
    4b60:	01 d0                	add    %edx,%eax
    4b62:	0f b7 00             	movzwl (%eax),%eax
    4b65:	0f b7 c0             	movzwl %ax,%eax
    4b68:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    4b6b:	8b 45 b0             	mov    -0x50(%ebp),%eax
    4b6e:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    4b71:	83 c0 09             	add    $0x9,%eax
    4b74:	ba 01 00 00 00       	mov    $0x1,%edx
    4b79:	89 c1                	mov    %eax,%ecx
    4b7b:	d3 e2                	shl    %cl,%edx
    4b7d:	89 d0                	mov    %edx,%eax
    4b7f:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    4b82:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    4b85:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    4b88:	73 0a                	jae    4b94 <HuffmanTree_makeTable+0x37f>
    4b8a:	b8 37 00 00 00       	mov    $0x37,%eax
    4b8f:	e9 0f 01 00 00       	jmp    4ca3 <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    4b94:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    4b9b:	eb 4c                	jmp    4be9 <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    4b9d:	8b 45 bc             	mov    -0x44(%ebp),%eax
    4ba0:	c1 e8 09             	shr    $0x9,%eax
    4ba3:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    4ba6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4ba9:	83 e8 09             	sub    $0x9,%eax
    4bac:	8b 55 e0             	mov    -0x20(%ebp),%edx
    4baf:	89 c1                	mov    %eax,%ecx
    4bb1:	d3 e2                	shl    %cl,%edx
    4bb3:	89 d0                	mov    %edx,%eax
    4bb5:	0b 45 a4             	or     -0x5c(%ebp),%eax
    4bb8:	89 c2                	mov    %eax,%edx
    4bba:	8b 45 ac             	mov    -0x54(%ebp),%eax
    4bbd:	01 d0                	add    %edx,%eax
    4bbf:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    4bc2:	8b 45 08             	mov    0x8(%ebp),%eax
    4bc5:	8b 50 10             	mov    0x10(%eax),%edx
    4bc8:	8b 45 a0             	mov    -0x60(%ebp),%eax
    4bcb:	01 d0                	add    %edx,%eax
    4bcd:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4bd0:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    4bd2:	8b 45 08             	mov    0x8(%ebp),%eax
    4bd5:	8b 40 14             	mov    0x14(%eax),%eax
    4bd8:	8b 55 a0             	mov    -0x60(%ebp),%edx
    4bdb:	01 d2                	add    %edx,%edx
    4bdd:	01 d0                	add    %edx,%eax
    4bdf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4be2:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    4be5:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4be9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4bec:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    4bef:	72 ac                	jb     4b9d <HuffmanTree_makeTable+0x388>
    4bf1:	eb 01                	jmp    4bf4 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    4bf3:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    4bf4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4bf8:	8b 45 08             	mov    0x8(%ebp),%eax
    4bfb:	8b 50 0c             	mov    0xc(%eax),%edx
    4bfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c01:	39 c2                	cmp    %eax,%edx
    4c03:	0f 87 52 fe ff ff    	ja     4a5b <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    4c09:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    4c0d:	7f 61                	jg     4c70 <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    4c0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4c16:	eb 4e                	jmp    4c66 <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    4c18:	8b 45 08             	mov    0x8(%ebp),%eax
    4c1b:	8b 50 10             	mov    0x10(%eax),%edx
    4c1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c21:	01 d0                	add    %edx,%eax
    4c23:	0f b6 00             	movzbl (%eax),%eax
    4c26:	3c 10                	cmp    $0x10,%al
    4c28:	75 38                	jne    4c62 <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    4c2a:	8b 45 08             	mov    0x8(%ebp),%eax
    4c2d:	8b 50 10             	mov    0x10(%eax),%edx
    4c30:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c33:	01 d0                	add    %edx,%eax
    4c35:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    4c38:	8b 15 68 bb 01 00    	mov    0x1bb68,%edx
    4c3e:	39 d1                	cmp    %edx,%ecx
    4c40:	73 07                	jae    4c49 <HuffmanTree_makeTable+0x434>
    4c42:	ba 01 00 00 00       	mov    $0x1,%edx
    4c47:	eb 05                	jmp    4c4e <HuffmanTree_makeTable+0x439>
    4c49:	ba 0a 00 00 00       	mov    $0xa,%edx
    4c4e:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    4c50:	8b 45 08             	mov    0x8(%ebp),%eax
    4c53:	8b 40 14             	mov    0x14(%eax),%eax
    4c56:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4c59:	01 d2                	add    %edx,%edx
    4c5b:	01 d0                	add    %edx,%eax
    4c5d:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    4c62:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4c66:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c69:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4c6c:	7c aa                	jl     4c18 <HuffmanTree_makeTable+0x403>
    4c6e:	eb 2e                	jmp    4c9e <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    4c70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4c77:	eb 1d                	jmp    4c96 <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    4c79:	8b 45 08             	mov    0x8(%ebp),%eax
    4c7c:	8b 50 10             	mov    0x10(%eax),%edx
    4c7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c82:	01 d0                	add    %edx,%eax
    4c84:	0f b6 00             	movzbl (%eax),%eax
    4c87:	3c 10                	cmp    $0x10,%al
    4c89:	75 07                	jne    4c92 <HuffmanTree_makeTable+0x47d>
    4c8b:	b8 37 00 00 00       	mov    $0x37,%eax
    4c90:	eb 11                	jmp    4ca3 <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    4c92:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4c96:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c99:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4c9c:	7c db                	jl     4c79 <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    4c9e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4ca3:	c9                   	leave  
    4ca4:	c3                   	ret    

00004ca5 <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    4ca5:	55                   	push   %ebp
    4ca6:	89 e5                	mov    %esp,%ebp
    4ca8:	56                   	push   %esi
    4ca9:	53                   	push   %ebx
    4caa:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    4cad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    4cb4:	8b 45 08             	mov    0x8(%ebp),%eax
    4cb7:	8b 40 0c             	mov    0xc(%eax),%eax
    4cba:	c1 e0 02             	shl    $0x2,%eax
    4cbd:	83 ec 0c             	sub    $0xc,%esp
    4cc0:	50                   	push   %eax
    4cc1:	e8 de eb ff ff       	call   38a4 <lodepng_malloc>
    4cc6:	83 c4 10             	add    $0x10,%esp
    4cc9:	89 c2                	mov    %eax,%edx
    4ccb:	8b 45 08             	mov    0x8(%ebp),%eax
    4cce:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4cd0:	8b 45 08             	mov    0x8(%ebp),%eax
    4cd3:	8b 40 08             	mov    0x8(%eax),%eax
    4cd6:	83 c0 01             	add    $0x1,%eax
    4cd9:	c1 e0 02             	shl    $0x2,%eax
    4cdc:	83 ec 0c             	sub    $0xc,%esp
    4cdf:	50                   	push   %eax
    4ce0:	e8 bf eb ff ff       	call   38a4 <lodepng_malloc>
    4ce5:	83 c4 10             	add    $0x10,%esp
    4ce8:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4ceb:	8b 45 08             	mov    0x8(%ebp),%eax
    4cee:	8b 40 08             	mov    0x8(%eax),%eax
    4cf1:	83 c0 01             	add    $0x1,%eax
    4cf4:	c1 e0 02             	shl    $0x2,%eax
    4cf7:	83 ec 0c             	sub    $0xc,%esp
    4cfa:	50                   	push   %eax
    4cfb:	e8 a4 eb ff ff       	call   38a4 <lodepng_malloc>
    4d00:	83 c4 10             	add    $0x10,%esp
    4d03:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    4d06:	8b 45 08             	mov    0x8(%ebp),%eax
    4d09:	8b 00                	mov    (%eax),%eax
    4d0b:	85 c0                	test   %eax,%eax
    4d0d:	74 0c                	je     4d1b <HuffmanTree_makeFromLengths2+0x76>
    4d0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    4d13:	74 06                	je     4d1b <HuffmanTree_makeFromLengths2+0x76>
    4d15:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4d19:	75 07                	jne    4d22 <HuffmanTree_makeFromLengths2+0x7d>
    4d1b:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    4d22:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4d26:	0f 85 7d 01 00 00    	jne    4ea9 <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    4d2c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4d33:	eb 2c                	jmp    4d61 <HuffmanTree_makeFromLengths2+0xbc>
    4d35:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4d38:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4d3f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4d42:	01 c2                	add    %eax,%edx
    4d44:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4d47:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4d4e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4d51:	01 c8                	add    %ecx,%eax
    4d53:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    4d59:	8b 00                	mov    (%eax),%eax
    4d5b:	89 02                	mov    %eax,(%edx)
    4d5d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    4d61:	8b 45 08             	mov    0x8(%ebp),%eax
    4d64:	8b 40 08             	mov    0x8(%eax),%eax
    4d67:	83 c0 01             	add    $0x1,%eax
    4d6a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4d6d:	75 c6                	jne    4d35 <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    4d6f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4d76:	eb 27                	jmp    4d9f <HuffmanTree_makeFromLengths2+0xfa>
    4d78:	8b 45 08             	mov    0x8(%ebp),%eax
    4d7b:	8b 40 04             	mov    0x4(%eax),%eax
    4d7e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4d81:	c1 e2 02             	shl    $0x2,%edx
    4d84:	01 d0                	add    %edx,%eax
    4d86:	8b 00                	mov    (%eax),%eax
    4d88:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4d8f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4d92:	01 d0                	add    %edx,%eax
    4d94:	8b 10                	mov    (%eax),%edx
    4d96:	83 c2 01             	add    $0x1,%edx
    4d99:	89 10                	mov    %edx,(%eax)
    4d9b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4d9f:	8b 45 08             	mov    0x8(%ebp),%eax
    4da2:	8b 40 0c             	mov    0xc(%eax),%eax
    4da5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4da8:	75 ce                	jne    4d78 <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4daa:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    4db1:	eb 47                	jmp    4dfa <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    4db3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4db6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4dbd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4dc0:	01 d0                	add    %edx,%eax
    4dc2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4dc5:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4dcb:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4dd2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4dd5:	01 ca                	add    %ecx,%edx
    4dd7:	8b 0a                	mov    (%edx),%ecx
    4dd9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4ddc:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4de2:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    4de9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4dec:	01 da                	add    %ebx,%edx
    4dee:	8b 12                	mov    (%edx),%edx
    4df0:	01 ca                	add    %ecx,%edx
    4df2:	01 d2                	add    %edx,%edx
    4df4:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4df6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4dfa:	8b 45 08             	mov    0x8(%ebp),%eax
    4dfd:	8b 40 08             	mov    0x8(%eax),%eax
    4e00:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4e03:	73 ae                	jae    4db3 <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4e05:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4e0c:	e9 89 00 00 00       	jmp    4e9a <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    4e11:	8b 45 08             	mov    0x8(%ebp),%eax
    4e14:	8b 40 04             	mov    0x4(%eax),%eax
    4e17:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4e1a:	c1 e2 02             	shl    $0x2,%edx
    4e1d:	01 d0                	add    %edx,%eax
    4e1f:	8b 00                	mov    (%eax),%eax
    4e21:	85 c0                	test   %eax,%eax
    4e23:	74 71                	je     4e96 <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    4e25:	8b 45 08             	mov    0x8(%ebp),%eax
    4e28:	8b 00                	mov    (%eax),%eax
    4e2a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4e2d:	c1 e2 02             	shl    $0x2,%edx
    4e30:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4e33:	8b 45 08             	mov    0x8(%ebp),%eax
    4e36:	8b 40 04             	mov    0x4(%eax),%eax
    4e39:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4e3c:	c1 e2 02             	shl    $0x2,%edx
    4e3f:	01 d0                	add    %edx,%eax
    4e41:	8b 00                	mov    (%eax),%eax
    4e43:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4e4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4e4d:	01 c2                	add    %eax,%edx
    4e4f:	8b 02                	mov    (%edx),%eax
    4e51:	8d 48 01             	lea    0x1(%eax),%ecx
    4e54:	89 0a                	mov    %ecx,(%edx)
    4e56:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    4e58:	8b 45 08             	mov    0x8(%ebp),%eax
    4e5b:	8b 00                	mov    (%eax),%eax
    4e5d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4e60:	c1 e2 02             	shl    $0x2,%edx
    4e63:	01 c2                	add    %eax,%edx
    4e65:	8b 45 08             	mov    0x8(%ebp),%eax
    4e68:	8b 00                	mov    (%eax),%eax
    4e6a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4e6d:	c1 e1 02             	shl    $0x2,%ecx
    4e70:	01 c8                	add    %ecx,%eax
    4e72:	8b 18                	mov    (%eax),%ebx
    4e74:	8b 45 08             	mov    0x8(%ebp),%eax
    4e77:	8b 40 04             	mov    0x4(%eax),%eax
    4e7a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4e7d:	c1 e1 02             	shl    $0x2,%ecx
    4e80:	01 c8                	add    %ecx,%eax
    4e82:	8b 00                	mov    (%eax),%eax
    4e84:	be 01 00 00 00       	mov    $0x1,%esi
    4e89:	89 c1                	mov    %eax,%ecx
    4e8b:	d3 e6                	shl    %cl,%esi
    4e8d:	89 f0                	mov    %esi,%eax
    4e8f:	83 e8 01             	sub    $0x1,%eax
    4e92:	21 d8                	and    %ebx,%eax
    4e94:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4e96:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    4e9a:	8b 45 08             	mov    0x8(%ebp),%eax
    4e9d:	8b 40 0c             	mov    0xc(%eax),%eax
    4ea0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4ea3:	0f 85 68 ff ff ff    	jne    4e11 <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    4ea9:	83 ec 0c             	sub    $0xc,%esp
    4eac:	ff 75 e8             	pushl  -0x18(%ebp)
    4eaf:	e8 11 ea ff ff       	call   38c5 <lodepng_free>
    4eb4:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    4eb7:	83 ec 0c             	sub    $0xc,%esp
    4eba:	ff 75 e4             	pushl  -0x1c(%ebp)
    4ebd:	e8 03 ea ff ff       	call   38c5 <lodepng_free>
    4ec2:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    4ec5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4ec9:	75 11                	jne    4edc <HuffmanTree_makeFromLengths2+0x237>
    4ecb:	83 ec 0c             	sub    $0xc,%esp
    4ece:	ff 75 08             	pushl  0x8(%ebp)
    4ed1:	e8 3f f9 ff ff       	call   4815 <HuffmanTree_makeTable>
    4ed6:	83 c4 10             	add    $0x10,%esp
    4ed9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    4edc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4edf:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4ee2:	5b                   	pop    %ebx
    4ee3:	5e                   	pop    %esi
    4ee4:	5d                   	pop    %ebp
    4ee5:	c3                   	ret    

00004ee6 <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    4ee6:	55                   	push   %ebp
    4ee7:	89 e5                	mov    %esp,%ebp
    4ee9:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    4eec:	8b 45 10             	mov    0x10(%ebp),%eax
    4eef:	c1 e0 02             	shl    $0x2,%eax
    4ef2:	83 ec 0c             	sub    $0xc,%esp
    4ef5:	50                   	push   %eax
    4ef6:	e8 a9 e9 ff ff       	call   38a4 <lodepng_malloc>
    4efb:	83 c4 10             	add    $0x10,%esp
    4efe:	89 c2                	mov    %eax,%edx
    4f00:	8b 45 08             	mov    0x8(%ebp),%eax
    4f03:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    4f06:	8b 45 08             	mov    0x8(%ebp),%eax
    4f09:	8b 40 04             	mov    0x4(%eax),%eax
    4f0c:	85 c0                	test   %eax,%eax
    4f0e:	75 07                	jne    4f17 <HuffmanTree_makeFromLengths+0x31>
    4f10:	b8 53 00 00 00       	mov    $0x53,%eax
    4f15:	eb 56                	jmp    4f6d <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    4f17:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4f1e:	eb 25                	jmp    4f45 <HuffmanTree_makeFromLengths+0x5f>
    4f20:	8b 45 08             	mov    0x8(%ebp),%eax
    4f23:	8b 40 04             	mov    0x4(%eax),%eax
    4f26:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4f29:	c1 e2 02             	shl    $0x2,%edx
    4f2c:	01 c2                	add    %eax,%edx
    4f2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f31:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4f38:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f3b:	01 c8                	add    %ecx,%eax
    4f3d:	8b 00                	mov    (%eax),%eax
    4f3f:	89 02                	mov    %eax,(%edx)
    4f41:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4f45:	8b 45 10             	mov    0x10(%ebp),%eax
    4f48:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4f4b:	75 d3                	jne    4f20 <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    4f4d:	8b 55 10             	mov    0x10(%ebp),%edx
    4f50:	8b 45 08             	mov    0x8(%ebp),%eax
    4f53:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    4f56:	8b 45 08             	mov    0x8(%ebp),%eax
    4f59:	8b 55 14             	mov    0x14(%ebp),%edx
    4f5c:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    4f5f:	83 ec 0c             	sub    $0xc,%esp
    4f62:	ff 75 08             	pushl  0x8(%ebp)
    4f65:	e8 3b fd ff ff       	call   4ca5 <HuffmanTree_makeFromLengths2>
    4f6a:	83 c4 10             	add    $0x10,%esp
}
    4f6d:	c9                   	leave  
    4f6e:	c3                   	ret    

00004f6f <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    4f6f:	55                   	push   %ebp
    4f70:	89 e5                	mov    %esp,%ebp
    4f72:	53                   	push   %ebx
    4f73:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    4f76:	8b 45 08             	mov    0x8(%ebp),%eax
    4f79:	8b 50 0c             	mov    0xc(%eax),%edx
    4f7c:	8b 45 08             	mov    0x8(%ebp),%eax
    4f7f:	8b 40 08             	mov    0x8(%eax),%eax
    4f82:	39 c2                	cmp    %eax,%edx
    4f84:	0f 82 0b 01 00 00    	jb     5095 <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    4f8a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4f91:	eb 19                	jmp    4fac <bpmnode_create+0x3d>
    4f93:	8b 45 08             	mov    0x8(%ebp),%eax
    4f96:	8b 40 04             	mov    0x4(%eax),%eax
    4f99:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4f9c:	c1 e2 04             	shl    $0x4,%edx
    4f9f:	01 d0                	add    %edx,%eax
    4fa1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    4fa8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4fac:	8b 45 08             	mov    0x8(%ebp),%eax
    4faf:	8b 00                	mov    (%eax),%eax
    4fb1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4fb4:	75 dd                	jne    4f93 <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    4fb6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4fbd:	eb 60                	jmp    501f <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    4fbf:	8b 45 08             	mov    0x8(%ebp),%eax
    4fc2:	8b 40 18             	mov    0x18(%eax),%eax
    4fc5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4fc8:	c1 e2 02             	shl    $0x2,%edx
    4fcb:	01 d0                	add    %edx,%eax
    4fcd:	8b 00                	mov    (%eax),%eax
    4fcf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4fd2:	eb 13                	jmp    4fe7 <bpmnode_create+0x78>
    4fd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4fd7:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4fde:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4fe1:	8b 40 08             	mov    0x8(%eax),%eax
    4fe4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4fe7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4feb:	75 e7                	jne    4fd4 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    4fed:	8b 45 08             	mov    0x8(%ebp),%eax
    4ff0:	8b 40 1c             	mov    0x1c(%eax),%eax
    4ff3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4ff6:	c1 e2 02             	shl    $0x2,%edx
    4ff9:	01 d0                	add    %edx,%eax
    4ffb:	8b 00                	mov    (%eax),%eax
    4ffd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5000:	eb 13                	jmp    5015 <bpmnode_create+0xa6>
    5002:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5005:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    500c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    500f:	8b 40 08             	mov    0x8(%eax),%eax
    5012:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5015:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5019:	75 e7                	jne    5002 <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    501b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    501f:	8b 45 08             	mov    0x8(%ebp),%eax
    5022:	8b 40 14             	mov    0x14(%eax),%eax
    5025:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5028:	75 95                	jne    4fbf <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    502a:	8b 45 08             	mov    0x8(%ebp),%eax
    502d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    5034:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    503b:	eb 44                	jmp    5081 <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    503d:	8b 45 08             	mov    0x8(%ebp),%eax
    5040:	8b 40 04             	mov    0x4(%eax),%eax
    5043:	8b 55 f8             	mov    -0x8(%ebp),%edx
    5046:	c1 e2 04             	shl    $0x4,%edx
    5049:	01 d0                	add    %edx,%eax
    504b:	8b 40 0c             	mov    0xc(%eax),%eax
    504e:	85 c0                	test   %eax,%eax
    5050:	75 2b                	jne    507d <bpmnode_create+0x10e>
    5052:	8b 45 08             	mov    0x8(%ebp),%eax
    5055:	8b 58 10             	mov    0x10(%eax),%ebx
    5058:	8b 45 08             	mov    0x8(%ebp),%eax
    505b:	8b 40 08             	mov    0x8(%eax),%eax
    505e:	8d 48 01             	lea    0x1(%eax),%ecx
    5061:	8b 55 08             	mov    0x8(%ebp),%edx
    5064:	89 4a 08             	mov    %ecx,0x8(%edx)
    5067:	c1 e0 02             	shl    $0x2,%eax
    506a:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    506d:	8b 45 08             	mov    0x8(%ebp),%eax
    5070:	8b 40 04             	mov    0x4(%eax),%eax
    5073:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    5076:	c1 e1 04             	shl    $0x4,%ecx
    5079:	01 c8                	add    %ecx,%eax
    507b:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    507d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    5081:	8b 45 08             	mov    0x8(%ebp),%eax
    5084:	8b 00                	mov    (%eax),%eax
    5086:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5089:	75 b2                	jne    503d <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    508b:	8b 45 08             	mov    0x8(%ebp),%eax
    508e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    5095:	8b 45 08             	mov    0x8(%ebp),%eax
    5098:	8b 58 10             	mov    0x10(%eax),%ebx
    509b:	8b 45 08             	mov    0x8(%ebp),%eax
    509e:	8b 40 0c             	mov    0xc(%eax),%eax
    50a1:	8d 48 01             	lea    0x1(%eax),%ecx
    50a4:	8b 55 08             	mov    0x8(%ebp),%edx
    50a7:	89 4a 0c             	mov    %ecx,0xc(%edx)
    50aa:	c1 e0 02             	shl    $0x2,%eax
    50ad:	01 d8                	add    %ebx,%eax
    50af:	8b 00                	mov    (%eax),%eax
    50b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    50b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    50b7:	8b 55 0c             	mov    0xc(%ebp),%edx
    50ba:	89 10                	mov    %edx,(%eax)
  result->index = index;
    50bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    50bf:	8b 55 10             	mov    0x10(%ebp),%edx
    50c2:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    50c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    50c8:	8b 55 14             	mov    0x14(%ebp),%edx
    50cb:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    50ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    50d1:	83 c4 10             	add    $0x10,%esp
    50d4:	5b                   	pop    %ebx
    50d5:	5d                   	pop    %ebp
    50d6:	c3                   	ret    

000050d7 <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    50d7:	55                   	push   %ebp
    50d8:	89 e5                	mov    %esp,%ebp
    50da:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    50dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    50e0:	c1 e0 04             	shl    $0x4,%eax
    50e3:	83 ec 0c             	sub    $0xc,%esp
    50e6:	50                   	push   %eax
    50e7:	e8 b8 e7 ff ff       	call   38a4 <lodepng_malloc>
    50ec:	83 c4 10             	add    $0x10,%esp
    50ef:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    50f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    50f9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    5100:	e9 41 01 00 00       	jmp    5246 <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    5105:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5108:	83 e0 01             	and    $0x1,%eax
    510b:	85 c0                	test   %eax,%eax
    510d:	74 05                	je     5114 <bpmnode_sort+0x3d>
    510f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5112:	eb 03                	jmp    5117 <bpmnode_sort+0x40>
    5114:	8b 45 08             	mov    0x8(%ebp),%eax
    5117:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    511a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    511d:	83 e0 01             	and    $0x1,%eax
    5120:	85 c0                	test   %eax,%eax
    5122:	74 05                	je     5129 <bpmnode_sort+0x52>
    5124:	8b 45 08             	mov    0x8(%ebp),%eax
    5127:	eb 03                	jmp    512c <bpmnode_sort+0x55>
    5129:	8b 45 dc             	mov    -0x24(%ebp),%eax
    512c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    512f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    5136:	e9 f8 00 00 00       	jmp    5233 <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    513b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    513e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5141:	01 c2                	add    %eax,%edx
    5143:	8b 45 0c             	mov    0xc(%ebp),%eax
    5146:	39 c2                	cmp    %eax,%edx
    5148:	0f 4e c2             	cmovle %edx,%eax
    514b:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    514e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5151:	8d 14 00             	lea    (%eax,%eax,1),%edx
    5154:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5157:	01 c2                	add    %eax,%edx
    5159:	8b 45 0c             	mov    0xc(%ebp),%eax
    515c:	39 c2                	cmp    %eax,%edx
    515e:	0f 4e c2             	cmovle %edx,%eax
    5161:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    5164:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5167:	89 45 e8             	mov    %eax,-0x18(%ebp)
    516a:	8b 45 d0             	mov    -0x30(%ebp),%eax
    516d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    5170:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5173:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5176:	e9 a4 00 00 00       	jmp    521f <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    517b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    517e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    5181:	7d 62                	jge    51e5 <bpmnode_sort+0x10e>
    5183:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5186:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    5189:	7d 22                	jge    51ad <bpmnode_sort+0xd6>
    518b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    518e:	c1 e0 04             	shl    $0x4,%eax
    5191:	89 c2                	mov    %eax,%edx
    5193:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5196:	01 d0                	add    %edx,%eax
    5198:	8b 10                	mov    (%eax),%edx
    519a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    519d:	c1 e0 04             	shl    $0x4,%eax
    51a0:	89 c1                	mov    %eax,%ecx
    51a2:	8b 45 d8             	mov    -0x28(%ebp),%eax
    51a5:	01 c8                	add    %ecx,%eax
    51a7:	8b 00                	mov    (%eax),%eax
    51a9:	39 c2                	cmp    %eax,%edx
    51ab:	7f 38                	jg     51e5 <bpmnode_sort+0x10e>
    51ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
    51b0:	c1 e0 04             	shl    $0x4,%eax
    51b3:	89 c2                	mov    %eax,%edx
    51b5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    51b8:	01 d0                	add    %edx,%eax
    51ba:	8b 55 e8             	mov    -0x18(%ebp),%edx
    51bd:	8d 4a 01             	lea    0x1(%edx),%ecx
    51c0:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    51c3:	89 d1                	mov    %edx,%ecx
    51c5:	c1 e1 04             	shl    $0x4,%ecx
    51c8:	8b 55 d8             	mov    -0x28(%ebp),%edx
    51cb:	01 ca                	add    %ecx,%edx
    51cd:	8b 0a                	mov    (%edx),%ecx
    51cf:	89 08                	mov    %ecx,(%eax)
    51d1:	8b 4a 04             	mov    0x4(%edx),%ecx
    51d4:	89 48 04             	mov    %ecx,0x4(%eax)
    51d7:	8b 4a 08             	mov    0x8(%edx),%ecx
    51da:	89 48 08             	mov    %ecx,0x8(%eax)
    51dd:	8b 52 0c             	mov    0xc(%edx),%edx
    51e0:	89 50 0c             	mov    %edx,0xc(%eax)
    51e3:	eb 36                	jmp    521b <bpmnode_sort+0x144>
        else b[k] = a[j++];
    51e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    51e8:	c1 e0 04             	shl    $0x4,%eax
    51eb:	89 c2                	mov    %eax,%edx
    51ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    51f0:	01 d0                	add    %edx,%eax
    51f2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    51f5:	8d 4a 01             	lea    0x1(%edx),%ecx
    51f8:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    51fb:	89 d1                	mov    %edx,%ecx
    51fd:	c1 e1 04             	shl    $0x4,%ecx
    5200:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5203:	01 ca                	add    %ecx,%edx
    5205:	8b 0a                	mov    (%edx),%ecx
    5207:	89 08                	mov    %ecx,(%eax)
    5209:	8b 4a 04             	mov    0x4(%edx),%ecx
    520c:	89 48 04             	mov    %ecx,0x4(%eax)
    520f:	8b 4a 08             	mov    0x8(%edx),%ecx
    5212:	89 48 08             	mov    %ecx,0x8(%eax)
    5215:	8b 52 0c             	mov    0xc(%edx),%edx
    5218:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    521b:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    521f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5222:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    5225:	0f 8c 50 ff ff ff    	jl     517b <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    522b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    522e:	01 c0                	add    %eax,%eax
    5230:	01 45 ec             	add    %eax,-0x14(%ebp)
    5233:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5236:	3b 45 0c             	cmp    0xc(%ebp),%eax
    5239:	0f 8c fc fe ff ff    	jl     513b <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    523f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    5243:	d1 65 f4             	shll   -0xc(%ebp)
    5246:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5249:	3b 45 0c             	cmp    0xc(%ebp),%eax
    524c:	0f 8c b3 fe ff ff    	jl     5105 <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    5252:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5255:	83 e0 01             	and    $0x1,%eax
    5258:	85 c0                	test   %eax,%eax
    525a:	74 18                	je     5274 <bpmnode_sort+0x19d>
    525c:	8b 45 0c             	mov    0xc(%ebp),%eax
    525f:	c1 e0 04             	shl    $0x4,%eax
    5262:	83 ec 04             	sub    $0x4,%esp
    5265:	50                   	push   %eax
    5266:	ff 75 dc             	pushl  -0x24(%ebp)
    5269:	ff 75 08             	pushl  0x8(%ebp)
    526c:	e8 71 e6 ff ff       	call   38e2 <lodepng_memcpy>
    5271:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    5274:	83 ec 0c             	sub    $0xc,%esp
    5277:	ff 75 dc             	pushl  -0x24(%ebp)
    527a:	e8 46 e6 ff ff       	call   38c5 <lodepng_free>
    527f:	83 c4 10             	add    $0x10,%esp
}
    5282:	90                   	nop
    5283:	c9                   	leave  
    5284:	c3                   	ret    

00005285 <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    5285:	55                   	push   %ebp
    5286:	89 e5                	mov    %esp,%ebp
    5288:	56                   	push   %esi
    5289:	53                   	push   %ebx
    528a:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    528d:	8b 45 08             	mov    0x8(%ebp),%eax
    5290:	8b 40 1c             	mov    0x1c(%eax),%eax
    5293:	8b 55 14             	mov    0x14(%ebp),%edx
    5296:	c1 e2 02             	shl    $0x2,%edx
    5299:	01 d0                	add    %edx,%eax
    529b:	8b 00                	mov    (%eax),%eax
    529d:	8b 40 04             	mov    0x4(%eax),%eax
    52a0:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    52a3:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    52a7:	75 66                	jne    530f <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    52a9:	8b 45 10             	mov    0x10(%ebp),%eax
    52ac:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    52af:	0f 83 a0 01 00 00    	jae    5455 <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    52b5:	8b 45 08             	mov    0x8(%ebp),%eax
    52b8:	8b 40 18             	mov    0x18(%eax),%eax
    52bb:	8b 55 14             	mov    0x14(%ebp),%edx
    52be:	c1 e2 02             	shl    $0x2,%edx
    52c1:	01 c2                	add    %eax,%edx
    52c3:	8b 45 08             	mov    0x8(%ebp),%eax
    52c6:	8b 40 1c             	mov    0x1c(%eax),%eax
    52c9:	8b 4d 14             	mov    0x14(%ebp),%ecx
    52cc:	c1 e1 02             	shl    $0x2,%ecx
    52cf:	01 c8                	add    %ecx,%eax
    52d1:	8b 00                	mov    (%eax),%eax
    52d3:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    52d5:	8b 45 08             	mov    0x8(%ebp),%eax
    52d8:	8b 40 1c             	mov    0x1c(%eax),%eax
    52db:	8b 55 14             	mov    0x14(%ebp),%edx
    52de:	c1 e2 02             	shl    $0x2,%edx
    52e1:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    52e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    52e7:	8d 50 01             	lea    0x1(%eax),%edx
    52ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    52ed:	c1 e0 04             	shl    $0x4,%eax
    52f0:	89 c1                	mov    %eax,%ecx
    52f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    52f5:	01 c8                	add    %ecx,%eax
    52f7:	8b 00                	mov    (%eax),%eax
    52f9:	6a 00                	push   $0x0
    52fb:	52                   	push   %edx
    52fc:	50                   	push   %eax
    52fd:	ff 75 08             	pushl  0x8(%ebp)
    5300:	e8 6a fc ff ff       	call   4f6f <bpmnode_create>
    5305:	83 c4 10             	add    $0x10,%esp
    5308:	89 03                	mov    %eax,(%ebx)
    530a:	e9 47 01 00 00       	jmp    5456 <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    530f:	8b 45 08             	mov    0x8(%ebp),%eax
    5312:	8b 40 18             	mov    0x18(%eax),%eax
    5315:	8b 55 14             	mov    0x14(%ebp),%edx
    5318:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    531e:	c1 e2 02             	shl    $0x2,%edx
    5321:	01 d0                	add    %edx,%eax
    5323:	8b 00                	mov    (%eax),%eax
    5325:	8b 10                	mov    (%eax),%edx
    5327:	8b 45 08             	mov    0x8(%ebp),%eax
    532a:	8b 40 1c             	mov    0x1c(%eax),%eax
    532d:	8b 4d 14             	mov    0x14(%ebp),%ecx
    5330:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    5336:	c1 e1 02             	shl    $0x2,%ecx
    5339:	01 c8                	add    %ecx,%eax
    533b:	8b 00                	mov    (%eax),%eax
    533d:	8b 00                	mov    (%eax),%eax
    533f:	01 d0                	add    %edx,%eax
    5341:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    5344:	8b 45 08             	mov    0x8(%ebp),%eax
    5347:	8b 40 18             	mov    0x18(%eax),%eax
    534a:	8b 55 14             	mov    0x14(%ebp),%edx
    534d:	c1 e2 02             	shl    $0x2,%edx
    5350:	01 c2                	add    %eax,%edx
    5352:	8b 45 08             	mov    0x8(%ebp),%eax
    5355:	8b 40 1c             	mov    0x1c(%eax),%eax
    5358:	8b 4d 14             	mov    0x14(%ebp),%ecx
    535b:	c1 e1 02             	shl    $0x2,%ecx
    535e:	01 c8                	add    %ecx,%eax
    5360:	8b 00                	mov    (%eax),%eax
    5362:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    5364:	8b 45 10             	mov    0x10(%ebp),%eax
    5367:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    536a:	73 60                	jae    53cc <boundaryPM+0x147>
    536c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    536f:	c1 e0 04             	shl    $0x4,%eax
    5372:	89 c2                	mov    %eax,%edx
    5374:	8b 45 0c             	mov    0xc(%ebp),%eax
    5377:	01 d0                	add    %edx,%eax
    5379:	8b 00                	mov    (%eax),%eax
    537b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    537e:	7d 4c                	jge    53cc <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    5380:	8b 45 08             	mov    0x8(%ebp),%eax
    5383:	8b 40 1c             	mov    0x1c(%eax),%eax
    5386:	8b 55 14             	mov    0x14(%ebp),%edx
    5389:	c1 e2 02             	shl    $0x2,%edx
    538c:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    538f:	8b 45 08             	mov    0x8(%ebp),%eax
    5392:	8b 40 1c             	mov    0x1c(%eax),%eax
    5395:	8b 55 14             	mov    0x14(%ebp),%edx
    5398:	c1 e2 02             	shl    $0x2,%edx
    539b:	01 d0                	add    %edx,%eax
    539d:	8b 00                	mov    (%eax),%eax
    539f:	8b 50 08             	mov    0x8(%eax),%edx
    53a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53a5:	8d 48 01             	lea    0x1(%eax),%ecx
    53a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53ab:	c1 e0 04             	shl    $0x4,%eax
    53ae:	89 c6                	mov    %eax,%esi
    53b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    53b3:	01 f0                	add    %esi,%eax
    53b5:	8b 00                	mov    (%eax),%eax
    53b7:	52                   	push   %edx
    53b8:	51                   	push   %ecx
    53b9:	50                   	push   %eax
    53ba:	ff 75 08             	pushl  0x8(%ebp)
    53bd:	e8 ad fb ff ff       	call   4f6f <bpmnode_create>
    53c2:	83 c4 10             	add    $0x10,%esp
    53c5:	89 03                	mov    %eax,(%ebx)
      return;
    53c7:	e9 8a 00 00 00       	jmp    5456 <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    53cc:	8b 45 08             	mov    0x8(%ebp),%eax
    53cf:	8b 40 1c             	mov    0x1c(%eax),%eax
    53d2:	8b 55 14             	mov    0x14(%ebp),%edx
    53d5:	c1 e2 02             	shl    $0x2,%edx
    53d8:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    53db:	8b 45 08             	mov    0x8(%ebp),%eax
    53de:	8b 40 1c             	mov    0x1c(%eax),%eax
    53e1:	8b 55 14             	mov    0x14(%ebp),%edx
    53e4:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    53ea:	c1 e2 02             	shl    $0x2,%edx
    53ed:	01 d0                	add    %edx,%eax
    53ef:	8b 00                	mov    (%eax),%eax
    53f1:	50                   	push   %eax
    53f2:	ff 75 f4             	pushl  -0xc(%ebp)
    53f5:	ff 75 f0             	pushl  -0x10(%ebp)
    53f8:	ff 75 08             	pushl  0x8(%ebp)
    53fb:	e8 6f fb ff ff       	call   4f6f <bpmnode_create>
    5400:	83 c4 10             	add    $0x10,%esp
    5403:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    5405:	8b 45 18             	mov    0x18(%ebp),%eax
    5408:	8d 50 01             	lea    0x1(%eax),%edx
    540b:	8b 45 10             	mov    0x10(%ebp),%eax
    540e:	83 e8 01             	sub    $0x1,%eax
    5411:	01 c0                	add    %eax,%eax
    5413:	39 c2                	cmp    %eax,%edx
    5415:	7d 3f                	jge    5456 <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    5417:	8b 45 14             	mov    0x14(%ebp),%eax
    541a:	83 e8 01             	sub    $0x1,%eax
    541d:	83 ec 0c             	sub    $0xc,%esp
    5420:	ff 75 18             	pushl  0x18(%ebp)
    5423:	50                   	push   %eax
    5424:	ff 75 10             	pushl  0x10(%ebp)
    5427:	ff 75 0c             	pushl  0xc(%ebp)
    542a:	ff 75 08             	pushl  0x8(%ebp)
    542d:	e8 53 fe ff ff       	call   5285 <boundaryPM>
    5432:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    5435:	8b 45 14             	mov    0x14(%ebp),%eax
    5438:	83 e8 01             	sub    $0x1,%eax
    543b:	83 ec 0c             	sub    $0xc,%esp
    543e:	ff 75 18             	pushl  0x18(%ebp)
    5441:	50                   	push   %eax
    5442:	ff 75 10             	pushl  0x10(%ebp)
    5445:	ff 75 0c             	pushl  0xc(%ebp)
    5448:	ff 75 08             	pushl  0x8(%ebp)
    544b:	e8 35 fe ff ff       	call   5285 <boundaryPM>
    5450:	83 c4 20             	add    $0x20,%esp
    5453:	eb 01                	jmp    5456 <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    5455:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    5456:	8d 65 f8             	lea    -0x8(%ebp),%esp
    5459:	5b                   	pop    %ebx
    545a:	5e                   	pop    %esi
    545b:	5d                   	pop    %ebp
    545c:	c3                   	ret    

0000545d <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    545d:	55                   	push   %ebp
    545e:	89 e5                	mov    %esp,%ebp
    5460:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    5463:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    546a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    5471:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    5475:	75 0a                	jne    5481 <lodepng_huffman_code_lengths+0x24>
    5477:	b8 50 00 00 00       	mov    $0x50,%eax
    547c:	e9 4d 03 00 00       	jmp    57ce <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    5481:	8b 45 14             	mov    0x14(%ebp),%eax
    5484:	ba 01 00 00 00       	mov    $0x1,%edx
    5489:	89 c1                	mov    %eax,%ecx
    548b:	d3 e2                	shl    %cl,%edx
    548d:	8b 45 10             	mov    0x10(%ebp),%eax
    5490:	39 c2                	cmp    %eax,%edx
    5492:	73 0a                	jae    549e <lodepng_huffman_code_lengths+0x41>
    5494:	b8 50 00 00 00       	mov    $0x50,%eax
    5499:	e9 30 03 00 00       	jmp    57ce <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    549e:	8b 45 10             	mov    0x10(%ebp),%eax
    54a1:	c1 e0 04             	shl    $0x4,%eax
    54a4:	83 ec 0c             	sub    $0xc,%esp
    54a7:	50                   	push   %eax
    54a8:	e8 f7 e3 ff ff       	call   38a4 <lodepng_malloc>
    54ad:	83 c4 10             	add    $0x10,%esp
    54b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    54b3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    54b7:	75 0a                	jne    54c3 <lodepng_huffman_code_lengths+0x66>
    54b9:	b8 53 00 00 00       	mov    $0x53,%eax
    54be:	e9 0b 03 00 00       	jmp    57ce <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    54c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    54ca:	eb 50                	jmp    551c <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    54cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    54cf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    54d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    54d9:	01 d0                	add    %edx,%eax
    54db:	8b 00                	mov    (%eax),%eax
    54dd:	85 c0                	test   %eax,%eax
    54df:	74 37                	je     5518 <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    54e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    54e4:	c1 e0 04             	shl    $0x4,%eax
    54e7:	89 c2                	mov    %eax,%edx
    54e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    54ec:	01 d0                	add    %edx,%eax
    54ee:	8b 55 f0             	mov    -0x10(%ebp),%edx
    54f1:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    54f8:	8b 55 0c             	mov    0xc(%ebp),%edx
    54fb:	01 ca                	add    %ecx,%edx
    54fd:	8b 12                	mov    (%edx),%edx
    54ff:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    5501:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5504:	c1 e0 04             	shl    $0x4,%eax
    5507:	89 c2                	mov    %eax,%edx
    5509:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    550c:	01 c2                	add    %eax,%edx
    550e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5511:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    5514:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    5518:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    551c:	8b 45 10             	mov    0x10(%ebp),%eax
    551f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5522:	75 a8                	jne    54cc <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    5524:	8b 45 10             	mov    0x10(%ebp),%eax
    5527:	c1 e0 02             	shl    $0x2,%eax
    552a:	83 ec 04             	sub    $0x4,%esp
    552d:	50                   	push   %eax
    552e:	6a 00                	push   $0x0
    5530:	ff 75 08             	pushl  0x8(%ebp)
    5533:	e8 dd e3 ff ff       	call   3915 <lodepng_memset>
    5538:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    553b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    553f:	75 18                	jne    5559 <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    5541:	8b 45 08             	mov    0x8(%ebp),%eax
    5544:	83 c0 04             	add    $0x4,%eax
    5547:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    554d:	8b 10                	mov    (%eax),%edx
    554f:	8b 45 08             	mov    0x8(%ebp),%eax
    5552:	89 10                	mov    %edx,(%eax)
    5554:	e9 64 02 00 00       	jmp    57bd <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    5559:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    555d:	75 3e                	jne    559d <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    555f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5562:	8b 40 04             	mov    0x4(%eax),%eax
    5565:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    556c:	8b 45 08             	mov    0x8(%ebp),%eax
    556f:	01 d0                	add    %edx,%eax
    5571:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    5577:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    557a:	8b 40 04             	mov    0x4(%eax),%eax
    557d:	85 c0                	test   %eax,%eax
    557f:	75 07                	jne    5588 <lodepng_huffman_code_lengths+0x12b>
    5581:	ba 04 00 00 00       	mov    $0x4,%edx
    5586:	eb 05                	jmp    558d <lodepng_huffman_code_lengths+0x130>
    5588:	ba 00 00 00 00       	mov    $0x0,%edx
    558d:	8b 45 08             	mov    0x8(%ebp),%eax
    5590:	01 d0                	add    %edx,%eax
    5592:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    5598:	e9 20 02 00 00       	jmp    57bd <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    559d:	83 ec 08             	sub    $0x8,%esp
    55a0:	ff 75 ec             	pushl  -0x14(%ebp)
    55a3:	ff 75 e4             	pushl  -0x1c(%ebp)
    55a6:	e8 2c fb ff ff       	call   50d7 <bpmnode_sort>
    55ab:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    55ae:	8b 45 14             	mov    0x14(%ebp),%eax
    55b1:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    55b4:	8b 45 14             	mov    0x14(%ebp),%eax
    55b7:	83 c0 01             	add    $0x1,%eax
    55ba:	0f af 45 14          	imul   0x14(%ebp),%eax
    55be:	01 c0                	add    %eax,%eax
    55c0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    55c3:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    55ca:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    55cd:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    55d0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    55d3:	c1 e0 04             	shl    $0x4,%eax
    55d6:	83 ec 0c             	sub    $0xc,%esp
    55d9:	50                   	push   %eax
    55da:	e8 c5 e2 ff ff       	call   38a4 <lodepng_malloc>
    55df:	83 c4 10             	add    $0x10,%esp
    55e2:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    55e5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    55e8:	c1 e0 02             	shl    $0x2,%eax
    55eb:	83 ec 0c             	sub    $0xc,%esp
    55ee:	50                   	push   %eax
    55ef:	e8 b0 e2 ff ff       	call   38a4 <lodepng_malloc>
    55f4:	83 c4 10             	add    $0x10,%esp
    55f7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    55fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
    55fd:	c1 e0 02             	shl    $0x2,%eax
    5600:	83 ec 0c             	sub    $0xc,%esp
    5603:	50                   	push   %eax
    5604:	e8 9b e2 ff ff       	call   38a4 <lodepng_malloc>
    5609:	83 c4 10             	add    $0x10,%esp
    560c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    560f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5612:	c1 e0 02             	shl    $0x2,%eax
    5615:	83 ec 0c             	sub    $0xc,%esp
    5618:	50                   	push   %eax
    5619:	e8 86 e2 ff ff       	call   38a4 <lodepng_malloc>
    561e:	83 c4 10             	add    $0x10,%esp
    5621:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    5624:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5627:	85 c0                	test   %eax,%eax
    5629:	74 15                	je     5640 <lodepng_huffman_code_lengths+0x1e3>
    562b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    562e:	85 c0                	test   %eax,%eax
    5630:	74 0e                	je     5640 <lodepng_huffman_code_lengths+0x1e3>
    5632:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5635:	85 c0                	test   %eax,%eax
    5637:	74 07                	je     5640 <lodepng_huffman_code_lengths+0x1e3>
    5639:	8b 45 e0             	mov    -0x20(%ebp),%eax
    563c:	85 c0                	test   %eax,%eax
    563e:	75 07                	jne    5647 <lodepng_huffman_code_lengths+0x1ea>
    5640:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    5647:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    564b:	0f 85 30 01 00 00    	jne    5781 <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    5651:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5658:	eb 1c                	jmp    5676 <lodepng_huffman_code_lengths+0x219>
    565a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    565d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5660:	c1 e2 02             	shl    $0x2,%edx
    5663:	01 d0                	add    %edx,%eax
    5665:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5668:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    566b:	c1 e1 04             	shl    $0x4,%ecx
    566e:	01 ca                	add    %ecx,%edx
    5670:	89 10                	mov    %edx,(%eax)
    5672:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5676:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5679:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    567c:	75 dc                	jne    565a <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    567e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5681:	8b 00                	mov    (%eax),%eax
    5683:	6a 00                	push   $0x0
    5685:	6a 01                	push   $0x1
    5687:	50                   	push   %eax
    5688:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    568b:	50                   	push   %eax
    568c:	e8 de f8 ff ff       	call   4f6f <bpmnode_create>
    5691:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    5694:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5697:	83 c0 10             	add    $0x10,%eax
    569a:	8b 00                	mov    (%eax),%eax
    569c:	6a 00                	push   $0x0
    569e:	6a 02                	push   $0x2
    56a0:	50                   	push   %eax
    56a1:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    56a4:	50                   	push   %eax
    56a5:	e8 c5 f8 ff ff       	call   4f6f <bpmnode_create>
    56aa:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    56ad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    56b4:	eb 27                	jmp    56dd <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    56b6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    56b9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    56bc:	c1 e2 02             	shl    $0x2,%edx
    56bf:	01 c2                	add    %eax,%edx
    56c1:	8b 45 c8             	mov    -0x38(%ebp),%eax
    56c4:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    56c6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    56c9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    56cc:	c1 e2 02             	shl    $0x2,%edx
    56cf:	01 d0                	add    %edx,%eax
    56d1:	8b 55 c8             	mov    -0x38(%ebp),%edx
    56d4:	83 c2 10             	add    $0x10,%edx
    56d7:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    56d9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    56dd:	8b 45 d8             	mov    -0x28(%ebp),%eax
    56e0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    56e3:	75 d1                	jne    56b6 <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    56e5:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    56ec:	eb 24                	jmp    5712 <lodepng_huffman_code_lengths+0x2b5>
    56ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
    56f1:	8b 55 14             	mov    0x14(%ebp),%edx
    56f4:	83 ea 01             	sub    $0x1,%edx
    56f7:	83 ec 0c             	sub    $0xc,%esp
    56fa:	50                   	push   %eax
    56fb:	52                   	push   %edx
    56fc:	ff 75 ec             	pushl  -0x14(%ebp)
    56ff:	ff 75 e4             	pushl  -0x1c(%ebp)
    5702:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5705:	50                   	push   %eax
    5706:	e8 7a fb ff ff       	call   5285 <boundaryPM>
    570b:	83 c4 20             	add    $0x20,%esp
    570e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5712:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5715:	83 e8 01             	sub    $0x1,%eax
    5718:	01 c0                	add    %eax,%eax
    571a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    571d:	75 cf                	jne    56ee <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    571f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5722:	8b 55 14             	mov    0x14(%ebp),%edx
    5725:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    572b:	c1 e2 02             	shl    $0x2,%edx
    572e:	01 d0                	add    %edx,%eax
    5730:	8b 00                	mov    (%eax),%eax
    5732:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5735:	eb 44                	jmp    577b <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    5737:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    573e:	eb 27                	jmp    5767 <lodepng_huffman_code_lengths+0x30a>
    5740:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5743:	c1 e0 04             	shl    $0x4,%eax
    5746:	89 c2                	mov    %eax,%edx
    5748:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    574b:	01 d0                	add    %edx,%eax
    574d:	8b 40 04             	mov    0x4(%eax),%eax
    5750:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5757:	8b 45 08             	mov    0x8(%ebp),%eax
    575a:	01 d0                	add    %edx,%eax
    575c:	8b 10                	mov    (%eax),%edx
    575e:	83 c2 01             	add    $0x1,%edx
    5761:	89 10                	mov    %edx,(%eax)
    5763:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5767:	8b 45 e8             	mov    -0x18(%ebp),%eax
    576a:	8b 40 04             	mov    0x4(%eax),%eax
    576d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5770:	75 ce                	jne    5740 <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    5772:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5775:	8b 40 08             	mov    0x8(%eax),%eax
    5778:	89 45 e8             	mov    %eax,-0x18(%ebp)
    577b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    577f:	75 b6                	jne    5737 <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    5781:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5784:	83 ec 0c             	sub    $0xc,%esp
    5787:	50                   	push   %eax
    5788:	e8 38 e1 ff ff       	call   38c5 <lodepng_free>
    578d:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    5790:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5793:	83 ec 0c             	sub    $0xc,%esp
    5796:	50                   	push   %eax
    5797:	e8 29 e1 ff ff       	call   38c5 <lodepng_free>
    579c:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    579f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    57a2:	83 ec 0c             	sub    $0xc,%esp
    57a5:	50                   	push   %eax
    57a6:	e8 1a e1 ff ff       	call   38c5 <lodepng_free>
    57ab:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    57ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
    57b1:	83 ec 0c             	sub    $0xc,%esp
    57b4:	50                   	push   %eax
    57b5:	e8 0b e1 ff ff       	call   38c5 <lodepng_free>
    57ba:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    57bd:	83 ec 0c             	sub    $0xc,%esp
    57c0:	ff 75 e4             	pushl  -0x1c(%ebp)
    57c3:	e8 fd e0 ff ff       	call   38c5 <lodepng_free>
    57c8:	83 c4 10             	add    $0x10,%esp
  return error;
    57cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    57ce:	c9                   	leave  
    57cf:	c3                   	ret    

000057d0 <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    57d0:	55                   	push   %ebp
    57d1:	89 e5                	mov    %esp,%ebp
    57d3:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    57d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    57dd:	eb 04                	jmp    57e3 <HuffmanTree_makeFromFrequencies+0x13>
    57df:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    57e3:	8b 45 14             	mov    0x14(%ebp),%eax
    57e6:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    57eb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    57f5:	01 d0                	add    %edx,%eax
    57f7:	8b 00                	mov    (%eax),%eax
    57f9:	85 c0                	test   %eax,%eax
    57fb:	75 08                	jne    5805 <HuffmanTree_makeFromFrequencies+0x35>
    57fd:	8b 45 14             	mov    0x14(%ebp),%eax
    5800:	3b 45 10             	cmp    0x10(%ebp),%eax
    5803:	7f da                	jg     57df <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    5805:	8b 45 14             	mov    0x14(%ebp),%eax
    5808:	c1 e0 02             	shl    $0x2,%eax
    580b:	83 ec 0c             	sub    $0xc,%esp
    580e:	50                   	push   %eax
    580f:	e8 90 e0 ff ff       	call   38a4 <lodepng_malloc>
    5814:	83 c4 10             	add    $0x10,%esp
    5817:	89 c2                	mov    %eax,%edx
    5819:	8b 45 08             	mov    0x8(%ebp),%eax
    581c:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    581f:	8b 45 08             	mov    0x8(%ebp),%eax
    5822:	8b 40 04             	mov    0x4(%eax),%eax
    5825:	85 c0                	test   %eax,%eax
    5827:	75 07                	jne    5830 <HuffmanTree_makeFromFrequencies+0x60>
    5829:	b8 53 00 00 00       	mov    $0x53,%eax
    582e:	eb 47                	jmp    5877 <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    5830:	8b 45 08             	mov    0x8(%ebp),%eax
    5833:	8b 55 18             	mov    0x18(%ebp),%edx
    5836:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    5839:	8b 55 14             	mov    0x14(%ebp),%edx
    583c:	8b 45 08             	mov    0x8(%ebp),%eax
    583f:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    5842:	8b 45 08             	mov    0x8(%ebp),%eax
    5845:	8b 40 04             	mov    0x4(%eax),%eax
    5848:	ff 75 18             	pushl  0x18(%ebp)
    584b:	ff 75 14             	pushl  0x14(%ebp)
    584e:	ff 75 0c             	pushl  0xc(%ebp)
    5851:	50                   	push   %eax
    5852:	e8 06 fc ff ff       	call   545d <lodepng_huffman_code_lengths>
    5857:	83 c4 10             	add    $0x10,%esp
    585a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    585d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5861:	75 11                	jne    5874 <HuffmanTree_makeFromFrequencies+0xa4>
    5863:	83 ec 0c             	sub    $0xc,%esp
    5866:	ff 75 08             	pushl  0x8(%ebp)
    5869:	e8 37 f4 ff ff       	call   4ca5 <HuffmanTree_makeFromLengths2>
    586e:	83 c4 10             	add    $0x10,%esp
    5871:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    5874:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5877:	c9                   	leave  
    5878:	c3                   	ret    

00005879 <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    5879:	55                   	push   %ebp
    587a:	89 e5                	mov    %esp,%ebp
    587c:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    587f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    5886:	83 ec 0c             	sub    $0xc,%esp
    5889:	68 80 04 00 00       	push   $0x480
    588e:	e8 11 e0 ff ff       	call   38a4 <lodepng_malloc>
    5893:	83 c4 10             	add    $0x10,%esp
    5896:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    5899:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    589d:	75 0a                	jne    58a9 <generateFixedLitLenTree+0x30>
    589f:	b8 53 00 00 00       	mov    $0x53,%eax
    58a4:	e9 d5 00 00 00       	jmp    597e <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    58a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    58b0:	eb 19                	jmp    58cb <generateFixedLitLenTree+0x52>
    58b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    58b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58bf:	01 d0                	add    %edx,%eax
    58c1:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    58c7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    58cb:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    58d2:	76 de                	jbe    58b2 <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    58d4:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    58db:	eb 19                	jmp    58f6 <generateFixedLitLenTree+0x7d>
    58dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    58e0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58ea:	01 d0                	add    %edx,%eax
    58ec:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    58f2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    58f6:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    58fd:	76 de                	jbe    58dd <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    58ff:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    5906:	eb 19                	jmp    5921 <generateFixedLitLenTree+0xa8>
    5908:	8b 45 f4             	mov    -0xc(%ebp),%eax
    590b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5912:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5915:	01 d0                	add    %edx,%eax
    5917:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    591d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5921:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    5928:	76 de                	jbe    5908 <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    592a:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    5931:	eb 19                	jmp    594c <generateFixedLitLenTree+0xd3>
    5933:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5936:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    593d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5940:	01 d0                	add    %edx,%eax
    5942:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5948:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    594c:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    5953:	76 de                	jbe    5933 <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5955:	6a 0f                	push   $0xf
    5957:	68 20 01 00 00       	push   $0x120
    595c:	ff 75 ec             	pushl  -0x14(%ebp)
    595f:	ff 75 08             	pushl  0x8(%ebp)
    5962:	e8 7f f5 ff ff       	call   4ee6 <HuffmanTree_makeFromLengths>
    5967:	83 c4 10             	add    $0x10,%esp
    596a:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    596d:	83 ec 0c             	sub    $0xc,%esp
    5970:	ff 75 ec             	pushl  -0x14(%ebp)
    5973:	e8 4d df ff ff       	call   38c5 <lodepng_free>
    5978:	83 c4 10             	add    $0x10,%esp
  return error;
    597b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    597e:	c9                   	leave  
    597f:	c3                   	ret    

00005980 <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    5980:	55                   	push   %ebp
    5981:	89 e5                	mov    %esp,%ebp
    5983:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    5986:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    598d:	83 ec 0c             	sub    $0xc,%esp
    5990:	68 80 00 00 00       	push   $0x80
    5995:	e8 0a df ff ff       	call   38a4 <lodepng_malloc>
    599a:	83 c4 10             	add    $0x10,%esp
    599d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    59a0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    59a4:	75 07                	jne    59ad <generateFixedDistanceTree+0x2d>
    59a6:	b8 53 00 00 00       	mov    $0x53,%eax
    59ab:	eb 4e                	jmp    59fb <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    59ad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    59b4:	eb 19                	jmp    59cf <generateFixedDistanceTree+0x4f>
    59b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    59b9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    59c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59c3:	01 d0                	add    %edx,%eax
    59c5:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    59cb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    59cf:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    59d3:	75 e1                	jne    59b6 <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    59d5:	6a 0f                	push   $0xf
    59d7:	6a 20                	push   $0x20
    59d9:	ff 75 ec             	pushl  -0x14(%ebp)
    59dc:	ff 75 08             	pushl  0x8(%ebp)
    59df:	e8 02 f5 ff ff       	call   4ee6 <HuffmanTree_makeFromLengths>
    59e4:	83 c4 10             	add    $0x10,%esp
    59e7:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    59ea:	83 ec 0c             	sub    $0xc,%esp
    59ed:	ff 75 ec             	pushl  -0x14(%ebp)
    59f0:	e8 d0 de ff ff       	call   38c5 <lodepng_free>
    59f5:	83 c4 10             	add    $0x10,%esp
  return error;
    59f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    59fb:	c9                   	leave  
    59fc:	c3                   	ret    

000059fd <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    59fd:	55                   	push   %ebp
    59fe:	89 e5                	mov    %esp,%ebp
    5a00:	53                   	push   %ebx
    5a01:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    5a04:	6a 09                	push   $0x9
    5a06:	ff 75 08             	pushl  0x8(%ebp)
    5a09:	e8 d8 eb ff ff       	call   45e6 <peekBits>
    5a0e:	83 c4 08             	add    $0x8,%esp
    5a11:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    5a15:	8b 45 0c             	mov    0xc(%ebp),%eax
    5a18:	8b 50 10             	mov    0x10(%eax),%edx
    5a1b:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    5a1f:	01 d0                	add    %edx,%eax
    5a21:	0f b6 00             	movzbl (%eax),%eax
    5a24:	0f b6 c0             	movzbl %al,%eax
    5a27:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    5a2b:	8b 45 0c             	mov    0xc(%ebp),%eax
    5a2e:	8b 40 14             	mov    0x14(%eax),%eax
    5a31:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    5a35:	01 d2                	add    %edx,%edx
    5a37:	01 d0                	add    %edx,%eax
    5a39:	0f b7 00             	movzwl (%eax),%eax
    5a3c:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    5a40:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    5a45:	77 16                	ja     5a5d <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    5a47:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    5a4b:	50                   	push   %eax
    5a4c:	ff 75 08             	pushl  0x8(%ebp)
    5a4f:	e8 b2 eb ff ff       	call   4606 <advanceBits>
    5a54:	83 c4 08             	add    $0x8,%esp
    return value;
    5a57:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    5a5b:	eb 5c                	jmp    5ab9 <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    5a5d:	6a 09                	push   $0x9
    5a5f:	ff 75 08             	pushl  0x8(%ebp)
    5a62:	e8 9f eb ff ff       	call   4606 <advanceBits>
    5a67:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    5a6a:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    5a6e:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    5a72:	83 e8 09             	sub    $0x9,%eax
    5a75:	50                   	push   %eax
    5a76:	ff 75 08             	pushl  0x8(%ebp)
    5a79:	e8 68 eb ff ff       	call   45e6 <peekBits>
    5a7e:	83 c4 08             	add    $0x8,%esp
    5a81:	01 d8                	add    %ebx,%eax
    5a83:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    5a86:	8b 45 0c             	mov    0xc(%ebp),%eax
    5a89:	8b 50 10             	mov    0x10(%eax),%edx
    5a8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5a8f:	01 d0                	add    %edx,%eax
    5a91:	0f b6 00             	movzbl (%eax),%eax
    5a94:	0f b6 c0             	movzbl %al,%eax
    5a97:	83 e8 09             	sub    $0x9,%eax
    5a9a:	50                   	push   %eax
    5a9b:	ff 75 08             	pushl  0x8(%ebp)
    5a9e:	e8 63 eb ff ff       	call   4606 <advanceBits>
    5aa3:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    5aa6:	8b 45 0c             	mov    0xc(%ebp),%eax
    5aa9:	8b 40 14             	mov    0x14(%eax),%eax
    5aac:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5aaf:	01 d2                	add    %edx,%edx
    5ab1:	01 d0                	add    %edx,%eax
    5ab3:	0f b7 00             	movzwl (%eax),%eax
    5ab6:	0f b7 c0             	movzwl %ax,%eax
  }
}
    5ab9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5abc:	c9                   	leave  
    5abd:	c3                   	ret    

00005abe <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    5abe:	55                   	push   %ebp
    5abf:	89 e5                	mov    %esp,%ebp
    5ac1:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    5ac4:	83 ec 0c             	sub    $0xc,%esp
    5ac7:	ff 75 08             	pushl  0x8(%ebp)
    5aca:	e8 aa fd ff ff       	call   5879 <generateFixedLitLenTree>
    5acf:	83 c4 10             	add    $0x10,%esp
    5ad2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    5ad5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5ad9:	74 05                	je     5ae0 <getTreeInflateFixed+0x22>
    5adb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5ade:	eb 0e                	jmp    5aee <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    5ae0:	83 ec 0c             	sub    $0xc,%esp
    5ae3:	ff 75 0c             	pushl  0xc(%ebp)
    5ae6:	e8 95 fe ff ff       	call   5980 <generateFixedDistanceTree>
    5aeb:	83 c4 10             	add    $0x10,%esp
}
    5aee:	c9                   	leave  
    5aef:	c3                   	ret    

00005af0 <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    5af0:	55                   	push   %ebp
    5af1:	89 e5                	mov    %esp,%ebp
    5af3:	53                   	push   %ebx
    5af4:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    5af7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    5afe:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    5b05:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    5b0c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    5b13:	6a 0e                	push   $0xe
    5b15:	ff 75 10             	pushl  0x10(%ebp)
    5b18:	e8 37 e6 ff ff       	call   4154 <ensureBits17>
    5b1d:	83 c4 08             	add    $0x8,%esp
    5b20:	85 c0                	test   %eax,%eax
    5b22:	75 0a                	jne    5b2e <getTreeInflateDynamic+0x3e>
    5b24:	b8 31 00 00 00       	mov    $0x31,%eax
    5b29:	e9 ec 04 00 00       	jmp    601a <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    5b2e:	6a 05                	push   $0x5
    5b30:	ff 75 10             	pushl  0x10(%ebp)
    5b33:	e8 f8 ea ff ff       	call   4630 <readBits>
    5b38:	83 c4 08             	add    $0x8,%esp
    5b3b:	05 01 01 00 00       	add    $0x101,%eax
    5b40:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    5b43:	6a 05                	push   $0x5
    5b45:	ff 75 10             	pushl  0x10(%ebp)
    5b48:	e8 e3 ea ff ff       	call   4630 <readBits>
    5b4d:	83 c4 08             	add    $0x8,%esp
    5b50:	83 c0 01             	add    $0x1,%eax
    5b53:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    5b56:	6a 04                	push   $0x4
    5b58:	ff 75 10             	pushl  0x10(%ebp)
    5b5b:	e8 d0 ea ff ff       	call   4630 <readBits>
    5b60:	83 c4 08             	add    $0x8,%esp
    5b63:	83 c0 04             	add    $0x4,%eax
    5b66:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    5b69:	83 ec 0c             	sub    $0xc,%esp
    5b6c:	6a 4c                	push   $0x4c
    5b6e:	e8 31 dd ff ff       	call   38a4 <lodepng_malloc>
    5b73:	83 c4 10             	add    $0x10,%esp
    5b76:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    5b79:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    5b7d:	75 0a                	jne    5b89 <getTreeInflateDynamic+0x99>
    5b7f:	b8 53 00 00 00       	mov    $0x53,%eax
    5b84:	e9 91 04 00 00       	jmp    601a <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    5b89:	83 ec 0c             	sub    $0xc,%esp
    5b8c:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5b8f:	50                   	push   %eax
    5b90:	e8 03 ec ff ff       	call   4798 <HuffmanTree_init>
    5b95:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    5b98:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5b9c:	0f 85 3c 04 00 00    	jne    5fde <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    5ba2:	8b 45 10             	mov    0x10(%ebp),%eax
    5ba5:	8b 48 08             	mov    0x8(%eax),%ecx
    5ba8:	8b 55 d0             	mov    -0x30(%ebp),%edx
    5bab:	89 d0                	mov    %edx,%eax
    5bad:	01 c0                	add    %eax,%eax
    5baf:	01 d0                	add    %edx,%eax
    5bb1:	89 c2                	mov    %eax,%edx
    5bb3:	8b 45 10             	mov    0x10(%ebp),%eax
    5bb6:	8b 40 0c             	mov    0xc(%eax),%eax
    5bb9:	83 ec 04             	sub    $0x4,%esp
    5bbc:	51                   	push   %ecx
    5bbd:	52                   	push   %edx
    5bbe:	50                   	push   %eax
    5bbf:	e8 f7 dd ff ff       	call   39bb <lodepng_gtofl>
    5bc4:	83 c4 10             	add    $0x10,%esp
    5bc7:	85 c0                	test   %eax,%eax
    5bc9:	74 0c                	je     5bd7 <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    5bcb:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5bd2:	e9 07 04 00 00       	jmp    5fde <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    5bd7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    5bde:	eb 3d                	jmp    5c1d <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    5be0:	83 ec 08             	sub    $0x8,%esp
    5be3:	6a 03                	push   $0x3
    5be5:	ff 75 10             	pushl  0x10(%ebp)
    5be8:	e8 8b e4 ff ff       	call   4078 <ensureBits9>
    5bed:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    5bf0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5bf3:	8b 04 85 e0 a4 01 00 	mov    0x1a4e0(,%eax,4),%eax
    5bfa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5c01:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5c04:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    5c07:	83 ec 08             	sub    $0x8,%esp
    5c0a:	6a 03                	push   $0x3
    5c0c:	ff 75 10             	pushl  0x10(%ebp)
    5c0f:	e8 1c ea ff ff       	call   4630 <readBits>
    5c14:	83 c4 10             	add    $0x10,%esp
    5c17:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    5c19:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5c1d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c20:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    5c23:	75 bb                	jne    5be0 <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5c25:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5c28:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5c2b:	eb 20                	jmp    5c4d <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    5c2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c30:	8b 04 85 e0 a4 01 00 	mov    0x1a4e0(,%eax,4),%eax
    5c37:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5c3e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5c41:	01 d0                	add    %edx,%eax
    5c43:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5c49:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5c4d:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    5c51:	75 da                	jne    5c2d <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    5c53:	6a 07                	push   $0x7
    5c55:	6a 13                	push   $0x13
    5c57:	ff 75 dc             	pushl  -0x24(%ebp)
    5c5a:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5c5d:	50                   	push   %eax
    5c5e:	e8 83 f2 ff ff       	call   4ee6 <HuffmanTree_makeFromLengths>
    5c63:	83 c4 10             	add    $0x10,%esp
    5c66:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5c69:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5c6d:	0f 85 64 03 00 00    	jne    5fd7 <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    5c73:	83 ec 0c             	sub    $0xc,%esp
    5c76:	68 80 04 00 00       	push   $0x480
    5c7b:	e8 24 dc ff ff       	call   38a4 <lodepng_malloc>
    5c80:	83 c4 10             	add    $0x10,%esp
    5c83:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    5c86:	83 ec 0c             	sub    $0xc,%esp
    5c89:	68 80 00 00 00       	push   $0x80
    5c8e:	e8 11 dc ff ff       	call   38a4 <lodepng_malloc>
    5c93:	83 c4 10             	add    $0x10,%esp
    5c96:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    5c99:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    5c9d:	74 06                	je     5ca5 <getTreeInflateDynamic+0x1b5>
    5c9f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5ca3:	75 0c                	jne    5cb1 <getTreeInflateDynamic+0x1c1>
    5ca5:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5cac:	e9 2d 03 00 00       	jmp    5fde <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    5cb1:	83 ec 04             	sub    $0x4,%esp
    5cb4:	68 80 04 00 00       	push   $0x480
    5cb9:	6a 00                	push   $0x0
    5cbb:	ff 75 e8             	pushl  -0x18(%ebp)
    5cbe:	e8 52 dc ff ff       	call   3915 <lodepng_memset>
    5cc3:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    5cc6:	83 ec 04             	sub    $0x4,%esp
    5cc9:	68 80 00 00 00       	push   $0x80
    5cce:	6a 00                	push   $0x0
    5cd0:	ff 75 e4             	pushl  -0x1c(%ebp)
    5cd3:	e8 3d dc ff ff       	call   3915 <lodepng_memset>
    5cd8:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    5cdb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    5ce2:	e9 8d 02 00 00       	jmp    5f74 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    5ce7:	83 ec 08             	sub    $0x8,%esp
    5cea:	6a 16                	push   $0x16
    5cec:	ff 75 10             	pushl  0x10(%ebp)
    5cef:	e8 8c e5 ff ff       	call   4280 <ensureBits25>
    5cf4:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    5cf7:	83 ec 08             	sub    $0x8,%esp
    5cfa:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5cfd:	50                   	push   %eax
    5cfe:	ff 75 10             	pushl  0x10(%ebp)
    5d01:	e8 f7 fc ff ff       	call   59fd <huffmanDecodeSymbol>
    5d06:	83 c4 10             	add    $0x10,%esp
    5d09:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    5d0c:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    5d10:	77 3e                	ja     5d50 <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    5d12:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d15:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5d18:	73 16                	jae    5d30 <getTreeInflateDynamic+0x240>
    5d1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d1d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5d24:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5d27:	01 c2                	add    %eax,%edx
    5d29:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5d2c:	89 02                	mov    %eax,(%edx)
    5d2e:	eb 17                	jmp    5d47 <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    5d30:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d33:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5d36:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5d3d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5d40:	01 c2                	add    %eax,%edx
    5d42:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5d45:	89 02                	mov    %eax,(%edx)
        ++i;
    5d47:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5d4b:	e9 0b 02 00 00       	jmp    5f5b <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    5d50:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    5d54:	0f 85 da 00 00 00    	jne    5e34 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    5d5a:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    5d61:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5d65:	75 0c                	jne    5d73 <getTreeInflateDynamic+0x283>
    5d67:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    5d6e:	e9 12 02 00 00       	jmp    5f85 <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    5d73:	83 ec 08             	sub    $0x8,%esp
    5d76:	6a 02                	push   $0x2
    5d78:	ff 75 10             	pushl  0x10(%ebp)
    5d7b:	e8 b0 e8 ff ff       	call   4630 <readBits>
    5d80:	83 c4 10             	add    $0x10,%esp
    5d83:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    5d86:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5d89:	83 c0 01             	add    $0x1,%eax
    5d8c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5d8f:	76 1b                	jbe    5dac <getTreeInflateDynamic+0x2bc>
    5d91:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d94:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5d99:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5da0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5da3:	01 d0                	add    %edx,%eax
    5da5:	8b 00                	mov    (%eax),%eax
    5da7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5daa:	eb 1c                	jmp    5dc8 <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    5dac:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5daf:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5db2:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5db7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5dbe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5dc1:	01 d0                	add    %edx,%eax
    5dc3:	8b 00                	mov    (%eax),%eax
    5dc5:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5dc8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5dcf:	eb 56                	jmp    5e27 <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    5dd1:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5dd4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5dd7:	01 d0                	add    %edx,%eax
    5dd9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5ddc:	77 0c                	ja     5dea <getTreeInflateDynamic+0x2fa>
    5dde:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    5de5:	e9 71 01 00 00       	jmp    5f5b <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    5dea:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ded:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5df0:	73 16                	jae    5e08 <getTreeInflateDynamic+0x318>
    5df2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5df5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5dfc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5dff:	01 c2                	add    %eax,%edx
    5e01:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5e04:	89 02                	mov    %eax,(%edx)
    5e06:	eb 17                	jmp    5e1f <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    5e08:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e0b:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5e0e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5e15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5e18:	01 c2                	add    %eax,%edx
    5e1a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5e1d:	89 02                	mov    %eax,(%edx)
          ++i;
    5e1f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5e23:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5e27:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e2a:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    5e2d:	72 a2                	jb     5dd1 <getTreeInflateDynamic+0x2e1>
    5e2f:	e9 27 01 00 00       	jmp    5f5b <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    5e34:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    5e38:	0f 85 88 00 00 00    	jne    5ec6 <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    5e3e:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    5e45:	83 ec 08             	sub    $0x8,%esp
    5e48:	6a 03                	push   $0x3
    5e4a:	ff 75 10             	pushl  0x10(%ebp)
    5e4d:	e8 de e7 ff ff       	call   4630 <readBits>
    5e52:	83 c4 10             	add    $0x10,%esp
    5e55:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5e58:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5e5f:	eb 58                	jmp    5eb9 <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    5e61:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5e64:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5e67:	01 d0                	add    %edx,%eax
    5e69:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5e6c:	77 0c                	ja     5e7a <getTreeInflateDynamic+0x38a>
    5e6e:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    5e75:	e9 e1 00 00 00       	jmp    5f5b <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5e7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e7d:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5e80:	73 17                	jae    5e99 <getTreeInflateDynamic+0x3a9>
    5e82:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e85:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5e8c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5e8f:	01 d0                	add    %edx,%eax
    5e91:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5e97:	eb 18                	jmp    5eb1 <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    5e99:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e9c:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5e9f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5ea6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5ea9:	01 d0                	add    %edx,%eax
    5eab:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5eb1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5eb5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5eb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5ebc:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    5ebf:	72 a0                	jb     5e61 <getTreeInflateDynamic+0x371>
    5ec1:	e9 95 00 00 00       	jmp    5f5b <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    5ec6:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    5eca:	0f 85 82 00 00 00    	jne    5f52 <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    5ed0:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    5ed7:	83 ec 08             	sub    $0x8,%esp
    5eda:	6a 07                	push   $0x7
    5edc:	ff 75 10             	pushl  0x10(%ebp)
    5edf:	e8 4c e7 ff ff       	call   4630 <readBits>
    5ee4:	83 c4 10             	add    $0x10,%esp
    5ee7:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5eea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5ef1:	eb 55                	jmp    5f48 <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    5ef3:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5ef6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5ef9:	01 d0                	add    %edx,%eax
    5efb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5efe:	77 09                	ja     5f09 <getTreeInflateDynamic+0x419>
    5f00:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    5f07:	eb 52                	jmp    5f5b <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5f09:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f0c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5f0f:	73 17                	jae    5f28 <getTreeInflateDynamic+0x438>
    5f11:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f14:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5f1b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5f1e:	01 d0                	add    %edx,%eax
    5f20:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5f26:	eb 18                	jmp    5f40 <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    5f28:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f2b:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5f2e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5f35:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5f38:	01 d0                	add    %edx,%eax
    5f3a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5f40:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5f44:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5f48:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f4b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    5f4e:	72 a3                	jb     5ef3 <getTreeInflateDynamic+0x403>
    5f50:	eb 09                	jmp    5f5b <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5f52:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5f59:	eb 2a                	jmp    5f85 <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    5f5b:	8b 45 10             	mov    0x10(%ebp),%eax
    5f5e:	8b 50 0c             	mov    0xc(%eax),%edx
    5f61:	8b 45 10             	mov    0x10(%ebp),%eax
    5f64:	8b 40 08             	mov    0x8(%eax),%eax
    5f67:	39 c2                	cmp    %eax,%edx
    5f69:	7e 09                	jle    5f74 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    5f6b:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5f72:	eb 11                	jmp    5f85 <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    5f74:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5f77:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5f7a:	01 d0                	add    %edx,%eax
    5f7c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5f7f:	0f 87 62 fd ff ff    	ja     5ce7 <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5f85:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5f89:	75 4f                	jne    5fda <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    5f8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5f8e:	05 00 04 00 00       	add    $0x400,%eax
    5f93:	8b 00                	mov    (%eax),%eax
    5f95:	85 c0                	test   %eax,%eax
    5f97:	75 09                	jne    5fa2 <getTreeInflateDynamic+0x4b2>
    5f99:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    5fa0:	eb 3c                	jmp    5fde <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5fa2:	6a 0f                	push   $0xf
    5fa4:	68 20 01 00 00       	push   $0x120
    5fa9:	ff 75 e8             	pushl  -0x18(%ebp)
    5fac:	ff 75 08             	pushl  0x8(%ebp)
    5faf:	e8 32 ef ff ff       	call   4ee6 <HuffmanTree_makeFromLengths>
    5fb4:	83 c4 10             	add    $0x10,%esp
    5fb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5fba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5fbe:	75 1d                	jne    5fdd <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    5fc0:	6a 0f                	push   $0xf
    5fc2:	6a 20                	push   $0x20
    5fc4:	ff 75 e4             	pushl  -0x1c(%ebp)
    5fc7:	ff 75 0c             	pushl  0xc(%ebp)
    5fca:	e8 17 ef ff ff       	call   4ee6 <HuffmanTree_makeFromLengths>
    5fcf:	83 c4 10             	add    $0x10,%esp
    5fd2:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    5fd5:	eb 07                	jmp    5fde <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    5fd7:	90                   	nop
    5fd8:	eb 04                	jmp    5fde <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5fda:	90                   	nop
    5fdb:	eb 01                	jmp    5fde <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    5fdd:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    5fde:	83 ec 0c             	sub    $0xc,%esp
    5fe1:	ff 75 dc             	pushl  -0x24(%ebp)
    5fe4:	e8 dc d8 ff ff       	call   38c5 <lodepng_free>
    5fe9:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    5fec:	83 ec 0c             	sub    $0xc,%esp
    5fef:	ff 75 e8             	pushl  -0x18(%ebp)
    5ff2:	e8 ce d8 ff ff       	call   38c5 <lodepng_free>
    5ff7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    5ffa:	83 ec 0c             	sub    $0xc,%esp
    5ffd:	ff 75 e4             	pushl  -0x1c(%ebp)
    6000:	e8 c0 d8 ff ff       	call   38c5 <lodepng_free>
    6005:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    6008:	83 ec 0c             	sub    $0xc,%esp
    600b:	8d 45 a8             	lea    -0x58(%ebp),%eax
    600e:	50                   	push   %eax
    600f:	e8 b1 e7 ff ff       	call   47c5 <HuffmanTree_cleanup>
    6014:	83 c4 10             	add    $0x10,%esp

  return error;
    6017:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    601a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    601d:	c9                   	leave  
    601e:	c3                   	ret    

0000601f <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    601f:	55                   	push   %ebp
    6020:	89 e5                	mov    %esp,%ebp
    6022:	53                   	push   %ebx
    6023:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    6026:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    602d:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6030:	50                   	push   %eax
    6031:	e8 62 e7 ff ff       	call   4798 <HuffmanTree_init>
    6036:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    6039:	8d 45 a0             	lea    -0x60(%ebp),%eax
    603c:	50                   	push   %eax
    603d:	e8 56 e7 ff ff       	call   4798 <HuffmanTree_init>
    6042:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    6045:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    6049:	75 1b                	jne    6066 <inflateHuffmanBlock+0x47>
    604b:	83 ec 08             	sub    $0x8,%esp
    604e:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6051:	50                   	push   %eax
    6052:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6055:	50                   	push   %eax
    6056:	e8 63 fa ff ff       	call   5abe <getTreeInflateFixed>
    605b:	83 c4 10             	add    $0x10,%esp
    605e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    6061:	e9 9a 02 00 00       	jmp    6300 <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    6066:	83 ec 04             	sub    $0x4,%esp
    6069:	ff 75 0c             	pushl  0xc(%ebp)
    606c:	8d 45 a0             	lea    -0x60(%ebp),%eax
    606f:	50                   	push   %eax
    6070:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6073:	50                   	push   %eax
    6074:	e8 77 fa ff ff       	call   5af0 <getTreeInflateDynamic>
    6079:	83 c4 10             	add    $0x10,%esp
    607c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    607f:	e9 7c 02 00 00       	jmp    6300 <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    6084:	83 ec 08             	sub    $0x8,%esp
    6087:	6a 14                	push   $0x14
    6089:	ff 75 0c             	pushl  0xc(%ebp)
    608c:	e8 ef e1 ff ff       	call   4280 <ensureBits25>
    6091:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    6094:	83 ec 08             	sub    $0x8,%esp
    6097:	8d 45 b8             	lea    -0x48(%ebp),%eax
    609a:	50                   	push   %eax
    609b:	ff 75 0c             	pushl  0xc(%ebp)
    609e:	e8 5a f9 ff ff       	call   59fd <huffmanDecodeSymbol>
    60a3:	83 c4 10             	add    $0x10,%esp
    60a6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    60a9:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    60b0:	77 42                	ja     60f4 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    60b2:	8b 45 08             	mov    0x8(%ebp),%eax
    60b5:	8b 40 04             	mov    0x4(%eax),%eax
    60b8:	83 c0 01             	add    $0x1,%eax
    60bb:	83 ec 08             	sub    $0x8,%esp
    60be:	50                   	push   %eax
    60bf:	ff 75 08             	pushl  0x8(%ebp)
    60c2:	e8 37 da ff ff       	call   3afe <ucvector_resize>
    60c7:	83 c4 10             	add    $0x10,%esp
    60ca:	85 c0                	test   %eax,%eax
    60cc:	75 0c                	jne    60da <inflateHuffmanBlock+0xbb>
    60ce:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    60d5:	e9 33 02 00 00       	jmp    630d <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    60da:	8b 45 08             	mov    0x8(%ebp),%eax
    60dd:	8b 10                	mov    (%eax),%edx
    60df:	8b 45 08             	mov    0x8(%ebp),%eax
    60e2:	8b 40 04             	mov    0x4(%eax),%eax
    60e5:	83 e8 01             	sub    $0x1,%eax
    60e8:	01 d0                	add    %edx,%eax
    60ea:	8b 55 dc             	mov    -0x24(%ebp),%edx
    60ed:	88 10                	mov    %dl,(%eax)
    60ef:	e9 d9 01 00 00       	jmp    62cd <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    60f4:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    60fb:	0f 86 ba 01 00 00    	jbe    62bb <inflateHuffmanBlock+0x29c>
    6101:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    6108:	0f 87 ad 01 00 00    	ja     62bb <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    610e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6111:	2d 01 01 00 00       	sub    $0x101,%eax
    6116:	8b 04 85 e0 a2 01 00 	mov    0x1a2e0(,%eax,4),%eax
    611d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    6120:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6123:	2d 01 01 00 00       	sub    $0x101,%eax
    6128:	8b 04 85 60 a3 01 00 	mov    0x1a360(,%eax,4),%eax
    612f:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    6132:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    6136:	74 1c                	je     6154 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    6138:	8b 45 d8             	mov    -0x28(%ebp),%eax
    613b:	83 ec 08             	sub    $0x8,%esp
    613e:	50                   	push   %eax
    613f:	ff 75 0c             	pushl  0xc(%ebp)
    6142:	e8 e9 e4 ff ff       	call   4630 <readBits>
    6147:	83 c4 10             	add    $0x10,%esp
    614a:	89 c2                	mov    %eax,%edx
    614c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    614f:	01 d0                	add    %edx,%eax
    6151:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    6154:	83 ec 08             	sub    $0x8,%esp
    6157:	6a 1c                	push   $0x1c
    6159:	ff 75 0c             	pushl  0xc(%ebp)
    615c:	e8 98 e2 ff ff       	call   43f9 <ensureBits32>
    6161:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    6164:	83 ec 08             	sub    $0x8,%esp
    6167:	8d 45 a0             	lea    -0x60(%ebp),%eax
    616a:	50                   	push   %eax
    616b:	ff 75 0c             	pushl  0xc(%ebp)
    616e:	e8 8a f8 ff ff       	call   59fd <huffmanDecodeSymbol>
    6173:	83 c4 10             	add    $0x10,%esp
    6176:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    6179:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    617d:	76 1e                	jbe    619d <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    617f:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    6183:	77 0c                	ja     6191 <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    6185:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    618c:	e9 7c 01 00 00       	jmp    630d <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    6191:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    6198:	e9 70 01 00 00       	jmp    630d <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    619d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    61a0:	8b 04 85 e0 a3 01 00 	mov    0x1a3e0(,%eax,4),%eax
    61a7:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    61aa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    61ad:	8b 04 85 60 a4 01 00 	mov    0x1a460(,%eax,4),%eax
    61b4:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    61b7:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    61bb:	74 15                	je     61d2 <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    61bd:	8b 45 d0             	mov    -0x30(%ebp),%eax
    61c0:	83 ec 08             	sub    $0x8,%esp
    61c3:	50                   	push   %eax
    61c4:	ff 75 0c             	pushl  0xc(%ebp)
    61c7:	e8 64 e4 ff ff       	call   4630 <readBits>
    61cc:	83 c4 10             	add    $0x10,%esp
    61cf:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    61d2:	8b 45 08             	mov    0x8(%ebp),%eax
    61d5:	8b 40 04             	mov    0x4(%eax),%eax
    61d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    61db:	8b 45 ec             	mov    -0x14(%ebp),%eax
    61de:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    61e1:	76 0c                	jbe    61ef <inflateHuffmanBlock+0x1d0>
    61e3:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    61ea:	e9 1e 01 00 00       	jmp    630d <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    61ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
    61f2:	2b 45 f0             	sub    -0x10(%ebp),%eax
    61f5:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    61f8:	8b 45 08             	mov    0x8(%ebp),%eax
    61fb:	8b 50 04             	mov    0x4(%eax),%edx
    61fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6201:	01 d0                	add    %edx,%eax
    6203:	83 ec 08             	sub    $0x8,%esp
    6206:	50                   	push   %eax
    6207:	ff 75 08             	pushl  0x8(%ebp)
    620a:	e8 ef d8 ff ff       	call   3afe <ucvector_resize>
    620f:	83 c4 10             	add    $0x10,%esp
    6212:	85 c0                	test   %eax,%eax
    6214:	75 0c                	jne    6222 <inflateHuffmanBlock+0x203>
    6216:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    621d:	e9 eb 00 00 00       	jmp    630d <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    6222:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6225:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    6228:	73 6b                	jae    6295 <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    622a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    622d:	8b 55 08             	mov    0x8(%ebp),%edx
    6230:	8b 0a                	mov    (%edx),%ecx
    6232:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6235:	01 d1                	add    %edx,%ecx
    6237:	8b 55 08             	mov    0x8(%ebp),%edx
    623a:	8b 1a                	mov    (%edx),%ebx
    623c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    623f:	01 da                	add    %ebx,%edx
    6241:	83 ec 04             	sub    $0x4,%esp
    6244:	50                   	push   %eax
    6245:	51                   	push   %ecx
    6246:	52                   	push   %edx
    6247:	e8 96 d6 ff ff       	call   38e2 <lodepng_memcpy>
    624c:	83 c4 10             	add    $0x10,%esp
        start += distance;
    624f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6252:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6255:	01 d0                	add    %edx,%eax
    6257:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    625a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    625d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    6260:	eb 29                	jmp    628b <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    6262:	8b 45 08             	mov    0x8(%ebp),%eax
    6265:	8b 08                	mov    (%eax),%ecx
    6267:	8b 45 ec             	mov    -0x14(%ebp),%eax
    626a:	8d 50 01             	lea    0x1(%eax),%edx
    626d:	89 55 ec             	mov    %edx,-0x14(%ebp)
    6270:	01 c1                	add    %eax,%ecx
    6272:	8b 45 08             	mov    0x8(%ebp),%eax
    6275:	8b 18                	mov    (%eax),%ebx
    6277:	8b 45 e8             	mov    -0x18(%ebp),%eax
    627a:	8d 50 01             	lea    0x1(%eax),%edx
    627d:	89 55 e8             	mov    %edx,-0x18(%ebp)
    6280:	01 d8                	add    %ebx,%eax
    6282:	0f b6 00             	movzbl (%eax),%eax
    6285:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    6287:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    628b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    628e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    6291:	7c cf                	jl     6262 <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    6293:	eb 38                	jmp    62cd <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    6295:	8b 45 08             	mov    0x8(%ebp),%eax
    6298:	8b 10                	mov    (%eax),%edx
    629a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    629d:	01 c2                	add    %eax,%edx
    629f:	8b 45 08             	mov    0x8(%ebp),%eax
    62a2:	8b 08                	mov    (%eax),%ecx
    62a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    62a7:	01 c8                	add    %ecx,%eax
    62a9:	83 ec 04             	sub    $0x4,%esp
    62ac:	ff 75 e4             	pushl  -0x1c(%ebp)
    62af:	52                   	push   %edx
    62b0:	50                   	push   %eax
    62b1:	e8 2c d6 ff ff       	call   38e2 <lodepng_memcpy>
    62b6:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    62b9:	eb 12                	jmp    62cd <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    62bb:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    62c2:	74 48                	je     630c <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    62c4:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    62cb:	eb 40                	jmp    630d <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    62cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    62d0:	8b 50 0c             	mov    0xc(%eax),%edx
    62d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    62d6:	8b 40 08             	mov    0x8(%eax),%eax
    62d9:	39 c2                	cmp    %eax,%edx
    62db:	7e 09                	jle    62e6 <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    62dd:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    62e4:	eb 27                	jmp    630d <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    62e6:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    62ea:	74 14                	je     6300 <inflateHuffmanBlock+0x2e1>
    62ec:	8b 45 08             	mov    0x8(%ebp),%eax
    62ef:	8b 40 04             	mov    0x4(%eax),%eax
    62f2:	3b 45 14             	cmp    0x14(%ebp),%eax
    62f5:	7e 09                	jle    6300 <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    62f7:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    62fe:	eb 0d                	jmp    630d <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    6300:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6304:	0f 84 7a fd ff ff    	je     6084 <inflateHuffmanBlock+0x65>
    630a:	eb 01                	jmp    630d <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    630c:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    630d:	83 ec 0c             	sub    $0xc,%esp
    6310:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6313:	50                   	push   %eax
    6314:	e8 ac e4 ff ff       	call   47c5 <HuffmanTree_cleanup>
    6319:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    631c:	83 ec 0c             	sub    $0xc,%esp
    631f:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6322:	50                   	push   %eax
    6323:	e8 9d e4 ff ff       	call   47c5 <HuffmanTree_cleanup>
    6328:	83 c4 10             	add    $0x10,%esp

  return error;
    632b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    632e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6331:	c9                   	leave  
    6332:	c3                   	ret    

00006333 <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    6333:	55                   	push   %ebp
    6334:	89 e5                	mov    %esp,%ebp
    6336:	53                   	push   %ebx
    6337:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    633a:	8b 45 0c             	mov    0xc(%ebp),%eax
    633d:	8b 40 04             	mov    0x4(%eax),%eax
    6340:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    6343:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    634a:	8b 45 0c             	mov    0xc(%ebp),%eax
    634d:	8b 40 0c             	mov    0xc(%eax),%eax
    6350:	83 c0 07             	add    $0x7,%eax
    6353:	c1 e8 03             	shr    $0x3,%eax
    6356:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    6359:	8b 45 f0             	mov    -0x10(%ebp),%eax
    635c:	83 c0 04             	add    $0x4,%eax
    635f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6362:	7c 0a                	jl     636e <inflateNoCompression+0x3b>
    6364:	b8 34 00 00 00       	mov    $0x34,%eax
    6369:	e9 01 01 00 00       	jmp    646f <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    636e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6371:	8b 10                	mov    (%eax),%edx
    6373:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6376:	01 d0                	add    %edx,%eax
    6378:	0f b6 00             	movzbl (%eax),%eax
    637b:	0f b6 d0             	movzbl %al,%edx
    637e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6381:	8b 00                	mov    (%eax),%eax
    6383:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    6386:	83 c1 01             	add    $0x1,%ecx
    6389:	01 c8                	add    %ecx,%eax
    638b:	0f b6 00             	movzbl (%eax),%eax
    638e:	0f b6 c0             	movzbl %al,%eax
    6391:	c1 e0 08             	shl    $0x8,%eax
    6394:	01 d0                	add    %edx,%eax
    6396:	89 45 ec             	mov    %eax,-0x14(%ebp)
    6399:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    639d:	8b 45 0c             	mov    0xc(%ebp),%eax
    63a0:	8b 10                	mov    (%eax),%edx
    63a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    63a5:	01 d0                	add    %edx,%eax
    63a7:	0f b6 00             	movzbl (%eax),%eax
    63aa:	0f b6 d0             	movzbl %al,%edx
    63ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    63b0:	8b 00                	mov    (%eax),%eax
    63b2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    63b5:	83 c1 01             	add    $0x1,%ecx
    63b8:	01 c8                	add    %ecx,%eax
    63ba:	0f b6 00             	movzbl (%eax),%eax
    63bd:	0f b6 c0             	movzbl %al,%eax
    63c0:	c1 e0 08             	shl    $0x8,%eax
    63c3:	01 d0                	add    %edx,%eax
    63c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    63c8:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    63cc:	8b 45 10             	mov    0x10(%ebp),%eax
    63cf:	8b 40 04             	mov    0x4(%eax),%eax
    63d2:	85 c0                	test   %eax,%eax
    63d4:	75 19                	jne    63ef <inflateNoCompression+0xbc>
    63d6:	8b 55 ec             	mov    -0x14(%ebp),%edx
    63d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    63dc:	01 d0                	add    %edx,%eax
    63de:	3d ff ff 00 00       	cmp    $0xffff,%eax
    63e3:	74 0a                	je     63ef <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    63e5:	b8 15 00 00 00       	mov    $0x15,%eax
    63ea:	e9 80 00 00 00       	jmp    646f <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    63ef:	8b 45 08             	mov    0x8(%ebp),%eax
    63f2:	8b 40 04             	mov    0x4(%eax),%eax
    63f5:	89 c2                	mov    %eax,%edx
    63f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    63fa:	01 d0                	add    %edx,%eax
    63fc:	50                   	push   %eax
    63fd:	ff 75 08             	pushl  0x8(%ebp)
    6400:	e8 f9 d6 ff ff       	call   3afe <ucvector_resize>
    6405:	83 c4 08             	add    $0x8,%esp
    6408:	85 c0                	test   %eax,%eax
    640a:	75 07                	jne    6413 <inflateNoCompression+0xe0>
    640c:	b8 53 00 00 00       	mov    $0x53,%eax
    6411:	eb 5c                	jmp    646f <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    6413:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6416:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6419:	01 c2                	add    %eax,%edx
    641b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    641e:	39 c2                	cmp    %eax,%edx
    6420:	76 07                	jbe    6429 <inflateNoCompression+0xf6>
    6422:	b8 17 00 00 00       	mov    $0x17,%eax
    6427:	eb 46                	jmp    646f <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    6429:	8b 45 ec             	mov    -0x14(%ebp),%eax
    642c:	8b 55 0c             	mov    0xc(%ebp),%edx
    642f:	8b 0a                	mov    (%edx),%ecx
    6431:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6434:	01 d1                	add    %edx,%ecx
    6436:	8b 55 08             	mov    0x8(%ebp),%edx
    6439:	8b 1a                	mov    (%edx),%ebx
    643b:	8b 55 08             	mov    0x8(%ebp),%edx
    643e:	8b 52 04             	mov    0x4(%edx),%edx
    6441:	2b 55 ec             	sub    -0x14(%ebp),%edx
    6444:	01 da                	add    %ebx,%edx
    6446:	50                   	push   %eax
    6447:	51                   	push   %ecx
    6448:	52                   	push   %edx
    6449:	e8 94 d4 ff ff       	call   38e2 <lodepng_memcpy>
    644e:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    6451:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6454:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6457:	01 d0                	add    %edx,%eax
    6459:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    645c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    645f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    6466:	8b 45 0c             	mov    0xc(%ebp),%eax
    6469:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    646c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    646f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6472:	c9                   	leave  
    6473:	c3                   	ret    

00006474 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    6474:	55                   	push   %ebp
    6475:	89 e5                	mov    %esp,%ebp
    6477:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    647a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    6481:	ff 75 10             	pushl  0x10(%ebp)
    6484:	ff 75 0c             	pushl  0xc(%ebp)
    6487:	8d 45 d8             	lea    -0x28(%ebp),%eax
    648a:	50                   	push   %eax
    648b:	e8 77 db ff ff       	call   4007 <LodePNGBitReader_init>
    6490:	83 c4 0c             	add    $0xc,%esp
    6493:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    6496:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    649a:	0f 84 b9 00 00 00    	je     6559 <lodepng_inflatev+0xe5>
    64a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    64a3:	e9 c1 00 00 00       	jmp    6569 <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    64a8:	6a 03                	push   $0x3
    64aa:	8d 45 d8             	lea    -0x28(%ebp),%eax
    64ad:	50                   	push   %eax
    64ae:	e8 c5 db ff ff       	call   4078 <ensureBits9>
    64b3:	83 c4 08             	add    $0x8,%esp
    64b6:	85 c0                	test   %eax,%eax
    64b8:	75 0a                	jne    64c4 <lodepng_inflatev+0x50>
    64ba:	b8 34 00 00 00       	mov    $0x34,%eax
    64bf:	e9 a5 00 00 00       	jmp    6569 <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    64c4:	6a 01                	push   $0x1
    64c6:	8d 45 d8             	lea    -0x28(%ebp),%eax
    64c9:	50                   	push   %eax
    64ca:	e8 61 e1 ff ff       	call   4630 <readBits>
    64cf:	83 c4 08             	add    $0x8,%esp
    64d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    64d5:	6a 02                	push   $0x2
    64d7:	8d 45 d8             	lea    -0x28(%ebp),%eax
    64da:	50                   	push   %eax
    64db:	e8 50 e1 ff ff       	call   4630 <readBits>
    64e0:	83 c4 08             	add    $0x8,%esp
    64e3:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    64e6:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    64ea:	75 07                	jne    64f3 <lodepng_inflatev+0x7f>
    64ec:	b8 14 00 00 00       	mov    $0x14,%eax
    64f1:	eb 76                	jmp    6569 <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    64f3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    64f7:	75 17                	jne    6510 <lodepng_inflatev+0x9c>
    64f9:	ff 75 14             	pushl  0x14(%ebp)
    64fc:	8d 45 d8             	lea    -0x28(%ebp),%eax
    64ff:	50                   	push   %eax
    6500:	ff 75 08             	pushl  0x8(%ebp)
    6503:	e8 2b fe ff ff       	call   6333 <inflateNoCompression>
    6508:	83 c4 0c             	add    $0xc,%esp
    650b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    650e:	eb 1c                	jmp    652c <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    6510:	8b 45 14             	mov    0x14(%ebp),%eax
    6513:	8b 40 08             	mov    0x8(%eax),%eax
    6516:	50                   	push   %eax
    6517:	ff 75 ec             	pushl  -0x14(%ebp)
    651a:	8d 45 d8             	lea    -0x28(%ebp),%eax
    651d:	50                   	push   %eax
    651e:	ff 75 08             	pushl  0x8(%ebp)
    6521:	e8 f9 fa ff ff       	call   601f <inflateHuffmanBlock>
    6526:	83 c4 10             	add    $0x10,%esp
    6529:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    652c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6530:	75 21                	jne    6553 <lodepng_inflatev+0xdf>
    6532:	8b 45 14             	mov    0x14(%ebp),%eax
    6535:	8b 40 08             	mov    0x8(%eax),%eax
    6538:	85 c0                	test   %eax,%eax
    653a:	74 17                	je     6553 <lodepng_inflatev+0xdf>
    653c:	8b 45 08             	mov    0x8(%ebp),%eax
    653f:	8b 50 04             	mov    0x4(%eax),%edx
    6542:	8b 45 14             	mov    0x14(%ebp),%eax
    6545:	8b 40 08             	mov    0x8(%eax),%eax
    6548:	39 c2                	cmp    %eax,%edx
    654a:	7e 07                	jle    6553 <lodepng_inflatev+0xdf>
    654c:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    6553:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6557:	75 0c                	jne    6565 <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    6559:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    655d:	0f 84 45 ff ff ff    	je     64a8 <lodepng_inflatev+0x34>
    6563:	eb 01                	jmp    6566 <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    6565:	90                   	nop
  }

  return error;
    6566:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    6569:	c9                   	leave  
    656a:	c3                   	ret    

0000656b <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    656b:	55                   	push   %ebp
    656c:	89 e5                	mov    %esp,%ebp
    656e:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    6571:	8b 45 0c             	mov    0xc(%ebp),%eax
    6574:	8b 08                	mov    (%eax),%ecx
    6576:	8b 45 08             	mov    0x8(%ebp),%eax
    6579:	8b 10                	mov    (%eax),%edx
    657b:	8d 45 e8             	lea    -0x18(%ebp),%eax
    657e:	51                   	push   %ecx
    657f:	52                   	push   %edx
    6580:	50                   	push   %eax
    6581:	e8 df d5 ff ff       	call   3b65 <ucvector_init>
    6586:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    6589:	ff 75 18             	pushl  0x18(%ebp)
    658c:	ff 75 14             	pushl  0x14(%ebp)
    658f:	ff 75 10             	pushl  0x10(%ebp)
    6592:	8d 45 e8             	lea    -0x18(%ebp),%eax
    6595:	50                   	push   %eax
    6596:	e8 d9 fe ff ff       	call   6474 <lodepng_inflatev>
    659b:	83 c4 10             	add    $0x10,%esp
    659e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    65a1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    65a4:	8b 45 08             	mov    0x8(%ebp),%eax
    65a7:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    65a9:	8b 55 ec             	mov    -0x14(%ebp),%edx
    65ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    65af:	89 10                	mov    %edx,(%eax)
  return error;
    65b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    65b4:	c9                   	leave  
    65b5:	c3                   	ret    

000065b6 <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    65b6:	55                   	push   %ebp
    65b7:	89 e5                	mov    %esp,%ebp
    65b9:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    65bc:	8b 45 14             	mov    0x14(%ebp),%eax
    65bf:	8b 40 10             	mov    0x10(%eax),%eax
    65c2:	85 c0                	test   %eax,%eax
    65c4:	74 64                	je     662a <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    65c6:	8b 45 14             	mov    0x14(%ebp),%eax
    65c9:	8b 40 10             	mov    0x10(%eax),%eax
    65cc:	8b 55 08             	mov    0x8(%ebp),%edx
    65cf:	8d 4a 04             	lea    0x4(%edx),%ecx
    65d2:	8b 55 08             	mov    0x8(%ebp),%edx
    65d5:	83 ec 0c             	sub    $0xc,%esp
    65d8:	ff 75 14             	pushl  0x14(%ebp)
    65db:	ff 75 10             	pushl  0x10(%ebp)
    65de:	ff 75 0c             	pushl  0xc(%ebp)
    65e1:	51                   	push   %ecx
    65e2:	52                   	push   %edx
    65e3:	ff d0                	call   *%eax
    65e5:	83 c4 20             	add    $0x20,%esp
    65e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    65eb:	8b 45 08             	mov    0x8(%ebp),%eax
    65ee:	8b 50 04             	mov    0x4(%eax),%edx
    65f1:	8b 45 08             	mov    0x8(%ebp),%eax
    65f4:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    65f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    65fb:	74 28                	je     6625 <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    65fd:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6604:	8b 45 14             	mov    0x14(%ebp),%eax
    6607:	8b 40 08             	mov    0x8(%eax),%eax
    660a:	85 c0                	test   %eax,%eax
    660c:	74 17                	je     6625 <inflatev+0x6f>
    660e:	8b 45 08             	mov    0x8(%ebp),%eax
    6611:	8b 50 04             	mov    0x4(%eax),%edx
    6614:	8b 45 14             	mov    0x14(%ebp),%eax
    6617:	8b 40 08             	mov    0x8(%eax),%eax
    661a:	39 c2                	cmp    %eax,%edx
    661c:	7e 07                	jle    6625 <inflatev+0x6f>
    661e:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    6625:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6628:	eb 14                	jmp    663e <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    662a:	ff 75 14             	pushl  0x14(%ebp)
    662d:	ff 75 10             	pushl  0x10(%ebp)
    6630:	ff 75 0c             	pushl  0xc(%ebp)
    6633:	ff 75 08             	pushl  0x8(%ebp)
    6636:	e8 39 fe ff ff       	call   6474 <lodepng_inflatev>
    663b:	83 c4 10             	add    $0x10,%esp
  }
}
    663e:	c9                   	leave  
    663f:	c3                   	ret    

00006640 <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    6640:	55                   	push   %ebp
    6641:	89 e5                	mov    %esp,%ebp
    6643:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    6646:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    664d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6650:	83 e8 01             	sub    $0x1,%eax
    6653:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    6656:	eb 39                	jmp    6691 <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    6658:	8b 55 fc             	mov    -0x4(%ebp),%edx
    665b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    665e:	01 d0                	add    %edx,%eax
    6660:	d1 f8                	sar    %eax
    6662:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    6665:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6668:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    666f:	8b 45 08             	mov    0x8(%ebp),%eax
    6672:	01 d0                	add    %edx,%eax
    6674:	8b 10                	mov    (%eax),%edx
    6676:	8b 45 10             	mov    0x10(%ebp),%eax
    6679:	39 c2                	cmp    %eax,%edx
    667b:	72 0b                	jb     6688 <searchCodeIndex+0x48>
    667d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6680:	83 e8 01             	sub    $0x1,%eax
    6683:	89 45 f8             	mov    %eax,-0x8(%ebp)
    6686:	eb 09                	jmp    6691 <searchCodeIndex+0x51>
    else left = mid + 1;
    6688:	8b 45 f4             	mov    -0xc(%ebp),%eax
    668b:	83 c0 01             	add    $0x1,%eax
    668e:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    6691:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6694:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6697:	7e bf                	jle    6658 <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    6699:	8b 45 fc             	mov    -0x4(%ebp),%eax
    669c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    669f:	7d 18                	jge    66b9 <searchCodeIndex+0x79>
    66a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    66a4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    66ab:	8b 45 08             	mov    0x8(%ebp),%eax
    66ae:	01 d0                	add    %edx,%eax
    66b0:	8b 10                	mov    (%eax),%edx
    66b2:	8b 45 10             	mov    0x10(%ebp),%eax
    66b5:	39 c2                	cmp    %eax,%edx
    66b7:	76 04                	jbe    66bd <searchCodeIndex+0x7d>
    66b9:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    66bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    66c0:	c9                   	leave  
    66c1:	c3                   	ret    

000066c2 <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    66c2:	55                   	push   %ebp
    66c3:	89 e5                	mov    %esp,%ebp
    66c5:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    66c8:	ff 75 0c             	pushl  0xc(%ebp)
    66cb:	6a 1d                	push   $0x1d
    66cd:	68 e0 a2 01 00       	push   $0x1a2e0
    66d2:	e8 69 ff ff ff       	call   6640 <searchCodeIndex>
    66d7:	83 c4 0c             	add    $0xc,%esp
    66da:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    66dd:	8b 55 0c             	mov    0xc(%ebp),%edx
    66e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    66e3:	8b 04 85 e0 a2 01 00 	mov    0x1a2e0(,%eax,4),%eax
    66ea:	29 c2                	sub    %eax,%edx
    66ec:	89 d0                	mov    %edx,%eax
    66ee:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    66f1:	ff 75 10             	pushl  0x10(%ebp)
    66f4:	6a 1e                	push   $0x1e
    66f6:	68 e0 a3 01 00       	push   $0x1a3e0
    66fb:	e8 40 ff ff ff       	call   6640 <searchCodeIndex>
    6700:	83 c4 0c             	add    $0xc,%esp
    6703:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    6706:	8b 55 10             	mov    0x10(%ebp),%edx
    6709:	8b 45 f4             	mov    -0xc(%ebp),%eax
    670c:	8b 04 85 e0 a3 01 00 	mov    0x1a3e0(,%eax,4),%eax
    6713:	29 c2                	sub    %eax,%edx
    6715:	89 d0                	mov    %edx,%eax
    6717:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    671a:	8b 45 08             	mov    0x8(%ebp),%eax
    671d:	8b 40 04             	mov    0x4(%eax),%eax
    6720:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    6723:	8b 45 08             	mov    0x8(%ebp),%eax
    6726:	8b 40 04             	mov    0x4(%eax),%eax
    6729:	83 c0 04             	add    $0x4,%eax
    672c:	50                   	push   %eax
    672d:	ff 75 08             	pushl  0x8(%ebp)
    6730:	e8 f0 d2 ff ff       	call   3a25 <uivector_resize>
    6735:	83 c4 08             	add    $0x8,%esp
    6738:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    673b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    673f:	74 57                	je     6798 <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    6741:	8b 45 08             	mov    0x8(%ebp),%eax
    6744:	8b 00                	mov    (%eax),%eax
    6746:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6749:	c1 e2 02             	shl    $0x2,%edx
    674c:	01 d0                	add    %edx,%eax
    674e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6751:	81 c2 01 01 00 00    	add    $0x101,%edx
    6757:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    6759:	8b 45 08             	mov    0x8(%ebp),%eax
    675c:	8b 00                	mov    (%eax),%eax
    675e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6761:	83 c2 01             	add    $0x1,%edx
    6764:	c1 e2 02             	shl    $0x2,%edx
    6767:	01 c2                	add    %eax,%edx
    6769:	8b 45 f8             	mov    -0x8(%ebp),%eax
    676c:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    676e:	8b 45 08             	mov    0x8(%ebp),%eax
    6771:	8b 00                	mov    (%eax),%eax
    6773:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6776:	83 c2 02             	add    $0x2,%edx
    6779:	c1 e2 02             	shl    $0x2,%edx
    677c:	01 c2                	add    %eax,%edx
    677e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6781:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    6783:	8b 45 08             	mov    0x8(%ebp),%eax
    6786:	8b 00                	mov    (%eax),%eax
    6788:	8b 55 ec             	mov    -0x14(%ebp),%edx
    678b:	83 c2 03             	add    $0x3,%edx
    678e:	c1 e2 02             	shl    $0x2,%edx
    6791:	01 c2                	add    %eax,%edx
    6793:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6796:	89 02                	mov    %eax,(%edx)
  }
}
    6798:	90                   	nop
    6799:	c9                   	leave  
    679a:	c3                   	ret    

0000679b <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    679b:	55                   	push   %ebp
    679c:	89 e5                	mov    %esp,%ebp
    679e:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    67a1:	b8 00 00 01 00       	mov    $0x10000,%eax
    67a6:	c1 e0 02             	shl    $0x2,%eax
    67a9:	83 ec 0c             	sub    $0xc,%esp
    67ac:	50                   	push   %eax
    67ad:	e8 f2 d0 ff ff       	call   38a4 <lodepng_malloc>
    67b2:	83 c4 10             	add    $0x10,%esp
    67b5:	89 c2                	mov    %eax,%edx
    67b7:	8b 45 08             	mov    0x8(%ebp),%eax
    67ba:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    67bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    67bf:	c1 e0 02             	shl    $0x2,%eax
    67c2:	83 ec 0c             	sub    $0xc,%esp
    67c5:	50                   	push   %eax
    67c6:	e8 d9 d0 ff ff       	call   38a4 <lodepng_malloc>
    67cb:	83 c4 10             	add    $0x10,%esp
    67ce:	89 c2                	mov    %eax,%edx
    67d0:	8b 45 08             	mov    0x8(%ebp),%eax
    67d3:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    67d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    67d9:	01 c0                	add    %eax,%eax
    67db:	83 ec 0c             	sub    $0xc,%esp
    67de:	50                   	push   %eax
    67df:	e8 c0 d0 ff ff       	call   38a4 <lodepng_malloc>
    67e4:	83 c4 10             	add    $0x10,%esp
    67e7:	89 c2                	mov    %eax,%edx
    67e9:	8b 45 08             	mov    0x8(%ebp),%eax
    67ec:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    67ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    67f2:	01 c0                	add    %eax,%eax
    67f4:	83 ec 0c             	sub    $0xc,%esp
    67f7:	50                   	push   %eax
    67f8:	e8 a7 d0 ff ff       	call   38a4 <lodepng_malloc>
    67fd:	83 c4 10             	add    $0x10,%esp
    6800:	89 c2                	mov    %eax,%edx
    6802:	8b 45 08             	mov    0x8(%ebp),%eax
    6805:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    6808:	b8 02 01 00 00       	mov    $0x102,%eax
    680d:	83 c0 01             	add    $0x1,%eax
    6810:	c1 e0 02             	shl    $0x2,%eax
    6813:	83 ec 0c             	sub    $0xc,%esp
    6816:	50                   	push   %eax
    6817:	e8 88 d0 ff ff       	call   38a4 <lodepng_malloc>
    681c:	83 c4 10             	add    $0x10,%esp
    681f:	89 c2                	mov    %eax,%edx
    6821:	8b 45 08             	mov    0x8(%ebp),%eax
    6824:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6827:	8b 45 0c             	mov    0xc(%ebp),%eax
    682a:	01 c0                	add    %eax,%eax
    682c:	83 ec 0c             	sub    $0xc,%esp
    682f:	50                   	push   %eax
    6830:	e8 6f d0 ff ff       	call   38a4 <lodepng_malloc>
    6835:	83 c4 10             	add    $0x10,%esp
    6838:	89 c2                	mov    %eax,%edx
    683a:	8b 45 08             	mov    0x8(%ebp),%eax
    683d:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    6840:	8b 45 08             	mov    0x8(%ebp),%eax
    6843:	8b 00                	mov    (%eax),%eax
    6845:	85 c0                	test   %eax,%eax
    6847:	74 32                	je     687b <hash_init+0xe0>
    6849:	8b 45 08             	mov    0x8(%ebp),%eax
    684c:	8b 40 04             	mov    0x4(%eax),%eax
    684f:	85 c0                	test   %eax,%eax
    6851:	74 28                	je     687b <hash_init+0xe0>
    6853:	8b 45 08             	mov    0x8(%ebp),%eax
    6856:	8b 40 08             	mov    0x8(%eax),%eax
    6859:	85 c0                	test   %eax,%eax
    685b:	74 1e                	je     687b <hash_init+0xe0>
    685d:	8b 45 08             	mov    0x8(%ebp),%eax
    6860:	8b 40 0c             	mov    0xc(%eax),%eax
    6863:	85 c0                	test   %eax,%eax
    6865:	74 14                	je     687b <hash_init+0xe0>
    6867:	8b 45 08             	mov    0x8(%ebp),%eax
    686a:	8b 40 10             	mov    0x10(%eax),%eax
    686d:	85 c0                	test   %eax,%eax
    686f:	74 0a                	je     687b <hash_init+0xe0>
    6871:	8b 45 08             	mov    0x8(%ebp),%eax
    6874:	8b 40 14             	mov    0x14(%eax),%eax
    6877:	85 c0                	test   %eax,%eax
    6879:	75 0a                	jne    6885 <hash_init+0xea>
    return 83; /*alloc fail*/
    687b:	b8 53 00 00 00       	mov    $0x53,%eax
    6880:	e9 d3 00 00 00       	jmp    6958 <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    6885:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    688c:	eb 17                	jmp    68a5 <hash_init+0x10a>
    688e:	8b 45 08             	mov    0x8(%ebp),%eax
    6891:	8b 00                	mov    (%eax),%eax
    6893:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6896:	c1 e2 02             	shl    $0x2,%edx
    6899:	01 d0                	add    %edx,%eax
    689b:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    68a1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    68a5:	b8 00 00 01 00       	mov    $0x10000,%eax
    68aa:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    68ad:	75 df                	jne    688e <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    68af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    68b6:	eb 18                	jmp    68d0 <hash_init+0x135>
    68b8:	8b 45 08             	mov    0x8(%ebp),%eax
    68bb:	8b 40 08             	mov    0x8(%eax),%eax
    68be:	8b 55 f4             	mov    -0xc(%ebp),%edx
    68c1:	c1 e2 02             	shl    $0x2,%edx
    68c4:	01 d0                	add    %edx,%eax
    68c6:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    68cc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    68d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    68d3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    68d6:	75 e0                	jne    68b8 <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    68d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    68df:	eb 17                	jmp    68f8 <hash_init+0x15d>
    68e1:	8b 45 08             	mov    0x8(%ebp),%eax
    68e4:	8b 40 04             	mov    0x4(%eax),%eax
    68e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    68ea:	01 d2                	add    %edx,%edx
    68ec:	01 d0                	add    %edx,%eax
    68ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
    68f1:	66 89 10             	mov    %dx,(%eax)
    68f4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    68f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    68fb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    68fe:	75 e1                	jne    68e1 <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    6900:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6907:	eb 18                	jmp    6921 <hash_init+0x186>
    6909:	8b 45 08             	mov    0x8(%ebp),%eax
    690c:	8b 40 0c             	mov    0xc(%eax),%eax
    690f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6912:	c1 e2 02             	shl    $0x2,%edx
    6915:	01 d0                	add    %edx,%eax
    6917:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    691d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6921:	b8 02 01 00 00       	mov    $0x102,%eax
    6926:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    6929:	76 de                	jbe    6909 <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    692b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6932:	eb 17                	jmp    694b <hash_init+0x1b0>
    6934:	8b 45 08             	mov    0x8(%ebp),%eax
    6937:	8b 40 10             	mov    0x10(%eax),%eax
    693a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    693d:	01 d2                	add    %edx,%edx
    693f:	01 d0                	add    %edx,%eax
    6941:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6944:	66 89 10             	mov    %dx,(%eax)
    6947:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    694b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    694e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6951:	75 e1                	jne    6934 <hash_init+0x199>

  return 0;
    6953:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6958:	c9                   	leave  
    6959:	c3                   	ret    

0000695a <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    695a:	55                   	push   %ebp
    695b:	89 e5                	mov    %esp,%ebp
    695d:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    6960:	8b 45 08             	mov    0x8(%ebp),%eax
    6963:	8b 00                	mov    (%eax),%eax
    6965:	83 ec 0c             	sub    $0xc,%esp
    6968:	50                   	push   %eax
    6969:	e8 57 cf ff ff       	call   38c5 <lodepng_free>
    696e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    6971:	8b 45 08             	mov    0x8(%ebp),%eax
    6974:	8b 40 08             	mov    0x8(%eax),%eax
    6977:	83 ec 0c             	sub    $0xc,%esp
    697a:	50                   	push   %eax
    697b:	e8 45 cf ff ff       	call   38c5 <lodepng_free>
    6980:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    6983:	8b 45 08             	mov    0x8(%ebp),%eax
    6986:	8b 40 04             	mov    0x4(%eax),%eax
    6989:	83 ec 0c             	sub    $0xc,%esp
    698c:	50                   	push   %eax
    698d:	e8 33 cf ff ff       	call   38c5 <lodepng_free>
    6992:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    6995:	8b 45 08             	mov    0x8(%ebp),%eax
    6998:	8b 40 14             	mov    0x14(%eax),%eax
    699b:	83 ec 0c             	sub    $0xc,%esp
    699e:	50                   	push   %eax
    699f:	e8 21 cf ff ff       	call   38c5 <lodepng_free>
    69a4:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    69a7:	8b 45 08             	mov    0x8(%ebp),%eax
    69aa:	8b 40 0c             	mov    0xc(%eax),%eax
    69ad:	83 ec 0c             	sub    $0xc,%esp
    69b0:	50                   	push   %eax
    69b1:	e8 0f cf ff ff       	call   38c5 <lodepng_free>
    69b6:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    69b9:	8b 45 08             	mov    0x8(%ebp),%eax
    69bc:	8b 40 10             	mov    0x10(%eax),%eax
    69bf:	83 ec 0c             	sub    $0xc,%esp
    69c2:	50                   	push   %eax
    69c3:	e8 fd ce ff ff       	call   38c5 <lodepng_free>
    69c8:	83 c4 10             	add    $0x10,%esp
}
    69cb:	90                   	nop
    69cc:	c9                   	leave  
    69cd:	c3                   	ret    

000069ce <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    69ce:	55                   	push   %ebp
    69cf:	89 e5                	mov    %esp,%ebp
    69d1:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    69d4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    69db:	8b 45 10             	mov    0x10(%ebp),%eax
    69de:	83 c0 02             	add    $0x2,%eax
    69e1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    69e4:	7d 41                	jge    6a27 <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    69e6:	8b 55 10             	mov    0x10(%ebp),%edx
    69e9:	8b 45 08             	mov    0x8(%ebp),%eax
    69ec:	01 d0                	add    %edx,%eax
    69ee:	0f b6 00             	movzbl (%eax),%eax
    69f1:	0f b6 c0             	movzbl %al,%eax
    69f4:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    69f7:	8b 45 10             	mov    0x10(%ebp),%eax
    69fa:	8d 50 01             	lea    0x1(%eax),%edx
    69fd:	8b 45 08             	mov    0x8(%ebp),%eax
    6a00:	01 d0                	add    %edx,%eax
    6a02:	0f b6 00             	movzbl (%eax),%eax
    6a05:	0f b6 c0             	movzbl %al,%eax
    6a08:	c1 e0 04             	shl    $0x4,%eax
    6a0b:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    6a0e:	8b 45 10             	mov    0x10(%ebp),%eax
    6a11:	8d 50 02             	lea    0x2(%eax),%edx
    6a14:	8b 45 08             	mov    0x8(%ebp),%eax
    6a17:	01 d0                	add    %edx,%eax
    6a19:	0f b6 00             	movzbl (%eax),%eax
    6a1c:	0f b6 c0             	movzbl %al,%eax
    6a1f:	c1 e0 08             	shl    $0x8,%eax
    6a22:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6a25:	eb 51                	jmp    6a78 <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    6a27:	8b 45 10             	mov    0x10(%ebp),%eax
    6a2a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6a2d:	7c 07                	jl     6a36 <getHash+0x68>
    6a2f:	b8 00 00 00 00       	mov    $0x0,%eax
    6a34:	eb 4a                	jmp    6a80 <getHash+0xb2>
    amount = size - pos;
    6a36:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a39:	2b 45 10             	sub    0x10(%ebp),%eax
    6a3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    6a3f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6a46:	eb 28                	jmp    6a70 <getHash+0xa2>
    6a48:	8b 55 10             	mov    0x10(%ebp),%edx
    6a4b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6a4e:	01 d0                	add    %edx,%eax
    6a50:	89 c2                	mov    %eax,%edx
    6a52:	8b 45 08             	mov    0x8(%ebp),%eax
    6a55:	01 d0                	add    %edx,%eax
    6a57:	0f b6 00             	movzbl (%eax),%eax
    6a5a:	0f b6 d0             	movzbl %al,%edx
    6a5d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6a60:	c1 e0 03             	shl    $0x3,%eax
    6a63:	89 c1                	mov    %eax,%ecx
    6a65:	d3 e2                	shl    %cl,%edx
    6a67:	89 d0                	mov    %edx,%eax
    6a69:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6a6c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6a70:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6a73:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    6a76:	75 d0                	jne    6a48 <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    6a78:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6a7d:	23 45 fc             	and    -0x4(%ebp),%eax
}
    6a80:	c9                   	leave  
    6a81:	c3                   	ret    

00006a82 <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    6a82:	55                   	push   %ebp
    6a83:	89 e5                	mov    %esp,%ebp
    6a85:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    6a88:	8b 55 10             	mov    0x10(%ebp),%edx
    6a8b:	8b 45 08             	mov    0x8(%ebp),%eax
    6a8e:	01 d0                	add    %edx,%eax
    6a90:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    6a93:	b8 02 01 00 00       	mov    $0x102,%eax
    6a98:	89 c2                	mov    %eax,%edx
    6a9a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6a9d:	01 d0                	add    %edx,%eax
    6a9f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    6aa2:	8b 55 0c             	mov    0xc(%ebp),%edx
    6aa5:	8b 45 08             	mov    0x8(%ebp),%eax
    6aa8:	01 d0                	add    %edx,%eax
    6aaa:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6aad:	73 0b                	jae    6aba <countZeros+0x38>
    6aaf:	8b 55 0c             	mov    0xc(%ebp),%edx
    6ab2:	8b 45 08             	mov    0x8(%ebp),%eax
    6ab5:	01 d0                	add    %edx,%eax
    6ab7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    6aba:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6abd:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    6ac0:	eb 04                	jmp    6ac6 <countZeros+0x44>
    6ac2:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    6ac6:	8b 45 08             	mov    0x8(%ebp),%eax
    6ac9:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6acc:	74 0a                	je     6ad8 <countZeros+0x56>
    6ace:	8b 45 08             	mov    0x8(%ebp),%eax
    6ad1:	0f b6 00             	movzbl (%eax),%eax
    6ad4:	84 c0                	test   %al,%al
    6ad6:	74 ea                	je     6ac2 <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    6ad8:	8b 55 08             	mov    0x8(%ebp),%edx
    6adb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6ade:	29 c2                	sub    %eax,%edx
    6ae0:	89 d0                	mov    %edx,%eax
}
    6ae2:	c9                   	leave  
    6ae3:	c3                   	ret    

00006ae4 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    6ae4:	55                   	push   %ebp
    6ae5:	89 e5                	mov    %esp,%ebp
    6ae7:	83 ec 04             	sub    $0x4,%esp
    6aea:	8b 45 14             	mov    0x14(%ebp),%eax
    6aed:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    6af1:	8b 45 08             	mov    0x8(%ebp),%eax
    6af4:	8b 40 08             	mov    0x8(%eax),%eax
    6af7:	8b 55 0c             	mov    0xc(%ebp),%edx
    6afa:	c1 e2 02             	shl    $0x2,%edx
    6afd:	01 c2                	add    %eax,%edx
    6aff:	8b 45 10             	mov    0x10(%ebp),%eax
    6b02:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    6b04:	8b 45 08             	mov    0x8(%ebp),%eax
    6b07:	8b 00                	mov    (%eax),%eax
    6b09:	8b 55 10             	mov    0x10(%ebp),%edx
    6b0c:	c1 e2 02             	shl    $0x2,%edx
    6b0f:	01 d0                	add    %edx,%eax
    6b11:	8b 00                	mov    (%eax),%eax
    6b13:	83 f8 ff             	cmp    $0xffffffff,%eax
    6b16:	74 1f                	je     6b37 <updateHashChain+0x53>
    6b18:	8b 45 08             	mov    0x8(%ebp),%eax
    6b1b:	8b 40 04             	mov    0x4(%eax),%eax
    6b1e:	8b 55 0c             	mov    0xc(%ebp),%edx
    6b21:	01 d2                	add    %edx,%edx
    6b23:	01 c2                	add    %eax,%edx
    6b25:	8b 45 08             	mov    0x8(%ebp),%eax
    6b28:	8b 00                	mov    (%eax),%eax
    6b2a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    6b2d:	c1 e1 02             	shl    $0x2,%ecx
    6b30:	01 c8                	add    %ecx,%eax
    6b32:	8b 00                	mov    (%eax),%eax
    6b34:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    6b37:	8b 45 08             	mov    0x8(%ebp),%eax
    6b3a:	8b 00                	mov    (%eax),%eax
    6b3c:	8b 55 10             	mov    0x10(%ebp),%edx
    6b3f:	c1 e2 02             	shl    $0x2,%edx
    6b42:	01 c2                	add    %eax,%edx
    6b44:	8b 45 0c             	mov    0xc(%ebp),%eax
    6b47:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    6b49:	8b 45 08             	mov    0x8(%ebp),%eax
    6b4c:	8b 40 14             	mov    0x14(%eax),%eax
    6b4f:	8b 55 0c             	mov    0xc(%ebp),%edx
    6b52:	01 d2                	add    %edx,%edx
    6b54:	01 c2                	add    %eax,%edx
    6b56:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    6b5a:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    6b5d:	8b 45 08             	mov    0x8(%ebp),%eax
    6b60:	8b 40 0c             	mov    0xc(%eax),%eax
    6b63:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    6b67:	c1 e2 02             	shl    $0x2,%edx
    6b6a:	01 d0                	add    %edx,%eax
    6b6c:	8b 00                	mov    (%eax),%eax
    6b6e:	83 f8 ff             	cmp    $0xffffffff,%eax
    6b71:	74 21                	je     6b94 <updateHashChain+0xb0>
    6b73:	8b 45 08             	mov    0x8(%ebp),%eax
    6b76:	8b 40 10             	mov    0x10(%eax),%eax
    6b79:	8b 55 0c             	mov    0xc(%ebp),%edx
    6b7c:	01 d2                	add    %edx,%edx
    6b7e:	01 c2                	add    %eax,%edx
    6b80:	8b 45 08             	mov    0x8(%ebp),%eax
    6b83:	8b 40 0c             	mov    0xc(%eax),%eax
    6b86:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    6b8a:	c1 e1 02             	shl    $0x2,%ecx
    6b8d:	01 c8                	add    %ecx,%eax
    6b8f:	8b 00                	mov    (%eax),%eax
    6b91:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    6b94:	8b 45 08             	mov    0x8(%ebp),%eax
    6b97:	8b 40 0c             	mov    0xc(%eax),%eax
    6b9a:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    6b9e:	c1 e2 02             	shl    $0x2,%edx
    6ba1:	01 c2                	add    %eax,%edx
    6ba3:	8b 45 0c             	mov    0xc(%ebp),%eax
    6ba6:	89 02                	mov    %eax,(%edx)
}
    6ba8:	90                   	nop
    6ba9:	c9                   	leave  
    6baa:	c3                   	ret    

00006bab <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    6bab:	55                   	push   %ebp
    6bac:	89 e5                	mov    %esp,%ebp
    6bae:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    6bb1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    6bb8:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6bbf:	77 08                	ja     6bc9 <encodeLZ77+0x1e>
    6bc1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6bc4:	c1 e8 03             	shr    $0x3,%eax
    6bc7:	eb 03                	jmp    6bcc <encodeLZ77+0x21>
    6bc9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6bcc:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    6bcf:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6bd6:	76 07                	jbe    6bdf <encodeLZ77+0x34>
    6bd8:	b8 02 01 00 00       	mov    $0x102,%eax
    6bdd:	eb 05                	jmp    6be4 <encodeLZ77+0x39>
    6bdf:	b8 40 00 00 00       	mov    $0x40,%eax
    6be4:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    6be7:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    6bee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    6bf5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    6bfc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    6c03:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    6c0a:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    6c0e:	74 09                	je     6c19 <encodeLZ77+0x6e>
    6c10:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    6c17:	76 0a                	jbe    6c23 <encodeLZ77+0x78>
    6c19:	b8 3c 00 00 00       	mov    $0x3c,%eax
    6c1e:	e9 e3 04 00 00       	jmp    7106 <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    6c23:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6c26:	83 e8 01             	sub    $0x1,%eax
    6c29:	23 45 1c             	and    0x1c(%ebp),%eax
    6c2c:	85 c0                	test   %eax,%eax
    6c2e:	74 0a                	je     6c3a <encodeLZ77+0x8f>
    6c30:	b8 5a 00 00 00       	mov    $0x5a,%eax
    6c35:	e9 cc 04 00 00       	jmp    7106 <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    6c3a:	b8 02 01 00 00       	mov    $0x102,%eax
    6c3f:	39 45 24             	cmp    %eax,0x24(%ebp)
    6c42:	76 08                	jbe    6c4c <encodeLZ77+0xa1>
    6c44:	b8 02 01 00 00       	mov    $0x102,%eax
    6c49:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    6c4c:	8b 45 14             	mov    0x14(%ebp),%eax
    6c4f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    6c52:	e9 a0 04 00 00       	jmp    70f7 <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    6c57:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6c5a:	8d 50 ff             	lea    -0x1(%eax),%edx
    6c5d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6c60:	21 d0                	and    %edx,%eax
    6c62:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    6c65:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    6c6c:	ff 75 fc             	pushl  -0x4(%ebp)
    6c6f:	ff 75 18             	pushl  0x18(%ebp)
    6c72:	ff 75 10             	pushl  0x10(%ebp)
    6c75:	e8 54 fd ff ff       	call   69ce <getHash>
    6c7a:	83 c4 0c             	add    $0xc,%esp
    6c7d:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    6c80:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6c84:	74 4e                	je     6cd4 <encodeLZ77+0x129>
    6c86:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6c8a:	75 48                	jne    6cd4 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6c8c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6c90:	75 16                	jne    6ca8 <encodeLZ77+0xfd>
    6c92:	ff 75 fc             	pushl  -0x4(%ebp)
    6c95:	ff 75 18             	pushl  0x18(%ebp)
    6c98:	ff 75 10             	pushl  0x10(%ebp)
    6c9b:	e8 e2 fd ff ff       	call   6a82 <countZeros>
    6ca0:	83 c4 0c             	add    $0xc,%esp
    6ca3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6ca6:	eb 35                	jmp    6cdd <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6ca8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6cab:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6cae:	01 c2                	add    %eax,%edx
    6cb0:	8b 45 18             	mov    0x18(%ebp),%eax
    6cb3:	39 c2                	cmp    %eax,%edx
    6cb5:	77 17                	ja     6cce <encodeLZ77+0x123>
    6cb7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6cba:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6cbd:	01 d0                	add    %edx,%eax
    6cbf:	8d 50 ff             	lea    -0x1(%eax),%edx
    6cc2:	8b 45 10             	mov    0x10(%ebp),%eax
    6cc5:	01 d0                	add    %edx,%eax
    6cc7:	0f b6 00             	movzbl (%eax),%eax
    6cca:	84 c0                	test   %al,%al
    6ccc:	74 0f                	je     6cdd <encodeLZ77+0x132>
    6cce:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6cd2:	eb 09                	jmp    6cdd <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    6cd4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6cdb:	eb 01                	jmp    6cde <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6cdd:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    6cde:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ce1:	0f b7 c0             	movzwl %ax,%eax
    6ce4:	50                   	push   %eax
    6ce5:	ff 75 b0             	pushl  -0x50(%ebp)
    6ce8:	ff 75 b4             	pushl  -0x4c(%ebp)
    6ceb:	ff 75 0c             	pushl  0xc(%ebp)
    6cee:	e8 f1 fd ff ff       	call   6ae4 <updateHashChain>
    6cf3:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    6cf6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    6cfd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    6d04:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d07:	8b 40 04             	mov    0x4(%eax),%eax
    6d0a:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    6d0d:	01 d2                	add    %edx,%edx
    6d0f:	01 d0                	add    %edx,%eax
    6d11:	0f b7 00             	movzwl (%eax),%eax
    6d14:	0f b7 c0             	movzwl %ax,%eax
    6d17:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    6d1a:	ba 02 01 00 00       	mov    $0x102,%edx
    6d1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6d22:	01 c2                	add    %eax,%edx
    6d24:	8b 45 18             	mov    0x18(%ebp),%eax
    6d27:	39 c2                	cmp    %eax,%edx
    6d29:	0f 4e c2             	cmovle %edx,%eax
    6d2c:	89 c2                	mov    %eax,%edx
    6d2e:	8b 45 10             	mov    0x10(%ebp),%eax
    6d31:	01 d0                	add    %edx,%eax
    6d33:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    6d36:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6d3d:	8b 45 c8             	mov    -0x38(%ebp),%eax
    6d40:	8d 50 01             	lea    0x1(%eax),%edx
    6d43:	89 55 c8             	mov    %edx,-0x38(%ebp)
    6d46:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    6d49:	0f 83 67 01 00 00    	jae    6eb6 <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    6d4f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6d52:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    6d55:	77 08                	ja     6d5f <encodeLZ77+0x1b4>
    6d57:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6d5a:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6d5d:	eb 0d                	jmp    6d6c <encodeLZ77+0x1c1>
    6d5f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6d62:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6d65:	89 c2                	mov    %eax,%edx
    6d67:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6d6a:	01 d0                	add    %edx,%eax
    6d6c:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6d6f:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6d72:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6d75:	0f 82 3e 01 00 00    	jb     6eb9 <encodeLZ77+0x30e>
      prev_offset = current_offset;
    6d7b:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6d7e:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    6d81:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    6d85:	0f 84 a3 00 00 00    	je     6e2e <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    6d8b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d8e:	8b 45 10             	mov    0x10(%ebp),%eax
    6d91:	01 d0                	add    %edx,%eax
    6d93:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    6d96:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6d99:	2b 45 a8             	sub    -0x58(%ebp),%eax
    6d9c:	89 c2                	mov    %eax,%edx
    6d9e:	8b 45 10             	mov    0x10(%ebp),%eax
    6da1:	01 d0                	add    %edx,%eax
    6da3:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    6da6:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6daa:	76 3a                	jbe    6de6 <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    6dac:	8b 45 0c             	mov    0xc(%ebp),%eax
    6daf:	8b 40 14             	mov    0x14(%eax),%eax
    6db2:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6db5:	01 d2                	add    %edx,%edx
    6db7:	01 d0                	add    %edx,%eax
    6db9:	0f b7 00             	movzwl (%eax),%eax
    6dbc:	0f b7 c0             	movzwl %ax,%eax
    6dbf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    6dc2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6dc5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6dc8:	76 06                	jbe    6dd0 <encodeLZ77+0x225>
    6dca:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6dcd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    6dd0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6dd3:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    6dd6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6dd9:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6ddc:	eb 08                	jmp    6de6 <encodeLZ77+0x23b>
          ++backptr;
    6dde:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    6de2:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6de6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6de9:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    6dec:	74 10                	je     6dfe <encodeLZ77+0x253>
    6dee:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6df1:	0f b6 10             	movzbl (%eax),%edx
    6df4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6df7:	0f b6 00             	movzbl (%eax),%eax
    6dfa:	38 c2                	cmp    %al,%dl
    6dfc:	74 e0                	je     6dde <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    6dfe:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6e01:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    6e04:	8b 55 10             	mov    0x10(%ebp),%edx
    6e07:	01 ca                	add    %ecx,%edx
    6e09:	29 d0                	sub    %edx,%eax
    6e0b:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    6e0e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6e11:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6e14:	76 18                	jbe    6e2e <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    6e16:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6e19:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    6e1c:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6e1f:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6e22:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6e25:	3b 45 24             	cmp    0x24(%ebp),%eax
    6e28:	0f 83 8e 00 00 00    	jae    6ebc <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6e2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e31:	8b 40 04             	mov    0x4(%eax),%eax
    6e34:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6e37:	01 d2                	add    %edx,%edx
    6e39:	01 d0                	add    %edx,%eax
    6e3b:	0f b7 00             	movzwl (%eax),%eax
    6e3e:	0f b7 c0             	movzwl %ax,%eax
    6e41:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    6e44:	74 79                	je     6ebf <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    6e46:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6e4a:	76 38                	jbe    6e84 <encodeLZ77+0x2d9>
    6e4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6e4f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6e52:	76 30                	jbe    6e84 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    6e54:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e57:	8b 40 10             	mov    0x10(%eax),%eax
    6e5a:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6e5d:	01 d2                	add    %edx,%edx
    6e5f:	01 d0                	add    %edx,%eax
    6e61:	0f b7 00             	movzwl (%eax),%eax
    6e64:	0f b7 c0             	movzwl %ax,%eax
    6e67:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    6e6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e6d:	8b 40 14             	mov    0x14(%eax),%eax
    6e70:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6e73:	01 d2                	add    %edx,%edx
    6e75:	01 d0                	add    %edx,%eax
    6e77:	0f b7 00             	movzwl (%eax),%eax
    6e7a:	0f b7 c0             	movzwl %ax,%eax
    6e7d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6e80:	74 2f                	je     6eb1 <encodeLZ77+0x306>
    6e82:	eb 3f                	jmp    6ec3 <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    6e84:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e87:	8b 40 04             	mov    0x4(%eax),%eax
    6e8a:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6e8d:	01 d2                	add    %edx,%edx
    6e8f:	01 d0                	add    %edx,%eax
    6e91:	0f b7 00             	movzwl (%eax),%eax
    6e94:	0f b7 c0             	movzwl %ax,%eax
    6e97:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6e9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e9d:	8b 40 08             	mov    0x8(%eax),%eax
    6ea0:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6ea3:	c1 e2 02             	shl    $0x2,%edx
    6ea6:	01 d0                	add    %edx,%eax
    6ea8:	8b 10                	mov    (%eax),%edx
    6eaa:	8b 45 b0             	mov    -0x50(%ebp),%eax
    6ead:	39 c2                	cmp    %eax,%edx
    6eaf:	75 11                	jne    6ec2 <encodeLZ77+0x317>
      }
    }
    6eb1:	e9 87 fe ff ff       	jmp    6d3d <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6eb6:	90                   	nop
    6eb7:	eb 0a                	jmp    6ec3 <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6eb9:	90                   	nop
    6eba:	eb 07                	jmp    6ec3 <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6ebc:	90                   	nop
    6ebd:	eb 04                	jmp    6ec3 <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6ebf:	90                   	nop
    6ec0:	eb 01                	jmp    6ec3 <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6ec2:	90                   	nop
      }
    }

    if(lazymatching) {
    6ec3:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    6ec7:	0f 84 c8 00 00 00    	je     6f95 <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    6ecd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6ed1:	75 30                	jne    6f03 <encodeLZ77+0x358>
    6ed3:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6ed7:	76 2a                	jbe    6f03 <encodeLZ77+0x358>
    6ed9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6edc:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    6edf:	77 22                	ja     6f03 <encodeLZ77+0x358>
    6ee1:	b8 02 01 00 00       	mov    $0x102,%eax
    6ee6:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6ee9:	73 18                	jae    6f03 <encodeLZ77+0x358>
        lazy = 1;
    6eeb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    6ef2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6ef5:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    6ef8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6efb:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    6efe:	e9 f0 01 00 00       	jmp    70f3 <encodeLZ77+0x548>
      }
      if(lazy) {
    6f03:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6f07:	0f 84 88 00 00 00    	je     6f95 <encodeLZ77+0x3ea>
        lazy = 0;
    6f0d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    6f14:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    6f18:	75 0c                	jne    6f26 <encodeLZ77+0x37b>
    6f1a:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    6f21:	e9 dd 01 00 00       	jmp    7103 <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    6f26:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6f29:	83 c0 01             	add    $0x1,%eax
    6f2c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6f2f:	73 2d                	jae    6f5e <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    6f31:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6f34:	8d 50 ff             	lea    -0x1(%eax),%edx
    6f37:	8b 45 10             	mov    0x10(%ebp),%eax
    6f3a:	01 d0                	add    %edx,%eax
    6f3c:	0f b6 00             	movzbl (%eax),%eax
    6f3f:	0f b6 c0             	movzbl %al,%eax
    6f42:	50                   	push   %eax
    6f43:	ff 75 08             	pushl  0x8(%ebp)
    6f46:	e8 6f cb ff ff       	call   3aba <uivector_push_back>
    6f4b:	83 c4 08             	add    $0x8,%esp
    6f4e:	85 c0                	test   %eax,%eax
    6f50:	75 43                	jne    6f95 <encodeLZ77+0x3ea>
    6f52:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6f59:	e9 a5 01 00 00       	jmp    7103 <encodeLZ77+0x558>
        } else {
          length = lazylength;
    6f5e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6f61:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    6f64:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6f67:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    6f6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    6f6d:	8b 00                	mov    (%eax),%eax
    6f6f:	8b 55 b0             	mov    -0x50(%ebp),%edx
    6f72:	c1 e2 02             	shl    $0x2,%edx
    6f75:	01 d0                	add    %edx,%eax
    6f77:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    6f7d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6f80:	8b 40 0c             	mov    0xc(%eax),%eax
    6f83:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6f86:	c1 e2 02             	shl    $0x2,%edx
    6f89:	01 d0                	add    %edx,%eax
    6f8b:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    6f91:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    6f95:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6f99:	76 14                	jbe    6faf <encodeLZ77+0x404>
    6f9b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6f9e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    6fa1:	76 0c                	jbe    6faf <encodeLZ77+0x404>
    6fa3:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    6faa:	e9 54 01 00 00       	jmp    7103 <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    6faf:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6fb3:	77 2e                	ja     6fe3 <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6fb5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6fb8:	8b 45 10             	mov    0x10(%ebp),%eax
    6fbb:	01 d0                	add    %edx,%eax
    6fbd:	0f b6 00             	movzbl (%eax),%eax
    6fc0:	0f b6 c0             	movzbl %al,%eax
    6fc3:	50                   	push   %eax
    6fc4:	ff 75 08             	pushl  0x8(%ebp)
    6fc7:	e8 ee ca ff ff       	call   3aba <uivector_push_back>
    6fcc:	83 c4 08             	add    $0x8,%esp
    6fcf:	85 c0                	test   %eax,%eax
    6fd1:	0f 85 1c 01 00 00    	jne    70f3 <encodeLZ77+0x548>
    6fd7:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6fde:	e9 20 01 00 00       	jmp    7103 <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    6fe3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6fe6:	3b 45 20             	cmp    0x20(%ebp),%eax
    6fe9:	72 0f                	jb     6ffa <encodeLZ77+0x44f>
    6feb:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    6fef:	75 37                	jne    7028 <encodeLZ77+0x47d>
    6ff1:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    6ff8:	76 2e                	jbe    7028 <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6ffa:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6ffd:	8b 45 10             	mov    0x10(%ebp),%eax
    7000:	01 d0                	add    %edx,%eax
    7002:	0f b6 00             	movzbl (%eax),%eax
    7005:	0f b6 c0             	movzbl %al,%eax
    7008:	50                   	push   %eax
    7009:	ff 75 08             	pushl  0x8(%ebp)
    700c:	e8 a9 ca ff ff       	call   3aba <uivector_push_back>
    7011:	83 c4 08             	add    $0x8,%esp
    7014:	85 c0                	test   %eax,%eax
    7016:	0f 85 d7 00 00 00    	jne    70f3 <encodeLZ77+0x548>
    701c:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7023:	e9 db 00 00 00       	jmp    7103 <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    7028:	8b 55 ec             	mov    -0x14(%ebp),%edx
    702b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    702e:	52                   	push   %edx
    702f:	50                   	push   %eax
    7030:	ff 75 08             	pushl  0x8(%ebp)
    7033:	e8 8a f6 ff ff       	call   66c2 <addLengthDistance>
    7038:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    703b:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    7042:	e9 a0 00 00 00       	jmp    70e7 <encodeLZ77+0x53c>
        ++pos;
    7047:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    704b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    704e:	8d 50 ff             	lea    -0x1(%eax),%edx
    7051:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7054:	21 d0                	and    %edx,%eax
    7056:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    7059:	ff 75 fc             	pushl  -0x4(%ebp)
    705c:	ff 75 18             	pushl  0x18(%ebp)
    705f:	ff 75 10             	pushl  0x10(%ebp)
    7062:	e8 67 f9 ff ff       	call   69ce <getHash>
    7067:	83 c4 0c             	add    $0xc,%esp
    706a:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    706d:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    7071:	74 4e                	je     70c1 <encodeLZ77+0x516>
    7073:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    7077:	75 48                	jne    70c1 <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    7079:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    707d:	75 16                	jne    7095 <encodeLZ77+0x4ea>
    707f:	ff 75 fc             	pushl  -0x4(%ebp)
    7082:	ff 75 18             	pushl  0x18(%ebp)
    7085:	ff 75 10             	pushl  0x10(%ebp)
    7088:	e8 f5 f9 ff ff       	call   6a82 <countZeros>
    708d:	83 c4 0c             	add    $0xc,%esp
    7090:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7093:	eb 35                	jmp    70ca <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    7095:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7098:	8b 45 f0             	mov    -0x10(%ebp),%eax
    709b:	01 c2                	add    %eax,%edx
    709d:	8b 45 18             	mov    0x18(%ebp),%eax
    70a0:	39 c2                	cmp    %eax,%edx
    70a2:	77 17                	ja     70bb <encodeLZ77+0x510>
    70a4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    70a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    70aa:	01 d0                	add    %edx,%eax
    70ac:	8d 50 ff             	lea    -0x1(%eax),%edx
    70af:	8b 45 10             	mov    0x10(%ebp),%eax
    70b2:	01 d0                	add    %edx,%eax
    70b4:	0f b6 00             	movzbl (%eax),%eax
    70b7:	84 c0                	test   %al,%al
    70b9:	74 0f                	je     70ca <encodeLZ77+0x51f>
    70bb:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    70bf:	eb 09                	jmp    70ca <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    70c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    70c8:	eb 01                	jmp    70cb <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    70ca:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    70cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    70ce:	0f b7 c0             	movzwl %ax,%eax
    70d1:	50                   	push   %eax
    70d2:	ff 75 b0             	pushl  -0x50(%ebp)
    70d5:	ff 75 b4             	pushl  -0x4c(%ebp)
    70d8:	ff 75 0c             	pushl  0xc(%ebp)
    70db:	e8 04 fa ff ff       	call   6ae4 <updateHashChain>
    70e0:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    70e3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    70e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    70ea:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    70ed:	0f 82 54 ff ff ff    	jb     7047 <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    70f3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    70f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    70fa:	3b 45 18             	cmp    0x18(%ebp),%eax
    70fd:	0f 8c 54 fb ff ff    	jl     6c57 <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    7103:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7106:	c9                   	leave  
    7107:	c3                   	ret    

00007108 <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    7108:	55                   	push   %ebp
    7109:	89 e5                	mov    %esp,%ebp
    710b:	53                   	push   %ebx
    710c:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    710f:	8b 45 10             	mov    0x10(%ebp),%eax
    7112:	05 fe ff 00 00       	add    $0xfffe,%eax
    7117:	ba 01 80 00 80       	mov    $0x80008001,%edx
    711c:	f7 e2                	mul    %edx
    711e:	89 d0                	mov    %edx,%eax
    7120:	c1 e8 0f             	shr    $0xf,%eax
    7123:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    7126:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    712d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    7134:	e9 1b 01 00 00       	jmp    7254 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    7139:	8b 45 08             	mov    0x8(%ebp),%eax
    713c:	8b 40 04             	mov    0x4(%eax),%eax
    713f:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    7142:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7145:	83 e8 01             	sub    $0x1,%eax
    7148:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    714b:	0f 94 c0             	sete   %al
    714e:	0f b6 c0             	movzbl %al,%eax
    7151:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    7154:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    715b:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    7162:	8b 45 10             	mov    0x10(%ebp),%eax
    7165:	2b 45 f4             	sub    -0xc(%ebp),%eax
    7168:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    716d:	77 09                	ja     7178 <deflateNoCompression+0x70>
    716f:	8b 45 10             	mov    0x10(%ebp),%eax
    7172:	2b 45 f4             	sub    -0xc(%ebp),%eax
    7175:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    7178:	b8 ff ff 00 00       	mov    $0xffff,%eax
    717d:	2b 45 f0             	sub    -0x10(%ebp),%eax
    7180:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    7183:	8b 45 08             	mov    0x8(%ebp),%eax
    7186:	8b 40 04             	mov    0x4(%eax),%eax
    7189:	89 c2                	mov    %eax,%edx
    718b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    718e:	01 d0                	add    %edx,%eax
    7190:	83 c0 05             	add    $0x5,%eax
    7193:	50                   	push   %eax
    7194:	ff 75 08             	pushl  0x8(%ebp)
    7197:	e8 62 c9 ff ff       	call   3afe <ucvector_resize>
    719c:	83 c4 08             	add    $0x8,%esp
    719f:	85 c0                	test   %eax,%eax
    71a1:	75 0a                	jne    71ad <deflateNoCompression+0xa5>
    71a3:	b8 53 00 00 00       	mov    $0x53,%eax
    71a8:	e9 b8 00 00 00       	jmp    7265 <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    71ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    71b0:	89 c2                	mov    %eax,%edx
    71b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    71b5:	83 e0 01             	and    $0x1,%eax
    71b8:	01 c0                	add    %eax,%eax
    71ba:	01 c2                	add    %eax,%edx
    71bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
    71bf:	83 e0 02             	and    $0x2,%eax
    71c2:	01 c0                	add    %eax,%eax
    71c4:	01 d0                	add    %edx,%eax
    71c6:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    71c9:	8b 45 08             	mov    0x8(%ebp),%eax
    71cc:	8b 10                	mov    (%eax),%edx
    71ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71d1:	01 c2                	add    %eax,%edx
    71d3:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    71d7:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    71d9:	8b 45 08             	mov    0x8(%ebp),%eax
    71dc:	8b 00                	mov    (%eax),%eax
    71de:	8b 55 e8             	mov    -0x18(%ebp),%edx
    71e1:	83 c2 01             	add    $0x1,%edx
    71e4:	01 d0                	add    %edx,%eax
    71e6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    71e9:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    71eb:	8b 45 08             	mov    0x8(%ebp),%eax
    71ee:	8b 00                	mov    (%eax),%eax
    71f0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    71f3:	83 c2 02             	add    $0x2,%edx
    71f6:	01 d0                	add    %edx,%eax
    71f8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    71fb:	c1 ea 08             	shr    $0x8,%edx
    71fe:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    7200:	8b 45 08             	mov    0x8(%ebp),%eax
    7203:	8b 00                	mov    (%eax),%eax
    7205:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7208:	83 c2 03             	add    $0x3,%edx
    720b:	01 d0                	add    %edx,%eax
    720d:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7210:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    7212:	8b 45 08             	mov    0x8(%ebp),%eax
    7215:	8b 00                	mov    (%eax),%eax
    7217:	8b 55 e8             	mov    -0x18(%ebp),%edx
    721a:	83 c2 04             	add    $0x4,%edx
    721d:	01 d0                	add    %edx,%eax
    721f:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7222:	c1 ea 08             	shr    $0x8,%edx
    7225:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    7227:	8b 45 f0             	mov    -0x10(%ebp),%eax
    722a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    722d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7230:	01 d1                	add    %edx,%ecx
    7232:	8b 55 08             	mov    0x8(%ebp),%edx
    7235:	8b 12                	mov    (%edx),%edx
    7237:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    723a:	83 c3 05             	add    $0x5,%ebx
    723d:	01 da                	add    %ebx,%edx
    723f:	50                   	push   %eax
    7240:	51                   	push   %ecx
    7241:	52                   	push   %edx
    7242:	e8 9b c6 ff ff       	call   38e2 <lodepng_memcpy>
    7247:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    724a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    724d:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    7250:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    7254:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7257:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    725a:	0f 85 d9 fe ff ff    	jne    7139 <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    7260:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7265:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7268:	c9                   	leave  
    7269:	c3                   	ret    

0000726a <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    726a:	55                   	push   %ebp
    726b:	89 e5                	mov    %esp,%ebp
    726d:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    7270:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    7277:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    727e:	e9 10 01 00 00       	jmp    7393 <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    7283:	8b 45 0c             	mov    0xc(%ebp),%eax
    7286:	8b 00                	mov    (%eax),%eax
    7288:	8b 55 fc             	mov    -0x4(%ebp),%edx
    728b:	c1 e2 02             	shl    $0x2,%edx
    728e:	01 d0                	add    %edx,%eax
    7290:	8b 00                	mov    (%eax),%eax
    7292:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    7295:	8b 45 10             	mov    0x10(%ebp),%eax
    7298:	8b 40 04             	mov    0x4(%eax),%eax
    729b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    729e:	c1 e2 02             	shl    $0x2,%edx
    72a1:	01 d0                	add    %edx,%eax
    72a3:	8b 00                	mov    (%eax),%eax
    72a5:	89 c1                	mov    %eax,%ecx
    72a7:	8b 45 10             	mov    0x10(%ebp),%eax
    72aa:	8b 00                	mov    (%eax),%eax
    72ac:	8b 55 f8             	mov    -0x8(%ebp),%edx
    72af:	c1 e2 02             	shl    $0x2,%edx
    72b2:	01 d0                	add    %edx,%eax
    72b4:	8b 00                	mov    (%eax),%eax
    72b6:	51                   	push   %ecx
    72b7:	50                   	push   %eax
    72b8:	ff 75 08             	pushl  0x8(%ebp)
    72bb:	e8 60 cc ff ff       	call   3f20 <writeBitsReversed>
    72c0:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    72c3:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    72ca:	0f 86 bf 00 00 00    	jbe    738f <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    72d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    72d3:	2d 01 01 00 00       	sub    $0x101,%eax
    72d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    72db:	8b 45 f4             	mov    -0xc(%ebp),%eax
    72de:	8b 04 85 60 a3 01 00 	mov    0x1a360(,%eax,4),%eax
    72e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    72e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    72eb:	8b 00                	mov    (%eax),%eax
    72ed:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    72f1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    72f4:	c1 e2 02             	shl    $0x2,%edx
    72f7:	01 d0                	add    %edx,%eax
    72f9:	8b 00                	mov    (%eax),%eax
    72fb:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    72fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    7301:	8b 00                	mov    (%eax),%eax
    7303:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7307:	8b 55 fc             	mov    -0x4(%ebp),%edx
    730a:	c1 e2 02             	shl    $0x2,%edx
    730d:	01 d0                	add    %edx,%eax
    730f:	8b 00                	mov    (%eax),%eax
    7311:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    7314:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7317:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    731a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    731d:	8b 04 85 60 a4 01 00 	mov    0x1a460(,%eax,4),%eax
    7324:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    7327:	8b 45 0c             	mov    0xc(%ebp),%eax
    732a:	8b 00                	mov    (%eax),%eax
    732c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7330:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7333:	c1 e2 02             	shl    $0x2,%edx
    7336:	01 d0                	add    %edx,%eax
    7338:	8b 00                	mov    (%eax),%eax
    733a:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    733d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7340:	50                   	push   %eax
    7341:	ff 75 ec             	pushl  -0x14(%ebp)
    7344:	ff 75 08             	pushl  0x8(%ebp)
    7347:	e8 40 ca ff ff       	call   3d8c <writeBits>
    734c:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    734f:	8b 45 14             	mov    0x14(%ebp),%eax
    7352:	8b 40 04             	mov    0x4(%eax),%eax
    7355:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7358:	c1 e2 02             	shl    $0x2,%edx
    735b:	01 d0                	add    %edx,%eax
    735d:	8b 00                	mov    (%eax),%eax
    735f:	89 c1                	mov    %eax,%ecx
    7361:	8b 45 14             	mov    0x14(%ebp),%eax
    7364:	8b 00                	mov    (%eax),%eax
    7366:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7369:	c1 e2 02             	shl    $0x2,%edx
    736c:	01 d0                	add    %edx,%eax
    736e:	8b 00                	mov    (%eax),%eax
    7370:	51                   	push   %ecx
    7371:	50                   	push   %eax
    7372:	ff 75 08             	pushl  0x8(%ebp)
    7375:	e8 a6 cb ff ff       	call   3f20 <writeBitsReversed>
    737a:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    737d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7380:	50                   	push   %eax
    7381:	ff 75 dc             	pushl  -0x24(%ebp)
    7384:	ff 75 08             	pushl  0x8(%ebp)
    7387:	e8 00 ca ff ff       	call   3d8c <writeBits>
    738c:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    738f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7393:	8b 45 0c             	mov    0xc(%ebp),%eax
    7396:	8b 40 04             	mov    0x4(%eax),%eax
    7399:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    739c:	0f 85 e1 fe ff ff    	jne    7283 <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    73a2:	90                   	nop
    73a3:	c9                   	leave  
    73a4:	c3                   	ret    

000073a5 <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    73a5:	55                   	push   %ebp
    73a6:	89 e5                	mov    %esp,%ebp
    73a8:	53                   	push   %ebx
    73a9:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    73af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    73b6:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    73bd:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    73c4:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    73cb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    73d2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    73d9:	8b 45 18             	mov    0x18(%ebp),%eax
    73dc:	2b 45 14             	sub    0x14(%ebp),%eax
    73df:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    73e2:	8b 45 20             	mov    0x20(%ebp),%eax
    73e5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    73e8:	8d 45 90             	lea    -0x70(%ebp),%eax
    73eb:	50                   	push   %eax
    73ec:	e8 a4 c6 ff ff       	call   3a95 <uivector_init>
    73f1:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    73f4:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    73fa:	50                   	push   %eax
    73fb:	e8 98 d3 ff ff       	call   4798 <HuffmanTree_init>
    7400:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    7403:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7409:	50                   	push   %eax
    740a:	e8 89 d3 ff ff       	call   4798 <HuffmanTree_init>
    740f:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    7412:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7418:	50                   	push   %eax
    7419:	e8 7a d3 ff ff       	call   4798 <HuffmanTree_init>
    741e:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    7421:	83 ec 0c             	sub    $0xc,%esp
    7424:	68 78 04 00 00       	push   $0x478
    7429:	e8 76 c4 ff ff       	call   38a4 <lodepng_malloc>
    742e:	83 c4 10             	add    $0x10,%esp
    7431:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    7434:	83 ec 0c             	sub    $0xc,%esp
    7437:	6a 78                	push   $0x78
    7439:	e8 66 c4 ff ff       	call   38a4 <lodepng_malloc>
    743e:	83 c4 10             	add    $0x10,%esp
    7441:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    7444:	83 ec 0c             	sub    $0xc,%esp
    7447:	6a 4c                	push   $0x4c
    7449:	e8 56 c4 ff ff       	call   38a4 <lodepng_malloc>
    744e:	83 c4 10             	add    $0x10,%esp
    7451:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    7454:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    7458:	74 0c                	je     7466 <deflateDynamic+0xc1>
    745a:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    745e:	74 06                	je     7466 <deflateDynamic+0xc1>
    7460:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    7464:	75 07                	jne    746d <deflateDynamic+0xc8>
    7466:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    746d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7471:	0f 85 f6 07 00 00    	jne    7c6d <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    7477:	83 ec 04             	sub    $0x4,%esp
    747a:	68 78 04 00 00       	push   $0x478
    747f:	6a 00                	push   $0x0
    7481:	ff 75 d4             	pushl  -0x2c(%ebp)
    7484:	e8 8c c4 ff ff       	call   3915 <lodepng_memset>
    7489:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    748c:	83 ec 04             	sub    $0x4,%esp
    748f:	6a 78                	push   $0x78
    7491:	6a 00                	push   $0x0
    7493:	ff 75 d0             	pushl  -0x30(%ebp)
    7496:	e8 7a c4 ff ff       	call   3915 <lodepng_memset>
    749b:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    749e:	83 ec 04             	sub    $0x4,%esp
    74a1:	6a 4c                	push   $0x4c
    74a3:	6a 00                	push   $0x0
    74a5:	ff 75 cc             	pushl  -0x34(%ebp)
    74a8:	e8 68 c4 ff ff       	call   3915 <lodepng_memset>
    74ad:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    74b0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    74b3:	8b 40 04             	mov    0x4(%eax),%eax
    74b6:	85 c0                	test   %eax,%eax
    74b8:	74 45                	je     74ff <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    74ba:	8b 45 1c             	mov    0x1c(%ebp),%eax
    74bd:	8b 58 14             	mov    0x14(%eax),%ebx
    74c0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    74c3:	8b 48 10             	mov    0x10(%eax),%ecx
    74c6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    74c9:	8b 50 0c             	mov    0xc(%eax),%edx
    74cc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    74cf:	8b 40 08             	mov    0x8(%eax),%eax
    74d2:	83 ec 0c             	sub    $0xc,%esp
    74d5:	53                   	push   %ebx
    74d6:	51                   	push   %ecx
    74d7:	52                   	push   %edx
    74d8:	50                   	push   %eax
    74d9:	ff 75 18             	pushl  0x18(%ebp)
    74dc:	ff 75 14             	pushl  0x14(%ebp)
    74df:	ff 75 10             	pushl  0x10(%ebp)
    74e2:	ff 75 0c             	pushl  0xc(%ebp)
    74e5:	8d 45 90             	lea    -0x70(%ebp),%eax
    74e8:	50                   	push   %eax
    74e9:	e8 bd f6 ff ff       	call   6bab <encodeLZ77>
    74ee:	83 c4 30             	add    $0x30,%esp
    74f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    74f4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    74f8:	74 59                	je     7553 <deflateDynamic+0x1ae>
    74fa:	e9 6e 07 00 00       	jmp    7c6d <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    74ff:	83 ec 08             	sub    $0x8,%esp
    7502:	ff 75 c8             	pushl  -0x38(%ebp)
    7505:	8d 45 90             	lea    -0x70(%ebp),%eax
    7508:	50                   	push   %eax
    7509:	e8 17 c5 ff ff       	call   3a25 <uivector_resize>
    750e:	83 c4 10             	add    $0x10,%esp
    7511:	85 c0                	test   %eax,%eax
    7513:	75 0c                	jne    7521 <deflateDynamic+0x17c>
    7515:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    751c:	e9 4c 07 00 00       	jmp    7c6d <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    7521:	8b 45 14             	mov    0x14(%ebp),%eax
    7524:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7527:	eb 22                	jmp    754b <deflateDynamic+0x1a6>
    7529:	8b 55 90             	mov    -0x70(%ebp),%edx
    752c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    752f:	2b 45 14             	sub    0x14(%ebp),%eax
    7532:	c1 e0 02             	shl    $0x2,%eax
    7535:	01 c2                	add    %eax,%edx
    7537:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    753a:	8b 45 10             	mov    0x10(%ebp),%eax
    753d:	01 c8                	add    %ecx,%eax
    753f:	0f b6 00             	movzbl (%eax),%eax
    7542:	0f b6 c0             	movzbl %al,%eax
    7545:	89 02                	mov    %eax,(%edx)
    7547:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    754b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    754e:	3b 45 18             	cmp    0x18(%ebp),%eax
    7551:	7c d6                	jl     7529 <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    7553:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    755a:	eb 60                	jmp    75bc <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    755c:	8b 45 90             	mov    -0x70(%ebp),%eax
    755f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7562:	c1 e2 02             	shl    $0x2,%edx
    7565:	01 d0                	add    %edx,%eax
    7567:	8b 00                	mov    (%eax),%eax
    7569:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    756c:	8b 45 c0             	mov    -0x40(%ebp),%eax
    756f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7576:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7579:	01 d0                	add    %edx,%eax
    757b:	8b 10                	mov    (%eax),%edx
    757d:	83 c2 01             	add    $0x1,%edx
    7580:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    7582:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    7589:	76 2d                	jbe    75b8 <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    758b:	8b 45 90             	mov    -0x70(%ebp),%eax
    758e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7591:	83 c2 02             	add    $0x2,%edx
    7594:	c1 e2 02             	shl    $0x2,%edx
    7597:	01 d0                	add    %edx,%eax
    7599:	8b 00                	mov    (%eax),%eax
    759b:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    759e:	8b 45 bc             	mov    -0x44(%ebp),%eax
    75a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75a8:	8b 45 d0             	mov    -0x30(%ebp),%eax
    75ab:	01 d0                	add    %edx,%eax
    75ad:	8b 10                	mov    (%eax),%edx
    75af:	83 c2 01             	add    $0x1,%edx
    75b2:	89 10                	mov    %edx,(%eax)
        i += 3;
    75b4:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    75b8:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    75bc:	8b 45 94             	mov    -0x6c(%ebp),%eax
    75bf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    75c2:	75 98                	jne    755c <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    75c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    75c7:	05 00 04 00 00       	add    $0x400,%eax
    75cc:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    75d2:	83 ec 0c             	sub    $0xc,%esp
    75d5:	6a 0f                	push   $0xf
    75d7:	68 1e 01 00 00       	push   $0x11e
    75dc:	68 01 01 00 00       	push   $0x101
    75e1:	ff 75 d4             	pushl  -0x2c(%ebp)
    75e4:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    75ea:	50                   	push   %eax
    75eb:	e8 e0 e1 ff ff       	call   57d0 <HuffmanTree_makeFromFrequencies>
    75f0:	83 c4 20             	add    $0x20,%esp
    75f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    75f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    75fa:	0f 85 66 06 00 00    	jne    7c66 <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    7600:	83 ec 0c             	sub    $0xc,%esp
    7603:	6a 0f                	push   $0xf
    7605:	6a 1e                	push   $0x1e
    7607:	6a 02                	push   $0x2
    7609:	ff 75 d0             	pushl  -0x30(%ebp)
    760c:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7612:	50                   	push   %eax
    7613:	e8 b8 e1 ff ff       	call   57d0 <HuffmanTree_makeFromFrequencies>
    7618:	83 c4 20             	add    $0x20,%esp
    761b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    761e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7622:	0f 85 41 06 00 00    	jne    7c69 <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    7628:	8b 45 84             	mov    -0x7c(%ebp),%eax
    762b:	ba 1e 01 00 00       	mov    $0x11e,%edx
    7630:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    7635:	0f 47 c2             	cmova  %edx,%eax
    7638:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    763b:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    7641:	ba 1e 00 00 00       	mov    $0x1e,%edx
    7646:	83 f8 1e             	cmp    $0x1e,%eax
    7649:	0f 47 c2             	cmova  %edx,%eax
    764c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    764f:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7652:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7655:	01 d0                	add    %edx,%eax
    7657:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    765a:	8b 45 b0             	mov    -0x50(%ebp),%eax
    765d:	c1 e0 02             	shl    $0x2,%eax
    7660:	83 ec 0c             	sub    $0xc,%esp
    7663:	50                   	push   %eax
    7664:	e8 3b c2 ff ff       	call   38a4 <lodepng_malloc>
    7669:	83 c4 10             	add    $0x10,%esp
    766c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    766f:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7672:	c1 e0 02             	shl    $0x2,%eax
    7675:	83 ec 0c             	sub    $0xc,%esp
    7678:	50                   	push   %eax
    7679:	e8 26 c2 ff ff       	call   38a4 <lodepng_malloc>
    767e:	83 c4 10             	add    $0x10,%esp
    7681:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    7684:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7688:	74 06                	je     7690 <deflateDynamic+0x2eb>
    768a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    768e:	75 0c                	jne    769c <deflateDynamic+0x2f7>
    7690:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7697:	e9 d1 05 00 00       	jmp    7c6d <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    769c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    76a3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    76aa:	eb 25                	jmp    76d1 <deflateDynamic+0x32c>
    76ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76af:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    76b9:	01 c2                	add    %eax,%edx
    76bb:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    76c1:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    76c4:	c1 e1 02             	shl    $0x2,%ecx
    76c7:	01 c8                	add    %ecx,%eax
    76c9:	8b 00                	mov    (%eax),%eax
    76cb:	89 02                	mov    %eax,(%edx)
    76cd:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    76d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76d4:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    76d7:	75 d3                	jne    76ac <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    76d9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    76e0:	eb 2a                	jmp    770c <deflateDynamic+0x367>
    76e2:	8b 55 b8             	mov    -0x48(%ebp),%edx
    76e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76e8:	01 d0                	add    %edx,%eax
    76ea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    76f4:	01 c2                	add    %eax,%edx
    76f6:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    76fc:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    76ff:	c1 e1 02             	shl    $0x2,%ecx
    7702:	01 c8                	add    %ecx,%eax
    7704:	8b 00                	mov    (%eax),%eax
    7706:	89 02                	mov    %eax,(%edx)
    7708:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    770c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    770f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    7712:	75 ce                	jne    76e2 <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7714:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    771b:	e9 3b 02 00 00       	jmp    795b <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    7720:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    7727:	eb 04                	jmp    772d <deflateDynamic+0x388>
    7729:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    772d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7730:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7733:	01 d0                	add    %edx,%eax
    7735:	8d 50 01             	lea    0x1(%eax),%edx
    7738:	8b 45 b0             	mov    -0x50(%ebp),%eax
    773b:	39 c2                	cmp    %eax,%edx
    773d:	73 2e                	jae    776d <deflateDynamic+0x3c8>
    773f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7742:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7745:	01 d0                	add    %edx,%eax
    7747:	83 c0 01             	add    $0x1,%eax
    774a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7751:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7754:	01 d0                	add    %edx,%eax
    7756:	8b 10                	mov    (%eax),%edx
    7758:	8b 45 e8             	mov    -0x18(%ebp),%eax
    775b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7762:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7765:	01 c8                	add    %ecx,%eax
    7767:	8b 00                	mov    (%eax),%eax
    7769:	39 c2                	cmp    %eax,%edx
    776b:	74 bc                	je     7729 <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    776d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7770:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7777:	8b 45 f0             	mov    -0x10(%ebp),%eax
    777a:	01 d0                	add    %edx,%eax
    777c:	8b 00                	mov    (%eax),%eax
    777e:	85 c0                	test   %eax,%eax
    7780:	0f 85 a9 00 00 00    	jne    782f <deflateDynamic+0x48a>
    7786:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    778a:	0f 86 9f 00 00 00    	jbe    782f <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    7790:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    7794:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    7798:	77 3a                	ja     77d4 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    779a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    779d:	8d 50 01             	lea    0x1(%eax),%edx
    77a0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    77a3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    77aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    77ad:	01 d0                	add    %edx,%eax
    77af:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    77b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    77b8:	8d 50 01             	lea    0x1(%eax),%edx
    77bb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    77be:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    77c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    77c8:	01 d0                	add    %edx,%eax
    77ca:	8b 55 dc             	mov    -0x24(%ebp),%edx
    77cd:	83 ea 03             	sub    $0x3,%edx
    77d0:	89 10                	mov    %edx,(%eax)
    77d2:	eb 48                	jmp    781c <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    77d4:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    77db:	76 07                	jbe    77e4 <deflateDynamic+0x43f>
    77dd:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    77e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    77e7:	8d 50 01             	lea    0x1(%eax),%edx
    77ea:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    77ed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    77f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    77f7:	01 d0                	add    %edx,%eax
    77f9:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    77ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7802:	8d 50 01             	lea    0x1(%eax),%edx
    7805:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7808:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    780f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7812:	01 d0                	add    %edx,%eax
    7814:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7817:	83 ea 0b             	sub    $0xb,%edx
    781a:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    781c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    781f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7822:	01 d0                	add    %edx,%eax
    7824:	83 e8 01             	sub    $0x1,%eax
    7827:	89 45 e8             	mov    %eax,-0x18(%ebp)
    782a:	e9 28 01 00 00       	jmp    7957 <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    782f:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    7833:	0f 86 f6 00 00 00    	jbe    792f <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    7839:	8b 45 dc             	mov    -0x24(%ebp),%eax
    783c:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    7841:	f7 e2                	mul    %edx
    7843:	89 d0                	mov    %edx,%eax
    7845:	c1 e8 02             	shr    $0x2,%eax
    7848:	89 45 ac             	mov    %eax,-0x54(%ebp)
    784b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    784e:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    7853:	89 c8                	mov    %ecx,%eax
    7855:	f7 e2                	mul    %edx
    7857:	c1 ea 02             	shr    $0x2,%edx
    785a:	89 d0                	mov    %edx,%eax
    785c:	01 c0                	add    %eax,%eax
    785e:	01 d0                	add    %edx,%eax
    7860:	01 c0                	add    %eax,%eax
    7862:	29 c1                	sub    %eax,%ecx
    7864:	89 c8                	mov    %ecx,%eax
    7866:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    7869:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    786c:	8d 50 01             	lea    0x1(%eax),%edx
    786f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7872:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7879:	8b 45 ec             	mov    -0x14(%ebp),%eax
    787c:	01 c2                	add    %eax,%edx
    787e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7881:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7888:	8b 45 f0             	mov    -0x10(%ebp),%eax
    788b:	01 c8                	add    %ecx,%eax
    788d:	8b 00                	mov    (%eax),%eax
    788f:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    7891:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    7898:	eb 3a                	jmp    78d4 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    789a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    789d:	8d 50 01             	lea    0x1(%eax),%edx
    78a0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    78a3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    78aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    78ad:	01 d0                	add    %edx,%eax
    78af:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    78b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    78b8:	8d 50 01             	lea    0x1(%eax),%edx
    78bb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    78be:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    78c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    78c8:	01 d0                	add    %edx,%eax
    78ca:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    78d0:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    78d4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    78d7:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    78da:	72 be                	jb     789a <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    78dc:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    78e0:	76 3a                	jbe    791c <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    78e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    78e5:	8d 50 01             	lea    0x1(%eax),%edx
    78e8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    78eb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    78f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    78f5:	01 d0                	add    %edx,%eax
    78f7:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    78fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7900:	8d 50 01             	lea    0x1(%eax),%edx
    7903:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7906:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    790d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7910:	01 d0                	add    %edx,%eax
    7912:	8b 55 a8             	mov    -0x58(%ebp),%edx
    7915:	83 ea 03             	sub    $0x3,%edx
    7918:	89 10                	mov    %edx,(%eax)
    791a:	eb 06                	jmp    7922 <deflateDynamic+0x57d>
        }
        else j -= rest;
    791c:	8b 45 a8             	mov    -0x58(%ebp),%eax
    791f:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    7922:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7925:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7928:	01 d0                	add    %edx,%eax
    792a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    792d:	eb 28                	jmp    7957 <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    792f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7932:	8d 50 01             	lea    0x1(%eax),%edx
    7935:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7938:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    793f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7942:	01 c2                	add    %eax,%edx
    7944:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7947:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    794e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7951:	01 c8                	add    %ecx,%eax
    7953:	8b 00                	mov    (%eax),%eax
    7955:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7957:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    795b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    795e:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    7961:	0f 85 b9 fd ff ff    	jne    7720 <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7967:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    796e:	eb 42                	jmp    79b2 <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    7970:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7973:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    797a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    797d:	01 d0                	add    %edx,%eax
    797f:	8b 00                	mov    (%eax),%eax
    7981:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7988:	8b 45 cc             	mov    -0x34(%ebp),%eax
    798b:	01 d0                	add    %edx,%eax
    798d:	8b 10                	mov    (%eax),%edx
    798f:	83 c2 01             	add    $0x1,%edx
    7992:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    7994:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7997:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    799e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    79a1:	01 d0                	add    %edx,%eax
    79a3:	8b 00                	mov    (%eax),%eax
    79a5:	83 f8 0f             	cmp    $0xf,%eax
    79a8:	76 04                	jbe    79ae <deflateDynamic+0x609>
    79aa:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    79ae:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    79b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    79b5:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    79b8:	75 b6                	jne    7970 <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    79ba:	83 ec 0c             	sub    $0xc,%esp
    79bd:	6a 07                	push   $0x7
    79bf:	6a 13                	push   $0x13
    79c1:	6a 13                	push   $0x13
    79c3:	ff 75 cc             	pushl  -0x34(%ebp)
    79c6:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    79cc:	50                   	push   %eax
    79cd:	e8 fe dd ff ff       	call   57d0 <HuffmanTree_makeFromFrequencies>
    79d2:	83 c4 20             	add    $0x20,%esp
    79d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    79d8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    79dc:	0f 85 8a 02 00 00    	jne    7c6c <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    79e2:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    79e9:	eb 04                	jmp    79ef <deflateDynamic+0x64a>
      numcodes_cl--;
    79eb:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    79ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
    79f2:	83 f8 04             	cmp    $0x4,%eax
    79f5:	76 1e                	jbe    7a15 <deflateDynamic+0x670>
    79f7:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    79fd:	8b 55 e0             	mov    -0x20(%ebp),%edx
    7a00:	83 ea 01             	sub    $0x1,%edx
    7a03:	8b 14 95 e0 a4 01 00 	mov    0x1a4e0(,%edx,4),%edx
    7a0a:	c1 e2 02             	shl    $0x2,%edx
    7a0d:	01 d0                	add    %edx,%eax
    7a0f:	8b 00                	mov    (%eax),%eax
    7a11:	85 c0                	test   %eax,%eax
    7a13:	74 d6                	je     79eb <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    7a15:	83 ec 04             	sub    $0x4,%esp
    7a18:	6a 01                	push   $0x1
    7a1a:	ff 75 c4             	pushl  -0x3c(%ebp)
    7a1d:	ff 75 08             	pushl  0x8(%ebp)
    7a20:	e8 67 c3 ff ff       	call   3d8c <writeBits>
    7a25:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    7a28:	83 ec 04             	sub    $0x4,%esp
    7a2b:	6a 01                	push   $0x1
    7a2d:	6a 00                	push   $0x0
    7a2f:	ff 75 08             	pushl  0x8(%ebp)
    7a32:	e8 55 c3 ff ff       	call   3d8c <writeBits>
    7a37:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    7a3a:	83 ec 04             	sub    $0x4,%esp
    7a3d:	6a 01                	push   $0x1
    7a3f:	6a 01                	push   $0x1
    7a41:	ff 75 08             	pushl  0x8(%ebp)
    7a44:	e8 43 c3 ff ff       	call   3d8c <writeBits>
    7a49:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    7a4c:	8b 45 b8             	mov    -0x48(%ebp),%eax
    7a4f:	2d 01 01 00 00       	sub    $0x101,%eax
    7a54:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    7a57:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7a5a:	83 e8 01             	sub    $0x1,%eax
    7a5d:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    7a60:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7a63:	83 e8 04             	sub    $0x4,%eax
    7a66:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    7a69:	83 ec 04             	sub    $0x4,%esp
    7a6c:	6a 05                	push   $0x5
    7a6e:	ff 75 a4             	pushl  -0x5c(%ebp)
    7a71:	ff 75 08             	pushl  0x8(%ebp)
    7a74:	e8 13 c3 ff ff       	call   3d8c <writeBits>
    7a79:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    7a7c:	83 ec 04             	sub    $0x4,%esp
    7a7f:	6a 05                	push   $0x5
    7a81:	ff 75 a0             	pushl  -0x60(%ebp)
    7a84:	ff 75 08             	pushl  0x8(%ebp)
    7a87:	e8 00 c3 ff ff       	call   3d8c <writeBits>
    7a8c:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    7a8f:	83 ec 04             	sub    $0x4,%esp
    7a92:	6a 04                	push   $0x4
    7a94:	ff 75 9c             	pushl  -0x64(%ebp)
    7a97:	ff 75 08             	pushl  0x8(%ebp)
    7a9a:	e8 ed c2 ff ff       	call   3d8c <writeBits>
    7a9f:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    7aa2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7aa9:	eb 2c                	jmp    7ad7 <deflateDynamic+0x732>
    7aab:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    7ab1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7ab4:	8b 04 85 e0 a4 01 00 	mov    0x1a4e0(,%eax,4),%eax
    7abb:	c1 e0 02             	shl    $0x2,%eax
    7abe:	01 d0                	add    %edx,%eax
    7ac0:	8b 00                	mov    (%eax),%eax
    7ac2:	83 ec 04             	sub    $0x4,%esp
    7ac5:	6a 03                	push   $0x3
    7ac7:	50                   	push   %eax
    7ac8:	ff 75 08             	pushl  0x8(%ebp)
    7acb:	e8 bc c2 ff ff       	call   3d8c <writeBits>
    7ad0:	83 c4 10             	add    $0x10,%esp
    7ad3:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7ad7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7ada:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    7add:	75 cc                	jne    7aab <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7adf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7ae6:	e9 0a 01 00 00       	jmp    7bf5 <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    7aeb:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7af1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7af4:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    7afb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7afe:	01 ca                	add    %ecx,%edx
    7b00:	8b 12                	mov    (%edx),%edx
    7b02:	c1 e2 02             	shl    $0x2,%edx
    7b05:	01 d0                	add    %edx,%eax
    7b07:	8b 00                	mov    (%eax),%eax
    7b09:	89 c3                	mov    %eax,%ebx
    7b0b:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    7b11:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7b14:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    7b1b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7b1e:	01 ca                	add    %ecx,%edx
    7b20:	8b 12                	mov    (%edx),%edx
    7b22:	c1 e2 02             	shl    $0x2,%edx
    7b25:	01 d0                	add    %edx,%eax
    7b27:	8b 00                	mov    (%eax),%eax
    7b29:	83 ec 04             	sub    $0x4,%esp
    7b2c:	53                   	push   %ebx
    7b2d:	50                   	push   %eax
    7b2e:	ff 75 08             	pushl  0x8(%ebp)
    7b31:	e8 ea c3 ff ff       	call   3f20 <writeBitsReversed>
    7b36:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    7b39:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7b3c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7b43:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7b46:	01 d0                	add    %edx,%eax
    7b48:	8b 00                	mov    (%eax),%eax
    7b4a:	83 f8 10             	cmp    $0x10,%eax
    7b4d:	75 28                	jne    7b77 <deflateDynamic+0x7d2>
    7b4f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7b53:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7b56:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7b5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7b60:	01 d0                	add    %edx,%eax
    7b62:	8b 00                	mov    (%eax),%eax
    7b64:	83 ec 04             	sub    $0x4,%esp
    7b67:	6a 02                	push   $0x2
    7b69:	50                   	push   %eax
    7b6a:	ff 75 08             	pushl  0x8(%ebp)
    7b6d:	e8 1a c2 ff ff       	call   3d8c <writeBits>
    7b72:	83 c4 10             	add    $0x10,%esp
    7b75:	eb 7a                	jmp    7bf1 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    7b77:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7b7a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7b81:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7b84:	01 d0                	add    %edx,%eax
    7b86:	8b 00                	mov    (%eax),%eax
    7b88:	83 f8 11             	cmp    $0x11,%eax
    7b8b:	75 28                	jne    7bb5 <deflateDynamic+0x810>
    7b8d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7b91:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7b94:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7b9b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7b9e:	01 d0                	add    %edx,%eax
    7ba0:	8b 00                	mov    (%eax),%eax
    7ba2:	83 ec 04             	sub    $0x4,%esp
    7ba5:	6a 03                	push   $0x3
    7ba7:	50                   	push   %eax
    7ba8:	ff 75 08             	pushl  0x8(%ebp)
    7bab:	e8 dc c1 ff ff       	call   3d8c <writeBits>
    7bb0:	83 c4 10             	add    $0x10,%esp
    7bb3:	eb 3c                	jmp    7bf1 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    7bb5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7bb8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7bbf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7bc2:	01 d0                	add    %edx,%eax
    7bc4:	8b 00                	mov    (%eax),%eax
    7bc6:	83 f8 12             	cmp    $0x12,%eax
    7bc9:	75 26                	jne    7bf1 <deflateDynamic+0x84c>
    7bcb:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7bcf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7bd2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7bd9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7bdc:	01 d0                	add    %edx,%eax
    7bde:	8b 00                	mov    (%eax),%eax
    7be0:	83 ec 04             	sub    $0x4,%esp
    7be3:	6a 07                	push   $0x7
    7be5:	50                   	push   %eax
    7be6:	ff 75 08             	pushl  0x8(%ebp)
    7be9:	e8 9e c1 ff ff       	call   3d8c <writeBits>
    7bee:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7bf1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7bf5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7bf8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7bfb:	0f 85 ea fe ff ff    	jne    7aeb <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7c01:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7c07:	50                   	push   %eax
    7c08:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7c0e:	50                   	push   %eax
    7c0f:	8d 45 90             	lea    -0x70(%ebp),%eax
    7c12:	50                   	push   %eax
    7c13:	ff 75 08             	pushl  0x8(%ebp)
    7c16:	e8 4f f6 ff ff       	call   726a <writeLZ77data>
    7c1b:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    7c1e:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7c24:	05 00 04 00 00       	add    $0x400,%eax
    7c29:	8b 00                	mov    (%eax),%eax
    7c2b:	85 c0                	test   %eax,%eax
    7c2d:	75 09                	jne    7c38 <deflateDynamic+0x893>
    7c2f:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    7c36:	eb 35                	jmp    7c6d <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    7c38:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7c3e:	05 00 04 00 00       	add    $0x400,%eax
    7c43:	8b 00                	mov    (%eax),%eax
    7c45:	89 c2                	mov    %eax,%edx
    7c47:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    7c4d:	05 00 04 00 00       	add    $0x400,%eax
    7c52:	8b 00                	mov    (%eax),%eax
    7c54:	83 ec 04             	sub    $0x4,%esp
    7c57:	52                   	push   %edx
    7c58:	50                   	push   %eax
    7c59:	ff 75 08             	pushl  0x8(%ebp)
    7c5c:	e8 bf c2 ff ff       	call   3f20 <writeBitsReversed>
    7c61:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    7c64:	eb 07                	jmp    7c6d <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    7c66:	90                   	nop
    7c67:	eb 04                	jmp    7c6d <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    7c69:	90                   	nop
    7c6a:	eb 01                	jmp    7c6d <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    7c6c:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    7c6d:	83 ec 0c             	sub    $0xc,%esp
    7c70:	8d 45 90             	lea    -0x70(%ebp),%eax
    7c73:	50                   	push   %eax
    7c74:	e8 73 bd ff ff       	call   39ec <uivector_cleanup>
    7c79:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    7c7c:	83 ec 0c             	sub    $0xc,%esp
    7c7f:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7c85:	50                   	push   %eax
    7c86:	e8 3a cb ff ff       	call   47c5 <HuffmanTree_cleanup>
    7c8b:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7c8e:	83 ec 0c             	sub    $0xc,%esp
    7c91:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7c97:	50                   	push   %eax
    7c98:	e8 28 cb ff ff       	call   47c5 <HuffmanTree_cleanup>
    7c9d:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    7ca0:	83 ec 0c             	sub    $0xc,%esp
    7ca3:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7ca9:	50                   	push   %eax
    7caa:	e8 16 cb ff ff       	call   47c5 <HuffmanTree_cleanup>
    7caf:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    7cb2:	83 ec 0c             	sub    $0xc,%esp
    7cb5:	ff 75 d4             	pushl  -0x2c(%ebp)
    7cb8:	e8 08 bc ff ff       	call   38c5 <lodepng_free>
    7cbd:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    7cc0:	83 ec 0c             	sub    $0xc,%esp
    7cc3:	ff 75 d0             	pushl  -0x30(%ebp)
    7cc6:	e8 fa bb ff ff       	call   38c5 <lodepng_free>
    7ccb:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    7cce:	83 ec 0c             	sub    $0xc,%esp
    7cd1:	ff 75 cc             	pushl  -0x34(%ebp)
    7cd4:	e8 ec bb ff ff       	call   38c5 <lodepng_free>
    7cd9:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    7cdc:	83 ec 0c             	sub    $0xc,%esp
    7cdf:	ff 75 f0             	pushl  -0x10(%ebp)
    7ce2:	e8 de bb ff ff       	call   38c5 <lodepng_free>
    7ce7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    7cea:	83 ec 0c             	sub    $0xc,%esp
    7ced:	ff 75 ec             	pushl  -0x14(%ebp)
    7cf0:	e8 d0 bb ff ff       	call   38c5 <lodepng_free>
    7cf5:	83 c4 10             	add    $0x10,%esp

  return error;
    7cf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7cfb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7cfe:	c9                   	leave  
    7cff:	c3                   	ret    

00007d00 <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    7d00:	55                   	push   %ebp
    7d01:	89 e5                	mov    %esp,%ebp
    7d03:	53                   	push   %ebx
    7d04:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    7d07:	8b 45 20             	mov    0x20(%ebp),%eax
    7d0a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    7d0d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    7d14:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7d17:	50                   	push   %eax
    7d18:	e8 7b ca ff ff       	call   4798 <HuffmanTree_init>
    7d1d:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    7d20:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7d23:	50                   	push   %eax
    7d24:	e8 6f ca ff ff       	call   4798 <HuffmanTree_init>
    7d29:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    7d2c:	83 ec 0c             	sub    $0xc,%esp
    7d2f:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7d32:	50                   	push   %eax
    7d33:	e8 41 db ff ff       	call   5879 <generateFixedLitLenTree>
    7d38:	83 c4 10             	add    $0x10,%esp
    7d3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    7d3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7d42:	75 12                	jne    7d56 <deflateFixed+0x56>
    7d44:	83 ec 0c             	sub    $0xc,%esp
    7d47:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7d4a:	50                   	push   %eax
    7d4b:	e8 30 dc ff ff       	call   5980 <generateFixedDistanceTree>
    7d50:	83 c4 10             	add    $0x10,%esp
    7d53:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7d56:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7d5a:	0f 85 3a 01 00 00    	jne    7e9a <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    7d60:	83 ec 04             	sub    $0x4,%esp
    7d63:	6a 01                	push   $0x1
    7d65:	ff 75 ec             	pushl  -0x14(%ebp)
    7d68:	ff 75 08             	pushl  0x8(%ebp)
    7d6b:	e8 1c c0 ff ff       	call   3d8c <writeBits>
    7d70:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    7d73:	83 ec 04             	sub    $0x4,%esp
    7d76:	6a 01                	push   $0x1
    7d78:	6a 01                	push   $0x1
    7d7a:	ff 75 08             	pushl  0x8(%ebp)
    7d7d:	e8 0a c0 ff ff       	call   3d8c <writeBits>
    7d82:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    7d85:	83 ec 04             	sub    $0x4,%esp
    7d88:	6a 01                	push   $0x1
    7d8a:	6a 00                	push   $0x0
    7d8c:	ff 75 08             	pushl  0x8(%ebp)
    7d8f:	e8 f8 bf ff ff       	call   3d8c <writeBits>
    7d94:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    7d97:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7d9a:	8b 40 04             	mov    0x4(%eax),%eax
    7d9d:	85 c0                	test   %eax,%eax
    7d9f:	74 77                	je     7e18 <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    7da1:	83 ec 0c             	sub    $0xc,%esp
    7da4:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7da7:	50                   	push   %eax
    7da8:	e8 e8 bc ff ff       	call   3a95 <uivector_init>
    7dad:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    7db0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7db3:	8b 58 14             	mov    0x14(%eax),%ebx
    7db6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7db9:	8b 48 10             	mov    0x10(%eax),%ecx
    7dbc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7dbf:	8b 50 0c             	mov    0xc(%eax),%edx
    7dc2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7dc5:	8b 40 08             	mov    0x8(%eax),%eax
    7dc8:	83 ec 0c             	sub    $0xc,%esp
    7dcb:	53                   	push   %ebx
    7dcc:	51                   	push   %ecx
    7dcd:	52                   	push   %edx
    7dce:	50                   	push   %eax
    7dcf:	ff 75 18             	pushl  0x18(%ebp)
    7dd2:	ff 75 14             	pushl  0x14(%ebp)
    7dd5:	ff 75 10             	pushl  0x10(%ebp)
    7dd8:	ff 75 0c             	pushl  0xc(%ebp)
    7ddb:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7dde:	50                   	push   %eax
    7ddf:	e8 c7 ed ff ff       	call   6bab <encodeLZ77>
    7de4:	83 c4 30             	add    $0x30,%esp
    7de7:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7dea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7dee:	75 17                	jne    7e07 <deflateFixed+0x107>
    7df0:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7df3:	50                   	push   %eax
    7df4:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7df7:	50                   	push   %eax
    7df8:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7dfb:	50                   	push   %eax
    7dfc:	ff 75 08             	pushl  0x8(%ebp)
    7dff:	e8 66 f4 ff ff       	call   726a <writeLZ77data>
    7e04:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    7e07:	83 ec 0c             	sub    $0xc,%esp
    7e0a:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7e0d:	50                   	push   %eax
    7e0e:	e8 d9 bb ff ff       	call   39ec <uivector_cleanup>
    7e13:	83 c4 10             	add    $0x10,%esp
    7e16:	eb 56                	jmp    7e6e <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7e18:	8b 45 14             	mov    0x14(%ebp),%eax
    7e1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7e1e:	eb 46                	jmp    7e66 <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    7e20:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7e23:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7e26:	8b 55 10             	mov    0x10(%ebp),%edx
    7e29:	01 ca                	add    %ecx,%edx
    7e2b:	0f b6 12             	movzbl (%edx),%edx
    7e2e:	0f b6 d2             	movzbl %dl,%edx
    7e31:	c1 e2 02             	shl    $0x2,%edx
    7e34:	01 d0                	add    %edx,%eax
    7e36:	8b 00                	mov    (%eax),%eax
    7e38:	89 c3                	mov    %eax,%ebx
    7e3a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7e3d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7e40:	8b 55 10             	mov    0x10(%ebp),%edx
    7e43:	01 ca                	add    %ecx,%edx
    7e45:	0f b6 12             	movzbl (%edx),%edx
    7e48:	0f b6 d2             	movzbl %dl,%edx
    7e4b:	c1 e2 02             	shl    $0x2,%edx
    7e4e:	01 d0                	add    %edx,%eax
    7e50:	8b 00                	mov    (%eax),%eax
    7e52:	83 ec 04             	sub    $0x4,%esp
    7e55:	53                   	push   %ebx
    7e56:	50                   	push   %eax
    7e57:	ff 75 08             	pushl  0x8(%ebp)
    7e5a:	e8 c1 c0 ff ff       	call   3f20 <writeBitsReversed>
    7e5f:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7e62:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7e66:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7e69:	3b 45 18             	cmp    0x18(%ebp),%eax
    7e6c:	7c b2                	jl     7e20 <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    7e6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7e72:	75 26                	jne    7e9a <deflateFixed+0x19a>
    7e74:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7e77:	05 00 04 00 00       	add    $0x400,%eax
    7e7c:	8b 00                	mov    (%eax),%eax
    7e7e:	89 c2                	mov    %eax,%edx
    7e80:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7e83:	05 00 04 00 00       	add    $0x400,%eax
    7e88:	8b 00                	mov    (%eax),%eax
    7e8a:	83 ec 04             	sub    $0x4,%esp
    7e8d:	52                   	push   %edx
    7e8e:	50                   	push   %eax
    7e8f:	ff 75 08             	pushl  0x8(%ebp)
    7e92:	e8 89 c0 ff ff       	call   3f20 <writeBitsReversed>
    7e97:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    7e9a:	83 ec 0c             	sub    $0xc,%esp
    7e9d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7ea0:	50                   	push   %eax
    7ea1:	e8 1f c9 ff ff       	call   47c5 <HuffmanTree_cleanup>
    7ea6:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7ea9:	83 ec 0c             	sub    $0xc,%esp
    7eac:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7eaf:	50                   	push   %eax
    7eb0:	e8 10 c9 ff ff       	call   47c5 <HuffmanTree_cleanup>
    7eb5:	83 c4 10             	add    $0x10,%esp

  return error;
    7eb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7ebb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7ebe:	c9                   	leave  
    7ebf:	c3                   	ret    

00007ec0 <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    7ec0:	55                   	push   %ebp
    7ec1:	89 e5                	mov    %esp,%ebp
    7ec3:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    7ec6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    7ecd:	ff 75 08             	pushl  0x8(%ebp)
    7ed0:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7ed3:	50                   	push   %eax
    7ed4:	e8 9e be ff ff       	call   3d77 <LodePNGBitWriter_init>
    7ed9:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    7edc:	8b 45 14             	mov    0x14(%ebp),%eax
    7edf:	8b 00                	mov    (%eax),%eax
    7ee1:	83 f8 02             	cmp    $0x2,%eax
    7ee4:	76 0a                	jbe    7ef0 <lodepng_deflatev+0x30>
    7ee6:	b8 3d 00 00 00       	mov    $0x3d,%eax
    7eeb:	e9 68 01 00 00       	jmp    8058 <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    7ef0:	8b 45 14             	mov    0x14(%ebp),%eax
    7ef3:	8b 00                	mov    (%eax),%eax
    7ef5:	85 c0                	test   %eax,%eax
    7ef7:	75 16                	jne    7f0f <lodepng_deflatev+0x4f>
    7ef9:	ff 75 10             	pushl  0x10(%ebp)
    7efc:	ff 75 0c             	pushl  0xc(%ebp)
    7eff:	ff 75 08             	pushl  0x8(%ebp)
    7f02:	e8 01 f2 ff ff       	call   7108 <deflateNoCompression>
    7f07:	83 c4 0c             	add    $0xc,%esp
    7f0a:	e9 49 01 00 00       	jmp    8058 <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    7f0f:	8b 45 14             	mov    0x14(%ebp),%eax
    7f12:	8b 00                	mov    (%eax),%eax
    7f14:	83 f8 01             	cmp    $0x1,%eax
    7f17:	75 08                	jne    7f21 <lodepng_deflatev+0x61>
    7f19:	8b 45 10             	mov    0x10(%ebp),%eax
    7f1c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    7f1f:	eb 2c                	jmp    7f4d <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    7f21:	8b 45 10             	mov    0x10(%ebp),%eax
    7f24:	c1 e8 03             	shr    $0x3,%eax
    7f27:	83 c0 08             	add    $0x8,%eax
    7f2a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    7f2d:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    7f34:	7f 07                	jg     7f3d <lodepng_deflatev+0x7d>
    7f36:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    7f3d:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    7f44:	7e 07                	jle    7f4d <lodepng_deflatev+0x8d>
    7f46:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    7f4d:	8b 55 10             	mov    0x10(%ebp),%edx
    7f50:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7f53:	01 d0                	add    %edx,%eax
    7f55:	83 e8 01             	sub    $0x1,%eax
    7f58:	99                   	cltd   
    7f59:	f7 7d ec             	idivl  -0x14(%ebp)
    7f5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    7f5f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7f63:	75 07                	jne    7f6c <lodepng_deflatev+0xac>
    7f65:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    7f6c:	8b 45 14             	mov    0x14(%ebp),%eax
    7f6f:	8b 40 08             	mov    0x8(%eax),%eax
    7f72:	83 ec 08             	sub    $0x8,%esp
    7f75:	50                   	push   %eax
    7f76:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7f79:	50                   	push   %eax
    7f7a:	e8 1c e8 ff ff       	call   679b <hash_init>
    7f7f:	83 c4 10             	add    $0x10,%esp
    7f82:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7f85:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7f89:	0f 85 b7 00 00 00    	jne    8046 <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7f8f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7f96:	e9 99 00 00 00       	jmp    8034 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    7f9b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7f9e:	83 e8 01             	sub    $0x1,%eax
    7fa1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7fa4:	0f 94 c0             	sete   %al
    7fa7:	0f b6 c0             	movzbl %al,%eax
    7faa:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    7fad:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7fb0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    7fb4:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    7fb7:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7fba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7fbd:	01 d0                	add    %edx,%eax
    7fbf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    7fc2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7fc5:	3b 45 10             	cmp    0x10(%ebp),%eax
    7fc8:	7e 06                	jle    7fd0 <lodepng_deflatev+0x110>
    7fca:	8b 45 10             	mov    0x10(%ebp),%eax
    7fcd:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    7fd0:	8b 45 14             	mov    0x14(%ebp),%eax
    7fd3:	8b 00                	mov    (%eax),%eax
    7fd5:	83 f8 01             	cmp    $0x1,%eax
    7fd8:	75 27                	jne    8001 <lodepng_deflatev+0x141>
    7fda:	83 ec 04             	sub    $0x4,%esp
    7fdd:	ff 75 e0             	pushl  -0x20(%ebp)
    7fe0:	ff 75 14             	pushl  0x14(%ebp)
    7fe3:	ff 75 e4             	pushl  -0x1c(%ebp)
    7fe6:	ff 75 dc             	pushl  -0x24(%ebp)
    7fe9:	ff 75 0c             	pushl  0xc(%ebp)
    7fec:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7fef:	50                   	push   %eax
    7ff0:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7ff3:	50                   	push   %eax
    7ff4:	e8 07 fd ff ff       	call   7d00 <deflateFixed>
    7ff9:	83 c4 20             	add    $0x20,%esp
    7ffc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7fff:	eb 2f                	jmp    8030 <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    8001:	8b 45 14             	mov    0x14(%ebp),%eax
    8004:	8b 00                	mov    (%eax),%eax
    8006:	83 f8 02             	cmp    $0x2,%eax
    8009:	75 25                	jne    8030 <lodepng_deflatev+0x170>
    800b:	83 ec 04             	sub    $0x4,%esp
    800e:	ff 75 e0             	pushl  -0x20(%ebp)
    8011:	ff 75 14             	pushl  0x14(%ebp)
    8014:	ff 75 e4             	pushl  -0x1c(%ebp)
    8017:	ff 75 dc             	pushl  -0x24(%ebp)
    801a:	ff 75 0c             	pushl  0xc(%ebp)
    801d:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    8020:	50                   	push   %eax
    8021:	8d 45 bc             	lea    -0x44(%ebp),%eax
    8024:	50                   	push   %eax
    8025:	e8 7b f3 ff ff       	call   73a5 <deflateDynamic>
    802a:	83 c4 20             	add    $0x20,%esp
    802d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    8030:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    8034:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8037:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    803a:	74 0a                	je     8046 <lodepng_deflatev+0x186>
    803c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8040:	0f 84 55 ff ff ff    	je     7f9b <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    8046:	83 ec 0c             	sub    $0xc,%esp
    8049:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    804c:	50                   	push   %eax
    804d:	e8 08 e9 ff ff       	call   695a <hash_cleanup>
    8052:	83 c4 10             	add    $0x10,%esp

  return error;
    8055:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8058:	c9                   	leave  
    8059:	c3                   	ret    

0000805a <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    805a:	55                   	push   %ebp
    805b:	89 e5                	mov    %esp,%ebp
    805d:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    8060:	8b 45 0c             	mov    0xc(%ebp),%eax
    8063:	8b 08                	mov    (%eax),%ecx
    8065:	8b 45 08             	mov    0x8(%ebp),%eax
    8068:	8b 10                	mov    (%eax),%edx
    806a:	8d 45 e8             	lea    -0x18(%ebp),%eax
    806d:	51                   	push   %ecx
    806e:	52                   	push   %edx
    806f:	50                   	push   %eax
    8070:	e8 f0 ba ff ff       	call   3b65 <ucvector_init>
    8075:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    8078:	ff 75 18             	pushl  0x18(%ebp)
    807b:	ff 75 14             	pushl  0x14(%ebp)
    807e:	ff 75 10             	pushl  0x10(%ebp)
    8081:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8084:	50                   	push   %eax
    8085:	e8 36 fe ff ff       	call   7ec0 <lodepng_deflatev>
    808a:	83 c4 10             	add    $0x10,%esp
    808d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    8090:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8093:	8b 45 08             	mov    0x8(%ebp),%eax
    8096:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8098:	8b 55 ec             	mov    -0x14(%ebp),%edx
    809b:	8b 45 0c             	mov    0xc(%ebp),%eax
    809e:	89 10                	mov    %edx,(%eax)
  return error;
    80a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    80a3:	c9                   	leave  
    80a4:	c3                   	ret    

000080a5 <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    80a5:	55                   	push   %ebp
    80a6:	89 e5                	mov    %esp,%ebp
    80a8:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    80ab:	8b 45 18             	mov    0x18(%ebp),%eax
    80ae:	8b 40 1c             	mov    0x1c(%eax),%eax
    80b1:	85 c0                	test   %eax,%eax
    80b3:	74 34                	je     80e9 <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    80b5:	8b 45 18             	mov    0x18(%ebp),%eax
    80b8:	8b 40 1c             	mov    0x1c(%eax),%eax
    80bb:	83 ec 0c             	sub    $0xc,%esp
    80be:	ff 75 18             	pushl  0x18(%ebp)
    80c1:	ff 75 14             	pushl  0x14(%ebp)
    80c4:	ff 75 10             	pushl  0x10(%ebp)
    80c7:	ff 75 0c             	pushl  0xc(%ebp)
    80ca:	ff 75 08             	pushl  0x8(%ebp)
    80cd:	ff d0                	call   *%eax
    80cf:	83 c4 20             	add    $0x20,%esp
    80d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    80d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    80d9:	74 07                	je     80e2 <deflate+0x3d>
    80db:	b8 6f 00 00 00       	mov    $0x6f,%eax
    80e0:	eb 21                	jmp    8103 <deflate+0x5e>
    80e2:	b8 00 00 00 00       	mov    $0x0,%eax
    80e7:	eb 1a                	jmp    8103 <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    80e9:	83 ec 0c             	sub    $0xc,%esp
    80ec:	ff 75 18             	pushl  0x18(%ebp)
    80ef:	ff 75 14             	pushl  0x14(%ebp)
    80f2:	ff 75 10             	pushl  0x10(%ebp)
    80f5:	ff 75 0c             	pushl  0xc(%ebp)
    80f8:	ff 75 08             	pushl  0x8(%ebp)
    80fb:	e8 5a ff ff ff       	call   805a <lodepng_deflate>
    8100:	83 c4 20             	add    $0x20,%esp
  }
}
    8103:	c9                   	leave  
    8104:	c3                   	ret    

00008105 <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    8105:	55                   	push   %ebp
    8106:	89 e5                	mov    %esp,%ebp
    8108:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    810b:	8b 45 08             	mov    0x8(%ebp),%eax
    810e:	0f b7 c0             	movzwl %ax,%eax
    8111:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    8114:	8b 45 08             	mov    0x8(%ebp),%eax
    8117:	c1 e8 10             	shr    $0x10,%eax
    811a:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    811d:	e9 82 00 00 00       	jmp    81a4 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    8122:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    8127:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    812e:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    8132:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    8135:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8138:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    813b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8142:	eb 1c                	jmp    8160 <update_adler32+0x5b>
      s1 += (*data++);
    8144:	8b 45 0c             	mov    0xc(%ebp),%eax
    8147:	8d 50 01             	lea    0x1(%eax),%edx
    814a:	89 55 0c             	mov    %edx,0xc(%ebp)
    814d:	0f b6 00             	movzbl (%eax),%eax
    8150:	0f b6 c0             	movzbl %al,%eax
    8153:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    8156:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8159:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    815c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8160:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8163:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    8166:	75 dc                	jne    8144 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    8168:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    816b:	ba 71 80 07 80       	mov    $0x80078071,%edx
    8170:	89 c8                	mov    %ecx,%eax
    8172:	f7 e2                	mul    %edx
    8174:	89 d0                	mov    %edx,%eax
    8176:	c1 e8 0f             	shr    $0xf,%eax
    8179:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    817f:	29 c1                	sub    %eax,%ecx
    8181:	89 c8                	mov    %ecx,%eax
    8183:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    8186:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    8189:	ba 71 80 07 80       	mov    $0x80078071,%edx
    818e:	89 c8                	mov    %ecx,%eax
    8190:	f7 e2                	mul    %edx
    8192:	89 d0                	mov    %edx,%eax
    8194:	c1 e8 0f             	shr    $0xf,%eax
    8197:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    819d:	29 c1                	sub    %eax,%ecx
    819f:	89 c8                	mov    %ecx,%eax
    81a1:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    81a4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    81a8:	0f 85 74 ff ff ff    	jne    8122 <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    81ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    81b1:	c1 e0 10             	shl    $0x10,%eax
    81b4:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    81b7:	c9                   	leave  
    81b8:	c3                   	ret    

000081b9 <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    81b9:	55                   	push   %ebp
    81ba:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    81bc:	ff 75 0c             	pushl  0xc(%ebp)
    81bf:	ff 75 08             	pushl  0x8(%ebp)
    81c2:	6a 01                	push   $0x1
    81c4:	e8 3c ff ff ff       	call   8105 <update_adler32>
    81c9:	83 c4 0c             	add    $0xc,%esp
}
    81cc:	c9                   	leave  
    81cd:	c3                   	ret    

000081ce <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    81ce:	55                   	push   %ebp
    81cf:	89 e5                	mov    %esp,%ebp
    81d1:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    81d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    81db:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    81df:	7f 0a                	jg     81eb <lodepng_zlib_decompressv+0x1d>
    81e1:	b8 35 00 00 00       	mov    $0x35,%eax
    81e6:	e9 27 01 00 00       	jmp    8312 <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    81eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    81ee:	0f b6 00             	movzbl (%eax),%eax
    81f1:	0f b6 c0             	movzbl %al,%eax
    81f4:	c1 e0 08             	shl    $0x8,%eax
    81f7:	89 c2                	mov    %eax,%edx
    81f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    81fc:	83 c0 01             	add    $0x1,%eax
    81ff:	0f b6 00             	movzbl (%eax),%eax
    8202:	0f b6 c0             	movzbl %al,%eax
    8205:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    8208:	ba 43 08 21 84       	mov    $0x84210843,%edx
    820d:	89 c8                	mov    %ecx,%eax
    820f:	f7 ea                	imul   %edx
    8211:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    8214:	c1 f8 04             	sar    $0x4,%eax
    8217:	89 c2                	mov    %eax,%edx
    8219:	89 c8                	mov    %ecx,%eax
    821b:	c1 f8 1f             	sar    $0x1f,%eax
    821e:	29 c2                	sub    %eax,%edx
    8220:	89 d0                	mov    %edx,%eax
    8222:	89 c2                	mov    %eax,%edx
    8224:	c1 e2 05             	shl    $0x5,%edx
    8227:	29 c2                	sub    %eax,%edx
    8229:	89 c8                	mov    %ecx,%eax
    822b:	29 d0                	sub    %edx,%eax
    822d:	85 c0                	test   %eax,%eax
    822f:	74 0a                	je     823b <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    8231:	b8 18 00 00 00       	mov    $0x18,%eax
    8236:	e9 d7 00 00 00       	jmp    8312 <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    823b:	8b 45 0c             	mov    0xc(%ebp),%eax
    823e:	0f b6 00             	movzbl (%eax),%eax
    8241:	0f b6 c0             	movzbl %al,%eax
    8244:	83 e0 0f             	and    $0xf,%eax
    8247:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    824a:	8b 45 0c             	mov    0xc(%ebp),%eax
    824d:	0f b6 00             	movzbl (%eax),%eax
    8250:	c0 e8 04             	shr    $0x4,%al
    8253:	0f b6 c0             	movzbl %al,%eax
    8256:	83 e0 0f             	and    $0xf,%eax
    8259:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    825c:	8b 45 0c             	mov    0xc(%ebp),%eax
    825f:	83 c0 01             	add    $0x1,%eax
    8262:	0f b6 00             	movzbl (%eax),%eax
    8265:	c0 e8 05             	shr    $0x5,%al
    8268:	0f b6 c0             	movzbl %al,%eax
    826b:	83 e0 01             	and    $0x1,%eax
    826e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    8271:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    8275:	75 06                	jne    827d <lodepng_zlib_decompressv+0xaf>
    8277:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    827b:	76 0a                	jbe    8287 <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    827d:	b8 19 00 00 00       	mov    $0x19,%eax
    8282:	e9 8b 00 00 00       	jmp    8312 <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    8287:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    828b:	74 07                	je     8294 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    828d:	b8 1a 00 00 00       	mov    $0x1a,%eax
    8292:	eb 7e                	jmp    8312 <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    8294:	8b 45 10             	mov    0x10(%ebp),%eax
    8297:	8d 50 fe             	lea    -0x2(%eax),%edx
    829a:	8b 45 0c             	mov    0xc(%ebp),%eax
    829d:	83 c0 02             	add    $0x2,%eax
    82a0:	ff 75 14             	pushl  0x14(%ebp)
    82a3:	52                   	push   %edx
    82a4:	50                   	push   %eax
    82a5:	ff 75 08             	pushl  0x8(%ebp)
    82a8:	e8 09 e3 ff ff       	call   65b6 <inflatev>
    82ad:	83 c4 10             	add    $0x10,%esp
    82b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    82b3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    82b7:	74 05                	je     82be <lodepng_zlib_decompressv+0xf0>
    82b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    82bc:	eb 54                	jmp    8312 <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    82be:	8b 45 14             	mov    0x14(%ebp),%eax
    82c1:	8b 00                	mov    (%eax),%eax
    82c3:	85 c0                	test   %eax,%eax
    82c5:	75 46                	jne    830d <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    82c7:	8b 45 10             	mov    0x10(%ebp),%eax
    82ca:	8d 50 fc             	lea    -0x4(%eax),%edx
    82cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    82d0:	01 d0                	add    %edx,%eax
    82d2:	83 ec 0c             	sub    $0xc,%esp
    82d5:	50                   	push   %eax
    82d6:	e8 47 b9 ff ff       	call   3c22 <lodepng_read32bitInt>
    82db:	83 c4 10             	add    $0x10,%esp
    82de:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    82e1:	8b 45 08             	mov    0x8(%ebp),%eax
    82e4:	8b 40 04             	mov    0x4(%eax),%eax
    82e7:	89 c2                	mov    %eax,%edx
    82e9:	8b 45 08             	mov    0x8(%ebp),%eax
    82ec:	8b 00                	mov    (%eax),%eax
    82ee:	83 ec 08             	sub    $0x8,%esp
    82f1:	52                   	push   %edx
    82f2:	50                   	push   %eax
    82f3:	e8 c1 fe ff ff       	call   81b9 <adler32>
    82f8:	83 c4 10             	add    $0x10,%esp
    82fb:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    82fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8301:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    8304:	74 07                	je     830d <lodepng_zlib_decompressv+0x13f>
    8306:	b8 3a 00 00 00       	mov    $0x3a,%eax
    830b:	eb 05                	jmp    8312 <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    830d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8312:	c9                   	leave  
    8313:	c3                   	ret    

00008314 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    8314:	55                   	push   %ebp
    8315:	89 e5                	mov    %esp,%ebp
    8317:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    831a:	8b 45 0c             	mov    0xc(%ebp),%eax
    831d:	8b 08                	mov    (%eax),%ecx
    831f:	8b 45 08             	mov    0x8(%ebp),%eax
    8322:	8b 10                	mov    (%eax),%edx
    8324:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8327:	51                   	push   %ecx
    8328:	52                   	push   %edx
    8329:	50                   	push   %eax
    832a:	e8 36 b8 ff ff       	call   3b65 <ucvector_init>
    832f:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    8332:	ff 75 18             	pushl  0x18(%ebp)
    8335:	ff 75 14             	pushl  0x14(%ebp)
    8338:	ff 75 10             	pushl  0x10(%ebp)
    833b:	8d 45 e8             	lea    -0x18(%ebp),%eax
    833e:	50                   	push   %eax
    833f:	e8 8a fe ff ff       	call   81ce <lodepng_zlib_decompressv>
    8344:	83 c4 10             	add    $0x10,%esp
    8347:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    834a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    834d:	8b 45 08             	mov    0x8(%ebp),%eax
    8350:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8352:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8355:	8b 45 0c             	mov    0xc(%ebp),%eax
    8358:	89 10                	mov    %edx,(%eax)
  return error;
    835a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    835d:	c9                   	leave  
    835e:	c3                   	ret    

0000835f <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    835f:	55                   	push   %ebp
    8360:	89 e5                	mov    %esp,%ebp
    8362:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    8365:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8368:	8b 40 0c             	mov    0xc(%eax),%eax
    836b:	85 c0                	test   %eax,%eax
    836d:	74 57                	je     83c6 <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    836f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8372:	8b 40 0c             	mov    0xc(%eax),%eax
    8375:	83 ec 0c             	sub    $0xc,%esp
    8378:	ff 75 1c             	pushl  0x1c(%ebp)
    837b:	ff 75 18             	pushl  0x18(%ebp)
    837e:	ff 75 14             	pushl  0x14(%ebp)
    8381:	ff 75 0c             	pushl  0xc(%ebp)
    8384:	ff 75 08             	pushl  0x8(%ebp)
    8387:	ff d0                	call   *%eax
    8389:	83 c4 20             	add    $0x20,%esp
    838c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    838f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8393:	0f 84 98 00 00 00    	je     8431 <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    8399:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    83a0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    83a3:	8b 40 08             	mov    0x8(%eax),%eax
    83a6:	85 c0                	test   %eax,%eax
    83a8:	0f 84 83 00 00 00    	je     8431 <zlib_decompress+0xd2>
    83ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    83b1:	8b 10                	mov    (%eax),%edx
    83b3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    83b6:	8b 40 08             	mov    0x8(%eax),%eax
    83b9:	39 c2                	cmp    %eax,%edx
    83bb:	7e 74                	jle    8431 <zlib_decompress+0xd2>
    83bd:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    83c4:	eb 6b                	jmp    8431 <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    83c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    83c9:	8b 08                	mov    (%eax),%ecx
    83cb:	8b 45 08             	mov    0x8(%ebp),%eax
    83ce:	8b 10                	mov    (%eax),%edx
    83d0:	8d 45 e8             	lea    -0x18(%ebp),%eax
    83d3:	83 ec 04             	sub    $0x4,%esp
    83d6:	51                   	push   %ecx
    83d7:	52                   	push   %edx
    83d8:	50                   	push   %eax
    83d9:	e8 87 b7 ff ff       	call   3b65 <ucvector_init>
    83de:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    83e1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    83e5:	74 22                	je     8409 <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    83e7:	8b 45 0c             	mov    0xc(%ebp),%eax
    83ea:	8b 10                	mov    (%eax),%edx
    83ec:	8b 45 10             	mov    0x10(%ebp),%eax
    83ef:	01 d0                	add    %edx,%eax
    83f1:	83 ec 08             	sub    $0x8,%esp
    83f4:	50                   	push   %eax
    83f5:	8d 45 e8             	lea    -0x18(%ebp),%eax
    83f8:	50                   	push   %eax
    83f9:	e8 00 b7 ff ff       	call   3afe <ucvector_resize>
    83fe:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    8401:	8b 45 0c             	mov    0xc(%ebp),%eax
    8404:	8b 00                	mov    (%eax),%eax
    8406:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    8409:	ff 75 1c             	pushl  0x1c(%ebp)
    840c:	ff 75 18             	pushl  0x18(%ebp)
    840f:	ff 75 14             	pushl  0x14(%ebp)
    8412:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8415:	50                   	push   %eax
    8416:	e8 b3 fd ff ff       	call   81ce <lodepng_zlib_decompressv>
    841b:	83 c4 10             	add    $0x10,%esp
    841e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    8421:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8424:	8b 45 08             	mov    0x8(%ebp),%eax
    8427:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    8429:	8b 55 ec             	mov    -0x14(%ebp),%edx
    842c:	8b 45 0c             	mov    0xc(%ebp),%eax
    842f:	89 10                	mov    %edx,(%eax)
  }
  return error;
    8431:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8434:	c9                   	leave  
    8435:	c3                   	ret    

00008436 <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    8436:	55                   	push   %ebp
    8437:	89 e5                	mov    %esp,%ebp
    8439:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    843c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    8443:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    844a:	83 ec 0c             	sub    $0xc,%esp
    844d:	ff 75 18             	pushl  0x18(%ebp)
    8450:	ff 75 14             	pushl  0x14(%ebp)
    8453:	ff 75 10             	pushl  0x10(%ebp)
    8456:	8d 45 d0             	lea    -0x30(%ebp),%eax
    8459:	50                   	push   %eax
    845a:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    845d:	50                   	push   %eax
    845e:	e8 42 fc ff ff       	call   80a5 <deflate>
    8463:	83 c4 20             	add    $0x20,%esp
    8466:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    8469:	8b 45 08             	mov    0x8(%ebp),%eax
    846c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    8472:	8b 45 0c             	mov    0xc(%ebp),%eax
    8475:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    847b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    847f:	75 33                	jne    84b4 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    8481:	8b 45 d0             	mov    -0x30(%ebp),%eax
    8484:	8d 50 06             	lea    0x6(%eax),%edx
    8487:	8b 45 0c             	mov    0xc(%ebp),%eax
    848a:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    848c:	8b 45 0c             	mov    0xc(%ebp),%eax
    848f:	8b 00                	mov    (%eax),%eax
    8491:	83 ec 0c             	sub    $0xc,%esp
    8494:	50                   	push   %eax
    8495:	e8 0a b4 ff ff       	call   38a4 <lodepng_malloc>
    849a:	83 c4 10             	add    $0x10,%esp
    849d:	89 c2                	mov    %eax,%edx
    849f:	8b 45 08             	mov    0x8(%ebp),%eax
    84a2:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    84a4:	8b 45 08             	mov    0x8(%ebp),%eax
    84a7:	8b 00                	mov    (%eax),%eax
    84a9:	85 c0                	test   %eax,%eax
    84ab:	75 07                	jne    84b4 <lodepng_zlib_compress+0x7e>
    84ad:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    84b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    84b8:	0f 85 e2 00 00 00    	jne    85a0 <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    84be:	8b 45 14             	mov    0x14(%ebp),%eax
    84c1:	83 ec 08             	sub    $0x8,%esp
    84c4:	50                   	push   %eax
    84c5:	ff 75 10             	pushl  0x10(%ebp)
    84c8:	e8 ec fc ff ff       	call   81b9 <adler32>
    84cd:	83 c4 10             	add    $0x10,%esp
    84d0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    84d3:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    84da:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    84e1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    84e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    84eb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    84f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    84f5:	01 d0                	add    %edx,%eax
    84f7:	8d 14 00             	lea    (%eax,%eax,1),%edx
    84fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
    84fd:	01 d0                	add    %edx,%eax
    84ff:	c1 e0 05             	shl    $0x5,%eax
    8502:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    8505:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    8508:	ba 85 10 42 08       	mov    $0x8421085,%edx
    850d:	89 c8                	mov    %ecx,%eax
    850f:	f7 e2                	mul    %edx
    8511:	89 c8                	mov    %ecx,%eax
    8513:	29 d0                	sub    %edx,%eax
    8515:	d1 e8                	shr    %eax
    8517:	01 d0                	add    %edx,%eax
    8519:	c1 e8 04             	shr    $0x4,%eax
    851c:	89 c2                	mov    %eax,%edx
    851e:	c1 e2 05             	shl    $0x5,%edx
    8521:	29 c2                	sub    %eax,%edx
    8523:	89 c8                	mov    %ecx,%eax
    8525:	29 d0                	sub    %edx,%eax
    8527:	ba 1f 00 00 00       	mov    $0x1f,%edx
    852c:	29 c2                	sub    %eax,%edx
    852e:	89 d0                	mov    %edx,%eax
    8530:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    8533:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8536:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    8539:	8b 45 08             	mov    0x8(%ebp),%eax
    853c:	8b 00                	mov    (%eax),%eax
    853e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8541:	c1 ea 08             	shr    $0x8,%edx
    8544:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    8546:	8b 45 08             	mov    0x8(%ebp),%eax
    8549:	8b 00                	mov    (%eax),%eax
    854b:	83 c0 01             	add    $0x1,%eax
    854e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8551:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    8553:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    855a:	eb 1e                	jmp    857a <lodepng_zlib_compress+0x144>
    855c:	8b 45 08             	mov    0x8(%ebp),%eax
    855f:	8b 00                	mov    (%eax),%eax
    8561:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8564:	83 c2 02             	add    $0x2,%edx
    8567:	01 c2                	add    %eax,%edx
    8569:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    856c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    856f:	01 c8                	add    %ecx,%eax
    8571:	0f b6 00             	movzbl (%eax),%eax
    8574:	88 02                	mov    %al,(%edx)
    8576:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    857a:	8b 45 d0             	mov    -0x30(%ebp),%eax
    857d:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    8580:	75 da                	jne    855c <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    8582:	8b 45 08             	mov    0x8(%ebp),%eax
    8585:	8b 10                	mov    (%eax),%edx
    8587:	8b 45 0c             	mov    0xc(%ebp),%eax
    858a:	8b 00                	mov    (%eax),%eax
    858c:	83 e8 04             	sub    $0x4,%eax
    858f:	01 d0                	add    %edx,%eax
    8591:	83 ec 08             	sub    $0x8,%esp
    8594:	ff 75 ec             	pushl  -0x14(%ebp)
    8597:	50                   	push   %eax
    8598:	e8 c8 b6 ff ff       	call   3c65 <lodepng_set32bitInt>
    859d:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    85a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    85a3:	83 ec 0c             	sub    $0xc,%esp
    85a6:	50                   	push   %eax
    85a7:	e8 19 b3 ff ff       	call   38c5 <lodepng_free>
    85ac:	83 c4 10             	add    $0x10,%esp
  return error;
    85af:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    85b2:	c9                   	leave  
    85b3:	c3                   	ret    

000085b4 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    85b4:	55                   	push   %ebp
    85b5:	89 e5                	mov    %esp,%ebp
    85b7:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    85ba:	8b 45 18             	mov    0x18(%ebp),%eax
    85bd:	8b 40 18             	mov    0x18(%eax),%eax
    85c0:	85 c0                	test   %eax,%eax
    85c2:	74 34                	je     85f8 <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    85c4:	8b 45 18             	mov    0x18(%ebp),%eax
    85c7:	8b 40 18             	mov    0x18(%eax),%eax
    85ca:	83 ec 0c             	sub    $0xc,%esp
    85cd:	ff 75 18             	pushl  0x18(%ebp)
    85d0:	ff 75 14             	pushl  0x14(%ebp)
    85d3:	ff 75 10             	pushl  0x10(%ebp)
    85d6:	ff 75 0c             	pushl  0xc(%ebp)
    85d9:	ff 75 08             	pushl  0x8(%ebp)
    85dc:	ff d0                	call   *%eax
    85de:	83 c4 20             	add    $0x20,%esp
    85e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    85e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    85e8:	74 07                	je     85f1 <zlib_compress+0x3d>
    85ea:	b8 6f 00 00 00       	mov    $0x6f,%eax
    85ef:	eb 21                	jmp    8612 <zlib_compress+0x5e>
    85f1:	b8 00 00 00 00       	mov    $0x0,%eax
    85f6:	eb 1a                	jmp    8612 <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    85f8:	83 ec 0c             	sub    $0xc,%esp
    85fb:	ff 75 18             	pushl  0x18(%ebp)
    85fe:	ff 75 14             	pushl  0x14(%ebp)
    8601:	ff 75 10             	pushl  0x10(%ebp)
    8604:	ff 75 0c             	pushl  0xc(%ebp)
    8607:	ff 75 08             	pushl  0x8(%ebp)
    860a:	e8 27 fe ff ff       	call   8436 <lodepng_zlib_compress>
    860f:	83 c4 20             	add    $0x20,%esp
  }
}
    8612:	c9                   	leave  
    8613:	c3                   	ret    

00008614 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    8614:	55                   	push   %ebp
    8615:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    8617:	8b 45 08             	mov    0x8(%ebp),%eax
    861a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    8620:	8b 45 08             	mov    0x8(%ebp),%eax
    8623:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    862a:	8b 45 08             	mov    0x8(%ebp),%eax
    862d:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    8634:	8b 45 08             	mov    0x8(%ebp),%eax
    8637:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    863e:	8b 45 08             	mov    0x8(%ebp),%eax
    8641:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    8648:	8b 45 08             	mov    0x8(%ebp),%eax
    864b:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    8652:	8b 45 08             	mov    0x8(%ebp),%eax
    8655:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    865c:	8b 45 08             	mov    0x8(%ebp),%eax
    865f:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    8666:	8b 45 08             	mov    0x8(%ebp),%eax
    8669:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    8670:	90                   	nop
    8671:	5d                   	pop    %ebp
    8672:	c3                   	ret    

00008673 <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    8673:	55                   	push   %ebp
    8674:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    8676:	8b 45 08             	mov    0x8(%ebp),%eax
    8679:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    867f:	8b 45 08             	mov    0x8(%ebp),%eax
    8682:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    8689:	8b 45 08             	mov    0x8(%ebp),%eax
    868c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    8693:	8b 45 08             	mov    0x8(%ebp),%eax
    8696:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    869d:	8b 45 08             	mov    0x8(%ebp),%eax
    86a0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    86a7:	8b 45 08             	mov    0x8(%ebp),%eax
    86aa:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    86b1:	90                   	nop
    86b2:	5d                   	pop    %ebp
    86b3:	c3                   	ret    

000086b4 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    86b4:	55                   	push   %ebp
    86b5:	89 e5                	mov    %esp,%ebp
    86b7:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    86ba:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    86c1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    86c8:	eb 2a                	jmp    86f4 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    86ca:	8b 55 f8             	mov    -0x8(%ebp),%edx
    86cd:	8b 45 08             	mov    0x8(%ebp),%eax
    86d0:	01 d0                	add    %edx,%eax
    86d2:	0f b6 00             	movzbl (%eax),%eax
    86d5:	0f b6 c0             	movzbl %al,%eax
    86d8:	33 45 fc             	xor    -0x4(%ebp),%eax
    86db:	0f b6 c0             	movzbl %al,%eax
    86de:	8b 04 85 20 e7 01 00 	mov    0x1e720(,%eax,4),%eax
    86e5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    86e8:	c1 ea 08             	shr    $0x8,%edx
    86eb:	31 d0                	xor    %edx,%eax
    86ed:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    86f0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    86f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    86f7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    86fa:	7c ce                	jl     86ca <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    86fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    86ff:	f7 d0                	not    %eax
}
    8701:	c9                   	leave  
    8702:	c3                   	ret    

00008703 <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    8703:	55                   	push   %ebp
    8704:	89 e5                	mov    %esp,%ebp
    8706:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    8709:	8b 45 08             	mov    0x8(%ebp),%eax
    870c:	8b 00                	mov    (%eax),%eax
    870e:	c1 f8 03             	sar    $0x3,%eax
    8711:	89 c2                	mov    %eax,%edx
    8713:	8b 45 0c             	mov    0xc(%ebp),%eax
    8716:	01 d0                	add    %edx,%eax
    8718:	0f b6 00             	movzbl (%eax),%eax
    871b:	0f b6 d0             	movzbl %al,%edx
    871e:	8b 45 08             	mov    0x8(%ebp),%eax
    8721:	8b 00                	mov    (%eax),%eax
    8723:	f7 d0                	not    %eax
    8725:	83 e0 07             	and    $0x7,%eax
    8728:	89 c1                	mov    %eax,%ecx
    872a:	d3 fa                	sar    %cl,%edx
    872c:	89 d0                	mov    %edx,%eax
    872e:	83 e0 01             	and    $0x1,%eax
    8731:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    8734:	8b 45 08             	mov    0x8(%ebp),%eax
    8737:	8b 00                	mov    (%eax),%eax
    8739:	8d 50 01             	lea    0x1(%eax),%edx
    873c:	8b 45 08             	mov    0x8(%ebp),%eax
    873f:	89 10                	mov    %edx,(%eax)
  return result;
    8741:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    8745:	c9                   	leave  
    8746:	c3                   	ret    

00008747 <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    8747:	55                   	push   %ebp
    8748:	89 e5                	mov    %esp,%ebp
    874a:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    874d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    8754:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    875b:	eb 1b                	jmp    8778 <readBitsFromReversedStream+0x31>
    result <<= 1u;
    875d:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    8760:	ff 75 0c             	pushl  0xc(%ebp)
    8763:	ff 75 08             	pushl  0x8(%ebp)
    8766:	e8 98 ff ff ff       	call   8703 <readBitFromReversedStream>
    876b:	83 c4 08             	add    $0x8,%esp
    876e:	0f b6 c0             	movzbl %al,%eax
    8771:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    8774:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8778:	8b 45 f8             	mov    -0x8(%ebp),%eax
    877b:	3b 45 10             	cmp    0x10(%ebp),%eax
    877e:	7c dd                	jl     875d <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    8780:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    8783:	c9                   	leave  
    8784:	c3                   	ret    

00008785 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    8785:	55                   	push   %ebp
    8786:	89 e5                	mov    %esp,%ebp
    8788:	56                   	push   %esi
    8789:	53                   	push   %ebx
    878a:	83 ec 04             	sub    $0x4,%esp
    878d:	8b 45 10             	mov    0x10(%ebp),%eax
    8790:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    8793:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    8797:	75 3e                	jne    87d7 <setBitOfReversedStream+0x52>
    8799:	8b 45 08             	mov    0x8(%ebp),%eax
    879c:	8b 00                	mov    (%eax),%eax
    879e:	c1 f8 03             	sar    $0x3,%eax
    87a1:	89 c2                	mov    %eax,%edx
    87a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    87a6:	01 c2                	add    %eax,%edx
    87a8:	8b 45 08             	mov    0x8(%ebp),%eax
    87ab:	8b 00                	mov    (%eax),%eax
    87ad:	c1 f8 03             	sar    $0x3,%eax
    87b0:	89 c1                	mov    %eax,%ecx
    87b2:	8b 45 0c             	mov    0xc(%ebp),%eax
    87b5:	01 c8                	add    %ecx,%eax
    87b7:	0f b6 18             	movzbl (%eax),%ebx
    87ba:	8b 45 08             	mov    0x8(%ebp),%eax
    87bd:	8b 00                	mov    (%eax),%eax
    87bf:	f7 d0                	not    %eax
    87c1:	83 e0 07             	and    $0x7,%eax
    87c4:	be 01 00 00 00       	mov    $0x1,%esi
    87c9:	89 c1                	mov    %eax,%ecx
    87cb:	d3 e6                	shl    %cl,%esi
    87cd:	89 f0                	mov    %esi,%eax
    87cf:	f7 d0                	not    %eax
    87d1:	21 d8                	and    %ebx,%eax
    87d3:	88 02                	mov    %al,(%edx)
    87d5:	eb 3a                	jmp    8811 <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    87d7:	8b 45 08             	mov    0x8(%ebp),%eax
    87da:	8b 00                	mov    (%eax),%eax
    87dc:	c1 f8 03             	sar    $0x3,%eax
    87df:	89 c2                	mov    %eax,%edx
    87e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    87e4:	01 c2                	add    %eax,%edx
    87e6:	8b 45 08             	mov    0x8(%ebp),%eax
    87e9:	8b 00                	mov    (%eax),%eax
    87eb:	c1 f8 03             	sar    $0x3,%eax
    87ee:	89 c1                	mov    %eax,%ecx
    87f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    87f3:	01 c8                	add    %ecx,%eax
    87f5:	0f b6 18             	movzbl (%eax),%ebx
    87f8:	8b 45 08             	mov    0x8(%ebp),%eax
    87fb:	8b 00                	mov    (%eax),%eax
    87fd:	f7 d0                	not    %eax
    87ff:	83 e0 07             	and    $0x7,%eax
    8802:	be 01 00 00 00       	mov    $0x1,%esi
    8807:	89 c1                	mov    %eax,%ecx
    8809:	d3 e6                	shl    %cl,%esi
    880b:	89 f0                	mov    %esi,%eax
    880d:	09 d8                	or     %ebx,%eax
    880f:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    8811:	8b 45 08             	mov    0x8(%ebp),%eax
    8814:	8b 00                	mov    (%eax),%eax
    8816:	8d 50 01             	lea    0x1(%eax),%edx
    8819:	8b 45 08             	mov    0x8(%ebp),%eax
    881c:	89 10                	mov    %edx,(%eax)
}
    881e:	90                   	nop
    881f:	83 c4 04             	add    $0x4,%esp
    8822:	5b                   	pop    %ebx
    8823:	5e                   	pop    %esi
    8824:	5d                   	pop    %ebp
    8825:	c3                   	ret    

00008826 <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    8826:	55                   	push   %ebp
    8827:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    8829:	ff 75 08             	pushl  0x8(%ebp)
    882c:	e8 f1 b3 ff ff       	call   3c22 <lodepng_read32bitInt>
    8831:	83 c4 04             	add    $0x4,%esp
}
    8834:	c9                   	leave  
    8835:	c3                   	ret    

00008836 <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    8836:	55                   	push   %ebp
    8837:	89 e5                	mov    %esp,%ebp
    8839:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    883c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8843:	eb 1c                	jmp    8861 <lodepng_chunk_type+0x2b>
    8845:	8b 55 08             	mov    0x8(%ebp),%edx
    8848:	8b 45 fc             	mov    -0x4(%ebp),%eax
    884b:	01 d0                	add    %edx,%eax
    884d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8850:	8d 4a 04             	lea    0x4(%edx),%ecx
    8853:	8b 55 0c             	mov    0xc(%ebp),%edx
    8856:	01 ca                	add    %ecx,%edx
    8858:	0f b6 12             	movzbl (%edx),%edx
    885b:	88 10                	mov    %dl,(%eax)
    885d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8861:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    8865:	75 de                	jne    8845 <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    8867:	8b 45 08             	mov    0x8(%ebp),%eax
    886a:	83 c0 04             	add    $0x4,%eax
    886d:	c6 00 00             	movb   $0x0,(%eax)
}
    8870:	90                   	nop
    8871:	c9                   	leave  
    8872:	c3                   	ret    

00008873 <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    8873:	55                   	push   %ebp
    8874:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    8876:	ff 75 0c             	pushl  0xc(%ebp)
    8879:	e8 c2 b0 ff ff       	call   3940 <lodepng_strlen>
    887e:	83 c4 04             	add    $0x4,%esp
    8881:	83 f8 04             	cmp    $0x4,%eax
    8884:	74 07                	je     888d <lodepng_chunk_type_equals+0x1a>
    8886:	b8 00 00 00 00       	mov    $0x0,%eax
    888b:	eb 79                	jmp    8906 <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    888d:	8b 45 08             	mov    0x8(%ebp),%eax
    8890:	83 c0 04             	add    $0x4,%eax
    8893:	0f b6 00             	movzbl (%eax),%eax
    8896:	0f b6 d0             	movzbl %al,%edx
    8899:	8b 45 0c             	mov    0xc(%ebp),%eax
    889c:	0f b6 00             	movzbl (%eax),%eax
    889f:	0f be c0             	movsbl %al,%eax
    88a2:	39 c2                	cmp    %eax,%edx
    88a4:	75 5b                	jne    8901 <lodepng_chunk_type_equals+0x8e>
    88a6:	8b 45 08             	mov    0x8(%ebp),%eax
    88a9:	83 c0 05             	add    $0x5,%eax
    88ac:	0f b6 00             	movzbl (%eax),%eax
    88af:	0f b6 d0             	movzbl %al,%edx
    88b2:	8b 45 0c             	mov    0xc(%ebp),%eax
    88b5:	83 c0 01             	add    $0x1,%eax
    88b8:	0f b6 00             	movzbl (%eax),%eax
    88bb:	0f be c0             	movsbl %al,%eax
    88be:	39 c2                	cmp    %eax,%edx
    88c0:	75 3f                	jne    8901 <lodepng_chunk_type_equals+0x8e>
    88c2:	8b 45 08             	mov    0x8(%ebp),%eax
    88c5:	83 c0 06             	add    $0x6,%eax
    88c8:	0f b6 00             	movzbl (%eax),%eax
    88cb:	0f b6 d0             	movzbl %al,%edx
    88ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    88d1:	83 c0 02             	add    $0x2,%eax
    88d4:	0f b6 00             	movzbl (%eax),%eax
    88d7:	0f be c0             	movsbl %al,%eax
    88da:	39 c2                	cmp    %eax,%edx
    88dc:	75 23                	jne    8901 <lodepng_chunk_type_equals+0x8e>
    88de:	8b 45 08             	mov    0x8(%ebp),%eax
    88e1:	83 c0 07             	add    $0x7,%eax
    88e4:	0f b6 00             	movzbl (%eax),%eax
    88e7:	0f b6 d0             	movzbl %al,%edx
    88ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    88ed:	83 c0 03             	add    $0x3,%eax
    88f0:	0f b6 00             	movzbl (%eax),%eax
    88f3:	0f be c0             	movsbl %al,%eax
    88f6:	39 c2                	cmp    %eax,%edx
    88f8:	75 07                	jne    8901 <lodepng_chunk_type_equals+0x8e>
    88fa:	b8 01 00 00 00       	mov    $0x1,%eax
    88ff:	eb 05                	jmp    8906 <lodepng_chunk_type_equals+0x93>
    8901:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8906:	c9                   	leave  
    8907:	c3                   	ret    

00008908 <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    8908:	55                   	push   %ebp
    8909:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    890b:	8b 45 08             	mov    0x8(%ebp),%eax
    890e:	83 c0 04             	add    $0x4,%eax
    8911:	0f b6 00             	movzbl (%eax),%eax
    8914:	0f b6 c0             	movzbl %al,%eax
    8917:	83 e0 20             	and    $0x20,%eax
    891a:	85 c0                	test   %eax,%eax
    891c:	0f 95 c0             	setne  %al
}
    891f:	5d                   	pop    %ebp
    8920:	c3                   	ret    

00008921 <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    8921:	55                   	push   %ebp
    8922:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    8924:	8b 45 08             	mov    0x8(%ebp),%eax
    8927:	83 c0 06             	add    $0x6,%eax
    892a:	0f b6 00             	movzbl (%eax),%eax
    892d:	0f b6 c0             	movzbl %al,%eax
    8930:	83 e0 20             	and    $0x20,%eax
    8933:	85 c0                	test   %eax,%eax
    8935:	0f 95 c0             	setne  %al
}
    8938:	5d                   	pop    %ebp
    8939:	c3                   	ret    

0000893a <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    893a:	55                   	push   %ebp
    893b:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    893d:	8b 45 08             	mov    0x8(%ebp),%eax
    8940:	83 c0 07             	add    $0x7,%eax
    8943:	0f b6 00             	movzbl (%eax),%eax
    8946:	0f b6 c0             	movzbl %al,%eax
    8949:	83 e0 20             	and    $0x20,%eax
    894c:	85 c0                	test   %eax,%eax
    894e:	0f 95 c0             	setne  %al
}
    8951:	5d                   	pop    %ebp
    8952:	c3                   	ret    

00008953 <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    8953:	55                   	push   %ebp
    8954:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    8956:	8b 45 08             	mov    0x8(%ebp),%eax
    8959:	83 c0 08             	add    $0x8,%eax
}
    895c:	5d                   	pop    %ebp
    895d:	c3                   	ret    

0000895e <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    895e:	55                   	push   %ebp
    895f:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    8961:	8b 45 08             	mov    0x8(%ebp),%eax
    8964:	83 c0 08             	add    $0x8,%eax
}
    8967:	5d                   	pop    %ebp
    8968:	c3                   	ret    

00008969 <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    8969:	55                   	push   %ebp
    896a:	89 e5                	mov    %esp,%ebp
    896c:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    896f:	ff 75 08             	pushl  0x8(%ebp)
    8972:	e8 af fe ff ff       	call   8826 <lodepng_chunk_length>
    8977:	83 c4 04             	add    $0x4,%esp
    897a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    897d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8980:	8d 50 08             	lea    0x8(%eax),%edx
    8983:	8b 45 08             	mov    0x8(%ebp),%eax
    8986:	01 d0                	add    %edx,%eax
    8988:	50                   	push   %eax
    8989:	e8 94 b2 ff ff       	call   3c22 <lodepng_read32bitInt>
    898e:	83 c4 04             	add    $0x4,%esp
    8991:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    8994:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8997:	83 c0 04             	add    $0x4,%eax
    899a:	89 c2                	mov    %eax,%edx
    899c:	8b 45 08             	mov    0x8(%ebp),%eax
    899f:	83 c0 04             	add    $0x4,%eax
    89a2:	52                   	push   %edx
    89a3:	50                   	push   %eax
    89a4:	e8 0b fd ff ff       	call   86b4 <lodepng_crc32>
    89a9:	83 c4 08             	add    $0x8,%esp
    89ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    89af:	8b 45 f8             	mov    -0x8(%ebp),%eax
    89b2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    89b5:	74 07                	je     89be <lodepng_chunk_check_crc+0x55>
    89b7:	b8 01 00 00 00       	mov    $0x1,%eax
    89bc:	eb 05                	jmp    89c3 <lodepng_chunk_check_crc+0x5a>
  else return 0;
    89be:	b8 00 00 00 00       	mov    $0x0,%eax
}
    89c3:	c9                   	leave  
    89c4:	c3                   	ret    

000089c5 <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    89c5:	55                   	push   %ebp
    89c6:	89 e5                	mov    %esp,%ebp
    89c8:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    89cb:	ff 75 08             	pushl  0x8(%ebp)
    89ce:	e8 53 fe ff ff       	call   8826 <lodepng_chunk_length>
    89d3:	83 c4 04             	add    $0x4,%esp
    89d6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    89d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    89dc:	83 c0 04             	add    $0x4,%eax
    89df:	89 c2                	mov    %eax,%edx
    89e1:	8b 45 08             	mov    0x8(%ebp),%eax
    89e4:	83 c0 04             	add    $0x4,%eax
    89e7:	52                   	push   %edx
    89e8:	50                   	push   %eax
    89e9:	e8 c6 fc ff ff       	call   86b4 <lodepng_crc32>
    89ee:	83 c4 08             	add    $0x8,%esp
    89f1:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    89f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    89f7:	8d 50 08             	lea    0x8(%eax),%edx
    89fa:	8b 45 08             	mov    0x8(%ebp),%eax
    89fd:	01 d0                	add    %edx,%eax
    89ff:	ff 75 f8             	pushl  -0x8(%ebp)
    8a02:	50                   	push   %eax
    8a03:	e8 5d b2 ff ff       	call   3c65 <lodepng_set32bitInt>
    8a08:	83 c4 08             	add    $0x8,%esp
}
    8a0b:	90                   	nop
    8a0c:	c9                   	leave  
    8a0d:	c3                   	ret    

00008a0e <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    8a0e:	55                   	push   %ebp
    8a0f:	89 e5                	mov    %esp,%ebp
    8a11:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8a14:	8b 45 08             	mov    0x8(%ebp),%eax
    8a17:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8a1a:	73 0f                	jae    8a2b <lodepng_chunk_next+0x1d>
    8a1c:	8b 55 0c             	mov    0xc(%ebp),%edx
    8a1f:	8b 45 08             	mov    0x8(%ebp),%eax
    8a22:	29 c2                	sub    %eax,%edx
    8a24:	89 d0                	mov    %edx,%eax
    8a26:	83 f8 0b             	cmp    $0xb,%eax
    8a29:	7f 08                	jg     8a33 <lodepng_chunk_next+0x25>
    8a2b:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a2e:	e9 af 00 00 00       	jmp    8ae2 <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8a33:	8b 45 08             	mov    0x8(%ebp),%eax
    8a36:	0f b6 00             	movzbl (%eax),%eax
    8a39:	3c 89                	cmp    $0x89,%al
    8a3b:	75 63                	jne    8aa0 <lodepng_chunk_next+0x92>
    8a3d:	8b 45 08             	mov    0x8(%ebp),%eax
    8a40:	83 c0 01             	add    $0x1,%eax
    8a43:	0f b6 00             	movzbl (%eax),%eax
    8a46:	3c 50                	cmp    $0x50,%al
    8a48:	75 56                	jne    8aa0 <lodepng_chunk_next+0x92>
    8a4a:	8b 45 08             	mov    0x8(%ebp),%eax
    8a4d:	83 c0 02             	add    $0x2,%eax
    8a50:	0f b6 00             	movzbl (%eax),%eax
    8a53:	3c 4e                	cmp    $0x4e,%al
    8a55:	75 49                	jne    8aa0 <lodepng_chunk_next+0x92>
    8a57:	8b 45 08             	mov    0x8(%ebp),%eax
    8a5a:	83 c0 03             	add    $0x3,%eax
    8a5d:	0f b6 00             	movzbl (%eax),%eax
    8a60:	3c 47                	cmp    $0x47,%al
    8a62:	75 3c                	jne    8aa0 <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    8a64:	8b 45 08             	mov    0x8(%ebp),%eax
    8a67:	83 c0 04             	add    $0x4,%eax
    8a6a:	0f b6 00             	movzbl (%eax),%eax
    8a6d:	3c 0d                	cmp    $0xd,%al
    8a6f:	75 2f                	jne    8aa0 <lodepng_chunk_next+0x92>
    8a71:	8b 45 08             	mov    0x8(%ebp),%eax
    8a74:	83 c0 05             	add    $0x5,%eax
    8a77:	0f b6 00             	movzbl (%eax),%eax
    8a7a:	3c 0a                	cmp    $0xa,%al
    8a7c:	75 22                	jne    8aa0 <lodepng_chunk_next+0x92>
    8a7e:	8b 45 08             	mov    0x8(%ebp),%eax
    8a81:	83 c0 06             	add    $0x6,%eax
    8a84:	0f b6 00             	movzbl (%eax),%eax
    8a87:	3c 1a                	cmp    $0x1a,%al
    8a89:	75 15                	jne    8aa0 <lodepng_chunk_next+0x92>
    8a8b:	8b 45 08             	mov    0x8(%ebp),%eax
    8a8e:	83 c0 07             	add    $0x7,%eax
    8a91:	0f b6 00             	movzbl (%eax),%eax
    8a94:	3c 0a                	cmp    $0xa,%al
    8a96:	75 08                	jne    8aa0 <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    8a98:	8b 45 08             	mov    0x8(%ebp),%eax
    8a9b:	83 c0 08             	add    $0x8,%eax
    8a9e:	eb 42                	jmp    8ae2 <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    8aa0:	ff 75 08             	pushl  0x8(%ebp)
    8aa3:	e8 7e fd ff ff       	call   8826 <lodepng_chunk_length>
    8aa8:	83 c4 04             	add    $0x4,%esp
    8aab:	89 c2                	mov    %eax,%edx
    8aad:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8ab0:	50                   	push   %eax
    8ab1:	6a 0c                	push   $0xc
    8ab3:	52                   	push   %edx
    8ab4:	e8 af ae ff ff       	call   3968 <lodepng_addofl>
    8ab9:	83 c4 0c             	add    $0xc,%esp
    8abc:	85 c0                	test   %eax,%eax
    8abe:	74 05                	je     8ac5 <lodepng_chunk_next+0xb7>
    8ac0:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ac3:	eb 1d                	jmp    8ae2 <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    8ac5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8ac8:	89 c2                	mov    %eax,%edx
    8aca:	8b 45 08             	mov    0x8(%ebp),%eax
    8acd:	01 d0                	add    %edx,%eax
    8acf:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8ad2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8ad5:	3b 45 08             	cmp    0x8(%ebp),%eax
    8ad8:	73 05                	jae    8adf <lodepng_chunk_next+0xd1>
    8ada:	8b 45 0c             	mov    0xc(%ebp),%eax
    8add:	eb 03                	jmp    8ae2 <lodepng_chunk_next+0xd4>
    return result;
    8adf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8ae2:	c9                   	leave  
    8ae3:	c3                   	ret    

00008ae4 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    8ae4:	55                   	push   %ebp
    8ae5:	89 e5                	mov    %esp,%ebp
    8ae7:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8aea:	8b 45 08             	mov    0x8(%ebp),%eax
    8aed:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8af0:	73 0f                	jae    8b01 <lodepng_chunk_next_const+0x1d>
    8af2:	8b 55 0c             	mov    0xc(%ebp),%edx
    8af5:	8b 45 08             	mov    0x8(%ebp),%eax
    8af8:	29 c2                	sub    %eax,%edx
    8afa:	89 d0                	mov    %edx,%eax
    8afc:	83 f8 0b             	cmp    $0xb,%eax
    8aff:	7f 08                	jg     8b09 <lodepng_chunk_next_const+0x25>
    8b01:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b04:	e9 af 00 00 00       	jmp    8bb8 <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8b09:	8b 45 08             	mov    0x8(%ebp),%eax
    8b0c:	0f b6 00             	movzbl (%eax),%eax
    8b0f:	3c 89                	cmp    $0x89,%al
    8b11:	75 63                	jne    8b76 <lodepng_chunk_next_const+0x92>
    8b13:	8b 45 08             	mov    0x8(%ebp),%eax
    8b16:	83 c0 01             	add    $0x1,%eax
    8b19:	0f b6 00             	movzbl (%eax),%eax
    8b1c:	3c 50                	cmp    $0x50,%al
    8b1e:	75 56                	jne    8b76 <lodepng_chunk_next_const+0x92>
    8b20:	8b 45 08             	mov    0x8(%ebp),%eax
    8b23:	83 c0 02             	add    $0x2,%eax
    8b26:	0f b6 00             	movzbl (%eax),%eax
    8b29:	3c 4e                	cmp    $0x4e,%al
    8b2b:	75 49                	jne    8b76 <lodepng_chunk_next_const+0x92>
    8b2d:	8b 45 08             	mov    0x8(%ebp),%eax
    8b30:	83 c0 03             	add    $0x3,%eax
    8b33:	0f b6 00             	movzbl (%eax),%eax
    8b36:	3c 47                	cmp    $0x47,%al
    8b38:	75 3c                	jne    8b76 <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    8b3a:	8b 45 08             	mov    0x8(%ebp),%eax
    8b3d:	83 c0 04             	add    $0x4,%eax
    8b40:	0f b6 00             	movzbl (%eax),%eax
    8b43:	3c 0d                	cmp    $0xd,%al
    8b45:	75 2f                	jne    8b76 <lodepng_chunk_next_const+0x92>
    8b47:	8b 45 08             	mov    0x8(%ebp),%eax
    8b4a:	83 c0 05             	add    $0x5,%eax
    8b4d:	0f b6 00             	movzbl (%eax),%eax
    8b50:	3c 0a                	cmp    $0xa,%al
    8b52:	75 22                	jne    8b76 <lodepng_chunk_next_const+0x92>
    8b54:	8b 45 08             	mov    0x8(%ebp),%eax
    8b57:	83 c0 06             	add    $0x6,%eax
    8b5a:	0f b6 00             	movzbl (%eax),%eax
    8b5d:	3c 1a                	cmp    $0x1a,%al
    8b5f:	75 15                	jne    8b76 <lodepng_chunk_next_const+0x92>
    8b61:	8b 45 08             	mov    0x8(%ebp),%eax
    8b64:	83 c0 07             	add    $0x7,%eax
    8b67:	0f b6 00             	movzbl (%eax),%eax
    8b6a:	3c 0a                	cmp    $0xa,%al
    8b6c:	75 08                	jne    8b76 <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    8b6e:	8b 45 08             	mov    0x8(%ebp),%eax
    8b71:	83 c0 08             	add    $0x8,%eax
    8b74:	eb 42                	jmp    8bb8 <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    8b76:	ff 75 08             	pushl  0x8(%ebp)
    8b79:	e8 a8 fc ff ff       	call   8826 <lodepng_chunk_length>
    8b7e:	83 c4 04             	add    $0x4,%esp
    8b81:	89 c2                	mov    %eax,%edx
    8b83:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8b86:	50                   	push   %eax
    8b87:	6a 0c                	push   $0xc
    8b89:	52                   	push   %edx
    8b8a:	e8 d9 ad ff ff       	call   3968 <lodepng_addofl>
    8b8f:	83 c4 0c             	add    $0xc,%esp
    8b92:	85 c0                	test   %eax,%eax
    8b94:	74 05                	je     8b9b <lodepng_chunk_next_const+0xb7>
    8b96:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b99:	eb 1d                	jmp    8bb8 <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    8b9b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8b9e:	89 c2                	mov    %eax,%edx
    8ba0:	8b 45 08             	mov    0x8(%ebp),%eax
    8ba3:	01 d0                	add    %edx,%eax
    8ba5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8ba8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8bab:	3b 45 08             	cmp    0x8(%ebp),%eax
    8bae:	73 05                	jae    8bb5 <lodepng_chunk_next_const+0xd1>
    8bb0:	8b 45 0c             	mov    0xc(%ebp),%eax
    8bb3:	eb 03                	jmp    8bb8 <lodepng_chunk_next_const+0xd4>
    return result;
    8bb5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8bb8:	c9                   	leave  
    8bb9:	c3                   	ret    

00008bba <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    8bba:	55                   	push   %ebp
    8bbb:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    8bbd:	8b 45 08             	mov    0x8(%ebp),%eax
    8bc0:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8bc3:	73 0f                	jae    8bd4 <lodepng_chunk_find+0x1a>
    8bc5:	8b 55 0c             	mov    0xc(%ebp),%edx
    8bc8:	8b 45 08             	mov    0x8(%ebp),%eax
    8bcb:	29 c2                	sub    %eax,%edx
    8bcd:	89 d0                	mov    %edx,%eax
    8bcf:	83 f8 0b             	cmp    $0xb,%eax
    8bd2:	7f 07                	jg     8bdb <lodepng_chunk_find+0x21>
    8bd4:	b8 00 00 00 00       	mov    $0x0,%eax
    8bd9:	eb 2a                	jmp    8c05 <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    8bdb:	ff 75 10             	pushl  0x10(%ebp)
    8bde:	ff 75 08             	pushl  0x8(%ebp)
    8be1:	e8 8d fc ff ff       	call   8873 <lodepng_chunk_type_equals>
    8be6:	83 c4 08             	add    $0x8,%esp
    8be9:	84 c0                	test   %al,%al
    8beb:	74 05                	je     8bf2 <lodepng_chunk_find+0x38>
    8bed:	8b 45 08             	mov    0x8(%ebp),%eax
    8bf0:	eb 13                	jmp    8c05 <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    8bf2:	ff 75 0c             	pushl  0xc(%ebp)
    8bf5:	ff 75 08             	pushl  0x8(%ebp)
    8bf8:	e8 11 fe ff ff       	call   8a0e <lodepng_chunk_next>
    8bfd:	83 c4 08             	add    $0x8,%esp
    8c00:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8c03:	eb b8                	jmp    8bbd <lodepng_chunk_find+0x3>
}
    8c05:	c9                   	leave  
    8c06:	c3                   	ret    

00008c07 <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    8c07:	55                   	push   %ebp
    8c08:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    8c0a:	8b 45 08             	mov    0x8(%ebp),%eax
    8c0d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8c10:	73 0f                	jae    8c21 <lodepng_chunk_find_const+0x1a>
    8c12:	8b 55 0c             	mov    0xc(%ebp),%edx
    8c15:	8b 45 08             	mov    0x8(%ebp),%eax
    8c18:	29 c2                	sub    %eax,%edx
    8c1a:	89 d0                	mov    %edx,%eax
    8c1c:	83 f8 0b             	cmp    $0xb,%eax
    8c1f:	7f 07                	jg     8c28 <lodepng_chunk_find_const+0x21>
    8c21:	b8 00 00 00 00       	mov    $0x0,%eax
    8c26:	eb 2a                	jmp    8c52 <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    8c28:	ff 75 10             	pushl  0x10(%ebp)
    8c2b:	ff 75 08             	pushl  0x8(%ebp)
    8c2e:	e8 40 fc ff ff       	call   8873 <lodepng_chunk_type_equals>
    8c33:	83 c4 08             	add    $0x8,%esp
    8c36:	84 c0                	test   %al,%al
    8c38:	74 05                	je     8c3f <lodepng_chunk_find_const+0x38>
    8c3a:	8b 45 08             	mov    0x8(%ebp),%eax
    8c3d:	eb 13                	jmp    8c52 <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    8c3f:	ff 75 0c             	pushl  0xc(%ebp)
    8c42:	ff 75 08             	pushl  0x8(%ebp)
    8c45:	e8 9a fe ff ff       	call   8ae4 <lodepng_chunk_next_const>
    8c4a:	83 c4 08             	add    $0x8,%esp
    8c4d:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8c50:	eb b8                	jmp    8c0a <lodepng_chunk_find_const+0x3>
}
    8c52:	c9                   	leave  
    8c53:	c3                   	ret    

00008c54 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    8c54:	55                   	push   %ebp
    8c55:	89 e5                	mov    %esp,%ebp
    8c57:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    8c5a:	ff 75 10             	pushl  0x10(%ebp)
    8c5d:	e8 c4 fb ff ff       	call   8826 <lodepng_chunk_length>
    8c62:	83 c4 04             	add    $0x4,%esp
    8c65:	89 c2                	mov    %eax,%edx
    8c67:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8c6a:	50                   	push   %eax
    8c6b:	6a 0c                	push   $0xc
    8c6d:	52                   	push   %edx
    8c6e:	e8 f5 ac ff ff       	call   3968 <lodepng_addofl>
    8c73:	83 c4 0c             	add    $0xc,%esp
    8c76:	85 c0                	test   %eax,%eax
    8c78:	74 0a                	je     8c84 <lodepng_chunk_append+0x30>
    8c7a:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8c7f:	e9 96 00 00 00       	jmp    8d1a <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    8c84:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8c87:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c8a:	8b 00                	mov    (%eax),%eax
    8c8c:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    8c8f:	51                   	push   %ecx
    8c90:	52                   	push   %edx
    8c91:	50                   	push   %eax
    8c92:	e8 d1 ac ff ff       	call   3968 <lodepng_addofl>
    8c97:	83 c4 0c             	add    $0xc,%esp
    8c9a:	85 c0                	test   %eax,%eax
    8c9c:	74 07                	je     8ca5 <lodepng_chunk_append+0x51>
    8c9e:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8ca3:	eb 75                	jmp    8d1a <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    8ca5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8ca8:	8b 45 08             	mov    0x8(%ebp),%eax
    8cab:	8b 00                	mov    (%eax),%eax
    8cad:	52                   	push   %edx
    8cae:	50                   	push   %eax
    8caf:	e8 07 ac ff ff       	call   38bb <lodepng_realloc>
    8cb4:	83 c4 08             	add    $0x8,%esp
    8cb7:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    8cba:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    8cbe:	75 07                	jne    8cc7 <lodepng_chunk_append+0x73>
    8cc0:	b8 53 00 00 00       	mov    $0x53,%eax
    8cc5:	eb 53                	jmp    8d1a <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    8cc7:	8b 45 08             	mov    0x8(%ebp),%eax
    8cca:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8ccd:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    8ccf:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8cd2:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cd5:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    8cd7:	8b 45 08             	mov    0x8(%ebp),%eax
    8cda:	8b 00                	mov    (%eax),%eax
    8cdc:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    8cdf:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8ce2:	29 d1                	sub    %edx,%ecx
    8ce4:	89 ca                	mov    %ecx,%edx
    8ce6:	01 d0                	add    %edx,%eax
    8ce8:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    8ceb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8cf2:	eb 19                	jmp    8d0d <lodepng_chunk_append+0xb9>
    8cf4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8cf7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8cfa:	01 c2                	add    %eax,%edx
    8cfc:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8cff:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d02:	01 c8                	add    %ecx,%eax
    8d04:	0f b6 00             	movzbl (%eax),%eax
    8d07:	88 02                	mov    %al,(%edx)
    8d09:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8d0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8d10:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    8d13:	75 df                	jne    8cf4 <lodepng_chunk_append+0xa0>

  return 0;
    8d15:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8d1a:	c9                   	leave  
    8d1b:	c3                   	ret    

00008d1c <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    8d1c:	55                   	push   %ebp
    8d1d:	89 e5                	mov    %esp,%ebp
    8d1f:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    8d22:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d25:	8b 40 04             	mov    0x4(%eax),%eax
    8d28:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    8d2b:	8b 55 10             	mov    0x10(%ebp),%edx
    8d2e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d31:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    8d34:	51                   	push   %ecx
    8d35:	52                   	push   %edx
    8d36:	50                   	push   %eax
    8d37:	e8 2c ac ff ff       	call   3968 <lodepng_addofl>
    8d3c:	83 c4 0c             	add    $0xc,%esp
    8d3f:	85 c0                	test   %eax,%eax
    8d41:	74 07                	je     8d4a <lodepng_chunk_init+0x2e>
    8d43:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8d48:	eb 78                	jmp    8dc2 <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    8d4a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d4d:	8d 55 fc             	lea    -0x4(%ebp),%edx
    8d50:	52                   	push   %edx
    8d51:	6a 0c                	push   $0xc
    8d53:	50                   	push   %eax
    8d54:	e8 0f ac ff ff       	call   3968 <lodepng_addofl>
    8d59:	83 c4 0c             	add    $0xc,%esp
    8d5c:	85 c0                	test   %eax,%eax
    8d5e:	74 07                	je     8d67 <lodepng_chunk_init+0x4b>
    8d60:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8d65:	eb 5b                	jmp    8dc2 <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    8d67:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d6a:	50                   	push   %eax
    8d6b:	ff 75 0c             	pushl  0xc(%ebp)
    8d6e:	e8 8b ad ff ff       	call   3afe <ucvector_resize>
    8d73:	83 c4 08             	add    $0x8,%esp
    8d76:	85 c0                	test   %eax,%eax
    8d78:	75 07                	jne    8d81 <lodepng_chunk_init+0x65>
    8d7a:	b8 53 00 00 00       	mov    $0x53,%eax
    8d7f:	eb 41                	jmp    8dc2 <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    8d81:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d84:	8b 00                	mov    (%eax),%eax
    8d86:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8d89:	2b 55 10             	sub    0x10(%ebp),%edx
    8d8c:	83 ea 0c             	sub    $0xc,%edx
    8d8f:	01 c2                	add    %eax,%edx
    8d91:	8b 45 08             	mov    0x8(%ebp),%eax
    8d94:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    8d96:	8b 45 08             	mov    0x8(%ebp),%eax
    8d99:	8b 00                	mov    (%eax),%eax
    8d9b:	ff 75 10             	pushl  0x10(%ebp)
    8d9e:	50                   	push   %eax
    8d9f:	e8 c1 ae ff ff       	call   3c65 <lodepng_set32bitInt>
    8da4:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    8da7:	8b 45 08             	mov    0x8(%ebp),%eax
    8daa:	8b 00                	mov    (%eax),%eax
    8dac:	83 c0 04             	add    $0x4,%eax
    8daf:	6a 04                	push   $0x4
    8db1:	ff 75 14             	pushl  0x14(%ebp)
    8db4:	50                   	push   %eax
    8db5:	e8 28 ab ff ff       	call   38e2 <lodepng_memcpy>
    8dba:	83 c4 0c             	add    $0xc,%esp

  return 0;
    8dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8dc2:	c9                   	leave  
    8dc3:	c3                   	ret    

00008dc4 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    8dc4:	55                   	push   %ebp
    8dc5:	89 e5                	mov    %esp,%ebp
    8dc7:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    8dca:	ff 75 10             	pushl  0x10(%ebp)
    8dcd:	ff 75 0c             	pushl  0xc(%ebp)
    8dd0:	ff 75 08             	pushl  0x8(%ebp)
    8dd3:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8dd6:	50                   	push   %eax
    8dd7:	e8 40 ff ff ff       	call   8d1c <lodepng_chunk_init>
    8ddc:	83 c4 10             	add    $0x10,%esp
    8ddf:	89 45 fc             	mov    %eax,-0x4(%ebp)
    8de2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    8de6:	74 05                	je     8ded <lodepng_chunk_createv+0x29>
    8de8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8deb:	eb 27                	jmp    8e14 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    8ded:	8b 45 0c             	mov    0xc(%ebp),%eax
    8df0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8df3:	83 c2 08             	add    $0x8,%edx
    8df6:	50                   	push   %eax
    8df7:	ff 75 14             	pushl  0x14(%ebp)
    8dfa:	52                   	push   %edx
    8dfb:	e8 e2 aa ff ff       	call   38e2 <lodepng_memcpy>
    8e00:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    8e03:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8e06:	50                   	push   %eax
    8e07:	e8 b9 fb ff ff       	call   89c5 <lodepng_chunk_generate_crc>
    8e0c:	83 c4 04             	add    $0x4,%esp

  return 0;
    8e0f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8e14:	c9                   	leave  
    8e15:	c3                   	ret    

00008e16 <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    8e16:	55                   	push   %ebp
    8e17:	89 e5                	mov    %esp,%ebp
    8e19:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    8e1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e1f:	8b 08                	mov    (%eax),%ecx
    8e21:	8b 45 08             	mov    0x8(%ebp),%eax
    8e24:	8b 10                	mov    (%eax),%edx
    8e26:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8e29:	51                   	push   %ecx
    8e2a:	52                   	push   %edx
    8e2b:	50                   	push   %eax
    8e2c:	e8 34 ad ff ff       	call   3b65 <ucvector_init>
    8e31:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    8e34:	ff 75 18             	pushl  0x18(%ebp)
    8e37:	ff 75 14             	pushl  0x14(%ebp)
    8e3a:	ff 75 10             	pushl  0x10(%ebp)
    8e3d:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8e40:	50                   	push   %eax
    8e41:	e8 7e ff ff ff       	call   8dc4 <lodepng_chunk_createv>
    8e46:	83 c4 10             	add    $0x10,%esp
    8e49:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    8e4c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8e4f:	8b 45 08             	mov    0x8(%ebp),%eax
    8e52:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8e54:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8e57:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e5a:	89 10                	mov    %edx,(%eax)
  return error;
    8e5c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    8e5f:	c9                   	leave  
    8e60:	c3                   	ret    

00008e61 <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    8e61:	55                   	push   %ebp
    8e62:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8e64:	8b 45 08             	mov    0x8(%ebp),%eax
    8e67:	83 f8 03             	cmp    $0x3,%eax
    8e6a:	74 6d                	je     8ed9 <checkColorValidity+0x78>
    8e6c:	83 f8 03             	cmp    $0x3,%eax
    8e6f:	77 0e                	ja     8e7f <checkColorValidity+0x1e>
    8e71:	85 c0                	test   %eax,%eax
    8e73:	74 28                	je     8e9d <checkColorValidity+0x3c>
    8e75:	83 f8 02             	cmp    $0x2,%eax
    8e78:	74 4c                	je     8ec6 <checkColorValidity+0x65>
    8e7a:	e9 a6 00 00 00       	jmp    8f25 <checkColorValidity+0xc4>
    8e7f:	83 f8 06             	cmp    $0x6,%eax
    8e82:	0f 84 83 00 00 00    	je     8f0b <checkColorValidity+0xaa>
    8e88:	3d ff 00 00 00       	cmp    $0xff,%eax
    8e8d:	0f 84 8b 00 00 00    	je     8f1e <checkColorValidity+0xbd>
    8e93:	83 f8 04             	cmp    $0x4,%eax
    8e96:	74 60                	je     8ef8 <checkColorValidity+0x97>
    8e98:	e9 88 00 00 00       	jmp    8f25 <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8e9d:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8ea1:	0f 84 85 00 00 00    	je     8f2c <checkColorValidity+0xcb>
    8ea7:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8eab:	74 7f                	je     8f2c <checkColorValidity+0xcb>
    8ead:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8eb1:	74 79                	je     8f2c <checkColorValidity+0xcb>
    8eb3:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8eb7:	74 73                	je     8f2c <checkColorValidity+0xcb>
    8eb9:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8ebd:	74 6d                	je     8f2c <checkColorValidity+0xcb>
    8ebf:	b8 25 00 00 00       	mov    $0x25,%eax
    8ec4:	eb 78                	jmp    8f3e <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8ec6:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8eca:	74 63                	je     8f2f <checkColorValidity+0xce>
    8ecc:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8ed0:	74 5d                	je     8f2f <checkColorValidity+0xce>
    8ed2:	b8 25 00 00 00       	mov    $0x25,%eax
    8ed7:	eb 65                	jmp    8f3e <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8ed9:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8edd:	74 53                	je     8f32 <checkColorValidity+0xd1>
    8edf:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8ee3:	74 4d                	je     8f32 <checkColorValidity+0xd1>
    8ee5:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8ee9:	74 47                	je     8f32 <checkColorValidity+0xd1>
    8eeb:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8eef:	74 41                	je     8f32 <checkColorValidity+0xd1>
    8ef1:	b8 25 00 00 00       	mov    $0x25,%eax
    8ef6:	eb 46                	jmp    8f3e <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8ef8:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8efc:	74 37                	je     8f35 <checkColorValidity+0xd4>
    8efe:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8f02:	74 31                	je     8f35 <checkColorValidity+0xd4>
    8f04:	b8 25 00 00 00       	mov    $0x25,%eax
    8f09:	eb 33                	jmp    8f3e <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8f0b:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8f0f:	74 27                	je     8f38 <checkColorValidity+0xd7>
    8f11:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8f15:	74 21                	je     8f38 <checkColorValidity+0xd7>
    8f17:	b8 25 00 00 00       	mov    $0x25,%eax
    8f1c:	eb 20                	jmp    8f3e <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    8f1e:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8f23:	eb 19                	jmp    8f3e <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    8f25:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8f2a:	eb 12                	jmp    8f3e <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8f2c:	90                   	nop
    8f2d:	eb 0a                	jmp    8f39 <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8f2f:	90                   	nop
    8f30:	eb 07                	jmp    8f39 <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8f32:	90                   	nop
    8f33:	eb 04                	jmp    8f39 <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8f35:	90                   	nop
    8f36:	eb 01                	jmp    8f39 <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8f38:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    8f39:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f3e:	5d                   	pop    %ebp
    8f3f:	c3                   	ret    

00008f40 <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    8f40:	55                   	push   %ebp
    8f41:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8f43:	8b 45 08             	mov    0x8(%ebp),%eax
    8f46:	83 f8 03             	cmp    $0x3,%eax
    8f49:	74 31                	je     8f7c <getNumColorChannels+0x3c>
    8f4b:	83 f8 03             	cmp    $0x3,%eax
    8f4e:	77 0b                	ja     8f5b <getNumColorChannels+0x1b>
    8f50:	85 c0                	test   %eax,%eax
    8f52:	74 1a                	je     8f6e <getNumColorChannels+0x2e>
    8f54:	83 f8 02             	cmp    $0x2,%eax
    8f57:	74 1c                	je     8f75 <getNumColorChannels+0x35>
    8f59:	eb 3d                	jmp    8f98 <getNumColorChannels+0x58>
    8f5b:	83 f8 06             	cmp    $0x6,%eax
    8f5e:	74 2a                	je     8f8a <getNumColorChannels+0x4a>
    8f60:	3d ff 00 00 00       	cmp    $0xff,%eax
    8f65:	74 2a                	je     8f91 <getNumColorChannels+0x51>
    8f67:	83 f8 04             	cmp    $0x4,%eax
    8f6a:	74 17                	je     8f83 <getNumColorChannels+0x43>
    8f6c:	eb 2a                	jmp    8f98 <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    8f6e:	b8 01 00 00 00       	mov    $0x1,%eax
    8f73:	eb 28                	jmp    8f9d <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    8f75:	b8 03 00 00 00       	mov    $0x3,%eax
    8f7a:	eb 21                	jmp    8f9d <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    8f7c:	b8 01 00 00 00       	mov    $0x1,%eax
    8f81:	eb 1a                	jmp    8f9d <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    8f83:	b8 02 00 00 00       	mov    $0x2,%eax
    8f88:	eb 13                	jmp    8f9d <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    8f8a:	b8 04 00 00 00       	mov    $0x4,%eax
    8f8f:	eb 0c                	jmp    8f9d <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    8f91:	b8 00 00 00 00       	mov    $0x0,%eax
    8f96:	eb 05                	jmp    8f9d <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    8f98:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    8f9d:	5d                   	pop    %ebp
    8f9e:	c3                   	ret    

00008f9f <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    8f9f:	55                   	push   %ebp
    8fa0:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    8fa2:	ff 75 08             	pushl  0x8(%ebp)
    8fa5:	e8 96 ff ff ff       	call   8f40 <getNumColorChannels>
    8faa:	83 c4 04             	add    $0x4,%esp
    8fad:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    8fb1:	c9                   	leave  
    8fb2:	c3                   	ret    

00008fb3 <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    8fb3:	55                   	push   %ebp
    8fb4:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    8fb6:	8b 45 08             	mov    0x8(%ebp),%eax
    8fb9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    8fc0:	8b 45 08             	mov    0x8(%ebp),%eax
    8fc3:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    8fca:	8b 45 08             	mov    0x8(%ebp),%eax
    8fcd:	8b 50 1c             	mov    0x1c(%eax),%edx
    8fd0:	8b 45 08             	mov    0x8(%ebp),%eax
    8fd3:	89 50 18             	mov    %edx,0x18(%eax)
    8fd6:	8b 45 08             	mov    0x8(%ebp),%eax
    8fd9:	8b 50 18             	mov    0x18(%eax),%edx
    8fdc:	8b 45 08             	mov    0x8(%ebp),%eax
    8fdf:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    8fe2:	8b 45 08             	mov    0x8(%ebp),%eax
    8fe5:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    8feb:	8b 45 08             	mov    0x8(%ebp),%eax
    8fee:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    8ff5:	8b 45 08             	mov    0x8(%ebp),%eax
    8ff8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8fff:	8b 45 08             	mov    0x8(%ebp),%eax
    9002:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    9009:	90                   	nop
    900a:	5d                   	pop    %ebp
    900b:	c3                   	ret    

0000900c <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    900c:	55                   	push   %ebp
    900d:	89 e5                	mov    %esp,%ebp
    900f:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    9012:	8b 45 08             	mov    0x8(%ebp),%eax
    9015:	8b 40 08             	mov    0x8(%eax),%eax
    9018:	85 c0                	test   %eax,%eax
    901a:	75 18                	jne    9034 <lodepng_color_mode_alloc_palette+0x28>
    901c:	83 ec 0c             	sub    $0xc,%esp
    901f:	68 00 04 00 00       	push   $0x400
    9024:	e8 7b a8 ff ff       	call   38a4 <lodepng_malloc>
    9029:	83 c4 10             	add    $0x10,%esp
    902c:	89 c2                	mov    %eax,%edx
    902e:	8b 45 08             	mov    0x8(%ebp),%eax
    9031:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    9034:	8b 45 08             	mov    0x8(%ebp),%eax
    9037:	8b 40 08             	mov    0x8(%eax),%eax
    903a:	85 c0                	test   %eax,%eax
    903c:	74 65                	je     90a3 <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    903e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9045:	eb 51                	jmp    9098 <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    9047:	8b 45 08             	mov    0x8(%ebp),%eax
    904a:	8b 40 08             	mov    0x8(%eax),%eax
    904d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9050:	c1 e2 02             	shl    $0x2,%edx
    9053:	01 d0                	add    %edx,%eax
    9055:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    9058:	8b 45 08             	mov    0x8(%ebp),%eax
    905b:	8b 40 08             	mov    0x8(%eax),%eax
    905e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9061:	c1 e2 02             	shl    $0x2,%edx
    9064:	83 c2 01             	add    $0x1,%edx
    9067:	01 d0                	add    %edx,%eax
    9069:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    906c:	8b 45 08             	mov    0x8(%ebp),%eax
    906f:	8b 40 08             	mov    0x8(%eax),%eax
    9072:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9075:	c1 e2 02             	shl    $0x2,%edx
    9078:	83 c2 02             	add    $0x2,%edx
    907b:	01 d0                	add    %edx,%eax
    907d:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    9080:	8b 45 08             	mov    0x8(%ebp),%eax
    9083:	8b 40 08             	mov    0x8(%eax),%eax
    9086:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9089:	c1 e2 02             	shl    $0x2,%edx
    908c:	83 c2 03             	add    $0x3,%edx
    908f:	01 d0                	add    %edx,%eax
    9091:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    9094:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9098:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    909f:	75 a6                	jne    9047 <lodepng_color_mode_alloc_palette+0x3b>
    90a1:	eb 01                	jmp    90a4 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    90a3:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    90a4:	c9                   	leave  
    90a5:	c3                   	ret    

000090a6 <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    90a6:	55                   	push   %ebp
    90a7:	89 e5                	mov    %esp,%ebp
    90a9:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    90ac:	83 ec 0c             	sub    $0xc,%esp
    90af:	ff 75 08             	pushl  0x8(%ebp)
    90b2:	e8 f3 01 00 00       	call   92aa <lodepng_palette_clear>
    90b7:	83 c4 10             	add    $0x10,%esp
}
    90ba:	90                   	nop
    90bb:	c9                   	leave  
    90bc:	c3                   	ret    

000090bd <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    90bd:	55                   	push   %ebp
    90be:	89 e5                	mov    %esp,%ebp
    90c0:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    90c3:	83 ec 0c             	sub    $0xc,%esp
    90c6:	ff 75 08             	pushl  0x8(%ebp)
    90c9:	e8 d8 ff ff ff       	call   90a6 <lodepng_color_mode_cleanup>
    90ce:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    90d1:	83 ec 04             	sub    $0x4,%esp
    90d4:	6a 20                	push   $0x20
    90d6:	ff 75 0c             	pushl  0xc(%ebp)
    90d9:	ff 75 08             	pushl  0x8(%ebp)
    90dc:	e8 01 a8 ff ff       	call   38e2 <lodepng_memcpy>
    90e1:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    90e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    90e7:	8b 40 08             	mov    0x8(%eax),%eax
    90ea:	85 c0                	test   %eax,%eax
    90ec:	74 5a                	je     9148 <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    90ee:	83 ec 0c             	sub    $0xc,%esp
    90f1:	68 00 04 00 00       	push   $0x400
    90f6:	e8 a9 a7 ff ff       	call   38a4 <lodepng_malloc>
    90fb:	83 c4 10             	add    $0x10,%esp
    90fe:	89 c2                	mov    %eax,%edx
    9100:	8b 45 08             	mov    0x8(%ebp),%eax
    9103:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    9106:	8b 45 08             	mov    0x8(%ebp),%eax
    9109:	8b 40 08             	mov    0x8(%eax),%eax
    910c:	85 c0                	test   %eax,%eax
    910e:	75 11                	jne    9121 <lodepng_color_mode_copy+0x64>
    9110:	8b 45 0c             	mov    0xc(%ebp),%eax
    9113:	8b 40 0c             	mov    0xc(%eax),%eax
    9116:	85 c0                	test   %eax,%eax
    9118:	74 07                	je     9121 <lodepng_color_mode_copy+0x64>
    911a:	b8 53 00 00 00       	mov    $0x53,%eax
    911f:	eb 2c                	jmp    914d <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    9121:	8b 45 0c             	mov    0xc(%ebp),%eax
    9124:	8b 40 0c             	mov    0xc(%eax),%eax
    9127:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    912e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9131:	8b 50 08             	mov    0x8(%eax),%edx
    9134:	8b 45 08             	mov    0x8(%ebp),%eax
    9137:	8b 40 08             	mov    0x8(%eax),%eax
    913a:	83 ec 04             	sub    $0x4,%esp
    913d:	51                   	push   %ecx
    913e:	52                   	push   %edx
    913f:	50                   	push   %eax
    9140:	e8 9d a7 ff ff       	call   38e2 <lodepng_memcpy>
    9145:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    9148:	b8 00 00 00 00       	mov    $0x0,%eax
}
    914d:	c9                   	leave  
    914e:	c3                   	ret    

0000914f <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    914f:	55                   	push   %ebp
    9150:	89 e5                	mov    %esp,%ebp
    9152:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    9155:	8d 45 e0             	lea    -0x20(%ebp),%eax
    9158:	50                   	push   %eax
    9159:	e8 55 fe ff ff       	call   8fb3 <lodepng_color_mode_init>
    915e:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    9161:	8b 45 0c             	mov    0xc(%ebp),%eax
    9164:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    9167:	8b 45 10             	mov    0x10(%ebp),%eax
    916a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    916d:	8b 45 08             	mov    0x8(%ebp),%eax
    9170:	8b 55 e0             	mov    -0x20(%ebp),%edx
    9173:	89 10                	mov    %edx,(%eax)
    9175:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    9178:	89 50 04             	mov    %edx,0x4(%eax)
    917b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    917e:	89 50 08             	mov    %edx,0x8(%eax)
    9181:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9184:	89 50 0c             	mov    %edx,0xc(%eax)
    9187:	8b 55 f0             	mov    -0x10(%ebp),%edx
    918a:	89 50 10             	mov    %edx,0x10(%eax)
    918d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9190:	89 50 14             	mov    %edx,0x14(%eax)
    9193:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9196:	89 50 18             	mov    %edx,0x18(%eax)
    9199:	8b 55 fc             	mov    -0x4(%ebp),%edx
    919c:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    919f:	8b 45 08             	mov    0x8(%ebp),%eax
    91a2:	c9                   	leave  
    91a3:	c2 04 00             	ret    $0x4

000091a6 <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    91a6:	55                   	push   %ebp
    91a7:	89 e5                	mov    %esp,%ebp
    91a9:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    91ac:	8b 45 08             	mov    0x8(%ebp),%eax
    91af:	8b 10                	mov    (%eax),%edx
    91b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    91b4:	8b 00                	mov    (%eax),%eax
    91b6:	39 c2                	cmp    %eax,%edx
    91b8:	74 0a                	je     91c4 <lodepng_color_mode_equal+0x1e>
    91ba:	b8 00 00 00 00       	mov    $0x0,%eax
    91bf:	e9 e4 00 00 00       	jmp    92a8 <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    91c4:	8b 45 08             	mov    0x8(%ebp),%eax
    91c7:	8b 50 04             	mov    0x4(%eax),%edx
    91ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    91cd:	8b 40 04             	mov    0x4(%eax),%eax
    91d0:	39 c2                	cmp    %eax,%edx
    91d2:	74 0a                	je     91de <lodepng_color_mode_equal+0x38>
    91d4:	b8 00 00 00 00       	mov    $0x0,%eax
    91d9:	e9 ca 00 00 00       	jmp    92a8 <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    91de:	8b 45 08             	mov    0x8(%ebp),%eax
    91e1:	8b 50 10             	mov    0x10(%eax),%edx
    91e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    91e7:	8b 40 10             	mov    0x10(%eax),%eax
    91ea:	39 c2                	cmp    %eax,%edx
    91ec:	74 0a                	je     91f8 <lodepng_color_mode_equal+0x52>
    91ee:	b8 00 00 00 00       	mov    $0x0,%eax
    91f3:	e9 b0 00 00 00       	jmp    92a8 <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    91f8:	8b 45 08             	mov    0x8(%ebp),%eax
    91fb:	8b 40 10             	mov    0x10(%eax),%eax
    91fe:	85 c0                	test   %eax,%eax
    9200:	74 48                	je     924a <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    9202:	8b 45 08             	mov    0x8(%ebp),%eax
    9205:	8b 50 14             	mov    0x14(%eax),%edx
    9208:	8b 45 0c             	mov    0xc(%ebp),%eax
    920b:	8b 40 14             	mov    0x14(%eax),%eax
    920e:	39 c2                	cmp    %eax,%edx
    9210:	74 0a                	je     921c <lodepng_color_mode_equal+0x76>
    9212:	b8 00 00 00 00       	mov    $0x0,%eax
    9217:	e9 8c 00 00 00       	jmp    92a8 <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    921c:	8b 45 08             	mov    0x8(%ebp),%eax
    921f:	8b 50 18             	mov    0x18(%eax),%edx
    9222:	8b 45 0c             	mov    0xc(%ebp),%eax
    9225:	8b 40 18             	mov    0x18(%eax),%eax
    9228:	39 c2                	cmp    %eax,%edx
    922a:	74 07                	je     9233 <lodepng_color_mode_equal+0x8d>
    922c:	b8 00 00 00 00       	mov    $0x0,%eax
    9231:	eb 75                	jmp    92a8 <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    9233:	8b 45 08             	mov    0x8(%ebp),%eax
    9236:	8b 50 1c             	mov    0x1c(%eax),%edx
    9239:	8b 45 0c             	mov    0xc(%ebp),%eax
    923c:	8b 40 1c             	mov    0x1c(%eax),%eax
    923f:	39 c2                	cmp    %eax,%edx
    9241:	74 07                	je     924a <lodepng_color_mode_equal+0xa4>
    9243:	b8 00 00 00 00       	mov    $0x0,%eax
    9248:	eb 5e                	jmp    92a8 <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    924a:	8b 45 08             	mov    0x8(%ebp),%eax
    924d:	8b 50 0c             	mov    0xc(%eax),%edx
    9250:	8b 45 0c             	mov    0xc(%ebp),%eax
    9253:	8b 40 0c             	mov    0xc(%eax),%eax
    9256:	39 c2                	cmp    %eax,%edx
    9258:	74 07                	je     9261 <lodepng_color_mode_equal+0xbb>
    925a:	b8 00 00 00 00       	mov    $0x0,%eax
    925f:	eb 47                	jmp    92a8 <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    9261:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9268:	eb 2b                	jmp    9295 <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    926a:	8b 45 08             	mov    0x8(%ebp),%eax
    926d:	8b 50 08             	mov    0x8(%eax),%edx
    9270:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9273:	01 d0                	add    %edx,%eax
    9275:	0f b6 10             	movzbl (%eax),%edx
    9278:	8b 45 0c             	mov    0xc(%ebp),%eax
    927b:	8b 48 08             	mov    0x8(%eax),%ecx
    927e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9281:	01 c8                	add    %ecx,%eax
    9283:	0f b6 00             	movzbl (%eax),%eax
    9286:	38 c2                	cmp    %al,%dl
    9288:	74 07                	je     9291 <lodepng_color_mode_equal+0xeb>
    928a:	b8 00 00 00 00       	mov    $0x0,%eax
    928f:	eb 17                	jmp    92a8 <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    9291:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9295:	8b 45 08             	mov    0x8(%ebp),%eax
    9298:	8b 40 0c             	mov    0xc(%eax),%eax
    929b:	c1 e0 02             	shl    $0x2,%eax
    929e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    92a1:	75 c7                	jne    926a <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    92a3:	b8 01 00 00 00       	mov    $0x1,%eax
}
    92a8:	c9                   	leave  
    92a9:	c3                   	ret    

000092aa <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    92aa:	55                   	push   %ebp
    92ab:	89 e5                	mov    %esp,%ebp
    92ad:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    92b0:	8b 45 08             	mov    0x8(%ebp),%eax
    92b3:	8b 40 08             	mov    0x8(%eax),%eax
    92b6:	85 c0                	test   %eax,%eax
    92b8:	74 12                	je     92cc <lodepng_palette_clear+0x22>
    92ba:	8b 45 08             	mov    0x8(%ebp),%eax
    92bd:	8b 40 08             	mov    0x8(%eax),%eax
    92c0:	83 ec 0c             	sub    $0xc,%esp
    92c3:	50                   	push   %eax
    92c4:	e8 fc a5 ff ff       	call   38c5 <lodepng_free>
    92c9:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    92cc:	8b 45 08             	mov    0x8(%ebp),%eax
    92cf:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    92d6:	8b 45 08             	mov    0x8(%ebp),%eax
    92d9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    92e0:	90                   	nop
    92e1:	c9                   	leave  
    92e2:	c3                   	ret    

000092e3 <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    92e3:	55                   	push   %ebp
    92e4:	89 e5                	mov    %esp,%ebp
    92e6:	53                   	push   %ebx
    92e7:	83 ec 14             	sub    $0x14,%esp
    92ea:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    92ed:	8b 4d 10             	mov    0x10(%ebp),%ecx
    92f0:	8b 55 14             	mov    0x14(%ebp),%edx
    92f3:	8b 45 18             	mov    0x18(%ebp),%eax
    92f6:	88 5d f4             	mov    %bl,-0xc(%ebp)
    92f9:	88 4d f0             	mov    %cl,-0x10(%ebp)
    92fc:	88 55 ec             	mov    %dl,-0x14(%ebp)
    92ff:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    9302:	8b 45 08             	mov    0x8(%ebp),%eax
    9305:	8b 40 08             	mov    0x8(%eax),%eax
    9308:	85 c0                	test   %eax,%eax
    930a:	75 22                	jne    932e <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    930c:	83 ec 0c             	sub    $0xc,%esp
    930f:	ff 75 08             	pushl  0x8(%ebp)
    9312:	e8 f5 fc ff ff       	call   900c <lodepng_color_mode_alloc_palette>
    9317:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    931a:	8b 45 08             	mov    0x8(%ebp),%eax
    931d:	8b 40 08             	mov    0x8(%eax),%eax
    9320:	85 c0                	test   %eax,%eax
    9322:	75 0a                	jne    932e <lodepng_palette_add+0x4b>
    9324:	b8 53 00 00 00       	mov    $0x53,%eax
    9329:	e9 8d 00 00 00       	jmp    93bb <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    932e:	8b 45 08             	mov    0x8(%ebp),%eax
    9331:	8b 40 0c             	mov    0xc(%eax),%eax
    9334:	3d ff 00 00 00       	cmp    $0xff,%eax
    9339:	7e 07                	jle    9342 <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    933b:	b8 6c 00 00 00       	mov    $0x6c,%eax
    9340:	eb 79                	jmp    93bb <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    9342:	8b 45 08             	mov    0x8(%ebp),%eax
    9345:	8b 50 08             	mov    0x8(%eax),%edx
    9348:	8b 45 08             	mov    0x8(%ebp),%eax
    934b:	8b 40 0c             	mov    0xc(%eax),%eax
    934e:	c1 e0 02             	shl    $0x2,%eax
    9351:	01 c2                	add    %eax,%edx
    9353:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    9357:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    9359:	8b 45 08             	mov    0x8(%ebp),%eax
    935c:	8b 50 08             	mov    0x8(%eax),%edx
    935f:	8b 45 08             	mov    0x8(%ebp),%eax
    9362:	8b 40 0c             	mov    0xc(%eax),%eax
    9365:	c1 e0 02             	shl    $0x2,%eax
    9368:	83 c0 01             	add    $0x1,%eax
    936b:	01 c2                	add    %eax,%edx
    936d:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    9371:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    9373:	8b 45 08             	mov    0x8(%ebp),%eax
    9376:	8b 50 08             	mov    0x8(%eax),%edx
    9379:	8b 45 08             	mov    0x8(%ebp),%eax
    937c:	8b 40 0c             	mov    0xc(%eax),%eax
    937f:	c1 e0 02             	shl    $0x2,%eax
    9382:	83 c0 02             	add    $0x2,%eax
    9385:	01 c2                	add    %eax,%edx
    9387:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    938b:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    938d:	8b 45 08             	mov    0x8(%ebp),%eax
    9390:	8b 50 08             	mov    0x8(%eax),%edx
    9393:	8b 45 08             	mov    0x8(%ebp),%eax
    9396:	8b 40 0c             	mov    0xc(%eax),%eax
    9399:	c1 e0 02             	shl    $0x2,%eax
    939c:	83 c0 03             	add    $0x3,%eax
    939f:	01 c2                	add    %eax,%edx
    93a1:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    93a5:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    93a7:	8b 45 08             	mov    0x8(%ebp),%eax
    93aa:	8b 40 0c             	mov    0xc(%eax),%eax
    93ad:	8d 50 01             	lea    0x1(%eax),%edx
    93b0:	8b 45 08             	mov    0x8(%ebp),%eax
    93b3:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    93b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    93bb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    93be:	c9                   	leave  
    93bf:	c3                   	ret    

000093c0 <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    93c0:	55                   	push   %ebp
    93c1:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    93c3:	8b 45 08             	mov    0x8(%ebp),%eax
    93c6:	8b 50 04             	mov    0x4(%eax),%edx
    93c9:	8b 45 08             	mov    0x8(%ebp),%eax
    93cc:	8b 00                	mov    (%eax),%eax
    93ce:	52                   	push   %edx
    93cf:	50                   	push   %eax
    93d0:	e8 ca fb ff ff       	call   8f9f <lodepng_get_bpp_lct>
    93d5:	83 c4 08             	add    $0x8,%esp
}
    93d8:	c9                   	leave  
    93d9:	c3                   	ret    

000093da <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    93da:	55                   	push   %ebp
    93db:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    93dd:	8b 45 08             	mov    0x8(%ebp),%eax
    93e0:	8b 00                	mov    (%eax),%eax
    93e2:	50                   	push   %eax
    93e3:	e8 58 fb ff ff       	call   8f40 <getNumColorChannels>
    93e8:	83 c4 04             	add    $0x4,%esp
}
    93eb:	c9                   	leave  
    93ec:	c3                   	ret    

000093ed <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    93ed:	55                   	push   %ebp
    93ee:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    93f0:	8b 45 08             	mov    0x8(%ebp),%eax
    93f3:	8b 00                	mov    (%eax),%eax
    93f5:	85 c0                	test   %eax,%eax
    93f7:	74 0a                	je     9403 <lodepng_is_greyscale_type+0x16>
    93f9:	8b 45 08             	mov    0x8(%ebp),%eax
    93fc:	8b 00                	mov    (%eax),%eax
    93fe:	83 f8 04             	cmp    $0x4,%eax
    9401:	75 07                	jne    940a <lodepng_is_greyscale_type+0x1d>
    9403:	b8 01 00 00 00       	mov    $0x1,%eax
    9408:	eb 05                	jmp    940f <lodepng_is_greyscale_type+0x22>
    940a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    940f:	5d                   	pop    %ebp
    9410:	c3                   	ret    

00009411 <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    9411:	55                   	push   %ebp
    9412:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    9414:	8b 45 08             	mov    0x8(%ebp),%eax
    9417:	8b 00                	mov    (%eax),%eax
    9419:	83 e0 04             	and    $0x4,%eax
    941c:	85 c0                	test   %eax,%eax
    941e:	0f 95 c0             	setne  %al
    9421:	0f b6 c0             	movzbl %al,%eax
}
    9424:	5d                   	pop    %ebp
    9425:	c3                   	ret    

00009426 <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    9426:	55                   	push   %ebp
    9427:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    9429:	8b 45 08             	mov    0x8(%ebp),%eax
    942c:	8b 00                	mov    (%eax),%eax
    942e:	83 f8 03             	cmp    $0x3,%eax
    9431:	0f 94 c0             	sete   %al
    9434:	0f b6 c0             	movzbl %al,%eax
}
    9437:	5d                   	pop    %ebp
    9438:	c3                   	ret    

00009439 <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    9439:	55                   	push   %ebp
    943a:	89 e5                	mov    %esp,%ebp
    943c:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    943f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9446:	eb 23                	jmp    946b <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    9448:	8b 45 08             	mov    0x8(%ebp),%eax
    944b:	8b 40 08             	mov    0x8(%eax),%eax
    944e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9451:	c1 e2 02             	shl    $0x2,%edx
    9454:	83 c2 03             	add    $0x3,%edx
    9457:	01 d0                	add    %edx,%eax
    9459:	0f b6 00             	movzbl (%eax),%eax
    945c:	3c ff                	cmp    $0xff,%al
    945e:	74 07                	je     9467 <lodepng_has_palette_alpha+0x2e>
    9460:	b8 01 00 00 00       	mov    $0x1,%eax
    9465:	eb 14                	jmp    947b <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    9467:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    946b:	8b 45 08             	mov    0x8(%ebp),%eax
    946e:	8b 40 0c             	mov    0xc(%eax),%eax
    9471:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    9474:	75 d2                	jne    9448 <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    9476:	b8 00 00 00 00       	mov    $0x0,%eax
}
    947b:	c9                   	leave  
    947c:	c3                   	ret    

0000947d <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    947d:	55                   	push   %ebp
    947e:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    9480:	8b 45 08             	mov    0x8(%ebp),%eax
    9483:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    9486:	85 c0                	test   %eax,%eax
    9488:	75 1e                	jne    94a8 <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    948a:	ff 75 08             	pushl  0x8(%ebp)
    948d:	e8 7f ff ff ff       	call   9411 <lodepng_is_alpha_type>
    9492:	83 c4 04             	add    $0x4,%esp
    9495:	85 c0                	test   %eax,%eax
    9497:	75 0f                	jne    94a8 <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    9499:	ff 75 08             	pushl  0x8(%ebp)
    949c:	e8 98 ff ff ff       	call   9439 <lodepng_has_palette_alpha>
    94a1:	83 c4 04             	add    $0x4,%esp
    94a4:	85 c0                	test   %eax,%eax
    94a6:	74 07                	je     94af <lodepng_can_have_alpha+0x32>
    94a8:	b8 01 00 00 00       	mov    $0x1,%eax
    94ad:	eb 05                	jmp    94b4 <lodepng_can_have_alpha+0x37>
    94af:	b8 00 00 00 00       	mov    $0x0,%eax
}
    94b4:	c9                   	leave  
    94b5:	c3                   	ret    

000094b6 <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    94b6:	55                   	push   %ebp
    94b7:	89 e5                	mov    %esp,%ebp
    94b9:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    94bc:	ff 75 14             	pushl  0x14(%ebp)
    94bf:	ff 75 10             	pushl  0x10(%ebp)
    94c2:	e8 d8 fa ff ff       	call   8f9f <lodepng_get_bpp_lct>
    94c7:	83 c4 08             	add    $0x8,%esp
    94ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    94cd:	8b 55 08             	mov    0x8(%ebp),%edx
    94d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    94d3:	0f af c2             	imul   %edx,%eax
    94d6:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    94d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    94dc:	c1 e8 03             	shr    $0x3,%eax
    94df:	89 c2                	mov    %eax,%edx
    94e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    94e4:	0f af c2             	imul   %edx,%eax
    94e7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    94ea:	89 d1                	mov    %edx,%ecx
    94ec:	83 e1 07             	and    $0x7,%ecx
    94ef:	8b 55 fc             	mov    -0x4(%ebp),%edx
    94f2:	0f af d1             	imul   %ecx,%edx
    94f5:	83 c2 07             	add    $0x7,%edx
    94f8:	c1 ea 03             	shr    $0x3,%edx
    94fb:	01 d0                	add    %edx,%eax
}
    94fd:	c9                   	leave  
    94fe:	c3                   	ret    

000094ff <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    94ff:	55                   	push   %ebp
    9500:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    9502:	8b 45 10             	mov    0x10(%ebp),%eax
    9505:	8b 50 04             	mov    0x4(%eax),%edx
    9508:	8b 45 10             	mov    0x10(%ebp),%eax
    950b:	8b 00                	mov    (%eax),%eax
    950d:	52                   	push   %edx
    950e:	50                   	push   %eax
    950f:	ff 75 0c             	pushl  0xc(%ebp)
    9512:	ff 75 08             	pushl  0x8(%ebp)
    9515:	e8 9c ff ff ff       	call   94b6 <lodepng_get_raw_size_lct>
    951a:	83 c4 10             	add    $0x10,%esp
}
    951d:	c9                   	leave  
    951e:	c3                   	ret    

0000951f <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    951f:	55                   	push   %ebp
    9520:	89 e5                	mov    %esp,%ebp
    9522:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    9525:	8b 45 08             	mov    0x8(%ebp),%eax
    9528:	c1 e8 03             	shr    $0x3,%eax
    952b:	0f af 45 10          	imul   0x10(%ebp),%eax
    952f:	8b 55 08             	mov    0x8(%ebp),%edx
    9532:	83 e2 07             	and    $0x7,%edx
    9535:	0f af 55 10          	imul   0x10(%ebp),%edx
    9539:	83 c2 07             	add    $0x7,%edx
    953c:	c1 ea 03             	shr    $0x3,%edx
    953f:	01 d0                	add    %edx,%eax
    9541:	83 c0 01             	add    $0x1,%eax
    9544:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    9547:	8b 45 0c             	mov    0xc(%ebp),%eax
    954a:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    954e:	c9                   	leave  
    954f:	c3                   	ret    

00009550 <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    9550:	55                   	push   %ebp
    9551:	89 e5                	mov    %esp,%ebp
    9553:	53                   	push   %ebx
    9554:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    9557:	ff 75 10             	pushl  0x10(%ebp)
    955a:	e8 61 fe ff ff       	call   93c0 <lodepng_get_bpp>
    955f:	83 c4 04             	add    $0x4,%esp
    9562:	89 c3                	mov    %eax,%ebx
    9564:	ff 75 14             	pushl  0x14(%ebp)
    9567:	e8 54 fe ff ff       	call   93c0 <lodepng_get_bpp>
    956c:	83 c4 04             	add    $0x4,%esp
    956f:	39 c3                	cmp    %eax,%ebx
    9571:	76 0d                	jbe    9580 <lodepng_pixel_overflow+0x30>
    9573:	ff 75 10             	pushl  0x10(%ebp)
    9576:	e8 45 fe ff ff       	call   93c0 <lodepng_get_bpp>
    957b:	83 c4 04             	add    $0x4,%esp
    957e:	eb 0b                	jmp    958b <lodepng_pixel_overflow+0x3b>
    9580:	ff 75 14             	pushl  0x14(%ebp)
    9583:	e8 38 fe ff ff       	call   93c0 <lodepng_get_bpp>
    9588:	83 c4 04             	add    $0x4,%esp
    958b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    958e:	8b 55 0c             	mov    0xc(%ebp),%edx
    9591:	8b 45 08             	mov    0x8(%ebp),%eax
    9594:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    9597:	51                   	push   %ecx
    9598:	52                   	push   %edx
    9599:	50                   	push   %eax
    959a:	e8 e9 a3 ff ff       	call   3988 <lodepng_mulofl>
    959f:	83 c4 0c             	add    $0xc,%esp
    95a2:	85 c0                	test   %eax,%eax
    95a4:	74 0a                	je     95b0 <lodepng_pixel_overflow+0x60>
    95a6:	b8 01 00 00 00       	mov    $0x1,%eax
    95ab:	e9 b6 00 00 00       	jmp    9666 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    95b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    95b3:	8d 55 f0             	lea    -0x10(%ebp),%edx
    95b6:	52                   	push   %edx
    95b7:	6a 08                	push   $0x8
    95b9:	50                   	push   %eax
    95ba:	e8 c9 a3 ff ff       	call   3988 <lodepng_mulofl>
    95bf:	83 c4 0c             	add    $0xc,%esp
    95c2:	85 c0                	test   %eax,%eax
    95c4:	74 0a                	je     95d0 <lodepng_pixel_overflow+0x80>
    95c6:	b8 01 00 00 00       	mov    $0x1,%eax
    95cb:	e9 96 00 00 00       	jmp    9666 <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    95d0:	8b 45 08             	mov    0x8(%ebp),%eax
    95d3:	c1 e8 03             	shr    $0x3,%eax
    95d6:	89 c2                	mov    %eax,%edx
    95d8:	8d 45 ec             	lea    -0x14(%ebp),%eax
    95db:	50                   	push   %eax
    95dc:	ff 75 f8             	pushl  -0x8(%ebp)
    95df:	52                   	push   %edx
    95e0:	e8 a3 a3 ff ff       	call   3988 <lodepng_mulofl>
    95e5:	83 c4 0c             	add    $0xc,%esp
    95e8:	85 c0                	test   %eax,%eax
    95ea:	74 07                	je     95f3 <lodepng_pixel_overflow+0xa3>
    95ec:	b8 01 00 00 00       	mov    $0x1,%eax
    95f1:	eb 73                	jmp    9666 <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    95f3:	8b 45 08             	mov    0x8(%ebp),%eax
    95f6:	83 e0 07             	and    $0x7,%eax
    95f9:	89 c2                	mov    %eax,%edx
    95fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    95fe:	0f af c2             	imul   %edx,%eax
    9601:	83 c0 07             	add    $0x7,%eax
    9604:	c1 e8 03             	shr    $0x3,%eax
    9607:	89 c1                	mov    %eax,%ecx
    9609:	8b 45 ec             	mov    -0x14(%ebp),%eax
    960c:	8d 55 ec             	lea    -0x14(%ebp),%edx
    960f:	52                   	push   %edx
    9610:	51                   	push   %ecx
    9611:	50                   	push   %eax
    9612:	e8 51 a3 ff ff       	call   3968 <lodepng_addofl>
    9617:	83 c4 0c             	add    $0xc,%esp
    961a:	85 c0                	test   %eax,%eax
    961c:	74 07                	je     9625 <lodepng_pixel_overflow+0xd5>
    961e:	b8 01 00 00 00       	mov    $0x1,%eax
    9623:	eb 41                	jmp    9666 <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    9625:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9628:	8d 55 ec             	lea    -0x14(%ebp),%edx
    962b:	52                   	push   %edx
    962c:	6a 05                	push   $0x5
    962e:	50                   	push   %eax
    962f:	e8 34 a3 ff ff       	call   3968 <lodepng_addofl>
    9634:	83 c4 0c             	add    $0xc,%esp
    9637:	85 c0                	test   %eax,%eax
    9639:	74 07                	je     9642 <lodepng_pixel_overflow+0xf2>
    963b:	b8 01 00 00 00       	mov    $0x1,%eax
    9640:	eb 24                	jmp    9666 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    9642:	8b 55 0c             	mov    0xc(%ebp),%edx
    9645:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9648:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    964b:	51                   	push   %ecx
    964c:	52                   	push   %edx
    964d:	50                   	push   %eax
    964e:	e8 35 a3 ff ff       	call   3988 <lodepng_mulofl>
    9653:	83 c4 0c             	add    $0xc,%esp
    9656:	85 c0                	test   %eax,%eax
    9658:	74 07                	je     9661 <lodepng_pixel_overflow+0x111>
    965a:	b8 01 00 00 00       	mov    $0x1,%eax
    965f:	eb 05                	jmp    9666 <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    9661:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9666:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9669:	c9                   	leave  
    966a:	c3                   	ret    

0000966b <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    966b:	55                   	push   %ebp
    966c:	89 e5                	mov    %esp,%ebp
    966e:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    9671:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9678:	eb 15                	jmp    968f <LodePNGUnknownChunks_init+0x24>
    967a:	8b 45 08             	mov    0x8(%ebp),%eax
    967d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9680:	83 c2 30             	add    $0x30,%edx
    9683:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    968a:	00 
    968b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    968f:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9693:	75 e5                	jne    967a <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    9695:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    969c:	eb 15                	jmp    96b3 <LodePNGUnknownChunks_init+0x48>
    969e:	8b 45 08             	mov    0x8(%ebp),%eax
    96a1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    96a4:	83 c2 34             	add    $0x34,%edx
    96a7:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    96ae:	00 
    96af:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    96b3:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    96b7:	75 e5                	jne    969e <LodePNGUnknownChunks_init+0x33>
}
    96b9:	90                   	nop
    96ba:	c9                   	leave  
    96bb:	c3                   	ret    

000096bc <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    96bc:	55                   	push   %ebp
    96bd:	89 e5                	mov    %esp,%ebp
    96bf:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    96c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    96c9:	eb 1d                	jmp    96e8 <LodePNGUnknownChunks_cleanup+0x2c>
    96cb:	8b 45 08             	mov    0x8(%ebp),%eax
    96ce:	8b 55 f4             	mov    -0xc(%ebp),%edx
    96d1:	83 c2 30             	add    $0x30,%edx
    96d4:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    96d8:	83 ec 0c             	sub    $0xc,%esp
    96db:	50                   	push   %eax
    96dc:	e8 e4 a1 ff ff       	call   38c5 <lodepng_free>
    96e1:	83 c4 10             	add    $0x10,%esp
    96e4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    96e8:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    96ec:	75 dd                	jne    96cb <LodePNGUnknownChunks_cleanup+0xf>
}
    96ee:	90                   	nop
    96ef:	c9                   	leave  
    96f0:	c3                   	ret    

000096f1 <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    96f1:	55                   	push   %ebp
    96f2:	89 e5                	mov    %esp,%ebp
    96f4:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    96f7:	83 ec 0c             	sub    $0xc,%esp
    96fa:	ff 75 08             	pushl  0x8(%ebp)
    96fd:	e8 ba ff ff ff       	call   96bc <LodePNGUnknownChunks_cleanup>
    9702:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    9705:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    970c:	e9 b7 00 00 00       	jmp    97c8 <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    9711:	8b 45 0c             	mov    0xc(%ebp),%eax
    9714:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9717:	83 c2 34             	add    $0x34,%edx
    971a:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    971e:	8b 45 08             	mov    0x8(%ebp),%eax
    9721:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9724:	83 c1 34             	add    $0x34,%ecx
    9727:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    972b:	8b 45 0c             	mov    0xc(%ebp),%eax
    972e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9731:	83 c2 34             	add    $0x34,%edx
    9734:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9738:	83 ec 0c             	sub    $0xc,%esp
    973b:	50                   	push   %eax
    973c:	e8 63 a1 ff ff       	call   38a4 <lodepng_malloc>
    9741:	83 c4 10             	add    $0x10,%esp
    9744:	89 c1                	mov    %eax,%ecx
    9746:	8b 45 08             	mov    0x8(%ebp),%eax
    9749:	8b 55 f4             	mov    -0xc(%ebp),%edx
    974c:	83 c2 30             	add    $0x30,%edx
    974f:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    9753:	8b 45 08             	mov    0x8(%ebp),%eax
    9756:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9759:	83 c2 30             	add    $0x30,%edx
    975c:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    9760:	85 c0                	test   %eax,%eax
    9762:	75 18                	jne    977c <LodePNGUnknownChunks_copy+0x8b>
    9764:	8b 45 08             	mov    0x8(%ebp),%eax
    9767:	8b 55 f4             	mov    -0xc(%ebp),%edx
    976a:	83 c2 34             	add    $0x34,%edx
    976d:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9771:	85 c0                	test   %eax,%eax
    9773:	74 07                	je     977c <LodePNGUnknownChunks_copy+0x8b>
    9775:	b8 53 00 00 00       	mov    $0x53,%eax
    977a:	eb 5b                	jmp    97d7 <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    977c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    9783:	eb 2d                	jmp    97b2 <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    9785:	8b 45 08             	mov    0x8(%ebp),%eax
    9788:	8b 55 f4             	mov    -0xc(%ebp),%edx
    978b:	83 c2 30             	add    $0x30,%edx
    978e:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    9792:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9795:	01 c2                	add    %eax,%edx
    9797:	8b 45 0c             	mov    0xc(%ebp),%eax
    979a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    979d:	83 c1 30             	add    $0x30,%ecx
    97a0:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    97a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    97a7:	01 c8                	add    %ecx,%eax
    97a9:	0f b6 00             	movzbl (%eax),%eax
    97ac:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    97ae:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    97b2:	8b 45 0c             	mov    0xc(%ebp),%eax
    97b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    97b8:	83 c2 34             	add    $0x34,%edx
    97bb:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    97bf:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    97c2:	7f c1                	jg     9785 <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    97c4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    97c8:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    97cc:	0f 85 3f ff ff ff    	jne    9711 <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    97d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    97d7:	c9                   	leave  
    97d8:	c3                   	ret    

000097d9 <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    97d9:	55                   	push   %ebp
    97da:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    97dc:	8b 45 08             	mov    0x8(%ebp),%eax
    97df:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    97e6:	8b 45 08             	mov    0x8(%ebp),%eax
    97e9:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    97f0:	8b 45 08             	mov    0x8(%ebp),%eax
    97f3:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    97fa:	90                   	nop
    97fb:	5d                   	pop    %ebp
    97fc:	c3                   	ret    

000097fd <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    97fd:	55                   	push   %ebp
    97fe:	89 e5                	mov    %esp,%ebp
    9800:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9803:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    980a:	eb 38                	jmp    9844 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    980c:	8b 45 08             	mov    0x8(%ebp),%eax
    980f:	8b 40 40             	mov    0x40(%eax),%eax
    9812:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9815:	c1 e2 02             	shl    $0x2,%edx
    9818:	01 d0                	add    %edx,%eax
    981a:	83 ec 0c             	sub    $0xc,%esp
    981d:	50                   	push   %eax
    981e:	e8 75 a3 ff ff       	call   3b98 <string_cleanup>
    9823:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    9826:	8b 45 08             	mov    0x8(%ebp),%eax
    9829:	8b 40 44             	mov    0x44(%eax),%eax
    982c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    982f:	c1 e2 02             	shl    $0x2,%edx
    9832:	01 d0                	add    %edx,%eax
    9834:	83 ec 0c             	sub    $0xc,%esp
    9837:	50                   	push   %eax
    9838:	e8 5b a3 ff ff       	call   3b98 <string_cleanup>
    983d:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9840:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9844:	8b 45 08             	mov    0x8(%ebp),%eax
    9847:	8b 40 3c             	mov    0x3c(%eax),%eax
    984a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    984d:	75 bd                	jne    980c <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    984f:	8b 45 08             	mov    0x8(%ebp),%eax
    9852:	8b 40 40             	mov    0x40(%eax),%eax
    9855:	83 ec 0c             	sub    $0xc,%esp
    9858:	50                   	push   %eax
    9859:	e8 67 a0 ff ff       	call   38c5 <lodepng_free>
    985e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    9861:	8b 45 08             	mov    0x8(%ebp),%eax
    9864:	8b 40 44             	mov    0x44(%eax),%eax
    9867:	83 ec 0c             	sub    $0xc,%esp
    986a:	50                   	push   %eax
    986b:	e8 55 a0 ff ff       	call   38c5 <lodepng_free>
    9870:	83 c4 10             	add    $0x10,%esp
}
    9873:	90                   	nop
    9874:	c9                   	leave  
    9875:	c3                   	ret    

00009876 <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9876:	55                   	push   %ebp
    9877:	89 e5                	mov    %esp,%ebp
    9879:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    987c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    9883:	8b 45 08             	mov    0x8(%ebp),%eax
    9886:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    988d:	8b 45 08             	mov    0x8(%ebp),%eax
    9890:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    9897:	8b 45 08             	mov    0x8(%ebp),%eax
    989a:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    98a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    98a8:	eb 42                	jmp    98ec <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    98aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    98ad:	8b 40 44             	mov    0x44(%eax),%eax
    98b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    98b3:	c1 e2 02             	shl    $0x2,%edx
    98b6:	01 d0                	add    %edx,%eax
    98b8:	8b 10                	mov    (%eax),%edx
    98ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    98bd:	8b 40 40             	mov    0x40(%eax),%eax
    98c0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    98c3:	c1 e1 02             	shl    $0x2,%ecx
    98c6:	01 c8                	add    %ecx,%eax
    98c8:	8b 00                	mov    (%eax),%eax
    98ca:	83 ec 04             	sub    $0x4,%esp
    98cd:	52                   	push   %edx
    98ce:	50                   	push   %eax
    98cf:	ff 75 08             	pushl  0x8(%ebp)
    98d2:	e8 4d 01 00 00       	call   9a24 <lodepng_add_text>
    98d7:	83 c4 10             	add    $0x10,%esp
    98da:	89 45 f0             	mov    %eax,-0x10(%ebp)
    98dd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    98e1:	74 05                	je     98e8 <LodePNGText_copy+0x72>
    98e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    98e6:	eb 14                	jmp    98fc <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    98e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    98ec:	8b 45 0c             	mov    0xc(%ebp),%eax
    98ef:	8b 40 3c             	mov    0x3c(%eax),%eax
    98f2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    98f5:	75 b3                	jne    98aa <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    98f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    98fc:	c9                   	leave  
    98fd:	c3                   	ret    

000098fe <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    98fe:	55                   	push   %ebp
    98ff:	89 e5                	mov    %esp,%ebp
    9901:	53                   	push   %ebx
    9902:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    9905:	8b 45 08             	mov    0x8(%ebp),%eax
    9908:	8b 40 3c             	mov    0x3c(%eax),%eax
    990b:	83 c0 01             	add    $0x1,%eax
    990e:	c1 e0 02             	shl    $0x2,%eax
    9911:	89 c2                	mov    %eax,%edx
    9913:	8b 45 08             	mov    0x8(%ebp),%eax
    9916:	8b 40 40             	mov    0x40(%eax),%eax
    9919:	52                   	push   %edx
    991a:	50                   	push   %eax
    991b:	e8 9b 9f ff ff       	call   38bb <lodepng_realloc>
    9920:	83 c4 08             	add    $0x8,%esp
    9923:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    9926:	8b 45 08             	mov    0x8(%ebp),%eax
    9929:	8b 40 3c             	mov    0x3c(%eax),%eax
    992c:	83 c0 01             	add    $0x1,%eax
    992f:	c1 e0 02             	shl    $0x2,%eax
    9932:	89 c2                	mov    %eax,%edx
    9934:	8b 45 08             	mov    0x8(%ebp),%eax
    9937:	8b 40 44             	mov    0x44(%eax),%eax
    993a:	52                   	push   %edx
    993b:	50                   	push   %eax
    993c:	e8 7a 9f ff ff       	call   38bb <lodepng_realloc>
    9941:	83 c4 08             	add    $0x8,%esp
    9944:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    9947:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    994b:	74 09                	je     9956 <lodepng_add_text_sized+0x58>
    994d:	8b 45 08             	mov    0x8(%ebp),%eax
    9950:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9953:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    9956:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    995a:	74 09                	je     9965 <lodepng_add_text_sized+0x67>
    995c:	8b 45 08             	mov    0x8(%ebp),%eax
    995f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9962:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    9965:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9969:	74 06                	je     9971 <lodepng_add_text_sized+0x73>
    996b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    996f:	75 0a                	jne    997b <lodepng_add_text_sized+0x7d>
    9971:	b8 53 00 00 00       	mov    $0x53,%eax
    9976:	e9 a4 00 00 00       	jmp    9a1f <lodepng_add_text_sized+0x121>

  ++info->text_num;
    997b:	8b 45 08             	mov    0x8(%ebp),%eax
    997e:	8b 40 3c             	mov    0x3c(%eax),%eax
    9981:	8d 50 01             	lea    0x1(%eax),%edx
    9984:	8b 45 08             	mov    0x8(%ebp),%eax
    9987:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    998a:	8b 45 08             	mov    0x8(%ebp),%eax
    998d:	8b 50 40             	mov    0x40(%eax),%edx
    9990:	8b 45 08             	mov    0x8(%ebp),%eax
    9993:	8b 40 3c             	mov    0x3c(%eax),%eax
    9996:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    999b:	c1 e0 02             	shl    $0x2,%eax
    999e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    99a1:	83 ec 0c             	sub    $0xc,%esp
    99a4:	ff 75 0c             	pushl  0xc(%ebp)
    99a7:	e8 54 a2 ff ff       	call   3c00 <alloc_string>
    99ac:	83 c4 10             	add    $0x10,%esp
    99af:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    99b1:	8b 45 08             	mov    0x8(%ebp),%eax
    99b4:	8b 50 44             	mov    0x44(%eax),%edx
    99b7:	8b 45 08             	mov    0x8(%ebp),%eax
    99ba:	8b 40 3c             	mov    0x3c(%eax),%eax
    99bd:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    99c2:	c1 e0 02             	shl    $0x2,%eax
    99c5:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    99c8:	83 ec 08             	sub    $0x8,%esp
    99cb:	ff 75 14             	pushl  0x14(%ebp)
    99ce:	ff 75 10             	pushl  0x10(%ebp)
    99d1:	e8 e5 a1 ff ff       	call   3bbb <alloc_string_sized>
    99d6:	83 c4 10             	add    $0x10,%esp
    99d9:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    99db:	8b 45 08             	mov    0x8(%ebp),%eax
    99de:	8b 50 40             	mov    0x40(%eax),%edx
    99e1:	8b 45 08             	mov    0x8(%ebp),%eax
    99e4:	8b 40 3c             	mov    0x3c(%eax),%eax
    99e7:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    99ec:	c1 e0 02             	shl    $0x2,%eax
    99ef:	01 d0                	add    %edx,%eax
    99f1:	8b 00                	mov    (%eax),%eax
    99f3:	85 c0                	test   %eax,%eax
    99f5:	74 1c                	je     9a13 <lodepng_add_text_sized+0x115>
    99f7:	8b 45 08             	mov    0x8(%ebp),%eax
    99fa:	8b 50 44             	mov    0x44(%eax),%edx
    99fd:	8b 45 08             	mov    0x8(%ebp),%eax
    9a00:	8b 40 3c             	mov    0x3c(%eax),%eax
    9a03:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9a08:	c1 e0 02             	shl    $0x2,%eax
    9a0b:	01 d0                	add    %edx,%eax
    9a0d:	8b 00                	mov    (%eax),%eax
    9a0f:	85 c0                	test   %eax,%eax
    9a11:	75 07                	jne    9a1a <lodepng_add_text_sized+0x11c>
    9a13:	b8 53 00 00 00       	mov    $0x53,%eax
    9a18:	eb 05                	jmp    9a1f <lodepng_add_text_sized+0x121>

  return 0;
    9a1a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9a1f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9a22:	c9                   	leave  
    9a23:	c3                   	ret    

00009a24 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    9a24:	55                   	push   %ebp
    9a25:	89 e5                	mov    %esp,%ebp
    9a27:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    9a2a:	ff 75 10             	pushl  0x10(%ebp)
    9a2d:	e8 0e 9f ff ff       	call   3940 <lodepng_strlen>
    9a32:	83 c4 04             	add    $0x4,%esp
    9a35:	50                   	push   %eax
    9a36:	ff 75 10             	pushl  0x10(%ebp)
    9a39:	ff 75 0c             	pushl  0xc(%ebp)
    9a3c:	ff 75 08             	pushl  0x8(%ebp)
    9a3f:	e8 ba fe ff ff       	call   98fe <lodepng_add_text_sized>
    9a44:	83 c4 10             	add    $0x10,%esp
}
    9a47:	c9                   	leave  
    9a48:	c3                   	ret    

00009a49 <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    9a49:	55                   	push   %ebp
    9a4a:	89 e5                	mov    %esp,%ebp
    9a4c:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    9a4f:	83 ec 0c             	sub    $0xc,%esp
    9a52:	ff 75 08             	pushl  0x8(%ebp)
    9a55:	e8 a3 fd ff ff       	call   97fd <LodePNGText_cleanup>
    9a5a:	83 c4 10             	add    $0x10,%esp
}
    9a5d:	90                   	nop
    9a5e:	c9                   	leave  
    9a5f:	c3                   	ret    

00009a60 <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    9a60:	55                   	push   %ebp
    9a61:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    9a63:	8b 45 08             	mov    0x8(%ebp),%eax
    9a66:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    9a6d:	8b 45 08             	mov    0x8(%ebp),%eax
    9a70:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    9a77:	8b 45 08             	mov    0x8(%ebp),%eax
    9a7a:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    9a81:	8b 45 08             	mov    0x8(%ebp),%eax
    9a84:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    9a8b:	8b 45 08             	mov    0x8(%ebp),%eax
    9a8e:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    9a95:	90                   	nop
    9a96:	5d                   	pop    %ebp
    9a97:	c3                   	ret    

00009a98 <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    9a98:	55                   	push   %ebp
    9a99:	89 e5                	mov    %esp,%ebp
    9a9b:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    9a9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9aa5:	eb 6c                	jmp    9b13 <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    9aa7:	8b 45 08             	mov    0x8(%ebp),%eax
    9aaa:	8b 40 4c             	mov    0x4c(%eax),%eax
    9aad:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9ab0:	c1 e2 02             	shl    $0x2,%edx
    9ab3:	01 d0                	add    %edx,%eax
    9ab5:	83 ec 0c             	sub    $0xc,%esp
    9ab8:	50                   	push   %eax
    9ab9:	e8 da a0 ff ff       	call   3b98 <string_cleanup>
    9abe:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    9ac1:	8b 45 08             	mov    0x8(%ebp),%eax
    9ac4:	8b 40 50             	mov    0x50(%eax),%eax
    9ac7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9aca:	c1 e2 02             	shl    $0x2,%edx
    9acd:	01 d0                	add    %edx,%eax
    9acf:	83 ec 0c             	sub    $0xc,%esp
    9ad2:	50                   	push   %eax
    9ad3:	e8 c0 a0 ff ff       	call   3b98 <string_cleanup>
    9ad8:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    9adb:	8b 45 08             	mov    0x8(%ebp),%eax
    9ade:	8b 40 54             	mov    0x54(%eax),%eax
    9ae1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9ae4:	c1 e2 02             	shl    $0x2,%edx
    9ae7:	01 d0                	add    %edx,%eax
    9ae9:	83 ec 0c             	sub    $0xc,%esp
    9aec:	50                   	push   %eax
    9aed:	e8 a6 a0 ff ff       	call   3b98 <string_cleanup>
    9af2:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    9af5:	8b 45 08             	mov    0x8(%ebp),%eax
    9af8:	8b 40 58             	mov    0x58(%eax),%eax
    9afb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9afe:	c1 e2 02             	shl    $0x2,%edx
    9b01:	01 d0                	add    %edx,%eax
    9b03:	83 ec 0c             	sub    $0xc,%esp
    9b06:	50                   	push   %eax
    9b07:	e8 8c a0 ff ff       	call   3b98 <string_cleanup>
    9b0c:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    9b0f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9b13:	8b 45 08             	mov    0x8(%ebp),%eax
    9b16:	8b 40 48             	mov    0x48(%eax),%eax
    9b19:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9b1c:	75 89                	jne    9aa7 <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    9b1e:	8b 45 08             	mov    0x8(%ebp),%eax
    9b21:	8b 40 4c             	mov    0x4c(%eax),%eax
    9b24:	83 ec 0c             	sub    $0xc,%esp
    9b27:	50                   	push   %eax
    9b28:	e8 98 9d ff ff       	call   38c5 <lodepng_free>
    9b2d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    9b30:	8b 45 08             	mov    0x8(%ebp),%eax
    9b33:	8b 40 50             	mov    0x50(%eax),%eax
    9b36:	83 ec 0c             	sub    $0xc,%esp
    9b39:	50                   	push   %eax
    9b3a:	e8 86 9d ff ff       	call   38c5 <lodepng_free>
    9b3f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    9b42:	8b 45 08             	mov    0x8(%ebp),%eax
    9b45:	8b 40 54             	mov    0x54(%eax),%eax
    9b48:	83 ec 0c             	sub    $0xc,%esp
    9b4b:	50                   	push   %eax
    9b4c:	e8 74 9d ff ff       	call   38c5 <lodepng_free>
    9b51:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    9b54:	8b 45 08             	mov    0x8(%ebp),%eax
    9b57:	8b 40 58             	mov    0x58(%eax),%eax
    9b5a:	83 ec 0c             	sub    $0xc,%esp
    9b5d:	50                   	push   %eax
    9b5e:	e8 62 9d ff ff       	call   38c5 <lodepng_free>
    9b63:	83 c4 10             	add    $0x10,%esp
}
    9b66:	90                   	nop
    9b67:	c9                   	leave  
    9b68:	c3                   	ret    

00009b69 <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9b69:	55                   	push   %ebp
    9b6a:	89 e5                	mov    %esp,%ebp
    9b6c:	56                   	push   %esi
    9b6d:	53                   	push   %ebx
    9b6e:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    9b71:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    9b78:	8b 45 08             	mov    0x8(%ebp),%eax
    9b7b:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    9b82:	8b 45 08             	mov    0x8(%ebp),%eax
    9b85:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    9b8c:	8b 45 08             	mov    0x8(%ebp),%eax
    9b8f:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    9b96:	8b 45 08             	mov    0x8(%ebp),%eax
    9b99:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    9ba0:	8b 45 08             	mov    0x8(%ebp),%eax
    9ba3:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    9baa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9bb1:	eb 64                	jmp    9c17 <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    9bb3:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bb6:	8b 40 58             	mov    0x58(%eax),%eax
    9bb9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9bbc:	c1 e2 02             	shl    $0x2,%edx
    9bbf:	01 d0                	add    %edx,%eax
    9bc1:	8b 18                	mov    (%eax),%ebx
    9bc3:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bc6:	8b 40 54             	mov    0x54(%eax),%eax
    9bc9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9bcc:	c1 e2 02             	shl    $0x2,%edx
    9bcf:	01 d0                	add    %edx,%eax
    9bd1:	8b 08                	mov    (%eax),%ecx
    9bd3:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bd6:	8b 40 50             	mov    0x50(%eax),%eax
    9bd9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9bdc:	c1 e2 02             	shl    $0x2,%edx
    9bdf:	01 d0                	add    %edx,%eax
    9be1:	8b 10                	mov    (%eax),%edx
    9be3:	8b 45 0c             	mov    0xc(%ebp),%eax
    9be6:	8b 40 4c             	mov    0x4c(%eax),%eax
    9be9:	8b 75 f4             	mov    -0xc(%ebp),%esi
    9bec:	c1 e6 02             	shl    $0x2,%esi
    9bef:	01 f0                	add    %esi,%eax
    9bf1:	8b 00                	mov    (%eax),%eax
    9bf3:	83 ec 0c             	sub    $0xc,%esp
    9bf6:	53                   	push   %ebx
    9bf7:	51                   	push   %ecx
    9bf8:	52                   	push   %edx
    9bf9:	50                   	push   %eax
    9bfa:	ff 75 08             	pushl  0x8(%ebp)
    9bfd:	e8 e4 01 00 00       	call   9de6 <lodepng_add_itext>
    9c02:	83 c4 20             	add    $0x20,%esp
    9c05:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9c08:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9c0c:	74 05                	je     9c13 <LodePNGIText_copy+0xaa>
    9c0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9c11:	eb 14                	jmp    9c27 <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    9c13:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9c17:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c1a:	8b 40 48             	mov    0x48(%eax),%eax
    9c1d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9c20:	75 91                	jne    9bb3 <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    9c22:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9c27:	8d 65 f8             	lea    -0x8(%ebp),%esp
    9c2a:	5b                   	pop    %ebx
    9c2b:	5e                   	pop    %esi
    9c2c:	5d                   	pop    %ebp
    9c2d:	c3                   	ret    

00009c2e <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    9c2e:	55                   	push   %ebp
    9c2f:	89 e5                	mov    %esp,%ebp
    9c31:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    9c34:	83 ec 0c             	sub    $0xc,%esp
    9c37:	ff 75 08             	pushl  0x8(%ebp)
    9c3a:	e8 59 fe ff ff       	call   9a98 <LodePNGIText_cleanup>
    9c3f:	83 c4 10             	add    $0x10,%esp
}
    9c42:	90                   	nop
    9c43:	c9                   	leave  
    9c44:	c3                   	ret    

00009c45 <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    9c45:	55                   	push   %ebp
    9c46:	89 e5                	mov    %esp,%ebp
    9c48:	53                   	push   %ebx
    9c49:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    9c4c:	8b 45 08             	mov    0x8(%ebp),%eax
    9c4f:	8b 40 48             	mov    0x48(%eax),%eax
    9c52:	83 c0 01             	add    $0x1,%eax
    9c55:	c1 e0 02             	shl    $0x2,%eax
    9c58:	89 c2                	mov    %eax,%edx
    9c5a:	8b 45 08             	mov    0x8(%ebp),%eax
    9c5d:	8b 40 4c             	mov    0x4c(%eax),%eax
    9c60:	52                   	push   %edx
    9c61:	50                   	push   %eax
    9c62:	e8 54 9c ff ff       	call   38bb <lodepng_realloc>
    9c67:	83 c4 08             	add    $0x8,%esp
    9c6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    9c6d:	8b 45 08             	mov    0x8(%ebp),%eax
    9c70:	8b 40 48             	mov    0x48(%eax),%eax
    9c73:	83 c0 01             	add    $0x1,%eax
    9c76:	c1 e0 02             	shl    $0x2,%eax
    9c79:	89 c2                	mov    %eax,%edx
    9c7b:	8b 45 08             	mov    0x8(%ebp),%eax
    9c7e:	8b 40 50             	mov    0x50(%eax),%eax
    9c81:	52                   	push   %edx
    9c82:	50                   	push   %eax
    9c83:	e8 33 9c ff ff       	call   38bb <lodepng_realloc>
    9c88:	83 c4 08             	add    $0x8,%esp
    9c8b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    9c8e:	8b 45 08             	mov    0x8(%ebp),%eax
    9c91:	8b 40 48             	mov    0x48(%eax),%eax
    9c94:	83 c0 01             	add    $0x1,%eax
    9c97:	c1 e0 02             	shl    $0x2,%eax
    9c9a:	89 c2                	mov    %eax,%edx
    9c9c:	8b 45 08             	mov    0x8(%ebp),%eax
    9c9f:	8b 40 54             	mov    0x54(%eax),%eax
    9ca2:	52                   	push   %edx
    9ca3:	50                   	push   %eax
    9ca4:	e8 12 9c ff ff       	call   38bb <lodepng_realloc>
    9ca9:	83 c4 08             	add    $0x8,%esp
    9cac:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    9caf:	8b 45 08             	mov    0x8(%ebp),%eax
    9cb2:	8b 40 48             	mov    0x48(%eax),%eax
    9cb5:	83 c0 01             	add    $0x1,%eax
    9cb8:	c1 e0 02             	shl    $0x2,%eax
    9cbb:	89 c2                	mov    %eax,%edx
    9cbd:	8b 45 08             	mov    0x8(%ebp),%eax
    9cc0:	8b 40 58             	mov    0x58(%eax),%eax
    9cc3:	52                   	push   %edx
    9cc4:	50                   	push   %eax
    9cc5:	e8 f1 9b ff ff       	call   38bb <lodepng_realloc>
    9cca:	83 c4 08             	add    $0x8,%esp
    9ccd:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    9cd0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9cd4:	74 09                	je     9cdf <lodepng_add_itext_sized+0x9a>
    9cd6:	8b 45 08             	mov    0x8(%ebp),%eax
    9cd9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9cdc:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    9cdf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9ce3:	74 09                	je     9cee <lodepng_add_itext_sized+0xa9>
    9ce5:	8b 45 08             	mov    0x8(%ebp),%eax
    9ce8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ceb:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    9cee:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9cf2:	74 09                	je     9cfd <lodepng_add_itext_sized+0xb8>
    9cf4:	8b 45 08             	mov    0x8(%ebp),%eax
    9cf7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9cfa:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    9cfd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9d01:	74 09                	je     9d0c <lodepng_add_itext_sized+0xc7>
    9d03:	8b 45 08             	mov    0x8(%ebp),%eax
    9d06:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9d09:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    9d0c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9d10:	74 12                	je     9d24 <lodepng_add_itext_sized+0xdf>
    9d12:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9d16:	74 0c                	je     9d24 <lodepng_add_itext_sized+0xdf>
    9d18:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9d1c:	74 06                	je     9d24 <lodepng_add_itext_sized+0xdf>
    9d1e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9d22:	75 0a                	jne    9d2e <lodepng_add_itext_sized+0xe9>
    9d24:	b8 53 00 00 00       	mov    $0x53,%eax
    9d29:	e9 b3 00 00 00       	jmp    9de1 <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    9d2e:	8b 45 08             	mov    0x8(%ebp),%eax
    9d31:	8b 40 48             	mov    0x48(%eax),%eax
    9d34:	8d 50 01             	lea    0x1(%eax),%edx
    9d37:	8b 45 08             	mov    0x8(%ebp),%eax
    9d3a:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    9d3d:	8b 45 08             	mov    0x8(%ebp),%eax
    9d40:	8b 50 4c             	mov    0x4c(%eax),%edx
    9d43:	8b 45 08             	mov    0x8(%ebp),%eax
    9d46:	8b 40 48             	mov    0x48(%eax),%eax
    9d49:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9d4e:	c1 e0 02             	shl    $0x2,%eax
    9d51:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9d54:	83 ec 0c             	sub    $0xc,%esp
    9d57:	ff 75 0c             	pushl  0xc(%ebp)
    9d5a:	e8 a1 9e ff ff       	call   3c00 <alloc_string>
    9d5f:	83 c4 10             	add    $0x10,%esp
    9d62:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    9d64:	8b 45 08             	mov    0x8(%ebp),%eax
    9d67:	8b 50 50             	mov    0x50(%eax),%edx
    9d6a:	8b 45 08             	mov    0x8(%ebp),%eax
    9d6d:	8b 40 48             	mov    0x48(%eax),%eax
    9d70:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9d75:	c1 e0 02             	shl    $0x2,%eax
    9d78:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9d7b:	83 ec 0c             	sub    $0xc,%esp
    9d7e:	ff 75 10             	pushl  0x10(%ebp)
    9d81:	e8 7a 9e ff ff       	call   3c00 <alloc_string>
    9d86:	83 c4 10             	add    $0x10,%esp
    9d89:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    9d8b:	8b 45 08             	mov    0x8(%ebp),%eax
    9d8e:	8b 50 54             	mov    0x54(%eax),%edx
    9d91:	8b 45 08             	mov    0x8(%ebp),%eax
    9d94:	8b 40 48             	mov    0x48(%eax),%eax
    9d97:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9d9c:	c1 e0 02             	shl    $0x2,%eax
    9d9f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9da2:	83 ec 0c             	sub    $0xc,%esp
    9da5:	ff 75 14             	pushl  0x14(%ebp)
    9da8:	e8 53 9e ff ff       	call   3c00 <alloc_string>
    9dad:	83 c4 10             	add    $0x10,%esp
    9db0:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    9db2:	8b 45 08             	mov    0x8(%ebp),%eax
    9db5:	8b 50 58             	mov    0x58(%eax),%edx
    9db8:	8b 45 08             	mov    0x8(%ebp),%eax
    9dbb:	8b 40 48             	mov    0x48(%eax),%eax
    9dbe:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9dc3:	c1 e0 02             	shl    $0x2,%eax
    9dc6:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9dc9:	83 ec 08             	sub    $0x8,%esp
    9dcc:	ff 75 1c             	pushl  0x1c(%ebp)
    9dcf:	ff 75 18             	pushl  0x18(%ebp)
    9dd2:	e8 e4 9d ff ff       	call   3bbb <alloc_string_sized>
    9dd7:	83 c4 10             	add    $0x10,%esp
    9dda:	89 03                	mov    %eax,(%ebx)

  return 0;
    9ddc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9de1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9de4:	c9                   	leave  
    9de5:	c3                   	ret    

00009de6 <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    9de6:	55                   	push   %ebp
    9de7:	89 e5                	mov    %esp,%ebp
    9de9:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    9dec:	ff 75 18             	pushl  0x18(%ebp)
    9def:	e8 4c 9b ff ff       	call   3940 <lodepng_strlen>
    9df4:	83 c4 04             	add    $0x4,%esp
    9df7:	83 ec 08             	sub    $0x8,%esp
    9dfa:	50                   	push   %eax
    9dfb:	ff 75 18             	pushl  0x18(%ebp)
    9dfe:	ff 75 14             	pushl  0x14(%ebp)
    9e01:	ff 75 10             	pushl  0x10(%ebp)
    9e04:	ff 75 0c             	pushl  0xc(%ebp)
    9e07:	ff 75 08             	pushl  0x8(%ebp)
    9e0a:	e8 36 fe ff ff       	call   9c45 <lodepng_add_itext_sized>
    9e0f:	83 c4 20             	add    $0x20,%esp
}
    9e12:	c9                   	leave  
    9e13:	c3                   	ret    

00009e14 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9e14:	55                   	push   %ebp
    9e15:	89 e5                	mov    %esp,%ebp
    9e17:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    9e1a:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    9e1e:	75 0a                	jne    9e2a <lodepng_assign_icc+0x16>
    9e20:	b8 64 00 00 00       	mov    $0x64,%eax
    9e25:	e9 81 00 00 00       	jmp    9eab <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    9e2a:	83 ec 0c             	sub    $0xc,%esp
    9e2d:	ff 75 0c             	pushl  0xc(%ebp)
    9e30:	e8 cb 9d ff ff       	call   3c00 <alloc_string>
    9e35:	83 c4 10             	add    $0x10,%esp
    9e38:	89 c2                	mov    %eax,%edx
    9e3a:	8b 45 08             	mov    0x8(%ebp),%eax
    9e3d:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    9e43:	8b 45 14             	mov    0x14(%ebp),%eax
    9e46:	83 ec 0c             	sub    $0xc,%esp
    9e49:	50                   	push   %eax
    9e4a:	e8 55 9a ff ff       	call   38a4 <lodepng_malloc>
    9e4f:	83 c4 10             	add    $0x10,%esp
    9e52:	89 c2                	mov    %eax,%edx
    9e54:	8b 45 08             	mov    0x8(%ebp),%eax
    9e57:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    9e5d:	8b 45 08             	mov    0x8(%ebp),%eax
    9e60:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9e66:	85 c0                	test   %eax,%eax
    9e68:	74 0d                	je     9e77 <lodepng_assign_icc+0x63>
    9e6a:	8b 45 08             	mov    0x8(%ebp),%eax
    9e6d:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9e73:	85 c0                	test   %eax,%eax
    9e75:	75 07                	jne    9e7e <lodepng_assign_icc+0x6a>
    9e77:	b8 53 00 00 00       	mov    $0x53,%eax
    9e7c:	eb 2d                	jmp    9eab <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    9e7e:	8b 55 14             	mov    0x14(%ebp),%edx
    9e81:	8b 45 08             	mov    0x8(%ebp),%eax
    9e84:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9e8a:	83 ec 04             	sub    $0x4,%esp
    9e8d:	52                   	push   %edx
    9e8e:	ff 75 10             	pushl  0x10(%ebp)
    9e91:	50                   	push   %eax
    9e92:	e8 4b 9a ff ff       	call   38e2 <lodepng_memcpy>
    9e97:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    9e9a:	8b 45 08             	mov    0x8(%ebp),%eax
    9e9d:	8b 55 14             	mov    0x14(%ebp),%edx
    9ea0:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    9ea6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9eab:	c9                   	leave  
    9eac:	c3                   	ret    

00009ead <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9ead:	55                   	push   %ebp
    9eae:	89 e5                	mov    %esp,%ebp
    9eb0:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    9eb3:	8b 45 08             	mov    0x8(%ebp),%eax
    9eb6:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9ebc:	85 c0                	test   %eax,%eax
    9ebe:	74 0e                	je     9ece <lodepng_set_icc+0x21>
    9ec0:	83 ec 0c             	sub    $0xc,%esp
    9ec3:	ff 75 08             	pushl  0x8(%ebp)
    9ec6:	e8 26 00 00 00       	call   9ef1 <lodepng_clear_icc>
    9ecb:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    9ece:	8b 45 08             	mov    0x8(%ebp),%eax
    9ed1:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    9ed8:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    9edb:	ff 75 14             	pushl  0x14(%ebp)
    9ede:	ff 75 10             	pushl  0x10(%ebp)
    9ee1:	ff 75 0c             	pushl  0xc(%ebp)
    9ee4:	ff 75 08             	pushl  0x8(%ebp)
    9ee7:	e8 28 ff ff ff       	call   9e14 <lodepng_assign_icc>
    9eec:	83 c4 10             	add    $0x10,%esp
}
    9eef:	c9                   	leave  
    9ef0:	c3                   	ret    

00009ef1 <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    9ef1:	55                   	push   %ebp
    9ef2:	89 e5                	mov    %esp,%ebp
    9ef4:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    9ef7:	8b 45 08             	mov    0x8(%ebp),%eax
    9efa:	05 c0 00 00 00       	add    $0xc0,%eax
    9eff:	83 ec 0c             	sub    $0xc,%esp
    9f02:	50                   	push   %eax
    9f03:	e8 90 9c ff ff       	call   3b98 <string_cleanup>
    9f08:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    9f0b:	8b 45 08             	mov    0x8(%ebp),%eax
    9f0e:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9f14:	83 ec 0c             	sub    $0xc,%esp
    9f17:	50                   	push   %eax
    9f18:	e8 a8 99 ff ff       	call   38c5 <lodepng_free>
    9f1d:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    9f20:	8b 45 08             	mov    0x8(%ebp),%eax
    9f23:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9f2a:	00 00 00 
  info->iccp_profile_size = 0;
    9f2d:	8b 45 08             	mov    0x8(%ebp),%eax
    9f30:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    9f37:	00 00 00 
  info->iccp_defined = 0;
    9f3a:	8b 45 08             	mov    0x8(%ebp),%eax
    9f3d:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9f44:	00 00 00 
}
    9f47:	90                   	nop
    9f48:	c9                   	leave  
    9f49:	c3                   	ret    

00009f4a <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    9f4a:	55                   	push   %ebp
    9f4b:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    9f4d:	8b 45 08             	mov    0x8(%ebp),%eax
    9f50:	83 c0 0c             	add    $0xc,%eax
    9f53:	50                   	push   %eax
    9f54:	e8 5a f0 ff ff       	call   8fb3 <lodepng_color_mode_init>
    9f59:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    9f5c:	8b 45 08             	mov    0x8(%ebp),%eax
    9f5f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    9f66:	8b 45 08             	mov    0x8(%ebp),%eax
    9f69:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    9f6f:	8b 45 08             	mov    0x8(%ebp),%eax
    9f72:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    9f79:	8b 45 08             	mov    0x8(%ebp),%eax
    9f7c:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    9f83:	8b 45 08             	mov    0x8(%ebp),%eax
    9f86:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    9f8d:	8b 45 08             	mov    0x8(%ebp),%eax
    9f90:	8b 50 38             	mov    0x38(%eax),%edx
    9f93:	8b 45 08             	mov    0x8(%ebp),%eax
    9f96:	89 50 34             	mov    %edx,0x34(%eax)
    9f99:	8b 45 08             	mov    0x8(%ebp),%eax
    9f9c:	8b 50 34             	mov    0x34(%eax),%edx
    9f9f:	8b 45 08             	mov    0x8(%ebp),%eax
    9fa2:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    9fa5:	ff 75 08             	pushl  0x8(%ebp)
    9fa8:	e8 2c f8 ff ff       	call   97d9 <LodePNGText_init>
    9fad:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    9fb0:	ff 75 08             	pushl  0x8(%ebp)
    9fb3:	e8 a8 fa ff ff       	call   9a60 <LodePNGIText_init>
    9fb8:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    9fbb:	8b 45 08             	mov    0x8(%ebp),%eax
    9fbe:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    9fc5:	8b 45 08             	mov    0x8(%ebp),%eax
    9fc8:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    9fcf:	8b 45 08             	mov    0x8(%ebp),%eax
    9fd2:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    9fd9:	00 00 00 
  info->chrm_defined = 0;
    9fdc:	8b 45 08             	mov    0x8(%ebp),%eax
    9fdf:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    9fe6:	00 00 00 
  info->srgb_defined = 0;
    9fe9:	8b 45 08             	mov    0x8(%ebp),%eax
    9fec:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    9ff3:	00 00 00 
  info->iccp_defined = 0;
    9ff6:	8b 45 08             	mov    0x8(%ebp),%eax
    9ff9:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    a000:	00 00 00 
  info->iccp_name = NULL;
    a003:	8b 45 08             	mov    0x8(%ebp),%eax
    a006:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    a00d:	00 00 00 
  info->iccp_profile = NULL;
    a010:	8b 45 08             	mov    0x8(%ebp),%eax
    a013:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    a01a:	00 00 00 

  LodePNGUnknownChunks_init(info);
    a01d:	ff 75 08             	pushl  0x8(%ebp)
    a020:	e8 46 f6 ff ff       	call   966b <LodePNGUnknownChunks_init>
    a025:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    a028:	90                   	nop
    a029:	c9                   	leave  
    a02a:	c3                   	ret    

0000a02b <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    a02b:	55                   	push   %ebp
    a02c:	89 e5                	mov    %esp,%ebp
    a02e:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    a031:	8b 45 08             	mov    0x8(%ebp),%eax
    a034:	83 c0 0c             	add    $0xc,%eax
    a037:	83 ec 0c             	sub    $0xc,%esp
    a03a:	50                   	push   %eax
    a03b:	e8 66 f0 ff ff       	call   90a6 <lodepng_color_mode_cleanup>
    a040:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    a043:	83 ec 0c             	sub    $0xc,%esp
    a046:	ff 75 08             	pushl  0x8(%ebp)
    a049:	e8 af f7 ff ff       	call   97fd <LodePNGText_cleanup>
    a04e:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    a051:	83 ec 0c             	sub    $0xc,%esp
    a054:	ff 75 08             	pushl  0x8(%ebp)
    a057:	e8 3c fa ff ff       	call   9a98 <LodePNGIText_cleanup>
    a05c:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    a05f:	83 ec 0c             	sub    $0xc,%esp
    a062:	ff 75 08             	pushl  0x8(%ebp)
    a065:	e8 87 fe ff ff       	call   9ef1 <lodepng_clear_icc>
    a06a:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    a06d:	83 ec 0c             	sub    $0xc,%esp
    a070:	ff 75 08             	pushl  0x8(%ebp)
    a073:	e8 44 f6 ff ff       	call   96bc <LodePNGUnknownChunks_cleanup>
    a078:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    a07b:	90                   	nop
    a07c:	c9                   	leave  
    a07d:	c3                   	ret    

0000a07e <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    a07e:	55                   	push   %ebp
    a07f:	89 e5                	mov    %esp,%ebp
    a081:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    a084:	83 ec 0c             	sub    $0xc,%esp
    a087:	ff 75 08             	pushl  0x8(%ebp)
    a08a:	e8 9c ff ff ff       	call   a02b <lodepng_info_cleanup>
    a08f:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    a092:	83 ec 04             	sub    $0x4,%esp
    a095:	68 e4 00 00 00       	push   $0xe4
    a09a:	ff 75 0c             	pushl  0xc(%ebp)
    a09d:	ff 75 08             	pushl  0x8(%ebp)
    a0a0:	e8 3d 98 ff ff       	call   38e2 <lodepng_memcpy>
    a0a5:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    a0a8:	8b 45 08             	mov    0x8(%ebp),%eax
    a0ab:	83 c0 0c             	add    $0xc,%eax
    a0ae:	83 ec 0c             	sub    $0xc,%esp
    a0b1:	50                   	push   %eax
    a0b2:	e8 fc ee ff ff       	call   8fb3 <lodepng_color_mode_init>
    a0b7:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    a0ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    a0bd:	8d 50 0c             	lea    0xc(%eax),%edx
    a0c0:	8b 45 08             	mov    0x8(%ebp),%eax
    a0c3:	83 c0 0c             	add    $0xc,%eax
    a0c6:	83 ec 08             	sub    $0x8,%esp
    a0c9:	52                   	push   %edx
    a0ca:	50                   	push   %eax
    a0cb:	e8 ed ef ff ff       	call   90bd <lodepng_color_mode_copy>
    a0d0:	83 c4 10             	add    $0x10,%esp
    a0d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    a0d6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    a0da:	74 08                	je     a0e4 <lodepng_info_copy+0x66>
    a0dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a0df:	e9 b7 00 00 00       	jmp    a19b <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    a0e4:	83 ec 08             	sub    $0x8,%esp
    a0e7:	ff 75 0c             	pushl  0xc(%ebp)
    a0ea:	ff 75 08             	pushl  0x8(%ebp)
    a0ed:	e8 84 f7 ff ff       	call   9876 <LodePNGText_copy>
    a0f2:	83 c4 10             	add    $0x10,%esp
    a0f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    a0f8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a0fc:	74 08                	je     a106 <lodepng_info_copy+0x88>
    a0fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a101:	e9 95 00 00 00       	jmp    a19b <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    a106:	83 ec 08             	sub    $0x8,%esp
    a109:	ff 75 0c             	pushl  0xc(%ebp)
    a10c:	ff 75 08             	pushl  0x8(%ebp)
    a10f:	e8 55 fa ff ff       	call   9b69 <LodePNGIText_copy>
    a114:	83 c4 10             	add    $0x10,%esp
    a117:	89 45 ec             	mov    %eax,-0x14(%ebp)
    a11a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    a11e:	74 05                	je     a125 <lodepng_info_copy+0xa7>
    a120:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a123:	eb 76                	jmp    a19b <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    a125:	8b 45 0c             	mov    0xc(%ebp),%eax
    a128:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    a12e:	85 c0                	test   %eax,%eax
    a130:	74 37                	je     a169 <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    a132:	8b 45 0c             	mov    0xc(%ebp),%eax
    a135:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    a13b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a13e:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    a144:	8b 45 0c             	mov    0xc(%ebp),%eax
    a147:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    a14d:	51                   	push   %ecx
    a14e:	52                   	push   %edx
    a14f:	50                   	push   %eax
    a150:	ff 75 08             	pushl  0x8(%ebp)
    a153:	e8 bc fc ff ff       	call   9e14 <lodepng_assign_icc>
    a158:	83 c4 10             	add    $0x10,%esp
    a15b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    a15e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    a162:	74 05                	je     a169 <lodepng_info_copy+0xeb>
    a164:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a167:	eb 32                	jmp    a19b <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    a169:	83 ec 0c             	sub    $0xc,%esp
    a16c:	ff 75 08             	pushl  0x8(%ebp)
    a16f:	e8 f7 f4 ff ff       	call   966b <LodePNGUnknownChunks_init>
    a174:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    a177:	83 ec 08             	sub    $0x8,%esp
    a17a:	ff 75 0c             	pushl  0xc(%ebp)
    a17d:	ff 75 08             	pushl  0x8(%ebp)
    a180:	e8 6c f5 ff ff       	call   96f1 <LodePNGUnknownChunks_copy>
    a185:	83 c4 10             	add    $0x10,%esp
    a188:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    a18b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    a18f:	74 05                	je     a196 <lodepng_info_copy+0x118>
    a191:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a194:	eb 05                	jmp    a19b <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    a196:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a19b:	c9                   	leave  
    a19c:	c3                   	ret    

0000a19d <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    a19d:	55                   	push   %ebp
    a19e:	89 e5                	mov    %esp,%ebp
    a1a0:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    a1a3:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    a1a7:	74 14                	je     a1bd <addColorBits+0x20>
    a1a9:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    a1ad:	75 07                	jne    a1b6 <addColorBits+0x19>
    a1af:	b8 03 00 00 00       	mov    $0x3,%eax
    a1b4:	eb 0c                	jmp    a1c2 <addColorBits+0x25>
    a1b6:	b8 01 00 00 00       	mov    $0x1,%eax
    a1bb:	eb 05                	jmp    a1c2 <addColorBits+0x25>
    a1bd:	b8 07 00 00 00       	mov    $0x7,%eax
    a1c2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    a1c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1c8:	23 45 fc             	and    -0x4(%ebp),%eax
    a1cb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    a1ce:	8b 45 10             	mov    0x10(%ebp),%eax
    a1d1:	ba 01 00 00 00       	mov    $0x1,%edx
    a1d6:	89 c1                	mov    %eax,%ecx
    a1d8:	d3 e2                	shl    %cl,%edx
    a1da:	89 d0                	mov    %edx,%eax
    a1dc:	83 e8 01             	sub    $0x1,%eax
    a1df:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    a1e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a1e5:	2b 45 f8             	sub    -0x8(%ebp),%eax
    a1e8:	0f af 45 10          	imul   0x10(%ebp),%eax
    a1ec:	89 c1                	mov    %eax,%ecx
    a1ee:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    a1f1:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a1f5:	75 18                	jne    a20f <addColorBits+0x72>
    a1f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1fa:	0f af 45 10          	imul   0x10(%ebp),%eax
    a1fe:	c1 e8 03             	shr    $0x3,%eax
    a201:	89 c2                	mov    %eax,%edx
    a203:	8b 45 08             	mov    0x8(%ebp),%eax
    a206:	01 d0                	add    %edx,%eax
    a208:	8b 55 14             	mov    0x14(%ebp),%edx
    a20b:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    a20d:	eb 1e                	jmp    a22d <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    a20f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a212:	0f af 45 10          	imul   0x10(%ebp),%eax
    a216:	c1 e8 03             	shr    $0x3,%eax
    a219:	8b 55 08             	mov    0x8(%ebp),%edx
    a21c:	01 c2                	add    %eax,%edx
    a21e:	8b 4d 08             	mov    0x8(%ebp),%ecx
    a221:	01 c8                	add    %ecx,%eax
    a223:	0f b6 08             	movzbl (%eax),%ecx
    a226:	8b 45 14             	mov    0x14(%ebp),%eax
    a229:	09 c8                	or     %ecx,%eax
    a22b:	88 02                	mov    %al,(%edx)
}
    a22d:	90                   	nop
    a22e:	c9                   	leave  
    a22f:	c3                   	ret    

0000a230 <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    a230:	55                   	push   %ebp
    a231:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    a233:	8b 45 08             	mov    0x8(%ebp),%eax
    a236:	6a 40                	push   $0x40
    a238:	6a 00                	push   $0x0
    a23a:	50                   	push   %eax
    a23b:	e8 d5 96 ff ff       	call   3915 <lodepng_memset>
    a240:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    a243:	8b 45 08             	mov    0x8(%ebp),%eax
    a246:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    a24d:	90                   	nop
    a24e:	c9                   	leave  
    a24f:	c3                   	ret    

0000a250 <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    a250:	55                   	push   %ebp
    a251:	89 e5                	mov    %esp,%ebp
    a253:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    a256:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a25d:	eb 3b                	jmp    a29a <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    a25f:	8b 45 08             	mov    0x8(%ebp),%eax
    a262:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a265:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a268:	85 c0                	test   %eax,%eax
    a26a:	74 2a                	je     a296 <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    a26c:	8b 45 08             	mov    0x8(%ebp),%eax
    a26f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a272:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a275:	83 ec 0c             	sub    $0xc,%esp
    a278:	50                   	push   %eax
    a279:	e8 d2 ff ff ff       	call   a250 <color_tree_cleanup>
    a27e:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    a281:	8b 45 08             	mov    0x8(%ebp),%eax
    a284:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a287:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a28a:	83 ec 0c             	sub    $0xc,%esp
    a28d:	50                   	push   %eax
    a28e:	e8 32 96 ff ff       	call   38c5 <lodepng_free>
    a293:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    a296:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a29a:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    a29e:	75 bf                	jne    a25f <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    a2a0:	90                   	nop
    a2a1:	c9                   	leave  
    a2a2:	c3                   	ret    

0000a2a3 <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a2a3:	55                   	push   %ebp
    a2a4:	89 e5                	mov    %esp,%ebp
    a2a6:	53                   	push   %ebx
    a2a7:	83 ec 20             	sub    $0x20,%esp
    a2aa:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a2ad:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a2b0:	8b 55 14             	mov    0x14(%ebp),%edx
    a2b3:	8b 45 18             	mov    0x18(%ebp),%eax
    a2b6:	88 5d e8             	mov    %bl,-0x18(%ebp)
    a2b9:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    a2bc:	88 55 e0             	mov    %dl,-0x20(%ebp)
    a2bf:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    a2c2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    a2c9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    a2d0:	eb 76                	jmp    a348 <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    a2d2:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a2d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a2d9:	89 c1                	mov    %eax,%ecx
    a2db:	d3 fa                	sar    %cl,%edx
    a2dd:	89 d0                	mov    %edx,%eax
    a2df:	83 e0 01             	and    $0x1,%eax
    a2e2:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a2e5:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a2e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a2ec:	89 c1                	mov    %eax,%ecx
    a2ee:	d3 fa                	sar    %cl,%edx
    a2f0:	89 d0                	mov    %edx,%eax
    a2f2:	83 e0 01             	and    $0x1,%eax
    a2f5:	01 d8                	add    %ebx,%eax
    a2f7:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a2fa:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a2fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a301:	89 c1                	mov    %eax,%ecx
    a303:	d3 fa                	sar    %cl,%edx
    a305:	89 d0                	mov    %edx,%eax
    a307:	83 e0 01             	and    $0x1,%eax
    a30a:	01 d8                	add    %ebx,%eax
    a30c:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a30f:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a313:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a316:	89 c1                	mov    %eax,%ecx
    a318:	d3 fa                	sar    %cl,%edx
    a31a:	89 d0                	mov    %edx,%eax
    a31c:	83 e0 01             	and    $0x1,%eax
    a31f:	01 d8                	add    %ebx,%eax
    a321:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    a324:	8b 45 08             	mov    0x8(%ebp),%eax
    a327:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a32a:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a32d:	85 c0                	test   %eax,%eax
    a32f:	75 07                	jne    a338 <color_tree_get+0x95>
    a331:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a336:	eb 2a                	jmp    a362 <color_tree_get+0xbf>
    else tree = tree->children[i];
    a338:	8b 45 08             	mov    0x8(%ebp),%eax
    a33b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a33e:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a341:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    a344:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    a348:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    a34c:	7e 84                	jle    a2d2 <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    a34e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    a352:	74 08                	je     a35c <color_tree_get+0xb9>
    a354:	8b 45 08             	mov    0x8(%ebp),%eax
    a357:	8b 40 40             	mov    0x40(%eax),%eax
    a35a:	eb 05                	jmp    a361 <color_tree_get+0xbe>
    a35c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a361:	90                   	nop
}
    a362:	83 c4 20             	add    $0x20,%esp
    a365:	5b                   	pop    %ebx
    a366:	5d                   	pop    %ebp
    a367:	c3                   	ret    

0000a368 <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a368:	55                   	push   %ebp
    a369:	89 e5                	mov    %esp,%ebp
    a36b:	53                   	push   %ebx
    a36c:	83 ec 10             	sub    $0x10,%esp
    a36f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a372:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a375:	8b 55 14             	mov    0x14(%ebp),%edx
    a378:	8b 45 18             	mov    0x18(%ebp),%eax
    a37b:	88 5d f8             	mov    %bl,-0x8(%ebp)
    a37e:	88 4d f4             	mov    %cl,-0xc(%ebp)
    a381:	88 55 f0             	mov    %dl,-0x10(%ebp)
    a384:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    a387:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    a38b:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    a38f:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    a393:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    a397:	53                   	push   %ebx
    a398:	51                   	push   %ecx
    a399:	52                   	push   %edx
    a39a:	50                   	push   %eax
    a39b:	ff 75 08             	pushl  0x8(%ebp)
    a39e:	e8 00 ff ff ff       	call   a2a3 <color_tree_get>
    a3a3:	83 c4 14             	add    $0x14,%esp
    a3a6:	f7 d0                	not    %eax
    a3a8:	c1 e8 1f             	shr    $0x1f,%eax
    a3ab:	0f b6 c0             	movzbl %al,%eax
}
    a3ae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a3b1:	c9                   	leave  
    a3b2:	c3                   	ret    

0000a3b3 <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    a3b3:	55                   	push   %ebp
    a3b4:	89 e5                	mov    %esp,%ebp
    a3b6:	53                   	push   %ebx
    a3b7:	83 ec 24             	sub    $0x24,%esp
    a3ba:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a3bd:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a3c0:	8b 55 14             	mov    0x14(%ebp),%edx
    a3c3:	8b 45 18             	mov    0x18(%ebp),%eax
    a3c6:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    a3c9:	88 4d e0             	mov    %cl,-0x20(%ebp)
    a3cc:	88 55 dc             	mov    %dl,-0x24(%ebp)
    a3cf:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    a3d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a3d9:	e9 b0 00 00 00       	jmp    a48e <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    a3de:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a3e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a3e5:	89 c1                	mov    %eax,%ecx
    a3e7:	d3 fa                	sar    %cl,%edx
    a3e9:	89 d0                	mov    %edx,%eax
    a3eb:	83 e0 01             	and    $0x1,%eax
    a3ee:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a3f1:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a3f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a3f8:	89 c1                	mov    %eax,%ecx
    a3fa:	d3 fa                	sar    %cl,%edx
    a3fc:	89 d0                	mov    %edx,%eax
    a3fe:	83 e0 01             	and    $0x1,%eax
    a401:	01 d8                	add    %ebx,%eax
    a403:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a406:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a40a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a40d:	89 c1                	mov    %eax,%ecx
    a40f:	d3 fa                	sar    %cl,%edx
    a411:	89 d0                	mov    %edx,%eax
    a413:	83 e0 01             	and    $0x1,%eax
    a416:	01 d8                	add    %ebx,%eax
    a418:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a41b:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    a41f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a422:	89 c1                	mov    %eax,%ecx
    a424:	d3 fa                	sar    %cl,%edx
    a426:	89 d0                	mov    %edx,%eax
    a428:	83 e0 01             	and    $0x1,%eax
    a42b:	01 d8                	add    %ebx,%eax
    a42d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    a430:	8b 45 08             	mov    0x8(%ebp),%eax
    a433:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a436:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a439:	85 c0                	test   %eax,%eax
    a43b:	75 41                	jne    a47e <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    a43d:	83 ec 0c             	sub    $0xc,%esp
    a440:	6a 44                	push   $0x44
    a442:	e8 5d 94 ff ff       	call   38a4 <lodepng_malloc>
    a447:	83 c4 10             	add    $0x10,%esp
    a44a:	89 c1                	mov    %eax,%ecx
    a44c:	8b 45 08             	mov    0x8(%ebp),%eax
    a44f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a452:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    a455:	8b 45 08             	mov    0x8(%ebp),%eax
    a458:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a45b:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a45e:	85 c0                	test   %eax,%eax
    a460:	75 07                	jne    a469 <color_tree_add+0xb6>
    a462:	b8 53 00 00 00       	mov    $0x53,%eax
    a467:	eb 3d                	jmp    a4a6 <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    a469:	8b 45 08             	mov    0x8(%ebp),%eax
    a46c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a46f:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a472:	83 ec 0c             	sub    $0xc,%esp
    a475:	50                   	push   %eax
    a476:	e8 b5 fd ff ff       	call   a230 <color_tree_init>
    a47b:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    a47e:	8b 45 08             	mov    0x8(%ebp),%eax
    a481:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a484:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a487:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    a48a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a48e:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    a492:	0f 8e 46 ff ff ff    	jle    a3de <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    a498:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a49b:	8b 45 08             	mov    0x8(%ebp),%eax
    a49e:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    a4a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a4a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a4a9:	c9                   	leave  
    a4aa:	c3                   	ret    

0000a4ab <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a4ab:	55                   	push   %ebp
    a4ac:	89 e5                	mov    %esp,%ebp
    a4ae:	53                   	push   %ebx
    a4af:	83 ec 20             	sub    $0x20,%esp
    a4b2:	8b 5d 18             	mov    0x18(%ebp),%ebx
    a4b5:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    a4b8:	8b 55 20             	mov    0x20(%ebp),%edx
    a4bb:	8b 45 24             	mov    0x24(%ebp),%eax
    a4be:	88 5d e8             	mov    %bl,-0x18(%ebp)
    a4c1:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    a4c4:	88 55 e0             	mov    %dl,-0x20(%ebp)
    a4c7:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a4ca:	8b 45 10             	mov    0x10(%ebp),%eax
    a4cd:	8b 00                	mov    (%eax),%eax
    a4cf:	85 c0                	test   %eax,%eax
    a4d1:	0f 85 ad 00 00 00    	jne    a584 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a4d7:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a4db:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    a4de:	8b 45 10             	mov    0x10(%ebp),%eax
    a4e1:	8b 40 04             	mov    0x4(%eax),%eax
    a4e4:	83 f8 08             	cmp    $0x8,%eax
    a4e7:	75 13                	jne    a4fc <rgba8ToPixel+0x51>
    a4e9:	8b 55 0c             	mov    0xc(%ebp),%edx
    a4ec:	8b 45 08             	mov    0x8(%ebp),%eax
    a4ef:	01 c2                	add    %eax,%edx
    a4f1:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    a4f5:	88 02                	mov    %al,(%edx)
    a4f7:	e9 b4 03 00 00       	jmp    a8b0 <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    a4fc:	8b 45 10             	mov    0x10(%ebp),%eax
    a4ff:	8b 40 04             	mov    0x4(%eax),%eax
    a502:	83 f8 10             	cmp    $0x10,%eax
    a505:	75 2a                	jne    a531 <rgba8ToPixel+0x86>
    a507:	8b 45 0c             	mov    0xc(%ebp),%eax
    a50a:	01 c0                	add    %eax,%eax
    a50c:	89 c2                	mov    %eax,%edx
    a50e:	8b 45 08             	mov    0x8(%ebp),%eax
    a511:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a514:	8b 45 0c             	mov    0xc(%ebp),%eax
    a517:	01 c0                	add    %eax,%eax
    a519:	8d 50 01             	lea    0x1(%eax),%edx
    a51c:	8b 45 08             	mov    0x8(%ebp),%eax
    a51f:	01 d0                	add    %edx,%eax
    a521:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a525:	88 10                	mov    %dl,(%eax)
    a527:	0f b6 00             	movzbl (%eax),%eax
    a52a:	88 01                	mov    %al,(%ecx)
    a52c:	e9 7f 03 00 00       	jmp    a8b0 <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    a531:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a535:	8b 45 10             	mov    0x10(%ebp),%eax
    a538:	8b 40 04             	mov    0x4(%eax),%eax
    a53b:	b9 08 00 00 00       	mov    $0x8,%ecx
    a540:	29 c1                	sub    %eax,%ecx
    a542:	89 c8                	mov    %ecx,%eax
    a544:	89 c1                	mov    %eax,%ecx
    a546:	d3 ea                	shr    %cl,%edx
    a548:	89 d0                	mov    %edx,%eax
    a54a:	89 c2                	mov    %eax,%edx
    a54c:	8b 45 10             	mov    0x10(%ebp),%eax
    a54f:	8b 40 04             	mov    0x4(%eax),%eax
    a552:	bb 01 00 00 00       	mov    $0x1,%ebx
    a557:	89 c1                	mov    %eax,%ecx
    a559:	d3 e3                	shl    %cl,%ebx
    a55b:	89 d8                	mov    %ebx,%eax
    a55d:	83 e8 01             	sub    $0x1,%eax
    a560:	21 d0                	and    %edx,%eax
    a562:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    a565:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a569:	8b 45 10             	mov    0x10(%ebp),%eax
    a56c:	8b 40 04             	mov    0x4(%eax),%eax
    a56f:	52                   	push   %edx
    a570:	50                   	push   %eax
    a571:	ff 75 0c             	pushl  0xc(%ebp)
    a574:	ff 75 08             	pushl  0x8(%ebp)
    a577:	e8 21 fc ff ff       	call   a19d <addColorBits>
    a57c:	83 c4 10             	add    $0x10,%esp
    a57f:	e9 2c 03 00 00       	jmp    a8b0 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    a584:	8b 45 10             	mov    0x10(%ebp),%eax
    a587:	8b 00                	mov    (%eax),%eax
    a589:	83 f8 02             	cmp    $0x2,%eax
    a58c:	0f 85 ee 00 00 00    	jne    a680 <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    a592:	8b 45 10             	mov    0x10(%ebp),%eax
    a595:	8b 40 04             	mov    0x4(%eax),%eax
    a598:	83 f8 08             	cmp    $0x8,%eax
    a59b:	75 49                	jne    a5e6 <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    a59d:	8b 55 0c             	mov    0xc(%ebp),%edx
    a5a0:	89 d0                	mov    %edx,%eax
    a5a2:	01 c0                	add    %eax,%eax
    a5a4:	01 d0                	add    %edx,%eax
    a5a6:	89 c2                	mov    %eax,%edx
    a5a8:	8b 45 08             	mov    0x8(%ebp),%eax
    a5ab:	01 c2                	add    %eax,%edx
    a5ad:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a5b1:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    a5b3:	8b 55 0c             	mov    0xc(%ebp),%edx
    a5b6:	89 d0                	mov    %edx,%eax
    a5b8:	01 c0                	add    %eax,%eax
    a5ba:	01 d0                	add    %edx,%eax
    a5bc:	8d 50 01             	lea    0x1(%eax),%edx
    a5bf:	8b 45 08             	mov    0x8(%ebp),%eax
    a5c2:	01 c2                	add    %eax,%edx
    a5c4:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a5c8:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a5ca:	8b 55 0c             	mov    0xc(%ebp),%edx
    a5cd:	89 d0                	mov    %edx,%eax
    a5cf:	01 c0                	add    %eax,%eax
    a5d1:	01 d0                	add    %edx,%eax
    a5d3:	8d 50 02             	lea    0x2(%eax),%edx
    a5d6:	8b 45 08             	mov    0x8(%ebp),%eax
    a5d9:	01 c2                	add    %eax,%edx
    a5db:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a5df:	88 02                	mov    %al,(%edx)
    a5e1:	e9 ca 02 00 00       	jmp    a8b0 <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a5e6:	8b 55 0c             	mov    0xc(%ebp),%edx
    a5e9:	89 d0                	mov    %edx,%eax
    a5eb:	01 c0                	add    %eax,%eax
    a5ed:	01 d0                	add    %edx,%eax
    a5ef:	01 c0                	add    %eax,%eax
    a5f1:	89 c2                	mov    %eax,%edx
    a5f3:	8b 45 08             	mov    0x8(%ebp),%eax
    a5f6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a5f9:	8b 55 0c             	mov    0xc(%ebp),%edx
    a5fc:	89 d0                	mov    %edx,%eax
    a5fe:	01 c0                	add    %eax,%eax
    a600:	01 d0                	add    %edx,%eax
    a602:	01 c0                	add    %eax,%eax
    a604:	8d 50 01             	lea    0x1(%eax),%edx
    a607:	8b 45 08             	mov    0x8(%ebp),%eax
    a60a:	01 d0                	add    %edx,%eax
    a60c:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a610:	88 10                	mov    %dl,(%eax)
    a612:	0f b6 00             	movzbl (%eax),%eax
    a615:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a617:	8b 55 0c             	mov    0xc(%ebp),%edx
    a61a:	89 d0                	mov    %edx,%eax
    a61c:	01 c0                	add    %eax,%eax
    a61e:	01 d0                	add    %edx,%eax
    a620:	01 c0                	add    %eax,%eax
    a622:	8d 50 02             	lea    0x2(%eax),%edx
    a625:	8b 45 08             	mov    0x8(%ebp),%eax
    a628:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a62b:	8b 55 0c             	mov    0xc(%ebp),%edx
    a62e:	89 d0                	mov    %edx,%eax
    a630:	01 c0                	add    %eax,%eax
    a632:	01 d0                	add    %edx,%eax
    a634:	01 c0                	add    %eax,%eax
    a636:	8d 50 03             	lea    0x3(%eax),%edx
    a639:	8b 45 08             	mov    0x8(%ebp),%eax
    a63c:	01 d0                	add    %edx,%eax
    a63e:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a642:	88 10                	mov    %dl,(%eax)
    a644:	0f b6 00             	movzbl (%eax),%eax
    a647:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a649:	8b 55 0c             	mov    0xc(%ebp),%edx
    a64c:	89 d0                	mov    %edx,%eax
    a64e:	01 c0                	add    %eax,%eax
    a650:	01 d0                	add    %edx,%eax
    a652:	01 c0                	add    %eax,%eax
    a654:	8d 50 04             	lea    0x4(%eax),%edx
    a657:	8b 45 08             	mov    0x8(%ebp),%eax
    a65a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a65d:	8b 55 0c             	mov    0xc(%ebp),%edx
    a660:	89 d0                	mov    %edx,%eax
    a662:	01 c0                	add    %eax,%eax
    a664:	01 d0                	add    %edx,%eax
    a666:	01 c0                	add    %eax,%eax
    a668:	8d 50 05             	lea    0x5(%eax),%edx
    a66b:	8b 45 08             	mov    0x8(%ebp),%eax
    a66e:	01 d0                	add    %edx,%eax
    a670:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a674:	88 10                	mov    %dl,(%eax)
    a676:	0f b6 00             	movzbl (%eax),%eax
    a679:	88 01                	mov    %al,(%ecx)
    a67b:	e9 30 02 00 00       	jmp    a8b0 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a680:	8b 45 10             	mov    0x10(%ebp),%eax
    a683:	8b 00                	mov    (%eax),%eax
    a685:	83 f8 03             	cmp    $0x3,%eax
    a688:	75 6d                	jne    a6f7 <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a68a:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a68e:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a692:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a696:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a69a:	53                   	push   %ebx
    a69b:	51                   	push   %ecx
    a69c:	52                   	push   %edx
    a69d:	50                   	push   %eax
    a69e:	ff 75 14             	pushl  0x14(%ebp)
    a6a1:	e8 fd fb ff ff       	call   a2a3 <color_tree_get>
    a6a6:	83 c4 14             	add    $0x14,%esp
    a6a9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a6ac:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a6b0:	79 0a                	jns    a6bc <rgba8ToPixel+0x211>
    a6b2:	b8 52 00 00 00       	mov    $0x52,%eax
    a6b7:	e9 f9 01 00 00       	jmp    a8b5 <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a6bc:	8b 45 10             	mov    0x10(%ebp),%eax
    a6bf:	8b 40 04             	mov    0x4(%eax),%eax
    a6c2:	83 f8 08             	cmp    $0x8,%eax
    a6c5:	75 12                	jne    a6d9 <rgba8ToPixel+0x22e>
    a6c7:	8b 55 0c             	mov    0xc(%ebp),%edx
    a6ca:	8b 45 08             	mov    0x8(%ebp),%eax
    a6cd:	01 d0                	add    %edx,%eax
    a6cf:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a6d2:	88 10                	mov    %dl,(%eax)
    a6d4:	e9 d7 01 00 00       	jmp    a8b0 <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a6d9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a6dc:	8b 45 10             	mov    0x10(%ebp),%eax
    a6df:	8b 40 04             	mov    0x4(%eax),%eax
    a6e2:	52                   	push   %edx
    a6e3:	50                   	push   %eax
    a6e4:	ff 75 0c             	pushl  0xc(%ebp)
    a6e7:	ff 75 08             	pushl  0x8(%ebp)
    a6ea:	e8 ae fa ff ff       	call   a19d <addColorBits>
    a6ef:	83 c4 10             	add    $0x10,%esp
    a6f2:	e9 b9 01 00 00       	jmp    a8b0 <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a6f7:	8b 45 10             	mov    0x10(%ebp),%eax
    a6fa:	8b 00                	mov    (%eax),%eax
    a6fc:	83 f8 04             	cmp    $0x4,%eax
    a6ff:	0f 85 9f 00 00 00    	jne    a7a4 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a705:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a709:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a70c:	8b 45 10             	mov    0x10(%ebp),%eax
    a70f:	8b 40 04             	mov    0x4(%eax),%eax
    a712:	83 f8 08             	cmp    $0x8,%eax
    a715:	75 2a                	jne    a741 <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a717:	8b 45 0c             	mov    0xc(%ebp),%eax
    a71a:	01 c0                	add    %eax,%eax
    a71c:	89 c2                	mov    %eax,%edx
    a71e:	8b 45 08             	mov    0x8(%ebp),%eax
    a721:	01 c2                	add    %eax,%edx
    a723:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a727:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a729:	8b 45 0c             	mov    0xc(%ebp),%eax
    a72c:	01 c0                	add    %eax,%eax
    a72e:	8d 50 01             	lea    0x1(%eax),%edx
    a731:	8b 45 08             	mov    0x8(%ebp),%eax
    a734:	01 c2                	add    %eax,%edx
    a736:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a73a:	88 02                	mov    %al,(%edx)
    a73c:	e9 6f 01 00 00       	jmp    a8b0 <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a741:	8b 45 10             	mov    0x10(%ebp),%eax
    a744:	8b 40 04             	mov    0x4(%eax),%eax
    a747:	83 f8 10             	cmp    $0x10,%eax
    a74a:	0f 85 60 01 00 00    	jne    a8b0 <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a750:	8b 45 0c             	mov    0xc(%ebp),%eax
    a753:	c1 e0 02             	shl    $0x2,%eax
    a756:	89 c2                	mov    %eax,%edx
    a758:	8b 45 08             	mov    0x8(%ebp),%eax
    a75b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a75e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a761:	c1 e0 02             	shl    $0x2,%eax
    a764:	8d 50 01             	lea    0x1(%eax),%edx
    a767:	8b 45 08             	mov    0x8(%ebp),%eax
    a76a:	01 d0                	add    %edx,%eax
    a76c:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a770:	88 10                	mov    %dl,(%eax)
    a772:	0f b6 00             	movzbl (%eax),%eax
    a775:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a777:	8b 45 0c             	mov    0xc(%ebp),%eax
    a77a:	c1 e0 02             	shl    $0x2,%eax
    a77d:	8d 50 02             	lea    0x2(%eax),%edx
    a780:	8b 45 08             	mov    0x8(%ebp),%eax
    a783:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a786:	8b 45 0c             	mov    0xc(%ebp),%eax
    a789:	c1 e0 02             	shl    $0x2,%eax
    a78c:	8d 50 03             	lea    0x3(%eax),%edx
    a78f:	8b 45 08             	mov    0x8(%ebp),%eax
    a792:	01 d0                	add    %edx,%eax
    a794:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a798:	88 10                	mov    %dl,(%eax)
    a79a:	0f b6 00             	movzbl (%eax),%eax
    a79d:	88 01                	mov    %al,(%ecx)
    a79f:	e9 0c 01 00 00       	jmp    a8b0 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a7a4:	8b 45 10             	mov    0x10(%ebp),%eax
    a7a7:	8b 00                	mov    (%eax),%eax
    a7a9:	83 f8 06             	cmp    $0x6,%eax
    a7ac:	0f 85 fe 00 00 00    	jne    a8b0 <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a7b2:	8b 45 10             	mov    0x10(%ebp),%eax
    a7b5:	8b 40 04             	mov    0x4(%eax),%eax
    a7b8:	83 f8 08             	cmp    $0x8,%eax
    a7bb:	75 54                	jne    a811 <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a7bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7c0:	c1 e0 02             	shl    $0x2,%eax
    a7c3:	89 c2                	mov    %eax,%edx
    a7c5:	8b 45 08             	mov    0x8(%ebp),%eax
    a7c8:	01 c2                	add    %eax,%edx
    a7ca:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a7ce:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a7d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7d3:	c1 e0 02             	shl    $0x2,%eax
    a7d6:	8d 50 01             	lea    0x1(%eax),%edx
    a7d9:	8b 45 08             	mov    0x8(%ebp),%eax
    a7dc:	01 c2                	add    %eax,%edx
    a7de:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a7e2:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a7e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7e7:	c1 e0 02             	shl    $0x2,%eax
    a7ea:	8d 50 02             	lea    0x2(%eax),%edx
    a7ed:	8b 45 08             	mov    0x8(%ebp),%eax
    a7f0:	01 c2                	add    %eax,%edx
    a7f2:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a7f6:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a7f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7fb:	c1 e0 02             	shl    $0x2,%eax
    a7fe:	8d 50 03             	lea    0x3(%eax),%edx
    a801:	8b 45 08             	mov    0x8(%ebp),%eax
    a804:	01 c2                	add    %eax,%edx
    a806:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a80a:	88 02                	mov    %al,(%edx)
    a80c:	e9 9f 00 00 00       	jmp    a8b0 <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a811:	8b 45 0c             	mov    0xc(%ebp),%eax
    a814:	c1 e0 03             	shl    $0x3,%eax
    a817:	89 c2                	mov    %eax,%edx
    a819:	8b 45 08             	mov    0x8(%ebp),%eax
    a81c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a81f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a822:	c1 e0 03             	shl    $0x3,%eax
    a825:	8d 50 01             	lea    0x1(%eax),%edx
    a828:	8b 45 08             	mov    0x8(%ebp),%eax
    a82b:	01 d0                	add    %edx,%eax
    a82d:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a831:	88 10                	mov    %dl,(%eax)
    a833:	0f b6 00             	movzbl (%eax),%eax
    a836:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a838:	8b 45 0c             	mov    0xc(%ebp),%eax
    a83b:	c1 e0 03             	shl    $0x3,%eax
    a83e:	8d 50 02             	lea    0x2(%eax),%edx
    a841:	8b 45 08             	mov    0x8(%ebp),%eax
    a844:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a847:	8b 45 0c             	mov    0xc(%ebp),%eax
    a84a:	c1 e0 03             	shl    $0x3,%eax
    a84d:	8d 50 03             	lea    0x3(%eax),%edx
    a850:	8b 45 08             	mov    0x8(%ebp),%eax
    a853:	01 d0                	add    %edx,%eax
    a855:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a859:	88 10                	mov    %dl,(%eax)
    a85b:	0f b6 00             	movzbl (%eax),%eax
    a85e:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a860:	8b 45 0c             	mov    0xc(%ebp),%eax
    a863:	c1 e0 03             	shl    $0x3,%eax
    a866:	8d 50 04             	lea    0x4(%eax),%edx
    a869:	8b 45 08             	mov    0x8(%ebp),%eax
    a86c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a86f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a872:	c1 e0 03             	shl    $0x3,%eax
    a875:	8d 50 05             	lea    0x5(%eax),%edx
    a878:	8b 45 08             	mov    0x8(%ebp),%eax
    a87b:	01 d0                	add    %edx,%eax
    a87d:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a881:	88 10                	mov    %dl,(%eax)
    a883:	0f b6 00             	movzbl (%eax),%eax
    a886:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    a888:	8b 45 0c             	mov    0xc(%ebp),%eax
    a88b:	c1 e0 03             	shl    $0x3,%eax
    a88e:	8d 50 06             	lea    0x6(%eax),%edx
    a891:	8b 45 08             	mov    0x8(%ebp),%eax
    a894:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a897:	8b 45 0c             	mov    0xc(%ebp),%eax
    a89a:	c1 e0 03             	shl    $0x3,%eax
    a89d:	8d 50 07             	lea    0x7(%eax),%edx
    a8a0:	8b 45 08             	mov    0x8(%ebp),%eax
    a8a3:	01 d0                	add    %edx,%eax
    a8a5:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a8a9:	88 10                	mov    %dl,(%eax)
    a8ab:	0f b6 00             	movzbl (%eax),%eax
    a8ae:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    a8b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a8b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a8b8:	c9                   	leave  
    a8b9:	c3                   	ret    

0000a8ba <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    a8ba:	55                   	push   %ebp
    a8bb:	89 e5                	mov    %esp,%ebp
    a8bd:	53                   	push   %ebx
    a8be:	83 ec 20             	sub    $0x20,%esp
    a8c1:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a8c4:	8b 4d 18             	mov    0x18(%ebp),%ecx
    a8c7:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8ca:	8b 45 20             	mov    0x20(%ebp),%eax
    a8cd:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    a8d1:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    a8d5:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    a8d9:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a8dd:	8b 45 10             	mov    0x10(%ebp),%eax
    a8e0:	8b 00                	mov    (%eax),%eax
    a8e2:	85 c0                	test   %eax,%eax
    a8e4:	75 36                	jne    a91c <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a8e6:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a8ea:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    a8ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8f1:	01 c0                	add    %eax,%eax
    a8f3:	89 c2                	mov    %eax,%edx
    a8f5:	8b 45 08             	mov    0x8(%ebp),%eax
    a8f8:	01 d0                	add    %edx,%eax
    a8fa:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a8fe:	66 c1 ea 08          	shr    $0x8,%dx
    a902:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    a904:	8b 45 0c             	mov    0xc(%ebp),%eax
    a907:	01 c0                	add    %eax,%eax
    a909:	8d 50 01             	lea    0x1(%eax),%edx
    a90c:	8b 45 08             	mov    0x8(%ebp),%eax
    a90f:	01 d0                	add    %edx,%eax
    a911:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a915:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a917:	e9 df 01 00 00       	jmp    aafb <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    a91c:	8b 45 10             	mov    0x10(%ebp),%eax
    a91f:	8b 00                	mov    (%eax),%eax
    a921:	83 f8 02             	cmp    $0x2,%eax
    a924:	0f 85 a6 00 00 00    	jne    a9d0 <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    a92a:	8b 55 0c             	mov    0xc(%ebp),%edx
    a92d:	89 d0                	mov    %edx,%eax
    a92f:	01 c0                	add    %eax,%eax
    a931:	01 d0                	add    %edx,%eax
    a933:	01 c0                	add    %eax,%eax
    a935:	89 c2                	mov    %eax,%edx
    a937:	8b 45 08             	mov    0x8(%ebp),%eax
    a93a:	01 d0                	add    %edx,%eax
    a93c:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a940:	66 c1 ea 08          	shr    $0x8,%dx
    a944:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    a946:	8b 55 0c             	mov    0xc(%ebp),%edx
    a949:	89 d0                	mov    %edx,%eax
    a94b:	01 c0                	add    %eax,%eax
    a94d:	01 d0                	add    %edx,%eax
    a94f:	01 c0                	add    %eax,%eax
    a951:	8d 50 01             	lea    0x1(%eax),%edx
    a954:	8b 45 08             	mov    0x8(%ebp),%eax
    a957:	01 d0                	add    %edx,%eax
    a959:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a95d:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    a95f:	8b 55 0c             	mov    0xc(%ebp),%edx
    a962:	89 d0                	mov    %edx,%eax
    a964:	01 c0                	add    %eax,%eax
    a966:	01 d0                	add    %edx,%eax
    a968:	01 c0                	add    %eax,%eax
    a96a:	8d 50 02             	lea    0x2(%eax),%edx
    a96d:	8b 45 08             	mov    0x8(%ebp),%eax
    a970:	01 d0                	add    %edx,%eax
    a972:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a976:	66 c1 ea 08          	shr    $0x8,%dx
    a97a:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    a97c:	8b 55 0c             	mov    0xc(%ebp),%edx
    a97f:	89 d0                	mov    %edx,%eax
    a981:	01 c0                	add    %eax,%eax
    a983:	01 d0                	add    %edx,%eax
    a985:	01 c0                	add    %eax,%eax
    a987:	8d 50 03             	lea    0x3(%eax),%edx
    a98a:	8b 45 08             	mov    0x8(%ebp),%eax
    a98d:	01 d0                	add    %edx,%eax
    a98f:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a993:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    a995:	8b 55 0c             	mov    0xc(%ebp),%edx
    a998:	89 d0                	mov    %edx,%eax
    a99a:	01 c0                	add    %eax,%eax
    a99c:	01 d0                	add    %edx,%eax
    a99e:	01 c0                	add    %eax,%eax
    a9a0:	8d 50 04             	lea    0x4(%eax),%edx
    a9a3:	8b 45 08             	mov    0x8(%ebp),%eax
    a9a6:	01 d0                	add    %edx,%eax
    a9a8:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a9ac:	66 c1 ea 08          	shr    $0x8,%dx
    a9b0:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    a9b2:	8b 55 0c             	mov    0xc(%ebp),%edx
    a9b5:	89 d0                	mov    %edx,%eax
    a9b7:	01 c0                	add    %eax,%eax
    a9b9:	01 d0                	add    %edx,%eax
    a9bb:	01 c0                	add    %eax,%eax
    a9bd:	8d 50 05             	lea    0x5(%eax),%edx
    a9c0:	8b 45 08             	mov    0x8(%ebp),%eax
    a9c3:	01 d0                	add    %edx,%eax
    a9c5:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a9c9:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a9cb:	e9 2b 01 00 00       	jmp    aafb <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a9d0:	8b 45 10             	mov    0x10(%ebp),%eax
    a9d3:	8b 00                	mov    (%eax),%eax
    a9d5:	83 f8 04             	cmp    $0x4,%eax
    a9d8:	75 64                	jne    aa3e <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a9da:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a9de:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    a9e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9e5:	c1 e0 02             	shl    $0x2,%eax
    a9e8:	89 c2                	mov    %eax,%edx
    a9ea:	8b 45 08             	mov    0x8(%ebp),%eax
    a9ed:	01 d0                	add    %edx,%eax
    a9ef:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a9f3:	66 c1 ea 08          	shr    $0x8,%dx
    a9f7:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    a9f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9fc:	c1 e0 02             	shl    $0x2,%eax
    a9ff:	8d 50 01             	lea    0x1(%eax),%edx
    aa02:	8b 45 08             	mov    0x8(%ebp),%eax
    aa05:	01 d0                	add    %edx,%eax
    aa07:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    aa0b:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    aa0d:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa10:	c1 e0 02             	shl    $0x2,%eax
    aa13:	8d 50 02             	lea    0x2(%eax),%edx
    aa16:	8b 45 08             	mov    0x8(%ebp),%eax
    aa19:	01 d0                	add    %edx,%eax
    aa1b:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    aa1f:	66 c1 ea 08          	shr    $0x8,%dx
    aa23:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    aa25:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa28:	c1 e0 02             	shl    $0x2,%eax
    aa2b:	8d 50 03             	lea    0x3(%eax),%edx
    aa2e:	8b 45 08             	mov    0x8(%ebp),%eax
    aa31:	01 d0                	add    %edx,%eax
    aa33:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    aa37:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    aa39:	e9 bd 00 00 00       	jmp    aafb <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    aa3e:	8b 45 10             	mov    0x10(%ebp),%eax
    aa41:	8b 00                	mov    (%eax),%eax
    aa43:	83 f8 06             	cmp    $0x6,%eax
    aa46:	0f 85 af 00 00 00    	jne    aafb <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    aa4c:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa4f:	c1 e0 03             	shl    $0x3,%eax
    aa52:	89 c2                	mov    %eax,%edx
    aa54:	8b 45 08             	mov    0x8(%ebp),%eax
    aa57:	01 d0                	add    %edx,%eax
    aa59:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    aa5d:	66 c1 ea 08          	shr    $0x8,%dx
    aa61:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    aa63:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa66:	c1 e0 03             	shl    $0x3,%eax
    aa69:	8d 50 01             	lea    0x1(%eax),%edx
    aa6c:	8b 45 08             	mov    0x8(%ebp),%eax
    aa6f:	01 d0                	add    %edx,%eax
    aa71:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    aa75:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    aa77:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa7a:	c1 e0 03             	shl    $0x3,%eax
    aa7d:	8d 50 02             	lea    0x2(%eax),%edx
    aa80:	8b 45 08             	mov    0x8(%ebp),%eax
    aa83:	01 d0                	add    %edx,%eax
    aa85:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    aa89:	66 c1 ea 08          	shr    $0x8,%dx
    aa8d:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    aa8f:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa92:	c1 e0 03             	shl    $0x3,%eax
    aa95:	8d 50 03             	lea    0x3(%eax),%edx
    aa98:	8b 45 08             	mov    0x8(%ebp),%eax
    aa9b:	01 d0                	add    %edx,%eax
    aa9d:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    aaa1:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    aaa3:	8b 45 0c             	mov    0xc(%ebp),%eax
    aaa6:	c1 e0 03             	shl    $0x3,%eax
    aaa9:	8d 50 04             	lea    0x4(%eax),%edx
    aaac:	8b 45 08             	mov    0x8(%ebp),%eax
    aaaf:	01 d0                	add    %edx,%eax
    aab1:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    aab5:	66 c1 ea 08          	shr    $0x8,%dx
    aab9:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    aabb:	8b 45 0c             	mov    0xc(%ebp),%eax
    aabe:	c1 e0 03             	shl    $0x3,%eax
    aac1:	8d 50 05             	lea    0x5(%eax),%edx
    aac4:	8b 45 08             	mov    0x8(%ebp),%eax
    aac7:	01 d0                	add    %edx,%eax
    aac9:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    aacd:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    aacf:	8b 45 0c             	mov    0xc(%ebp),%eax
    aad2:	c1 e0 03             	shl    $0x3,%eax
    aad5:	8d 50 06             	lea    0x6(%eax),%edx
    aad8:	8b 45 08             	mov    0x8(%ebp),%eax
    aadb:	01 d0                	add    %edx,%eax
    aadd:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    aae1:	66 c1 ea 08          	shr    $0x8,%dx
    aae5:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    aae7:	8b 45 0c             	mov    0xc(%ebp),%eax
    aaea:	c1 e0 03             	shl    $0x3,%eax
    aaed:	8d 50 07             	lea    0x7(%eax),%edx
    aaf0:	8b 45 08             	mov    0x8(%ebp),%eax
    aaf3:	01 d0                	add    %edx,%eax
    aaf5:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    aaf9:	88 10                	mov    %dl,(%eax)
  }
}
    aafb:	90                   	nop
    aafc:	83 c4 20             	add    $0x20,%esp
    aaff:	5b                   	pop    %ebx
    ab00:	5d                   	pop    %ebp
    ab01:	c3                   	ret    

0000ab02 <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    ab02:	55                   	push   %ebp
    ab03:	89 e5                	mov    %esp,%ebp
    ab05:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    ab08:	8b 45 20             	mov    0x20(%ebp),%eax
    ab0b:	8b 00                	mov    (%eax),%eax
    ab0d:	85 c0                	test   %eax,%eax
    ab0f:	0f 85 8c 01 00 00    	jne    aca1 <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    ab15:	8b 45 20             	mov    0x20(%ebp),%eax
    ab18:	8b 40 04             	mov    0x4(%eax),%eax
    ab1b:	83 f8 08             	cmp    $0x8,%eax
    ab1e:	75 59                	jne    ab79 <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    ab20:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ab23:	8b 45 18             	mov    0x18(%ebp),%eax
    ab26:	01 d0                	add    %edx,%eax
    ab28:	0f b6 10             	movzbl (%eax),%edx
    ab2b:	8b 45 10             	mov    0x10(%ebp),%eax
    ab2e:	88 10                	mov    %dl,(%eax)
    ab30:	8b 45 10             	mov    0x10(%ebp),%eax
    ab33:	0f b6 10             	movzbl (%eax),%edx
    ab36:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab39:	88 10                	mov    %dl,(%eax)
    ab3b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab3e:	0f b6 10             	movzbl (%eax),%edx
    ab41:	8b 45 08             	mov    0x8(%ebp),%eax
    ab44:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    ab46:	8b 45 20             	mov    0x20(%ebp),%eax
    ab49:	8b 40 10             	mov    0x10(%eax),%eax
    ab4c:	85 c0                	test   %eax,%eax
    ab4e:	74 1e                	je     ab6e <getPixelColorRGBA8+0x6c>
    ab50:	8b 45 08             	mov    0x8(%ebp),%eax
    ab53:	0f b6 00             	movzbl (%eax),%eax
    ab56:	0f b6 d0             	movzbl %al,%edx
    ab59:	8b 45 20             	mov    0x20(%ebp),%eax
    ab5c:	8b 40 14             	mov    0x14(%eax),%eax
    ab5f:	39 c2                	cmp    %eax,%edx
    ab61:	75 0b                	jne    ab6e <getPixelColorRGBA8+0x6c>
    ab63:	8b 45 14             	mov    0x14(%ebp),%eax
    ab66:	c6 00 00             	movb   $0x0,(%eax)
    ab69:	e9 5e 05 00 00       	jmp    b0cc <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    ab6e:	8b 45 14             	mov    0x14(%ebp),%eax
    ab71:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ab74:	e9 53 05 00 00       	jmp    b0cc <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    ab79:	8b 45 20             	mov    0x20(%ebp),%eax
    ab7c:	8b 40 04             	mov    0x4(%eax),%eax
    ab7f:	83 f8 10             	cmp    $0x10,%eax
    ab82:	0f 85 80 00 00 00    	jne    ac08 <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    ab88:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab8b:	01 c0                	add    %eax,%eax
    ab8d:	89 c2                	mov    %eax,%edx
    ab8f:	8b 45 18             	mov    0x18(%ebp),%eax
    ab92:	01 d0                	add    %edx,%eax
    ab94:	0f b6 10             	movzbl (%eax),%edx
    ab97:	8b 45 10             	mov    0x10(%ebp),%eax
    ab9a:	88 10                	mov    %dl,(%eax)
    ab9c:	8b 45 10             	mov    0x10(%ebp),%eax
    ab9f:	0f b6 10             	movzbl (%eax),%edx
    aba2:	8b 45 0c             	mov    0xc(%ebp),%eax
    aba5:	88 10                	mov    %dl,(%eax)
    aba7:	8b 45 0c             	mov    0xc(%ebp),%eax
    abaa:	0f b6 10             	movzbl (%eax),%edx
    abad:	8b 45 08             	mov    0x8(%ebp),%eax
    abb0:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    abb2:	8b 45 20             	mov    0x20(%ebp),%eax
    abb5:	8b 40 10             	mov    0x10(%eax),%eax
    abb8:	85 c0                	test   %eax,%eax
    abba:	74 41                	je     abfd <getPixelColorRGBA8+0xfb>
    abbc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    abbf:	01 c0                	add    %eax,%eax
    abc1:	89 c2                	mov    %eax,%edx
    abc3:	8b 45 18             	mov    0x18(%ebp),%eax
    abc6:	01 d0                	add    %edx,%eax
    abc8:	0f b6 00             	movzbl (%eax),%eax
    abcb:	0f b6 c0             	movzbl %al,%eax
    abce:	c1 e0 08             	shl    $0x8,%eax
    abd1:	89 c2                	mov    %eax,%edx
    abd3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    abd6:	01 c0                	add    %eax,%eax
    abd8:	8d 48 01             	lea    0x1(%eax),%ecx
    abdb:	8b 45 18             	mov    0x18(%ebp),%eax
    abde:	01 c8                	add    %ecx,%eax
    abe0:	0f b6 00             	movzbl (%eax),%eax
    abe3:	0f b6 c0             	movzbl %al,%eax
    abe6:	01 c2                	add    %eax,%edx
    abe8:	8b 45 20             	mov    0x20(%ebp),%eax
    abeb:	8b 40 14             	mov    0x14(%eax),%eax
    abee:	39 c2                	cmp    %eax,%edx
    abf0:	75 0b                	jne    abfd <getPixelColorRGBA8+0xfb>
    abf2:	8b 45 14             	mov    0x14(%ebp),%eax
    abf5:	c6 00 00             	movb   $0x0,(%eax)
    abf8:	e9 cf 04 00 00       	jmp    b0cc <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    abfd:	8b 45 14             	mov    0x14(%ebp),%eax
    ac00:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ac03:	e9 c4 04 00 00       	jmp    b0cc <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    ac08:	8b 45 20             	mov    0x20(%ebp),%eax
    ac0b:	8b 40 04             	mov    0x4(%eax),%eax
    ac0e:	ba 01 00 00 00       	mov    $0x1,%edx
    ac13:	89 c1                	mov    %eax,%ecx
    ac15:	d3 e2                	shl    %cl,%edx
    ac17:	89 d0                	mov    %edx,%eax
    ac19:	83 e8 01             	sub    $0x1,%eax
    ac1c:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    ac1f:	8b 45 20             	mov    0x20(%ebp),%eax
    ac22:	8b 50 04             	mov    0x4(%eax),%edx
    ac25:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ac28:	0f af c2             	imul   %edx,%eax
    ac2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ac2e:	8b 45 20             	mov    0x20(%ebp),%eax
    ac31:	8b 40 04             	mov    0x4(%eax),%eax
    ac34:	50                   	push   %eax
    ac35:	ff 75 18             	pushl  0x18(%ebp)
    ac38:	8d 45 f0             	lea    -0x10(%ebp),%eax
    ac3b:	50                   	push   %eax
    ac3c:	e8 06 db ff ff       	call   8747 <readBitsFromReversedStream>
    ac41:	83 c4 0c             	add    $0xc,%esp
    ac44:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    ac47:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ac4a:	89 d0                	mov    %edx,%eax
    ac4c:	c1 e0 08             	shl    $0x8,%eax
    ac4f:	29 d0                	sub    %edx,%eax
    ac51:	ba 00 00 00 00       	mov    $0x0,%edx
    ac56:	f7 75 f8             	divl   -0x8(%ebp)
    ac59:	89 c2                	mov    %eax,%edx
    ac5b:	8b 45 10             	mov    0x10(%ebp),%eax
    ac5e:	88 10                	mov    %dl,(%eax)
    ac60:	8b 45 10             	mov    0x10(%ebp),%eax
    ac63:	0f b6 10             	movzbl (%eax),%edx
    ac66:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac69:	88 10                	mov    %dl,(%eax)
    ac6b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac6e:	0f b6 10             	movzbl (%eax),%edx
    ac71:	8b 45 08             	mov    0x8(%ebp),%eax
    ac74:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    ac76:	8b 45 20             	mov    0x20(%ebp),%eax
    ac79:	8b 40 10             	mov    0x10(%eax),%eax
    ac7c:	85 c0                	test   %eax,%eax
    ac7e:	74 16                	je     ac96 <getPixelColorRGBA8+0x194>
    ac80:	8b 45 20             	mov    0x20(%ebp),%eax
    ac83:	8b 40 14             	mov    0x14(%eax),%eax
    ac86:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    ac89:	75 0b                	jne    ac96 <getPixelColorRGBA8+0x194>
    ac8b:	8b 45 14             	mov    0x14(%ebp),%eax
    ac8e:	c6 00 00             	movb   $0x0,(%eax)
    ac91:	e9 36 04 00 00       	jmp    b0cc <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    ac96:	8b 45 14             	mov    0x14(%ebp),%eax
    ac99:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ac9c:	e9 2b 04 00 00       	jmp    b0cc <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    aca1:	8b 45 20             	mov    0x20(%ebp),%eax
    aca4:	8b 00                	mov    (%eax),%eax
    aca6:	83 f8 02             	cmp    $0x2,%eax
    aca9:	0f 85 f5 01 00 00    	jne    aea4 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    acaf:	8b 45 20             	mov    0x20(%ebp),%eax
    acb2:	8b 40 04             	mov    0x4(%eax),%eax
    acb5:	83 f8 08             	cmp    $0x8,%eax
    acb8:	0f 85 a3 00 00 00    	jne    ad61 <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    acbe:	8b 55 1c             	mov    0x1c(%ebp),%edx
    acc1:	89 d0                	mov    %edx,%eax
    acc3:	01 c0                	add    %eax,%eax
    acc5:	01 d0                	add    %edx,%eax
    acc7:	89 c2                	mov    %eax,%edx
    acc9:	8b 45 18             	mov    0x18(%ebp),%eax
    accc:	01 d0                	add    %edx,%eax
    acce:	0f b6 10             	movzbl (%eax),%edx
    acd1:	8b 45 08             	mov    0x8(%ebp),%eax
    acd4:	88 10                	mov    %dl,(%eax)
    acd6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    acd9:	89 d0                	mov    %edx,%eax
    acdb:	01 c0                	add    %eax,%eax
    acdd:	01 d0                	add    %edx,%eax
    acdf:	8d 50 01             	lea    0x1(%eax),%edx
    ace2:	8b 45 18             	mov    0x18(%ebp),%eax
    ace5:	01 d0                	add    %edx,%eax
    ace7:	0f b6 10             	movzbl (%eax),%edx
    acea:	8b 45 0c             	mov    0xc(%ebp),%eax
    aced:	88 10                	mov    %dl,(%eax)
    acef:	8b 55 1c             	mov    0x1c(%ebp),%edx
    acf2:	89 d0                	mov    %edx,%eax
    acf4:	01 c0                	add    %eax,%eax
    acf6:	01 d0                	add    %edx,%eax
    acf8:	8d 50 02             	lea    0x2(%eax),%edx
    acfb:	8b 45 18             	mov    0x18(%ebp),%eax
    acfe:	01 d0                	add    %edx,%eax
    ad00:	0f b6 10             	movzbl (%eax),%edx
    ad03:	8b 45 10             	mov    0x10(%ebp),%eax
    ad06:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    ad08:	8b 45 20             	mov    0x20(%ebp),%eax
    ad0b:	8b 40 10             	mov    0x10(%eax),%eax
    ad0e:	85 c0                	test   %eax,%eax
    ad10:	74 44                	je     ad56 <getPixelColorRGBA8+0x254>
    ad12:	8b 45 08             	mov    0x8(%ebp),%eax
    ad15:	0f b6 00             	movzbl (%eax),%eax
    ad18:	0f b6 d0             	movzbl %al,%edx
    ad1b:	8b 45 20             	mov    0x20(%ebp),%eax
    ad1e:	8b 40 14             	mov    0x14(%eax),%eax
    ad21:	39 c2                	cmp    %eax,%edx
    ad23:	75 31                	jne    ad56 <getPixelColorRGBA8+0x254>
    ad25:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad28:	0f b6 00             	movzbl (%eax),%eax
    ad2b:	0f b6 d0             	movzbl %al,%edx
    ad2e:	8b 45 20             	mov    0x20(%ebp),%eax
    ad31:	8b 40 18             	mov    0x18(%eax),%eax
    ad34:	39 c2                	cmp    %eax,%edx
    ad36:	75 1e                	jne    ad56 <getPixelColorRGBA8+0x254>
    ad38:	8b 45 10             	mov    0x10(%ebp),%eax
    ad3b:	0f b6 00             	movzbl (%eax),%eax
    ad3e:	0f b6 d0             	movzbl %al,%edx
    ad41:	8b 45 20             	mov    0x20(%ebp),%eax
    ad44:	8b 40 1c             	mov    0x1c(%eax),%eax
    ad47:	39 c2                	cmp    %eax,%edx
    ad49:	75 0b                	jne    ad56 <getPixelColorRGBA8+0x254>
    ad4b:	8b 45 14             	mov    0x14(%ebp),%eax
    ad4e:	c6 00 00             	movb   $0x0,(%eax)
    ad51:	e9 76 03 00 00       	jmp    b0cc <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    ad56:	8b 45 14             	mov    0x14(%ebp),%eax
    ad59:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ad5c:	e9 6b 03 00 00       	jmp    b0cc <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    ad61:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ad64:	89 d0                	mov    %edx,%eax
    ad66:	01 c0                	add    %eax,%eax
    ad68:	01 d0                	add    %edx,%eax
    ad6a:	01 c0                	add    %eax,%eax
    ad6c:	89 c2                	mov    %eax,%edx
    ad6e:	8b 45 18             	mov    0x18(%ebp),%eax
    ad71:	01 d0                	add    %edx,%eax
    ad73:	0f b6 10             	movzbl (%eax),%edx
    ad76:	8b 45 08             	mov    0x8(%ebp),%eax
    ad79:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    ad7b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ad7e:	89 d0                	mov    %edx,%eax
    ad80:	01 c0                	add    %eax,%eax
    ad82:	01 d0                	add    %edx,%eax
    ad84:	01 c0                	add    %eax,%eax
    ad86:	8d 50 02             	lea    0x2(%eax),%edx
    ad89:	8b 45 18             	mov    0x18(%ebp),%eax
    ad8c:	01 d0                	add    %edx,%eax
    ad8e:	0f b6 10             	movzbl (%eax),%edx
    ad91:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad94:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    ad96:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ad99:	89 d0                	mov    %edx,%eax
    ad9b:	01 c0                	add    %eax,%eax
    ad9d:	01 d0                	add    %edx,%eax
    ad9f:	01 c0                	add    %eax,%eax
    ada1:	8d 50 04             	lea    0x4(%eax),%edx
    ada4:	8b 45 18             	mov    0x18(%ebp),%eax
    ada7:	01 d0                	add    %edx,%eax
    ada9:	0f b6 10             	movzbl (%eax),%edx
    adac:	8b 45 10             	mov    0x10(%ebp),%eax
    adaf:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    adb1:	8b 45 20             	mov    0x20(%ebp),%eax
    adb4:	8b 40 10             	mov    0x10(%eax),%eax
    adb7:	85 c0                	test   %eax,%eax
    adb9:	0f 84 da 00 00 00    	je     ae99 <getPixelColorRGBA8+0x397>
    adbf:	8b 55 1c             	mov    0x1c(%ebp),%edx
    adc2:	89 d0                	mov    %edx,%eax
    adc4:	01 c0                	add    %eax,%eax
    adc6:	01 d0                	add    %edx,%eax
    adc8:	01 c0                	add    %eax,%eax
    adca:	89 c2                	mov    %eax,%edx
    adcc:	8b 45 18             	mov    0x18(%ebp),%eax
    adcf:	01 d0                	add    %edx,%eax
    add1:	0f b6 00             	movzbl (%eax),%eax
    add4:	0f b6 c0             	movzbl %al,%eax
    add7:	c1 e0 08             	shl    $0x8,%eax
    adda:	89 c1                	mov    %eax,%ecx
    addc:	8b 55 1c             	mov    0x1c(%ebp),%edx
    addf:	89 d0                	mov    %edx,%eax
    ade1:	01 c0                	add    %eax,%eax
    ade3:	01 d0                	add    %edx,%eax
    ade5:	01 c0                	add    %eax,%eax
    ade7:	8d 50 01             	lea    0x1(%eax),%edx
    adea:	8b 45 18             	mov    0x18(%ebp),%eax
    aded:	01 d0                	add    %edx,%eax
    adef:	0f b6 00             	movzbl (%eax),%eax
    adf2:	0f b6 c0             	movzbl %al,%eax
    adf5:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    adf8:	8b 45 20             	mov    0x20(%ebp),%eax
    adfb:	8b 40 14             	mov    0x14(%eax),%eax
    adfe:	39 c2                	cmp    %eax,%edx
    ae00:	0f 85 93 00 00 00    	jne    ae99 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    ae06:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ae09:	89 d0                	mov    %edx,%eax
    ae0b:	01 c0                	add    %eax,%eax
    ae0d:	01 d0                	add    %edx,%eax
    ae0f:	01 c0                	add    %eax,%eax
    ae11:	8d 50 02             	lea    0x2(%eax),%edx
    ae14:	8b 45 18             	mov    0x18(%ebp),%eax
    ae17:	01 d0                	add    %edx,%eax
    ae19:	0f b6 00             	movzbl (%eax),%eax
    ae1c:	0f b6 c0             	movzbl %al,%eax
    ae1f:	c1 e0 08             	shl    $0x8,%eax
    ae22:	89 c1                	mov    %eax,%ecx
    ae24:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ae27:	89 d0                	mov    %edx,%eax
    ae29:	01 c0                	add    %eax,%eax
    ae2b:	01 d0                	add    %edx,%eax
    ae2d:	01 c0                	add    %eax,%eax
    ae2f:	8d 50 03             	lea    0x3(%eax),%edx
    ae32:	8b 45 18             	mov    0x18(%ebp),%eax
    ae35:	01 d0                	add    %edx,%eax
    ae37:	0f b6 00             	movzbl (%eax),%eax
    ae3a:	0f b6 c0             	movzbl %al,%eax
    ae3d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ae40:	8b 45 20             	mov    0x20(%ebp),%eax
    ae43:	8b 40 18             	mov    0x18(%eax),%eax
    ae46:	39 c2                	cmp    %eax,%edx
    ae48:	75 4f                	jne    ae99 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    ae4a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ae4d:	89 d0                	mov    %edx,%eax
    ae4f:	01 c0                	add    %eax,%eax
    ae51:	01 d0                	add    %edx,%eax
    ae53:	01 c0                	add    %eax,%eax
    ae55:	8d 50 04             	lea    0x4(%eax),%edx
    ae58:	8b 45 18             	mov    0x18(%ebp),%eax
    ae5b:	01 d0                	add    %edx,%eax
    ae5d:	0f b6 00             	movzbl (%eax),%eax
    ae60:	0f b6 c0             	movzbl %al,%eax
    ae63:	c1 e0 08             	shl    $0x8,%eax
    ae66:	89 c1                	mov    %eax,%ecx
    ae68:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ae6b:	89 d0                	mov    %edx,%eax
    ae6d:	01 c0                	add    %eax,%eax
    ae6f:	01 d0                	add    %edx,%eax
    ae71:	01 c0                	add    %eax,%eax
    ae73:	8d 50 05             	lea    0x5(%eax),%edx
    ae76:	8b 45 18             	mov    0x18(%ebp),%eax
    ae79:	01 d0                	add    %edx,%eax
    ae7b:	0f b6 00             	movzbl (%eax),%eax
    ae7e:	0f b6 c0             	movzbl %al,%eax
    ae81:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ae84:	8b 45 20             	mov    0x20(%ebp),%eax
    ae87:	8b 40 1c             	mov    0x1c(%eax),%eax
    ae8a:	39 c2                	cmp    %eax,%edx
    ae8c:	75 0b                	jne    ae99 <getPixelColorRGBA8+0x397>
    ae8e:	8b 45 14             	mov    0x14(%ebp),%eax
    ae91:	c6 00 00             	movb   $0x0,(%eax)
    ae94:	e9 33 02 00 00       	jmp    b0cc <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    ae99:	8b 45 14             	mov    0x14(%ebp),%eax
    ae9c:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ae9f:	e9 28 02 00 00       	jmp    b0cc <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    aea4:	8b 45 20             	mov    0x20(%ebp),%eax
    aea7:	8b 00                	mov    (%eax),%eax
    aea9:	83 f8 03             	cmp    $0x3,%eax
    aeac:	0f 85 ac 00 00 00    	jne    af5e <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    aeb2:	8b 45 20             	mov    0x20(%ebp),%eax
    aeb5:	8b 40 04             	mov    0x4(%eax),%eax
    aeb8:	83 f8 08             	cmp    $0x8,%eax
    aebb:	75 13                	jne    aed0 <getPixelColorRGBA8+0x3ce>
    aebd:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aec0:	8b 45 18             	mov    0x18(%ebp),%eax
    aec3:	01 d0                	add    %edx,%eax
    aec5:	0f b6 00             	movzbl (%eax),%eax
    aec8:	0f b6 c0             	movzbl %al,%eax
    aecb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    aece:	eb 28                	jmp    aef8 <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    aed0:	8b 45 20             	mov    0x20(%ebp),%eax
    aed3:	8b 50 04             	mov    0x4(%eax),%edx
    aed6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aed9:	0f af c2             	imul   %edx,%eax
    aedc:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    aedf:	8b 45 20             	mov    0x20(%ebp),%eax
    aee2:	8b 40 04             	mov    0x4(%eax),%eax
    aee5:	50                   	push   %eax
    aee6:	ff 75 18             	pushl  0x18(%ebp)
    aee9:	8d 45 ec             	lea    -0x14(%ebp),%eax
    aeec:	50                   	push   %eax
    aeed:	e8 55 d8 ff ff       	call   8747 <readBitsFromReversedStream>
    aef2:	83 c4 0c             	add    $0xc,%esp
    aef5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    aef8:	8b 45 20             	mov    0x20(%ebp),%eax
    aefb:	8b 40 08             	mov    0x8(%eax),%eax
    aefe:	8b 55 fc             	mov    -0x4(%ebp),%edx
    af01:	c1 e2 02             	shl    $0x2,%edx
    af04:	01 d0                	add    %edx,%eax
    af06:	0f b6 10             	movzbl (%eax),%edx
    af09:	8b 45 08             	mov    0x8(%ebp),%eax
    af0c:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    af0e:	8b 45 20             	mov    0x20(%ebp),%eax
    af11:	8b 40 08             	mov    0x8(%eax),%eax
    af14:	8b 55 fc             	mov    -0x4(%ebp),%edx
    af17:	c1 e2 02             	shl    $0x2,%edx
    af1a:	83 c2 01             	add    $0x1,%edx
    af1d:	01 d0                	add    %edx,%eax
    af1f:	0f b6 10             	movzbl (%eax),%edx
    af22:	8b 45 0c             	mov    0xc(%ebp),%eax
    af25:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    af27:	8b 45 20             	mov    0x20(%ebp),%eax
    af2a:	8b 40 08             	mov    0x8(%eax),%eax
    af2d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    af30:	c1 e2 02             	shl    $0x2,%edx
    af33:	83 c2 02             	add    $0x2,%edx
    af36:	01 d0                	add    %edx,%eax
    af38:	0f b6 10             	movzbl (%eax),%edx
    af3b:	8b 45 10             	mov    0x10(%ebp),%eax
    af3e:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    af40:	8b 45 20             	mov    0x20(%ebp),%eax
    af43:	8b 40 08             	mov    0x8(%eax),%eax
    af46:	8b 55 fc             	mov    -0x4(%ebp),%edx
    af49:	c1 e2 02             	shl    $0x2,%edx
    af4c:	83 c2 03             	add    $0x3,%edx
    af4f:	01 d0                	add    %edx,%eax
    af51:	0f b6 10             	movzbl (%eax),%edx
    af54:	8b 45 14             	mov    0x14(%ebp),%eax
    af57:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    af59:	e9 6e 01 00 00       	jmp    b0cc <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    af5e:	8b 45 20             	mov    0x20(%ebp),%eax
    af61:	8b 00                	mov    (%eax),%eax
    af63:	83 f8 04             	cmp    $0x4,%eax
    af66:	0f 85 95 00 00 00    	jne    b001 <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    af6c:	8b 45 20             	mov    0x20(%ebp),%eax
    af6f:	8b 40 04             	mov    0x4(%eax),%eax
    af72:	83 f8 08             	cmp    $0x8,%eax
    af75:	75 44                	jne    afbb <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    af77:	8b 45 1c             	mov    0x1c(%ebp),%eax
    af7a:	01 c0                	add    %eax,%eax
    af7c:	89 c2                	mov    %eax,%edx
    af7e:	8b 45 18             	mov    0x18(%ebp),%eax
    af81:	01 d0                	add    %edx,%eax
    af83:	0f b6 10             	movzbl (%eax),%edx
    af86:	8b 45 10             	mov    0x10(%ebp),%eax
    af89:	88 10                	mov    %dl,(%eax)
    af8b:	8b 45 10             	mov    0x10(%ebp),%eax
    af8e:	0f b6 10             	movzbl (%eax),%edx
    af91:	8b 45 0c             	mov    0xc(%ebp),%eax
    af94:	88 10                	mov    %dl,(%eax)
    af96:	8b 45 0c             	mov    0xc(%ebp),%eax
    af99:	0f b6 10             	movzbl (%eax),%edx
    af9c:	8b 45 08             	mov    0x8(%ebp),%eax
    af9f:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    afa1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    afa4:	01 c0                	add    %eax,%eax
    afa6:	8d 50 01             	lea    0x1(%eax),%edx
    afa9:	8b 45 18             	mov    0x18(%ebp),%eax
    afac:	01 d0                	add    %edx,%eax
    afae:	0f b6 10             	movzbl (%eax),%edx
    afb1:	8b 45 14             	mov    0x14(%ebp),%eax
    afb4:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    afb6:	e9 11 01 00 00       	jmp    b0cc <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    afbb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    afbe:	c1 e0 02             	shl    $0x2,%eax
    afc1:	89 c2                	mov    %eax,%edx
    afc3:	8b 45 18             	mov    0x18(%ebp),%eax
    afc6:	01 d0                	add    %edx,%eax
    afc8:	0f b6 10             	movzbl (%eax),%edx
    afcb:	8b 45 10             	mov    0x10(%ebp),%eax
    afce:	88 10                	mov    %dl,(%eax)
    afd0:	8b 45 10             	mov    0x10(%ebp),%eax
    afd3:	0f b6 10             	movzbl (%eax),%edx
    afd6:	8b 45 0c             	mov    0xc(%ebp),%eax
    afd9:	88 10                	mov    %dl,(%eax)
    afdb:	8b 45 0c             	mov    0xc(%ebp),%eax
    afde:	0f b6 10             	movzbl (%eax),%edx
    afe1:	8b 45 08             	mov    0x8(%ebp),%eax
    afe4:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    afe6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    afe9:	c1 e0 02             	shl    $0x2,%eax
    afec:	8d 50 02             	lea    0x2(%eax),%edx
    afef:	8b 45 18             	mov    0x18(%ebp),%eax
    aff2:	01 d0                	add    %edx,%eax
    aff4:	0f b6 10             	movzbl (%eax),%edx
    aff7:	8b 45 14             	mov    0x14(%ebp),%eax
    affa:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    affc:	e9 cb 00 00 00       	jmp    b0cc <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    b001:	8b 45 20             	mov    0x20(%ebp),%eax
    b004:	8b 00                	mov    (%eax),%eax
    b006:	83 f8 06             	cmp    $0x6,%eax
    b009:	0f 85 bd 00 00 00    	jne    b0cc <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    b00f:	8b 45 20             	mov    0x20(%ebp),%eax
    b012:	8b 40 04             	mov    0x4(%eax),%eax
    b015:	83 f8 08             	cmp    $0x8,%eax
    b018:	75 59                	jne    b073 <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    b01a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b01d:	c1 e0 02             	shl    $0x2,%eax
    b020:	89 c2                	mov    %eax,%edx
    b022:	8b 45 18             	mov    0x18(%ebp),%eax
    b025:	01 d0                	add    %edx,%eax
    b027:	0f b6 10             	movzbl (%eax),%edx
    b02a:	8b 45 08             	mov    0x8(%ebp),%eax
    b02d:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    b02f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b032:	c1 e0 02             	shl    $0x2,%eax
    b035:	8d 50 01             	lea    0x1(%eax),%edx
    b038:	8b 45 18             	mov    0x18(%ebp),%eax
    b03b:	01 d0                	add    %edx,%eax
    b03d:	0f b6 10             	movzbl (%eax),%edx
    b040:	8b 45 0c             	mov    0xc(%ebp),%eax
    b043:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    b045:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b048:	c1 e0 02             	shl    $0x2,%eax
    b04b:	8d 50 02             	lea    0x2(%eax),%edx
    b04e:	8b 45 18             	mov    0x18(%ebp),%eax
    b051:	01 d0                	add    %edx,%eax
    b053:	0f b6 10             	movzbl (%eax),%edx
    b056:	8b 45 10             	mov    0x10(%ebp),%eax
    b059:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    b05b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b05e:	c1 e0 02             	shl    $0x2,%eax
    b061:	8d 50 03             	lea    0x3(%eax),%edx
    b064:	8b 45 18             	mov    0x18(%ebp),%eax
    b067:	01 d0                	add    %edx,%eax
    b069:	0f b6 10             	movzbl (%eax),%edx
    b06c:	8b 45 14             	mov    0x14(%ebp),%eax
    b06f:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b071:	eb 59                	jmp    b0cc <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    b073:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b076:	c1 e0 03             	shl    $0x3,%eax
    b079:	89 c2                	mov    %eax,%edx
    b07b:	8b 45 18             	mov    0x18(%ebp),%eax
    b07e:	01 d0                	add    %edx,%eax
    b080:	0f b6 10             	movzbl (%eax),%edx
    b083:	8b 45 08             	mov    0x8(%ebp),%eax
    b086:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    b088:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b08b:	c1 e0 03             	shl    $0x3,%eax
    b08e:	8d 50 02             	lea    0x2(%eax),%edx
    b091:	8b 45 18             	mov    0x18(%ebp),%eax
    b094:	01 d0                	add    %edx,%eax
    b096:	0f b6 10             	movzbl (%eax),%edx
    b099:	8b 45 0c             	mov    0xc(%ebp),%eax
    b09c:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    b09e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b0a1:	c1 e0 03             	shl    $0x3,%eax
    b0a4:	8d 50 04             	lea    0x4(%eax),%edx
    b0a7:	8b 45 18             	mov    0x18(%ebp),%eax
    b0aa:	01 d0                	add    %edx,%eax
    b0ac:	0f b6 10             	movzbl (%eax),%edx
    b0af:	8b 45 10             	mov    0x10(%ebp),%eax
    b0b2:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    b0b4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b0b7:	c1 e0 03             	shl    $0x3,%eax
    b0ba:	8d 50 06             	lea    0x6(%eax),%edx
    b0bd:	8b 45 18             	mov    0x18(%ebp),%eax
    b0c0:	01 d0                	add    %edx,%eax
    b0c2:	0f b6 10             	movzbl (%eax),%edx
    b0c5:	8b 45 14             	mov    0x14(%ebp),%eax
    b0c8:	88 10                	mov    %dl,(%eax)
    }
  }
}
    b0ca:	eb 00                	jmp    b0cc <getPixelColorRGBA8+0x5ca>
    b0cc:	90                   	nop
    b0cd:	c9                   	leave  
    b0ce:	c3                   	ret    

0000b0cf <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    b0cf:	55                   	push   %ebp
    b0d0:	89 e5                	mov    %esp,%ebp
    b0d2:	53                   	push   %ebx
    b0d3:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    b0d6:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b0dd:	8b 45 14             	mov    0x14(%ebp),%eax
    b0e0:	8b 00                	mov    (%eax),%eax
    b0e2:	85 c0                	test   %eax,%eax
    b0e4:	0f 85 14 02 00 00    	jne    b2fe <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    b0ea:	8b 45 14             	mov    0x14(%ebp),%eax
    b0ed:	8b 40 04             	mov    0x4(%eax),%eax
    b0f0:	83 f8 08             	cmp    $0x8,%eax
    b0f3:	0f 85 a0 00 00 00    	jne    b199 <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0f9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b100:	eb 39                	jmp    b13b <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b102:	8b 45 08             	mov    0x8(%ebp),%eax
    b105:	83 c0 01             	add    $0x1,%eax
    b108:	8b 55 08             	mov    0x8(%ebp),%edx
    b10b:	83 c2 02             	add    $0x2,%edx
    b10e:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b111:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b114:	01 d9                	add    %ebx,%ecx
    b116:	0f b6 09             	movzbl (%ecx),%ecx
    b119:	88 0a                	mov    %cl,(%edx)
    b11b:	0f b6 12             	movzbl (%edx),%edx
    b11e:	88 10                	mov    %dl,(%eax)
    b120:	0f b6 10             	movzbl (%eax),%edx
    b123:	8b 45 08             	mov    0x8(%ebp),%eax
    b126:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    b128:	8b 45 08             	mov    0x8(%ebp),%eax
    b12b:	83 c0 03             	add    $0x3,%eax
    b12e:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b131:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b135:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b138:	01 45 08             	add    %eax,0x8(%ebp)
    b13b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b13e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b141:	75 bf                	jne    b102 <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    b143:	8b 45 14             	mov    0x14(%ebp),%eax
    b146:	8b 40 10             	mov    0x10(%eax),%eax
    b149:	85 c0                	test   %eax,%eax
    b14b:	0f 84 48 06 00 00    	je     b799 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    b151:	8b 45 0c             	mov    0xc(%ebp),%eax
    b154:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    b158:	f7 d8                	neg    %eax
    b15a:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b15d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b164:	eb 26                	jmp    b18c <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    b166:	8b 45 08             	mov    0x8(%ebp),%eax
    b169:	0f b6 00             	movzbl (%eax),%eax
    b16c:	0f b6 d0             	movzbl %al,%edx
    b16f:	8b 45 14             	mov    0x14(%ebp),%eax
    b172:	8b 40 14             	mov    0x14(%eax),%eax
    b175:	39 c2                	cmp    %eax,%edx
    b177:	75 09                	jne    b182 <getPixelColorsRGBA8+0xb3>
    b179:	8b 45 08             	mov    0x8(%ebp),%eax
    b17c:	83 c0 03             	add    $0x3,%eax
    b17f:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b182:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b186:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b189:	01 45 08             	add    %eax,0x8(%ebp)
    b18c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b18f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b192:	75 d2                	jne    b166 <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b194:	e9 00 06 00 00       	jmp    b799 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    b199:	8b 45 14             	mov    0x14(%ebp),%eax
    b19c:	8b 40 04             	mov    0x4(%eax),%eax
    b19f:	83 f8 10             	cmp    $0x10,%eax
    b1a2:	0f 85 a5 00 00 00    	jne    b24d <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1a8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b1af:	e9 88 00 00 00       	jmp    b23c <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b1b4:	8b 45 08             	mov    0x8(%ebp),%eax
    b1b7:	83 c0 01             	add    $0x1,%eax
    b1ba:	8b 55 08             	mov    0x8(%ebp),%edx
    b1bd:	83 c2 02             	add    $0x2,%edx
    b1c0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b1c3:	01 c9                	add    %ecx,%ecx
    b1c5:	89 cb                	mov    %ecx,%ebx
    b1c7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b1ca:	01 d9                	add    %ebx,%ecx
    b1cc:	0f b6 09             	movzbl (%ecx),%ecx
    b1cf:	88 0a                	mov    %cl,(%edx)
    b1d1:	0f b6 12             	movzbl (%edx),%edx
    b1d4:	88 10                	mov    %dl,(%eax)
    b1d6:	0f b6 10             	movzbl (%eax),%edx
    b1d9:	8b 45 08             	mov    0x8(%ebp),%eax
    b1dc:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    b1de:	8b 45 08             	mov    0x8(%ebp),%eax
    b1e1:	8d 50 03             	lea    0x3(%eax),%edx
    b1e4:	8b 45 14             	mov    0x14(%ebp),%eax
    b1e7:	8b 40 10             	mov    0x10(%eax),%eax
    b1ea:	85 c0                	test   %eax,%eax
    b1ec:	74 3d                	je     b22b <getPixelColorsRGBA8+0x15c>
    b1ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1f1:	01 c0                	add    %eax,%eax
    b1f3:	89 c1                	mov    %eax,%ecx
    b1f5:	8b 45 10             	mov    0x10(%ebp),%eax
    b1f8:	01 c8                	add    %ecx,%eax
    b1fa:	0f b6 00             	movzbl (%eax),%eax
    b1fd:	0f b6 c0             	movzbl %al,%eax
    b200:	c1 e0 08             	shl    $0x8,%eax
    b203:	89 c1                	mov    %eax,%ecx
    b205:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b208:	01 c0                	add    %eax,%eax
    b20a:	8d 58 01             	lea    0x1(%eax),%ebx
    b20d:	8b 45 10             	mov    0x10(%ebp),%eax
    b210:	01 d8                	add    %ebx,%eax
    b212:	0f b6 00             	movzbl (%eax),%eax
    b215:	0f b6 c0             	movzbl %al,%eax
    b218:	01 c1                	add    %eax,%ecx
    b21a:	8b 45 14             	mov    0x14(%ebp),%eax
    b21d:	8b 40 14             	mov    0x14(%eax),%eax
    b220:	39 c1                	cmp    %eax,%ecx
    b222:	75 07                	jne    b22b <getPixelColorsRGBA8+0x15c>
    b224:	b8 00 00 00 00       	mov    $0x0,%eax
    b229:	eb 05                	jmp    b230 <getPixelColorsRGBA8+0x161>
    b22b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b230:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b232:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b236:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b239:	01 45 08             	add    %eax,0x8(%ebp)
    b23c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b23f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b242:	0f 85 6c ff ff ff    	jne    b1b4 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b248:	e9 4c 05 00 00       	jmp    b799 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b24d:	8b 45 14             	mov    0x14(%ebp),%eax
    b250:	8b 40 04             	mov    0x4(%eax),%eax
    b253:	ba 01 00 00 00       	mov    $0x1,%edx
    b258:	89 c1                	mov    %eax,%ecx
    b25a:	d3 e2                	shl    %cl,%edx
    b25c:	89 d0                	mov    %edx,%eax
    b25e:	83 e8 01             	sub    $0x1,%eax
    b261:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b264:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b26b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b272:	eb 79                	jmp    b2ed <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b274:	8b 45 14             	mov    0x14(%ebp),%eax
    b277:	8b 40 04             	mov    0x4(%eax),%eax
    b27a:	50                   	push   %eax
    b27b:	ff 75 10             	pushl  0x10(%ebp)
    b27e:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b281:	50                   	push   %eax
    b282:	e8 c0 d4 ff ff       	call   8747 <readBitsFromReversedStream>
    b287:	83 c4 0c             	add    $0xc,%esp
    b28a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b28d:	8b 45 08             	mov    0x8(%ebp),%eax
    b290:	8d 48 01             	lea    0x1(%eax),%ecx
    b293:	8b 45 08             	mov    0x8(%ebp),%eax
    b296:	8d 58 02             	lea    0x2(%eax),%ebx
    b299:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b29c:	89 d0                	mov    %edx,%eax
    b29e:	c1 e0 08             	shl    $0x8,%eax
    b2a1:	29 d0                	sub    %edx,%eax
    b2a3:	ba 00 00 00 00       	mov    $0x0,%edx
    b2a8:	f7 75 f0             	divl   -0x10(%ebp)
    b2ab:	88 03                	mov    %al,(%ebx)
    b2ad:	0f b6 03             	movzbl (%ebx),%eax
    b2b0:	88 01                	mov    %al,(%ecx)
    b2b2:	0f b6 11             	movzbl (%ecx),%edx
    b2b5:	8b 45 08             	mov    0x8(%ebp),%eax
    b2b8:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    b2ba:	8b 45 08             	mov    0x8(%ebp),%eax
    b2bd:	8d 50 03             	lea    0x3(%eax),%edx
    b2c0:	8b 45 14             	mov    0x14(%ebp),%eax
    b2c3:	8b 40 10             	mov    0x10(%eax),%eax
    b2c6:	85 c0                	test   %eax,%eax
    b2c8:	74 12                	je     b2dc <getPixelColorsRGBA8+0x20d>
    b2ca:	8b 45 14             	mov    0x14(%ebp),%eax
    b2cd:	8b 40 14             	mov    0x14(%eax),%eax
    b2d0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    b2d3:	75 07                	jne    b2dc <getPixelColorsRGBA8+0x20d>
    b2d5:	b8 00 00 00 00       	mov    $0x0,%eax
    b2da:	eb 05                	jmp    b2e1 <getPixelColorsRGBA8+0x212>
    b2dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b2e1:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2e3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b2e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b2ea:	01 45 08             	add    %eax,0x8(%ebp)
    b2ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2f0:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b2f3:	0f 85 7b ff ff ff    	jne    b274 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b2f9:	e9 9b 04 00 00       	jmp    b799 <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b2fe:	8b 45 14             	mov    0x14(%ebp),%eax
    b301:	8b 00                	mov    (%eax),%eax
    b303:	83 f8 02             	cmp    $0x2,%eax
    b306:	0f 85 41 02 00 00    	jne    b54d <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    b30c:	8b 45 14             	mov    0x14(%ebp),%eax
    b30f:	8b 40 04             	mov    0x4(%eax),%eax
    b312:	83 f8 08             	cmp    $0x8,%eax
    b315:	0f 85 c4 00 00 00    	jne    b3df <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b31b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b322:	eb 31                	jmp    b355 <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    b324:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b327:	89 d0                	mov    %edx,%eax
    b329:	01 c0                	add    %eax,%eax
    b32b:	01 d0                	add    %edx,%eax
    b32d:	89 c2                	mov    %eax,%edx
    b32f:	8b 45 10             	mov    0x10(%ebp),%eax
    b332:	01 d0                	add    %edx,%eax
    b334:	6a 03                	push   $0x3
    b336:	50                   	push   %eax
    b337:	ff 75 08             	pushl  0x8(%ebp)
    b33a:	e8 a3 85 ff ff       	call   38e2 <lodepng_memcpy>
    b33f:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    b342:	8b 45 08             	mov    0x8(%ebp),%eax
    b345:	83 c0 03             	add    $0x3,%eax
    b348:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b34b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b34f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b352:	01 45 08             	add    %eax,0x8(%ebp)
    b355:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b358:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b35b:	75 c7                	jne    b324 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    b35d:	8b 45 14             	mov    0x14(%ebp),%eax
    b360:	8b 40 10             	mov    0x10(%eax),%eax
    b363:	85 c0                	test   %eax,%eax
    b365:	0f 84 2e 04 00 00    	je     b799 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    b36b:	8b 45 0c             	mov    0xc(%ebp),%eax
    b36e:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    b372:	f7 d8                	neg    %eax
    b374:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b377:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b37e:	eb 52                	jmp    b3d2 <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    b380:	8b 45 08             	mov    0x8(%ebp),%eax
    b383:	0f b6 00             	movzbl (%eax),%eax
    b386:	0f b6 d0             	movzbl %al,%edx
    b389:	8b 45 14             	mov    0x14(%ebp),%eax
    b38c:	8b 40 14             	mov    0x14(%eax),%eax
    b38f:	39 c2                	cmp    %eax,%edx
    b391:	75 35                	jne    b3c8 <getPixelColorsRGBA8+0x2f9>
    b393:	8b 45 08             	mov    0x8(%ebp),%eax
    b396:	83 c0 01             	add    $0x1,%eax
    b399:	0f b6 00             	movzbl (%eax),%eax
    b39c:	0f b6 d0             	movzbl %al,%edx
    b39f:	8b 45 14             	mov    0x14(%ebp),%eax
    b3a2:	8b 40 18             	mov    0x18(%eax),%eax
    b3a5:	39 c2                	cmp    %eax,%edx
    b3a7:	75 1f                	jne    b3c8 <getPixelColorsRGBA8+0x2f9>
    b3a9:	8b 45 08             	mov    0x8(%ebp),%eax
    b3ac:	83 c0 02             	add    $0x2,%eax
    b3af:	0f b6 00             	movzbl (%eax),%eax
    b3b2:	0f b6 d0             	movzbl %al,%edx
    b3b5:	8b 45 14             	mov    0x14(%ebp),%eax
    b3b8:	8b 40 1c             	mov    0x1c(%eax),%eax
    b3bb:	39 c2                	cmp    %eax,%edx
    b3bd:	75 09                	jne    b3c8 <getPixelColorsRGBA8+0x2f9>
    b3bf:	8b 45 08             	mov    0x8(%ebp),%eax
    b3c2:	83 c0 03             	add    $0x3,%eax
    b3c5:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3c8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3cf:	01 45 08             	add    %eax,0x8(%ebp)
    b3d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3d5:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b3d8:	75 a6                	jne    b380 <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b3da:	e9 ba 03 00 00       	jmp    b799 <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3df:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b3e6:	e9 51 01 00 00       	jmp    b53c <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    b3eb:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3ee:	89 d0                	mov    %edx,%eax
    b3f0:	01 c0                	add    %eax,%eax
    b3f2:	01 d0                	add    %edx,%eax
    b3f4:	01 c0                	add    %eax,%eax
    b3f6:	89 c2                	mov    %eax,%edx
    b3f8:	8b 45 10             	mov    0x10(%ebp),%eax
    b3fb:	01 d0                	add    %edx,%eax
    b3fd:	0f b6 10             	movzbl (%eax),%edx
    b400:	8b 45 08             	mov    0x8(%ebp),%eax
    b403:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b405:	8b 45 08             	mov    0x8(%ebp),%eax
    b408:	8d 48 01             	lea    0x1(%eax),%ecx
    b40b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b40e:	89 d0                	mov    %edx,%eax
    b410:	01 c0                	add    %eax,%eax
    b412:	01 d0                	add    %edx,%eax
    b414:	01 c0                	add    %eax,%eax
    b416:	8d 50 02             	lea    0x2(%eax),%edx
    b419:	8b 45 10             	mov    0x10(%ebp),%eax
    b41c:	01 d0                	add    %edx,%eax
    b41e:	0f b6 00             	movzbl (%eax),%eax
    b421:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b423:	8b 45 08             	mov    0x8(%ebp),%eax
    b426:	8d 48 02             	lea    0x2(%eax),%ecx
    b429:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b42c:	89 d0                	mov    %edx,%eax
    b42e:	01 c0                	add    %eax,%eax
    b430:	01 d0                	add    %edx,%eax
    b432:	01 c0                	add    %eax,%eax
    b434:	8d 50 04             	lea    0x4(%eax),%edx
    b437:	8b 45 10             	mov    0x10(%ebp),%eax
    b43a:	01 d0                	add    %edx,%eax
    b43c:	0f b6 00             	movzbl (%eax),%eax
    b43f:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    b441:	8b 45 08             	mov    0x8(%ebp),%eax
    b444:	8d 48 03             	lea    0x3(%eax),%ecx
    b447:	8b 45 14             	mov    0x14(%ebp),%eax
    b44a:	8b 40 10             	mov    0x10(%eax),%eax
    b44d:	85 c0                	test   %eax,%eax
    b44f:	0f 84 d6 00 00 00    	je     b52b <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b455:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b458:	89 d0                	mov    %edx,%eax
    b45a:	01 c0                	add    %eax,%eax
    b45c:	01 d0                	add    %edx,%eax
    b45e:	01 c0                	add    %eax,%eax
    b460:	89 c2                	mov    %eax,%edx
    b462:	8b 45 10             	mov    0x10(%ebp),%eax
    b465:	01 d0                	add    %edx,%eax
    b467:	0f b6 00             	movzbl (%eax),%eax
    b46a:	0f b6 c0             	movzbl %al,%eax
    b46d:	c1 e0 08             	shl    $0x8,%eax
    b470:	89 c3                	mov    %eax,%ebx
    b472:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b475:	89 d0                	mov    %edx,%eax
    b477:	01 c0                	add    %eax,%eax
    b479:	01 d0                	add    %edx,%eax
    b47b:	01 c0                	add    %eax,%eax
    b47d:	8d 50 01             	lea    0x1(%eax),%edx
    b480:	8b 45 10             	mov    0x10(%ebp),%eax
    b483:	01 d0                	add    %edx,%eax
    b485:	0f b6 00             	movzbl (%eax),%eax
    b488:	0f b6 c0             	movzbl %al,%eax
    b48b:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b48e:	8b 45 14             	mov    0x14(%ebp),%eax
    b491:	8b 40 14             	mov    0x14(%eax),%eax
    b494:	39 c2                	cmp    %eax,%edx
    b496:	0f 85 8f 00 00 00    	jne    b52b <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b49c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b49f:	89 d0                	mov    %edx,%eax
    b4a1:	01 c0                	add    %eax,%eax
    b4a3:	01 d0                	add    %edx,%eax
    b4a5:	01 c0                	add    %eax,%eax
    b4a7:	8d 50 02             	lea    0x2(%eax),%edx
    b4aa:	8b 45 10             	mov    0x10(%ebp),%eax
    b4ad:	01 d0                	add    %edx,%eax
    b4af:	0f b6 00             	movzbl (%eax),%eax
    b4b2:	0f b6 c0             	movzbl %al,%eax
    b4b5:	c1 e0 08             	shl    $0x8,%eax
    b4b8:	89 c3                	mov    %eax,%ebx
    b4ba:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b4bd:	89 d0                	mov    %edx,%eax
    b4bf:	01 c0                	add    %eax,%eax
    b4c1:	01 d0                	add    %edx,%eax
    b4c3:	01 c0                	add    %eax,%eax
    b4c5:	8d 50 03             	lea    0x3(%eax),%edx
    b4c8:	8b 45 10             	mov    0x10(%ebp),%eax
    b4cb:	01 d0                	add    %edx,%eax
    b4cd:	0f b6 00             	movzbl (%eax),%eax
    b4d0:	0f b6 c0             	movzbl %al,%eax
    b4d3:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b4d6:	8b 45 14             	mov    0x14(%ebp),%eax
    b4d9:	8b 40 18             	mov    0x18(%eax),%eax
    b4dc:	39 c2                	cmp    %eax,%edx
    b4de:	75 4b                	jne    b52b <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    b4e0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b4e3:	89 d0                	mov    %edx,%eax
    b4e5:	01 c0                	add    %eax,%eax
    b4e7:	01 d0                	add    %edx,%eax
    b4e9:	01 c0                	add    %eax,%eax
    b4eb:	8d 50 04             	lea    0x4(%eax),%edx
    b4ee:	8b 45 10             	mov    0x10(%ebp),%eax
    b4f1:	01 d0                	add    %edx,%eax
    b4f3:	0f b6 00             	movzbl (%eax),%eax
    b4f6:	0f b6 c0             	movzbl %al,%eax
    b4f9:	c1 e0 08             	shl    $0x8,%eax
    b4fc:	89 c3                	mov    %eax,%ebx
    b4fe:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b501:	89 d0                	mov    %edx,%eax
    b503:	01 c0                	add    %eax,%eax
    b505:	01 d0                	add    %edx,%eax
    b507:	01 c0                	add    %eax,%eax
    b509:	8d 50 05             	lea    0x5(%eax),%edx
    b50c:	8b 45 10             	mov    0x10(%ebp),%eax
    b50f:	01 d0                	add    %edx,%eax
    b511:	0f b6 00             	movzbl (%eax),%eax
    b514:	0f b6 c0             	movzbl %al,%eax
    b517:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b51a:	8b 45 14             	mov    0x14(%ebp),%eax
    b51d:	8b 40 1c             	mov    0x1c(%eax),%eax
    b520:	39 c2                	cmp    %eax,%edx
    b522:	75 07                	jne    b52b <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    b524:	b8 00 00 00 00       	mov    $0x0,%eax
    b529:	eb 05                	jmp    b530 <getPixelColorsRGBA8+0x461>
    b52b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b530:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b532:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b536:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b539:	01 45 08             	add    %eax,0x8(%ebp)
    b53c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b53f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b542:	0f 85 a3 fe ff ff    	jne    b3eb <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b548:	e9 4c 02 00 00       	jmp    b799 <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b54d:	8b 45 14             	mov    0x14(%ebp),%eax
    b550:	8b 00                	mov    (%eax),%eax
    b552:	83 f8 03             	cmp    $0x3,%eax
    b555:	0f 85 b4 00 00 00    	jne    b60f <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    b55b:	8b 45 14             	mov    0x14(%ebp),%eax
    b55e:	8b 40 04             	mov    0x4(%eax),%eax
    b561:	83 f8 08             	cmp    $0x8,%eax
    b564:	75 4d                	jne    b5b3 <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b566:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b56d:	eb 37                	jmp    b5a6 <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    b56f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b572:	8b 45 10             	mov    0x10(%ebp),%eax
    b575:	01 d0                	add    %edx,%eax
    b577:	0f b6 00             	movzbl (%eax),%eax
    b57a:	0f b6 c0             	movzbl %al,%eax
    b57d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b580:	8b 45 14             	mov    0x14(%ebp),%eax
    b583:	8b 40 08             	mov    0x8(%eax),%eax
    b586:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b589:	c1 e2 02             	shl    $0x2,%edx
    b58c:	01 d0                	add    %edx,%eax
    b58e:	6a 04                	push   $0x4
    b590:	50                   	push   %eax
    b591:	ff 75 08             	pushl  0x8(%ebp)
    b594:	e8 49 83 ff ff       	call   38e2 <lodepng_memcpy>
    b599:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b59c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b5a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5a3:	01 45 08             	add    %eax,0x8(%ebp)
    b5a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5a9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b5ac:	75 c1                	jne    b56f <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b5ae:	e9 e6 01 00 00       	jmp    b799 <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    b5b3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5ba:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b5c1:	eb 3f                	jmp    b602 <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b5c3:	8b 45 14             	mov    0x14(%ebp),%eax
    b5c6:	8b 40 04             	mov    0x4(%eax),%eax
    b5c9:	50                   	push   %eax
    b5ca:	ff 75 10             	pushl  0x10(%ebp)
    b5cd:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b5d0:	50                   	push   %eax
    b5d1:	e8 71 d1 ff ff       	call   8747 <readBitsFromReversedStream>
    b5d6:	83 c4 0c             	add    $0xc,%esp
    b5d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b5dc:	8b 45 14             	mov    0x14(%ebp),%eax
    b5df:	8b 40 08             	mov    0x8(%eax),%eax
    b5e2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b5e5:	c1 e2 02             	shl    $0x2,%edx
    b5e8:	01 d0                	add    %edx,%eax
    b5ea:	6a 04                	push   $0x4
    b5ec:	50                   	push   %eax
    b5ed:	ff 75 08             	pushl  0x8(%ebp)
    b5f0:	e8 ed 82 ff ff       	call   38e2 <lodepng_memcpy>
    b5f5:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5f8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b5fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5ff:	01 45 08             	add    %eax,0x8(%ebp)
    b602:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b605:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b608:	75 b9                	jne    b5c3 <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b60a:	e9 8a 01 00 00       	jmp    b799 <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b60f:	8b 45 14             	mov    0x14(%ebp),%eax
    b612:	8b 00                	mov    (%eax),%eax
    b614:	83 f8 04             	cmp    $0x4,%eax
    b617:	0f 85 d1 00 00 00    	jne    b6ee <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b61d:	8b 45 14             	mov    0x14(%ebp),%eax
    b620:	8b 40 04             	mov    0x4(%eax),%eax
    b623:	83 f8 08             	cmp    $0x8,%eax
    b626:	75 62                	jne    b68a <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b628:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b62f:	eb 4c                	jmp    b67d <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b631:	8b 45 08             	mov    0x8(%ebp),%eax
    b634:	83 c0 01             	add    $0x1,%eax
    b637:	8b 55 08             	mov    0x8(%ebp),%edx
    b63a:	83 c2 02             	add    $0x2,%edx
    b63d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b640:	01 c9                	add    %ecx,%ecx
    b642:	89 cb                	mov    %ecx,%ebx
    b644:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b647:	01 d9                	add    %ebx,%ecx
    b649:	0f b6 09             	movzbl (%ecx),%ecx
    b64c:	88 0a                	mov    %cl,(%edx)
    b64e:	0f b6 12             	movzbl (%edx),%edx
    b651:	88 10                	mov    %dl,(%eax)
    b653:	0f b6 10             	movzbl (%eax),%edx
    b656:	8b 45 08             	mov    0x8(%ebp),%eax
    b659:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b65b:	8b 45 08             	mov    0x8(%ebp),%eax
    b65e:	8d 50 03             	lea    0x3(%eax),%edx
    b661:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b664:	01 c0                	add    %eax,%eax
    b666:	8d 48 01             	lea    0x1(%eax),%ecx
    b669:	8b 45 10             	mov    0x10(%ebp),%eax
    b66c:	01 c8                	add    %ecx,%eax
    b66e:	0f b6 00             	movzbl (%eax),%eax
    b671:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b673:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b677:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b67a:	01 45 08             	add    %eax,0x8(%ebp)
    b67d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b680:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b683:	75 ac                	jne    b631 <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b685:	e9 0f 01 00 00       	jmp    b799 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b68a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b691:	eb 4e                	jmp    b6e1 <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b693:	8b 45 08             	mov    0x8(%ebp),%eax
    b696:	83 c0 01             	add    $0x1,%eax
    b699:	8b 55 08             	mov    0x8(%ebp),%edx
    b69c:	83 c2 02             	add    $0x2,%edx
    b69f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b6a2:	c1 e1 02             	shl    $0x2,%ecx
    b6a5:	89 cb                	mov    %ecx,%ebx
    b6a7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b6aa:	01 d9                	add    %ebx,%ecx
    b6ac:	0f b6 09             	movzbl (%ecx),%ecx
    b6af:	88 0a                	mov    %cl,(%edx)
    b6b1:	0f b6 12             	movzbl (%edx),%edx
    b6b4:	88 10                	mov    %dl,(%eax)
    b6b6:	0f b6 10             	movzbl (%eax),%edx
    b6b9:	8b 45 08             	mov    0x8(%ebp),%eax
    b6bc:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b6be:	8b 45 08             	mov    0x8(%ebp),%eax
    b6c1:	8d 50 03             	lea    0x3(%eax),%edx
    b6c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6c7:	c1 e0 02             	shl    $0x2,%eax
    b6ca:	8d 48 02             	lea    0x2(%eax),%ecx
    b6cd:	8b 45 10             	mov    0x10(%ebp),%eax
    b6d0:	01 c8                	add    %ecx,%eax
    b6d2:	0f b6 00             	movzbl (%eax),%eax
    b6d5:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b6d7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b6db:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b6de:	01 45 08             	add    %eax,0x8(%ebp)
    b6e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6e4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b6e7:	75 aa                	jne    b693 <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b6e9:	e9 ab 00 00 00       	jmp    b799 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b6ee:	8b 45 14             	mov    0x14(%ebp),%eax
    b6f1:	8b 00                	mov    (%eax),%eax
    b6f3:	83 f8 06             	cmp    $0x6,%eax
    b6f6:	0f 85 9d 00 00 00    	jne    b799 <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b6fc:	8b 45 14             	mov    0x14(%ebp),%eax
    b6ff:	8b 40 04             	mov    0x4(%eax),%eax
    b702:	83 f8 08             	cmp    $0x8,%eax
    b705:	75 17                	jne    b71e <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b707:	8b 45 0c             	mov    0xc(%ebp),%eax
    b70a:	c1 e0 02             	shl    $0x2,%eax
    b70d:	50                   	push   %eax
    b70e:	ff 75 10             	pushl  0x10(%ebp)
    b711:	ff 75 08             	pushl  0x8(%ebp)
    b714:	e8 c9 81 ff ff       	call   38e2 <lodepng_memcpy>
    b719:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b71c:	eb 7b                	jmp    b799 <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b71e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b725:	eb 6a                	jmp    b791 <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b727:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b72a:	c1 e0 03             	shl    $0x3,%eax
    b72d:	89 c2                	mov    %eax,%edx
    b72f:	8b 45 10             	mov    0x10(%ebp),%eax
    b732:	01 d0                	add    %edx,%eax
    b734:	0f b6 10             	movzbl (%eax),%edx
    b737:	8b 45 08             	mov    0x8(%ebp),%eax
    b73a:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b73c:	8b 45 08             	mov    0x8(%ebp),%eax
    b73f:	8d 50 01             	lea    0x1(%eax),%edx
    b742:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b745:	c1 e0 03             	shl    $0x3,%eax
    b748:	8d 48 02             	lea    0x2(%eax),%ecx
    b74b:	8b 45 10             	mov    0x10(%ebp),%eax
    b74e:	01 c8                	add    %ecx,%eax
    b750:	0f b6 00             	movzbl (%eax),%eax
    b753:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b755:	8b 45 08             	mov    0x8(%ebp),%eax
    b758:	8d 50 02             	lea    0x2(%eax),%edx
    b75b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b75e:	c1 e0 03             	shl    $0x3,%eax
    b761:	8d 48 04             	lea    0x4(%eax),%ecx
    b764:	8b 45 10             	mov    0x10(%ebp),%eax
    b767:	01 c8                	add    %ecx,%eax
    b769:	0f b6 00             	movzbl (%eax),%eax
    b76c:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b76e:	8b 45 08             	mov    0x8(%ebp),%eax
    b771:	8d 50 03             	lea    0x3(%eax),%edx
    b774:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b777:	c1 e0 03             	shl    $0x3,%eax
    b77a:	8d 48 06             	lea    0x6(%eax),%ecx
    b77d:	8b 45 10             	mov    0x10(%ebp),%eax
    b780:	01 c8                	add    %ecx,%eax
    b782:	0f b6 00             	movzbl (%eax),%eax
    b785:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b787:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b78b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b78e:	01 45 08             	add    %eax,0x8(%ebp)
    b791:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b794:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b797:	75 8e                	jne    b727 <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b799:	90                   	nop
    b79a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b79d:	c9                   	leave  
    b79e:	c3                   	ret    

0000b79f <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b79f:	55                   	push   %ebp
    b7a0:	89 e5                	mov    %esp,%ebp
    b7a2:	53                   	push   %ebx
    b7a3:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b7a6:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b7ad:	8b 45 14             	mov    0x14(%ebp),%eax
    b7b0:	8b 00                	mov    (%eax),%eax
    b7b2:	85 c0                	test   %eax,%eax
    b7b4:	0f 85 2a 01 00 00    	jne    b8e4 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b7ba:	8b 45 14             	mov    0x14(%ebp),%eax
    b7bd:	8b 40 04             	mov    0x4(%eax),%eax
    b7c0:	83 f8 08             	cmp    $0x8,%eax
    b7c3:	75 46                	jne    b80b <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b7c5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b7cc:	eb 30                	jmp    b7fe <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b7ce:	8b 45 08             	mov    0x8(%ebp),%eax
    b7d1:	83 c0 01             	add    $0x1,%eax
    b7d4:	8b 55 08             	mov    0x8(%ebp),%edx
    b7d7:	83 c2 02             	add    $0x2,%edx
    b7da:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b7dd:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b7e0:	01 d9                	add    %ebx,%ecx
    b7e2:	0f b6 09             	movzbl (%ecx),%ecx
    b7e5:	88 0a                	mov    %cl,(%edx)
    b7e7:	0f b6 12             	movzbl (%edx),%edx
    b7ea:	88 10                	mov    %dl,(%eax)
    b7ec:	0f b6 10             	movzbl (%eax),%edx
    b7ef:	8b 45 08             	mov    0x8(%ebp),%eax
    b7f2:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b7f4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b7f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b7fb:	01 45 08             	add    %eax,0x8(%ebp)
    b7fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b801:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b804:	75 c8                	jne    b7ce <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b806:	e9 a8 03 00 00       	jmp    bbb3 <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b80b:	8b 45 14             	mov    0x14(%ebp),%eax
    b80e:	8b 40 04             	mov    0x4(%eax),%eax
    b811:	83 f8 10             	cmp    $0x10,%eax
    b814:	75 4a                	jne    b860 <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b816:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b81d:	eb 34                	jmp    b853 <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b81f:	8b 45 08             	mov    0x8(%ebp),%eax
    b822:	83 c0 01             	add    $0x1,%eax
    b825:	8b 55 08             	mov    0x8(%ebp),%edx
    b828:	83 c2 02             	add    $0x2,%edx
    b82b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b82e:	01 c9                	add    %ecx,%ecx
    b830:	89 cb                	mov    %ecx,%ebx
    b832:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b835:	01 d9                	add    %ebx,%ecx
    b837:	0f b6 09             	movzbl (%ecx),%ecx
    b83a:	88 0a                	mov    %cl,(%edx)
    b83c:	0f b6 12             	movzbl (%edx),%edx
    b83f:	88 10                	mov    %dl,(%eax)
    b841:	0f b6 10             	movzbl (%eax),%edx
    b844:	8b 45 08             	mov    0x8(%ebp),%eax
    b847:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b849:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b84d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b850:	01 45 08             	add    %eax,0x8(%ebp)
    b853:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b856:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b859:	75 c4                	jne    b81f <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b85b:	e9 53 03 00 00       	jmp    bbb3 <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b860:	8b 45 14             	mov    0x14(%ebp),%eax
    b863:	8b 40 04             	mov    0x4(%eax),%eax
    b866:	ba 01 00 00 00       	mov    $0x1,%edx
    b86b:	89 c1                	mov    %eax,%ecx
    b86d:	d3 e2                	shl    %cl,%edx
    b86f:	89 d0                	mov    %edx,%eax
    b871:	83 e8 01             	sub    $0x1,%eax
    b874:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b877:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b87e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b885:	eb 50                	jmp    b8d7 <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b887:	8b 45 14             	mov    0x14(%ebp),%eax
    b88a:	8b 40 04             	mov    0x4(%eax),%eax
    b88d:	50                   	push   %eax
    b88e:	ff 75 10             	pushl  0x10(%ebp)
    b891:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b894:	50                   	push   %eax
    b895:	e8 ad ce ff ff       	call   8747 <readBitsFromReversedStream>
    b89a:	83 c4 0c             	add    $0xc,%esp
    b89d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b8a0:	8b 45 08             	mov    0x8(%ebp),%eax
    b8a3:	8d 48 01             	lea    0x1(%eax),%ecx
    b8a6:	8b 45 08             	mov    0x8(%ebp),%eax
    b8a9:	8d 58 02             	lea    0x2(%eax),%ebx
    b8ac:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b8af:	89 d0                	mov    %edx,%eax
    b8b1:	c1 e0 08             	shl    $0x8,%eax
    b8b4:	29 d0                	sub    %edx,%eax
    b8b6:	ba 00 00 00 00       	mov    $0x0,%edx
    b8bb:	f7 75 f0             	divl   -0x10(%ebp)
    b8be:	88 03                	mov    %al,(%ebx)
    b8c0:	0f b6 03             	movzbl (%ebx),%eax
    b8c3:	88 01                	mov    %al,(%ecx)
    b8c5:	0f b6 11             	movzbl (%ecx),%edx
    b8c8:	8b 45 08             	mov    0x8(%ebp),%eax
    b8cb:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b8cd:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b8d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b8d4:	01 45 08             	add    %eax,0x8(%ebp)
    b8d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b8da:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b8dd:	75 a8                	jne    b887 <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b8df:	e9 cf 02 00 00       	jmp    bbb3 <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b8e4:	8b 45 14             	mov    0x14(%ebp),%eax
    b8e7:	8b 00                	mov    (%eax),%eax
    b8e9:	83 f8 02             	cmp    $0x2,%eax
    b8ec:	0f 85 9e 00 00 00    	jne    b990 <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    b8f2:	8b 45 14             	mov    0x14(%ebp),%eax
    b8f5:	8b 40 04             	mov    0x4(%eax),%eax
    b8f8:	83 f8 08             	cmp    $0x8,%eax
    b8fb:	75 1d                	jne    b91a <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    b8fd:	8b 55 0c             	mov    0xc(%ebp),%edx
    b900:	89 d0                	mov    %edx,%eax
    b902:	01 c0                	add    %eax,%eax
    b904:	01 d0                	add    %edx,%eax
    b906:	50                   	push   %eax
    b907:	ff 75 10             	pushl  0x10(%ebp)
    b90a:	ff 75 08             	pushl  0x8(%ebp)
    b90d:	e8 d0 7f ff ff       	call   38e2 <lodepng_memcpy>
    b912:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b915:	e9 99 02 00 00       	jmp    bbb3 <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b91a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b921:	eb 60                	jmp    b983 <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    b923:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b926:	89 d0                	mov    %edx,%eax
    b928:	01 c0                	add    %eax,%eax
    b92a:	01 d0                	add    %edx,%eax
    b92c:	01 c0                	add    %eax,%eax
    b92e:	89 c2                	mov    %eax,%edx
    b930:	8b 45 10             	mov    0x10(%ebp),%eax
    b933:	01 d0                	add    %edx,%eax
    b935:	0f b6 10             	movzbl (%eax),%edx
    b938:	8b 45 08             	mov    0x8(%ebp),%eax
    b93b:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b93d:	8b 45 08             	mov    0x8(%ebp),%eax
    b940:	8d 48 01             	lea    0x1(%eax),%ecx
    b943:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b946:	89 d0                	mov    %edx,%eax
    b948:	01 c0                	add    %eax,%eax
    b94a:	01 d0                	add    %edx,%eax
    b94c:	01 c0                	add    %eax,%eax
    b94e:	8d 50 02             	lea    0x2(%eax),%edx
    b951:	8b 45 10             	mov    0x10(%ebp),%eax
    b954:	01 d0                	add    %edx,%eax
    b956:	0f b6 00             	movzbl (%eax),%eax
    b959:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b95b:	8b 45 08             	mov    0x8(%ebp),%eax
    b95e:	8d 48 02             	lea    0x2(%eax),%ecx
    b961:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b964:	89 d0                	mov    %edx,%eax
    b966:	01 c0                	add    %eax,%eax
    b968:	01 d0                	add    %edx,%eax
    b96a:	01 c0                	add    %eax,%eax
    b96c:	8d 50 04             	lea    0x4(%eax),%edx
    b96f:	8b 45 10             	mov    0x10(%ebp),%eax
    b972:	01 d0                	add    %edx,%eax
    b974:	0f b6 00             	movzbl (%eax),%eax
    b977:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b979:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b97d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b980:	01 45 08             	add    %eax,0x8(%ebp)
    b983:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b986:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b989:	75 98                	jne    b923 <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b98b:	e9 23 02 00 00       	jmp    bbb3 <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b990:	8b 45 14             	mov    0x14(%ebp),%eax
    b993:	8b 00                	mov    (%eax),%eax
    b995:	83 f8 03             	cmp    $0x3,%eax
    b998:	0f 85 b4 00 00 00    	jne    ba52 <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    b99e:	8b 45 14             	mov    0x14(%ebp),%eax
    b9a1:	8b 40 04             	mov    0x4(%eax),%eax
    b9a4:	83 f8 08             	cmp    $0x8,%eax
    b9a7:	75 4d                	jne    b9f6 <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b9a9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b9b0:	eb 37                	jmp    b9e9 <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    b9b2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b9b5:	8b 45 10             	mov    0x10(%ebp),%eax
    b9b8:	01 d0                	add    %edx,%eax
    b9ba:	0f b6 00             	movzbl (%eax),%eax
    b9bd:	0f b6 c0             	movzbl %al,%eax
    b9c0:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b9c3:	8b 45 14             	mov    0x14(%ebp),%eax
    b9c6:	8b 40 08             	mov    0x8(%eax),%eax
    b9c9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b9cc:	c1 e2 02             	shl    $0x2,%edx
    b9cf:	01 d0                	add    %edx,%eax
    b9d1:	6a 03                	push   $0x3
    b9d3:	50                   	push   %eax
    b9d4:	ff 75 08             	pushl  0x8(%ebp)
    b9d7:	e8 06 7f ff ff       	call   38e2 <lodepng_memcpy>
    b9dc:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b9df:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b9e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b9e6:	01 45 08             	add    %eax,0x8(%ebp)
    b9e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b9ec:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b9ef:	75 c1                	jne    b9b2 <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b9f1:	e9 bd 01 00 00       	jmp    bbb3 <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    b9f6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b9fd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ba04:	eb 3f                	jmp    ba45 <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ba06:	8b 45 14             	mov    0x14(%ebp),%eax
    ba09:	8b 40 04             	mov    0x4(%eax),%eax
    ba0c:	50                   	push   %eax
    ba0d:	ff 75 10             	pushl  0x10(%ebp)
    ba10:	8d 45 dc             	lea    -0x24(%ebp),%eax
    ba13:	50                   	push   %eax
    ba14:	e8 2e cd ff ff       	call   8747 <readBitsFromReversedStream>
    ba19:	83 c4 0c             	add    $0xc,%esp
    ba1c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    ba1f:	8b 45 14             	mov    0x14(%ebp),%eax
    ba22:	8b 40 08             	mov    0x8(%eax),%eax
    ba25:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ba28:	c1 e2 02             	shl    $0x2,%edx
    ba2b:	01 d0                	add    %edx,%eax
    ba2d:	6a 03                	push   $0x3
    ba2f:	50                   	push   %eax
    ba30:	ff 75 08             	pushl  0x8(%ebp)
    ba33:	e8 aa 7e ff ff       	call   38e2 <lodepng_memcpy>
    ba38:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ba3b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ba3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ba42:	01 45 08             	add    %eax,0x8(%ebp)
    ba45:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ba48:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ba4b:	75 b9                	jne    ba06 <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    ba4d:	e9 61 01 00 00       	jmp    bbb3 <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    ba52:	8b 45 14             	mov    0x14(%ebp),%eax
    ba55:	8b 00                	mov    (%eax),%eax
    ba57:	83 f8 04             	cmp    $0x4,%eax
    ba5a:	0f 85 a0 00 00 00    	jne    bb00 <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    ba60:	8b 45 14             	mov    0x14(%ebp),%eax
    ba63:	8b 40 04             	mov    0x4(%eax),%eax
    ba66:	83 f8 08             	cmp    $0x8,%eax
    ba69:	75 4a                	jne    bab5 <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ba6b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ba72:	eb 34                	jmp    baa8 <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    ba74:	8b 45 08             	mov    0x8(%ebp),%eax
    ba77:	83 c0 01             	add    $0x1,%eax
    ba7a:	8b 55 08             	mov    0x8(%ebp),%edx
    ba7d:	83 c2 02             	add    $0x2,%edx
    ba80:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    ba83:	01 c9                	add    %ecx,%ecx
    ba85:	89 cb                	mov    %ecx,%ebx
    ba87:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ba8a:	01 d9                	add    %ebx,%ecx
    ba8c:	0f b6 09             	movzbl (%ecx),%ecx
    ba8f:	88 0a                	mov    %cl,(%edx)
    ba91:	0f b6 12             	movzbl (%edx),%edx
    ba94:	88 10                	mov    %dl,(%eax)
    ba96:	0f b6 10             	movzbl (%eax),%edx
    ba99:	8b 45 08             	mov    0x8(%ebp),%eax
    ba9c:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ba9e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    baa2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    baa5:	01 45 08             	add    %eax,0x8(%ebp)
    baa8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    baab:	3b 45 0c             	cmp    0xc(%ebp),%eax
    baae:	75 c4                	jne    ba74 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bab0:	e9 fe 00 00 00       	jmp    bbb3 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bab5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    babc:	eb 35                	jmp    baf3 <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    babe:	8b 45 08             	mov    0x8(%ebp),%eax
    bac1:	83 c0 01             	add    $0x1,%eax
    bac4:	8b 55 08             	mov    0x8(%ebp),%edx
    bac7:	83 c2 02             	add    $0x2,%edx
    baca:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    bacd:	c1 e1 02             	shl    $0x2,%ecx
    bad0:	89 cb                	mov    %ecx,%ebx
    bad2:	8b 4d 10             	mov    0x10(%ebp),%ecx
    bad5:	01 d9                	add    %ebx,%ecx
    bad7:	0f b6 09             	movzbl (%ecx),%ecx
    bada:	88 0a                	mov    %cl,(%edx)
    badc:	0f b6 12             	movzbl (%edx),%edx
    badf:	88 10                	mov    %dl,(%eax)
    bae1:	0f b6 10             	movzbl (%eax),%edx
    bae4:	8b 45 08             	mov    0x8(%ebp),%eax
    bae7:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bae9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    baed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    baf0:	01 45 08             	add    %eax,0x8(%ebp)
    baf3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    baf6:	3b 45 0c             	cmp    0xc(%ebp),%eax
    baf9:	75 c3                	jne    babe <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bafb:	e9 b3 00 00 00       	jmp    bbb3 <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    bb00:	8b 45 14             	mov    0x14(%ebp),%eax
    bb03:	8b 00                	mov    (%eax),%eax
    bb05:	83 f8 06             	cmp    $0x6,%eax
    bb08:	0f 85 a5 00 00 00    	jne    bbb3 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    bb0e:	8b 45 14             	mov    0x14(%ebp),%eax
    bb11:	8b 40 04             	mov    0x4(%eax),%eax
    bb14:	83 f8 08             	cmp    $0x8,%eax
    bb17:	75 38                	jne    bb51 <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bb19:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bb20:	eb 25                	jmp    bb47 <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    bb22:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bb25:	c1 e0 02             	shl    $0x2,%eax
    bb28:	89 c2                	mov    %eax,%edx
    bb2a:	8b 45 10             	mov    0x10(%ebp),%eax
    bb2d:	01 d0                	add    %edx,%eax
    bb2f:	6a 03                	push   $0x3
    bb31:	50                   	push   %eax
    bb32:	ff 75 08             	pushl  0x8(%ebp)
    bb35:	e8 a8 7d ff ff       	call   38e2 <lodepng_memcpy>
    bb3a:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bb3d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bb41:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bb44:	01 45 08             	add    %eax,0x8(%ebp)
    bb47:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bb4a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bb4d:	75 d3                	jne    bb22 <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bb4f:	eb 62                	jmp    bbb3 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bb51:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bb58:	eb 51                	jmp    bbab <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    bb5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bb5d:	c1 e0 03             	shl    $0x3,%eax
    bb60:	89 c2                	mov    %eax,%edx
    bb62:	8b 45 10             	mov    0x10(%ebp),%eax
    bb65:	01 d0                	add    %edx,%eax
    bb67:	0f b6 10             	movzbl (%eax),%edx
    bb6a:	8b 45 08             	mov    0x8(%ebp),%eax
    bb6d:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    bb6f:	8b 45 08             	mov    0x8(%ebp),%eax
    bb72:	8d 50 01             	lea    0x1(%eax),%edx
    bb75:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bb78:	c1 e0 03             	shl    $0x3,%eax
    bb7b:	8d 48 02             	lea    0x2(%eax),%ecx
    bb7e:	8b 45 10             	mov    0x10(%ebp),%eax
    bb81:	01 c8                	add    %ecx,%eax
    bb83:	0f b6 00             	movzbl (%eax),%eax
    bb86:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    bb88:	8b 45 08             	mov    0x8(%ebp),%eax
    bb8b:	8d 50 02             	lea    0x2(%eax),%edx
    bb8e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bb91:	c1 e0 03             	shl    $0x3,%eax
    bb94:	8d 48 04             	lea    0x4(%eax),%ecx
    bb97:	8b 45 10             	mov    0x10(%ebp),%eax
    bb9a:	01 c8                	add    %ecx,%eax
    bb9c:	0f b6 00             	movzbl (%eax),%eax
    bb9f:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bba1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bba5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bba8:	01 45 08             	add    %eax,0x8(%ebp)
    bbab:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bbae:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bbb1:	75 a7                	jne    bb5a <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bbb3:	90                   	nop
    bbb4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    bbb7:	c9                   	leave  
    bbb8:	c3                   	ret    

0000bbb9 <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    bbb9:	55                   	push   %ebp
    bbba:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    bbbc:	8b 45 20             	mov    0x20(%ebp),%eax
    bbbf:	8b 00                	mov    (%eax),%eax
    bbc1:	85 c0                	test   %eax,%eax
    bbc3:	0f 85 a4 00 00 00    	jne    bc6d <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    bbc9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bbcc:	01 c0                	add    %eax,%eax
    bbce:	89 c2                	mov    %eax,%edx
    bbd0:	8b 45 18             	mov    0x18(%ebp),%eax
    bbd3:	01 d0                	add    %edx,%eax
    bbd5:	0f b6 00             	movzbl (%eax),%eax
    bbd8:	0f b6 c0             	movzbl %al,%eax
    bbdb:	c1 e0 08             	shl    $0x8,%eax
    bbde:	89 c2                	mov    %eax,%edx
    bbe0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bbe3:	01 c0                	add    %eax,%eax
    bbe5:	8d 48 01             	lea    0x1(%eax),%ecx
    bbe8:	8b 45 18             	mov    0x18(%ebp),%eax
    bbeb:	01 c8                	add    %ecx,%eax
    bbed:	0f b6 00             	movzbl (%eax),%eax
    bbf0:	0f b6 c0             	movzbl %al,%eax
    bbf3:	01 c2                	add    %eax,%edx
    bbf5:	8b 45 10             	mov    0x10(%ebp),%eax
    bbf8:	66 89 10             	mov    %dx,(%eax)
    bbfb:	8b 45 10             	mov    0x10(%ebp),%eax
    bbfe:	0f b7 10             	movzwl (%eax),%edx
    bc01:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc04:	66 89 10             	mov    %dx,(%eax)
    bc07:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc0a:	0f b7 10             	movzwl (%eax),%edx
    bc0d:	8b 45 08             	mov    0x8(%ebp),%eax
    bc10:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    bc13:	8b 45 20             	mov    0x20(%ebp),%eax
    bc16:	8b 40 10             	mov    0x10(%eax),%eax
    bc19:	85 c0                	test   %eax,%eax
    bc1b:	74 43                	je     bc60 <getPixelColorRGBA16+0xa7>
    bc1d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc20:	01 c0                	add    %eax,%eax
    bc22:	89 c2                	mov    %eax,%edx
    bc24:	8b 45 18             	mov    0x18(%ebp),%eax
    bc27:	01 d0                	add    %edx,%eax
    bc29:	0f b6 00             	movzbl (%eax),%eax
    bc2c:	0f b6 c0             	movzbl %al,%eax
    bc2f:	c1 e0 08             	shl    $0x8,%eax
    bc32:	89 c2                	mov    %eax,%edx
    bc34:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc37:	01 c0                	add    %eax,%eax
    bc39:	8d 48 01             	lea    0x1(%eax),%ecx
    bc3c:	8b 45 18             	mov    0x18(%ebp),%eax
    bc3f:	01 c8                	add    %ecx,%eax
    bc41:	0f b6 00             	movzbl (%eax),%eax
    bc44:	0f b6 c0             	movzbl %al,%eax
    bc47:	01 c2                	add    %eax,%edx
    bc49:	8b 45 20             	mov    0x20(%ebp),%eax
    bc4c:	8b 40 14             	mov    0x14(%eax),%eax
    bc4f:	39 c2                	cmp    %eax,%edx
    bc51:	75 0d                	jne    bc60 <getPixelColorRGBA16+0xa7>
    bc53:	8b 45 14             	mov    0x14(%ebp),%eax
    bc56:	66 c7 00 00 00       	movw   $0x0,(%eax)
    bc5b:	e9 48 03 00 00       	jmp    bfa8 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    bc60:	8b 45 14             	mov    0x14(%ebp),%eax
    bc63:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    bc68:	e9 3b 03 00 00       	jmp    bfa8 <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    bc6d:	8b 45 20             	mov    0x20(%ebp),%eax
    bc70:	8b 00                	mov    (%eax),%eax
    bc72:	83 f8 02             	cmp    $0x2,%eax
    bc75:	0f 85 b6 01 00 00    	jne    be31 <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    bc7b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bc7e:	89 d0                	mov    %edx,%eax
    bc80:	01 c0                	add    %eax,%eax
    bc82:	01 d0                	add    %edx,%eax
    bc84:	01 c0                	add    %eax,%eax
    bc86:	89 c2                	mov    %eax,%edx
    bc88:	8b 45 18             	mov    0x18(%ebp),%eax
    bc8b:	01 d0                	add    %edx,%eax
    bc8d:	0f b6 00             	movzbl (%eax),%eax
    bc90:	0f b6 c0             	movzbl %al,%eax
    bc93:	c1 e0 08             	shl    $0x8,%eax
    bc96:	89 c1                	mov    %eax,%ecx
    bc98:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bc9b:	89 d0                	mov    %edx,%eax
    bc9d:	01 c0                	add    %eax,%eax
    bc9f:	01 d0                	add    %edx,%eax
    bca1:	01 c0                	add    %eax,%eax
    bca3:	8d 50 01             	lea    0x1(%eax),%edx
    bca6:	8b 45 18             	mov    0x18(%ebp),%eax
    bca9:	01 d0                	add    %edx,%eax
    bcab:	0f b6 00             	movzbl (%eax),%eax
    bcae:	0f b6 c0             	movzbl %al,%eax
    bcb1:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bcb4:	8b 45 08             	mov    0x8(%ebp),%eax
    bcb7:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    bcba:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bcbd:	89 d0                	mov    %edx,%eax
    bcbf:	01 c0                	add    %eax,%eax
    bcc1:	01 d0                	add    %edx,%eax
    bcc3:	01 c0                	add    %eax,%eax
    bcc5:	8d 50 02             	lea    0x2(%eax),%edx
    bcc8:	8b 45 18             	mov    0x18(%ebp),%eax
    bccb:	01 d0                	add    %edx,%eax
    bccd:	0f b6 00             	movzbl (%eax),%eax
    bcd0:	0f b6 c0             	movzbl %al,%eax
    bcd3:	c1 e0 08             	shl    $0x8,%eax
    bcd6:	89 c1                	mov    %eax,%ecx
    bcd8:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bcdb:	89 d0                	mov    %edx,%eax
    bcdd:	01 c0                	add    %eax,%eax
    bcdf:	01 d0                	add    %edx,%eax
    bce1:	01 c0                	add    %eax,%eax
    bce3:	8d 50 03             	lea    0x3(%eax),%edx
    bce6:	8b 45 18             	mov    0x18(%ebp),%eax
    bce9:	01 d0                	add    %edx,%eax
    bceb:	0f b6 00             	movzbl (%eax),%eax
    bcee:	0f b6 c0             	movzbl %al,%eax
    bcf1:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bcf4:	8b 45 0c             	mov    0xc(%ebp),%eax
    bcf7:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    bcfa:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bcfd:	89 d0                	mov    %edx,%eax
    bcff:	01 c0                	add    %eax,%eax
    bd01:	01 d0                	add    %edx,%eax
    bd03:	01 c0                	add    %eax,%eax
    bd05:	8d 50 04             	lea    0x4(%eax),%edx
    bd08:	8b 45 18             	mov    0x18(%ebp),%eax
    bd0b:	01 d0                	add    %edx,%eax
    bd0d:	0f b6 00             	movzbl (%eax),%eax
    bd10:	0f b6 c0             	movzbl %al,%eax
    bd13:	c1 e0 08             	shl    $0x8,%eax
    bd16:	89 c1                	mov    %eax,%ecx
    bd18:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bd1b:	89 d0                	mov    %edx,%eax
    bd1d:	01 c0                	add    %eax,%eax
    bd1f:	01 d0                	add    %edx,%eax
    bd21:	01 c0                	add    %eax,%eax
    bd23:	8d 50 05             	lea    0x5(%eax),%edx
    bd26:	8b 45 18             	mov    0x18(%ebp),%eax
    bd29:	01 d0                	add    %edx,%eax
    bd2b:	0f b6 00             	movzbl (%eax),%eax
    bd2e:	0f b6 c0             	movzbl %al,%eax
    bd31:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bd34:	8b 45 10             	mov    0x10(%ebp),%eax
    bd37:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    bd3a:	8b 45 20             	mov    0x20(%ebp),%eax
    bd3d:	8b 40 10             	mov    0x10(%eax),%eax
    bd40:	85 c0                	test   %eax,%eax
    bd42:	0f 84 dc 00 00 00    	je     be24 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    bd48:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bd4b:	89 d0                	mov    %edx,%eax
    bd4d:	01 c0                	add    %eax,%eax
    bd4f:	01 d0                	add    %edx,%eax
    bd51:	01 c0                	add    %eax,%eax
    bd53:	89 c2                	mov    %eax,%edx
    bd55:	8b 45 18             	mov    0x18(%ebp),%eax
    bd58:	01 d0                	add    %edx,%eax
    bd5a:	0f b6 00             	movzbl (%eax),%eax
    bd5d:	0f b6 c0             	movzbl %al,%eax
    bd60:	c1 e0 08             	shl    $0x8,%eax
    bd63:	89 c1                	mov    %eax,%ecx
    bd65:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bd68:	89 d0                	mov    %edx,%eax
    bd6a:	01 c0                	add    %eax,%eax
    bd6c:	01 d0                	add    %edx,%eax
    bd6e:	01 c0                	add    %eax,%eax
    bd70:	8d 50 01             	lea    0x1(%eax),%edx
    bd73:	8b 45 18             	mov    0x18(%ebp),%eax
    bd76:	01 d0                	add    %edx,%eax
    bd78:	0f b6 00             	movzbl (%eax),%eax
    bd7b:	0f b6 c0             	movzbl %al,%eax
    bd7e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bd81:	8b 45 20             	mov    0x20(%ebp),%eax
    bd84:	8b 40 14             	mov    0x14(%eax),%eax
    bd87:	39 c2                	cmp    %eax,%edx
    bd89:	0f 85 95 00 00 00    	jne    be24 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    bd8f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bd92:	89 d0                	mov    %edx,%eax
    bd94:	01 c0                	add    %eax,%eax
    bd96:	01 d0                	add    %edx,%eax
    bd98:	01 c0                	add    %eax,%eax
    bd9a:	8d 50 02             	lea    0x2(%eax),%edx
    bd9d:	8b 45 18             	mov    0x18(%ebp),%eax
    bda0:	01 d0                	add    %edx,%eax
    bda2:	0f b6 00             	movzbl (%eax),%eax
    bda5:	0f b6 c0             	movzbl %al,%eax
    bda8:	c1 e0 08             	shl    $0x8,%eax
    bdab:	89 c1                	mov    %eax,%ecx
    bdad:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bdb0:	89 d0                	mov    %edx,%eax
    bdb2:	01 c0                	add    %eax,%eax
    bdb4:	01 d0                	add    %edx,%eax
    bdb6:	01 c0                	add    %eax,%eax
    bdb8:	8d 50 03             	lea    0x3(%eax),%edx
    bdbb:	8b 45 18             	mov    0x18(%ebp),%eax
    bdbe:	01 d0                	add    %edx,%eax
    bdc0:	0f b6 00             	movzbl (%eax),%eax
    bdc3:	0f b6 c0             	movzbl %al,%eax
    bdc6:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bdc9:	8b 45 20             	mov    0x20(%ebp),%eax
    bdcc:	8b 40 18             	mov    0x18(%eax),%eax
    bdcf:	39 c2                	cmp    %eax,%edx
    bdd1:	75 51                	jne    be24 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    bdd3:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bdd6:	89 d0                	mov    %edx,%eax
    bdd8:	01 c0                	add    %eax,%eax
    bdda:	01 d0                	add    %edx,%eax
    bddc:	01 c0                	add    %eax,%eax
    bdde:	8d 50 04             	lea    0x4(%eax),%edx
    bde1:	8b 45 18             	mov    0x18(%ebp),%eax
    bde4:	01 d0                	add    %edx,%eax
    bde6:	0f b6 00             	movzbl (%eax),%eax
    bde9:	0f b6 c0             	movzbl %al,%eax
    bdec:	c1 e0 08             	shl    $0x8,%eax
    bdef:	89 c1                	mov    %eax,%ecx
    bdf1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bdf4:	89 d0                	mov    %edx,%eax
    bdf6:	01 c0                	add    %eax,%eax
    bdf8:	01 d0                	add    %edx,%eax
    bdfa:	01 c0                	add    %eax,%eax
    bdfc:	8d 50 05             	lea    0x5(%eax),%edx
    bdff:	8b 45 18             	mov    0x18(%ebp),%eax
    be02:	01 d0                	add    %edx,%eax
    be04:	0f b6 00             	movzbl (%eax),%eax
    be07:	0f b6 c0             	movzbl %al,%eax
    be0a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    be0d:	8b 45 20             	mov    0x20(%ebp),%eax
    be10:	8b 40 1c             	mov    0x1c(%eax),%eax
    be13:	39 c2                	cmp    %eax,%edx
    be15:	75 0d                	jne    be24 <getPixelColorRGBA16+0x26b>
    be17:	8b 45 14             	mov    0x14(%ebp),%eax
    be1a:	66 c7 00 00 00       	movw   $0x0,(%eax)
    be1f:	e9 84 01 00 00       	jmp    bfa8 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    be24:	8b 45 14             	mov    0x14(%ebp),%eax
    be27:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    be2c:	e9 77 01 00 00       	jmp    bfa8 <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    be31:	8b 45 20             	mov    0x20(%ebp),%eax
    be34:	8b 00                	mov    (%eax),%eax
    be36:	83 f8 04             	cmp    $0x4,%eax
    be39:	0f 85 86 00 00 00    	jne    bec5 <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    be3f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    be42:	c1 e0 02             	shl    $0x2,%eax
    be45:	89 c2                	mov    %eax,%edx
    be47:	8b 45 18             	mov    0x18(%ebp),%eax
    be4a:	01 d0                	add    %edx,%eax
    be4c:	0f b6 00             	movzbl (%eax),%eax
    be4f:	0f b6 c0             	movzbl %al,%eax
    be52:	c1 e0 08             	shl    $0x8,%eax
    be55:	89 c2                	mov    %eax,%edx
    be57:	8b 45 1c             	mov    0x1c(%ebp),%eax
    be5a:	c1 e0 02             	shl    $0x2,%eax
    be5d:	8d 48 01             	lea    0x1(%eax),%ecx
    be60:	8b 45 18             	mov    0x18(%ebp),%eax
    be63:	01 c8                	add    %ecx,%eax
    be65:	0f b6 00             	movzbl (%eax),%eax
    be68:	0f b6 c0             	movzbl %al,%eax
    be6b:	01 c2                	add    %eax,%edx
    be6d:	8b 45 10             	mov    0x10(%ebp),%eax
    be70:	66 89 10             	mov    %dx,(%eax)
    be73:	8b 45 10             	mov    0x10(%ebp),%eax
    be76:	0f b7 10             	movzwl (%eax),%edx
    be79:	8b 45 0c             	mov    0xc(%ebp),%eax
    be7c:	66 89 10             	mov    %dx,(%eax)
    be7f:	8b 45 0c             	mov    0xc(%ebp),%eax
    be82:	0f b7 10             	movzwl (%eax),%edx
    be85:	8b 45 08             	mov    0x8(%ebp),%eax
    be88:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    be8b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    be8e:	c1 e0 02             	shl    $0x2,%eax
    be91:	8d 50 02             	lea    0x2(%eax),%edx
    be94:	8b 45 18             	mov    0x18(%ebp),%eax
    be97:	01 d0                	add    %edx,%eax
    be99:	0f b6 00             	movzbl (%eax),%eax
    be9c:	0f b6 c0             	movzbl %al,%eax
    be9f:	c1 e0 08             	shl    $0x8,%eax
    bea2:	89 c2                	mov    %eax,%edx
    bea4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bea7:	c1 e0 02             	shl    $0x2,%eax
    beaa:	8d 48 03             	lea    0x3(%eax),%ecx
    bead:	8b 45 18             	mov    0x18(%ebp),%eax
    beb0:	01 c8                	add    %ecx,%eax
    beb2:	0f b6 00             	movzbl (%eax),%eax
    beb5:	0f b6 c0             	movzbl %al,%eax
    beb8:	01 c2                	add    %eax,%edx
    beba:	8b 45 14             	mov    0x14(%ebp),%eax
    bebd:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    bec0:	e9 e3 00 00 00       	jmp    bfa8 <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    bec5:	8b 45 20             	mov    0x20(%ebp),%eax
    bec8:	8b 00                	mov    (%eax),%eax
    beca:	83 f8 06             	cmp    $0x6,%eax
    becd:	0f 85 d5 00 00 00    	jne    bfa8 <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    bed3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bed6:	c1 e0 03             	shl    $0x3,%eax
    bed9:	89 c2                	mov    %eax,%edx
    bedb:	8b 45 18             	mov    0x18(%ebp),%eax
    bede:	01 d0                	add    %edx,%eax
    bee0:	0f b6 00             	movzbl (%eax),%eax
    bee3:	0f b6 c0             	movzbl %al,%eax
    bee6:	c1 e0 08             	shl    $0x8,%eax
    bee9:	89 c2                	mov    %eax,%edx
    beeb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    beee:	c1 e0 03             	shl    $0x3,%eax
    bef1:	8d 48 01             	lea    0x1(%eax),%ecx
    bef4:	8b 45 18             	mov    0x18(%ebp),%eax
    bef7:	01 c8                	add    %ecx,%eax
    bef9:	0f b6 00             	movzbl (%eax),%eax
    befc:	0f b6 c0             	movzbl %al,%eax
    beff:	01 c2                	add    %eax,%edx
    bf01:	8b 45 08             	mov    0x8(%ebp),%eax
    bf04:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    bf07:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bf0a:	c1 e0 03             	shl    $0x3,%eax
    bf0d:	8d 50 02             	lea    0x2(%eax),%edx
    bf10:	8b 45 18             	mov    0x18(%ebp),%eax
    bf13:	01 d0                	add    %edx,%eax
    bf15:	0f b6 00             	movzbl (%eax),%eax
    bf18:	0f b6 c0             	movzbl %al,%eax
    bf1b:	c1 e0 08             	shl    $0x8,%eax
    bf1e:	89 c2                	mov    %eax,%edx
    bf20:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bf23:	c1 e0 03             	shl    $0x3,%eax
    bf26:	8d 48 03             	lea    0x3(%eax),%ecx
    bf29:	8b 45 18             	mov    0x18(%ebp),%eax
    bf2c:	01 c8                	add    %ecx,%eax
    bf2e:	0f b6 00             	movzbl (%eax),%eax
    bf31:	0f b6 c0             	movzbl %al,%eax
    bf34:	01 c2                	add    %eax,%edx
    bf36:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf39:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    bf3c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bf3f:	c1 e0 03             	shl    $0x3,%eax
    bf42:	8d 50 04             	lea    0x4(%eax),%edx
    bf45:	8b 45 18             	mov    0x18(%ebp),%eax
    bf48:	01 d0                	add    %edx,%eax
    bf4a:	0f b6 00             	movzbl (%eax),%eax
    bf4d:	0f b6 c0             	movzbl %al,%eax
    bf50:	c1 e0 08             	shl    $0x8,%eax
    bf53:	89 c2                	mov    %eax,%edx
    bf55:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bf58:	c1 e0 03             	shl    $0x3,%eax
    bf5b:	8d 48 05             	lea    0x5(%eax),%ecx
    bf5e:	8b 45 18             	mov    0x18(%ebp),%eax
    bf61:	01 c8                	add    %ecx,%eax
    bf63:	0f b6 00             	movzbl (%eax),%eax
    bf66:	0f b6 c0             	movzbl %al,%eax
    bf69:	01 c2                	add    %eax,%edx
    bf6b:	8b 45 10             	mov    0x10(%ebp),%eax
    bf6e:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    bf71:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bf74:	c1 e0 03             	shl    $0x3,%eax
    bf77:	8d 50 06             	lea    0x6(%eax),%edx
    bf7a:	8b 45 18             	mov    0x18(%ebp),%eax
    bf7d:	01 d0                	add    %edx,%eax
    bf7f:	0f b6 00             	movzbl (%eax),%eax
    bf82:	0f b6 c0             	movzbl %al,%eax
    bf85:	c1 e0 08             	shl    $0x8,%eax
    bf88:	89 c2                	mov    %eax,%edx
    bf8a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bf8d:	c1 e0 03             	shl    $0x3,%eax
    bf90:	8d 48 07             	lea    0x7(%eax),%ecx
    bf93:	8b 45 18             	mov    0x18(%ebp),%eax
    bf96:	01 c8                	add    %ecx,%eax
    bf98:	0f b6 00             	movzbl (%eax),%eax
    bf9b:	0f b6 c0             	movzbl %al,%eax
    bf9e:	01 c2                	add    %eax,%edx
    bfa0:	8b 45 14             	mov    0x14(%ebp),%eax
    bfa3:	66 89 10             	mov    %dx,(%eax)
  }
}
    bfa6:	eb 00                	jmp    bfa8 <getPixelColorRGBA16+0x3ef>
    bfa8:	90                   	nop
    bfa9:	5d                   	pop    %ebp
    bfaa:	c3                   	ret    

0000bfab <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    bfab:	55                   	push   %ebp
    bfac:	89 e5                	mov    %esp,%ebp
    bfae:	56                   	push   %esi
    bfaf:	53                   	push   %ebx
    bfb0:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    bfb3:	8b 55 18             	mov    0x18(%ebp),%edx
    bfb6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bfb9:	0f af c2             	imul   %edx,%eax
    bfbc:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    bfbf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    bfc6:	8b 45 14             	mov    0x14(%ebp),%eax
    bfc9:	8b 00                	mov    (%eax),%eax
    bfcb:	83 f8 03             	cmp    $0x3,%eax
    bfce:	75 14                	jne    bfe4 <lodepng_convert+0x39>
    bfd0:	8b 45 14             	mov    0x14(%ebp),%eax
    bfd3:	8b 40 08             	mov    0x8(%eax),%eax
    bfd6:	85 c0                	test   %eax,%eax
    bfd8:	75 0a                	jne    bfe4 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    bfda:	b8 6b 00 00 00       	mov    $0x6b,%eax
    bfdf:	e9 19 03 00 00       	jmp    c2fd <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    bfe4:	ff 75 14             	pushl  0x14(%ebp)
    bfe7:	ff 75 10             	pushl  0x10(%ebp)
    bfea:	e8 b7 d1 ff ff       	call   91a6 <lodepng_color_mode_equal>
    bfef:	83 c4 08             	add    $0x8,%esp
    bff2:	85 c0                	test   %eax,%eax
    bff4:	74 2f                	je     c025 <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bff6:	ff 75 14             	pushl  0x14(%ebp)
    bff9:	ff 75 1c             	pushl  0x1c(%ebp)
    bffc:	ff 75 18             	pushl  0x18(%ebp)
    bfff:	e8 fb d4 ff ff       	call   94ff <lodepng_get_raw_size>
    c004:	83 c4 0c             	add    $0xc,%esp
    c007:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    c00a:	ff 75 dc             	pushl  -0x24(%ebp)
    c00d:	ff 75 0c             	pushl  0xc(%ebp)
    c010:	ff 75 08             	pushl  0x8(%ebp)
    c013:	e8 ca 78 ff ff       	call   38e2 <lodepng_memcpy>
    c018:	83 c4 0c             	add    $0xc,%esp
    return 0;
    c01b:	b8 00 00 00 00       	mov    $0x0,%eax
    c020:	e9 d8 02 00 00       	jmp    c2fd <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    c025:	8b 45 10             	mov    0x10(%ebp),%eax
    c028:	8b 00                	mov    (%eax),%eax
    c02a:	83 f8 03             	cmp    $0x3,%eax
    c02d:	0f 85 16 01 00 00    	jne    c149 <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    c033:	8b 45 10             	mov    0x10(%ebp),%eax
    c036:	8b 40 0c             	mov    0xc(%eax),%eax
    c039:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    c03c:	8b 45 10             	mov    0x10(%ebp),%eax
    c03f:	8b 40 08             	mov    0x8(%eax),%eax
    c042:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    c045:	8b 45 10             	mov    0x10(%ebp),%eax
    c048:	8b 40 04             	mov    0x4(%eax),%eax
    c04b:	ba 01 00 00 00       	mov    $0x1,%edx
    c050:	89 c1                	mov    %eax,%ecx
    c052:	d3 e2                	shl    %cl,%edx
    c054:	89 d0                	mov    %edx,%eax
    c056:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    c059:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c05d:	75 5b                	jne    c0ba <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    c05f:	8b 45 14             	mov    0x14(%ebp),%eax
    c062:	8b 40 0c             	mov    0xc(%eax),%eax
    c065:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    c068:	8b 45 14             	mov    0x14(%ebp),%eax
    c06b:	8b 40 08             	mov    0x8(%eax),%eax
    c06e:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    c071:	8b 45 14             	mov    0x14(%ebp),%eax
    c074:	8b 00                	mov    (%eax),%eax
    c076:	83 f8 03             	cmp    $0x3,%eax
    c079:	75 3f                	jne    c0ba <lodepng_convert+0x10f>
    c07b:	8b 45 14             	mov    0x14(%ebp),%eax
    c07e:	8b 50 04             	mov    0x4(%eax),%edx
    c081:	8b 45 10             	mov    0x10(%ebp),%eax
    c084:	8b 40 04             	mov    0x4(%eax),%eax
    c087:	39 c2                	cmp    %eax,%edx
    c089:	75 2f                	jne    c0ba <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    c08b:	ff 75 14             	pushl  0x14(%ebp)
    c08e:	ff 75 1c             	pushl  0x1c(%ebp)
    c091:	ff 75 18             	pushl  0x18(%ebp)
    c094:	e8 66 d4 ff ff       	call   94ff <lodepng_get_raw_size>
    c099:	83 c4 0c             	add    $0xc,%esp
    c09c:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    c09f:	ff 75 d8             	pushl  -0x28(%ebp)
    c0a2:	ff 75 0c             	pushl  0xc(%ebp)
    c0a5:	ff 75 08             	pushl  0x8(%ebp)
    c0a8:	e8 35 78 ff ff       	call   38e2 <lodepng_memcpy>
    c0ad:	83 c4 0c             	add    $0xc,%esp
        return 0;
    c0b0:	b8 00 00 00 00       	mov    $0x0,%eax
    c0b5:	e9 43 02 00 00       	jmp    c2fd <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    c0ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c0bd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    c0c0:	7d 06                	jge    c0c8 <lodepng_convert+0x11d>
    c0c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c0c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    c0c8:	8d 45 90             	lea    -0x70(%ebp),%eax
    c0cb:	50                   	push   %eax
    c0cc:	e8 5f e1 ff ff       	call   a230 <color_tree_init>
    c0d1:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    c0d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c0db:	eb 61                	jmp    c13e <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    c0dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c0e0:	c1 e0 02             	shl    $0x2,%eax
    c0e3:	89 c2                	mov    %eax,%edx
    c0e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c0e8:	01 d0                	add    %edx,%eax
    c0ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    c0ed:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c0f0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c0f3:	83 c0 03             	add    $0x3,%eax
    c0f6:	0f b6 00             	movzbl (%eax),%eax
    c0f9:	0f b6 d8             	movzbl %al,%ebx
    c0fc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c0ff:	83 c0 02             	add    $0x2,%eax
    c102:	0f b6 00             	movzbl (%eax),%eax
    c105:	0f b6 c8             	movzbl %al,%ecx
    c108:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c10b:	83 c0 01             	add    $0x1,%eax
    c10e:	0f b6 00             	movzbl (%eax),%eax
    c111:	0f b6 d0             	movzbl %al,%edx
    c114:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c117:	0f b6 00             	movzbl (%eax),%eax
    c11a:	0f b6 c0             	movzbl %al,%eax
    c11d:	83 ec 08             	sub    $0x8,%esp
    c120:	56                   	push   %esi
    c121:	53                   	push   %ebx
    c122:	51                   	push   %ecx
    c123:	52                   	push   %edx
    c124:	50                   	push   %eax
    c125:	8d 45 90             	lea    -0x70(%ebp),%eax
    c128:	50                   	push   %eax
    c129:	e8 85 e2 ff ff       	call   a3b3 <color_tree_add>
    c12e:	83 c4 20             	add    $0x20,%esp
    c131:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    c134:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c138:	75 0e                	jne    c148 <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    c13a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c13e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c141:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    c144:	75 97                	jne    c0dd <lodepng_convert+0x132>
    c146:	eb 01                	jmp    c149 <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    c148:	90                   	nop
    }
  }

  if(!error) {
    c149:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c14d:	0f 85 8e 01 00 00    	jne    c2e1 <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    c153:	8b 45 14             	mov    0x14(%ebp),%eax
    c156:	8b 40 04             	mov    0x4(%eax),%eax
    c159:	83 f8 10             	cmp    $0x10,%eax
    c15c:	0f 85 99 00 00 00    	jne    c1fb <lodepng_convert+0x250>
    c162:	8b 45 10             	mov    0x10(%ebp),%eax
    c165:	8b 40 04             	mov    0x4(%eax),%eax
    c168:	83 f8 10             	cmp    $0x10,%eax
    c16b:	0f 85 8a 00 00 00    	jne    c1fb <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    c171:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c178:	eb 74                	jmp    c1ee <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    c17a:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    c180:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    c186:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    c18c:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c192:	83 ec 04             	sub    $0x4,%esp
    c195:	ff 75 14             	pushl  0x14(%ebp)
    c198:	ff 75 f4             	pushl  -0xc(%ebp)
    c19b:	ff 75 0c             	pushl  0xc(%ebp)
    c19e:	8d 45 88             	lea    -0x78(%ebp),%eax
    c1a1:	50                   	push   %eax
    c1a2:	8d 45 8a             	lea    -0x76(%ebp),%eax
    c1a5:	50                   	push   %eax
    c1a6:	8d 45 8c             	lea    -0x74(%ebp),%eax
    c1a9:	50                   	push   %eax
    c1aa:	8d 45 8e             	lea    -0x72(%ebp),%eax
    c1ad:	50                   	push   %eax
    c1ae:	e8 06 fa ff ff       	call   bbb9 <getPixelColorRGBA16>
    c1b3:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    c1b6:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    c1ba:	0f b7 d8             	movzwl %ax,%ebx
    c1bd:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    c1c1:	0f b7 c8             	movzwl %ax,%ecx
    c1c4:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    c1c8:	0f b7 d0             	movzwl %ax,%edx
    c1cb:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    c1cf:	0f b7 c0             	movzwl %ax,%eax
    c1d2:	83 ec 04             	sub    $0x4,%esp
    c1d5:	53                   	push   %ebx
    c1d6:	51                   	push   %ecx
    c1d7:	52                   	push   %edx
    c1d8:	50                   	push   %eax
    c1d9:	ff 75 10             	pushl  0x10(%ebp)
    c1dc:	ff 75 f4             	pushl  -0xc(%ebp)
    c1df:	ff 75 08             	pushl  0x8(%ebp)
    c1e2:	e8 d3 e6 ff ff       	call   a8ba <rgba16ToPixel>
    c1e7:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    c1ea:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c1ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c1f1:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    c1f4:	75 84                	jne    c17a <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    c1f6:	e9 e6 00 00 00       	jmp    c2e1 <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    c1fb:	8b 45 10             	mov    0x10(%ebp),%eax
    c1fe:	8b 40 04             	mov    0x4(%eax),%eax
    c201:	83 f8 08             	cmp    $0x8,%eax
    c204:	75 23                	jne    c229 <lodepng_convert+0x27e>
    c206:	8b 45 10             	mov    0x10(%ebp),%eax
    c209:	8b 00                	mov    (%eax),%eax
    c20b:	83 f8 06             	cmp    $0x6,%eax
    c20e:	75 19                	jne    c229 <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    c210:	ff 75 14             	pushl  0x14(%ebp)
    c213:	ff 75 0c             	pushl  0xc(%ebp)
    c216:	ff 75 e0             	pushl  -0x20(%ebp)
    c219:	ff 75 08             	pushl  0x8(%ebp)
    c21c:	e8 ae ee ff ff       	call   b0cf <getPixelColorsRGBA8>
    c221:	83 c4 10             	add    $0x10,%esp
    c224:	e9 b8 00 00 00       	jmp    c2e1 <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    c229:	8b 45 10             	mov    0x10(%ebp),%eax
    c22c:	8b 40 04             	mov    0x4(%eax),%eax
    c22f:	83 f8 08             	cmp    $0x8,%eax
    c232:	75 23                	jne    c257 <lodepng_convert+0x2ac>
    c234:	8b 45 10             	mov    0x10(%ebp),%eax
    c237:	8b 00                	mov    (%eax),%eax
    c239:	83 f8 02             	cmp    $0x2,%eax
    c23c:	75 19                	jne    c257 <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    c23e:	ff 75 14             	pushl  0x14(%ebp)
    c241:	ff 75 0c             	pushl  0xc(%ebp)
    c244:	ff 75 e0             	pushl  -0x20(%ebp)
    c247:	ff 75 08             	pushl  0x8(%ebp)
    c24a:	e8 50 f5 ff ff       	call   b79f <getPixelColorsRGB8>
    c24f:	83 c4 10             	add    $0x10,%esp
    c252:	e9 8a 00 00 00       	jmp    c2e1 <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    c257:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    c25b:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    c25f:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    c263:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    c267:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c26e:	eb 66                	jmp    c2d6 <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c270:	83 ec 04             	sub    $0x4,%esp
    c273:	ff 75 14             	pushl  0x14(%ebp)
    c276:	ff 75 f4             	pushl  -0xc(%ebp)
    c279:	ff 75 0c             	pushl  0xc(%ebp)
    c27c:	8d 45 84             	lea    -0x7c(%ebp),%eax
    c27f:	50                   	push   %eax
    c280:	8d 45 85             	lea    -0x7b(%ebp),%eax
    c283:	50                   	push   %eax
    c284:	8d 45 86             	lea    -0x7a(%ebp),%eax
    c287:	50                   	push   %eax
    c288:	8d 45 87             	lea    -0x79(%ebp),%eax
    c28b:	50                   	push   %eax
    c28c:	e8 71 e8 ff ff       	call   ab02 <getPixelColorRGBA8>
    c291:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    c294:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    c298:	0f b6 d8             	movzbl %al,%ebx
    c29b:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    c29f:	0f b6 c8             	movzbl %al,%ecx
    c2a2:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    c2a6:	0f b6 d0             	movzbl %al,%edx
    c2a9:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    c2ad:	0f b6 c0             	movzbl %al,%eax
    c2b0:	53                   	push   %ebx
    c2b1:	51                   	push   %ecx
    c2b2:	52                   	push   %edx
    c2b3:	50                   	push   %eax
    c2b4:	8d 45 90             	lea    -0x70(%ebp),%eax
    c2b7:	50                   	push   %eax
    c2b8:	ff 75 10             	pushl  0x10(%ebp)
    c2bb:	ff 75 f4             	pushl  -0xc(%ebp)
    c2be:	ff 75 08             	pushl  0x8(%ebp)
    c2c1:	e8 e5 e1 ff ff       	call   a4ab <rgba8ToPixel>
    c2c6:	83 c4 20             	add    $0x20,%esp
    c2c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    c2cc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c2d0:	75 0e                	jne    c2e0 <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    c2d2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c2d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c2d9:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    c2dc:	75 92                	jne    c270 <lodepng_convert+0x2c5>
    c2de:	eb 01                	jmp    c2e1 <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    c2e0:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    c2e1:	8b 45 10             	mov    0x10(%ebp),%eax
    c2e4:	8b 00                	mov    (%eax),%eax
    c2e6:	83 f8 03             	cmp    $0x3,%eax
    c2e9:	75 0f                	jne    c2fa <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    c2eb:	83 ec 0c             	sub    $0xc,%esp
    c2ee:	8d 45 90             	lea    -0x70(%ebp),%eax
    c2f1:	50                   	push   %eax
    c2f2:	e8 59 df ff ff       	call   a250 <color_tree_cleanup>
    c2f7:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    c2fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    c2fd:	8d 65 f8             	lea    -0x8(%ebp),%esp
    c300:	5b                   	pop    %ebx
    c301:	5e                   	pop    %esi
    c302:	5d                   	pop    %ebp
    c303:	c3                   	ret    

0000c304 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    c304:	55                   	push   %ebp
    c305:	89 e5                	mov    %esp,%ebp
    c307:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    c30a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    c311:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c318:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    c31f:	8b 45 24             	mov    0x24(%ebp),%eax
    c322:	8b 40 04             	mov    0x4(%eax),%eax
    c325:	ba 01 00 00 00       	mov    $0x1,%edx
    c32a:	89 c1                	mov    %eax,%ecx
    c32c:	d3 e2                	shl    %cl,%edx
    c32e:	89 d0                	mov    %edx,%eax
    c330:	8d 48 ff             	lea    -0x1(%eax),%ecx
    c333:	b8 ff ff 00 00       	mov    $0xffff,%eax
    c338:	ba 00 00 00 00       	mov    $0x0,%edx
    c33d:	f7 f1                	div    %ecx
    c33f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    c342:	8b 45 20             	mov    0x20(%ebp),%eax
    c345:	8b 40 04             	mov    0x4(%eax),%eax
    c348:	ba 10 00 00 00       	mov    $0x10,%edx
    c34d:	29 c2                	sub    %eax,%edx
    c34f:	89 d0                	mov    %edx,%eax
    c351:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    c354:	8b 45 24             	mov    0x24(%ebp),%eax
    c357:	8b 00                	mov    (%eax),%eax
    c359:	85 c0                	test   %eax,%eax
    c35b:	74 0a                	je     c367 <lodepng_convert_rgb+0x63>
    c35d:	8b 45 24             	mov    0x24(%ebp),%eax
    c360:	8b 00                	mov    (%eax),%eax
    c362:	83 f8 04             	cmp    $0x4,%eax
    c365:	75 1b                	jne    c382 <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    c367:	8b 45 14             	mov    0x14(%ebp),%eax
    c36a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c36e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c371:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c374:	89 45 f8             	mov    %eax,-0x8(%ebp)
    c377:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c37a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    c37d:	e9 c2 00 00 00       	jmp    c444 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    c382:	8b 45 24             	mov    0x24(%ebp),%eax
    c385:	8b 00                	mov    (%eax),%eax
    c387:	83 f8 02             	cmp    $0x2,%eax
    c38a:	74 0a                	je     c396 <lodepng_convert_rgb+0x92>
    c38c:	8b 45 24             	mov    0x24(%ebp),%eax
    c38f:	8b 00                	mov    (%eax),%eax
    c391:	83 f8 06             	cmp    $0x6,%eax
    c394:	75 23                	jne    c3b9 <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    c396:	8b 45 14             	mov    0x14(%ebp),%eax
    c399:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c39d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    c3a0:	8b 45 18             	mov    0x18(%ebp),%eax
    c3a3:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c3a7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    c3aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c3ad:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c3b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c3b4:	e9 8b 00 00 00       	jmp    c444 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    c3b9:	8b 45 24             	mov    0x24(%ebp),%eax
    c3bc:	8b 00                	mov    (%eax),%eax
    c3be:	83 f8 03             	cmp    $0x3,%eax
    c3c1:	75 77                	jne    c43a <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    c3c3:	8b 45 24             	mov    0x24(%ebp),%eax
    c3c6:	8b 40 0c             	mov    0xc(%eax),%eax
    c3c9:	3b 45 14             	cmp    0x14(%ebp),%eax
    c3cc:	77 0a                	ja     c3d8 <lodepng_convert_rgb+0xd4>
    c3ce:	b8 52 00 00 00       	mov    $0x52,%eax
    c3d3:	e9 cb 01 00 00       	jmp    c5a3 <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    c3d8:	8b 45 24             	mov    0x24(%ebp),%eax
    c3db:	8b 40 08             	mov    0x8(%eax),%eax
    c3de:	8b 55 14             	mov    0x14(%ebp),%edx
    c3e1:	c1 e2 02             	shl    $0x2,%edx
    c3e4:	01 d0                	add    %edx,%eax
    c3e6:	0f b6 00             	movzbl (%eax),%eax
    c3e9:	0f b6 d0             	movzbl %al,%edx
    c3ec:	89 d0                	mov    %edx,%eax
    c3ee:	c1 e0 08             	shl    $0x8,%eax
    c3f1:	01 d0                	add    %edx,%eax
    c3f3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    c3f6:	8b 45 24             	mov    0x24(%ebp),%eax
    c3f9:	8b 40 08             	mov    0x8(%eax),%eax
    c3fc:	8b 55 14             	mov    0x14(%ebp),%edx
    c3ff:	c1 e2 02             	shl    $0x2,%edx
    c402:	83 c2 01             	add    $0x1,%edx
    c405:	01 d0                	add    %edx,%eax
    c407:	0f b6 00             	movzbl (%eax),%eax
    c40a:	0f b6 d0             	movzbl %al,%edx
    c40d:	89 d0                	mov    %edx,%eax
    c40f:	c1 e0 08             	shl    $0x8,%eax
    c412:	01 d0                	add    %edx,%eax
    c414:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    c417:	8b 45 24             	mov    0x24(%ebp),%eax
    c41a:	8b 40 08             	mov    0x8(%eax),%eax
    c41d:	8b 55 14             	mov    0x14(%ebp),%edx
    c420:	c1 e2 02             	shl    $0x2,%edx
    c423:	83 c2 02             	add    $0x2,%edx
    c426:	01 d0                	add    %edx,%eax
    c428:	0f b6 00             	movzbl (%eax),%eax
    c42b:	0f b6 d0             	movzbl %al,%edx
    c42e:	89 d0                	mov    %edx,%eax
    c430:	c1 e0 08             	shl    $0x8,%eax
    c433:	01 d0                	add    %edx,%eax
    c435:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c438:	eb 0a                	jmp    c444 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    c43a:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c43f:	e9 5f 01 00 00       	jmp    c5a3 <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    c444:	8b 45 20             	mov    0x20(%ebp),%eax
    c447:	8b 00                	mov    (%eax),%eax
    c449:	85 c0                	test   %eax,%eax
    c44b:	74 0a                	je     c457 <lodepng_convert_rgb+0x153>
    c44d:	8b 45 20             	mov    0x20(%ebp),%eax
    c450:	8b 00                	mov    (%eax),%eax
    c452:	83 f8 04             	cmp    $0x4,%eax
    c455:	75 14                	jne    c46b <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    c457:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c45a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c45d:	89 c1                	mov    %eax,%ecx
    c45f:	d3 ea                	shr    %cl,%edx
    c461:	8b 45 08             	mov    0x8(%ebp),%eax
    c464:	89 10                	mov    %edx,(%eax)
    c466:	e9 33 01 00 00       	jmp    c59e <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    c46b:	8b 45 20             	mov    0x20(%ebp),%eax
    c46e:	8b 00                	mov    (%eax),%eax
    c470:	83 f8 02             	cmp    $0x2,%eax
    c473:	74 0a                	je     c47f <lodepng_convert_rgb+0x17b>
    c475:	8b 45 20             	mov    0x20(%ebp),%eax
    c478:	8b 00                	mov    (%eax),%eax
    c47a:	83 f8 06             	cmp    $0x6,%eax
    c47d:	75 32                	jne    c4b1 <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    c47f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c482:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c485:	89 c1                	mov    %eax,%ecx
    c487:	d3 ea                	shr    %cl,%edx
    c489:	8b 45 08             	mov    0x8(%ebp),%eax
    c48c:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    c48e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c491:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c494:	89 c1                	mov    %eax,%ecx
    c496:	d3 ea                	shr    %cl,%edx
    c498:	8b 45 0c             	mov    0xc(%ebp),%eax
    c49b:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    c49d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c4a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c4a3:	89 c1                	mov    %eax,%ecx
    c4a5:	d3 ea                	shr    %cl,%edx
    c4a7:	8b 45 10             	mov    0x10(%ebp),%eax
    c4aa:	89 10                	mov    %edx,(%eax)
    c4ac:	e9 ed 00 00 00       	jmp    c59e <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    c4b1:	8b 45 20             	mov    0x20(%ebp),%eax
    c4b4:	8b 00                	mov    (%eax),%eax
    c4b6:	83 f8 03             	cmp    $0x3,%eax
    c4b9:	0f 85 d8 00 00 00    	jne    c597 <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    c4bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c4c2:	c1 e8 08             	shr    $0x8,%eax
    c4c5:	89 c2                	mov    %eax,%edx
    c4c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c4ca:	0f b6 c0             	movzbl %al,%eax
    c4cd:	39 c2                	cmp    %eax,%edx
    c4cf:	75 24                	jne    c4f5 <lodepng_convert_rgb+0x1f1>
    c4d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c4d4:	c1 e8 08             	shr    $0x8,%eax
    c4d7:	89 c2                	mov    %eax,%edx
    c4d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c4dc:	0f b6 c0             	movzbl %al,%eax
    c4df:	39 c2                	cmp    %eax,%edx
    c4e1:	75 12                	jne    c4f5 <lodepng_convert_rgb+0x1f1>
    c4e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c4e6:	c1 e8 08             	shr    $0x8,%eax
    c4e9:	89 c2                	mov    %eax,%edx
    c4eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c4ee:	0f b6 c0             	movzbl %al,%eax
    c4f1:	39 c2                	cmp    %eax,%edx
    c4f3:	74 0a                	je     c4ff <lodepng_convert_rgb+0x1fb>
    c4f5:	b8 52 00 00 00       	mov    $0x52,%eax
    c4fa:	e9 a4 00 00 00       	jmp    c5a3 <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    c4ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    c506:	eb 79                	jmp    c581 <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    c508:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c50b:	c1 e0 02             	shl    $0x2,%eax
    c50e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c511:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c514:	c1 e8 08             	shr    $0x8,%eax
    c517:	89 c1                	mov    %eax,%ecx
    c519:	8b 45 20             	mov    0x20(%ebp),%eax
    c51c:	8b 50 08             	mov    0x8(%eax),%edx
    c51f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c522:	01 d0                	add    %edx,%eax
    c524:	0f b6 00             	movzbl (%eax),%eax
    c527:	0f b6 c0             	movzbl %al,%eax
    c52a:	39 c1                	cmp    %eax,%ecx
    c52c:	75 4f                	jne    c57d <lodepng_convert_rgb+0x279>
    c52e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c531:	c1 e8 08             	shr    $0x8,%eax
    c534:	89 c1                	mov    %eax,%ecx
    c536:	8b 45 20             	mov    0x20(%ebp),%eax
    c539:	8b 40 08             	mov    0x8(%eax),%eax
    c53c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c53f:	83 c2 01             	add    $0x1,%edx
    c542:	01 d0                	add    %edx,%eax
    c544:	0f b6 00             	movzbl (%eax),%eax
    c547:	0f b6 c0             	movzbl %al,%eax
    c54a:	39 c1                	cmp    %eax,%ecx
    c54c:	75 2f                	jne    c57d <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    c54e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c551:	c1 e8 08             	shr    $0x8,%eax
    c554:	89 c1                	mov    %eax,%ecx
    c556:	8b 45 20             	mov    0x20(%ebp),%eax
    c559:	8b 40 08             	mov    0x8(%eax),%eax
    c55c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c55f:	83 c2 02             	add    $0x2,%edx
    c562:	01 d0                	add    %edx,%eax
    c564:	0f b6 00             	movzbl (%eax),%eax
    c567:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c56a:	39 c1                	cmp    %eax,%ecx
    c56c:	75 0f                	jne    c57d <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    c56e:	8b 45 08             	mov    0x8(%ebp),%eax
    c571:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c574:	89 10                	mov    %edx,(%eax)
        return 0;
    c576:	b8 00 00 00 00       	mov    $0x0,%eax
    c57b:	eb 26                	jmp    c5a3 <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    c57d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c581:	8b 45 20             	mov    0x20(%ebp),%eax
    c584:	8b 40 0c             	mov    0xc(%eax),%eax
    c587:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    c58a:	0f 87 78 ff ff ff    	ja     c508 <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    c590:	b8 52 00 00 00       	mov    $0x52,%eax
    c595:	eb 0c                	jmp    c5a3 <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    c597:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c59c:	eb 05                	jmp    c5a3 <lodepng_convert_rgb+0x29f>
  }

  return 0;
    c59e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c5a3:	c9                   	leave  
    c5a4:	c3                   	ret    

0000c5a5 <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    c5a5:	55                   	push   %ebp
    c5a6:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    c5a8:	8b 45 08             	mov    0x8(%ebp),%eax
    c5ab:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    c5b1:	8b 45 08             	mov    0x8(%ebp),%eax
    c5b4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    c5bb:	8b 45 08             	mov    0x8(%ebp),%eax
    c5be:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    c5c4:	8b 45 08             	mov    0x8(%ebp),%eax
    c5c7:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c5cb:	8b 45 08             	mov    0x8(%ebp),%eax
    c5ce:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c5d2:	8b 45 08             	mov    0x8(%ebp),%eax
    c5d5:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c5d9:	8b 45 08             	mov    0x8(%ebp),%eax
    c5dc:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c5e0:	8b 45 08             	mov    0x8(%ebp),%eax
    c5e3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c5ea:	8b 45 08             	mov    0x8(%ebp),%eax
    c5ed:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c5f4:	8b 45 08             	mov    0x8(%ebp),%eax
    c5f7:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c5fe:	00 00 00 
  stats->numpixels = 0;
    c601:	8b 45 08             	mov    0x8(%ebp),%eax
    c604:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c60b:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c60e:	8b 45 08             	mov    0x8(%ebp),%eax
    c611:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c618:	00 00 00 
  stats->allow_greyscale = 1;
    c61b:	8b 45 08             	mov    0x8(%ebp),%eax
    c61e:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c625:	00 00 00 
}
    c628:	90                   	nop
    c629:	5d                   	pop    %ebp
    c62a:	c3                   	ret    

0000c62b <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c62b:	55                   	push   %ebp
    c62c:	89 e5                	mov    %esp,%ebp
    c62e:	53                   	push   %ebx
    c62f:	83 ec 04             	sub    $0x4,%esp
    c632:	8b 45 08             	mov    0x8(%ebp),%eax
    c635:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c638:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c63c:	74 06                	je     c644 <getValueRequiredBits+0x19>
    c63e:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c642:	75 07                	jne    c64b <getValueRequiredBits+0x20>
    c644:	b8 01 00 00 00       	mov    $0x1,%eax
    c649:	eb 6b                	jmp    c6b6 <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c64b:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c64f:	0f b6 d9             	movzbl %cl,%ebx
    c652:	89 da                	mov    %ebx,%edx
    c654:	89 d0                	mov    %edx,%eax
    c656:	c1 e0 04             	shl    $0x4,%eax
    c659:	89 c2                	mov    %eax,%edx
    c65b:	89 d0                	mov    %edx,%eax
    c65d:	c1 e0 04             	shl    $0x4,%eax
    c660:	29 d0                	sub    %edx,%eax
    c662:	01 d8                	add    %ebx,%eax
    c664:	66 c1 e8 08          	shr    $0x8,%ax
    c668:	c0 e8 04             	shr    $0x4,%al
    c66b:	89 c2                	mov    %eax,%edx
    c66d:	c1 e2 04             	shl    $0x4,%edx
    c670:	01 c2                	add    %eax,%edx
    c672:	89 c8                	mov    %ecx,%eax
    c674:	29 d0                	sub    %edx,%eax
    c676:	84 c0                	test   %al,%al
    c678:	75 37                	jne    c6b1 <getValueRequiredBits+0x86>
    c67a:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c67e:	0f b6 d1             	movzbl %cl,%edx
    c681:	89 d0                	mov    %edx,%eax
    c683:	01 c0                	add    %eax,%eax
    c685:	01 d0                	add    %edx,%eax
    c687:	c1 e0 06             	shl    $0x6,%eax
    c68a:	01 d0                	add    %edx,%eax
    c68c:	66 c1 e8 08          	shr    $0x8,%ax
    c690:	c0 e8 06             	shr    $0x6,%al
    c693:	ba 55 00 00 00       	mov    $0x55,%edx
    c698:	0f af c2             	imul   %edx,%eax
    c69b:	29 c1                	sub    %eax,%ecx
    c69d:	89 c8                	mov    %ecx,%eax
    c69f:	84 c0                	test   %al,%al
    c6a1:	75 07                	jne    c6aa <getValueRequiredBits+0x7f>
    c6a3:	b8 02 00 00 00       	mov    $0x2,%eax
    c6a8:	eb 0c                	jmp    c6b6 <getValueRequiredBits+0x8b>
    c6aa:	b8 04 00 00 00       	mov    $0x4,%eax
    c6af:	eb 05                	jmp    c6b6 <getValueRequiredBits+0x8b>
  return 8;
    c6b1:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c6b6:	83 c4 04             	add    $0x4,%esp
    c6b9:	5b                   	pop    %ebx
    c6ba:	5d                   	pop    %ebp
    c6bb:	c3                   	ret    

0000c6bc <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c6bc:	55                   	push   %ebp
    c6bd:	89 e5                	mov    %esp,%ebp
    c6bf:	56                   	push   %esi
    c6c0:	53                   	push   %ebx
    c6c1:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c6c7:	8b 55 10             	mov    0x10(%ebp),%edx
    c6ca:	8b 45 14             	mov    0x14(%ebp),%eax
    c6cd:	0f af c2             	imul   %edx,%eax
    c6d0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c6d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c6da:	ff 75 18             	pushl  0x18(%ebp)
    c6dd:	e8 0b cd ff ff       	call   93ed <lodepng_is_greyscale_type>
    c6e2:	83 c4 04             	add    $0x4,%esp
    c6e5:	85 c0                	test   %eax,%eax
    c6e7:	0f 95 c0             	setne  %al
    c6ea:	0f b6 c0             	movzbl %al,%eax
    c6ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c6f0:	ff 75 18             	pushl  0x18(%ebp)
    c6f3:	e8 85 cd ff ff       	call   947d <lodepng_can_have_alpha>
    c6f8:	83 c4 04             	add    $0x4,%esp
    c6fb:	85 c0                	test   %eax,%eax
    c6fd:	0f 94 c0             	sete   %al
    c700:	0f b6 c0             	movzbl %al,%eax
    c703:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c706:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c70d:	ff 75 18             	pushl  0x18(%ebp)
    c710:	e8 ab cc ff ff       	call   93c0 <lodepng_get_bpp>
    c715:	83 c4 04             	add    $0x4,%esp
    c718:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c71b:	8b 45 08             	mov    0x8(%ebp),%eax
    c71e:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c724:	83 f8 01             	cmp    $0x1,%eax
    c727:	75 0d                	jne    c736 <lodepng_compute_color_stats+0x7a>
    c729:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c72d:	75 07                	jne    c736 <lodepng_compute_color_stats+0x7a>
    c72f:	b8 01 00 00 00       	mov    $0x1,%eax
    c734:	eb 05                	jmp    c73b <lodepng_compute_color_stats+0x7f>
    c736:	b8 00 00 00 00       	mov    $0x0,%eax
    c73b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c73e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c745:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c74c:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c750:	77 26                	ja     c778 <lodepng_compute_color_stats+0xbc>
    c752:	8b 45 08             	mov    0x8(%ebp),%eax
    c755:	8b 50 14             	mov    0x14(%eax),%edx
    c758:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c75b:	bb 01 00 00 00       	mov    $0x1,%ebx
    c760:	89 c1                	mov    %eax,%ecx
    c762:	d3 e3                	shl    %cl,%ebx
    c764:	89 d8                	mov    %ebx,%eax
    c766:	01 d0                	add    %edx,%eax
    c768:	ba 01 01 00 00       	mov    $0x101,%edx
    c76d:	3d 01 01 00 00       	cmp    $0x101,%eax
    c772:	0f 47 c2             	cmova  %edx,%eax
    c775:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c778:	8b 45 08             	mov    0x8(%ebp),%eax
    c77b:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c781:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c784:	01 c2                	add    %eax,%edx
    c786:	8b 45 08             	mov    0x8(%ebp),%eax
    c789:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c78f:	8b 45 08             	mov    0x8(%ebp),%eax
    c792:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c798:	85 c0                	test   %eax,%eax
    c79a:	75 07                	jne    c7a3 <lodepng_compute_color_stats+0xe7>
    c79c:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c7a3:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c7a9:	50                   	push   %eax
    c7aa:	e8 81 da ff ff       	call   a230 <color_tree_init>
    c7af:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c7b2:	8b 45 08             	mov    0x8(%ebp),%eax
    c7b5:	8b 40 10             	mov    0x10(%eax),%eax
    c7b8:	85 c0                	test   %eax,%eax
    c7ba:	74 07                	je     c7c3 <lodepng_compute_color_stats+0x107>
    c7bc:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c7c3:	8b 45 08             	mov    0x8(%ebp),%eax
    c7c6:	8b 00                	mov    (%eax),%eax
    c7c8:	85 c0                	test   %eax,%eax
    c7ca:	74 07                	je     c7d3 <lodepng_compute_color_stats+0x117>
    c7cc:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c7d3:	8b 45 08             	mov    0x8(%ebp),%eax
    c7d6:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c7dc:	83 f8 10             	cmp    $0x10,%eax
    c7df:	75 07                	jne    c7e8 <lodepng_compute_color_stats+0x12c>
    c7e1:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c7e8:	8b 45 08             	mov    0x8(%ebp),%eax
    c7eb:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c7f1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c7f4:	72 07                	jb     c7fd <lodepng_compute_color_stats+0x141>
    c7f6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c7fd:	8b 45 08             	mov    0x8(%ebp),%eax
    c800:	8b 40 14             	mov    0x14(%eax),%eax
    c803:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c806:	72 07                	jb     c80f <lodepng_compute_color_stats+0x153>
    c808:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c80f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c813:	0f 85 82 00 00 00    	jne    c89b <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c819:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c820:	eb 6c                	jmp    c88e <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c822:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c825:	c1 e0 02             	shl    $0x2,%eax
    c828:	8d 50 10             	lea    0x10(%eax),%edx
    c82b:	8b 45 08             	mov    0x8(%ebp),%eax
    c82e:	01 d0                	add    %edx,%eax
    c830:	83 c0 08             	add    $0x8,%eax
    c833:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c836:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c839:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c83c:	83 c0 03             	add    $0x3,%eax
    c83f:	0f b6 00             	movzbl (%eax),%eax
    c842:	0f b6 d8             	movzbl %al,%ebx
    c845:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c848:	83 c0 02             	add    $0x2,%eax
    c84b:	0f b6 00             	movzbl (%eax),%eax
    c84e:	0f b6 c8             	movzbl %al,%ecx
    c851:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c854:	83 c0 01             	add    $0x1,%eax
    c857:	0f b6 00             	movzbl (%eax),%eax
    c85a:	0f b6 d0             	movzbl %al,%edx
    c85d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c860:	0f b6 00             	movzbl (%eax),%eax
    c863:	0f b6 c0             	movzbl %al,%eax
    c866:	83 ec 08             	sub    $0x8,%esp
    c869:	56                   	push   %esi
    c86a:	53                   	push   %ebx
    c86b:	51                   	push   %ecx
    c86c:	52                   	push   %edx
    c86d:	50                   	push   %eax
    c86e:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c874:	50                   	push   %eax
    c875:	e8 39 db ff ff       	call   a3b3 <color_tree_add>
    c87a:	83 c4 20             	add    $0x20,%esp
    c87d:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    c880:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c884:	0f 85 22 09 00 00    	jne    d1ac <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    c88a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c88e:	8b 45 08             	mov    0x8(%ebp),%eax
    c891:	8b 50 14             	mov    0x14(%eax),%edx
    c894:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c897:	39 c2                	cmp    %eax,%edx
    c899:	77 87                	ja     c822 <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    c89b:	8b 45 18             	mov    0x18(%ebp),%eax
    c89e:	8b 40 04             	mov    0x4(%eax),%eax
    c8a1:	83 f8 10             	cmp    $0x10,%eax
    c8a4:	0f 85 1e 01 00 00    	jne    c9c8 <lodepng_compute_color_stats+0x30c>
    c8aa:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c8ae:	0f 85 14 01 00 00    	jne    c9c8 <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c8b4:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    c8bb:	00 00 
    c8bd:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    c8c4:	00 00 
    c8c6:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    c8cd:	00 00 
    c8cf:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    c8d6:	00 00 
    for(i = 0; i != numpixels; ++i) {
    c8d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c8df:	e9 d8 00 00 00       	jmp    c9bc <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c8e4:	83 ec 04             	sub    $0x4,%esp
    c8e7:	ff 75 18             	pushl  0x18(%ebp)
    c8ea:	ff 75 f4             	pushl  -0xc(%ebp)
    c8ed:	ff 75 0c             	pushl  0xc(%ebp)
    c8f0:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    c8f6:	50                   	push   %eax
    c8f7:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    c8fd:	50                   	push   %eax
    c8fe:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    c904:	50                   	push   %eax
    c905:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    c90b:	50                   	push   %eax
    c90c:	e8 a8 f2 ff ff       	call   bbb9 <getPixelColorRGBA16>
    c911:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c914:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c91b:	66 c1 e8 08          	shr    $0x8,%ax
    c91f:	89 c2                	mov    %eax,%edx
    c921:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c928:	31 d0                	xor    %edx,%eax
    c92a:	0f b7 c0             	movzwl %ax,%eax
    c92d:	0f b6 c0             	movzbl %al,%eax
    c930:	85 c0                	test   %eax,%eax
    c932:	75 60                	jne    c994 <lodepng_compute_color_stats+0x2d8>
    c934:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c93b:	66 c1 e8 08          	shr    $0x8,%ax
    c93f:	89 c2                	mov    %eax,%edx
    c941:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c948:	31 d0                	xor    %edx,%eax
    c94a:	0f b7 c0             	movzwl %ax,%eax
    c94d:	0f b6 c0             	movzbl %al,%eax
    c950:	85 c0                	test   %eax,%eax
    c952:	75 40                	jne    c994 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c954:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c95b:	66 c1 e8 08          	shr    $0x8,%ax
    c95f:	89 c2                	mov    %eax,%edx
    c961:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c968:	31 d0                	xor    %edx,%eax
    c96a:	0f b7 c0             	movzwl %ax,%eax
    c96d:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c970:	85 c0                	test   %eax,%eax
    c972:	75 20                	jne    c994 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c974:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c97b:	66 c1 e8 08          	shr    $0x8,%ax
    c97f:	89 c2                	mov    %eax,%edx
    c981:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c988:	31 d0                	xor    %edx,%eax
    c98a:	0f b7 c0             	movzwl %ax,%eax
    c98d:	0f b6 c0             	movzbl %al,%eax
    c990:	85 c0                	test   %eax,%eax
    c992:	74 24                	je     c9b8 <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    c994:	8b 45 08             	mov    0x8(%ebp),%eax
    c997:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    c99e:	00 00 00 
        sixteen = 1;
    c9a1:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    c9a8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    c9af:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    c9b6:	eb 10                	jmp    c9c8 <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    c9b8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c9bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c9bf:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c9c2:	0f 85 1c ff ff ff    	jne    c8e4 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    c9c8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c9cc:	0f 84 bd 02 00 00    	je     cc8f <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c9d2:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    c9d9:	00 00 
    c9db:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    c9e2:	00 00 
    c9e4:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    c9eb:	00 00 
    c9ed:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    c9f4:	00 00 

    for(i = 0; i != numpixels; ++i) {
    c9f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c9fd:	e9 b1 01 00 00       	jmp    cbb3 <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    ca02:	83 ec 04             	sub    $0x4,%esp
    ca05:	ff 75 18             	pushl  0x18(%ebp)
    ca08:	ff 75 f4             	pushl  -0xc(%ebp)
    ca0b:	ff 75 0c             	pushl  0xc(%ebp)
    ca0e:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    ca14:	50                   	push   %eax
    ca15:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    ca1b:	50                   	push   %eax
    ca1c:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    ca22:	50                   	push   %eax
    ca23:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    ca29:	50                   	push   %eax
    ca2a:	e8 8a f1 ff ff       	call   bbb9 <getPixelColorRGBA16>
    ca2f:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    ca32:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ca36:	75 36                	jne    ca6e <lodepng_compute_color_stats+0x3b2>
    ca38:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    ca3f:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    ca46:	66 39 c2             	cmp    %ax,%dx
    ca49:	75 13                	jne    ca5e <lodepng_compute_color_stats+0x3a2>
    ca4b:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    ca52:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    ca59:	66 39 c2             	cmp    %ax,%dx
    ca5c:	74 10                	je     ca6e <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    ca5e:	8b 45 08             	mov    0x8(%ebp),%eax
    ca61:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    ca67:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    ca6e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ca72:	0f 85 1f 01 00 00    	jne    cb97 <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    ca78:	8b 45 08             	mov    0x8(%ebp),%eax
    ca7b:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    ca7f:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    ca86:	66 39 c2             	cmp    %ax,%dx
    ca89:	75 2d                	jne    cab8 <lodepng_compute_color_stats+0x3fc>
    ca8b:	8b 45 08             	mov    0x8(%ebp),%eax
    ca8e:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    ca92:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    ca99:	66 39 c2             	cmp    %ax,%dx
    ca9c:	75 1a                	jne    cab8 <lodepng_compute_color_stats+0x3fc>
    ca9e:	8b 45 08             	mov    0x8(%ebp),%eax
    caa1:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    caa5:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    caac:	66 39 c2             	cmp    %ax,%dx
    caaf:	75 07                	jne    cab8 <lodepng_compute_color_stats+0x3fc>
    cab1:	b8 01 00 00 00       	mov    $0x1,%eax
    cab6:	eb 05                	jmp    cabd <lodepng_compute_color_stats+0x401>
    cab8:	b8 00 00 00 00       	mov    $0x0,%eax
    cabd:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    cac0:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    cac7:	66 83 f8 ff          	cmp    $0xffff,%ax
    cacb:	74 3c                	je     cb09 <lodepng_compute_color_stats+0x44d>
    cacd:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    cad4:	66 85 c0             	test   %ax,%ax
    cad7:	75 10                	jne    cae9 <lodepng_compute_color_stats+0x42d>
    cad9:	8b 45 08             	mov    0x8(%ebp),%eax
    cadc:	8b 40 04             	mov    0x4(%eax),%eax
    cadf:	85 c0                	test   %eax,%eax
    cae1:	74 26                	je     cb09 <lodepng_compute_color_stats+0x44d>
    cae3:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    cae7:	75 20                	jne    cb09 <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    cae9:	8b 45 08             	mov    0x8(%ebp),%eax
    caec:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    caf3:	8b 45 08             	mov    0x8(%ebp),%eax
    caf6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cafd:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    cb04:	e9 8e 00 00 00       	jmp    cb97 <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    cb09:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    cb10:	66 85 c0             	test   %ax,%ax
    cb13:	75 4a                	jne    cb5f <lodepng_compute_color_stats+0x4a3>
    cb15:	8b 45 08             	mov    0x8(%ebp),%eax
    cb18:	8b 40 10             	mov    0x10(%eax),%eax
    cb1b:	85 c0                	test   %eax,%eax
    cb1d:	75 40                	jne    cb5f <lodepng_compute_color_stats+0x4a3>
    cb1f:	8b 45 08             	mov    0x8(%ebp),%eax
    cb22:	8b 40 04             	mov    0x4(%eax),%eax
    cb25:	85 c0                	test   %eax,%eax
    cb27:	75 36                	jne    cb5f <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    cb29:	8b 45 08             	mov    0x8(%ebp),%eax
    cb2c:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    cb33:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    cb3a:	8b 45 08             	mov    0x8(%ebp),%eax
    cb3d:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    cb41:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    cb48:	8b 45 08             	mov    0x8(%ebp),%eax
    cb4b:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    cb4f:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    cb56:	8b 45 08             	mov    0x8(%ebp),%eax
    cb59:	66 89 50 0c          	mov    %dx,0xc(%eax)
    cb5d:	eb 38                	jmp    cb97 <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    cb5f:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    cb66:	66 83 f8 ff          	cmp    $0xffff,%ax
    cb6a:	75 2b                	jne    cb97 <lodepng_compute_color_stats+0x4db>
    cb6c:	8b 45 08             	mov    0x8(%ebp),%eax
    cb6f:	8b 40 04             	mov    0x4(%eax),%eax
    cb72:	85 c0                	test   %eax,%eax
    cb74:	74 21                	je     cb97 <lodepng_compute_color_stats+0x4db>
    cb76:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    cb7a:	74 1b                	je     cb97 <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cb7c:	8b 45 08             	mov    0x8(%ebp),%eax
    cb7f:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cb86:	8b 45 08             	mov    0x8(%ebp),%eax
    cb89:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cb90:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cb97:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cb9b:	74 12                	je     cbaf <lodepng_compute_color_stats+0x4f3>
    cb9d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cba1:	74 0c                	je     cbaf <lodepng_compute_color_stats+0x4f3>
    cba3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cba7:	74 06                	je     cbaf <lodepng_compute_color_stats+0x4f3>
    cba9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cbad:	75 12                	jne    cbc1 <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    cbaf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cbb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cbb6:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cbb9:	0f 85 43 fe ff ff    	jne    ca02 <lodepng_compute_color_stats+0x346>
    cbbf:	eb 01                	jmp    cbc2 <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cbc1:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    cbc2:	8b 45 08             	mov    0x8(%ebp),%eax
    cbc5:	8b 40 04             	mov    0x4(%eax),%eax
    cbc8:	85 c0                	test   %eax,%eax
    cbca:	0f 84 e0 05 00 00    	je     d1b0 <lodepng_compute_color_stats+0xaf4>
    cbd0:	8b 45 08             	mov    0x8(%ebp),%eax
    cbd3:	8b 40 10             	mov    0x10(%eax),%eax
    cbd6:	85 c0                	test   %eax,%eax
    cbd8:	0f 85 d2 05 00 00    	jne    d1b0 <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    cbde:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cbe5:	e9 94 00 00 00       	jmp    cc7e <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    cbea:	83 ec 04             	sub    $0x4,%esp
    cbed:	ff 75 18             	pushl  0x18(%ebp)
    cbf0:	ff 75 f4             	pushl  -0xc(%ebp)
    cbf3:	ff 75 0c             	pushl  0xc(%ebp)
    cbf6:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    cbfc:	50                   	push   %eax
    cbfd:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    cc03:	50                   	push   %eax
    cc04:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    cc0a:	50                   	push   %eax
    cc0b:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    cc11:	50                   	push   %eax
    cc12:	e8 a2 ef ff ff       	call   bbb9 <getPixelColorRGBA16>
    cc17:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    cc1a:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    cc21:	66 85 c0             	test   %ax,%ax
    cc24:	74 54                	je     cc7a <lodepng_compute_color_stats+0x5be>
    cc26:	8b 45 08             	mov    0x8(%ebp),%eax
    cc29:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    cc2d:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    cc34:	66 39 c2             	cmp    %ax,%dx
    cc37:	75 41                	jne    cc7a <lodepng_compute_color_stats+0x5be>
    cc39:	8b 45 08             	mov    0x8(%ebp),%eax
    cc3c:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cc40:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    cc47:	66 39 c2             	cmp    %ax,%dx
    cc4a:	75 2e                	jne    cc7a <lodepng_compute_color_stats+0x5be>
    cc4c:	8b 45 08             	mov    0x8(%ebp),%eax
    cc4f:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    cc53:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    cc5a:	66 39 c2             	cmp    %ax,%dx
    cc5d:	75 1b                	jne    cc7a <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cc5f:	8b 45 08             	mov    0x8(%ebp),%eax
    cc62:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cc69:	8b 45 08             	mov    0x8(%ebp),%eax
    cc6c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cc73:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    cc7a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cc7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cc81:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cc84:	0f 85 60 ff ff ff    	jne    cbea <lodepng_compute_color_stats+0x52e>
    cc8a:	e9 21 05 00 00       	jmp    d1b0 <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    cc8f:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    cc96:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    cc9d:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    cca4:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    ccab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ccb2:	e9 ab 03 00 00       	jmp    d062 <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    ccb7:	83 ec 04             	sub    $0x4,%esp
    ccba:	ff 75 18             	pushl  0x18(%ebp)
    ccbd:	ff 75 f4             	pushl  -0xc(%ebp)
    ccc0:	ff 75 0c             	pushl  0xc(%ebp)
    ccc3:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    ccc9:	50                   	push   %eax
    ccca:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    ccd0:	50                   	push   %eax
    ccd1:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    ccd7:	50                   	push   %eax
    ccd8:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    ccde:	50                   	push   %eax
    ccdf:	e8 1e de ff ff       	call   ab02 <getPixelColorRGBA8>
    cce4:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    cce7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cceb:	75 41                	jne    cd2e <lodepng_compute_color_stats+0x672>
    cced:	8b 45 08             	mov    0x8(%ebp),%eax
    ccf0:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ccf6:	83 f8 07             	cmp    $0x7,%eax
    ccf9:	77 33                	ja     cd2e <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    ccfb:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cd02:	0f b6 c0             	movzbl %al,%eax
    cd05:	83 ec 0c             	sub    $0xc,%esp
    cd08:	50                   	push   %eax
    cd09:	e8 1d f9 ff ff       	call   c62b <getValueRequiredBits>
    cd0e:	83 c4 10             	add    $0x10,%esp
    cd11:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    cd14:	8b 45 08             	mov    0x8(%ebp),%eax
    cd17:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cd1d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    cd20:	73 0c                	jae    cd2e <lodepng_compute_color_stats+0x672>
    cd22:	8b 45 08             	mov    0x8(%ebp),%eax
    cd25:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    cd28:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    cd2e:	8b 45 08             	mov    0x8(%ebp),%eax
    cd31:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cd37:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    cd3a:	0f 93 c0             	setae  %al
    cd3d:	0f b6 c0             	movzbl %al,%eax
    cd40:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    cd43:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cd47:	75 4f                	jne    cd98 <lodepng_compute_color_stats+0x6dc>
    cd49:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    cd50:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cd57:	38 c2                	cmp    %al,%dl
    cd59:	75 12                	jne    cd6d <lodepng_compute_color_stats+0x6b1>
    cd5b:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    cd62:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cd69:	38 c2                	cmp    %al,%dl
    cd6b:	74 2b                	je     cd98 <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    cd6d:	8b 45 08             	mov    0x8(%ebp),%eax
    cd70:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    cd76:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    cd7d:	8b 45 08             	mov    0x8(%ebp),%eax
    cd80:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cd86:	83 f8 07             	cmp    $0x7,%eax
    cd89:	77 0d                	ja     cd98 <lodepng_compute_color_stats+0x6dc>
    cd8b:	8b 45 08             	mov    0x8(%ebp),%eax
    cd8e:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cd95:	00 00 00 
      }

      if(!alpha_done) {
    cd98:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cd9c:	0f 85 65 01 00 00    	jne    cf07 <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    cda2:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cda9:	0f b6 d0             	movzbl %al,%edx
    cdac:	8b 45 08             	mov    0x8(%ebp),%eax
    cdaf:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cdb3:	66 39 c2             	cmp    %ax,%dx
    cdb6:	75 33                	jne    cdeb <lodepng_compute_color_stats+0x72f>
    cdb8:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cdbf:	0f b6 d0             	movzbl %al,%edx
    cdc2:	8b 45 08             	mov    0x8(%ebp),%eax
    cdc5:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cdc9:	66 39 c2             	cmp    %ax,%dx
    cdcc:	75 1d                	jne    cdeb <lodepng_compute_color_stats+0x72f>
    cdce:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cdd5:	0f b6 d0             	movzbl %al,%edx
    cdd8:	8b 45 08             	mov    0x8(%ebp),%eax
    cddb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cddf:	66 39 c2             	cmp    %ax,%dx
    cde2:	75 07                	jne    cdeb <lodepng_compute_color_stats+0x72f>
    cde4:	b8 01 00 00 00       	mov    $0x1,%eax
    cde9:	eb 05                	jmp    cdf0 <lodepng_compute_color_stats+0x734>
    cdeb:	b8 00 00 00 00       	mov    $0x0,%eax
    cdf0:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    cdf3:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cdfa:	3c ff                	cmp    $0xff,%al
    cdfc:	74 5a                	je     ce58 <lodepng_compute_color_stats+0x79c>
    cdfe:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ce05:	84 c0                	test   %al,%al
    ce07:	75 10                	jne    ce19 <lodepng_compute_color_stats+0x75d>
    ce09:	8b 45 08             	mov    0x8(%ebp),%eax
    ce0c:	8b 40 04             	mov    0x4(%eax),%eax
    ce0f:	85 c0                	test   %eax,%eax
    ce11:	74 45                	je     ce58 <lodepng_compute_color_stats+0x79c>
    ce13:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    ce17:	75 3f                	jne    ce58 <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    ce19:	8b 45 08             	mov    0x8(%ebp),%eax
    ce1c:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    ce23:	8b 45 08             	mov    0x8(%ebp),%eax
    ce26:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    ce2d:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    ce34:	8b 45 08             	mov    0x8(%ebp),%eax
    ce37:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ce3d:	83 f8 07             	cmp    $0x7,%eax
    ce40:	0f 87 c1 00 00 00    	ja     cf07 <lodepng_compute_color_stats+0x84b>
    ce46:	8b 45 08             	mov    0x8(%ebp),%eax
    ce49:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    ce50:	00 00 00 
    ce53:	e9 af 00 00 00       	jmp    cf07 <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    ce58:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ce5f:	84 c0                	test   %al,%al
    ce61:	75 53                	jne    ceb6 <lodepng_compute_color_stats+0x7fa>
    ce63:	8b 45 08             	mov    0x8(%ebp),%eax
    ce66:	8b 40 10             	mov    0x10(%eax),%eax
    ce69:	85 c0                	test   %eax,%eax
    ce6b:	75 49                	jne    ceb6 <lodepng_compute_color_stats+0x7fa>
    ce6d:	8b 45 08             	mov    0x8(%ebp),%eax
    ce70:	8b 40 04             	mov    0x4(%eax),%eax
    ce73:	85 c0                	test   %eax,%eax
    ce75:	75 3f                	jne    ceb6 <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    ce77:	8b 45 08             	mov    0x8(%ebp),%eax
    ce7a:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    ce81:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ce88:	0f b6 d0             	movzbl %al,%edx
    ce8b:	8b 45 08             	mov    0x8(%ebp),%eax
    ce8e:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    ce92:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ce99:	0f b6 d0             	movzbl %al,%edx
    ce9c:	8b 45 08             	mov    0x8(%ebp),%eax
    ce9f:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    cea3:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ceaa:	0f b6 d0             	movzbl %al,%edx
    cead:	8b 45 08             	mov    0x8(%ebp),%eax
    ceb0:	66 89 50 0c          	mov    %dx,0xc(%eax)
    ceb4:	eb 51                	jmp    cf07 <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    ceb6:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cebd:	3c ff                	cmp    $0xff,%al
    cebf:	75 46                	jne    cf07 <lodepng_compute_color_stats+0x84b>
    cec1:	8b 45 08             	mov    0x8(%ebp),%eax
    cec4:	8b 40 04             	mov    0x4(%eax),%eax
    cec7:	85 c0                	test   %eax,%eax
    cec9:	74 3c                	je     cf07 <lodepng_compute_color_stats+0x84b>
    cecb:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    cecf:	74 36                	je     cf07 <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    ced1:	8b 45 08             	mov    0x8(%ebp),%eax
    ced4:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cedb:	8b 45 08             	mov    0x8(%ebp),%eax
    cede:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cee5:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    ceec:	8b 45 08             	mov    0x8(%ebp),%eax
    ceef:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cef5:	83 f8 07             	cmp    $0x7,%eax
    cef8:	77 0d                	ja     cf07 <lodepng_compute_color_stats+0x84b>
    cefa:	8b 45 08             	mov    0x8(%ebp),%eax
    cefd:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cf04:	00 00 00 
        }
      }

      if(!numcolors_done) {
    cf07:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cf0b:	0f 85 35 01 00 00    	jne    d046 <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    cf11:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cf18:	0f b6 d8             	movzbl %al,%ebx
    cf1b:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cf22:	0f b6 c8             	movzbl %al,%ecx
    cf25:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cf2c:	0f b6 d0             	movzbl %al,%edx
    cf2f:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cf36:	0f b6 c0             	movzbl %al,%eax
    cf39:	83 ec 0c             	sub    $0xc,%esp
    cf3c:	53                   	push   %ebx
    cf3d:	51                   	push   %ecx
    cf3e:	52                   	push   %edx
    cf3f:	50                   	push   %eax
    cf40:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cf46:	50                   	push   %eax
    cf47:	e8 1c d4 ff ff       	call   a368 <color_tree_has>
    cf4c:	83 c4 20             	add    $0x20,%esp
    cf4f:	85 c0                	test   %eax,%eax
    cf51:	0f 85 ef 00 00 00    	jne    d046 <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    cf57:	8b 45 08             	mov    0x8(%ebp),%eax
    cf5a:	8b 70 14             	mov    0x14(%eax),%esi
    cf5d:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cf64:	0f b6 d8             	movzbl %al,%ebx
    cf67:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cf6e:	0f b6 c8             	movzbl %al,%ecx
    cf71:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cf78:	0f b6 d0             	movzbl %al,%edx
    cf7b:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cf82:	0f b6 c0             	movzbl %al,%eax
    cf85:	83 ec 08             	sub    $0x8,%esp
    cf88:	56                   	push   %esi
    cf89:	53                   	push   %ebx
    cf8a:	51                   	push   %ecx
    cf8b:	52                   	push   %edx
    cf8c:	50                   	push   %eax
    cf8d:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cf93:	50                   	push   %eax
    cf94:	e8 1a d4 ff ff       	call   a3b3 <color_tree_add>
    cf99:	83 c4 20             	add    $0x20,%esp
    cf9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    cf9f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    cfa3:	0f 85 06 02 00 00    	jne    d1af <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    cfa9:	8b 45 08             	mov    0x8(%ebp),%eax
    cfac:	8b 40 14             	mov    0x14(%eax),%eax
    cfaf:	3d ff 00 00 00       	cmp    $0xff,%eax
    cfb4:	77 6f                	ja     d025 <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    cfb6:	8b 45 08             	mov    0x8(%ebp),%eax
    cfb9:	83 c0 18             	add    $0x18,%eax
    cfbc:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    cfbf:	8b 45 08             	mov    0x8(%ebp),%eax
    cfc2:	8b 40 14             	mov    0x14(%eax),%eax
    cfc5:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    cfc8:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cfcb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    cfd2:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cfd5:	01 c2                	add    %eax,%edx
    cfd7:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cfde:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    cfe0:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cfe3:	c1 e0 02             	shl    $0x2,%eax
    cfe6:	8d 50 01             	lea    0x1(%eax),%edx
    cfe9:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cfec:	01 c2                	add    %eax,%edx
    cfee:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cff5:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    cff7:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cffa:	c1 e0 02             	shl    $0x2,%eax
    cffd:	8d 50 02             	lea    0x2(%eax),%edx
    d000:	8b 45 bc             	mov    -0x44(%ebp),%eax
    d003:	01 c2                	add    %eax,%edx
    d005:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d00c:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    d00e:	8b 45 b8             	mov    -0x48(%ebp),%eax
    d011:	c1 e0 02             	shl    $0x2,%eax
    d014:	8d 50 03             	lea    0x3(%eax),%edx
    d017:	8b 45 bc             	mov    -0x44(%ebp),%eax
    d01a:	01 c2                	add    %eax,%edx
    d01c:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d023:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    d025:	8b 45 08             	mov    0x8(%ebp),%eax
    d028:	8b 40 14             	mov    0x14(%eax),%eax
    d02b:	8d 50 01             	lea    0x1(%eax),%edx
    d02e:	8b 45 08             	mov    0x8(%ebp),%eax
    d031:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    d034:	8b 45 08             	mov    0x8(%ebp),%eax
    d037:	8b 40 14             	mov    0x14(%eax),%eax
    d03a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    d03d:	0f 93 c0             	setae  %al
    d040:	0f b6 c0             	movzbl %al,%eax
    d043:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    d046:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d04a:	74 12                	je     d05e <lodepng_compute_color_stats+0x9a2>
    d04c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d050:	74 0c                	je     d05e <lodepng_compute_color_stats+0x9a2>
    d052:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d056:	74 06                	je     d05e <lodepng_compute_color_stats+0x9a2>
    d058:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d05c:	75 12                	jne    d070 <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    d05e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d062:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d065:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    d068:	0f 85 49 fc ff ff    	jne    ccb7 <lodepng_compute_color_stats+0x5fb>
    d06e:	eb 01                	jmp    d071 <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    d070:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    d071:	8b 45 08             	mov    0x8(%ebp),%eax
    d074:	8b 40 04             	mov    0x4(%eax),%eax
    d077:	85 c0                	test   %eax,%eax
    d079:	0f 84 dd 00 00 00    	je     d15c <lodepng_compute_color_stats+0xaa0>
    d07f:	8b 45 08             	mov    0x8(%ebp),%eax
    d082:	8b 40 10             	mov    0x10(%eax),%eax
    d085:	85 c0                	test   %eax,%eax
    d087:	0f 85 cf 00 00 00    	jne    d15c <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    d08d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d094:	e9 b7 00 00 00       	jmp    d150 <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    d099:	83 ec 04             	sub    $0x4,%esp
    d09c:	ff 75 18             	pushl  0x18(%ebp)
    d09f:	ff 75 f4             	pushl  -0xc(%ebp)
    d0a2:	ff 75 0c             	pushl  0xc(%ebp)
    d0a5:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    d0ab:	50                   	push   %eax
    d0ac:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    d0b2:	50                   	push   %eax
    d0b3:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    d0b9:	50                   	push   %eax
    d0ba:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    d0c0:	50                   	push   %eax
    d0c1:	e8 3c da ff ff       	call   ab02 <getPixelColorRGBA8>
    d0c6:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    d0c9:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d0d0:	84 c0                	test   %al,%al
    d0d2:	74 78                	je     d14c <lodepng_compute_color_stats+0xa90>
    d0d4:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d0db:	0f b6 d0             	movzbl %al,%edx
    d0de:	8b 45 08             	mov    0x8(%ebp),%eax
    d0e1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d0e5:	66 39 c2             	cmp    %ax,%dx
    d0e8:	75 62                	jne    d14c <lodepng_compute_color_stats+0xa90>
    d0ea:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d0f1:	0f b6 d0             	movzbl %al,%edx
    d0f4:	8b 45 08             	mov    0x8(%ebp),%eax
    d0f7:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d0fb:	66 39 c2             	cmp    %ax,%dx
    d0fe:	75 4c                	jne    d14c <lodepng_compute_color_stats+0xa90>
    d100:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d107:	0f b6 d0             	movzbl %al,%edx
    d10a:	8b 45 08             	mov    0x8(%ebp),%eax
    d10d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d111:	66 39 c2             	cmp    %ax,%dx
    d114:	75 36                	jne    d14c <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    d116:	8b 45 08             	mov    0x8(%ebp),%eax
    d119:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    d120:	8b 45 08             	mov    0x8(%ebp),%eax
    d123:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    d12a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    d131:	8b 45 08             	mov    0x8(%ebp),%eax
    d134:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d13a:	83 f8 07             	cmp    $0x7,%eax
    d13d:	77 0d                	ja     d14c <lodepng_compute_color_stats+0xa90>
    d13f:	8b 45 08             	mov    0x8(%ebp),%eax
    d142:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    d149:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    d14c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d150:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d153:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    d156:	0f 85 3d ff ff ff    	jne    d099 <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    d15c:	8b 45 08             	mov    0x8(%ebp),%eax
    d15f:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    d163:	8b 45 08             	mov    0x8(%ebp),%eax
    d166:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d16a:	c1 e0 08             	shl    $0x8,%eax
    d16d:	01 c2                	add    %eax,%edx
    d16f:	8b 45 08             	mov    0x8(%ebp),%eax
    d172:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    d176:	8b 45 08             	mov    0x8(%ebp),%eax
    d179:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    d17d:	8b 45 08             	mov    0x8(%ebp),%eax
    d180:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d184:	c1 e0 08             	shl    $0x8,%eax
    d187:	01 c2                	add    %eax,%edx
    d189:	8b 45 08             	mov    0x8(%ebp),%eax
    d18c:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    d190:	8b 45 08             	mov    0x8(%ebp),%eax
    d193:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    d197:	8b 45 08             	mov    0x8(%ebp),%eax
    d19a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d19e:	c1 e0 08             	shl    $0x8,%eax
    d1a1:	01 c2                	add    %eax,%edx
    d1a3:	8b 45 08             	mov    0x8(%ebp),%eax
    d1a6:	66 89 50 0c          	mov    %dx,0xc(%eax)
    d1aa:	eb 04                	jmp    d1b0 <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    d1ac:	90                   	nop
    d1ad:	eb 01                	jmp    d1b0 <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    d1af:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    d1b0:	83 ec 0c             	sub    $0xc,%esp
    d1b3:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    d1b9:	50                   	push   %eax
    d1ba:	e8 91 d0 ff ff       	call   a250 <color_tree_cleanup>
    d1bf:	83 c4 10             	add    $0x10,%esp
  return error;
    d1c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    d1c5:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d1c8:	5b                   	pop    %ebx
    d1c9:	5e                   	pop    %esi
    d1ca:	5d                   	pop    %ebp
    d1cb:	c3                   	ret    

0000d1cc <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    d1cc:	55                   	push   %ebp
    d1cd:	89 e5                	mov    %esp,%ebp
    d1cf:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    d1d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    d1d9:	8d 45 cc             	lea    -0x34(%ebp),%eax
    d1dc:	50                   	push   %eax
    d1dd:	e8 d1 bd ff ff       	call   8fb3 <lodepng_color_mode_init>
    d1e2:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    d1e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1e8:	c1 e8 08             	shr    $0x8,%eax
    d1eb:	88 45 ec             	mov    %al,-0x14(%ebp)
    d1ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1f1:	88 45 ed             	mov    %al,-0x13(%ebp)
    d1f4:	8b 45 10             	mov    0x10(%ebp),%eax
    d1f7:	c1 e8 08             	shr    $0x8,%eax
    d1fa:	88 45 ee             	mov    %al,-0x12(%ebp)
    d1fd:	8b 45 10             	mov    0x10(%ebp),%eax
    d200:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    d203:	8b 45 14             	mov    0x14(%ebp),%eax
    d206:	c1 e8 08             	shr    $0x8,%eax
    d209:	88 45 f0             	mov    %al,-0x10(%ebp)
    d20c:	8b 45 14             	mov    0x14(%ebp),%eax
    d20f:	88 45 f1             	mov    %al,-0xf(%ebp)
    d212:	8b 45 18             	mov    0x18(%ebp),%eax
    d215:	c1 e8 08             	shr    $0x8,%eax
    d218:	88 45 f2             	mov    %al,-0xe(%ebp)
    d21b:	8b 45 18             	mov    0x18(%ebp),%eax
    d21e:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    d221:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    d228:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    d22f:	83 ec 0c             	sub    $0xc,%esp
    d232:	8d 45 cc             	lea    -0x34(%ebp),%eax
    d235:	50                   	push   %eax
    d236:	6a 01                	push   $0x1
    d238:	6a 01                	push   $0x1
    d23a:	8d 45 ec             	lea    -0x14(%ebp),%eax
    d23d:	50                   	push   %eax
    d23e:	ff 75 08             	pushl  0x8(%ebp)
    d241:	e8 76 f4 ff ff       	call   c6bc <lodepng_compute_color_stats>
    d246:	83 c4 20             	add    $0x20,%esp
    d249:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    d24c:	83 ec 0c             	sub    $0xc,%esp
    d24f:	8d 45 cc             	lea    -0x34(%ebp),%eax
    d252:	50                   	push   %eax
    d253:	e8 4e be ff ff       	call   90a6 <lodepng_color_mode_cleanup>
    d258:	83 c4 10             	add    $0x10,%esp
  return error;
    d25b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d25e:	c9                   	leave  
    d25f:	c3                   	ret    

0000d260 <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    d260:	55                   	push   %ebp
    d261:	89 e5                	mov    %esp,%ebp
    d263:	56                   	push   %esi
    d264:	53                   	push   %ebx
    d265:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    d268:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    d26f:	8b 45 10             	mov    0x10(%ebp),%eax
    d272:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    d278:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    d27b:	8b 45 10             	mov    0x10(%ebp),%eax
    d27e:	8b 40 10             	mov    0x10(%eax),%eax
    d281:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    d284:	8b 45 10             	mov    0x10(%ebp),%eax
    d287:	8b 40 04             	mov    0x4(%eax),%eax
    d28a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    d28d:	8b 45 10             	mov    0x10(%ebp),%eax
    d290:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d296:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    d299:	8b 45 08             	mov    0x8(%ebp),%eax
    d29c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    d2a3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d2a7:	74 21                	je     d2ca <auto_choose_color+0x6a>
    d2a9:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    d2ad:	7f 1b                	jg     d2ca <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    d2af:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    d2b6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    d2bd:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    d2c1:	77 07                	ja     d2ca <auto_choose_color+0x6a>
    d2c3:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    d2ca:	8b 45 10             	mov    0x10(%ebp),%eax
    d2cd:	8b 00                	mov    (%eax),%eax
    d2cf:	85 c0                	test   %eax,%eax
    d2d1:	0f 94 c0             	sete   %al
    d2d4:	0f b6 c0             	movzbl %al,%eax
    d2d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    d2da:	8b 45 10             	mov    0x10(%ebp),%eax
    d2dd:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    d2e3:	85 c0                	test   %eax,%eax
    d2e5:	75 07                	jne    d2ee <auto_choose_color+0x8e>
    d2e7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    d2ee:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d2f2:	75 0d                	jne    d301 <auto_choose_color+0xa1>
    d2f4:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    d2f8:	77 07                	ja     d301 <auto_choose_color+0xa1>
    d2fa:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    d301:	8b 45 10             	mov    0x10(%ebp),%eax
    d304:	8b 40 14             	mov    0x14(%eax),%eax
    d307:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    d30a:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    d30e:	7e 21                	jle    d331 <auto_choose_color+0xd1>
    d310:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    d314:	7e 14                	jle    d32a <auto_choose_color+0xca>
    d316:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    d31a:	7f 07                	jg     d323 <auto_choose_color+0xc3>
    d31c:	b8 04 00 00 00       	mov    $0x4,%eax
    d321:	eb 13                	jmp    d336 <auto_choose_color+0xd6>
    d323:	b8 08 00 00 00       	mov    $0x8,%eax
    d328:	eb 0c                	jmp    d336 <auto_choose_color+0xd6>
    d32a:	b8 02 00 00 00       	mov    $0x2,%eax
    d32f:	eb 05                	jmp    d336 <auto_choose_color+0xd6>
    d331:	b8 01 00 00 00       	mov    $0x1,%eax
    d336:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    d339:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    d340:	7f 13                	jg     d355 <auto_choose_color+0xf5>
    d342:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    d346:	77 0d                	ja     d355 <auto_choose_color+0xf5>
    d348:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    d34c:	74 07                	je     d355 <auto_choose_color+0xf5>
    d34e:	b8 01 00 00 00       	mov    $0x1,%eax
    d353:	eb 05                	jmp    d35a <auto_choose_color+0xfa>
    d355:	b8 00 00 00 00       	mov    $0x0,%eax
    d35a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    d35d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d360:	01 c0                	add    %eax,%eax
    d362:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    d365:	7e 07                	jle    d36e <auto_choose_color+0x10e>
    d367:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    d36e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d372:	74 15                	je     d389 <auto_choose_color+0x129>
    d374:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d378:	75 0f                	jne    d389 <auto_choose_color+0x129>
    d37a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d37d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    d380:	77 07                	ja     d389 <auto_choose_color+0x129>
    d382:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    d389:	8b 45 10             	mov    0x10(%ebp),%eax
    d38c:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    d392:	85 c0                	test   %eax,%eax
    d394:	75 07                	jne    d39d <auto_choose_color+0x13d>
    d396:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    d39d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d3a1:	0f 84 0a 01 00 00    	je     d4b1 <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    d3a7:	8b 45 10             	mov    0x10(%ebp),%eax
    d3aa:	83 c0 18             	add    $0x18,%eax
    d3ad:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    d3b0:	83 ec 0c             	sub    $0xc,%esp
    d3b3:	ff 75 08             	pushl  0x8(%ebp)
    d3b6:	e8 ef be ff ff       	call   92aa <lodepng_palette_clear>
    d3bb:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    d3be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    d3c5:	eb 6e                	jmp    d435 <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    d3c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d3ca:	c1 e0 02             	shl    $0x2,%eax
    d3cd:	8d 50 03             	lea    0x3(%eax),%edx
    d3d0:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d3d3:	01 d0                	add    %edx,%eax
    d3d5:	0f b6 00             	movzbl (%eax),%eax
    d3d8:	0f b6 d8             	movzbl %al,%ebx
    d3db:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d3de:	c1 e0 02             	shl    $0x2,%eax
    d3e1:	8d 50 02             	lea    0x2(%eax),%edx
    d3e4:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d3e7:	01 d0                	add    %edx,%eax
    d3e9:	0f b6 00             	movzbl (%eax),%eax
    d3ec:	0f b6 c8             	movzbl %al,%ecx
    d3ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d3f2:	c1 e0 02             	shl    $0x2,%eax
    d3f5:	8d 50 01             	lea    0x1(%eax),%edx
    d3f8:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d3fb:	01 d0                	add    %edx,%eax
    d3fd:	0f b6 00             	movzbl (%eax),%eax
    d400:	0f b6 d0             	movzbl %al,%edx
    d403:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d406:	c1 e0 02             	shl    $0x2,%eax
    d409:	89 c6                	mov    %eax,%esi
    d40b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d40e:	01 f0                	add    %esi,%eax
    d410:	0f b6 00             	movzbl (%eax),%eax
    d413:	0f b6 c0             	movzbl %al,%eax
    d416:	83 ec 0c             	sub    $0xc,%esp
    d419:	53                   	push   %ebx
    d41a:	51                   	push   %ecx
    d41b:	52                   	push   %edx
    d41c:	50                   	push   %eax
    d41d:	ff 75 08             	pushl  0x8(%ebp)
    d420:	e8 be be ff ff       	call   92e3 <lodepng_palette_add>
    d425:	83 c4 20             	add    $0x20,%esp
    d428:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    d42b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    d42f:	75 13                	jne    d444 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    d431:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    d435:	8b 45 10             	mov    0x10(%ebp),%eax
    d438:	8b 50 14             	mov    0x14(%eax),%edx
    d43b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d43e:	39 c2                	cmp    %eax,%edx
    d440:	75 85                	jne    d3c7 <auto_choose_color+0x167>
    d442:	eb 01                	jmp    d445 <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    d444:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    d445:	8b 45 08             	mov    0x8(%ebp),%eax
    d448:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    d44e:	8b 45 08             	mov    0x8(%ebp),%eax
    d451:	8b 55 d0             	mov    -0x30(%ebp),%edx
    d454:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    d457:	8b 45 0c             	mov    0xc(%ebp),%eax
    d45a:	8b 00                	mov    (%eax),%eax
    d45c:	83 f8 03             	cmp    $0x3,%eax
    d45f:	0f 85 ec 00 00 00    	jne    d551 <auto_choose_color+0x2f1>
    d465:	8b 45 0c             	mov    0xc(%ebp),%eax
    d468:	8b 50 0c             	mov    0xc(%eax),%edx
    d46b:	8b 45 08             	mov    0x8(%ebp),%eax
    d46e:	8b 40 0c             	mov    0xc(%eax),%eax
    d471:	39 c2                	cmp    %eax,%edx
    d473:	0f 8c d8 00 00 00    	jl     d551 <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    d479:	8b 45 0c             	mov    0xc(%ebp),%eax
    d47c:	8b 50 04             	mov    0x4(%eax),%edx
    d47f:	8b 45 08             	mov    0x8(%ebp),%eax
    d482:	8b 40 04             	mov    0x4(%eax),%eax
    d485:	39 c2                	cmp    %eax,%edx
    d487:	0f 85 c4 00 00 00    	jne    d551 <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    d48d:	83 ec 0c             	sub    $0xc,%esp
    d490:	ff 75 08             	pushl  0x8(%ebp)
    d493:	e8 0e bc ff ff       	call   90a6 <lodepng_color_mode_cleanup>
    d498:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    d49b:	83 ec 08             	sub    $0x8,%esp
    d49e:	ff 75 0c             	pushl  0xc(%ebp)
    d4a1:	ff 75 08             	pushl  0x8(%ebp)
    d4a4:	e8 14 bc ff ff       	call   90bd <lodepng_color_mode_copy>
    d4a9:	83 c4 10             	add    $0x10,%esp
    d4ac:	e9 a0 00 00 00       	jmp    d551 <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    d4b1:	8b 45 08             	mov    0x8(%ebp),%eax
    d4b4:	8b 55 dc             	mov    -0x24(%ebp),%edx
    d4b7:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    d4ba:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d4be:	74 14                	je     d4d4 <auto_choose_color+0x274>
    d4c0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d4c4:	74 07                	je     d4cd <auto_choose_color+0x26d>
    d4c6:	b8 04 00 00 00       	mov    $0x4,%eax
    d4cb:	eb 19                	jmp    d4e6 <auto_choose_color+0x286>
    d4cd:	b8 06 00 00 00       	mov    $0x6,%eax
    d4d2:	eb 12                	jmp    d4e6 <auto_choose_color+0x286>
    d4d4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d4d8:	74 07                	je     d4e1 <auto_choose_color+0x281>
    d4da:	b8 00 00 00 00       	mov    $0x0,%eax
    d4df:	eb 05                	jmp    d4e6 <auto_choose_color+0x286>
    d4e1:	b8 02 00 00 00       	mov    $0x2,%eax
    d4e6:	8b 55 08             	mov    0x8(%ebp),%edx
    d4e9:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    d4eb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d4ef:	74 60                	je     d551 <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    d4f1:	8b 45 08             	mov    0x8(%ebp),%eax
    d4f4:	8b 40 04             	mov    0x4(%eax),%eax
    d4f7:	ba 01 00 00 00       	mov    $0x1,%edx
    d4fc:	89 c1                	mov    %eax,%ecx
    d4fe:	d3 e2                	shl    %cl,%edx
    d500:	89 d0                	mov    %edx,%eax
    d502:	83 e8 01             	sub    $0x1,%eax
    d505:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    d508:	8b 45 10             	mov    0x10(%ebp),%eax
    d50b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d50f:	0f b7 c0             	movzwl %ax,%eax
    d512:	23 45 c8             	and    -0x38(%ebp),%eax
    d515:	89 c2                	mov    %eax,%edx
    d517:	8b 45 08             	mov    0x8(%ebp),%eax
    d51a:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    d51d:	8b 45 10             	mov    0x10(%ebp),%eax
    d520:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d524:	0f b7 c0             	movzwl %ax,%eax
    d527:	23 45 c8             	and    -0x38(%ebp),%eax
    d52a:	89 c2                	mov    %eax,%edx
    d52c:	8b 45 08             	mov    0x8(%ebp),%eax
    d52f:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    d532:	8b 45 10             	mov    0x10(%ebp),%eax
    d535:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d539:	0f b7 c0             	movzwl %ax,%eax
    d53c:	23 45 c8             	and    -0x38(%ebp),%eax
    d53f:	89 c2                	mov    %eax,%edx
    d541:	8b 45 08             	mov    0x8(%ebp),%eax
    d544:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    d547:	8b 45 08             	mov    0x8(%ebp),%eax
    d54a:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    d551:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d554:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d557:	5b                   	pop    %ebx
    d558:	5e                   	pop    %esi
    d559:	5d                   	pop    %ebp
    d55a:	c3                   	ret    

0000d55b <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    d55b:	55                   	push   %ebp
    d55c:	89 e5                	mov    %esp,%ebp
    d55e:	83 ec 1c             	sub    $0x1c,%esp
    d561:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d564:	8b 55 0c             	mov    0xc(%ebp),%edx
    d567:	8b 45 10             	mov    0x10(%ebp),%eax
    d56a:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    d56e:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    d572:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    d576:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    d57a:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d57e:	29 c2                	sub    %eax,%edx
    d580:	89 d0                	mov    %edx,%eax
    d582:	99                   	cltd   
    d583:	31 d0                	xor    %edx,%eax
    d585:	29 d0                	sub    %edx,%eax
    d587:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    d58b:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d58f:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d593:	29 c2                	sub    %eax,%edx
    d595:	89 d0                	mov    %edx,%eax
    d597:	99                   	cltd   
    d598:	31 d0                	xor    %edx,%eax
    d59a:	29 d0                	sub    %edx,%eax
    d59c:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    d5a0:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d5a4:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    d5a8:	01 c2                	add    %eax,%edx
    d5aa:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d5ae:	29 c2                	sub    %eax,%edx
    d5b0:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d5b4:	29 c2                	sub    %eax,%edx
    d5b6:	89 d0                	mov    %edx,%eax
    d5b8:	99                   	cltd   
    d5b9:	31 d0                	xor    %edx,%eax
    d5bb:	29 d0                	sub    %edx,%eax
    d5bd:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    d5c1:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d5c5:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d5c9:	7d 10                	jge    d5db <paethPredictor+0x80>
    d5cb:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d5cf:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d5d3:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d5d7:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d5db:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d5df:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d5e3:	7d 06                	jge    d5eb <paethPredictor+0x90>
    d5e5:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d5e9:	eb 04                	jmp    d5ef <paethPredictor+0x94>
    d5eb:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d5ef:	c9                   	leave  
    d5f0:	c3                   	ret    

0000d5f1 <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d5f1:	55                   	push   %ebp
    d5f2:	89 e5                	mov    %esp,%ebp
    d5f4:	56                   	push   %esi
    d5f5:	53                   	push   %ebx
    d5f6:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d5f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d600:	e9 e2 00 00 00       	jmp    d6e7 <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d605:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d608:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d60f:	8b 45 08             	mov    0x8(%ebp),%eax
    d612:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d615:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d618:	8b 14 85 b4 a5 01 00 	mov    0x1a5b4(,%eax,4),%edx
    d61f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d622:	01 c2                	add    %eax,%edx
    d624:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d627:	8b 04 85 7c a5 01 00 	mov    0x1a57c(,%eax,4),%eax
    d62e:	29 c2                	sub    %eax,%edx
    d630:	89 d0                	mov    %edx,%eax
    d632:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d635:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d638:	8b 34 85 b4 a5 01 00 	mov    0x1a5b4(,%eax,4),%esi
    d63f:	89 d8                	mov    %ebx,%eax
    d641:	ba 00 00 00 00       	mov    $0x0,%edx
    d646:	f7 f6                	div    %esi
    d648:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d64a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d64d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d654:	8b 45 0c             	mov    0xc(%ebp),%eax
    d657:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d65a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d65d:	8b 14 85 d0 a5 01 00 	mov    0x1a5d0(,%eax,4),%edx
    d664:	8b 45 20             	mov    0x20(%ebp),%eax
    d667:	01 c2                	add    %eax,%edx
    d669:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d66c:	8b 04 85 98 a5 01 00 	mov    0x1a598(,%eax,4),%eax
    d673:	29 c2                	sub    %eax,%edx
    d675:	89 d0                	mov    %edx,%eax
    d677:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d67a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d67d:	8b 34 85 d0 a5 01 00 	mov    0x1a5d0(,%eax,4),%esi
    d684:	89 d8                	mov    %ebx,%eax
    d686:	ba 00 00 00 00       	mov    $0x0,%edx
    d68b:	f7 f6                	div    %esi
    d68d:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d68f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d692:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d699:	8b 45 08             	mov    0x8(%ebp),%eax
    d69c:	01 d0                	add    %edx,%eax
    d69e:	8b 00                	mov    (%eax),%eax
    d6a0:	85 c0                	test   %eax,%eax
    d6a2:	75 15                	jne    d6b9 <Adam7_getpassvalues+0xc8>
    d6a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6a7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d6ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    d6b1:	01 d0                	add    %edx,%eax
    d6b3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d6b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6bc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d6c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    d6c6:	01 d0                	add    %edx,%eax
    d6c8:	8b 00                	mov    (%eax),%eax
    d6ca:	85 c0                	test   %eax,%eax
    d6cc:	75 15                	jne    d6e3 <Adam7_getpassvalues+0xf2>
    d6ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6d1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d6d8:	8b 45 08             	mov    0x8(%ebp),%eax
    d6db:	01 d0                	add    %edx,%eax
    d6dd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d6e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d6e7:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d6eb:	0f 85 14 ff ff ff    	jne    d605 <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d6f1:	8b 45 18             	mov    0x18(%ebp),%eax
    d6f4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d6fa:	8b 45 18             	mov    0x18(%ebp),%eax
    d6fd:	8b 10                	mov    (%eax),%edx
    d6ff:	8b 45 14             	mov    0x14(%ebp),%eax
    d702:	89 10                	mov    %edx,(%eax)
    d704:	8b 45 14             	mov    0x14(%ebp),%eax
    d707:	8b 10                	mov    (%eax),%edx
    d709:	8b 45 10             	mov    0x10(%ebp),%eax
    d70c:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d70e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d715:	e9 40 01 00 00       	jmp    d85a <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d71a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d71d:	83 c0 01             	add    $0x1,%eax
    d720:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d727:	8b 45 10             	mov    0x10(%ebp),%eax
    d72a:	01 c2                	add    %eax,%edx
    d72c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d72f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d736:	8b 45 10             	mov    0x10(%ebp),%eax
    d739:	01 c8                	add    %ecx,%eax
    d73b:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d73d:	89 c6                	mov    %eax,%esi
    d73f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d742:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d749:	8b 45 08             	mov    0x8(%ebp),%eax
    d74c:	01 c8                	add    %ecx,%eax
    d74e:	8b 00                	mov    (%eax),%eax
    d750:	85 c0                	test   %eax,%eax
    d752:	74 49                	je     d79d <Adam7_getpassvalues+0x1ac>
    d754:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d757:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d75e:	8b 45 0c             	mov    0xc(%ebp),%eax
    d761:	01 c8                	add    %ecx,%eax
    d763:	8b 00                	mov    (%eax),%eax
    d765:	85 c0                	test   %eax,%eax
    d767:	74 34                	je     d79d <Adam7_getpassvalues+0x1ac>
    d769:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d76c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d773:	8b 45 0c             	mov    0xc(%ebp),%eax
    d776:	01 c8                	add    %ecx,%eax
    d778:	8b 08                	mov    (%eax),%ecx
    d77a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d77d:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d784:	8b 45 08             	mov    0x8(%ebp),%eax
    d787:	01 d8                	add    %ebx,%eax
    d789:	8b 00                	mov    (%eax),%eax
    d78b:	0f af 45 24          	imul   0x24(%ebp),%eax
    d78f:	83 c0 07             	add    $0x7,%eax
    d792:	c1 e8 03             	shr    $0x3,%eax
    d795:	83 c0 01             	add    $0x1,%eax
    d798:	0f af c1             	imul   %ecx,%eax
    d79b:	eb 05                	jmp    d7a2 <Adam7_getpassvalues+0x1b1>
    d79d:	b8 00 00 00 00       	mov    $0x0,%eax
    d7a2:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d7a4:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d7a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7a9:	83 c0 01             	add    $0x1,%eax
    d7ac:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d7b3:	8b 45 14             	mov    0x14(%ebp),%eax
    d7b6:	01 c2                	add    %eax,%edx
    d7b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7bb:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d7c2:	8b 45 14             	mov    0x14(%ebp),%eax
    d7c5:	01 c8                	add    %ecx,%eax
    d7c7:	8b 00                	mov    (%eax),%eax
    d7c9:	89 c6                	mov    %eax,%esi
    d7cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7ce:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d7d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7d8:	01 c8                	add    %ecx,%eax
    d7da:	8b 08                	mov    (%eax),%ecx
    d7dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7df:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d7e6:	8b 45 08             	mov    0x8(%ebp),%eax
    d7e9:	01 d8                	add    %ebx,%eax
    d7eb:	8b 00                	mov    (%eax),%eax
    d7ed:	0f af 45 24          	imul   0x24(%ebp),%eax
    d7f1:	83 c0 07             	add    $0x7,%eax
    d7f4:	c1 e8 03             	shr    $0x3,%eax
    d7f7:	0f af c1             	imul   %ecx,%eax
    d7fa:	01 f0                	add    %esi,%eax
    d7fc:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d7fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d801:	83 c0 01             	add    $0x1,%eax
    d804:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d80b:	8b 45 18             	mov    0x18(%ebp),%eax
    d80e:	01 c2                	add    %eax,%edx
    d810:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d813:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d81a:	8b 45 18             	mov    0x18(%ebp),%eax
    d81d:	01 c8                	add    %ecx,%eax
    d81f:	8b 00                	mov    (%eax),%eax
    d821:	89 c6                	mov    %eax,%esi
    d823:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d826:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d82d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d830:	01 c8                	add    %ecx,%eax
    d832:	8b 08                	mov    (%eax),%ecx
    d834:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d837:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d83e:	8b 45 08             	mov    0x8(%ebp),%eax
    d841:	01 d8                	add    %ebx,%eax
    d843:	8b 00                	mov    (%eax),%eax
    d845:	0f af c1             	imul   %ecx,%eax
    d848:	0f af 45 24          	imul   0x24(%ebp),%eax
    d84c:	83 c0 07             	add    $0x7,%eax
    d84f:	c1 e8 03             	shr    $0x3,%eax
    d852:	01 f0                	add    %esi,%eax
    d854:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d856:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d85a:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d85e:	0f 85 b6 fe ff ff    	jne    d71a <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d864:	90                   	nop
    d865:	83 c4 10             	add    $0x10,%esp
    d868:	5b                   	pop    %ebx
    d869:	5e                   	pop    %esi
    d86a:	5d                   	pop    %ebp
    d86b:	c3                   	ret    

0000d86c <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    d86c:	55                   	push   %ebp
    d86d:	89 e5                	mov    %esp,%ebp
    d86f:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    d872:	8b 45 10             	mov    0x10(%ebp),%eax
    d875:	05 98 00 00 00       	add    $0x98,%eax
    d87a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    d87d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    d881:	74 06                	je     d889 <lodepng_inspect+0x1d>
    d883:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d887:	75 17                	jne    d8a0 <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    d889:	8b 45 10             	mov    0x10(%ebp),%eax
    d88c:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    d893:	00 00 00 
    d896:	b8 30 00 00 00       	mov    $0x30,%eax
    d89b:	e9 ce 02 00 00       	jmp    db6e <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    d8a0:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    d8a4:	7f 17                	jg     d8bd <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    d8a6:	8b 45 10             	mov    0x10(%ebp),%eax
    d8a9:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    d8b0:	00 00 00 
    d8b3:	b8 1b 00 00 00       	mov    $0x1b,%eax
    d8b8:	e9 b1 02 00 00       	jmp    db6e <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    d8bd:	83 ec 0c             	sub    $0xc,%esp
    d8c0:	ff 75 f4             	pushl  -0xc(%ebp)
    d8c3:	e8 63 c7 ff ff       	call   a02b <lodepng_info_cleanup>
    d8c8:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    d8cb:	83 ec 0c             	sub    $0xc,%esp
    d8ce:	ff 75 f4             	pushl  -0xc(%ebp)
    d8d1:	e8 74 c6 ff ff       	call   9f4a <lodepng_info_init>
    d8d6:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    d8d9:	8b 45 14             	mov    0x14(%ebp),%eax
    d8dc:	0f b6 00             	movzbl (%eax),%eax
    d8df:	3c 89                	cmp    $0x89,%al
    d8e1:	75 5b                	jne    d93e <lodepng_inspect+0xd2>
    d8e3:	8b 45 14             	mov    0x14(%ebp),%eax
    d8e6:	83 c0 01             	add    $0x1,%eax
    d8e9:	0f b6 00             	movzbl (%eax),%eax
    d8ec:	3c 50                	cmp    $0x50,%al
    d8ee:	75 4e                	jne    d93e <lodepng_inspect+0xd2>
    d8f0:	8b 45 14             	mov    0x14(%ebp),%eax
    d8f3:	83 c0 02             	add    $0x2,%eax
    d8f6:	0f b6 00             	movzbl (%eax),%eax
    d8f9:	3c 4e                	cmp    $0x4e,%al
    d8fb:	75 41                	jne    d93e <lodepng_inspect+0xd2>
    d8fd:	8b 45 14             	mov    0x14(%ebp),%eax
    d900:	83 c0 03             	add    $0x3,%eax
    d903:	0f b6 00             	movzbl (%eax),%eax
    d906:	3c 47                	cmp    $0x47,%al
    d908:	75 34                	jne    d93e <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    d90a:	8b 45 14             	mov    0x14(%ebp),%eax
    d90d:	83 c0 04             	add    $0x4,%eax
    d910:	0f b6 00             	movzbl (%eax),%eax
    d913:	3c 0d                	cmp    $0xd,%al
    d915:	75 27                	jne    d93e <lodepng_inspect+0xd2>
    d917:	8b 45 14             	mov    0x14(%ebp),%eax
    d91a:	83 c0 05             	add    $0x5,%eax
    d91d:	0f b6 00             	movzbl (%eax),%eax
    d920:	3c 0a                	cmp    $0xa,%al
    d922:	75 1a                	jne    d93e <lodepng_inspect+0xd2>
    d924:	8b 45 14             	mov    0x14(%ebp),%eax
    d927:	83 c0 06             	add    $0x6,%eax
    d92a:	0f b6 00             	movzbl (%eax),%eax
    d92d:	3c 1a                	cmp    $0x1a,%al
    d92f:	75 0d                	jne    d93e <lodepng_inspect+0xd2>
    d931:	8b 45 14             	mov    0x14(%ebp),%eax
    d934:	83 c0 07             	add    $0x7,%eax
    d937:	0f b6 00             	movzbl (%eax),%eax
    d93a:	3c 0a                	cmp    $0xa,%al
    d93c:	74 17                	je     d955 <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    d93e:	8b 45 10             	mov    0x10(%ebp),%eax
    d941:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    d948:	00 00 00 
    d94b:	b8 1c 00 00 00       	mov    $0x1c,%eax
    d950:	e9 19 02 00 00       	jmp    db6e <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    d955:	8b 45 14             	mov    0x14(%ebp),%eax
    d958:	83 c0 08             	add    $0x8,%eax
    d95b:	83 ec 0c             	sub    $0xc,%esp
    d95e:	50                   	push   %eax
    d95f:	e8 c2 ae ff ff       	call   8826 <lodepng_chunk_length>
    d964:	83 c4 10             	add    $0x10,%esp
    d967:	83 f8 0d             	cmp    $0xd,%eax
    d96a:	74 17                	je     d983 <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    d96c:	8b 45 10             	mov    0x10(%ebp),%eax
    d96f:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    d976:	00 00 00 
    d979:	b8 5e 00 00 00       	mov    $0x5e,%eax
    d97e:	e9 eb 01 00 00       	jmp    db6e <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    d983:	8b 45 14             	mov    0x14(%ebp),%eax
    d986:	83 c0 08             	add    $0x8,%eax
    d989:	83 ec 08             	sub    $0x8,%esp
    d98c:	68 ec a5 01 00       	push   $0x1a5ec
    d991:	50                   	push   %eax
    d992:	e8 dc ae ff ff       	call   8873 <lodepng_chunk_type_equals>
    d997:	83 c4 10             	add    $0x10,%esp
    d99a:	84 c0                	test   %al,%al
    d99c:	75 17                	jne    d9b5 <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    d99e:	8b 45 10             	mov    0x10(%ebp),%eax
    d9a1:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    d9a8:	00 00 00 
    d9ab:	b8 1d 00 00 00       	mov    $0x1d,%eax
    d9b0:	e9 b9 01 00 00       	jmp    db6e <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    d9b5:	8b 45 14             	mov    0x14(%ebp),%eax
    d9b8:	83 c0 10             	add    $0x10,%eax
    d9bb:	83 ec 0c             	sub    $0xc,%esp
    d9be:	50                   	push   %eax
    d9bf:	e8 5e 62 ff ff       	call   3c22 <lodepng_read32bitInt>
    d9c4:	83 c4 10             	add    $0x10,%esp
    d9c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    d9ca:	8b 45 14             	mov    0x14(%ebp),%eax
    d9cd:	83 c0 14             	add    $0x14,%eax
    d9d0:	83 ec 0c             	sub    $0xc,%esp
    d9d3:	50                   	push   %eax
    d9d4:	e8 49 62 ff ff       	call   3c22 <lodepng_read32bitInt>
    d9d9:	83 c4 10             	add    $0x10,%esp
    d9dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    d9df:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d9e3:	74 08                	je     d9ed <lodepng_inspect+0x181>
    d9e5:	8b 45 08             	mov    0x8(%ebp),%eax
    d9e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d9eb:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    d9ed:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d9f1:	74 08                	je     d9fb <lodepng_inspect+0x18f>
    d9f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    d9f6:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d9f9:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    d9fb:	8b 45 14             	mov    0x14(%ebp),%eax
    d9fe:	83 c0 18             	add    $0x18,%eax
    da01:	0f b6 00             	movzbl (%eax),%eax
    da04:	0f b6 d0             	movzbl %al,%edx
    da07:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da0a:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    da0d:	8b 45 14             	mov    0x14(%ebp),%eax
    da10:	83 c0 19             	add    $0x19,%eax
    da13:	0f b6 00             	movzbl (%eax),%eax
    da16:	0f b6 d0             	movzbl %al,%edx
    da19:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da1c:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    da1f:	8b 45 14             	mov    0x14(%ebp),%eax
    da22:	83 c0 1a             	add    $0x1a,%eax
    da25:	0f b6 00             	movzbl (%eax),%eax
    da28:	0f b6 d0             	movzbl %al,%edx
    da2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da2e:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    da30:	8b 45 14             	mov    0x14(%ebp),%eax
    da33:	83 c0 1b             	add    $0x1b,%eax
    da36:	0f b6 00             	movzbl (%eax),%eax
    da39:	0f b6 d0             	movzbl %al,%edx
    da3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da3f:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    da42:	8b 45 14             	mov    0x14(%ebp),%eax
    da45:	83 c0 1c             	add    $0x1c,%eax
    da48:	0f b6 00             	movzbl (%eax),%eax
    da4b:	0f b6 d0             	movzbl %al,%edx
    da4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da51:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    da54:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    da58:	74 06                	je     da60 <lodepng_inspect+0x1f4>
    da5a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    da5e:	75 17                	jne    da77 <lodepng_inspect+0x20b>
    da60:	8b 45 10             	mov    0x10(%ebp),%eax
    da63:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    da6a:	00 00 00 
    da6d:	b8 5d 00 00 00       	mov    $0x5d,%eax
    da72:	e9 f7 00 00 00       	jmp    db6e <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    da77:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da7a:	8b 50 10             	mov    0x10(%eax),%edx
    da7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da80:	8b 40 0c             	mov    0xc(%eax),%eax
    da83:	83 ec 08             	sub    $0x8,%esp
    da86:	52                   	push   %edx
    da87:	50                   	push   %eax
    da88:	e8 d4 b3 ff ff       	call   8e61 <checkColorValidity>
    da8d:	83 c4 10             	add    $0x10,%esp
    da90:	89 c2                	mov    %eax,%edx
    da92:	8b 45 10             	mov    0x10(%ebp),%eax
    da95:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    da9b:	8b 45 10             	mov    0x10(%ebp),%eax
    da9e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    daa4:	85 c0                	test   %eax,%eax
    daa6:	74 0e                	je     dab6 <lodepng_inspect+0x24a>
    daa8:	8b 45 10             	mov    0x10(%ebp),%eax
    daab:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    dab1:	e9 b8 00 00 00       	jmp    db6e <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    dab6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dab9:	8b 00                	mov    (%eax),%eax
    dabb:	85 c0                	test   %eax,%eax
    dabd:	74 17                	je     dad6 <lodepng_inspect+0x26a>
    dabf:	8b 45 10             	mov    0x10(%ebp),%eax
    dac2:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    dac9:	00 00 00 
    dacc:	b8 20 00 00 00       	mov    $0x20,%eax
    dad1:	e9 98 00 00 00       	jmp    db6e <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    dad6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dad9:	8b 40 04             	mov    0x4(%eax),%eax
    dadc:	85 c0                	test   %eax,%eax
    dade:	74 14                	je     daf4 <lodepng_inspect+0x288>
    dae0:	8b 45 10             	mov    0x10(%ebp),%eax
    dae3:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    daea:	00 00 00 
    daed:	b8 21 00 00 00       	mov    $0x21,%eax
    daf2:	eb 7a                	jmp    db6e <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    daf4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    daf7:	8b 40 08             	mov    0x8(%eax),%eax
    dafa:	83 f8 01             	cmp    $0x1,%eax
    dafd:	76 14                	jbe    db13 <lodepng_inspect+0x2a7>
    daff:	8b 45 10             	mov    0x10(%ebp),%eax
    db02:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    db09:	00 00 00 
    db0c:	b8 22 00 00 00       	mov    $0x22,%eax
    db11:	eb 5b                	jmp    db6e <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    db13:	8b 45 10             	mov    0x10(%ebp),%eax
    db16:	8b 40 18             	mov    0x18(%eax),%eax
    db19:	85 c0                	test   %eax,%eax
    db1b:	75 48                	jne    db65 <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    db1d:	8b 45 14             	mov    0x14(%ebp),%eax
    db20:	83 c0 1d             	add    $0x1d,%eax
    db23:	83 ec 0c             	sub    $0xc,%esp
    db26:	50                   	push   %eax
    db27:	e8 f6 60 ff ff       	call   3c22 <lodepng_read32bitInt>
    db2c:	83 c4 10             	add    $0x10,%esp
    db2f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    db32:	8b 45 14             	mov    0x14(%ebp),%eax
    db35:	83 c0 0c             	add    $0xc,%eax
    db38:	83 ec 08             	sub    $0x8,%esp
    db3b:	6a 11                	push   $0x11
    db3d:	50                   	push   %eax
    db3e:	e8 71 ab ff ff       	call   86b4 <lodepng_crc32>
    db43:	83 c4 10             	add    $0x10,%esp
    db46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    db49:	8b 45 e8             	mov    -0x18(%ebp),%eax
    db4c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    db4f:	74 14                	je     db65 <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    db51:	8b 45 10             	mov    0x10(%ebp),%eax
    db54:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    db5b:	00 00 00 
    db5e:	b8 39 00 00 00       	mov    $0x39,%eax
    db63:	eb 09                	jmp    db6e <lodepng_inspect+0x302>
    }
  }

  return state->error;
    db65:	8b 45 10             	mov    0x10(%ebp),%eax
    db68:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    db6e:	c9                   	leave  
    db6f:	c3                   	ret    

0000db70 <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    db70:	55                   	push   %ebp
    db71:	89 e5                	mov    %esp,%ebp
    db73:	56                   	push   %esi
    db74:	53                   	push   %ebx
    db75:	83 ec 44             	sub    $0x44,%esp
    db78:	8b 45 18             	mov    0x18(%ebp),%eax
    db7b:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    db7e:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    db82:	83 f8 04             	cmp    $0x4,%eax
    db85:	0f 87 81 07 00 00    	ja     e30c <unfilterScanline+0x79c>
    db8b:	8b 04 85 f4 a5 01 00 	mov    0x1a5f4(,%eax,4),%eax
    db92:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    db94:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    db9b:	eb 19                	jmp    dbb6 <unfilterScanline+0x46>
    db9d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dba0:	8b 45 08             	mov    0x8(%ebp),%eax
    dba3:	01 c2                	add    %eax,%edx
    dba5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dba8:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbab:	01 c8                	add    %ecx,%eax
    dbad:	0f b6 00             	movzbl (%eax),%eax
    dbb0:	88 02                	mov    %al,(%edx)
    dbb2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dbb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbb9:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dbbc:	75 df                	jne    db9d <unfilterScanline+0x2d>
      break;
    dbbe:	e9 50 07 00 00       	jmp    e313 <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    dbc3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dbca:	eb 19                	jmp    dbe5 <unfilterScanline+0x75>
    dbcc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dbcf:	8b 45 08             	mov    0x8(%ebp),%eax
    dbd2:	01 c2                	add    %eax,%edx
    dbd4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dbd7:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbda:	01 c8                	add    %ecx,%eax
    dbdc:	0f b6 00             	movzbl (%eax),%eax
    dbdf:	88 02                	mov    %al,(%edx)
    dbe1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dbe5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbe8:	3b 45 14             	cmp    0x14(%ebp),%eax
    dbeb:	75 df                	jne    dbcc <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    dbed:	8b 45 14             	mov    0x14(%ebp),%eax
    dbf0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    dbf3:	eb 2b                	jmp    dc20 <unfilterScanline+0xb0>
    dbf5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dbf8:	8b 45 08             	mov    0x8(%ebp),%eax
    dbfb:	01 c2                	add    %eax,%edx
    dbfd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dc00:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc03:	01 c8                	add    %ecx,%eax
    dc05:	0f b6 08             	movzbl (%eax),%ecx
    dc08:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc0b:	2b 45 14             	sub    0x14(%ebp),%eax
    dc0e:	89 c3                	mov    %eax,%ebx
    dc10:	8b 45 08             	mov    0x8(%ebp),%eax
    dc13:	01 d8                	add    %ebx,%eax
    dc15:	0f b6 00             	movzbl (%eax),%eax
    dc18:	01 c8                	add    %ecx,%eax
    dc1a:	88 02                	mov    %al,(%edx)
    dc1c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dc20:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc23:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dc26:	7c cd                	jl     dbf5 <unfilterScanline+0x85>
      break;
    dc28:	e9 e6 06 00 00       	jmp    e313 <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    dc2d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    dc31:	74 3c                	je     dc6f <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    dc33:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dc3a:	eb 26                	jmp    dc62 <unfilterScanline+0xf2>
    dc3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc3f:	8b 45 08             	mov    0x8(%ebp),%eax
    dc42:	01 d0                	add    %edx,%eax
    dc44:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dc47:	8b 55 0c             	mov    0xc(%ebp),%edx
    dc4a:	01 ca                	add    %ecx,%edx
    dc4c:	0f b6 0a             	movzbl (%edx),%ecx
    dc4f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    dc52:	8b 55 10             	mov    0x10(%ebp),%edx
    dc55:	01 da                	add    %ebx,%edx
    dc57:	0f b6 12             	movzbl (%edx),%edx
    dc5a:	01 ca                	add    %ecx,%edx
    dc5c:	88 10                	mov    %dl,(%eax)
    dc5e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dc62:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc65:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dc68:	75 d2                	jne    dc3c <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    dc6a:	e9 a4 06 00 00       	jmp    e313 <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    dc6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dc76:	eb 19                	jmp    dc91 <unfilterScanline+0x121>
    dc78:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc7b:	8b 45 08             	mov    0x8(%ebp),%eax
    dc7e:	01 c2                	add    %eax,%edx
    dc80:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dc83:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc86:	01 c8                	add    %ecx,%eax
    dc88:	0f b6 00             	movzbl (%eax),%eax
    dc8b:	88 02                	mov    %al,(%edx)
    dc8d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dc91:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc94:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dc97:	75 df                	jne    dc78 <unfilterScanline+0x108>
      }
      break;
    dc99:	e9 75 06 00 00       	jmp    e313 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    dc9e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    dca2:	0f 84 8e 00 00 00    	je     dd36 <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    dca8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dcaf:	eb 28                	jmp    dcd9 <unfilterScanline+0x169>
    dcb1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcb4:	8b 45 08             	mov    0x8(%ebp),%eax
    dcb7:	01 d0                	add    %edx,%eax
    dcb9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dcbc:	8b 55 0c             	mov    0xc(%ebp),%edx
    dcbf:	01 ca                	add    %ecx,%edx
    dcc1:	0f b6 12             	movzbl (%edx),%edx
    dcc4:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    dcc7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    dcca:	01 d9                	add    %ebx,%ecx
    dccc:	0f b6 09             	movzbl (%ecx),%ecx
    dccf:	d0 e9                	shr    %cl
    dcd1:	01 ca                	add    %ecx,%edx
    dcd3:	88 10                	mov    %dl,(%eax)
    dcd5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dcd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcdc:	3b 45 14             	cmp    0x14(%ebp),%eax
    dcdf:	75 d0                	jne    dcb1 <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    dce1:	8b 45 14             	mov    0x14(%ebp),%eax
    dce4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    dce7:	eb 40                	jmp    dd29 <unfilterScanline+0x1b9>
    dce9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcec:	8b 45 08             	mov    0x8(%ebp),%eax
    dcef:	01 c2                	add    %eax,%edx
    dcf1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dcf4:	8b 45 0c             	mov    0xc(%ebp),%eax
    dcf7:	01 c8                	add    %ecx,%eax
    dcf9:	0f b6 08             	movzbl (%eax),%ecx
    dcfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcff:	2b 45 14             	sub    0x14(%ebp),%eax
    dd02:	89 c3                	mov    %eax,%ebx
    dd04:	8b 45 08             	mov    0x8(%ebp),%eax
    dd07:	01 d8                	add    %ebx,%eax
    dd09:	0f b6 00             	movzbl (%eax),%eax
    dd0c:	0f b6 d8             	movzbl %al,%ebx
    dd0f:	8b 75 f4             	mov    -0xc(%ebp),%esi
    dd12:	8b 45 10             	mov    0x10(%ebp),%eax
    dd15:	01 f0                	add    %esi,%eax
    dd17:	0f b6 00             	movzbl (%eax),%eax
    dd1a:	0f b6 c0             	movzbl %al,%eax
    dd1d:	01 d8                	add    %ebx,%eax
    dd1f:	d1 f8                	sar    %eax
    dd21:	01 c8                	add    %ecx,%eax
    dd23:	88 02                	mov    %al,(%edx)
    dd25:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd29:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd2c:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd2f:	7c b8                	jl     dce9 <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    dd31:	e9 dd 05 00 00       	jmp    e313 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    dd36:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dd3d:	eb 19                	jmp    dd58 <unfilterScanline+0x1e8>
    dd3f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd42:	8b 45 08             	mov    0x8(%ebp),%eax
    dd45:	01 c2                	add    %eax,%edx
    dd47:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd4a:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd4d:	01 c8                	add    %ecx,%eax
    dd4f:	0f b6 00             	movzbl (%eax),%eax
    dd52:	88 02                	mov    %al,(%edx)
    dd54:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd58:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd5b:	3b 45 14             	cmp    0x14(%ebp),%eax
    dd5e:	75 df                	jne    dd3f <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    dd60:	8b 45 14             	mov    0x14(%ebp),%eax
    dd63:	89 45 f4             	mov    %eax,-0xc(%ebp)
    dd66:	eb 2d                	jmp    dd95 <unfilterScanline+0x225>
    dd68:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd6b:	8b 45 08             	mov    0x8(%ebp),%eax
    dd6e:	01 c2                	add    %eax,%edx
    dd70:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd73:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd76:	01 c8                	add    %ecx,%eax
    dd78:	0f b6 08             	movzbl (%eax),%ecx
    dd7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd7e:	2b 45 14             	sub    0x14(%ebp),%eax
    dd81:	89 c3                	mov    %eax,%ebx
    dd83:	8b 45 08             	mov    0x8(%ebp),%eax
    dd86:	01 d8                	add    %ebx,%eax
    dd88:	0f b6 00             	movzbl (%eax),%eax
    dd8b:	d0 e8                	shr    %al
    dd8d:	01 c8                	add    %ecx,%eax
    dd8f:	88 02                	mov    %al,(%edx)
    dd91:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd95:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd98:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd9b:	7c cb                	jl     dd68 <unfilterScanline+0x1f8>
      }
      break;
    dd9d:	e9 71 05 00 00       	jmp    e313 <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    dda2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    dda6:	0f 84 f9 04 00 00    	je     e2a5 <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    ddac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ddb3:	eb 26                	jmp    dddb <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    ddb5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ddb8:	8b 45 08             	mov    0x8(%ebp),%eax
    ddbb:	01 d0                	add    %edx,%eax
    ddbd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ddc0:	8b 55 0c             	mov    0xc(%ebp),%edx
    ddc3:	01 ca                	add    %ecx,%edx
    ddc5:	0f b6 0a             	movzbl (%edx),%ecx
    ddc8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    ddcb:	8b 55 10             	mov    0x10(%ebp),%edx
    ddce:	01 da                	add    %ebx,%edx
    ddd0:	0f b6 12             	movzbl (%edx),%edx
    ddd3:	01 ca                	add    %ecx,%edx
    ddd5:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    ddd7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dddb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddde:	3b 45 14             	cmp    0x14(%ebp),%eax
    dde1:	75 d2                	jne    ddb5 <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    dde3:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    dde7:	0f 8e db 01 00 00    	jle    dfc8 <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    dded:	e9 c2 01 00 00       	jmp    dfb4 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    ddf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddf5:	2b 45 14             	sub    0x14(%ebp),%eax
    ddf8:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    ddfb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ddfe:	8b 45 0c             	mov    0xc(%ebp),%eax
    de01:	01 d0                	add    %edx,%eax
    de03:	0f b6 00             	movzbl (%eax),%eax
    de06:	88 45 ef             	mov    %al,-0x11(%ebp)
    de09:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de0c:	8d 50 01             	lea    0x1(%eax),%edx
    de0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    de12:	01 d0                	add    %edx,%eax
    de14:	0f b6 00             	movzbl (%eax),%eax
    de17:	88 45 ee             	mov    %al,-0x12(%ebp)
    de1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de1d:	8d 50 02             	lea    0x2(%eax),%edx
    de20:	8b 45 0c             	mov    0xc(%ebp),%eax
    de23:	01 d0                	add    %edx,%eax
    de25:	0f b6 00             	movzbl (%eax),%eax
    de28:	88 45 ed             	mov    %al,-0x13(%ebp)
    de2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de2e:	8d 50 03             	lea    0x3(%eax),%edx
    de31:	8b 45 0c             	mov    0xc(%ebp),%eax
    de34:	01 d0                	add    %edx,%eax
    de36:	0f b6 00             	movzbl (%eax),%eax
    de39:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    de3c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    de3f:	8b 45 08             	mov    0x8(%ebp),%eax
    de42:	01 d0                	add    %edx,%eax
    de44:	0f b6 00             	movzbl (%eax),%eax
    de47:	88 45 eb             	mov    %al,-0x15(%ebp)
    de4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    de4d:	8d 50 01             	lea    0x1(%eax),%edx
    de50:	8b 45 08             	mov    0x8(%ebp),%eax
    de53:	01 d0                	add    %edx,%eax
    de55:	0f b6 00             	movzbl (%eax),%eax
    de58:	88 45 ea             	mov    %al,-0x16(%ebp)
    de5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    de5e:	8d 50 02             	lea    0x2(%eax),%edx
    de61:	8b 45 08             	mov    0x8(%ebp),%eax
    de64:	01 d0                	add    %edx,%eax
    de66:	0f b6 00             	movzbl (%eax),%eax
    de69:	88 45 e9             	mov    %al,-0x17(%ebp)
    de6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    de6f:	8d 50 03             	lea    0x3(%eax),%edx
    de72:	8b 45 08             	mov    0x8(%ebp),%eax
    de75:	01 d0                	add    %edx,%eax
    de77:	0f b6 00             	movzbl (%eax),%eax
    de7a:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    de7d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    de80:	8b 45 10             	mov    0x10(%ebp),%eax
    de83:	01 d0                	add    %edx,%eax
    de85:	0f b6 00             	movzbl (%eax),%eax
    de88:	88 45 e7             	mov    %al,-0x19(%ebp)
    de8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de8e:	8d 50 01             	lea    0x1(%eax),%edx
    de91:	8b 45 10             	mov    0x10(%ebp),%eax
    de94:	01 d0                	add    %edx,%eax
    de96:	0f b6 00             	movzbl (%eax),%eax
    de99:	88 45 e6             	mov    %al,-0x1a(%ebp)
    de9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de9f:	8d 50 02             	lea    0x2(%eax),%edx
    dea2:	8b 45 10             	mov    0x10(%ebp),%eax
    dea5:	01 d0                	add    %edx,%eax
    dea7:	0f b6 00             	movzbl (%eax),%eax
    deaa:	88 45 e5             	mov    %al,-0x1b(%ebp)
    dead:	8b 45 f4             	mov    -0xc(%ebp),%eax
    deb0:	8d 50 03             	lea    0x3(%eax),%edx
    deb3:	8b 45 10             	mov    0x10(%ebp),%eax
    deb6:	01 d0                	add    %edx,%eax
    deb8:	0f b6 00             	movzbl (%eax),%eax
    debb:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    debe:	8b 55 f0             	mov    -0x10(%ebp),%edx
    dec1:	8b 45 10             	mov    0x10(%ebp),%eax
    dec4:	01 d0                	add    %edx,%eax
    dec6:	0f b6 00             	movzbl (%eax),%eax
    dec9:	88 45 e3             	mov    %al,-0x1d(%ebp)
    decc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    decf:	8d 50 01             	lea    0x1(%eax),%edx
    ded2:	8b 45 10             	mov    0x10(%ebp),%eax
    ded5:	01 d0                	add    %edx,%eax
    ded7:	0f b6 00             	movzbl (%eax),%eax
    deda:	88 45 e2             	mov    %al,-0x1e(%ebp)
    dedd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dee0:	8d 50 02             	lea    0x2(%eax),%edx
    dee3:	8b 45 10             	mov    0x10(%ebp),%eax
    dee6:	01 d0                	add    %edx,%eax
    dee8:	0f b6 00             	movzbl (%eax),%eax
    deeb:	88 45 e1             	mov    %al,-0x1f(%ebp)
    deee:	8b 45 f0             	mov    -0x10(%ebp),%eax
    def1:	8d 50 03             	lea    0x3(%eax),%edx
    def4:	8b 45 10             	mov    0x10(%ebp),%eax
    def7:	01 d0                	add    %edx,%eax
    def9:	0f b6 00             	movzbl (%eax),%eax
    defc:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    deff:	8b 55 f4             	mov    -0xc(%ebp),%edx
    df02:	8b 45 08             	mov    0x8(%ebp),%eax
    df05:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    df08:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    df0c:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    df10:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    df14:	51                   	push   %ecx
    df15:	52                   	push   %edx
    df16:	50                   	push   %eax
    df17:	e8 3f f6 ff ff       	call   d55b <paethPredictor>
    df1c:	83 c4 0c             	add    $0xc,%esp
    df1f:	89 c2                	mov    %eax,%edx
    df21:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    df25:	01 d0                	add    %edx,%eax
    df27:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    df29:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df2c:	8d 50 01             	lea    0x1(%eax),%edx
    df2f:	8b 45 08             	mov    0x8(%ebp),%eax
    df32:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    df35:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    df39:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    df3d:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    df41:	51                   	push   %ecx
    df42:	52                   	push   %edx
    df43:	50                   	push   %eax
    df44:	e8 12 f6 ff ff       	call   d55b <paethPredictor>
    df49:	83 c4 0c             	add    $0xc,%esp
    df4c:	89 c2                	mov    %eax,%edx
    df4e:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    df52:	01 d0                	add    %edx,%eax
    df54:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    df56:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df59:	8d 50 02             	lea    0x2(%eax),%edx
    df5c:	8b 45 08             	mov    0x8(%ebp),%eax
    df5f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    df62:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    df66:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    df6a:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    df6e:	51                   	push   %ecx
    df6f:	52                   	push   %edx
    df70:	50                   	push   %eax
    df71:	e8 e5 f5 ff ff       	call   d55b <paethPredictor>
    df76:	83 c4 0c             	add    $0xc,%esp
    df79:	89 c2                	mov    %eax,%edx
    df7b:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    df7f:	01 d0                	add    %edx,%eax
    df81:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    df83:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df86:	8d 50 03             	lea    0x3(%eax),%edx
    df89:	8b 45 08             	mov    0x8(%ebp),%eax
    df8c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    df8f:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    df93:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    df97:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    df9b:	51                   	push   %ecx
    df9c:	52                   	push   %edx
    df9d:	50                   	push   %eax
    df9e:	e8 b8 f5 ff ff       	call   d55b <paethPredictor>
    dfa3:	83 c4 0c             	add    $0xc,%esp
    dfa6:	89 c2                	mov    %eax,%edx
    dfa8:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    dfac:	01 d0                	add    %edx,%eax
    dfae:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    dfb0:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    dfb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dfb7:	83 c0 03             	add    $0x3,%eax
    dfba:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dfbd:	0f 8c 2f fe ff ff    	jl     ddf2 <unfilterScanline+0x282>
    dfc3:	e9 d3 02 00 00       	jmp    e29b <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    dfc8:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    dfcc:	0f 8e 6a 01 00 00    	jle    e13c <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    dfd2:	e9 51 01 00 00       	jmp    e128 <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    dfd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dfda:	2b 45 14             	sub    0x14(%ebp),%eax
    dfdd:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    dfe0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dfe3:	8b 45 0c             	mov    0xc(%ebp),%eax
    dfe6:	01 d0                	add    %edx,%eax
    dfe8:	0f b6 00             	movzbl (%eax),%eax
    dfeb:	88 45 db             	mov    %al,-0x25(%ebp)
    dfee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dff1:	8d 50 01             	lea    0x1(%eax),%edx
    dff4:	8b 45 0c             	mov    0xc(%ebp),%eax
    dff7:	01 d0                	add    %edx,%eax
    dff9:	0f b6 00             	movzbl (%eax),%eax
    dffc:	88 45 da             	mov    %al,-0x26(%ebp)
    dfff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e002:	8d 50 02             	lea    0x2(%eax),%edx
    e005:	8b 45 0c             	mov    0xc(%ebp),%eax
    e008:	01 d0                	add    %edx,%eax
    e00a:	0f b6 00             	movzbl (%eax),%eax
    e00d:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    e010:	8b 55 dc             	mov    -0x24(%ebp),%edx
    e013:	8b 45 08             	mov    0x8(%ebp),%eax
    e016:	01 d0                	add    %edx,%eax
    e018:	0f b6 00             	movzbl (%eax),%eax
    e01b:	88 45 d8             	mov    %al,-0x28(%ebp)
    e01e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e021:	8d 50 01             	lea    0x1(%eax),%edx
    e024:	8b 45 08             	mov    0x8(%ebp),%eax
    e027:	01 d0                	add    %edx,%eax
    e029:	0f b6 00             	movzbl (%eax),%eax
    e02c:	88 45 d7             	mov    %al,-0x29(%ebp)
    e02f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e032:	8d 50 02             	lea    0x2(%eax),%edx
    e035:	8b 45 08             	mov    0x8(%ebp),%eax
    e038:	01 d0                	add    %edx,%eax
    e03a:	0f b6 00             	movzbl (%eax),%eax
    e03d:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    e040:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e043:	8b 45 10             	mov    0x10(%ebp),%eax
    e046:	01 d0                	add    %edx,%eax
    e048:	0f b6 00             	movzbl (%eax),%eax
    e04b:	88 45 d5             	mov    %al,-0x2b(%ebp)
    e04e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e051:	8d 50 01             	lea    0x1(%eax),%edx
    e054:	8b 45 10             	mov    0x10(%ebp),%eax
    e057:	01 d0                	add    %edx,%eax
    e059:	0f b6 00             	movzbl (%eax),%eax
    e05c:	88 45 d4             	mov    %al,-0x2c(%ebp)
    e05f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e062:	8d 50 02             	lea    0x2(%eax),%edx
    e065:	8b 45 10             	mov    0x10(%ebp),%eax
    e068:	01 d0                	add    %edx,%eax
    e06a:	0f b6 00             	movzbl (%eax),%eax
    e06d:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    e070:	8b 55 dc             	mov    -0x24(%ebp),%edx
    e073:	8b 45 10             	mov    0x10(%ebp),%eax
    e076:	01 d0                	add    %edx,%eax
    e078:	0f b6 00             	movzbl (%eax),%eax
    e07b:	88 45 d2             	mov    %al,-0x2e(%ebp)
    e07e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e081:	8d 50 01             	lea    0x1(%eax),%edx
    e084:	8b 45 10             	mov    0x10(%ebp),%eax
    e087:	01 d0                	add    %edx,%eax
    e089:	0f b6 00             	movzbl (%eax),%eax
    e08c:	88 45 d1             	mov    %al,-0x2f(%ebp)
    e08f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e092:	8d 50 02             	lea    0x2(%eax),%edx
    e095:	8b 45 10             	mov    0x10(%ebp),%eax
    e098:	01 d0                	add    %edx,%eax
    e09a:	0f b6 00             	movzbl (%eax),%eax
    e09d:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    e0a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e0a3:	8b 45 08             	mov    0x8(%ebp),%eax
    e0a6:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e0a9:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    e0ad:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    e0b1:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    e0b5:	51                   	push   %ecx
    e0b6:	52                   	push   %edx
    e0b7:	50                   	push   %eax
    e0b8:	e8 9e f4 ff ff       	call   d55b <paethPredictor>
    e0bd:	83 c4 0c             	add    $0xc,%esp
    e0c0:	89 c2                	mov    %eax,%edx
    e0c2:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    e0c6:	01 d0                	add    %edx,%eax
    e0c8:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    e0ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e0cd:	8d 50 01             	lea    0x1(%eax),%edx
    e0d0:	8b 45 08             	mov    0x8(%ebp),%eax
    e0d3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e0d6:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    e0da:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    e0de:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    e0e2:	51                   	push   %ecx
    e0e3:	52                   	push   %edx
    e0e4:	50                   	push   %eax
    e0e5:	e8 71 f4 ff ff       	call   d55b <paethPredictor>
    e0ea:	83 c4 0c             	add    $0xc,%esp
    e0ed:	89 c2                	mov    %eax,%edx
    e0ef:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    e0f3:	01 d0                	add    %edx,%eax
    e0f5:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    e0f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e0fa:	8d 50 02             	lea    0x2(%eax),%edx
    e0fd:	8b 45 08             	mov    0x8(%ebp),%eax
    e100:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e103:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    e107:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    e10b:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    e10f:	51                   	push   %ecx
    e110:	52                   	push   %edx
    e111:	50                   	push   %eax
    e112:	e8 44 f4 ff ff       	call   d55b <paethPredictor>
    e117:	83 c4 0c             	add    $0xc,%esp
    e11a:	89 c2                	mov    %eax,%edx
    e11c:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    e120:	01 d0                	add    %edx,%eax
    e122:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    e124:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    e128:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e12b:	83 c0 02             	add    $0x2,%eax
    e12e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e131:	0f 8c a0 fe ff ff    	jl     dfd7 <unfilterScanline+0x467>
    e137:	e9 5f 01 00 00       	jmp    e29b <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    e13c:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    e140:	0f 8e 55 01 00 00    	jle    e29b <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    e146:	e9 e0 00 00 00       	jmp    e22b <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    e14b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e14e:	2b 45 14             	sub    0x14(%ebp),%eax
    e151:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    e154:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e157:	8b 45 0c             	mov    0xc(%ebp),%eax
    e15a:	01 d0                	add    %edx,%eax
    e15c:	0f b6 00             	movzbl (%eax),%eax
    e15f:	88 45 cb             	mov    %al,-0x35(%ebp)
    e162:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e165:	8d 50 01             	lea    0x1(%eax),%edx
    e168:	8b 45 0c             	mov    0xc(%ebp),%eax
    e16b:	01 d0                	add    %edx,%eax
    e16d:	0f b6 00             	movzbl (%eax),%eax
    e170:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    e173:	8b 55 cc             	mov    -0x34(%ebp),%edx
    e176:	8b 45 08             	mov    0x8(%ebp),%eax
    e179:	01 d0                	add    %edx,%eax
    e17b:	0f b6 00             	movzbl (%eax),%eax
    e17e:	88 45 c9             	mov    %al,-0x37(%ebp)
    e181:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e184:	8d 50 01             	lea    0x1(%eax),%edx
    e187:	8b 45 08             	mov    0x8(%ebp),%eax
    e18a:	01 d0                	add    %edx,%eax
    e18c:	0f b6 00             	movzbl (%eax),%eax
    e18f:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    e192:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e195:	8b 45 10             	mov    0x10(%ebp),%eax
    e198:	01 d0                	add    %edx,%eax
    e19a:	0f b6 00             	movzbl (%eax),%eax
    e19d:	88 45 c7             	mov    %al,-0x39(%ebp)
    e1a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1a3:	8d 50 01             	lea    0x1(%eax),%edx
    e1a6:	8b 45 10             	mov    0x10(%ebp),%eax
    e1a9:	01 d0                	add    %edx,%eax
    e1ab:	0f b6 00             	movzbl (%eax),%eax
    e1ae:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    e1b1:	8b 55 cc             	mov    -0x34(%ebp),%edx
    e1b4:	8b 45 10             	mov    0x10(%ebp),%eax
    e1b7:	01 d0                	add    %edx,%eax
    e1b9:	0f b6 00             	movzbl (%eax),%eax
    e1bc:	88 45 c5             	mov    %al,-0x3b(%ebp)
    e1bf:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e1c2:	8d 50 01             	lea    0x1(%eax),%edx
    e1c5:	8b 45 10             	mov    0x10(%ebp),%eax
    e1c8:	01 d0                	add    %edx,%eax
    e1ca:	0f b6 00             	movzbl (%eax),%eax
    e1cd:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    e1d0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e1d3:	8b 45 08             	mov    0x8(%ebp),%eax
    e1d6:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e1d9:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    e1dd:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    e1e1:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    e1e5:	51                   	push   %ecx
    e1e6:	52                   	push   %edx
    e1e7:	50                   	push   %eax
    e1e8:	e8 6e f3 ff ff       	call   d55b <paethPredictor>
    e1ed:	83 c4 0c             	add    $0xc,%esp
    e1f0:	89 c2                	mov    %eax,%edx
    e1f2:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    e1f6:	01 d0                	add    %edx,%eax
    e1f8:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    e1fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1fd:	8d 50 01             	lea    0x1(%eax),%edx
    e200:	8b 45 08             	mov    0x8(%ebp),%eax
    e203:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e206:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    e20a:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    e20e:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    e212:	51                   	push   %ecx
    e213:	52                   	push   %edx
    e214:	50                   	push   %eax
    e215:	e8 41 f3 ff ff       	call   d55b <paethPredictor>
    e21a:	83 c4 0c             	add    $0xc,%esp
    e21d:	89 c2                	mov    %eax,%edx
    e21f:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    e223:	01 d0                	add    %edx,%eax
    e225:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    e227:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    e22b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e22e:	83 c0 01             	add    $0x1,%eax
    e231:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e234:	0f 8c 11 ff ff ff    	jl     e14b <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    e23a:	eb 5f                	jmp    e29b <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    e23c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e23f:	8b 45 08             	mov    0x8(%ebp),%eax
    e242:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e245:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e248:	8b 45 0c             	mov    0xc(%ebp),%eax
    e24b:	01 d0                	add    %edx,%eax
    e24d:	0f b6 00             	movzbl (%eax),%eax
    e250:	88 45 b7             	mov    %al,-0x49(%ebp)
    e253:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e256:	2b 45 14             	sub    0x14(%ebp),%eax
    e259:	89 c2                	mov    %eax,%edx
    e25b:	8b 45 10             	mov    0x10(%ebp),%eax
    e25e:	01 d0                	add    %edx,%eax
    e260:	0f b6 00             	movzbl (%eax),%eax
    e263:	0f b6 c8             	movzbl %al,%ecx
    e266:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e269:	8b 45 10             	mov    0x10(%ebp),%eax
    e26c:	01 d0                	add    %edx,%eax
    e26e:	0f b6 00             	movzbl (%eax),%eax
    e271:	0f b6 d0             	movzbl %al,%edx
    e274:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e277:	2b 45 14             	sub    0x14(%ebp),%eax
    e27a:	89 c6                	mov    %eax,%esi
    e27c:	8b 45 08             	mov    0x8(%ebp),%eax
    e27f:	01 f0                	add    %esi,%eax
    e281:	0f b6 00             	movzbl (%eax),%eax
    e284:	0f b6 c0             	movzbl %al,%eax
    e287:	51                   	push   %ecx
    e288:	52                   	push   %edx
    e289:	50                   	push   %eax
    e28a:	e8 cc f2 ff ff       	call   d55b <paethPredictor>
    e28f:	83 c4 0c             	add    $0xc,%esp
    e292:	02 45 b7             	add    -0x49(%ebp),%al
    e295:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    e297:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e29b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e29e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e2a1:	75 99                	jne    e23c <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    e2a3:	eb 6e                	jmp    e313 <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    e2a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e2ac:	eb 19                	jmp    e2c7 <unfilterScanline+0x757>
          recon[i] = scanline[i];
    e2ae:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e2b1:	8b 45 08             	mov    0x8(%ebp),%eax
    e2b4:	01 c2                	add    %eax,%edx
    e2b6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e2b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    e2bc:	01 c8                	add    %ecx,%eax
    e2be:	0f b6 00             	movzbl (%eax),%eax
    e2c1:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    e2c3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e2c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e2ca:	3b 45 14             	cmp    0x14(%ebp),%eax
    e2cd:	75 df                	jne    e2ae <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    e2cf:	8b 45 14             	mov    0x14(%ebp),%eax
    e2d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e2d5:	eb 2b                	jmp    e302 <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    e2d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e2da:	8b 45 08             	mov    0x8(%ebp),%eax
    e2dd:	01 c2                	add    %eax,%edx
    e2df:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e2e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    e2e5:	01 c8                	add    %ecx,%eax
    e2e7:	0f b6 08             	movzbl (%eax),%ecx
    e2ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e2ed:	2b 45 14             	sub    0x14(%ebp),%eax
    e2f0:	89 c3                	mov    %eax,%ebx
    e2f2:	8b 45 08             	mov    0x8(%ebp),%eax
    e2f5:	01 d8                	add    %ebx,%eax
    e2f7:	0f b6 00             	movzbl (%eax),%eax
    e2fa:	01 c8                	add    %ecx,%eax
    e2fc:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    e2fe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e302:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e305:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e308:	7c cd                	jl     e2d7 <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    e30a:	eb 07                	jmp    e313 <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    e30c:	b8 24 00 00 00       	mov    $0x24,%eax
    e311:	eb 05                	jmp    e318 <unfilterScanline+0x7a8>
  }
  return 0;
    e313:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e318:	8d 65 f8             	lea    -0x8(%ebp),%esp
    e31b:	5b                   	pop    %ebx
    e31c:	5e                   	pop    %esi
    e31d:	5d                   	pop    %ebp
    e31e:	c3                   	ret    

0000e31f <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    e31f:	55                   	push   %ebp
    e320:	89 e5                	mov    %esp,%ebp
    e322:	53                   	push   %ebx
    e323:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    e326:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    e32d:	8b 45 18             	mov    0x18(%ebp),%eax
    e330:	83 c0 07             	add    $0x7,%eax
    e333:	c1 e8 03             	shr    $0x3,%eax
    e336:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    e339:	ff 75 18             	pushl  0x18(%ebp)
    e33c:	6a 01                	push   $0x1
    e33e:	ff 75 10             	pushl  0x10(%ebp)
    e341:	e8 d9 b1 ff ff       	call   951f <lodepng_get_raw_size_idat>
    e346:	83 c4 0c             	add    $0xc,%esp
    e349:	83 e8 01             	sub    $0x1,%eax
    e34c:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    e34f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e356:	eb 6d                	jmp    e3c5 <unfilter+0xa6>
    size_t outindex = linebytes * y;
    e358:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e35b:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e35f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    e362:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e365:	83 c0 01             	add    $0x1,%eax
    e368:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e36c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    e36f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e372:	8b 45 0c             	mov    0xc(%ebp),%eax
    e375:	01 d0                	add    %edx,%eax
    e377:	0f b6 00             	movzbl (%eax),%eax
    e37a:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    e37d:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    e381:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e384:	8d 4a 01             	lea    0x1(%edx),%ecx
    e387:	8b 55 0c             	mov    0xc(%ebp),%edx
    e38a:	01 d1                	add    %edx,%ecx
    e38c:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    e38f:	8b 55 08             	mov    0x8(%ebp),%edx
    e392:	01 da                	add    %ebx,%edx
    e394:	ff 75 ec             	pushl  -0x14(%ebp)
    e397:	50                   	push   %eax
    e398:	ff 75 f0             	pushl  -0x10(%ebp)
    e39b:	ff 75 f4             	pushl  -0xc(%ebp)
    e39e:	51                   	push   %ecx
    e39f:	52                   	push   %edx
    e3a0:	e8 cb f7 ff ff       	call   db70 <unfilterScanline>
    e3a5:	83 c4 18             	add    $0x18,%esp
    e3a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
    e3ab:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    e3af:	74 05                	je     e3b6 <unfilter+0x97>
    e3b1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e3b4:	eb 1c                	jmp    e3d2 <unfilter+0xb3>

    prevline = &out[outindex];
    e3b6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e3b9:	8b 45 08             	mov    0x8(%ebp),%eax
    e3bc:	01 d0                	add    %edx,%eax
    e3be:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    e3c1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e3c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e3c8:	3b 45 14             	cmp    0x14(%ebp),%eax
    e3cb:	72 8b                	jb     e358 <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    e3cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e3d2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    e3d5:	c9                   	leave  
    e3d6:	c3                   	ret    

0000e3d7 <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    e3d7:	55                   	push   %ebp
    e3d8:	89 e5                	mov    %esp,%ebp
    e3da:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e3e0:	ff 75 18             	pushl  0x18(%ebp)
    e3e3:	ff 75 14             	pushl  0x14(%ebp)
    e3e6:	ff 75 10             	pushl  0x10(%ebp)
    e3e9:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    e3ef:	50                   	push   %eax
    e3f0:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    e3f6:	50                   	push   %eax
    e3f7:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    e3fd:	50                   	push   %eax
    e3fe:	8d 45 94             	lea    -0x6c(%ebp),%eax
    e401:	50                   	push   %eax
    e402:	8d 45 b0             	lea    -0x50(%ebp),%eax
    e405:	50                   	push   %eax
    e406:	e8 e6 f1 ff ff       	call   d5f1 <Adam7_getpassvalues>
    e40b:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    e40e:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    e412:	0f 86 0a 01 00 00    	jbe    e522 <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    e418:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e41f:	e9 ef 00 00 00       	jmp    e513 <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    e424:	8b 45 18             	mov    0x18(%ebp),%eax
    e427:	c1 e8 03             	shr    $0x3,%eax
    e42a:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    e42d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e434:	e9 c6 00 00 00       	jmp    e4ff <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    e439:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e440:	e9 a6 00 00 00       	jmp    e4eb <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    e445:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e448:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e44f:	89 c1                	mov    %eax,%ecx
    e451:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e454:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e458:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e45c:	89 c2                	mov    %eax,%edx
    e45e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e461:	01 c2                	add    %eax,%edx
    e463:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e466:	0f af c2             	imul   %edx,%eax
    e469:	01 c8                	add    %ecx,%eax
    e46b:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    e46e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e471:	8b 14 85 98 a5 01 00 	mov    0x1a598(,%eax,4),%edx
    e478:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e47b:	8b 04 85 d0 a5 01 00 	mov    0x1a5d0(,%eax,4),%eax
    e482:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e486:	01 d0                	add    %edx,%eax
    e488:	0f af 45 10          	imul   0x10(%ebp),%eax
    e48c:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    e48e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e491:	8b 04 85 b4 a5 01 00 	mov    0x1a5b4(,%eax,4),%eax
    e498:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e49c:	01 c2                	add    %eax,%edx
    e49e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e4a1:	8b 04 85 7c a5 01 00 	mov    0x1a57c(,%eax,4),%eax
    e4a8:	01 c2                	add    %eax,%edx
    e4aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e4ad:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    e4b0:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e4b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e4ba:	eb 23                	jmp    e4df <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    e4bc:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e4bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e4c2:	01 c2                	add    %eax,%edx
    e4c4:	8b 45 08             	mov    0x8(%ebp),%eax
    e4c7:	01 c2                	add    %eax,%edx
    e4c9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    e4cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e4cf:	01 c1                	add    %eax,%ecx
    e4d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    e4d4:	01 c8                	add    %ecx,%eax
    e4d6:	0f b6 00             	movzbl (%eax),%eax
    e4d9:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e4db:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e4df:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e4e2:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e4e5:	72 d5                	jb     e4bc <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e4e7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e4eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e4ee:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e4f2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    e4f5:	0f 87 4a ff ff ff    	ja     e445 <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    e4fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e4ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e502:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e506:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    e509:	0f 87 2a ff ff ff    	ja     e439 <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    e50f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e513:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e517:	0f 85 07 ff ff ff    	jne    e424 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e51d:	e9 22 01 00 00       	jmp    e644 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e522:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e529:	e9 0c 01 00 00       	jmp    e63a <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    e52e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e531:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e535:	0f af 45 18          	imul   0x18(%ebp),%eax
    e539:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    e53c:	8b 45 18             	mov    0x18(%ebp),%eax
    e53f:	0f af 45 10          	imul   0x10(%ebp),%eax
    e543:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e546:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    e54d:	e9 d4 00 00 00       	jmp    e626 <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    e552:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e559:	e9 b4 00 00 00       	jmp    e612 <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    e55e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e561:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e568:	c1 e0 03             	shl    $0x3,%eax
    e56b:	89 c1                	mov    %eax,%ecx
    e56d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e570:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    e574:	89 c2                	mov    %eax,%edx
    e576:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e579:	0f af 45 18          	imul   0x18(%ebp),%eax
    e57d:	01 d0                	add    %edx,%eax
    e57f:	01 c8                	add    %ecx,%eax
    e581:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    e587:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e58a:	8b 14 85 98 a5 01 00 	mov    0x1a598(,%eax,4),%edx
    e591:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e594:	8b 04 85 d0 a5 01 00 	mov    0x1a5d0(,%eax,4),%eax
    e59b:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    e59f:	01 d0                	add    %edx,%eax
    e5a1:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    e5a5:	89 c2                	mov    %eax,%edx
    e5a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e5aa:	8b 0c 85 7c a5 01 00 	mov    0x1a57c(,%eax,4),%ecx
    e5b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e5b4:	8b 04 85 b4 a5 01 00 	mov    0x1a5b4(,%eax,4),%eax
    e5bb:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e5bf:	01 c8                	add    %ecx,%eax
    e5c1:	0f af 45 18          	imul   0x18(%ebp),%eax
    e5c5:	01 d0                	add    %edx,%eax
    e5c7:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e5cd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e5d4:	eb 30                	jmp    e606 <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e5d6:	ff 75 0c             	pushl  0xc(%ebp)
    e5d9:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e5df:	50                   	push   %eax
    e5e0:	e8 1e a1 ff ff       	call   8703 <readBitFromReversedStream>
    e5e5:	83 c4 08             	add    $0x8,%esp
    e5e8:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e5eb:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e5ef:	50                   	push   %eax
    e5f0:	ff 75 08             	pushl  0x8(%ebp)
    e5f3:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e5f9:	50                   	push   %eax
    e5fa:	e8 86 a1 ff ff       	call   8785 <setBitOfReversedStream>
    e5ff:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e602:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e606:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e609:	3b 45 18             	cmp    0x18(%ebp),%eax
    e60c:	72 c8                	jb     e5d6 <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e60e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e612:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e615:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e619:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e61c:	0f 87 3c ff ff ff    	ja     e55e <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e622:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e626:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e629:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e62d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e630:	0f 87 1c ff ff ff    	ja     e552 <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e636:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e63a:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e63e:	0f 85 ea fe ff ff    	jne    e52e <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e644:	90                   	nop
    e645:	c9                   	leave  
    e646:	c3                   	ret    

0000e647 <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e647:	55                   	push   %ebp
    e648:	89 e5                	mov    %esp,%ebp
    e64a:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e64d:	8b 45 14             	mov    0x14(%ebp),%eax
    e650:	2b 45 10             	sub    0x10(%ebp),%eax
    e653:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e656:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e65d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e664:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e66b:	eb 4a                	jmp    e6b7 <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e66d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e674:	eb 2a                	jmp    e6a0 <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e676:	ff 75 0c             	pushl  0xc(%ebp)
    e679:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e67c:	50                   	push   %eax
    e67d:	e8 81 a0 ff ff       	call   8703 <readBitFromReversedStream>
    e682:	83 c4 08             	add    $0x8,%esp
    e685:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e688:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e68c:	50                   	push   %eax
    e68d:	ff 75 08             	pushl  0x8(%ebp)
    e690:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e693:	50                   	push   %eax
    e694:	e8 ec a0 ff ff       	call   8785 <setBitOfReversedStream>
    e699:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e69c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e6a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e6a3:	3b 45 10             	cmp    0x10(%ebp),%eax
    e6a6:	7c ce                	jl     e676 <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e6a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e6ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e6ae:	01 d0                	add    %edx,%eax
    e6b0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e6b3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e6b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e6ba:	3b 45 18             	cmp    0x18(%ebp),%eax
    e6bd:	72 ae                	jb     e66d <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e6bf:	90                   	nop
    e6c0:	c9                   	leave  
    e6c1:	c3                   	ret    

0000e6c2 <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e6c2:	55                   	push   %ebp
    e6c3:	89 e5                	mov    %esp,%ebp
    e6c5:	57                   	push   %edi
    e6c6:	56                   	push   %esi
    e6c7:	53                   	push   %ebx
    e6c8:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e6ce:	8b 45 18             	mov    0x18(%ebp),%eax
    e6d1:	83 c0 0c             	add    $0xc,%eax
    e6d4:	50                   	push   %eax
    e6d5:	e8 e6 ac ff ff       	call   93c0 <lodepng_get_bpp>
    e6da:	83 c4 04             	add    $0x4,%esp
    e6dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e6e0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e6e4:	75 0a                	jne    e6f0 <postProcessScanlines+0x2e>
    e6e6:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e6eb:	e9 c3 01 00 00       	jmp    e8b3 <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e6f0:	8b 45 18             	mov    0x18(%ebp),%eax
    e6f3:	8b 40 08             	mov    0x8(%eax),%eax
    e6f6:	85 c0                	test   %eax,%eax
    e6f8:	0f 85 a8 00 00 00    	jne    e7a6 <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e6fe:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e702:	77 76                	ja     e77a <postProcessScanlines+0xb8>
    e704:	8b 45 10             	mov    0x10(%ebp),%eax
    e707:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e70b:	89 c2                	mov    %eax,%edx
    e70d:	8b 45 10             	mov    0x10(%ebp),%eax
    e710:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e714:	83 c0 07             	add    $0x7,%eax
    e717:	c1 e8 03             	shr    $0x3,%eax
    e71a:	c1 e0 03             	shl    $0x3,%eax
    e71d:	39 c2                	cmp    %eax,%edx
    e71f:	74 59                	je     e77a <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e721:	ff 75 ec             	pushl  -0x14(%ebp)
    e724:	ff 75 14             	pushl  0x14(%ebp)
    e727:	ff 75 10             	pushl  0x10(%ebp)
    e72a:	ff 75 0c             	pushl  0xc(%ebp)
    e72d:	ff 75 0c             	pushl  0xc(%ebp)
    e730:	e8 ea fb ff ff       	call   e31f <unfilter>
    e735:	83 c4 14             	add    $0x14,%esp
    e738:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e73b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e73f:	74 08                	je     e749 <postProcessScanlines+0x87>
    e741:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e744:	e9 6a 01 00 00       	jmp    e8b3 <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e749:	8b 45 10             	mov    0x10(%ebp),%eax
    e74c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e750:	83 c0 07             	add    $0x7,%eax
    e753:	c1 e8 03             	shr    $0x3,%eax
    e756:	c1 e0 03             	shl    $0x3,%eax
    e759:	89 c2                	mov    %eax,%edx
    e75b:	8b 45 10             	mov    0x10(%ebp),%eax
    e75e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e762:	ff 75 14             	pushl  0x14(%ebp)
    e765:	52                   	push   %edx
    e766:	50                   	push   %eax
    e767:	ff 75 0c             	pushl  0xc(%ebp)
    e76a:	ff 75 08             	pushl  0x8(%ebp)
    e76d:	e8 d5 fe ff ff       	call   e647 <removePaddingBits>
    e772:	83 c4 14             	add    $0x14,%esp
    e775:	e9 34 01 00 00       	jmp    e8ae <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e77a:	ff 75 ec             	pushl  -0x14(%ebp)
    e77d:	ff 75 14             	pushl  0x14(%ebp)
    e780:	ff 75 10             	pushl  0x10(%ebp)
    e783:	ff 75 0c             	pushl  0xc(%ebp)
    e786:	ff 75 08             	pushl  0x8(%ebp)
    e789:	e8 91 fb ff ff       	call   e31f <unfilter>
    e78e:	83 c4 14             	add    $0x14,%esp
    e791:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e794:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e798:	0f 84 10 01 00 00    	je     e8ae <postProcessScanlines+0x1ec>
    e79e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e7a1:	e9 0d 01 00 00       	jmp    e8b3 <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e7a6:	ff 75 ec             	pushl  -0x14(%ebp)
    e7a9:	ff 75 14             	pushl  0x14(%ebp)
    e7ac:	ff 75 10             	pushl  0x10(%ebp)
    e7af:	8d 45 88             	lea    -0x78(%ebp),%eax
    e7b2:	50                   	push   %eax
    e7b3:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e7b9:	50                   	push   %eax
    e7ba:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e7c0:	50                   	push   %eax
    e7c1:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e7c4:	50                   	push   %eax
    e7c5:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e7c8:	50                   	push   %eax
    e7c9:	e8 23 ee ff ff       	call   d5f1 <Adam7_getpassvalues>
    e7ce:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e7d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e7d8:	e9 b0 00 00 00       	jmp    e88d <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e7dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e7e0:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e7e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e7e7:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e7eb:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e7ee:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e7f5:	89 cb                	mov    %ecx,%ebx
    e7f7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e7fa:	01 cb                	add    %ecx,%ebx
    e7fc:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e7ff:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e806:	89 ce                	mov    %ecx,%esi
    e808:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e80b:	01 f1                	add    %esi,%ecx
    e80d:	ff 75 ec             	pushl  -0x14(%ebp)
    e810:	52                   	push   %edx
    e811:	50                   	push   %eax
    e812:	53                   	push   %ebx
    e813:	51                   	push   %ecx
    e814:	e8 06 fb ff ff       	call   e31f <unfilter>
    e819:	83 c4 14             	add    $0x14,%esp
    e81c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e81f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e823:	74 08                	je     e82d <postProcessScanlines+0x16b>
    e825:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e828:	e9 86 00 00 00       	jmp    e8b3 <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e82d:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e831:	77 56                	ja     e889 <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e833:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e836:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e83a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e83d:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e841:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e845:	83 c2 07             	add    $0x7,%edx
    e848:	c1 ea 03             	shr    $0x3,%edx
    e84b:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e84e:	89 d6                	mov    %edx,%esi
    e850:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e853:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e857:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e85b:	89 d3                	mov    %edx,%ebx
    e85d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e860:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    e867:	89 d1                	mov    %edx,%ecx
    e869:	8b 55 0c             	mov    0xc(%ebp),%edx
    e86c:	01 d1                	add    %edx,%ecx
    e86e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e871:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    e875:	89 d7                	mov    %edx,%edi
    e877:	8b 55 0c             	mov    0xc(%ebp),%edx
    e87a:	01 fa                	add    %edi,%edx
    e87c:	50                   	push   %eax
    e87d:	56                   	push   %esi
    e87e:	53                   	push   %ebx
    e87f:	51                   	push   %ecx
    e880:	52                   	push   %edx
    e881:	e8 c1 fd ff ff       	call   e647 <removePaddingBits>
    e886:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    e889:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e88d:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    e891:	0f 85 46 ff ff ff    	jne    e7dd <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    e897:	ff 75 ec             	pushl  -0x14(%ebp)
    e89a:	ff 75 14             	pushl  0x14(%ebp)
    e89d:	ff 75 10             	pushl  0x10(%ebp)
    e8a0:	ff 75 0c             	pushl  0xc(%ebp)
    e8a3:	ff 75 08             	pushl  0x8(%ebp)
    e8a6:	e8 2c fb ff ff       	call   e3d7 <Adam7_deinterlace>
    e8ab:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    e8ae:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e8b3:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e8b6:	5b                   	pop    %ebx
    e8b7:	5e                   	pop    %esi
    e8b8:	5f                   	pop    %edi
    e8b9:	5d                   	pop    %ebp
    e8ba:	c3                   	ret    

0000e8bb <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e8bb:	55                   	push   %ebp
    e8bc:	89 e5                	mov    %esp,%ebp
    e8be:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    e8c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    e8c8:	8b 45 10             	mov    0x10(%ebp),%eax
    e8cb:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    e8d0:	f7 e2                	mul    %edx
    e8d2:	89 d0                	mov    %edx,%eax
    e8d4:	d1 e8                	shr    %eax
    e8d6:	89 c2                	mov    %eax,%edx
    e8d8:	8b 45 08             	mov    0x8(%ebp),%eax
    e8db:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    e8de:	8b 45 08             	mov    0x8(%ebp),%eax
    e8e1:	8b 40 0c             	mov    0xc(%eax),%eax
    e8e4:	85 c0                	test   %eax,%eax
    e8e6:	74 0d                	je     e8f5 <readChunk_PLTE+0x3a>
    e8e8:	8b 45 08             	mov    0x8(%ebp),%eax
    e8eb:	8b 40 0c             	mov    0xc(%eax),%eax
    e8ee:	3d 00 01 00 00       	cmp    $0x100,%eax
    e8f3:	7e 0a                	jle    e8ff <readChunk_PLTE+0x44>
    e8f5:	b8 26 00 00 00       	mov    $0x26,%eax
    e8fa:	e9 da 00 00 00       	jmp    e9d9 <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    e8ff:	83 ec 0c             	sub    $0xc,%esp
    e902:	ff 75 08             	pushl  0x8(%ebp)
    e905:	e8 02 a7 ff ff       	call   900c <lodepng_color_mode_alloc_palette>
    e90a:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    e90d:	8b 45 08             	mov    0x8(%ebp),%eax
    e910:	8b 40 08             	mov    0x8(%eax),%eax
    e913:	85 c0                	test   %eax,%eax
    e915:	75 1e                	jne    e935 <readChunk_PLTE+0x7a>
    e917:	8b 45 08             	mov    0x8(%ebp),%eax
    e91a:	8b 40 0c             	mov    0xc(%eax),%eax
    e91d:	85 c0                	test   %eax,%eax
    e91f:	74 14                	je     e935 <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    e921:	8b 45 08             	mov    0x8(%ebp),%eax
    e924:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    e92b:	b8 53 00 00 00       	mov    $0x53,%eax
    e930:	e9 a4 00 00 00       	jmp    e9d9 <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    e935:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e93c:	e9 84 00 00 00       	jmp    e9c5 <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    e941:	8b 45 08             	mov    0x8(%ebp),%eax
    e944:	8b 40 08             	mov    0x8(%eax),%eax
    e947:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e94a:	c1 e2 02             	shl    $0x2,%edx
    e94d:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e950:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e953:	8d 50 01             	lea    0x1(%eax),%edx
    e956:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e959:	8b 55 0c             	mov    0xc(%ebp),%edx
    e95c:	01 d0                	add    %edx,%eax
    e95e:	0f b6 00             	movzbl (%eax),%eax
    e961:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    e963:	8b 45 08             	mov    0x8(%ebp),%eax
    e966:	8b 40 08             	mov    0x8(%eax),%eax
    e969:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e96c:	c1 e2 02             	shl    $0x2,%edx
    e96f:	83 c2 01             	add    $0x1,%edx
    e972:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e975:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e978:	8d 50 01             	lea    0x1(%eax),%edx
    e97b:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e97e:	8b 55 0c             	mov    0xc(%ebp),%edx
    e981:	01 d0                	add    %edx,%eax
    e983:	0f b6 00             	movzbl (%eax),%eax
    e986:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    e988:	8b 45 08             	mov    0x8(%ebp),%eax
    e98b:	8b 40 08             	mov    0x8(%eax),%eax
    e98e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e991:	c1 e2 02             	shl    $0x2,%edx
    e994:	83 c2 02             	add    $0x2,%edx
    e997:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e99a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e99d:	8d 50 01             	lea    0x1(%eax),%edx
    e9a0:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e9a3:	8b 55 0c             	mov    0xc(%ebp),%edx
    e9a6:	01 d0                	add    %edx,%eax
    e9a8:	0f b6 00             	movzbl (%eax),%eax
    e9ab:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    e9ad:	8b 45 08             	mov    0x8(%ebp),%eax
    e9b0:	8b 40 08             	mov    0x8(%eax),%eax
    e9b3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e9b6:	c1 e2 02             	shl    $0x2,%edx
    e9b9:	83 c2 03             	add    $0x3,%edx
    e9bc:	01 d0                	add    %edx,%eax
    e9be:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    e9c1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e9c5:	8b 45 08             	mov    0x8(%ebp),%eax
    e9c8:	8b 40 0c             	mov    0xc(%eax),%eax
    e9cb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e9ce:	0f 85 6d ff ff ff    	jne    e941 <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    e9d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e9d9:	c9                   	leave  
    e9da:	c3                   	ret    

0000e9db <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e9db:	55                   	push   %ebp
    e9dc:	89 e5                	mov    %esp,%ebp
    e9de:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    e9e1:	8b 45 08             	mov    0x8(%ebp),%eax
    e9e4:	8b 00                	mov    (%eax),%eax
    e9e6:	83 f8 03             	cmp    $0x3,%eax
    e9e9:	75 4d                	jne    ea38 <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    e9eb:	8b 45 08             	mov    0x8(%ebp),%eax
    e9ee:	8b 40 0c             	mov    0xc(%eax),%eax
    e9f1:	3b 45 10             	cmp    0x10(%ebp),%eax
    e9f4:	7d 0a                	jge    ea00 <readChunk_tRNS+0x25>
    e9f6:	b8 27 00 00 00       	mov    $0x27,%eax
    e9fb:	e9 3c 01 00 00       	jmp    eb3c <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    ea00:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    ea07:	eb 22                	jmp    ea2b <readChunk_tRNS+0x50>
    ea09:	8b 45 08             	mov    0x8(%ebp),%eax
    ea0c:	8b 40 08             	mov    0x8(%eax),%eax
    ea0f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ea12:	c1 e2 02             	shl    $0x2,%edx
    ea15:	83 c2 03             	add    $0x3,%edx
    ea18:	01 c2                	add    %eax,%edx
    ea1a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    ea1d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ea20:	01 c8                	add    %ecx,%eax
    ea22:	0f b6 00             	movzbl (%eax),%eax
    ea25:	88 02                	mov    %al,(%edx)
    ea27:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    ea2b:	8b 45 10             	mov    0x10(%ebp),%eax
    ea2e:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    ea31:	75 d6                	jne    ea09 <readChunk_tRNS+0x2e>
    ea33:	e9 ff 00 00 00       	jmp    eb37 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    ea38:	8b 45 08             	mov    0x8(%ebp),%eax
    ea3b:	8b 00                	mov    (%eax),%eax
    ea3d:	85 c0                	test   %eax,%eax
    ea3f:	75 59                	jne    ea9a <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    ea41:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    ea45:	74 0a                	je     ea51 <readChunk_tRNS+0x76>
    ea47:	b8 1e 00 00 00       	mov    $0x1e,%eax
    ea4c:	e9 eb 00 00 00       	jmp    eb3c <readChunk_tRNS+0x161>

    color->key_defined = 1;
    ea51:	8b 45 08             	mov    0x8(%ebp),%eax
    ea54:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    ea5b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea5e:	0f b6 00             	movzbl (%eax),%eax
    ea61:	0f b6 c0             	movzbl %al,%eax
    ea64:	c1 e0 08             	shl    $0x8,%eax
    ea67:	89 c2                	mov    %eax,%edx
    ea69:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea6c:	83 c0 01             	add    $0x1,%eax
    ea6f:	0f b6 00             	movzbl (%eax),%eax
    ea72:	0f b6 c0             	movzbl %al,%eax
    ea75:	01 c2                	add    %eax,%edx
    ea77:	8b 45 08             	mov    0x8(%ebp),%eax
    ea7a:	89 50 1c             	mov    %edx,0x1c(%eax)
    ea7d:	8b 45 08             	mov    0x8(%ebp),%eax
    ea80:	8b 50 1c             	mov    0x1c(%eax),%edx
    ea83:	8b 45 08             	mov    0x8(%ebp),%eax
    ea86:	89 50 18             	mov    %edx,0x18(%eax)
    ea89:	8b 45 08             	mov    0x8(%ebp),%eax
    ea8c:	8b 50 18             	mov    0x18(%eax),%edx
    ea8f:	8b 45 08             	mov    0x8(%ebp),%eax
    ea92:	89 50 14             	mov    %edx,0x14(%eax)
    ea95:	e9 9d 00 00 00       	jmp    eb37 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    ea9a:	8b 45 08             	mov    0x8(%ebp),%eax
    ea9d:	8b 00                	mov    (%eax),%eax
    ea9f:	83 f8 02             	cmp    $0x2,%eax
    eaa2:	0f 85 88 00 00 00    	jne    eb30 <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    eaa8:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    eaac:	74 0a                	je     eab8 <readChunk_tRNS+0xdd>
    eaae:	b8 29 00 00 00       	mov    $0x29,%eax
    eab3:	e9 84 00 00 00       	jmp    eb3c <readChunk_tRNS+0x161>

    color->key_defined = 1;
    eab8:	8b 45 08             	mov    0x8(%ebp),%eax
    eabb:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    eac2:	8b 45 0c             	mov    0xc(%ebp),%eax
    eac5:	0f b6 00             	movzbl (%eax),%eax
    eac8:	0f b6 c0             	movzbl %al,%eax
    eacb:	c1 e0 08             	shl    $0x8,%eax
    eace:	89 c2                	mov    %eax,%edx
    ead0:	8b 45 0c             	mov    0xc(%ebp),%eax
    ead3:	83 c0 01             	add    $0x1,%eax
    ead6:	0f b6 00             	movzbl (%eax),%eax
    ead9:	0f b6 c0             	movzbl %al,%eax
    eadc:	01 c2                	add    %eax,%edx
    eade:	8b 45 08             	mov    0x8(%ebp),%eax
    eae1:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    eae4:	8b 45 0c             	mov    0xc(%ebp),%eax
    eae7:	83 c0 02             	add    $0x2,%eax
    eaea:	0f b6 00             	movzbl (%eax),%eax
    eaed:	0f b6 c0             	movzbl %al,%eax
    eaf0:	c1 e0 08             	shl    $0x8,%eax
    eaf3:	89 c2                	mov    %eax,%edx
    eaf5:	8b 45 0c             	mov    0xc(%ebp),%eax
    eaf8:	83 c0 03             	add    $0x3,%eax
    eafb:	0f b6 00             	movzbl (%eax),%eax
    eafe:	0f b6 c0             	movzbl %al,%eax
    eb01:	01 c2                	add    %eax,%edx
    eb03:	8b 45 08             	mov    0x8(%ebp),%eax
    eb06:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    eb09:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb0c:	83 c0 04             	add    $0x4,%eax
    eb0f:	0f b6 00             	movzbl (%eax),%eax
    eb12:	0f b6 c0             	movzbl %al,%eax
    eb15:	c1 e0 08             	shl    $0x8,%eax
    eb18:	89 c2                	mov    %eax,%edx
    eb1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb1d:	83 c0 05             	add    $0x5,%eax
    eb20:	0f b6 00             	movzbl (%eax),%eax
    eb23:	0f b6 c0             	movzbl %al,%eax
    eb26:	01 c2                	add    %eax,%edx
    eb28:	8b 45 08             	mov    0x8(%ebp),%eax
    eb2b:	89 50 1c             	mov    %edx,0x1c(%eax)
    eb2e:	eb 07                	jmp    eb37 <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    eb30:	b8 2a 00 00 00       	mov    $0x2a,%eax
    eb35:	eb 05                	jmp    eb3c <readChunk_tRNS+0x161>

  return 0; /* OK */
    eb37:	b8 00 00 00 00       	mov    $0x0,%eax
}
    eb3c:	c9                   	leave  
    eb3d:	c3                   	ret    

0000eb3e <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    eb3e:	55                   	push   %ebp
    eb3f:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    eb41:	8b 45 08             	mov    0x8(%ebp),%eax
    eb44:	8b 40 0c             	mov    0xc(%eax),%eax
    eb47:	83 f8 03             	cmp    $0x3,%eax
    eb4a:	75 63                	jne    ebaf <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    eb4c:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    eb50:	74 0a                	je     eb5c <readChunk_bKGD+0x1e>
    eb52:	b8 2b 00 00 00       	mov    $0x2b,%eax
    eb57:	e9 63 01 00 00       	jmp    ecbf <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    eb5c:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb5f:	0f b6 00             	movzbl (%eax),%eax
    eb62:	0f b6 d0             	movzbl %al,%edx
    eb65:	8b 45 08             	mov    0x8(%ebp),%eax
    eb68:	8b 40 18             	mov    0x18(%eax),%eax
    eb6b:	39 c2                	cmp    %eax,%edx
    eb6d:	7c 0a                	jl     eb79 <readChunk_bKGD+0x3b>
    eb6f:	b8 67 00 00 00       	mov    $0x67,%eax
    eb74:	e9 46 01 00 00       	jmp    ecbf <readChunk_bKGD+0x181>

    info->background_defined = 1;
    eb79:	8b 45 08             	mov    0x8(%ebp),%eax
    eb7c:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    eb83:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb86:	0f b6 00             	movzbl (%eax),%eax
    eb89:	0f b6 d0             	movzbl %al,%edx
    eb8c:	8b 45 08             	mov    0x8(%ebp),%eax
    eb8f:	89 50 38             	mov    %edx,0x38(%eax)
    eb92:	8b 45 08             	mov    0x8(%ebp),%eax
    eb95:	8b 50 38             	mov    0x38(%eax),%edx
    eb98:	8b 45 08             	mov    0x8(%ebp),%eax
    eb9b:	89 50 34             	mov    %edx,0x34(%eax)
    eb9e:	8b 45 08             	mov    0x8(%ebp),%eax
    eba1:	8b 50 34             	mov    0x34(%eax),%edx
    eba4:	8b 45 08             	mov    0x8(%ebp),%eax
    eba7:	89 50 30             	mov    %edx,0x30(%eax)
    ebaa:	e9 0b 01 00 00       	jmp    ecba <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    ebaf:	8b 45 08             	mov    0x8(%ebp),%eax
    ebb2:	8b 40 0c             	mov    0xc(%eax),%eax
    ebb5:	85 c0                	test   %eax,%eax
    ebb7:	74 0b                	je     ebc4 <readChunk_bKGD+0x86>
    ebb9:	8b 45 08             	mov    0x8(%ebp),%eax
    ebbc:	8b 40 0c             	mov    0xc(%eax),%eax
    ebbf:	83 f8 04             	cmp    $0x4,%eax
    ebc2:	75 59                	jne    ec1d <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    ebc4:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    ebc8:	74 0a                	je     ebd4 <readChunk_bKGD+0x96>
    ebca:	b8 2c 00 00 00       	mov    $0x2c,%eax
    ebcf:	e9 eb 00 00 00       	jmp    ecbf <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    ebd4:	8b 45 08             	mov    0x8(%ebp),%eax
    ebd7:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    ebde:	8b 45 0c             	mov    0xc(%ebp),%eax
    ebe1:	0f b6 00             	movzbl (%eax),%eax
    ebe4:	0f b6 c0             	movzbl %al,%eax
    ebe7:	c1 e0 08             	shl    $0x8,%eax
    ebea:	89 c2                	mov    %eax,%edx
    ebec:	8b 45 0c             	mov    0xc(%ebp),%eax
    ebef:	83 c0 01             	add    $0x1,%eax
    ebf2:	0f b6 00             	movzbl (%eax),%eax
    ebf5:	0f b6 c0             	movzbl %al,%eax
    ebf8:	01 c2                	add    %eax,%edx
    ebfa:	8b 45 08             	mov    0x8(%ebp),%eax
    ebfd:	89 50 38             	mov    %edx,0x38(%eax)
    ec00:	8b 45 08             	mov    0x8(%ebp),%eax
    ec03:	8b 50 38             	mov    0x38(%eax),%edx
    ec06:	8b 45 08             	mov    0x8(%ebp),%eax
    ec09:	89 50 34             	mov    %edx,0x34(%eax)
    ec0c:	8b 45 08             	mov    0x8(%ebp),%eax
    ec0f:	8b 50 34             	mov    0x34(%eax),%edx
    ec12:	8b 45 08             	mov    0x8(%ebp),%eax
    ec15:	89 50 30             	mov    %edx,0x30(%eax)
    ec18:	e9 9d 00 00 00       	jmp    ecba <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    ec1d:	8b 45 08             	mov    0x8(%ebp),%eax
    ec20:	8b 40 0c             	mov    0xc(%eax),%eax
    ec23:	83 f8 02             	cmp    $0x2,%eax
    ec26:	74 0f                	je     ec37 <readChunk_bKGD+0xf9>
    ec28:	8b 45 08             	mov    0x8(%ebp),%eax
    ec2b:	8b 40 0c             	mov    0xc(%eax),%eax
    ec2e:	83 f8 06             	cmp    $0x6,%eax
    ec31:	0f 85 83 00 00 00    	jne    ecba <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    ec37:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    ec3b:	74 07                	je     ec44 <readChunk_bKGD+0x106>
    ec3d:	b8 2d 00 00 00       	mov    $0x2d,%eax
    ec42:	eb 7b                	jmp    ecbf <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    ec44:	8b 45 08             	mov    0x8(%ebp),%eax
    ec47:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    ec4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec51:	0f b6 00             	movzbl (%eax),%eax
    ec54:	0f b6 c0             	movzbl %al,%eax
    ec57:	c1 e0 08             	shl    $0x8,%eax
    ec5a:	89 c2                	mov    %eax,%edx
    ec5c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec5f:	83 c0 01             	add    $0x1,%eax
    ec62:	0f b6 00             	movzbl (%eax),%eax
    ec65:	0f b6 c0             	movzbl %al,%eax
    ec68:	01 c2                	add    %eax,%edx
    ec6a:	8b 45 08             	mov    0x8(%ebp),%eax
    ec6d:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    ec70:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec73:	83 c0 02             	add    $0x2,%eax
    ec76:	0f b6 00             	movzbl (%eax),%eax
    ec79:	0f b6 c0             	movzbl %al,%eax
    ec7c:	c1 e0 08             	shl    $0x8,%eax
    ec7f:	89 c2                	mov    %eax,%edx
    ec81:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec84:	83 c0 03             	add    $0x3,%eax
    ec87:	0f b6 00             	movzbl (%eax),%eax
    ec8a:	0f b6 c0             	movzbl %al,%eax
    ec8d:	01 c2                	add    %eax,%edx
    ec8f:	8b 45 08             	mov    0x8(%ebp),%eax
    ec92:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    ec95:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec98:	83 c0 04             	add    $0x4,%eax
    ec9b:	0f b6 00             	movzbl (%eax),%eax
    ec9e:	0f b6 c0             	movzbl %al,%eax
    eca1:	c1 e0 08             	shl    $0x8,%eax
    eca4:	89 c2                	mov    %eax,%edx
    eca6:	8b 45 0c             	mov    0xc(%ebp),%eax
    eca9:	83 c0 05             	add    $0x5,%eax
    ecac:	0f b6 00             	movzbl (%eax),%eax
    ecaf:	0f b6 c0             	movzbl %al,%eax
    ecb2:	01 c2                	add    %eax,%edx
    ecb4:	8b 45 08             	mov    0x8(%ebp),%eax
    ecb7:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    ecba:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ecbf:	5d                   	pop    %ebp
    ecc0:	c3                   	ret    

0000ecc1 <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ecc1:	55                   	push   %ebp
    ecc2:	89 e5                	mov    %esp,%ebp
    ecc4:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    ecc7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    ecce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ecd5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ecdc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ece0:	0f 85 06 01 00 00    	jne    edec <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    ece6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    eced:	eb 04                	jmp    ecf3 <readChunk_tEXt+0x32>
    ecef:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    ecf3:	8b 45 10             	mov    0x10(%ebp),%eax
    ecf6:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    ecf9:	73 0f                	jae    ed0a <readChunk_tEXt+0x49>
    ecfb:	8b 55 0c             	mov    0xc(%ebp),%edx
    ecfe:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ed01:	01 d0                	add    %edx,%eax
    ed03:	0f b6 00             	movzbl (%eax),%eax
    ed06:	84 c0                	test   %al,%al
    ed08:	75 e5                	jne    ecef <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    ed0a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ed0e:	74 06                	je     ed16 <readChunk_tEXt+0x55>
    ed10:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    ed14:	76 0c                	jbe    ed22 <readChunk_tEXt+0x61>
    ed16:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    ed1d:	e9 ca 00 00 00       	jmp    edec <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    ed22:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ed25:	83 c0 01             	add    $0x1,%eax
    ed28:	83 ec 0c             	sub    $0xc,%esp
    ed2b:	50                   	push   %eax
    ed2c:	e8 73 4b ff ff       	call   38a4 <lodepng_malloc>
    ed31:	83 c4 10             	add    $0x10,%esp
    ed34:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    ed37:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ed3b:	75 0c                	jne    ed49 <readChunk_tEXt+0x88>
    ed3d:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ed44:	e9 a3 00 00 00       	jmp    edec <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    ed49:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ed4c:	83 ec 04             	sub    $0x4,%esp
    ed4f:	50                   	push   %eax
    ed50:	ff 75 0c             	pushl  0xc(%ebp)
    ed53:	ff 75 f0             	pushl  -0x10(%ebp)
    ed56:	e8 87 4b ff ff       	call   38e2 <lodepng_memcpy>
    ed5b:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    ed5e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ed61:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ed64:	01 d0                	add    %edx,%eax
    ed66:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    ed69:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ed6c:	83 c0 01             	add    $0x1,%eax
    ed6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    ed72:	8b 45 10             	mov    0x10(%ebp),%eax
    ed75:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    ed78:	72 08                	jb     ed82 <readChunk_tEXt+0xc1>
    ed7a:	8b 45 10             	mov    0x10(%ebp),%eax
    ed7d:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    ed80:	eb 05                	jmp    ed87 <readChunk_tEXt+0xc6>
    ed82:	b8 00 00 00 00       	mov    $0x0,%eax
    ed87:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    ed8a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ed8d:	83 c0 01             	add    $0x1,%eax
    ed90:	83 ec 0c             	sub    $0xc,%esp
    ed93:	50                   	push   %eax
    ed94:	e8 0b 4b ff ff       	call   38a4 <lodepng_malloc>
    ed99:	83 c4 10             	add    $0x10,%esp
    ed9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    ed9f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    eda3:	75 09                	jne    edae <readChunk_tEXt+0xed>
    eda5:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    edac:	eb 3e                	jmp    edec <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    edae:	8b 45 e8             	mov    -0x18(%ebp),%eax
    edb1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    edb4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    edb7:	01 ca                	add    %ecx,%edx
    edb9:	83 ec 04             	sub    $0x4,%esp
    edbc:	50                   	push   %eax
    edbd:	52                   	push   %edx
    edbe:	ff 75 ec             	pushl  -0x14(%ebp)
    edc1:	e8 1c 4b ff ff       	call   38e2 <lodepng_memcpy>
    edc6:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    edc9:	8b 55 ec             	mov    -0x14(%ebp),%edx
    edcc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    edcf:	01 d0                	add    %edx,%eax
    edd1:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    edd4:	83 ec 04             	sub    $0x4,%esp
    edd7:	ff 75 ec             	pushl  -0x14(%ebp)
    edda:	ff 75 f0             	pushl  -0x10(%ebp)
    eddd:	ff 75 08             	pushl  0x8(%ebp)
    ede0:	e8 3f ac ff ff       	call   9a24 <lodepng_add_text>
    ede5:	83 c4 10             	add    $0x10,%esp
    ede8:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    edeb:	90                   	nop
  }

  lodepng_free(key);
    edec:	83 ec 0c             	sub    $0xc,%esp
    edef:	ff 75 f0             	pushl  -0x10(%ebp)
    edf2:	e8 ce 4a ff ff       	call   38c5 <lodepng_free>
    edf7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    edfa:	83 ec 0c             	sub    $0xc,%esp
    edfd:	ff 75 ec             	pushl  -0x14(%ebp)
    ee00:	e8 c0 4a ff ff       	call   38c5 <lodepng_free>
    ee05:	83 c4 10             	add    $0x10,%esp

  return error;
    ee08:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ee0b:	c9                   	leave  
    ee0c:	c3                   	ret    

0000ee0d <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    ee0d:	55                   	push   %ebp
    ee0e:	89 e5                	mov    %esp,%ebp
    ee10:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    ee13:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    ee1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee1d:	8b 10                	mov    (%eax),%edx
    ee1f:	89 55 d0             	mov    %edx,-0x30(%ebp)
    ee22:	8b 50 04             	mov    0x4(%eax),%edx
    ee25:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    ee28:	8b 50 08             	mov    0x8(%eax),%edx
    ee2b:	89 55 d8             	mov    %edx,-0x28(%ebp)
    ee2e:	8b 50 0c             	mov    0xc(%eax),%edx
    ee31:	89 55 dc             	mov    %edx,-0x24(%ebp)
    ee34:	8b 50 10             	mov    0x10(%eax),%edx
    ee37:	89 55 e0             	mov    %edx,-0x20(%ebp)
    ee3a:	8b 40 14             	mov    0x14(%eax),%eax
    ee3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    ee40:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    ee47:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    ee4e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ee55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ee59:	0f 85 48 01 00 00    	jne    efa7 <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    ee5f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ee66:	eb 04                	jmp    ee6c <readChunk_zTXt+0x5f>
    ee68:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ee6c:	8b 45 14             	mov    0x14(%ebp),%eax
    ee6f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ee72:	73 0f                	jae    ee83 <readChunk_zTXt+0x76>
    ee74:	8b 55 10             	mov    0x10(%ebp),%edx
    ee77:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ee7a:	01 d0                	add    %edx,%eax
    ee7c:	0f b6 00             	movzbl (%eax),%eax
    ee7f:	84 c0                	test   %al,%al
    ee81:	75 e5                	jne    ee68 <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    ee83:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ee86:	8d 50 02             	lea    0x2(%eax),%edx
    ee89:	8b 45 14             	mov    0x14(%ebp),%eax
    ee8c:	39 c2                	cmp    %eax,%edx
    ee8e:	72 0c                	jb     ee9c <readChunk_zTXt+0x8f>
    ee90:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ee97:	e9 0b 01 00 00       	jmp    efa7 <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    ee9c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    eea0:	74 06                	je     eea8 <readChunk_zTXt+0x9b>
    eea2:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    eea6:	76 0c                	jbe    eeb4 <readChunk_zTXt+0xa7>
    eea8:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    eeaf:	e9 f3 00 00 00       	jmp    efa7 <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    eeb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eeb7:	83 c0 01             	add    $0x1,%eax
    eeba:	83 ec 0c             	sub    $0xc,%esp
    eebd:	50                   	push   %eax
    eebe:	e8 e1 49 ff ff       	call   38a4 <lodepng_malloc>
    eec3:	83 c4 10             	add    $0x10,%esp
    eec6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    eec9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    eecd:	75 0c                	jne    eedb <readChunk_zTXt+0xce>
    eecf:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eed6:	e9 cc 00 00 00       	jmp    efa7 <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    eedb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eede:	83 ec 04             	sub    $0x4,%esp
    eee1:	50                   	push   %eax
    eee2:	ff 75 10             	pushl  0x10(%ebp)
    eee5:	ff 75 ec             	pushl  -0x14(%ebp)
    eee8:	e8 f5 49 ff ff       	call   38e2 <lodepng_memcpy>
    eeed:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    eef0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    eef3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eef6:	01 d0                	add    %edx,%eax
    eef8:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    eefb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eefe:	8d 50 01             	lea    0x1(%eax),%edx
    ef01:	8b 45 10             	mov    0x10(%ebp),%eax
    ef04:	01 d0                	add    %edx,%eax
    ef06:	0f b6 00             	movzbl (%eax),%eax
    ef09:	84 c0                	test   %al,%al
    ef0b:	74 0c                	je     ef19 <readChunk_zTXt+0x10c>
    ef0d:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ef14:	e9 8e 00 00 00       	jmp    efa7 <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    ef19:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ef1c:	83 c0 02             	add    $0x2,%eax
    ef1f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    ef22:	8b 45 14             	mov    0x14(%ebp),%eax
    ef25:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    ef28:	76 09                	jbe    ef33 <readChunk_zTXt+0x126>
    ef2a:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ef31:	eb 74                	jmp    efa7 <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    ef33:	8b 45 14             	mov    0x14(%ebp),%eax
    ef36:	2b 45 e8             	sub    -0x18(%ebp),%eax
    ef39:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    ef3c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef3f:	8b 40 30             	mov    0x30(%eax),%eax
    ef42:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    ef45:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ef48:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ef4b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ef4e:	01 d1                	add    %edx,%ecx
    ef50:	83 ec 08             	sub    $0x8,%esp
    ef53:	8d 55 d0             	lea    -0x30(%ebp),%edx
    ef56:	52                   	push   %edx
    ef57:	50                   	push   %eax
    ef58:	51                   	push   %ecx
    ef59:	6a 00                	push   $0x0
    ef5b:	8d 45 c8             	lea    -0x38(%ebp),%eax
    ef5e:	50                   	push   %eax
    ef5f:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ef62:	50                   	push   %eax
    ef63:	e8 f7 93 ff ff       	call   835f <zlib_decompress>
    ef68:	83 c4 20             	add    $0x20,%esp
    ef6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    ef6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ef72:	74 11                	je     ef85 <readChunk_zTXt+0x178>
    ef74:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ef77:	8b 45 c8             	mov    -0x38(%ebp),%eax
    ef7a:	39 c2                	cmp    %eax,%edx
    ef7c:	7d 07                	jge    ef85 <readChunk_zTXt+0x178>
    ef7e:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    ef85:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ef89:	75 1b                	jne    efa6 <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    ef8b:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ef8e:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ef91:	52                   	push   %edx
    ef92:	50                   	push   %eax
    ef93:	ff 75 ec             	pushl  -0x14(%ebp)
    ef96:	ff 75 08             	pushl  0x8(%ebp)
    ef99:	e8 60 a9 ff ff       	call   98fe <lodepng_add_text_sized>
    ef9e:	83 c4 10             	add    $0x10,%esp
    efa1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    efa4:	eb 01                	jmp    efa7 <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    efa6:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    efa7:	83 ec 0c             	sub    $0xc,%esp
    efaa:	ff 75 ec             	pushl  -0x14(%ebp)
    efad:	e8 13 49 ff ff       	call   38c5 <lodepng_free>
    efb2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    efb5:	8b 45 cc             	mov    -0x34(%ebp),%eax
    efb8:	83 ec 0c             	sub    $0xc,%esp
    efbb:	50                   	push   %eax
    efbc:	e8 04 49 ff ff       	call   38c5 <lodepng_free>
    efc1:	83 c4 10             	add    $0x10,%esp

  return error;
    efc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    efc7:	c9                   	leave  
    efc8:	c3                   	ret    

0000efc9 <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    efc9:	55                   	push   %ebp
    efca:	89 e5                	mov    %esp,%ebp
    efcc:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    efcf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    efd6:	8b 45 0c             	mov    0xc(%ebp),%eax
    efd9:	8b 10                	mov    (%eax),%edx
    efdb:	89 55 c0             	mov    %edx,-0x40(%ebp)
    efde:	8b 50 04             	mov    0x4(%eax),%edx
    efe1:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    efe4:	8b 50 08             	mov    0x8(%eax),%edx
    efe7:	89 55 c8             	mov    %edx,-0x38(%ebp)
    efea:	8b 50 0c             	mov    0xc(%eax),%edx
    efed:	89 55 cc             	mov    %edx,-0x34(%ebp)
    eff0:	8b 50 10             	mov    0x10(%eax),%edx
    eff3:	89 55 d0             	mov    %edx,-0x30(%ebp)
    eff6:	8b 40 14             	mov    0x14(%eax),%eax
    eff9:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    effc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    f003:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    f00a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    f011:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f015:	0f 85 d5 02 00 00    	jne    f2f0 <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    f01b:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    f01f:	7f 0c                	jg     f02d <readChunk_iTXt+0x64>
    f021:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    f028:	e9 c3 02 00 00       	jmp    f2f0 <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f02d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f034:	eb 04                	jmp    f03a <readChunk_iTXt+0x71>
    f036:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f03a:	8b 45 14             	mov    0x14(%ebp),%eax
    f03d:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f040:	73 0f                	jae    f051 <readChunk_iTXt+0x88>
    f042:	8b 55 10             	mov    0x10(%ebp),%edx
    f045:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f048:	01 d0                	add    %edx,%eax
    f04a:	0f b6 00             	movzbl (%eax),%eax
    f04d:	84 c0                	test   %al,%al
    f04f:	75 e5                	jne    f036 <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    f051:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f054:	8d 50 03             	lea    0x3(%eax),%edx
    f057:	8b 45 14             	mov    0x14(%ebp),%eax
    f05a:	39 c2                	cmp    %eax,%edx
    f05c:	72 0c                	jb     f06a <readChunk_iTXt+0xa1>
    f05e:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    f065:	e9 86 02 00 00       	jmp    f2f0 <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    f06a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f06e:	74 06                	je     f076 <readChunk_iTXt+0xad>
    f070:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f074:	76 0c                	jbe    f082 <readChunk_iTXt+0xb9>
    f076:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    f07d:	e9 6e 02 00 00       	jmp    f2f0 <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    f082:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f085:	83 c0 01             	add    $0x1,%eax
    f088:	83 ec 0c             	sub    $0xc,%esp
    f08b:	50                   	push   %eax
    f08c:	e8 13 48 ff ff       	call   38a4 <lodepng_malloc>
    f091:	83 c4 10             	add    $0x10,%esp
    f094:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    f097:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    f09b:	75 0c                	jne    f0a9 <readChunk_iTXt+0xe0>
    f09d:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f0a4:	e9 47 02 00 00       	jmp    f2f0 <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    f0a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f0ac:	83 ec 04             	sub    $0x4,%esp
    f0af:	50                   	push   %eax
    f0b0:	ff 75 10             	pushl  0x10(%ebp)
    f0b3:	ff 75 e8             	pushl  -0x18(%ebp)
    f0b6:	e8 27 48 ff ff       	call   38e2 <lodepng_memcpy>
    f0bb:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    f0be:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f0c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f0c4:	01 d0                	add    %edx,%eax
    f0c6:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    f0c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f0cc:	8d 50 01             	lea    0x1(%eax),%edx
    f0cf:	8b 45 10             	mov    0x10(%ebp),%eax
    f0d2:	01 d0                	add    %edx,%eax
    f0d4:	0f b6 00             	movzbl (%eax),%eax
    f0d7:	0f b6 c0             	movzbl %al,%eax
    f0da:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    f0dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f0e0:	8d 50 02             	lea    0x2(%eax),%edx
    f0e3:	8b 45 10             	mov    0x10(%ebp),%eax
    f0e6:	01 d0                	add    %edx,%eax
    f0e8:	0f b6 00             	movzbl (%eax),%eax
    f0eb:	84 c0                	test   %al,%al
    f0ed:	74 0c                	je     f0fb <readChunk_iTXt+0x132>
    f0ef:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    f0f6:	e9 f5 01 00 00       	jmp    f2f0 <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    f0fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f0fe:	83 c0 03             	add    $0x3,%eax
    f101:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    f104:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    f10b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    f10e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f111:	eb 08                	jmp    f11b <readChunk_iTXt+0x152>
    f113:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f117:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f11b:	8b 45 14             	mov    0x14(%ebp),%eax
    f11e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    f121:	73 0f                	jae    f132 <readChunk_iTXt+0x169>
    f123:	8b 55 10             	mov    0x10(%ebp),%edx
    f126:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f129:	01 d0                	add    %edx,%eax
    f12b:	0f b6 00             	movzbl (%eax),%eax
    f12e:	84 c0                	test   %al,%al
    f130:	75 e1                	jne    f113 <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    f132:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f135:	83 c0 01             	add    $0x1,%eax
    f138:	83 ec 0c             	sub    $0xc,%esp
    f13b:	50                   	push   %eax
    f13c:	e8 63 47 ff ff       	call   38a4 <lodepng_malloc>
    f141:	83 c4 10             	add    $0x10,%esp
    f144:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    f147:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    f14b:	75 0c                	jne    f159 <readChunk_iTXt+0x190>
    f14d:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f154:	e9 97 01 00 00       	jmp    f2f0 <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    f159:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f15c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f15f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f162:	01 ca                	add    %ecx,%edx
    f164:	83 ec 04             	sub    $0x4,%esp
    f167:	50                   	push   %eax
    f168:	52                   	push   %edx
    f169:	ff 75 e4             	pushl  -0x1c(%ebp)
    f16c:	e8 71 47 ff ff       	call   38e2 <lodepng_memcpy>
    f171:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    f174:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f177:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f17a:	01 d0                	add    %edx,%eax
    f17c:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    f17f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f182:	8b 45 d8             	mov    -0x28(%ebp),%eax
    f185:	01 d0                	add    %edx,%eax
    f187:	83 c0 01             	add    $0x1,%eax
    f18a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    f18d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    f194:	8b 45 d8             	mov    -0x28(%ebp),%eax
    f197:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f19a:	eb 08                	jmp    f1a4 <readChunk_iTXt+0x1db>
    f19c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f1a0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f1a4:	8b 45 14             	mov    0x14(%ebp),%eax
    f1a7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    f1aa:	73 0f                	jae    f1bb <readChunk_iTXt+0x1f2>
    f1ac:	8b 55 10             	mov    0x10(%ebp),%edx
    f1af:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f1b2:	01 d0                	add    %edx,%eax
    f1b4:	0f b6 00             	movzbl (%eax),%eax
    f1b7:	84 c0                	test   %al,%al
    f1b9:	75 e1                	jne    f19c <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    f1bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f1be:	83 c0 01             	add    $0x1,%eax
    f1c1:	83 ec 0c             	sub    $0xc,%esp
    f1c4:	50                   	push   %eax
    f1c5:	e8 da 46 ff ff       	call   38a4 <lodepng_malloc>
    f1ca:	83 c4 10             	add    $0x10,%esp
    f1cd:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    f1d0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    f1d4:	75 0c                	jne    f1e2 <readChunk_iTXt+0x219>
    f1d6:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f1dd:	e9 0e 01 00 00       	jmp    f2f0 <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    f1e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f1e5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f1e8:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f1eb:	01 ca                	add    %ecx,%edx
    f1ed:	83 ec 04             	sub    $0x4,%esp
    f1f0:	50                   	push   %eax
    f1f1:	52                   	push   %edx
    f1f2:	ff 75 e0             	pushl  -0x20(%ebp)
    f1f5:	e8 e8 46 ff ff       	call   38e2 <lodepng_memcpy>
    f1fa:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    f1fd:	8b 55 e0             	mov    -0x20(%ebp),%edx
    f200:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f203:	01 d0                	add    %edx,%eax
    f205:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    f208:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f20b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    f20e:	01 d0                	add    %edx,%eax
    f210:	83 c0 01             	add    $0x1,%eax
    f213:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    f216:	8b 45 14             	mov    0x14(%ebp),%eax
    f219:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    f21c:	72 08                	jb     f226 <readChunk_iTXt+0x25d>
    f21e:	8b 45 14             	mov    0x14(%ebp),%eax
    f221:	2b 45 d8             	sub    -0x28(%ebp),%eax
    f224:	eb 05                	jmp    f22b <readChunk_iTXt+0x262>
    f226:	b8 00 00 00 00       	mov    $0x0,%eax
    f22b:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    f22e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    f232:	0f 84 90 00 00 00    	je     f2c8 <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    f238:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    f23f:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    f246:	8b 45 0c             	mov    0xc(%ebp),%eax
    f249:	8b 40 30             	mov    0x30(%eax),%eax
    f24c:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    f24f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f252:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f255:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f258:	01 d1                	add    %edx,%ecx
    f25a:	83 ec 08             	sub    $0x8,%esp
    f25d:	8d 55 c0             	lea    -0x40(%ebp),%edx
    f260:	52                   	push   %edx
    f261:	50                   	push   %eax
    f262:	51                   	push   %ecx
    f263:	6a 00                	push   $0x0
    f265:	8d 45 b8             	lea    -0x48(%ebp),%eax
    f268:	50                   	push   %eax
    f269:	8d 45 bc             	lea    -0x44(%ebp),%eax
    f26c:	50                   	push   %eax
    f26d:	e8 ed 90 ff ff       	call   835f <zlib_decompress>
    f272:	83 c4 20             	add    $0x20,%esp
    f275:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    f278:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f27c:	74 11                	je     f28f <readChunk_iTXt+0x2c6>
    f27e:	8b 55 c8             	mov    -0x38(%ebp),%edx
    f281:	8b 45 b8             	mov    -0x48(%ebp),%eax
    f284:	39 c2                	cmp    %eax,%edx
    f286:	7d 07                	jge    f28f <readChunk_iTXt+0x2c6>
    f288:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    f28f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f293:	75 22                	jne    f2b7 <readChunk_iTXt+0x2ee>
    f295:	8b 55 b8             	mov    -0x48(%ebp),%edx
    f298:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f29b:	83 ec 08             	sub    $0x8,%esp
    f29e:	52                   	push   %edx
    f29f:	50                   	push   %eax
    f2a0:	ff 75 e0             	pushl  -0x20(%ebp)
    f2a3:	ff 75 e4             	pushl  -0x1c(%ebp)
    f2a6:	ff 75 e8             	pushl  -0x18(%ebp)
    f2a9:	ff 75 08             	pushl  0x8(%ebp)
    f2ac:	e8 94 a9 ff ff       	call   9c45 <lodepng_add_itext_sized>
    f2b1:	83 c4 20             	add    $0x20,%esp
    f2b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    f2b7:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f2ba:	83 ec 0c             	sub    $0xc,%esp
    f2bd:	50                   	push   %eax
    f2be:	e8 02 46 ff ff       	call   38c5 <lodepng_free>
    f2c3:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    f2c6:	eb 27                	jmp    f2ef <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    f2c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2cb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f2ce:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f2d1:	01 ca                	add    %ecx,%edx
    f2d3:	83 ec 08             	sub    $0x8,%esp
    f2d6:	50                   	push   %eax
    f2d7:	52                   	push   %edx
    f2d8:	ff 75 e0             	pushl  -0x20(%ebp)
    f2db:	ff 75 e4             	pushl  -0x1c(%ebp)
    f2de:	ff 75 e8             	pushl  -0x18(%ebp)
    f2e1:	ff 75 08             	pushl  0x8(%ebp)
    f2e4:	e8 5c a9 ff ff       	call   9c45 <lodepng_add_itext_sized>
    f2e9:	83 c4 20             	add    $0x20,%esp
    f2ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    f2ef:	90                   	nop
  }

  lodepng_free(key);
    f2f0:	83 ec 0c             	sub    $0xc,%esp
    f2f3:	ff 75 e8             	pushl  -0x18(%ebp)
    f2f6:	e8 ca 45 ff ff       	call   38c5 <lodepng_free>
    f2fb:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    f2fe:	83 ec 0c             	sub    $0xc,%esp
    f301:	ff 75 e4             	pushl  -0x1c(%ebp)
    f304:	e8 bc 45 ff ff       	call   38c5 <lodepng_free>
    f309:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    f30c:	83 ec 0c             	sub    $0xc,%esp
    f30f:	ff 75 e0             	pushl  -0x20(%ebp)
    f312:	e8 ae 45 ff ff       	call   38c5 <lodepng_free>
    f317:	83 c4 10             	add    $0x10,%esp

  return error;
    f31a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f31d:	c9                   	leave  
    f31e:	c3                   	ret    

0000f31f <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f31f:	55                   	push   %ebp
    f320:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    f322:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    f326:	74 0a                	je     f332 <readChunk_tIME+0x13>
    f328:	b8 49 00 00 00       	mov    $0x49,%eax
    f32d:	e9 8b 00 00 00       	jmp    f3bd <readChunk_tIME+0x9e>

  info->time_defined = 1;
    f332:	8b 45 08             	mov    0x8(%ebp),%eax
    f335:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    f33c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f33f:	0f b6 00             	movzbl (%eax),%eax
    f342:	0f b6 c0             	movzbl %al,%eax
    f345:	c1 e0 08             	shl    $0x8,%eax
    f348:	89 c2                	mov    %eax,%edx
    f34a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f34d:	83 c0 01             	add    $0x1,%eax
    f350:	0f b6 00             	movzbl (%eax),%eax
    f353:	0f b6 c0             	movzbl %al,%eax
    f356:	01 c2                	add    %eax,%edx
    f358:	8b 45 08             	mov    0x8(%ebp),%eax
    f35b:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    f35e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f361:	83 c0 02             	add    $0x2,%eax
    f364:	0f b6 00             	movzbl (%eax),%eax
    f367:	0f b6 d0             	movzbl %al,%edx
    f36a:	8b 45 08             	mov    0x8(%ebp),%eax
    f36d:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    f370:	8b 45 0c             	mov    0xc(%ebp),%eax
    f373:	83 c0 03             	add    $0x3,%eax
    f376:	0f b6 00             	movzbl (%eax),%eax
    f379:	0f b6 d0             	movzbl %al,%edx
    f37c:	8b 45 08             	mov    0x8(%ebp),%eax
    f37f:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    f382:	8b 45 0c             	mov    0xc(%ebp),%eax
    f385:	83 c0 04             	add    $0x4,%eax
    f388:	0f b6 00             	movzbl (%eax),%eax
    f38b:	0f b6 d0             	movzbl %al,%edx
    f38e:	8b 45 08             	mov    0x8(%ebp),%eax
    f391:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    f394:	8b 45 0c             	mov    0xc(%ebp),%eax
    f397:	83 c0 05             	add    $0x5,%eax
    f39a:	0f b6 00             	movzbl (%eax),%eax
    f39d:	0f b6 d0             	movzbl %al,%edx
    f3a0:	8b 45 08             	mov    0x8(%ebp),%eax
    f3a3:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    f3a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3a9:	83 c0 06             	add    $0x6,%eax
    f3ac:	0f b6 00             	movzbl (%eax),%eax
    f3af:	0f b6 d0             	movzbl %al,%edx
    f3b2:	8b 45 08             	mov    0x8(%ebp),%eax
    f3b5:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    f3b8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f3bd:	5d                   	pop    %ebp
    f3be:	c3                   	ret    

0000f3bf <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f3bf:	55                   	push   %ebp
    f3c0:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    f3c2:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    f3c6:	74 0a                	je     f3d2 <readChunk_pHYs+0x13>
    f3c8:	b8 4a 00 00 00       	mov    $0x4a,%eax
    f3cd:	e9 ba 00 00 00       	jmp    f48c <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    f3d2:	8b 45 08             	mov    0x8(%ebp),%eax
    f3d5:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    f3dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3df:	0f b6 00             	movzbl (%eax),%eax
    f3e2:	0f b6 c0             	movzbl %al,%eax
    f3e5:	c1 e0 08             	shl    $0x8,%eax
    f3e8:	89 c2                	mov    %eax,%edx
    f3ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3ed:	83 c0 01             	add    $0x1,%eax
    f3f0:	0f b6 00             	movzbl (%eax),%eax
    f3f3:	0f b6 c0             	movzbl %al,%eax
    f3f6:	01 d0                	add    %edx,%eax
    f3f8:	c1 e0 08             	shl    $0x8,%eax
    f3fb:	89 c2                	mov    %eax,%edx
    f3fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    f400:	83 c0 02             	add    $0x2,%eax
    f403:	0f b6 00             	movzbl (%eax),%eax
    f406:	0f b6 c0             	movzbl %al,%eax
    f409:	01 d0                	add    %edx,%eax
    f40b:	c1 e0 08             	shl    $0x8,%eax
    f40e:	89 c2                	mov    %eax,%edx
    f410:	8b 45 0c             	mov    0xc(%ebp),%eax
    f413:	83 c0 03             	add    $0x3,%eax
    f416:	0f b6 00             	movzbl (%eax),%eax
    f419:	0f b6 c0             	movzbl %al,%eax
    f41c:	01 c2                	add    %eax,%edx
    f41e:	8b 45 08             	mov    0x8(%ebp),%eax
    f421:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    f424:	8b 45 0c             	mov    0xc(%ebp),%eax
    f427:	83 c0 04             	add    $0x4,%eax
    f42a:	0f b6 00             	movzbl (%eax),%eax
    f42d:	0f b6 c0             	movzbl %al,%eax
    f430:	c1 e0 08             	shl    $0x8,%eax
    f433:	89 c2                	mov    %eax,%edx
    f435:	8b 45 0c             	mov    0xc(%ebp),%eax
    f438:	83 c0 05             	add    $0x5,%eax
    f43b:	0f b6 00             	movzbl (%eax),%eax
    f43e:	0f b6 c0             	movzbl %al,%eax
    f441:	01 d0                	add    %edx,%eax
    f443:	c1 e0 08             	shl    $0x8,%eax
    f446:	89 c2                	mov    %eax,%edx
    f448:	8b 45 0c             	mov    0xc(%ebp),%eax
    f44b:	83 c0 06             	add    $0x6,%eax
    f44e:	0f b6 00             	movzbl (%eax),%eax
    f451:	0f b6 c0             	movzbl %al,%eax
    f454:	01 d0                	add    %edx,%eax
    f456:	c1 e0 08             	shl    $0x8,%eax
    f459:	89 c2                	mov    %eax,%edx
    f45b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f45e:	83 c0 07             	add    $0x7,%eax
    f461:	0f b6 00             	movzbl (%eax),%eax
    f464:	0f b6 c0             	movzbl %al,%eax
    f467:	01 c2                	add    %eax,%edx
    f469:	8b 45 08             	mov    0x8(%ebp),%eax
    f46c:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    f472:	8b 45 0c             	mov    0xc(%ebp),%eax
    f475:	83 c0 08             	add    $0x8,%eax
    f478:	0f b6 00             	movzbl (%eax),%eax
    f47b:	0f b6 d0             	movzbl %al,%edx
    f47e:	8b 45 08             	mov    0x8(%ebp),%eax
    f481:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    f487:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f48c:	5d                   	pop    %ebp
    f48d:	c3                   	ret    

0000f48e <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f48e:	55                   	push   %ebp
    f48f:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    f491:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    f495:	74 07                	je     f49e <readChunk_gAMA+0x10>
    f497:	b8 60 00 00 00       	mov    $0x60,%eax
    f49c:	eb 5d                	jmp    f4fb <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    f49e:	8b 45 08             	mov    0x8(%ebp),%eax
    f4a1:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    f4a8:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    f4ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4ae:	0f b6 00             	movzbl (%eax),%eax
    f4b1:	0f b6 c0             	movzbl %al,%eax
    f4b4:	c1 e0 08             	shl    $0x8,%eax
    f4b7:	89 c2                	mov    %eax,%edx
    f4b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4bc:	83 c0 01             	add    $0x1,%eax
    f4bf:	0f b6 00             	movzbl (%eax),%eax
    f4c2:	0f b6 c0             	movzbl %al,%eax
    f4c5:	01 d0                	add    %edx,%eax
    f4c7:	c1 e0 08             	shl    $0x8,%eax
    f4ca:	89 c2                	mov    %eax,%edx
    f4cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4cf:	83 c0 02             	add    $0x2,%eax
    f4d2:	0f b6 00             	movzbl (%eax),%eax
    f4d5:	0f b6 c0             	movzbl %al,%eax
    f4d8:	01 d0                	add    %edx,%eax
    f4da:	c1 e0 08             	shl    $0x8,%eax
    f4dd:	89 c2                	mov    %eax,%edx
    f4df:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4e2:	83 c0 03             	add    $0x3,%eax
    f4e5:	0f b6 00             	movzbl (%eax),%eax
    f4e8:	0f b6 c0             	movzbl %al,%eax
    f4eb:	01 c2                	add    %eax,%edx
    f4ed:	8b 45 08             	mov    0x8(%ebp),%eax
    f4f0:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    f4f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f4fb:	5d                   	pop    %ebp
    f4fc:	c3                   	ret    

0000f4fd <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f4fd:	55                   	push   %ebp
    f4fe:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    f500:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    f504:	74 0a                	je     f510 <readChunk_cHRM+0x13>
    f506:	b8 61 00 00 00       	mov    $0x61,%eax
    f50b:	e9 7f 02 00 00       	jmp    f78f <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    f510:	8b 45 08             	mov    0x8(%ebp),%eax
    f513:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    f51a:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    f51d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f520:	0f b6 00             	movzbl (%eax),%eax
    f523:	0f b6 c0             	movzbl %al,%eax
    f526:	c1 e0 08             	shl    $0x8,%eax
    f529:	89 c2                	mov    %eax,%edx
    f52b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f52e:	83 c0 01             	add    $0x1,%eax
    f531:	0f b6 00             	movzbl (%eax),%eax
    f534:	0f b6 c0             	movzbl %al,%eax
    f537:	01 d0                	add    %edx,%eax
    f539:	c1 e0 08             	shl    $0x8,%eax
    f53c:	89 c2                	mov    %eax,%edx
    f53e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f541:	83 c0 02             	add    $0x2,%eax
    f544:	0f b6 00             	movzbl (%eax),%eax
    f547:	0f b6 c0             	movzbl %al,%eax
    f54a:	01 d0                	add    %edx,%eax
    f54c:	c1 e0 08             	shl    $0x8,%eax
    f54f:	89 c2                	mov    %eax,%edx
    f551:	8b 45 0c             	mov    0xc(%ebp),%eax
    f554:	83 c0 03             	add    $0x3,%eax
    f557:	0f b6 00             	movzbl (%eax),%eax
    f55a:	0f b6 c0             	movzbl %al,%eax
    f55d:	01 c2                	add    %eax,%edx
    f55f:	8b 45 08             	mov    0x8(%ebp),%eax
    f562:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    f568:	8b 45 0c             	mov    0xc(%ebp),%eax
    f56b:	83 c0 04             	add    $0x4,%eax
    f56e:	0f b6 00             	movzbl (%eax),%eax
    f571:	0f b6 c0             	movzbl %al,%eax
    f574:	c1 e0 08             	shl    $0x8,%eax
    f577:	89 c2                	mov    %eax,%edx
    f579:	8b 45 0c             	mov    0xc(%ebp),%eax
    f57c:	83 c0 05             	add    $0x5,%eax
    f57f:	0f b6 00             	movzbl (%eax),%eax
    f582:	0f b6 c0             	movzbl %al,%eax
    f585:	01 d0                	add    %edx,%eax
    f587:	c1 e0 08             	shl    $0x8,%eax
    f58a:	89 c2                	mov    %eax,%edx
    f58c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f58f:	83 c0 06             	add    $0x6,%eax
    f592:	0f b6 00             	movzbl (%eax),%eax
    f595:	0f b6 c0             	movzbl %al,%eax
    f598:	01 d0                	add    %edx,%eax
    f59a:	c1 e0 08             	shl    $0x8,%eax
    f59d:	89 c2                	mov    %eax,%edx
    f59f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5a2:	83 c0 07             	add    $0x7,%eax
    f5a5:	0f b6 00             	movzbl (%eax),%eax
    f5a8:	0f b6 c0             	movzbl %al,%eax
    f5ab:	01 c2                	add    %eax,%edx
    f5ad:	8b 45 08             	mov    0x8(%ebp),%eax
    f5b0:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    f5b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5b9:	83 c0 08             	add    $0x8,%eax
    f5bc:	0f b6 00             	movzbl (%eax),%eax
    f5bf:	0f b6 c0             	movzbl %al,%eax
    f5c2:	c1 e0 08             	shl    $0x8,%eax
    f5c5:	89 c2                	mov    %eax,%edx
    f5c7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5ca:	83 c0 09             	add    $0x9,%eax
    f5cd:	0f b6 00             	movzbl (%eax),%eax
    f5d0:	0f b6 c0             	movzbl %al,%eax
    f5d3:	01 d0                	add    %edx,%eax
    f5d5:	c1 e0 08             	shl    $0x8,%eax
    f5d8:	89 c2                	mov    %eax,%edx
    f5da:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5dd:	83 c0 0a             	add    $0xa,%eax
    f5e0:	0f b6 00             	movzbl (%eax),%eax
    f5e3:	0f b6 c0             	movzbl %al,%eax
    f5e6:	01 d0                	add    %edx,%eax
    f5e8:	c1 e0 08             	shl    $0x8,%eax
    f5eb:	89 c2                	mov    %eax,%edx
    f5ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5f0:	83 c0 0b             	add    $0xb,%eax
    f5f3:	0f b6 00             	movzbl (%eax),%eax
    f5f6:	0f b6 c0             	movzbl %al,%eax
    f5f9:	01 c2                	add    %eax,%edx
    f5fb:	8b 45 08             	mov    0x8(%ebp),%eax
    f5fe:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f604:	8b 45 0c             	mov    0xc(%ebp),%eax
    f607:	83 c0 0c             	add    $0xc,%eax
    f60a:	0f b6 00             	movzbl (%eax),%eax
    f60d:	0f b6 c0             	movzbl %al,%eax
    f610:	c1 e0 08             	shl    $0x8,%eax
    f613:	89 c2                	mov    %eax,%edx
    f615:	8b 45 0c             	mov    0xc(%ebp),%eax
    f618:	83 c0 0d             	add    $0xd,%eax
    f61b:	0f b6 00             	movzbl (%eax),%eax
    f61e:	0f b6 c0             	movzbl %al,%eax
    f621:	01 d0                	add    %edx,%eax
    f623:	c1 e0 08             	shl    $0x8,%eax
    f626:	89 c2                	mov    %eax,%edx
    f628:	8b 45 0c             	mov    0xc(%ebp),%eax
    f62b:	83 c0 0e             	add    $0xe,%eax
    f62e:	0f b6 00             	movzbl (%eax),%eax
    f631:	0f b6 c0             	movzbl %al,%eax
    f634:	01 d0                	add    %edx,%eax
    f636:	c1 e0 08             	shl    $0x8,%eax
    f639:	89 c2                	mov    %eax,%edx
    f63b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f63e:	83 c0 0f             	add    $0xf,%eax
    f641:	0f b6 00             	movzbl (%eax),%eax
    f644:	0f b6 c0             	movzbl %al,%eax
    f647:	01 c2                	add    %eax,%edx
    f649:	8b 45 08             	mov    0x8(%ebp),%eax
    f64c:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f652:	8b 45 0c             	mov    0xc(%ebp),%eax
    f655:	83 c0 10             	add    $0x10,%eax
    f658:	0f b6 00             	movzbl (%eax),%eax
    f65b:	0f b6 c0             	movzbl %al,%eax
    f65e:	c1 e0 08             	shl    $0x8,%eax
    f661:	89 c2                	mov    %eax,%edx
    f663:	8b 45 0c             	mov    0xc(%ebp),%eax
    f666:	83 c0 11             	add    $0x11,%eax
    f669:	0f b6 00             	movzbl (%eax),%eax
    f66c:	0f b6 c0             	movzbl %al,%eax
    f66f:	01 d0                	add    %edx,%eax
    f671:	c1 e0 08             	shl    $0x8,%eax
    f674:	89 c2                	mov    %eax,%edx
    f676:	8b 45 0c             	mov    0xc(%ebp),%eax
    f679:	83 c0 12             	add    $0x12,%eax
    f67c:	0f b6 00             	movzbl (%eax),%eax
    f67f:	0f b6 c0             	movzbl %al,%eax
    f682:	01 d0                	add    %edx,%eax
    f684:	c1 e0 08             	shl    $0x8,%eax
    f687:	89 c2                	mov    %eax,%edx
    f689:	8b 45 0c             	mov    0xc(%ebp),%eax
    f68c:	83 c0 13             	add    $0x13,%eax
    f68f:	0f b6 00             	movzbl (%eax),%eax
    f692:	0f b6 c0             	movzbl %al,%eax
    f695:	01 c2                	add    %eax,%edx
    f697:	8b 45 08             	mov    0x8(%ebp),%eax
    f69a:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f6a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    f6a3:	83 c0 14             	add    $0x14,%eax
    f6a6:	0f b6 00             	movzbl (%eax),%eax
    f6a9:	0f b6 c0             	movzbl %al,%eax
    f6ac:	c1 e0 08             	shl    $0x8,%eax
    f6af:	89 c2                	mov    %eax,%edx
    f6b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    f6b4:	83 c0 15             	add    $0x15,%eax
    f6b7:	0f b6 00             	movzbl (%eax),%eax
    f6ba:	0f b6 c0             	movzbl %al,%eax
    f6bd:	01 d0                	add    %edx,%eax
    f6bf:	c1 e0 08             	shl    $0x8,%eax
    f6c2:	89 c2                	mov    %eax,%edx
    f6c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f6c7:	83 c0 16             	add    $0x16,%eax
    f6ca:	0f b6 00             	movzbl (%eax),%eax
    f6cd:	0f b6 c0             	movzbl %al,%eax
    f6d0:	01 d0                	add    %edx,%eax
    f6d2:	c1 e0 08             	shl    $0x8,%eax
    f6d5:	89 c2                	mov    %eax,%edx
    f6d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f6da:	83 c0 17             	add    $0x17,%eax
    f6dd:	0f b6 00             	movzbl (%eax),%eax
    f6e0:	0f b6 c0             	movzbl %al,%eax
    f6e3:	01 c2                	add    %eax,%edx
    f6e5:	8b 45 08             	mov    0x8(%ebp),%eax
    f6e8:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f6ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    f6f1:	83 c0 18             	add    $0x18,%eax
    f6f4:	0f b6 00             	movzbl (%eax),%eax
    f6f7:	0f b6 c0             	movzbl %al,%eax
    f6fa:	c1 e0 08             	shl    $0x8,%eax
    f6fd:	89 c2                	mov    %eax,%edx
    f6ff:	8b 45 0c             	mov    0xc(%ebp),%eax
    f702:	83 c0 19             	add    $0x19,%eax
    f705:	0f b6 00             	movzbl (%eax),%eax
    f708:	0f b6 c0             	movzbl %al,%eax
    f70b:	01 d0                	add    %edx,%eax
    f70d:	c1 e0 08             	shl    $0x8,%eax
    f710:	89 c2                	mov    %eax,%edx
    f712:	8b 45 0c             	mov    0xc(%ebp),%eax
    f715:	83 c0 1a             	add    $0x1a,%eax
    f718:	0f b6 00             	movzbl (%eax),%eax
    f71b:	0f b6 c0             	movzbl %al,%eax
    f71e:	01 d0                	add    %edx,%eax
    f720:	c1 e0 08             	shl    $0x8,%eax
    f723:	89 c2                	mov    %eax,%edx
    f725:	8b 45 0c             	mov    0xc(%ebp),%eax
    f728:	83 c0 1b             	add    $0x1b,%eax
    f72b:	0f b6 00             	movzbl (%eax),%eax
    f72e:	0f b6 c0             	movzbl %al,%eax
    f731:	01 c2                	add    %eax,%edx
    f733:	8b 45 08             	mov    0x8(%ebp),%eax
    f736:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f73c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f73f:	83 c0 1c             	add    $0x1c,%eax
    f742:	0f b6 00             	movzbl (%eax),%eax
    f745:	0f b6 c0             	movzbl %al,%eax
    f748:	c1 e0 08             	shl    $0x8,%eax
    f74b:	89 c2                	mov    %eax,%edx
    f74d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f750:	83 c0 1d             	add    $0x1d,%eax
    f753:	0f b6 00             	movzbl (%eax),%eax
    f756:	0f b6 c0             	movzbl %al,%eax
    f759:	01 d0                	add    %edx,%eax
    f75b:	c1 e0 08             	shl    $0x8,%eax
    f75e:	89 c2                	mov    %eax,%edx
    f760:	8b 45 0c             	mov    0xc(%ebp),%eax
    f763:	83 c0 1e             	add    $0x1e,%eax
    f766:	0f b6 00             	movzbl (%eax),%eax
    f769:	0f b6 c0             	movzbl %al,%eax
    f76c:	01 d0                	add    %edx,%eax
    f76e:	c1 e0 08             	shl    $0x8,%eax
    f771:	89 c2                	mov    %eax,%edx
    f773:	8b 45 0c             	mov    0xc(%ebp),%eax
    f776:	83 c0 1f             	add    $0x1f,%eax
    f779:	0f b6 00             	movzbl (%eax),%eax
    f77c:	0f b6 c0             	movzbl %al,%eax
    f77f:	01 c2                	add    %eax,%edx
    f781:	8b 45 08             	mov    0x8(%ebp),%eax
    f784:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f78a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f78f:	5d                   	pop    %ebp
    f790:	c3                   	ret    

0000f791 <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f791:	55                   	push   %ebp
    f792:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f794:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f798:	74 07                	je     f7a1 <readChunk_sRGB+0x10>
    f79a:	b8 62 00 00 00       	mov    $0x62,%eax
    f79f:	eb 24                	jmp    f7c5 <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f7a1:	8b 45 08             	mov    0x8(%ebp),%eax
    f7a4:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f7ab:	00 00 00 
  info->srgb_intent = data[0];
    f7ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7b1:	0f b6 00             	movzbl (%eax),%eax
    f7b4:	0f b6 d0             	movzbl %al,%edx
    f7b7:	8b 45 08             	mov    0x8(%ebp),%eax
    f7ba:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f7c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f7c5:	5d                   	pop    %ebp
    f7c6:	c3                   	ret    

0000f7c7 <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f7c7:	55                   	push   %ebp
    f7c8:	89 e5                	mov    %esp,%ebp
    f7ca:	53                   	push   %ebx
    f7cb:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f7ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f7d5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f7dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7df:	8b 10                	mov    (%eax),%edx
    f7e1:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f7e4:	8b 50 04             	mov    0x4(%eax),%edx
    f7e7:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f7ea:	8b 50 08             	mov    0x8(%eax),%edx
    f7ed:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f7f0:	8b 50 0c             	mov    0xc(%eax),%edx
    f7f3:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f7f6:	8b 50 10             	mov    0x10(%eax),%edx
    f7f9:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f7fc:	8b 40 14             	mov    0x14(%eax),%eax
    f7ff:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f802:	8b 45 08             	mov    0x8(%ebp),%eax
    f805:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f80c:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f80f:	8b 45 08             	mov    0x8(%ebp),%eax
    f812:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f818:	85 c0                	test   %eax,%eax
    f81a:	74 0e                	je     f82a <readChunk_iCCP+0x63>
    f81c:	83 ec 0c             	sub    $0xc,%esp
    f81f:	ff 75 08             	pushl  0x8(%ebp)
    f822:	e8 ca a6 ff ff       	call   9ef1 <lodepng_clear_icc>
    f827:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f82a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f831:	eb 04                	jmp    f837 <readChunk_iCCP+0x70>
    f833:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f837:	8b 45 14             	mov    0x14(%ebp),%eax
    f83a:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f83d:	73 0f                	jae    f84e <readChunk_iCCP+0x87>
    f83f:	8b 55 10             	mov    0x10(%ebp),%edx
    f842:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f845:	01 d0                	add    %edx,%eax
    f847:	0f b6 00             	movzbl (%eax),%eax
    f84a:	84 c0                	test   %al,%al
    f84c:	75 e5                	jne    f833 <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f84e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f851:	8d 50 02             	lea    0x2(%eax),%edx
    f854:	8b 45 14             	mov    0x14(%ebp),%eax
    f857:	39 c2                	cmp    %eax,%edx
    f859:	72 0a                	jb     f865 <readChunk_iCCP+0x9e>
    f85b:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f860:	e9 46 01 00 00       	jmp    f9ab <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f865:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f869:	74 06                	je     f871 <readChunk_iCCP+0xaa>
    f86b:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f86f:	76 0a                	jbe    f87b <readChunk_iCCP+0xb4>
    f871:	b8 59 00 00 00       	mov    $0x59,%eax
    f876:	e9 30 01 00 00       	jmp    f9ab <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    f87b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f87e:	83 c0 01             	add    $0x1,%eax
    f881:	83 ec 0c             	sub    $0xc,%esp
    f884:	50                   	push   %eax
    f885:	e8 1a 40 ff ff       	call   38a4 <lodepng_malloc>
    f88a:	83 c4 10             	add    $0x10,%esp
    f88d:	89 c2                	mov    %eax,%edx
    f88f:	8b 45 08             	mov    0x8(%ebp),%eax
    f892:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    f898:	8b 45 08             	mov    0x8(%ebp),%eax
    f89b:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f8a1:	85 c0                	test   %eax,%eax
    f8a3:	75 0a                	jne    f8af <readChunk_iCCP+0xe8>
    f8a5:	b8 53 00 00 00       	mov    $0x53,%eax
    f8aa:	e9 fc 00 00 00       	jmp    f9ab <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    f8af:	8b 45 08             	mov    0x8(%ebp),%eax
    f8b2:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f8b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f8bb:	01 d0                	add    %edx,%eax
    f8bd:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    f8c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f8c7:	eb 1f                	jmp    f8e8 <readChunk_iCCP+0x121>
    f8c9:	8b 45 08             	mov    0x8(%ebp),%eax
    f8cc:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f8d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f8d5:	01 d0                	add    %edx,%eax
    f8d7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f8da:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f8dd:	01 ca                	add    %ecx,%edx
    f8df:	0f b6 12             	movzbl (%edx),%edx
    f8e2:	88 10                	mov    %dl,(%eax)
    f8e4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f8e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f8eb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f8ee:	75 d9                	jne    f8c9 <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    f8f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f8f3:	8d 50 01             	lea    0x1(%eax),%edx
    f8f6:	8b 45 10             	mov    0x10(%ebp),%eax
    f8f9:	01 d0                	add    %edx,%eax
    f8fb:	0f b6 00             	movzbl (%eax),%eax
    f8fe:	84 c0                	test   %al,%al
    f900:	74 0a                	je     f90c <readChunk_iCCP+0x145>
    f902:	b8 48 00 00 00       	mov    $0x48,%eax
    f907:	e9 9f 00 00 00       	jmp    f9ab <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    f90c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f90f:	83 c0 02             	add    $0x2,%eax
    f912:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    f915:	8b 45 14             	mov    0x14(%ebp),%eax
    f918:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f91b:	76 0a                	jbe    f927 <readChunk_iCCP+0x160>
    f91d:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f922:	e9 84 00 00 00       	jmp    f9ab <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    f927:	8b 45 14             	mov    0x14(%ebp),%eax
    f92a:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f92d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    f930:	8b 45 0c             	mov    0xc(%ebp),%eax
    f933:	8b 40 34             	mov    0x34(%eax),%eax
    f936:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    f939:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f93c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f93f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f942:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    f945:	8b 55 08             	mov    0x8(%ebp),%edx
    f948:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    f94e:	83 ec 08             	sub    $0x8,%esp
    f951:	8d 55 cc             	lea    -0x34(%ebp),%edx
    f954:	52                   	push   %edx
    f955:	50                   	push   %eax
    f956:	53                   	push   %ebx
    f957:	6a 00                	push   $0x0
    f959:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    f95c:	50                   	push   %eax
    f95d:	51                   	push   %ecx
    f95e:	e8 fc 89 ff ff       	call   835f <zlib_decompress>
    f963:	83 c4 20             	add    $0x20,%esp
    f966:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    f969:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f96d:	74 11                	je     f980 <readChunk_iCCP+0x1b9>
    f96f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    f972:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f975:	39 c2                	cmp    %eax,%edx
    f977:	7d 07                	jge    f980 <readChunk_iCCP+0x1b9>
    f979:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    f980:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f983:	89 c2                	mov    %eax,%edx
    f985:	8b 45 08             	mov    0x8(%ebp),%eax
    f988:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    f98e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f992:	75 14                	jne    f9a8 <readChunk_iCCP+0x1e1>
    f994:	8b 45 08             	mov    0x8(%ebp),%eax
    f997:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    f99d:	85 c0                	test   %eax,%eax
    f99f:	75 07                	jne    f9a8 <readChunk_iCCP+0x1e1>
    f9a1:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    f9a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f9ab:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f9ae:	c9                   	leave  
    f9af:	c3                   	ret    

0000f9b0 <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    f9b0:	55                   	push   %ebp
    f9b1:	89 e5                	mov    %esp,%ebp
    f9b3:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    f9b6:	8b 55 0c             	mov    0xc(%ebp),%edx
    f9b9:	8b 45 10             	mov    0x10(%ebp),%eax
    f9bc:	01 d0                	add    %edx,%eax
    f9be:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    f9c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    f9c8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    f9cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    f9d2:	83 c0 04             	add    $0x4,%eax
    f9d5:	3b 45 14             	cmp    0x14(%ebp),%eax
    f9d8:	7e 0a                	jle    f9e4 <lodepng_inspect_chunk+0x34>
    f9da:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f9df:	e9 43 03 00 00       	jmp    fd27 <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    f9e4:	ff 75 ec             	pushl  -0x14(%ebp)
    f9e7:	e8 3a 8e ff ff       	call   8826 <lodepng_chunk_length>
    f9ec:	83 c4 04             	add    $0x4,%esp
    f9ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    f9f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f9f5:	85 c0                	test   %eax,%eax
    f9f7:	79 0a                	jns    fa03 <lodepng_inspect_chunk+0x53>
    f9f9:	b8 3f 00 00 00       	mov    $0x3f,%eax
    f9fe:	e9 24 03 00 00       	jmp    fd27 <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    fa03:	ff 75 ec             	pushl  -0x14(%ebp)
    fa06:	e8 53 8f ff ff       	call   895e <lodepng_chunk_data_const>
    fa0b:	83 c4 04             	add    $0x4,%esp
    fa0e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    fa11:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fa14:	8d 50 04             	lea    0x4(%eax),%edx
    fa17:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fa1a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    fa1d:	8b 55 14             	mov    0x14(%ebp),%edx
    fa20:	8b 45 10             	mov    0x10(%ebp),%eax
    fa23:	01 d0                	add    %edx,%eax
    fa25:	39 c1                	cmp    %eax,%ecx
    fa27:	76 0a                	jbe    fa33 <lodepng_inspect_chunk+0x83>
    fa29:	b8 1e 00 00 00       	mov    $0x1e,%eax
    fa2e:	e9 f4 02 00 00       	jmp    fd27 <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    fa33:	68 08 a6 01 00       	push   $0x1a608
    fa38:	ff 75 ec             	pushl  -0x14(%ebp)
    fa3b:	e8 33 8e ff ff       	call   8873 <lodepng_chunk_type_equals>
    fa40:	83 c4 08             	add    $0x8,%esp
    fa43:	84 c0                	test   %al,%al
    fa45:	74 24                	je     fa6b <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    fa47:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fa4a:	8b 55 08             	mov    0x8(%ebp),%edx
    fa4d:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fa53:	83 ec 04             	sub    $0x4,%esp
    fa56:	50                   	push   %eax
    fa57:	ff 75 e4             	pushl  -0x1c(%ebp)
    fa5a:	52                   	push   %edx
    fa5b:	e8 5b ee ff ff       	call   e8bb <readChunk_PLTE>
    fa60:	83 c4 10             	add    $0x10,%esp
    fa63:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fa66:	e9 8a 02 00 00       	jmp    fcf5 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fa6b:	83 ec 08             	sub    $0x8,%esp
    fa6e:	68 0d a6 01 00       	push   $0x1a60d
    fa73:	ff 75 ec             	pushl  -0x14(%ebp)
    fa76:	e8 f8 8d ff ff       	call   8873 <lodepng_chunk_type_equals>
    fa7b:	83 c4 10             	add    $0x10,%esp
    fa7e:	84 c0                	test   %al,%al
    fa80:	74 24                	je     faa6 <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    fa82:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fa85:	8b 55 08             	mov    0x8(%ebp),%edx
    fa88:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fa8e:	83 ec 04             	sub    $0x4,%esp
    fa91:	50                   	push   %eax
    fa92:	ff 75 e4             	pushl  -0x1c(%ebp)
    fa95:	52                   	push   %edx
    fa96:	e8 40 ef ff ff       	call   e9db <readChunk_tRNS>
    fa9b:	83 c4 10             	add    $0x10,%esp
    fa9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    faa1:	e9 4f 02 00 00       	jmp    fcf5 <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    faa6:	83 ec 08             	sub    $0x8,%esp
    faa9:	68 12 a6 01 00       	push   $0x1a612
    faae:	ff 75 ec             	pushl  -0x14(%ebp)
    fab1:	e8 bd 8d ff ff       	call   8873 <lodepng_chunk_type_equals>
    fab6:	83 c4 10             	add    $0x10,%esp
    fab9:	84 c0                	test   %al,%al
    fabb:	74 24                	je     fae1 <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fabd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fac0:	8b 55 08             	mov    0x8(%ebp),%edx
    fac3:	81 c2 98 00 00 00    	add    $0x98,%edx
    fac9:	83 ec 04             	sub    $0x4,%esp
    facc:	50                   	push   %eax
    facd:	ff 75 e4             	pushl  -0x1c(%ebp)
    fad0:	52                   	push   %edx
    fad1:	e8 68 f0 ff ff       	call   eb3e <readChunk_bKGD>
    fad6:	83 c4 10             	add    $0x10,%esp
    fad9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fadc:	e9 14 02 00 00       	jmp    fcf5 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fae1:	83 ec 08             	sub    $0x8,%esp
    fae4:	68 17 a6 01 00       	push   $0x1a617
    fae9:	ff 75 ec             	pushl  -0x14(%ebp)
    faec:	e8 82 8d ff ff       	call   8873 <lodepng_chunk_type_equals>
    faf1:	83 c4 10             	add    $0x10,%esp
    faf4:	84 c0                	test   %al,%al
    faf6:	74 24                	je     fb1c <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    faf8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fafb:	8b 55 08             	mov    0x8(%ebp),%edx
    fafe:	81 c2 98 00 00 00    	add    $0x98,%edx
    fb04:	83 ec 04             	sub    $0x4,%esp
    fb07:	50                   	push   %eax
    fb08:	ff 75 e4             	pushl  -0x1c(%ebp)
    fb0b:	52                   	push   %edx
    fb0c:	e8 b0 f1 ff ff       	call   ecc1 <readChunk_tEXt>
    fb11:	83 c4 10             	add    $0x10,%esp
    fb14:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fb17:	e9 d9 01 00 00       	jmp    fcf5 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    fb1c:	83 ec 08             	sub    $0x8,%esp
    fb1f:	68 1c a6 01 00       	push   $0x1a61c
    fb24:	ff 75 ec             	pushl  -0x14(%ebp)
    fb27:	e8 47 8d ff ff       	call   8873 <lodepng_chunk_type_equals>
    fb2c:	83 c4 10             	add    $0x10,%esp
    fb2f:	84 c0                	test   %al,%al
    fb31:	74 25                	je     fb58 <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    fb33:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fb36:	8b 45 08             	mov    0x8(%ebp),%eax
    fb39:	8b 4d 08             	mov    0x8(%ebp),%ecx
    fb3c:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fb42:	52                   	push   %edx
    fb43:	ff 75 e4             	pushl  -0x1c(%ebp)
    fb46:	50                   	push   %eax
    fb47:	51                   	push   %ecx
    fb48:	e8 c0 f2 ff ff       	call   ee0d <readChunk_zTXt>
    fb4d:	83 c4 10             	add    $0x10,%esp
    fb50:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fb53:	e9 9d 01 00 00       	jmp    fcf5 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    fb58:	83 ec 08             	sub    $0x8,%esp
    fb5b:	68 21 a6 01 00       	push   $0x1a621
    fb60:	ff 75 ec             	pushl  -0x14(%ebp)
    fb63:	e8 0b 8d ff ff       	call   8873 <lodepng_chunk_type_equals>
    fb68:	83 c4 10             	add    $0x10,%esp
    fb6b:	84 c0                	test   %al,%al
    fb6d:	74 25                	je     fb94 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    fb6f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fb72:	8b 45 08             	mov    0x8(%ebp),%eax
    fb75:	8b 4d 08             	mov    0x8(%ebp),%ecx
    fb78:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fb7e:	52                   	push   %edx
    fb7f:	ff 75 e4             	pushl  -0x1c(%ebp)
    fb82:	50                   	push   %eax
    fb83:	51                   	push   %ecx
    fb84:	e8 40 f4 ff ff       	call   efc9 <readChunk_iTXt>
    fb89:	83 c4 10             	add    $0x10,%esp
    fb8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fb8f:	e9 61 01 00 00       	jmp    fcf5 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    fb94:	83 ec 08             	sub    $0x8,%esp
    fb97:	68 26 a6 01 00       	push   $0x1a626
    fb9c:	ff 75 ec             	pushl  -0x14(%ebp)
    fb9f:	e8 cf 8c ff ff       	call   8873 <lodepng_chunk_type_equals>
    fba4:	83 c4 10             	add    $0x10,%esp
    fba7:	84 c0                	test   %al,%al
    fba9:	74 24                	je     fbcf <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    fbab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fbae:	8b 55 08             	mov    0x8(%ebp),%edx
    fbb1:	81 c2 98 00 00 00    	add    $0x98,%edx
    fbb7:	83 ec 04             	sub    $0x4,%esp
    fbba:	50                   	push   %eax
    fbbb:	ff 75 e4             	pushl  -0x1c(%ebp)
    fbbe:	52                   	push   %edx
    fbbf:	e8 5b f7 ff ff       	call   f31f <readChunk_tIME>
    fbc4:	83 c4 10             	add    $0x10,%esp
    fbc7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fbca:	e9 26 01 00 00       	jmp    fcf5 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    fbcf:	83 ec 08             	sub    $0x8,%esp
    fbd2:	68 2b a6 01 00       	push   $0x1a62b
    fbd7:	ff 75 ec             	pushl  -0x14(%ebp)
    fbda:	e8 94 8c ff ff       	call   8873 <lodepng_chunk_type_equals>
    fbdf:	83 c4 10             	add    $0x10,%esp
    fbe2:	84 c0                	test   %al,%al
    fbe4:	74 24                	je     fc0a <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    fbe6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fbe9:	8b 55 08             	mov    0x8(%ebp),%edx
    fbec:	81 c2 98 00 00 00    	add    $0x98,%edx
    fbf2:	83 ec 04             	sub    $0x4,%esp
    fbf5:	50                   	push   %eax
    fbf6:	ff 75 e4             	pushl  -0x1c(%ebp)
    fbf9:	52                   	push   %edx
    fbfa:	e8 c0 f7 ff ff       	call   f3bf <readChunk_pHYs>
    fbff:	83 c4 10             	add    $0x10,%esp
    fc02:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fc05:	e9 eb 00 00 00       	jmp    fcf5 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    fc0a:	83 ec 08             	sub    $0x8,%esp
    fc0d:	68 30 a6 01 00       	push   $0x1a630
    fc12:	ff 75 ec             	pushl  -0x14(%ebp)
    fc15:	e8 59 8c ff ff       	call   8873 <lodepng_chunk_type_equals>
    fc1a:	83 c4 10             	add    $0x10,%esp
    fc1d:	84 c0                	test   %al,%al
    fc1f:	74 24                	je     fc45 <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    fc21:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fc24:	8b 55 08             	mov    0x8(%ebp),%edx
    fc27:	81 c2 98 00 00 00    	add    $0x98,%edx
    fc2d:	83 ec 04             	sub    $0x4,%esp
    fc30:	50                   	push   %eax
    fc31:	ff 75 e4             	pushl  -0x1c(%ebp)
    fc34:	52                   	push   %edx
    fc35:	e8 54 f8 ff ff       	call   f48e <readChunk_gAMA>
    fc3a:	83 c4 10             	add    $0x10,%esp
    fc3d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fc40:	e9 b0 00 00 00       	jmp    fcf5 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    fc45:	83 ec 08             	sub    $0x8,%esp
    fc48:	68 35 a6 01 00       	push   $0x1a635
    fc4d:	ff 75 ec             	pushl  -0x14(%ebp)
    fc50:	e8 1e 8c ff ff       	call   8873 <lodepng_chunk_type_equals>
    fc55:	83 c4 10             	add    $0x10,%esp
    fc58:	84 c0                	test   %al,%al
    fc5a:	74 21                	je     fc7d <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    fc5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fc5f:	8b 55 08             	mov    0x8(%ebp),%edx
    fc62:	81 c2 98 00 00 00    	add    $0x98,%edx
    fc68:	83 ec 04             	sub    $0x4,%esp
    fc6b:	50                   	push   %eax
    fc6c:	ff 75 e4             	pushl  -0x1c(%ebp)
    fc6f:	52                   	push   %edx
    fc70:	e8 88 f8 ff ff       	call   f4fd <readChunk_cHRM>
    fc75:	83 c4 10             	add    $0x10,%esp
    fc78:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fc7b:	eb 78                	jmp    fcf5 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    fc7d:	83 ec 08             	sub    $0x8,%esp
    fc80:	68 3a a6 01 00       	push   $0x1a63a
    fc85:	ff 75 ec             	pushl  -0x14(%ebp)
    fc88:	e8 e6 8b ff ff       	call   8873 <lodepng_chunk_type_equals>
    fc8d:	83 c4 10             	add    $0x10,%esp
    fc90:	84 c0                	test   %al,%al
    fc92:	74 21                	je     fcb5 <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    fc94:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fc97:	8b 55 08             	mov    0x8(%ebp),%edx
    fc9a:	81 c2 98 00 00 00    	add    $0x98,%edx
    fca0:	83 ec 04             	sub    $0x4,%esp
    fca3:	50                   	push   %eax
    fca4:	ff 75 e4             	pushl  -0x1c(%ebp)
    fca7:	52                   	push   %edx
    fca8:	e8 e4 fa ff ff       	call   f791 <readChunk_sRGB>
    fcad:	83 c4 10             	add    $0x10,%esp
    fcb0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fcb3:	eb 40                	jmp    fcf5 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    fcb5:	83 ec 08             	sub    $0x8,%esp
    fcb8:	68 3f a6 01 00       	push   $0x1a63f
    fcbd:	ff 75 ec             	pushl  -0x14(%ebp)
    fcc0:	e8 ae 8b ff ff       	call   8873 <lodepng_chunk_type_equals>
    fcc5:	83 c4 10             	add    $0x10,%esp
    fcc8:	84 c0                	test   %al,%al
    fcca:	74 22                	je     fcee <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    fccc:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fccf:	8b 45 08             	mov    0x8(%ebp),%eax
    fcd2:	8b 4d 08             	mov    0x8(%ebp),%ecx
    fcd5:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fcdb:	52                   	push   %edx
    fcdc:	ff 75 e4             	pushl  -0x1c(%ebp)
    fcdf:	50                   	push   %eax
    fce0:	51                   	push   %ecx
    fce1:	e8 e1 fa ff ff       	call   f7c7 <readChunk_iCCP>
    fce6:	83 c4 10             	add    $0x10,%esp
    fce9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fcec:	eb 07                	jmp    fcf5 <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    fcee:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    fcf5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    fcf9:	75 29                	jne    fd24 <lodepng_inspect_chunk+0x374>
    fcfb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fcff:	75 23                	jne    fd24 <lodepng_inspect_chunk+0x374>
    fd01:	8b 45 08             	mov    0x8(%ebp),%eax
    fd04:	8b 40 18             	mov    0x18(%eax),%eax
    fd07:	85 c0                	test   %eax,%eax
    fd09:	75 19                	jne    fd24 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    fd0b:	83 ec 0c             	sub    $0xc,%esp
    fd0e:	ff 75 ec             	pushl  -0x14(%ebp)
    fd11:	e8 53 8c ff ff       	call   8969 <lodepng_chunk_check_crc>
    fd16:	83 c4 10             	add    $0x10,%esp
    fd19:	85 c0                	test   %eax,%eax
    fd1b:	74 07                	je     fd24 <lodepng_inspect_chunk+0x374>
    fd1d:	b8 39 00 00 00       	mov    $0x39,%eax
    fd22:	eb 03                	jmp    fd27 <lodepng_inspect_chunk+0x377>
  }

  return error;
    fd24:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    fd27:	c9                   	leave  
    fd28:	c3                   	ret    

0000fd29 <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    fd29:	55                   	push   %ebp
    fd2a:	89 e5                	mov    %esp,%ebp
    fd2c:	56                   	push   %esi
    fd2d:	53                   	push   %ebx
    fd2e:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    fd31:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    fd35:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    fd3c:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    fd43:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    fd4a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    fd51:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    fd58:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    fd5f:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    fd66:	8b 45 08             	mov    0x8(%ebp),%eax
    fd69:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    fd6f:	8b 45 10             	mov    0x10(%ebp),%eax
    fd72:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    fd78:	8b 45 10             	mov    0x10(%ebp),%eax
    fd7b:	8b 10                	mov    (%eax),%edx
    fd7d:	8b 45 0c             	mov    0xc(%ebp),%eax
    fd80:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    fd82:	83 ec 0c             	sub    $0xc,%esp
    fd85:	ff 75 1c             	pushl  0x1c(%ebp)
    fd88:	ff 75 18             	pushl  0x18(%ebp)
    fd8b:	ff 75 14             	pushl  0x14(%ebp)
    fd8e:	ff 75 10             	pushl  0x10(%ebp)
    fd91:	ff 75 0c             	pushl  0xc(%ebp)
    fd94:	e8 d3 da ff ff       	call   d86c <lodepng_inspect>
    fd99:	83 c4 20             	add    $0x20,%esp
    fd9c:	89 c2                	mov    %eax,%edx
    fd9e:	8b 45 14             	mov    0x14(%ebp),%eax
    fda1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    fda7:	8b 45 14             	mov    0x14(%ebp),%eax
    fdaa:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fdb0:	85 c0                	test   %eax,%eax
    fdb2:	0f 85 24 0a 00 00    	jne    107dc <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    fdb8:	8b 45 14             	mov    0x14(%ebp),%eax
    fdbb:	8d 58 78             	lea    0x78(%eax),%ebx
    fdbe:	8b 45 14             	mov    0x14(%ebp),%eax
    fdc1:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    fdc7:	8b 45 10             	mov    0x10(%ebp),%eax
    fdca:	8b 10                	mov    (%eax),%edx
    fdcc:	8b 45 0c             	mov    0xc(%ebp),%eax
    fdcf:	8b 00                	mov    (%eax),%eax
    fdd1:	53                   	push   %ebx
    fdd2:	51                   	push   %ecx
    fdd3:	52                   	push   %edx
    fdd4:	50                   	push   %eax
    fdd5:	e8 76 97 ff ff       	call   9550 <lodepng_pixel_overflow>
    fdda:	83 c4 10             	add    $0x10,%esp
    fddd:	85 c0                	test   %eax,%eax
    fddf:	74 12                	je     fdf3 <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    fde1:	8b 45 14             	mov    0x14(%ebp),%eax
    fde4:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    fdeb:	00 00 00 
    fdee:	e9 ea 09 00 00       	jmp    107dd <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    fdf3:	83 ec 0c             	sub    $0xc,%esp
    fdf6:	ff 75 1c             	pushl  0x1c(%ebp)
    fdf9:	e8 a6 3a ff ff       	call   38a4 <lodepng_malloc>
    fdfe:	83 c4 10             	add    $0x10,%esp
    fe01:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    fe04:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    fe08:	75 12                	jne    fe1c <decodeGeneric+0xf3>
    fe0a:	8b 45 14             	mov    0x14(%ebp),%eax
    fe0d:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    fe14:	00 00 00 
    fe17:	e9 c1 09 00 00       	jmp    107dd <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    fe1c:	8b 45 18             	mov    0x18(%ebp),%eax
    fe1f:	83 c0 21             	add    $0x21,%eax
    fe22:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    fe25:	e9 81 06 00 00       	jmp    104ab <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    fe2a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fe2d:	8b 45 18             	mov    0x18(%ebp),%eax
    fe30:	29 c2                	sub    %eax,%edx
    fe32:	89 d0                	mov    %edx,%eax
    fe34:	83 c0 0c             	add    $0xc,%eax
    fe37:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fe3a:	7f 08                	jg     fe44 <decodeGeneric+0x11b>
    fe3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fe3f:	3b 45 18             	cmp    0x18(%ebp),%eax
    fe42:	73 20                	jae    fe64 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    fe44:	8b 45 14             	mov    0x14(%ebp),%eax
    fe47:	8b 40 20             	mov    0x20(%eax),%eax
    fe4a:	85 c0                	test   %eax,%eax
    fe4c:	0f 85 72 06 00 00    	jne    104c4 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    fe52:	8b 45 14             	mov    0x14(%ebp),%eax
    fe55:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    fe5c:	00 00 00 
    fe5f:	e9 6a 06 00 00       	jmp    104ce <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    fe64:	83 ec 0c             	sub    $0xc,%esp
    fe67:	ff 75 f0             	pushl  -0x10(%ebp)
    fe6a:	e8 b7 89 ff ff       	call   8826 <lodepng_chunk_length>
    fe6f:	83 c4 10             	add    $0x10,%esp
    fe72:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
    fe75:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fe78:	85 c0                	test   %eax,%eax
    fe7a:	79 20                	jns    fe9c <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    fe7c:	8b 45 14             	mov    0x14(%ebp),%eax
    fe7f:	8b 40 20             	mov    0x20(%eax),%eax
    fe82:	85 c0                	test   %eax,%eax
    fe84:	0f 85 3d 06 00 00    	jne    104c7 <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
    fe8a:	8b 45 14             	mov    0x14(%ebp),%eax
    fe8d:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
    fe94:	00 00 00 
    fe97:	e9 32 06 00 00       	jmp    104ce <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
    fe9c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fe9f:	8b 45 18             	mov    0x18(%ebp),%eax
    fea2:	29 c2                	sub    %eax,%edx
    fea4:	89 d0                	mov    %edx,%eax
    fea6:	89 c2                	mov    %eax,%edx
    fea8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    feab:	01 d0                	add    %edx,%eax
    fead:	83 c0 0c             	add    $0xc,%eax
    feb0:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    feb3:	7f 10                	jg     fec5 <decodeGeneric+0x19c>
    feb5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    feb8:	8d 50 0c             	lea    0xc(%eax),%edx
    febb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    febe:	01 d0                	add    %edx,%eax
    fec0:	3b 45 18             	cmp    0x18(%ebp),%eax
    fec3:	73 12                	jae    fed7 <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    fec5:	8b 45 14             	mov    0x14(%ebp),%eax
    fec8:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
    fecf:	00 00 00 
    fed2:	e9 f7 05 00 00       	jmp    104ce <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
    fed7:	83 ec 0c             	sub    $0xc,%esp
    feda:	ff 75 f0             	pushl  -0x10(%ebp)
    fedd:	e8 7c 8a ff ff       	call   895e <lodepng_chunk_data_const>
    fee2:	83 c4 10             	add    $0x10,%esp
    fee5:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
    fee8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
    feef:	83 ec 08             	sub    $0x8,%esp
    fef2:	68 44 a6 01 00       	push   $0x1a644
    fef7:	ff 75 f0             	pushl  -0x10(%ebp)
    fefa:	e8 74 89 ff ff       	call   8873 <lodepng_chunk_type_equals>
    feff:	83 c4 10             	add    $0x10,%esp
    ff02:	84 c0                	test   %al,%al
    ff04:	74 79                	je     ff7f <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
    ff06:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ff09:	83 ec 04             	sub    $0x4,%esp
    ff0c:	8d 55 bc             	lea    -0x44(%ebp),%edx
    ff0f:	52                   	push   %edx
    ff10:	50                   	push   %eax
    ff11:	ff 75 ec             	pushl  -0x14(%ebp)
    ff14:	e8 4f 3a ff ff       	call   3968 <lodepng_addofl>
    ff19:	83 c4 10             	add    $0x10,%esp
    ff1c:	85 c0                	test   %eax,%eax
    ff1e:	74 12                	je     ff32 <decodeGeneric+0x209>
    ff20:	8b 45 14             	mov    0x14(%ebp),%eax
    ff23:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    ff2a:	00 00 00 
    ff2d:	e9 9c 05 00 00       	jmp    104ce <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
    ff32:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ff35:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ff38:	7e 13                	jle    ff4d <decodeGeneric+0x224>
    ff3a:	8b 45 14             	mov    0x14(%ebp),%eax
    ff3d:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    ff44:	00 00 00 
    ff47:	90                   	nop
    ff48:	e9 81 05 00 00       	jmp    104ce <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
    ff4d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ff50:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    ff53:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ff56:	01 ca                	add    %ecx,%edx
    ff58:	83 ec 04             	sub    $0x4,%esp
    ff5b:	50                   	push   %eax
    ff5c:	ff 75 d0             	pushl  -0x30(%ebp)
    ff5f:	52                   	push   %edx
    ff60:	e8 7d 39 ff ff       	call   38e2 <lodepng_memcpy>
    ff65:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
    ff68:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ff6b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ff6e:	01 d0                	add    %edx,%eax
    ff70:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
    ff73:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    ff7a:	e9 db 04 00 00       	jmp    1045a <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
    ff7f:	83 ec 08             	sub    $0x8,%esp
    ff82:	68 49 a6 01 00       	push   $0x1a649
    ff87:	ff 75 f0             	pushl  -0x10(%ebp)
    ff8a:	e8 e4 88 ff ff       	call   8873 <lodepng_chunk_type_equals>
    ff8f:	83 c4 10             	add    $0x10,%esp
    ff92:	84 c0                	test   %al,%al
    ff94:	74 09                	je     ff9f <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
    ff96:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    ff9a:	e9 bb 04 00 00       	jmp    1045a <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    ff9f:	83 ec 08             	sub    $0x8,%esp
    ffa2:	68 08 a6 01 00       	push   $0x1a608
    ffa7:	ff 75 f0             	pushl  -0x10(%ebp)
    ffaa:	e8 c4 88 ff ff       	call   8873 <lodepng_chunk_type_equals>
    ffaf:	83 c4 10             	add    $0x10,%esp
    ffb2:	84 c0                	test   %al,%al
    ffb4:	74 44                	je     fffa <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    ffb6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ffb9:	8b 55 14             	mov    0x14(%ebp),%edx
    ffbc:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    ffc2:	83 ec 04             	sub    $0x4,%esp
    ffc5:	50                   	push   %eax
    ffc6:	ff 75 d0             	pushl  -0x30(%ebp)
    ffc9:	52                   	push   %edx
    ffca:	e8 ec e8 ff ff       	call   e8bb <readChunk_PLTE>
    ffcf:	83 c4 10             	add    $0x10,%esp
    ffd2:	89 c2                	mov    %eax,%edx
    ffd4:	8b 45 14             	mov    0x14(%ebp),%eax
    ffd7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    ffdd:	8b 45 14             	mov    0x14(%ebp),%eax
    ffe0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ffe6:	85 c0                	test   %eax,%eax
    ffe8:	0f 85 dc 04 00 00    	jne    104ca <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
    ffee:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    fff5:	e9 60 04 00 00       	jmp    1045a <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fffa:	83 ec 08             	sub    $0x8,%esp
    fffd:	68 0d a6 01 00       	push   $0x1a60d
   10002:	ff 75 f0             	pushl  -0x10(%ebp)
   10005:	e8 69 88 ff ff       	call   8873 <lodepng_chunk_type_equals>
   1000a:	83 c4 10             	add    $0x10,%esp
   1000d:	84 c0                	test   %al,%al
   1000f:	74 3d                	je     1004e <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
   10011:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10014:	8b 55 14             	mov    0x14(%ebp),%edx
   10017:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   1001d:	83 ec 04             	sub    $0x4,%esp
   10020:	50                   	push   %eax
   10021:	ff 75 d0             	pushl  -0x30(%ebp)
   10024:	52                   	push   %edx
   10025:	e8 b1 e9 ff ff       	call   e9db <readChunk_tRNS>
   1002a:	83 c4 10             	add    $0x10,%esp
   1002d:	89 c2                	mov    %eax,%edx
   1002f:	8b 45 14             	mov    0x14(%ebp),%eax
   10032:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10038:	8b 45 14             	mov    0x14(%ebp),%eax
   1003b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10041:	85 c0                	test   %eax,%eax
   10043:	0f 84 11 04 00 00    	je     1045a <decodeGeneric+0x731>
   10049:	e9 80 04 00 00       	jmp    104ce <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
   1004e:	83 ec 08             	sub    $0x8,%esp
   10051:	68 12 a6 01 00       	push   $0x1a612
   10056:	ff 75 f0             	pushl  -0x10(%ebp)
   10059:	e8 15 88 ff ff       	call   8873 <lodepng_chunk_type_equals>
   1005e:	83 c4 10             	add    $0x10,%esp
   10061:	84 c0                	test   %al,%al
   10063:	74 3d                	je     100a2 <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
   10065:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10068:	8b 55 14             	mov    0x14(%ebp),%edx
   1006b:	81 c2 98 00 00 00    	add    $0x98,%edx
   10071:	83 ec 04             	sub    $0x4,%esp
   10074:	50                   	push   %eax
   10075:	ff 75 d0             	pushl  -0x30(%ebp)
   10078:	52                   	push   %edx
   10079:	e8 c0 ea ff ff       	call   eb3e <readChunk_bKGD>
   1007e:	83 c4 10             	add    $0x10,%esp
   10081:	89 c2                	mov    %eax,%edx
   10083:	8b 45 14             	mov    0x14(%ebp),%eax
   10086:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   1008c:	8b 45 14             	mov    0x14(%ebp),%eax
   1008f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10095:	85 c0                	test   %eax,%eax
   10097:	0f 84 bd 03 00 00    	je     1045a <decodeGeneric+0x731>
   1009d:	e9 2c 04 00 00       	jmp    104ce <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
   100a2:	83 ec 08             	sub    $0x8,%esp
   100a5:	68 17 a6 01 00       	push   $0x1a617
   100aa:	ff 75 f0             	pushl  -0x10(%ebp)
   100ad:	e8 c1 87 ff ff       	call   8873 <lodepng_chunk_type_equals>
   100b2:	83 c4 10             	add    $0x10,%esp
   100b5:	84 c0                	test   %al,%al
   100b7:	74 4b                	je     10104 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
   100b9:	8b 45 14             	mov    0x14(%ebp),%eax
   100bc:	8b 40 28             	mov    0x28(%eax),%eax
   100bf:	85 c0                	test   %eax,%eax
   100c1:	0f 84 93 03 00 00    	je     1045a <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
   100c7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   100ca:	8b 55 14             	mov    0x14(%ebp),%edx
   100cd:	81 c2 98 00 00 00    	add    $0x98,%edx
   100d3:	83 ec 04             	sub    $0x4,%esp
   100d6:	50                   	push   %eax
   100d7:	ff 75 d0             	pushl  -0x30(%ebp)
   100da:	52                   	push   %edx
   100db:	e8 e1 eb ff ff       	call   ecc1 <readChunk_tEXt>
   100e0:	83 c4 10             	add    $0x10,%esp
   100e3:	89 c2                	mov    %eax,%edx
   100e5:	8b 45 14             	mov    0x14(%ebp),%eax
   100e8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   100ee:	8b 45 14             	mov    0x14(%ebp),%eax
   100f1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   100f7:	85 c0                	test   %eax,%eax
   100f9:	0f 84 5b 03 00 00    	je     1045a <decodeGeneric+0x731>
   100ff:	e9 ca 03 00 00       	jmp    104ce <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
   10104:	83 ec 08             	sub    $0x8,%esp
   10107:	68 1c a6 01 00       	push   $0x1a61c
   1010c:	ff 75 f0             	pushl  -0x10(%ebp)
   1010f:	e8 5f 87 ff ff       	call   8873 <lodepng_chunk_type_equals>
   10114:	83 c4 10             	add    $0x10,%esp
   10117:	84 c0                	test   %al,%al
   10119:	74 4c                	je     10167 <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
   1011b:	8b 45 14             	mov    0x14(%ebp),%eax
   1011e:	8b 40 28             	mov    0x28(%eax),%eax
   10121:	85 c0                	test   %eax,%eax
   10123:	0f 84 31 03 00 00    	je     1045a <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
   10129:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   1012c:	8b 45 14             	mov    0x14(%ebp),%eax
   1012f:	8b 4d 14             	mov    0x14(%ebp),%ecx
   10132:	81 c1 98 00 00 00    	add    $0x98,%ecx
   10138:	52                   	push   %edx
   10139:	ff 75 d0             	pushl  -0x30(%ebp)
   1013c:	50                   	push   %eax
   1013d:	51                   	push   %ecx
   1013e:	e8 ca ec ff ff       	call   ee0d <readChunk_zTXt>
   10143:	83 c4 10             	add    $0x10,%esp
   10146:	89 c2                	mov    %eax,%edx
   10148:	8b 45 14             	mov    0x14(%ebp),%eax
   1014b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   10151:	8b 45 14             	mov    0x14(%ebp),%eax
   10154:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1015a:	85 c0                	test   %eax,%eax
   1015c:	0f 84 f8 02 00 00    	je     1045a <decodeGeneric+0x731>
   10162:	e9 67 03 00 00       	jmp    104ce <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
   10167:	83 ec 08             	sub    $0x8,%esp
   1016a:	68 21 a6 01 00       	push   $0x1a621
   1016f:	ff 75 f0             	pushl  -0x10(%ebp)
   10172:	e8 fc 86 ff ff       	call   8873 <lodepng_chunk_type_equals>
   10177:	83 c4 10             	add    $0x10,%esp
   1017a:	84 c0                	test   %al,%al
   1017c:	74 4c                	je     101ca <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
   1017e:	8b 45 14             	mov    0x14(%ebp),%eax
   10181:	8b 40 28             	mov    0x28(%eax),%eax
   10184:	85 c0                	test   %eax,%eax
   10186:	0f 84 ce 02 00 00    	je     1045a <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
   1018c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   1018f:	8b 45 14             	mov    0x14(%ebp),%eax
   10192:	8b 4d 14             	mov    0x14(%ebp),%ecx
   10195:	81 c1 98 00 00 00    	add    $0x98,%ecx
   1019b:	52                   	push   %edx
   1019c:	ff 75 d0             	pushl  -0x30(%ebp)
   1019f:	50                   	push   %eax
   101a0:	51                   	push   %ecx
   101a1:	e8 23 ee ff ff       	call   efc9 <readChunk_iTXt>
   101a6:	83 c4 10             	add    $0x10,%esp
   101a9:	89 c2                	mov    %eax,%edx
   101ab:	8b 45 14             	mov    0x14(%ebp),%eax
   101ae:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   101b4:	8b 45 14             	mov    0x14(%ebp),%eax
   101b7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   101bd:	85 c0                	test   %eax,%eax
   101bf:	0f 84 95 02 00 00    	je     1045a <decodeGeneric+0x731>
   101c5:	e9 04 03 00 00       	jmp    104ce <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
   101ca:	83 ec 08             	sub    $0x8,%esp
   101cd:	68 26 a6 01 00       	push   $0x1a626
   101d2:	ff 75 f0             	pushl  -0x10(%ebp)
   101d5:	e8 99 86 ff ff       	call   8873 <lodepng_chunk_type_equals>
   101da:	83 c4 10             	add    $0x10,%esp
   101dd:	84 c0                	test   %al,%al
   101df:	74 3d                	je     1021e <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
   101e1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   101e4:	8b 55 14             	mov    0x14(%ebp),%edx
   101e7:	81 c2 98 00 00 00    	add    $0x98,%edx
   101ed:	83 ec 04             	sub    $0x4,%esp
   101f0:	50                   	push   %eax
   101f1:	ff 75 d0             	pushl  -0x30(%ebp)
   101f4:	52                   	push   %edx
   101f5:	e8 25 f1 ff ff       	call   f31f <readChunk_tIME>
   101fa:	83 c4 10             	add    $0x10,%esp
   101fd:	89 c2                	mov    %eax,%edx
   101ff:	8b 45 14             	mov    0x14(%ebp),%eax
   10202:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10208:	8b 45 14             	mov    0x14(%ebp),%eax
   1020b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10211:	85 c0                	test   %eax,%eax
   10213:	0f 84 41 02 00 00    	je     1045a <decodeGeneric+0x731>
   10219:	e9 b0 02 00 00       	jmp    104ce <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
   1021e:	83 ec 08             	sub    $0x8,%esp
   10221:	68 2b a6 01 00       	push   $0x1a62b
   10226:	ff 75 f0             	pushl  -0x10(%ebp)
   10229:	e8 45 86 ff ff       	call   8873 <lodepng_chunk_type_equals>
   1022e:	83 c4 10             	add    $0x10,%esp
   10231:	84 c0                	test   %al,%al
   10233:	74 3d                	je     10272 <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
   10235:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10238:	8b 55 14             	mov    0x14(%ebp),%edx
   1023b:	81 c2 98 00 00 00    	add    $0x98,%edx
   10241:	83 ec 04             	sub    $0x4,%esp
   10244:	50                   	push   %eax
   10245:	ff 75 d0             	pushl  -0x30(%ebp)
   10248:	52                   	push   %edx
   10249:	e8 71 f1 ff ff       	call   f3bf <readChunk_pHYs>
   1024e:	83 c4 10             	add    $0x10,%esp
   10251:	89 c2                	mov    %eax,%edx
   10253:	8b 45 14             	mov    0x14(%ebp),%eax
   10256:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   1025c:	8b 45 14             	mov    0x14(%ebp),%eax
   1025f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10265:	85 c0                	test   %eax,%eax
   10267:	0f 84 ed 01 00 00    	je     1045a <decodeGeneric+0x731>
   1026d:	e9 5c 02 00 00       	jmp    104ce <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
   10272:	83 ec 08             	sub    $0x8,%esp
   10275:	68 30 a6 01 00       	push   $0x1a630
   1027a:	ff 75 f0             	pushl  -0x10(%ebp)
   1027d:	e8 f1 85 ff ff       	call   8873 <lodepng_chunk_type_equals>
   10282:	83 c4 10             	add    $0x10,%esp
   10285:	84 c0                	test   %al,%al
   10287:	74 3d                	je     102c6 <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
   10289:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1028c:	8b 55 14             	mov    0x14(%ebp),%edx
   1028f:	81 c2 98 00 00 00    	add    $0x98,%edx
   10295:	83 ec 04             	sub    $0x4,%esp
   10298:	50                   	push   %eax
   10299:	ff 75 d0             	pushl  -0x30(%ebp)
   1029c:	52                   	push   %edx
   1029d:	e8 ec f1 ff ff       	call   f48e <readChunk_gAMA>
   102a2:	83 c4 10             	add    $0x10,%esp
   102a5:	89 c2                	mov    %eax,%edx
   102a7:	8b 45 14             	mov    0x14(%ebp),%eax
   102aa:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   102b0:	8b 45 14             	mov    0x14(%ebp),%eax
   102b3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   102b9:	85 c0                	test   %eax,%eax
   102bb:	0f 84 99 01 00 00    	je     1045a <decodeGeneric+0x731>
   102c1:	e9 08 02 00 00       	jmp    104ce <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   102c6:	83 ec 08             	sub    $0x8,%esp
   102c9:	68 35 a6 01 00       	push   $0x1a635
   102ce:	ff 75 f0             	pushl  -0x10(%ebp)
   102d1:	e8 9d 85 ff ff       	call   8873 <lodepng_chunk_type_equals>
   102d6:	83 c4 10             	add    $0x10,%esp
   102d9:	84 c0                	test   %al,%al
   102db:	74 3d                	je     1031a <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
   102dd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   102e0:	8b 55 14             	mov    0x14(%ebp),%edx
   102e3:	81 c2 98 00 00 00    	add    $0x98,%edx
   102e9:	83 ec 04             	sub    $0x4,%esp
   102ec:	50                   	push   %eax
   102ed:	ff 75 d0             	pushl  -0x30(%ebp)
   102f0:	52                   	push   %edx
   102f1:	e8 07 f2 ff ff       	call   f4fd <readChunk_cHRM>
   102f6:	83 c4 10             	add    $0x10,%esp
   102f9:	89 c2                	mov    %eax,%edx
   102fb:	8b 45 14             	mov    0x14(%ebp),%eax
   102fe:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10304:	8b 45 14             	mov    0x14(%ebp),%eax
   10307:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1030d:	85 c0                	test   %eax,%eax
   1030f:	0f 84 45 01 00 00    	je     1045a <decodeGeneric+0x731>
   10315:	e9 b4 01 00 00       	jmp    104ce <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   1031a:	83 ec 08             	sub    $0x8,%esp
   1031d:	68 3a a6 01 00       	push   $0x1a63a
   10322:	ff 75 f0             	pushl  -0x10(%ebp)
   10325:	e8 49 85 ff ff       	call   8873 <lodepng_chunk_type_equals>
   1032a:	83 c4 10             	add    $0x10,%esp
   1032d:	84 c0                	test   %al,%al
   1032f:	74 3d                	je     1036e <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
   10331:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10334:	8b 55 14             	mov    0x14(%ebp),%edx
   10337:	81 c2 98 00 00 00    	add    $0x98,%edx
   1033d:	83 ec 04             	sub    $0x4,%esp
   10340:	50                   	push   %eax
   10341:	ff 75 d0             	pushl  -0x30(%ebp)
   10344:	52                   	push   %edx
   10345:	e8 47 f4 ff ff       	call   f791 <readChunk_sRGB>
   1034a:	83 c4 10             	add    $0x10,%esp
   1034d:	89 c2                	mov    %eax,%edx
   1034f:	8b 45 14             	mov    0x14(%ebp),%eax
   10352:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10358:	8b 45 14             	mov    0x14(%ebp),%eax
   1035b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10361:	85 c0                	test   %eax,%eax
   10363:	0f 84 f1 00 00 00    	je     1045a <decodeGeneric+0x731>
   10369:	e9 60 01 00 00       	jmp    104ce <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   1036e:	83 ec 08             	sub    $0x8,%esp
   10371:	68 3f a6 01 00       	push   $0x1a63f
   10376:	ff 75 f0             	pushl  -0x10(%ebp)
   10379:	e8 f5 84 ff ff       	call   8873 <lodepng_chunk_type_equals>
   1037e:	83 c4 10             	add    $0x10,%esp
   10381:	84 c0                	test   %al,%al
   10383:	74 3e                	je     103c3 <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   10385:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   10388:	8b 45 14             	mov    0x14(%ebp),%eax
   1038b:	8b 4d 14             	mov    0x14(%ebp),%ecx
   1038e:	81 c1 98 00 00 00    	add    $0x98,%ecx
   10394:	52                   	push   %edx
   10395:	ff 75 d0             	pushl  -0x30(%ebp)
   10398:	50                   	push   %eax
   10399:	51                   	push   %ecx
   1039a:	e8 28 f4 ff ff       	call   f7c7 <readChunk_iCCP>
   1039f:	83 c4 10             	add    $0x10,%esp
   103a2:	89 c2                	mov    %eax,%edx
   103a4:	8b 45 14             	mov    0x14(%ebp),%eax
   103a7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   103ad:	8b 45 14             	mov    0x14(%ebp),%eax
   103b0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   103b6:	85 c0                	test   %eax,%eax
   103b8:	0f 84 9c 00 00 00    	je     1045a <decodeGeneric+0x731>
   103be:	e9 0b 01 00 00       	jmp    104ce <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
   103c3:	8b 45 14             	mov    0x14(%ebp),%eax
   103c6:	8b 40 1c             	mov    0x1c(%eax),%eax
   103c9:	85 c0                	test   %eax,%eax
   103cb:	75 24                	jne    103f1 <decodeGeneric+0x6c8>
   103cd:	83 ec 0c             	sub    $0xc,%esp
   103d0:	ff 75 f0             	pushl  -0x10(%ebp)
   103d3:	e8 30 85 ff ff       	call   8908 <lodepng_chunk_ancillary>
   103d8:	83 c4 10             	add    $0x10,%esp
   103db:	84 c0                	test   %al,%al
   103dd:	75 12                	jne    103f1 <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
   103df:	8b 45 14             	mov    0x14(%ebp),%eax
   103e2:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
   103e9:	00 00 00 
   103ec:	e9 dd 00 00 00       	jmp    104ce <decodeGeneric+0x7a5>
      }

      unknown = 1;
   103f1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
   103f8:	8b 45 14             	mov    0x14(%ebp),%eax
   103fb:	8b 40 2c             	mov    0x2c(%eax),%eax
   103fe:	85 c0                	test   %eax,%eax
   10400:	74 58                	je     1045a <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
   10402:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10405:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
   10408:	83 c0 58             	add    $0x58,%eax
   1040b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10412:	8b 45 14             	mov    0x14(%ebp),%eax
   10415:	01 d0                	add    %edx,%eax
   10417:	8d 50 10             	lea    0x10(%eax),%edx
   1041a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1041d:	83 e8 01             	sub    $0x1,%eax
   10420:	83 c0 54             	add    $0x54,%eax
   10423:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   1042a:	8b 45 14             	mov    0x14(%ebp),%eax
   1042d:	01 c8                	add    %ecx,%eax
   1042f:	83 c0 14             	add    $0x14,%eax
   10432:	83 ec 04             	sub    $0x4,%esp
   10435:	ff 75 f0             	pushl  -0x10(%ebp)
   10438:	52                   	push   %edx
   10439:	50                   	push   %eax
   1043a:	e8 15 88 ff ff       	call   8c54 <lodepng_chunk_append>
   1043f:	83 c4 10             	add    $0x10,%esp
   10442:	89 c2                	mov    %eax,%edx
   10444:	8b 45 14             	mov    0x14(%ebp),%eax
   10447:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   1044d:	8b 45 14             	mov    0x14(%ebp),%eax
   10450:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10456:	85 c0                	test   %eax,%eax
   10458:	75 73                	jne    104cd <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
   1045a:	8b 45 14             	mov    0x14(%ebp),%eax
   1045d:	8b 40 18             	mov    0x18(%eax),%eax
   10460:	85 c0                	test   %eax,%eax
   10462:	75 27                	jne    1048b <decodeGeneric+0x762>
   10464:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10468:	75 21                	jne    1048b <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
   1046a:	83 ec 0c             	sub    $0xc,%esp
   1046d:	ff 75 f0             	pushl  -0x10(%ebp)
   10470:	e8 f4 84 ff ff       	call   8969 <lodepng_chunk_check_crc>
   10475:	83 c4 10             	add    $0x10,%esp
   10478:	85 c0                	test   %eax,%eax
   1047a:	74 0f                	je     1048b <decodeGeneric+0x762>
   1047c:	8b 45 14             	mov    0x14(%ebp),%eax
   1047f:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
   10486:	00 00 00 
   10489:	eb 43                	jmp    104ce <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
   1048b:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   1048f:	75 1a                	jne    104ab <decodeGeneric+0x782>
   10491:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10494:	8b 45 18             	mov    0x18(%ebp),%eax
   10497:	01 d0                	add    %edx,%eax
   10499:	83 ec 08             	sub    $0x8,%esp
   1049c:	50                   	push   %eax
   1049d:	ff 75 f0             	pushl  -0x10(%ebp)
   104a0:	e8 3f 86 ff ff       	call   8ae4 <lodepng_chunk_next_const>
   104a5:	83 c4 10             	add    $0x10,%esp
   104a8:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   104ab:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   104af:	75 1d                	jne    104ce <decodeGeneric+0x7a5>
   104b1:	8b 45 14             	mov    0x14(%ebp),%eax
   104b4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   104ba:	85 c0                	test   %eax,%eax
   104bc:	0f 84 68 f9 ff ff    	je     fe2a <decodeGeneric+0x101>
   104c2:	eb 0a                	jmp    104ce <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   104c4:	90                   	nop
   104c5:	eb 07                	jmp    104ce <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   104c7:	90                   	nop
   104c8:	eb 04                	jmp    104ce <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
   104ca:	90                   	nop
   104cb:	eb 01                	jmp    104ce <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   104cd:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
   104ce:	8b 45 14             	mov    0x14(%ebp),%eax
   104d1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   104d7:	85 c0                	test   %eax,%eax
   104d9:	75 28                	jne    10503 <decodeGeneric+0x7da>
   104db:	8b 45 14             	mov    0x14(%ebp),%eax
   104de:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   104e4:	83 f8 03             	cmp    $0x3,%eax
   104e7:	75 1a                	jne    10503 <decodeGeneric+0x7da>
   104e9:	8b 45 14             	mov    0x14(%ebp),%eax
   104ec:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   104f2:	85 c0                	test   %eax,%eax
   104f4:	75 0d                	jne    10503 <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   104f6:	8b 45 14             	mov    0x14(%ebp),%eax
   104f9:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   10500:	00 00 00 
  }

  if(!state->error) {
   10503:	8b 45 14             	mov    0x14(%ebp),%eax
   10506:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1050c:	85 c0                	test   %eax,%eax
   1050e:	0f 85 d2 01 00 00    	jne    106e6 <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   10514:	8b 45 14             	mov    0x14(%ebp),%eax
   10517:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   1051d:	85 c0                	test   %eax,%eax
   1051f:	75 3a                	jne    1055b <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   10521:	8b 45 14             	mov    0x14(%ebp),%eax
   10524:	05 a4 00 00 00       	add    $0xa4,%eax
   10529:	83 ec 0c             	sub    $0xc,%esp
   1052c:	50                   	push   %eax
   1052d:	e8 8e 8e ff ff       	call   93c0 <lodepng_get_bpp>
   10532:	83 c4 10             	add    $0x10,%esp
   10535:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   10538:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   1053b:	8b 45 10             	mov    0x10(%ebp),%eax
   1053e:	8b 10                	mov    (%eax),%edx
   10540:	8b 45 0c             	mov    0xc(%ebp),%eax
   10543:	8b 00                	mov    (%eax),%eax
   10545:	83 ec 04             	sub    $0x4,%esp
   10548:	51                   	push   %ecx
   10549:	52                   	push   %edx
   1054a:	50                   	push   %eax
   1054b:	e8 cf 8f ff ff       	call   951f <lodepng_get_raw_size_idat>
   10550:	83 c4 10             	add    $0x10,%esp
   10553:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10556:	e9 60 01 00 00       	jmp    106bb <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   1055b:	8b 45 14             	mov    0x14(%ebp),%eax
   1055e:	05 a4 00 00 00       	add    $0xa4,%eax
   10563:	83 ec 0c             	sub    $0xc,%esp
   10566:	50                   	push   %eax
   10567:	e8 54 8e ff ff       	call   93c0 <lodepng_get_bpp>
   1056c:	83 c4 10             	add    $0x10,%esp
   1056f:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   10572:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   10579:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1057c:	8b 55 10             	mov    0x10(%ebp),%edx
   1057f:	8b 12                	mov    (%edx),%edx
   10581:	83 c2 07             	add    $0x7,%edx
   10584:	89 d1                	mov    %edx,%ecx
   10586:	c1 e9 03             	shr    $0x3,%ecx
   10589:	8b 55 0c             	mov    0xc(%ebp),%edx
   1058c:	8b 12                	mov    (%edx),%edx
   1058e:	83 c2 07             	add    $0x7,%edx
   10591:	c1 ea 03             	shr    $0x3,%edx
   10594:	83 ec 04             	sub    $0x4,%esp
   10597:	50                   	push   %eax
   10598:	51                   	push   %ecx
   10599:	52                   	push   %edx
   1059a:	e8 80 8f ff ff       	call   951f <lodepng_get_raw_size_idat>
   1059f:	83 c4 10             	add    $0x10,%esp
   105a2:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   105a5:	8b 45 0c             	mov    0xc(%ebp),%eax
   105a8:	8b 00                	mov    (%eax),%eax
   105aa:	83 f8 04             	cmp    $0x4,%eax
   105ad:	76 2c                	jbe    105db <decodeGeneric+0x8b2>
   105af:	8b 45 c8             	mov    -0x38(%ebp),%eax
   105b2:	8b 55 10             	mov    0x10(%ebp),%edx
   105b5:	8b 12                	mov    (%edx),%edx
   105b7:	83 c2 07             	add    $0x7,%edx
   105ba:	89 d1                	mov    %edx,%ecx
   105bc:	c1 e9 03             	shr    $0x3,%ecx
   105bf:	8b 55 0c             	mov    0xc(%ebp),%edx
   105c2:	8b 12                	mov    (%edx),%edx
   105c4:	83 c2 03             	add    $0x3,%edx
   105c7:	c1 ea 03             	shr    $0x3,%edx
   105ca:	83 ec 04             	sub    $0x4,%esp
   105cd:	50                   	push   %eax
   105ce:	51                   	push   %ecx
   105cf:	52                   	push   %edx
   105d0:	e8 4a 8f ff ff       	call   951f <lodepng_get_raw_size_idat>
   105d5:	83 c4 10             	add    $0x10,%esp
   105d8:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   105db:	8b 45 c8             	mov    -0x38(%ebp),%eax
   105de:	8b 55 10             	mov    0x10(%ebp),%edx
   105e1:	8b 12                	mov    (%edx),%edx
   105e3:	83 c2 03             	add    $0x3,%edx
   105e6:	89 d1                	mov    %edx,%ecx
   105e8:	c1 e9 03             	shr    $0x3,%ecx
   105eb:	8b 55 0c             	mov    0xc(%ebp),%edx
   105ee:	8b 12                	mov    (%edx),%edx
   105f0:	83 c2 03             	add    $0x3,%edx
   105f3:	c1 ea 02             	shr    $0x2,%edx
   105f6:	83 ec 04             	sub    $0x4,%esp
   105f9:	50                   	push   %eax
   105fa:	51                   	push   %ecx
   105fb:	52                   	push   %edx
   105fc:	e8 1e 8f ff ff       	call   951f <lodepng_get_raw_size_idat>
   10601:	83 c4 10             	add    $0x10,%esp
   10604:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   10607:	8b 45 0c             	mov    0xc(%ebp),%eax
   1060a:	8b 00                	mov    (%eax),%eax
   1060c:	83 f8 02             	cmp    $0x2,%eax
   1060f:	76 2c                	jbe    1063d <decodeGeneric+0x914>
   10611:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10614:	8b 55 10             	mov    0x10(%ebp),%edx
   10617:	8b 12                	mov    (%edx),%edx
   10619:	83 c2 03             	add    $0x3,%edx
   1061c:	89 d1                	mov    %edx,%ecx
   1061e:	c1 e9 02             	shr    $0x2,%ecx
   10621:	8b 55 0c             	mov    0xc(%ebp),%edx
   10624:	8b 12                	mov    (%edx),%edx
   10626:	83 c2 01             	add    $0x1,%edx
   10629:	c1 ea 02             	shr    $0x2,%edx
   1062c:	83 ec 04             	sub    $0x4,%esp
   1062f:	50                   	push   %eax
   10630:	51                   	push   %ecx
   10631:	52                   	push   %edx
   10632:	e8 e8 8e ff ff       	call   951f <lodepng_get_raw_size_idat>
   10637:	83 c4 10             	add    $0x10,%esp
   1063a:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   1063d:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10640:	8b 55 10             	mov    0x10(%ebp),%edx
   10643:	8b 12                	mov    (%edx),%edx
   10645:	83 c2 01             	add    $0x1,%edx
   10648:	89 d1                	mov    %edx,%ecx
   1064a:	c1 e9 02             	shr    $0x2,%ecx
   1064d:	8b 55 0c             	mov    0xc(%ebp),%edx
   10650:	8b 12                	mov    (%edx),%edx
   10652:	83 c2 01             	add    $0x1,%edx
   10655:	d1 ea                	shr    %edx
   10657:	83 ec 04             	sub    $0x4,%esp
   1065a:	50                   	push   %eax
   1065b:	51                   	push   %ecx
   1065c:	52                   	push   %edx
   1065d:	e8 bd 8e ff ff       	call   951f <lodepng_get_raw_size_idat>
   10662:	83 c4 10             	add    $0x10,%esp
   10665:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   10668:	8b 45 0c             	mov    0xc(%ebp),%eax
   1066b:	8b 00                	mov    (%eax),%eax
   1066d:	83 f8 01             	cmp    $0x1,%eax
   10670:	76 27                	jbe    10699 <decodeGeneric+0x970>
   10672:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10675:	8b 55 10             	mov    0x10(%ebp),%edx
   10678:	8b 12                	mov    (%edx),%edx
   1067a:	83 c2 01             	add    $0x1,%edx
   1067d:	89 d1                	mov    %edx,%ecx
   1067f:	d1 e9                	shr    %ecx
   10681:	8b 55 0c             	mov    0xc(%ebp),%edx
   10684:	8b 12                	mov    (%edx),%edx
   10686:	d1 ea                	shr    %edx
   10688:	83 ec 04             	sub    $0x4,%esp
   1068b:	50                   	push   %eax
   1068c:	51                   	push   %ecx
   1068d:	52                   	push   %edx
   1068e:	e8 8c 8e ff ff       	call   951f <lodepng_get_raw_size_idat>
   10693:	83 c4 10             	add    $0x10,%esp
   10696:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   10699:	8b 55 c8             	mov    -0x38(%ebp),%edx
   1069c:	8b 45 10             	mov    0x10(%ebp),%eax
   1069f:	8b 00                	mov    (%eax),%eax
   106a1:	d1 e8                	shr    %eax
   106a3:	89 c1                	mov    %eax,%ecx
   106a5:	8b 45 0c             	mov    0xc(%ebp),%eax
   106a8:	8b 00                	mov    (%eax),%eax
   106aa:	83 ec 04             	sub    $0x4,%esp
   106ad:	52                   	push   %edx
   106ae:	51                   	push   %ecx
   106af:	50                   	push   %eax
   106b0:	e8 6a 8e ff ff       	call   951f <lodepng_get_raw_size_idat>
   106b5:	83 c4 10             	add    $0x10,%esp
   106b8:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   106bb:	8b 45 14             	mov    0x14(%ebp),%eax
   106be:	83 ec 08             	sub    $0x8,%esp
   106c1:	50                   	push   %eax
   106c2:	ff 75 ec             	pushl  -0x14(%ebp)
   106c5:	ff 75 d8             	pushl  -0x28(%ebp)
   106c8:	ff 75 e8             	pushl  -0x18(%ebp)
   106cb:	8d 45 c0             	lea    -0x40(%ebp),%eax
   106ce:	50                   	push   %eax
   106cf:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   106d2:	50                   	push   %eax
   106d3:	e8 87 7c ff ff       	call   835f <zlib_decompress>
   106d8:	83 c4 20             	add    $0x20,%esp
   106db:	89 c2                	mov    %eax,%edx
   106dd:	8b 45 14             	mov    0x14(%ebp),%eax
   106e0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   106e6:	8b 45 14             	mov    0x14(%ebp),%eax
   106e9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   106ef:	85 c0                	test   %eax,%eax
   106f1:	75 15                	jne    10708 <decodeGeneric+0x9df>
   106f3:	8b 45 c0             	mov    -0x40(%ebp),%eax
   106f6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   106f9:	74 0d                	je     10708 <decodeGeneric+0x9df>
   106fb:	8b 45 14             	mov    0x14(%ebp),%eax
   106fe:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   10705:	00 00 00 
  lodepng_free(idat);
   10708:	83 ec 0c             	sub    $0xc,%esp
   1070b:	ff 75 d8             	pushl  -0x28(%ebp)
   1070e:	e8 b2 31 ff ff       	call   38c5 <lodepng_free>
   10713:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   10716:	8b 45 14             	mov    0x14(%ebp),%eax
   10719:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1071f:	85 c0                	test   %eax,%eax
   10721:	75 4f                	jne    10772 <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   10723:	8b 45 14             	mov    0x14(%ebp),%eax
   10726:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   1072c:	8b 45 10             	mov    0x10(%ebp),%eax
   1072f:	8b 10                	mov    (%eax),%edx
   10731:	8b 45 0c             	mov    0xc(%ebp),%eax
   10734:	8b 00                	mov    (%eax),%eax
   10736:	83 ec 04             	sub    $0x4,%esp
   10739:	51                   	push   %ecx
   1073a:	52                   	push   %edx
   1073b:	50                   	push   %eax
   1073c:	e8 be 8d ff ff       	call   94ff <lodepng_get_raw_size>
   10741:	83 c4 10             	add    $0x10,%esp
   10744:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10747:	83 ec 0c             	sub    $0xc,%esp
   1074a:	ff 75 e4             	pushl  -0x1c(%ebp)
   1074d:	e8 52 31 ff ff       	call   38a4 <lodepng_malloc>
   10752:	83 c4 10             	add    $0x10,%esp
   10755:	89 c2                	mov    %eax,%edx
   10757:	8b 45 08             	mov    0x8(%ebp),%eax
   1075a:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   1075c:	8b 45 08             	mov    0x8(%ebp),%eax
   1075f:	8b 00                	mov    (%eax),%eax
   10761:	85 c0                	test   %eax,%eax
   10763:	75 0d                	jne    10772 <decodeGeneric+0xa49>
   10765:	8b 45 14             	mov    0x14(%ebp),%eax
   10768:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   1076f:	00 00 00 
  }
  if(!state->error) {
   10772:	8b 45 14             	mov    0x14(%ebp),%eax
   10775:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1077b:	85 c0                	test   %eax,%eax
   1077d:	75 4c                	jne    107cb <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   1077f:	8b 45 08             	mov    0x8(%ebp),%eax
   10782:	8b 00                	mov    (%eax),%eax
   10784:	83 ec 04             	sub    $0x4,%esp
   10787:	ff 75 e4             	pushl  -0x1c(%ebp)
   1078a:	6a 00                	push   $0x0
   1078c:	50                   	push   %eax
   1078d:	e8 83 31 ff ff       	call   3915 <lodepng_memset>
   10792:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   10795:	8b 45 14             	mov    0x14(%ebp),%eax
   10798:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   1079e:	8b 45 10             	mov    0x10(%ebp),%eax
   107a1:	8b 18                	mov    (%eax),%ebx
   107a3:	8b 45 0c             	mov    0xc(%ebp),%eax
   107a6:	8b 08                	mov    (%eax),%ecx
   107a8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   107ab:	8b 45 08             	mov    0x8(%ebp),%eax
   107ae:	8b 00                	mov    (%eax),%eax
   107b0:	83 ec 0c             	sub    $0xc,%esp
   107b3:	56                   	push   %esi
   107b4:	53                   	push   %ebx
   107b5:	51                   	push   %ecx
   107b6:	52                   	push   %edx
   107b7:	50                   	push   %eax
   107b8:	e8 05 df ff ff       	call   e6c2 <postProcessScanlines>
   107bd:	83 c4 20             	add    $0x20,%esp
   107c0:	89 c2                	mov    %eax,%edx
   107c2:	8b 45 14             	mov    0x14(%ebp),%eax
   107c5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   107cb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   107ce:	83 ec 0c             	sub    $0xc,%esp
   107d1:	50                   	push   %eax
   107d2:	e8 ee 30 ff ff       	call   38c5 <lodepng_free>
   107d7:	83 c4 10             	add    $0x10,%esp
   107da:	eb 01                	jmp    107dd <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   107dc:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   107dd:	8d 65 f8             	lea    -0x8(%ebp),%esp
   107e0:	5b                   	pop    %ebx
   107e1:	5e                   	pop    %esi
   107e2:	5d                   	pop    %ebp
   107e3:	c3                   	ret    

000107e4 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   107e4:	55                   	push   %ebp
   107e5:	89 e5                	mov    %esp,%ebp
   107e7:	56                   	push   %esi
   107e8:	53                   	push   %ebx
   107e9:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   107ec:	8b 45 08             	mov    0x8(%ebp),%eax
   107ef:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   107f5:	83 ec 08             	sub    $0x8,%esp
   107f8:	ff 75 1c             	pushl  0x1c(%ebp)
   107fb:	ff 75 18             	pushl  0x18(%ebp)
   107fe:	ff 75 14             	pushl  0x14(%ebp)
   10801:	ff 75 10             	pushl  0x10(%ebp)
   10804:	ff 75 0c             	pushl  0xc(%ebp)
   10807:	ff 75 08             	pushl  0x8(%ebp)
   1080a:	e8 1a f5 ff ff       	call   fd29 <decodeGeneric>
   1080f:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   10812:	8b 45 14             	mov    0x14(%ebp),%eax
   10815:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1081b:	85 c0                	test   %eax,%eax
   1081d:	74 0e                	je     1082d <lodepng_decode+0x49>
   1081f:	8b 45 14             	mov    0x14(%ebp),%eax
   10822:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10828:	e9 55 01 00 00       	jmp    10982 <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   1082d:	8b 45 14             	mov    0x14(%ebp),%eax
   10830:	8b 40 24             	mov    0x24(%eax),%eax
   10833:	85 c0                	test   %eax,%eax
   10835:	74 20                	je     10857 <lodepng_decode+0x73>
   10837:	8b 45 14             	mov    0x14(%ebp),%eax
   1083a:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   10840:	8b 45 14             	mov    0x14(%ebp),%eax
   10843:	83 c0 78             	add    $0x78,%eax
   10846:	83 ec 08             	sub    $0x8,%esp
   10849:	52                   	push   %edx
   1084a:	50                   	push   %eax
   1084b:	e8 56 89 ff ff       	call   91a6 <lodepng_color_mode_equal>
   10850:	83 c4 10             	add    $0x10,%esp
   10853:	85 c0                	test   %eax,%eax
   10855:	74 54                	je     108ab <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   10857:	8b 45 14             	mov    0x14(%ebp),%eax
   1085a:	8b 40 24             	mov    0x24(%eax),%eax
   1085d:	85 c0                	test   %eax,%eax
   1085f:	0f 85 13 01 00 00    	jne    10978 <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   10865:	8b 45 14             	mov    0x14(%ebp),%eax
   10868:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   1086e:	8b 45 14             	mov    0x14(%ebp),%eax
   10871:	83 c0 78             	add    $0x78,%eax
   10874:	83 ec 08             	sub    $0x8,%esp
   10877:	52                   	push   %edx
   10878:	50                   	push   %eax
   10879:	e8 3f 88 ff ff       	call   90bd <lodepng_color_mode_copy>
   1087e:	83 c4 10             	add    $0x10,%esp
   10881:	89 c2                	mov    %eax,%edx
   10883:	8b 45 14             	mov    0x14(%ebp),%eax
   10886:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   1088c:	8b 45 14             	mov    0x14(%ebp),%eax
   1088f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10895:	85 c0                	test   %eax,%eax
   10897:	0f 84 db 00 00 00    	je     10978 <lodepng_decode+0x194>
   1089d:	8b 45 14             	mov    0x14(%ebp),%eax
   108a0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   108a6:	e9 d7 00 00 00       	jmp    10982 <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   108ab:	8b 45 08             	mov    0x8(%ebp),%eax
   108ae:	8b 00                	mov    (%eax),%eax
   108b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   108b3:	8b 45 14             	mov    0x14(%ebp),%eax
   108b6:	8b 40 78             	mov    0x78(%eax),%eax
   108b9:	83 f8 02             	cmp    $0x2,%eax
   108bc:	74 20                	je     108de <lodepng_decode+0xfa>
   108be:	8b 45 14             	mov    0x14(%ebp),%eax
   108c1:	8b 40 78             	mov    0x78(%eax),%eax
   108c4:	83 f8 06             	cmp    $0x6,%eax
   108c7:	74 15                	je     108de <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   108c9:	8b 45 14             	mov    0x14(%ebp),%eax
   108cc:	8b 40 7c             	mov    0x7c(%eax),%eax
   108cf:	83 f8 08             	cmp    $0x8,%eax
   108d2:	74 0a                	je     108de <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   108d4:	b8 38 00 00 00       	mov    $0x38,%eax
   108d9:	e9 a4 00 00 00       	jmp    10982 <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   108de:	8b 45 14             	mov    0x14(%ebp),%eax
   108e1:	8d 48 78             	lea    0x78(%eax),%ecx
   108e4:	8b 45 10             	mov    0x10(%ebp),%eax
   108e7:	8b 10                	mov    (%eax),%edx
   108e9:	8b 45 0c             	mov    0xc(%ebp),%eax
   108ec:	8b 00                	mov    (%eax),%eax
   108ee:	83 ec 04             	sub    $0x4,%esp
   108f1:	51                   	push   %ecx
   108f2:	52                   	push   %edx
   108f3:	50                   	push   %eax
   108f4:	e8 06 8c ff ff       	call   94ff <lodepng_get_raw_size>
   108f9:	83 c4 10             	add    $0x10,%esp
   108fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   108ff:	83 ec 0c             	sub    $0xc,%esp
   10902:	ff 75 f0             	pushl  -0x10(%ebp)
   10905:	e8 9a 2f ff ff       	call   38a4 <lodepng_malloc>
   1090a:	83 c4 10             	add    $0x10,%esp
   1090d:	89 c2                	mov    %eax,%edx
   1090f:	8b 45 08             	mov    0x8(%ebp),%eax
   10912:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   10914:	8b 45 08             	mov    0x8(%ebp),%eax
   10917:	8b 00                	mov    (%eax),%eax
   10919:	85 c0                	test   %eax,%eax
   1091b:	75 0f                	jne    1092c <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   1091d:	8b 45 14             	mov    0x14(%ebp),%eax
   10920:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   10927:	00 00 00 
   1092a:	eb 3c                	jmp    10968 <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   1092c:	8b 45 10             	mov    0x10(%ebp),%eax
   1092f:	8b 08                	mov    (%eax),%ecx
   10931:	8b 45 0c             	mov    0xc(%ebp),%eax
   10934:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   10936:	8b 45 14             	mov    0x14(%ebp),%eax
   10939:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   1093f:	8b 45 14             	mov    0x14(%ebp),%eax
   10942:	8d 58 78             	lea    0x78(%eax),%ebx
   10945:	8b 45 08             	mov    0x8(%ebp),%eax
   10948:	8b 00                	mov    (%eax),%eax
   1094a:	83 ec 08             	sub    $0x8,%esp
   1094d:	51                   	push   %ecx
   1094e:	52                   	push   %edx
   1094f:	56                   	push   %esi
   10950:	53                   	push   %ebx
   10951:	ff 75 f4             	pushl  -0xc(%ebp)
   10954:	50                   	push   %eax
   10955:	e8 51 b6 ff ff       	call   bfab <lodepng_convert>
   1095a:	83 c4 20             	add    $0x20,%esp
   1095d:	89 c2                	mov    %eax,%edx
   1095f:	8b 45 14             	mov    0x14(%ebp),%eax
   10962:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   10968:	83 ec 0c             	sub    $0xc,%esp
   1096b:	ff 75 f4             	pushl  -0xc(%ebp)
   1096e:	e8 52 2f ff ff       	call   38c5 <lodepng_free>
   10973:	83 c4 10             	add    $0x10,%esp
   10976:	eb 01                	jmp    10979 <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   10978:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   10979:	8b 45 14             	mov    0x14(%ebp),%eax
   1097c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   10982:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10985:	5b                   	pop    %ebx
   10986:	5e                   	pop    %esi
   10987:	5d                   	pop    %ebp
   10988:	c3                   	ret    

00010989 <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   10989:	55                   	push   %ebp
   1098a:	89 e5                	mov    %esp,%ebp
   1098c:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   10992:	83 ec 0c             	sub    $0xc,%esp
   10995:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1099b:	50                   	push   %eax
   1099c:	e8 d9 01 00 00       	call   10b7a <lodepng_state_init>
   109a1:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   109a4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   109a7:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   109ad:	8b 45 20             	mov    0x20(%ebp),%eax
   109b0:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   109b6:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   109bd:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   109c0:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   109c7:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   109ca:	83 ec 08             	sub    $0x8,%esp
   109cd:	ff 75 18             	pushl  0x18(%ebp)
   109d0:	ff 75 14             	pushl  0x14(%ebp)
   109d3:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   109d9:	50                   	push   %eax
   109da:	ff 75 10             	pushl  0x10(%ebp)
   109dd:	ff 75 0c             	pushl  0xc(%ebp)
   109e0:	ff 75 08             	pushl  0x8(%ebp)
   109e3:	e8 fc fd ff ff       	call   107e4 <lodepng_decode>
   109e8:	83 c4 20             	add    $0x20,%esp
   109eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   109ee:	83 ec 0c             	sub    $0xc,%esp
   109f1:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   109f7:	50                   	push   %eax
   109f8:	e8 d7 01 00 00       	call   10bd4 <lodepng_state_cleanup>
   109fd:	83 c4 10             	add    $0x10,%esp
  return error;
   10a00:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10a03:	c9                   	leave  
   10a04:	c3                   	ret    

00010a05 <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10a05:	55                   	push   %ebp
   10a06:	89 e5                	mov    %esp,%ebp
   10a08:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   10a0b:	83 ec 04             	sub    $0x4,%esp
   10a0e:	6a 08                	push   $0x8
   10a10:	6a 06                	push   $0x6
   10a12:	ff 75 18             	pushl  0x18(%ebp)
   10a15:	ff 75 14             	pushl  0x14(%ebp)
   10a18:	ff 75 10             	pushl  0x10(%ebp)
   10a1b:	ff 75 0c             	pushl  0xc(%ebp)
   10a1e:	ff 75 08             	pushl  0x8(%ebp)
   10a21:	e8 63 ff ff ff       	call   10989 <lodepng_decode_memory>
   10a26:	83 c4 20             	add    $0x20,%esp
}
   10a29:	c9                   	leave  
   10a2a:	c3                   	ret    

00010a2b <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10a2b:	55                   	push   %ebp
   10a2c:	89 e5                	mov    %esp,%ebp
   10a2e:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   10a31:	83 ec 04             	sub    $0x4,%esp
   10a34:	6a 08                	push   $0x8
   10a36:	6a 02                	push   $0x2
   10a38:	ff 75 18             	pushl  0x18(%ebp)
   10a3b:	ff 75 14             	pushl  0x14(%ebp)
   10a3e:	ff 75 10             	pushl  0x10(%ebp)
   10a41:	ff 75 0c             	pushl  0xc(%ebp)
   10a44:	ff 75 08             	pushl  0x8(%ebp)
   10a47:	e8 3d ff ff ff       	call   10989 <lodepng_decode_memory>
   10a4c:	83 c4 20             	add    $0x20,%esp
}
   10a4f:	c9                   	leave  
   10a50:	c3                   	ret    

00010a51 <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   10a51:	55                   	push   %ebp
   10a52:	89 e5                	mov    %esp,%ebp
   10a54:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   10a57:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   10a5e:	8b 45 08             	mov    0x8(%ebp),%eax
   10a61:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   10a67:	8b 45 10             	mov    0x10(%ebp),%eax
   10a6a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   10a70:	8b 45 10             	mov    0x10(%ebp),%eax
   10a73:	8b 10                	mov    (%eax),%edx
   10a75:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a78:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   10a7a:	83 ec 04             	sub    $0x4,%esp
   10a7d:	ff 75 14             	pushl  0x14(%ebp)
   10a80:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10a83:	50                   	push   %eax
   10a84:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10a87:	50                   	push   %eax
   10a88:	e8 70 32 ff ff       	call   3cfd <lodepng_load_file>
   10a8d:	83 c4 10             	add    $0x10,%esp
   10a90:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   10a93:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10a97:	75 25                	jne    10abe <lodepng_decode_file+0x6d>
   10a99:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10a9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a9f:	83 ec 04             	sub    $0x4,%esp
   10aa2:	ff 75 1c             	pushl  0x1c(%ebp)
   10aa5:	ff 75 18             	pushl  0x18(%ebp)
   10aa8:	52                   	push   %edx
   10aa9:	50                   	push   %eax
   10aaa:	ff 75 10             	pushl  0x10(%ebp)
   10aad:	ff 75 0c             	pushl  0xc(%ebp)
   10ab0:	ff 75 08             	pushl  0x8(%ebp)
   10ab3:	e8 d1 fe ff ff       	call   10989 <lodepng_decode_memory>
   10ab8:	83 c4 20             	add    $0x20,%esp
   10abb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   10abe:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ac1:	83 ec 0c             	sub    $0xc,%esp
   10ac4:	50                   	push   %eax
   10ac5:	e8 fb 2d ff ff       	call   38c5 <lodepng_free>
   10aca:	83 c4 10             	add    $0x10,%esp
  return error;
   10acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10ad0:	c9                   	leave  
   10ad1:	c3                   	ret    

00010ad2 <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10ad2:	55                   	push   %ebp
   10ad3:	89 e5                	mov    %esp,%ebp
   10ad5:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   10ad8:	83 ec 08             	sub    $0x8,%esp
   10adb:	6a 08                	push   $0x8
   10add:	6a 06                	push   $0x6
   10adf:	ff 75 14             	pushl  0x14(%ebp)
   10ae2:	ff 75 10             	pushl  0x10(%ebp)
   10ae5:	ff 75 0c             	pushl  0xc(%ebp)
   10ae8:	ff 75 08             	pushl  0x8(%ebp)
   10aeb:	e8 61 ff ff ff       	call   10a51 <lodepng_decode_file>
   10af0:	83 c4 20             	add    $0x20,%esp
}
   10af3:	c9                   	leave  
   10af4:	c3                   	ret    

00010af5 <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10af5:	55                   	push   %ebp
   10af6:	89 e5                	mov    %esp,%ebp
   10af8:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   10afb:	83 ec 08             	sub    $0x8,%esp
   10afe:	6a 08                	push   $0x8
   10b00:	6a 02                	push   $0x2
   10b02:	ff 75 14             	pushl  0x14(%ebp)
   10b05:	ff 75 10             	pushl  0x10(%ebp)
   10b08:	ff 75 0c             	pushl  0xc(%ebp)
   10b0b:	ff 75 08             	pushl  0x8(%ebp)
   10b0e:	e8 3e ff ff ff       	call   10a51 <lodepng_decode_file>
   10b13:	83 c4 20             	add    $0x20,%esp
}
   10b16:	c9                   	leave  
   10b17:	c3                   	ret    

00010b18 <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   10b18:	55                   	push   %ebp
   10b19:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   10b1b:	8b 45 08             	mov    0x8(%ebp),%eax
   10b1e:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   10b25:	8b 45 08             	mov    0x8(%ebp),%eax
   10b28:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   10b2f:	8b 45 08             	mov    0x8(%ebp),%eax
   10b32:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   10b39:	8b 45 08             	mov    0x8(%ebp),%eax
   10b3c:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   10b43:	8b 45 08             	mov    0x8(%ebp),%eax
   10b46:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   10b4d:	8b 45 08             	mov    0x8(%ebp),%eax
   10b50:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   10b57:	8b 45 08             	mov    0x8(%ebp),%eax
   10b5a:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   10b61:	8b 45 08             	mov    0x8(%ebp),%eax
   10b64:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   10b6b:	8b 45 08             	mov    0x8(%ebp),%eax
   10b6e:	50                   	push   %eax
   10b6f:	e8 ff 7a ff ff       	call   8673 <lodepng_decompress_settings_init>
   10b74:	83 c4 04             	add    $0x4,%esp
}
   10b77:	90                   	nop
   10b78:	c9                   	leave  
   10b79:	c3                   	ret    

00010b7a <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   10b7a:	55                   	push   %ebp
   10b7b:	89 e5                	mov    %esp,%ebp
   10b7d:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   10b80:	8b 45 08             	mov    0x8(%ebp),%eax
   10b83:	50                   	push   %eax
   10b84:	e8 8f ff ff ff       	call   10b18 <lodepng_decoder_settings_init>
   10b89:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   10b8c:	8b 45 08             	mov    0x8(%ebp),%eax
   10b8f:	83 c0 38             	add    $0x38,%eax
   10b92:	83 ec 0c             	sub    $0xc,%esp
   10b95:	50                   	push   %eax
   10b96:	e8 fc 30 00 00       	call   13c97 <lodepng_encoder_settings_init>
   10b9b:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   10b9e:	8b 45 08             	mov    0x8(%ebp),%eax
   10ba1:	83 c0 78             	add    $0x78,%eax
   10ba4:	83 ec 0c             	sub    $0xc,%esp
   10ba7:	50                   	push   %eax
   10ba8:	e8 06 84 ff ff       	call   8fb3 <lodepng_color_mode_init>
   10bad:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   10bb0:	8b 45 08             	mov    0x8(%ebp),%eax
   10bb3:	05 98 00 00 00       	add    $0x98,%eax
   10bb8:	83 ec 0c             	sub    $0xc,%esp
   10bbb:	50                   	push   %eax
   10bbc:	e8 89 93 ff ff       	call   9f4a <lodepng_info_init>
   10bc1:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   10bc4:	8b 45 08             	mov    0x8(%ebp),%eax
   10bc7:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   10bce:	00 00 00 
}
   10bd1:	90                   	nop
   10bd2:	c9                   	leave  
   10bd3:	c3                   	ret    

00010bd4 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   10bd4:	55                   	push   %ebp
   10bd5:	89 e5                	mov    %esp,%ebp
   10bd7:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   10bda:	8b 45 08             	mov    0x8(%ebp),%eax
   10bdd:	83 c0 78             	add    $0x78,%eax
   10be0:	83 ec 0c             	sub    $0xc,%esp
   10be3:	50                   	push   %eax
   10be4:	e8 bd 84 ff ff       	call   90a6 <lodepng_color_mode_cleanup>
   10be9:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   10bec:	8b 45 08             	mov    0x8(%ebp),%eax
   10bef:	05 98 00 00 00       	add    $0x98,%eax
   10bf4:	83 ec 0c             	sub    $0xc,%esp
   10bf7:	50                   	push   %eax
   10bf8:	e8 2e 94 ff ff       	call   a02b <lodepng_info_cleanup>
   10bfd:	83 c4 10             	add    $0x10,%esp
}
   10c00:	90                   	nop
   10c01:	c9                   	leave  
   10c02:	c3                   	ret    

00010c03 <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   10c03:	55                   	push   %ebp
   10c04:	89 e5                	mov    %esp,%ebp
   10c06:	57                   	push   %edi
   10c07:	56                   	push   %esi
   10c08:	53                   	push   %ebx
   10c09:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   10c0c:	83 ec 0c             	sub    $0xc,%esp
   10c0f:	ff 75 08             	pushl  0x8(%ebp)
   10c12:	e8 bd ff ff ff       	call   10bd4 <lodepng_state_cleanup>
   10c17:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   10c1a:	8b 55 08             	mov    0x8(%ebp),%edx
   10c1d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c20:	89 c3                	mov    %eax,%ebx
   10c22:	b8 60 00 00 00       	mov    $0x60,%eax
   10c27:	89 d7                	mov    %edx,%edi
   10c29:	89 de                	mov    %ebx,%esi
   10c2b:	89 c1                	mov    %eax,%ecx
   10c2d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   10c2f:	8b 45 08             	mov    0x8(%ebp),%eax
   10c32:	83 c0 78             	add    $0x78,%eax
   10c35:	83 ec 0c             	sub    $0xc,%esp
   10c38:	50                   	push   %eax
   10c39:	e8 75 83 ff ff       	call   8fb3 <lodepng_color_mode_init>
   10c3e:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   10c41:	8b 45 08             	mov    0x8(%ebp),%eax
   10c44:	05 98 00 00 00       	add    $0x98,%eax
   10c49:	83 ec 0c             	sub    $0xc,%esp
   10c4c:	50                   	push   %eax
   10c4d:	e8 f8 92 ff ff       	call   9f4a <lodepng_info_init>
   10c52:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   10c55:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c58:	8d 50 78             	lea    0x78(%eax),%edx
   10c5b:	8b 45 08             	mov    0x8(%ebp),%eax
   10c5e:	83 c0 78             	add    $0x78,%eax
   10c61:	83 ec 08             	sub    $0x8,%esp
   10c64:	52                   	push   %edx
   10c65:	50                   	push   %eax
   10c66:	e8 52 84 ff ff       	call   90bd <lodepng_color_mode_copy>
   10c6b:	83 c4 10             	add    $0x10,%esp
   10c6e:	89 c2                	mov    %eax,%edx
   10c70:	8b 45 08             	mov    0x8(%ebp),%eax
   10c73:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10c79:	8b 45 08             	mov    0x8(%ebp),%eax
   10c7c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10c82:	85 c0                	test   %eax,%eax
   10c84:	75 36                	jne    10cbc <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   10c86:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c89:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   10c8f:	8b 45 08             	mov    0x8(%ebp),%eax
   10c92:	05 98 00 00 00       	add    $0x98,%eax
   10c97:	83 ec 08             	sub    $0x8,%esp
   10c9a:	52                   	push   %edx
   10c9b:	50                   	push   %eax
   10c9c:	e8 dd 93 ff ff       	call   a07e <lodepng_info_copy>
   10ca1:	83 c4 10             	add    $0x10,%esp
   10ca4:	89 c2                	mov    %eax,%edx
   10ca6:	8b 45 08             	mov    0x8(%ebp),%eax
   10ca9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10caf:	8b 45 08             	mov    0x8(%ebp),%eax
   10cb2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10cb8:	85 c0                	test   %eax,%eax
   10cba:	eb 01                	jmp    10cbd <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   10cbc:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   10cbd:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10cc0:	5b                   	pop    %ebx
   10cc1:	5e                   	pop    %esi
   10cc2:	5f                   	pop    %edi
   10cc3:	5d                   	pop    %ebp
   10cc4:	c3                   	ret    

00010cc5 <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   10cc5:	55                   	push   %ebp
   10cc6:	89 e5                	mov    %esp,%ebp
   10cc8:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   10ccb:	8b 45 08             	mov    0x8(%ebp),%eax
   10cce:	8b 40 04             	mov    0x4(%eax),%eax
   10cd1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   10cd4:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   10cd8:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   10cdc:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   10ce0:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   10ce4:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   10ce8:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   10cec:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   10cf0:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   10cf4:	8b 45 08             	mov    0x8(%ebp),%eax
   10cf7:	8b 40 04             	mov    0x4(%eax),%eax
   10cfa:	83 c0 08             	add    $0x8,%eax
   10cfd:	50                   	push   %eax
   10cfe:	ff 75 08             	pushl  0x8(%ebp)
   10d01:	e8 f8 2d ff ff       	call   3afe <ucvector_resize>
   10d06:	83 c4 08             	add    $0x8,%esp
   10d09:	85 c0                	test   %eax,%eax
   10d0b:	75 07                	jne    10d14 <writeSignature+0x4f>
   10d0d:	b8 53 00 00 00       	mov    $0x53,%eax
   10d12:	eb 1e                	jmp    10d32 <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   10d14:	8b 45 08             	mov    0x8(%ebp),%eax
   10d17:	8b 10                	mov    (%eax),%edx
   10d19:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10d1c:	01 c2                	add    %eax,%edx
   10d1e:	6a 08                	push   $0x8
   10d20:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10d23:	50                   	push   %eax
   10d24:	52                   	push   %edx
   10d25:	e8 b8 2b ff ff       	call   38e2 <lodepng_memcpy>
   10d2a:	83 c4 0c             	add    $0xc,%esp
  return 0;
   10d2d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10d32:	c9                   	leave  
   10d33:	c3                   	ret    

00010d34 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   10d34:	55                   	push   %ebp
   10d35:	89 e5                	mov    %esp,%ebp
   10d37:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   10d3a:	68 ec a5 01 00       	push   $0x1a5ec
   10d3f:	6a 0d                	push   $0xd
   10d41:	ff 75 08             	pushl  0x8(%ebp)
   10d44:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10d47:	50                   	push   %eax
   10d48:	e8 cf 7f ff ff       	call   8d1c <lodepng_chunk_init>
   10d4d:	83 c4 10             	add    $0x10,%esp
   10d50:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10d53:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10d57:	74 05                	je     10d5e <addChunk_IHDR+0x2a>
   10d59:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10d5c:	eb 6d                	jmp    10dcb <addChunk_IHDR+0x97>
  data = chunk + 8;
   10d5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d61:	83 c0 08             	add    $0x8,%eax
   10d64:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   10d67:	ff 75 0c             	pushl  0xc(%ebp)
   10d6a:	ff 75 f8             	pushl  -0x8(%ebp)
   10d6d:	e8 f3 2e ff ff       	call   3c65 <lodepng_set32bitInt>
   10d72:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   10d75:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10d78:	83 c0 04             	add    $0x4,%eax
   10d7b:	ff 75 10             	pushl  0x10(%ebp)
   10d7e:	50                   	push   %eax
   10d7f:	e8 e1 2e ff ff       	call   3c65 <lodepng_set32bitInt>
   10d84:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   10d87:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10d8a:	83 c0 08             	add    $0x8,%eax
   10d8d:	8b 55 18             	mov    0x18(%ebp),%edx
   10d90:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   10d92:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10d95:	83 c0 09             	add    $0x9,%eax
   10d98:	8b 55 14             	mov    0x14(%ebp),%edx
   10d9b:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   10d9d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10da0:	83 c0 0a             	add    $0xa,%eax
   10da3:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   10da6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10da9:	83 c0 0b             	add    $0xb,%eax
   10dac:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   10daf:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10db2:	83 c0 0c             	add    $0xc,%eax
   10db5:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10db8:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   10dba:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10dbd:	50                   	push   %eax
   10dbe:	e8 02 7c ff ff       	call   89c5 <lodepng_chunk_generate_crc>
   10dc3:	83 c4 04             	add    $0x4,%esp
  return 0;
   10dc6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10dcb:	c9                   	leave  
   10dcc:	c3                   	ret    

00010dcd <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   10dcd:	55                   	push   %ebp
   10dce:	89 e5                	mov    %esp,%ebp
   10dd0:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   10dd3:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   10dda:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ddd:	8b 50 0c             	mov    0xc(%eax),%edx
   10de0:	89 d0                	mov    %edx,%eax
   10de2:	01 c0                	add    %eax,%eax
   10de4:	01 d0                	add    %edx,%eax
   10de6:	68 08 a6 01 00       	push   $0x1a608
   10deb:	50                   	push   %eax
   10dec:	ff 75 08             	pushl  0x8(%ebp)
   10def:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10df2:	50                   	push   %eax
   10df3:	e8 24 7f ff ff       	call   8d1c <lodepng_chunk_init>
   10df8:	83 c4 10             	add    $0x10,%esp
   10dfb:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10dfe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e02:	74 08                	je     10e0c <addChunk_PLTE+0x3f>
   10e04:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e07:	e9 95 00 00 00       	jmp    10ea1 <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   10e0c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10e13:	eb 70                	jmp    10e85 <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   10e15:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10e18:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10e1b:	8d 50 01             	lea    0x1(%eax),%edx
   10e1e:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10e21:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10e24:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e27:	8b 40 08             	mov    0x8(%eax),%eax
   10e2a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10e2d:	c1 e1 02             	shl    $0x2,%ecx
   10e30:	01 c8                	add    %ecx,%eax
   10e32:	0f b6 00             	movzbl (%eax),%eax
   10e35:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   10e37:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10e3a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10e3d:	8d 50 01             	lea    0x1(%eax),%edx
   10e40:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10e43:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10e46:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e49:	8b 40 08             	mov    0x8(%eax),%eax
   10e4c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10e4f:	c1 e1 02             	shl    $0x2,%ecx
   10e52:	83 c1 01             	add    $0x1,%ecx
   10e55:	01 c8                	add    %ecx,%eax
   10e57:	0f b6 00             	movzbl (%eax),%eax
   10e5a:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   10e5c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10e5f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10e62:	8d 50 01             	lea    0x1(%eax),%edx
   10e65:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10e68:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10e6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e6e:	8b 40 08             	mov    0x8(%eax),%eax
   10e71:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10e74:	c1 e1 02             	shl    $0x2,%ecx
   10e77:	83 c1 02             	add    $0x2,%ecx
   10e7a:	01 c8                	add    %ecx,%eax
   10e7c:	0f b6 00             	movzbl (%eax),%eax
   10e7f:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   10e81:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10e85:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e88:	8b 40 0c             	mov    0xc(%eax),%eax
   10e8b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   10e8e:	75 85                	jne    10e15 <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   10e90:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10e93:	50                   	push   %eax
   10e94:	e8 2c 7b ff ff       	call   89c5 <lodepng_chunk_generate_crc>
   10e99:	83 c4 04             	add    $0x4,%esp
  return 0;
   10e9c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10ea1:	c9                   	leave  
   10ea2:	c3                   	ret    

00010ea3 <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   10ea3:	55                   	push   %ebp
   10ea4:	89 e5                	mov    %esp,%ebp
   10ea6:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10ea9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   10eb0:	8b 45 0c             	mov    0xc(%ebp),%eax
   10eb3:	8b 00                	mov    (%eax),%eax
   10eb5:	83 f8 03             	cmp    $0x3,%eax
   10eb8:	0f 85 ae 00 00 00    	jne    10f6c <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   10ebe:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ec1:	8b 40 0c             	mov    0xc(%eax),%eax
   10ec4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10ec7:	8b 45 0c             	mov    0xc(%ebp),%eax
   10eca:	8b 40 0c             	mov    0xc(%eax),%eax
   10ecd:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10ed0:	eb 23                	jmp    10ef5 <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10ed2:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ed5:	8b 40 08             	mov    0x8(%eax),%eax
   10ed8:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10edb:	83 ea 01             	sub    $0x1,%edx
   10ede:	c1 e2 02             	shl    $0x2,%edx
   10ee1:	83 c2 03             	add    $0x3,%edx
   10ee4:	01 d0                	add    %edx,%eax
   10ee6:	0f b6 00             	movzbl (%eax),%eax
   10ee9:	3c ff                	cmp    $0xff,%al
   10eeb:	75 10                	jne    10efd <addChunk_tRNS+0x5a>
      --amount;
   10eed:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10ef1:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   10ef5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10ef9:	75 d7                	jne    10ed2 <addChunk_tRNS+0x2f>
   10efb:	eb 01                	jmp    10efe <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10efd:	90                   	nop
      --amount;
    }
    if(amount) {
   10efe:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10f02:	0f 84 63 01 00 00    	je     1106b <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   10f08:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10f0b:	68 0d a6 01 00       	push   $0x1a60d
   10f10:	50                   	push   %eax
   10f11:	ff 75 08             	pushl  0x8(%ebp)
   10f14:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10f17:	50                   	push   %eax
   10f18:	e8 ff 7d ff ff       	call   8d1c <lodepng_chunk_init>
   10f1d:	83 c4 10             	add    $0x10,%esp
   10f20:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10f23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10f27:	74 08                	je     10f31 <addChunk_tRNS+0x8e>
   10f29:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10f2c:	e9 52 01 00 00       	jmp    11083 <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   10f31:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10f38:	eb 25                	jmp    10f5f <addChunk_tRNS+0xbc>
   10f3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10f3d:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10f40:	83 c2 08             	add    $0x8,%edx
   10f43:	01 c2                	add    %eax,%edx
   10f45:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f48:	8b 40 08             	mov    0x8(%eax),%eax
   10f4b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10f4e:	c1 e1 02             	shl    $0x2,%ecx
   10f51:	83 c1 03             	add    $0x3,%ecx
   10f54:	01 c8                	add    %ecx,%eax
   10f56:	0f b6 00             	movzbl (%eax),%eax
   10f59:	88 02                	mov    %al,(%edx)
   10f5b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10f5f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10f62:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   10f65:	75 d3                	jne    10f3a <addChunk_tRNS+0x97>
   10f67:	e9 ff 00 00 00       	jmp    1106b <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   10f6c:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f6f:	8b 00                	mov    (%eax),%eax
   10f71:	85 c0                	test   %eax,%eax
   10f73:	75 59                	jne    10fce <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   10f75:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f78:	8b 40 10             	mov    0x10(%eax),%eax
   10f7b:	85 c0                	test   %eax,%eax
   10f7d:	0f 84 e8 00 00 00    	je     1106b <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   10f83:	68 0d a6 01 00       	push   $0x1a60d
   10f88:	6a 02                	push   $0x2
   10f8a:	ff 75 08             	pushl  0x8(%ebp)
   10f8d:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10f90:	50                   	push   %eax
   10f91:	e8 86 7d ff ff       	call   8d1c <lodepng_chunk_init>
   10f96:	83 c4 10             	add    $0x10,%esp
   10f99:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10f9c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10fa0:	74 08                	je     10faa <addChunk_tRNS+0x107>
   10fa2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10fa5:	e9 d9 00 00 00       	jmp    11083 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10faa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10fad:	8d 50 08             	lea    0x8(%eax),%edx
   10fb0:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fb3:	8b 40 14             	mov    0x14(%eax),%eax
   10fb6:	c1 e8 08             	shr    $0x8,%eax
   10fb9:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10fbb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10fbe:	8d 50 09             	lea    0x9(%eax),%edx
   10fc1:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fc4:	8b 40 14             	mov    0x14(%eax),%eax
   10fc7:	88 02                	mov    %al,(%edx)
   10fc9:	e9 9d 00 00 00       	jmp    1106b <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   10fce:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fd1:	8b 00                	mov    (%eax),%eax
   10fd3:	83 f8 02             	cmp    $0x2,%eax
   10fd6:	0f 85 8f 00 00 00    	jne    1106b <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   10fdc:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fdf:	8b 40 10             	mov    0x10(%eax),%eax
   10fe2:	85 c0                	test   %eax,%eax
   10fe4:	0f 84 81 00 00 00    	je     1106b <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   10fea:	68 0d a6 01 00       	push   $0x1a60d
   10fef:	6a 06                	push   $0x6
   10ff1:	ff 75 08             	pushl  0x8(%ebp)
   10ff4:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10ff7:	50                   	push   %eax
   10ff8:	e8 1f 7d ff ff       	call   8d1c <lodepng_chunk_init>
   10ffd:	83 c4 10             	add    $0x10,%esp
   11000:	89 45 ec             	mov    %eax,-0x14(%ebp)
   11003:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11007:	74 05                	je     1100e <addChunk_tRNS+0x16b>
   11009:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1100c:	eb 75                	jmp    11083 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   1100e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11011:	8d 50 08             	lea    0x8(%eax),%edx
   11014:	8b 45 0c             	mov    0xc(%ebp),%eax
   11017:	8b 40 14             	mov    0x14(%eax),%eax
   1101a:	c1 e8 08             	shr    $0x8,%eax
   1101d:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   1101f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11022:	8d 50 09             	lea    0x9(%eax),%edx
   11025:	8b 45 0c             	mov    0xc(%ebp),%eax
   11028:	8b 40 14             	mov    0x14(%eax),%eax
   1102b:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   1102d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11030:	8d 50 0a             	lea    0xa(%eax),%edx
   11033:	8b 45 0c             	mov    0xc(%ebp),%eax
   11036:	8b 40 18             	mov    0x18(%eax),%eax
   11039:	c1 e8 08             	shr    $0x8,%eax
   1103c:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   1103e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11041:	8d 50 0b             	lea    0xb(%eax),%edx
   11044:	8b 45 0c             	mov    0xc(%ebp),%eax
   11047:	8b 40 18             	mov    0x18(%eax),%eax
   1104a:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   1104c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1104f:	8d 50 0c             	lea    0xc(%eax),%edx
   11052:	8b 45 0c             	mov    0xc(%ebp),%eax
   11055:	8b 40 1c             	mov    0x1c(%eax),%eax
   11058:	c1 e8 08             	shr    $0x8,%eax
   1105b:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   1105d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11060:	8d 50 0d             	lea    0xd(%eax),%edx
   11063:	8b 45 0c             	mov    0xc(%ebp),%eax
   11066:	8b 40 1c             	mov    0x1c(%eax),%eax
   11069:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   1106b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1106e:	85 c0                	test   %eax,%eax
   11070:	74 0c                	je     1107e <addChunk_tRNS+0x1db>
   11072:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11075:	50                   	push   %eax
   11076:	e8 4a 79 ff ff       	call   89c5 <lodepng_chunk_generate_crc>
   1107b:	83 c4 04             	add    $0x4,%esp
  return 0;
   1107e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11083:	c9                   	leave  
   11084:	c3                   	ret    

00011085 <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   11085:	55                   	push   %ebp
   11086:	89 e5                	mov    %esp,%ebp
   11088:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   1108b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   11092:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   11099:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   110a0:	83 ec 0c             	sub    $0xc,%esp
   110a3:	ff 75 14             	pushl  0x14(%ebp)
   110a6:	ff 75 10             	pushl  0x10(%ebp)
   110a9:	ff 75 0c             	pushl  0xc(%ebp)
   110ac:	8d 45 ec             	lea    -0x14(%ebp),%eax
   110af:	50                   	push   %eax
   110b0:	8d 45 f0             	lea    -0x10(%ebp),%eax
   110b3:	50                   	push   %eax
   110b4:	e8 fb 74 ff ff       	call   85b4 <zlib_compress>
   110b9:	83 c4 20             	add    $0x20,%esp
   110bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   110bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   110c3:	75 1b                	jne    110e0 <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   110c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110c8:	8b 55 ec             	mov    -0x14(%ebp),%edx
   110cb:	50                   	push   %eax
   110cc:	68 44 a6 01 00       	push   $0x1a644
   110d1:	52                   	push   %edx
   110d2:	ff 75 08             	pushl  0x8(%ebp)
   110d5:	e8 ea 7c ff ff       	call   8dc4 <lodepng_chunk_createv>
   110da:	83 c4 10             	add    $0x10,%esp
   110dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   110e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110e3:	83 ec 0c             	sub    $0xc,%esp
   110e6:	50                   	push   %eax
   110e7:	e8 d9 27 ff ff       	call   38c5 <lodepng_free>
   110ec:	83 c4 10             	add    $0x10,%esp
  return error;
   110ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   110f2:	c9                   	leave  
   110f3:	c3                   	ret    

000110f4 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   110f4:	55                   	push   %ebp
   110f5:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   110f7:	6a 00                	push   $0x0
   110f9:	68 49 a6 01 00       	push   $0x1a649
   110fe:	6a 00                	push   $0x0
   11100:	ff 75 08             	pushl  0x8(%ebp)
   11103:	e8 bc 7c ff ff       	call   8dc4 <lodepng_chunk_createv>
   11108:	83 c4 10             	add    $0x10,%esp
}
   1110b:	c9                   	leave  
   1110c:	c3                   	ret    

0001110d <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   1110d:	55                   	push   %ebp
   1110e:	89 e5                	mov    %esp,%ebp
   11110:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   11113:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   1111a:	ff 75 0c             	pushl  0xc(%ebp)
   1111d:	e8 1e 28 ff ff       	call   3940 <lodepng_strlen>
   11122:	83 c4 04             	add    $0x4,%esp
   11125:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11128:	ff 75 10             	pushl  0x10(%ebp)
   1112b:	e8 10 28 ff ff       	call   3940 <lodepng_strlen>
   11130:	83 c4 04             	add    $0x4,%esp
   11133:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   11136:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11139:	8d 50 01             	lea    0x1(%eax),%edx
   1113c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1113f:	01 d0                	add    %edx,%eax
   11141:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11144:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11148:	7e 06                	jle    11150 <addChunk_tEXt+0x43>
   1114a:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   1114e:	7e 07                	jle    11157 <addChunk_tEXt+0x4a>
   11150:	b8 59 00 00 00       	mov    $0x59,%eax
   11155:	eb 74                	jmp    111cb <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   11157:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1115a:	68 17 a6 01 00       	push   $0x1a617
   1115f:	50                   	push   %eax
   11160:	ff 75 08             	pushl  0x8(%ebp)
   11163:	8d 45 ec             	lea    -0x14(%ebp),%eax
   11166:	50                   	push   %eax
   11167:	e8 b0 7b ff ff       	call   8d1c <lodepng_chunk_init>
   1116c:	83 c4 10             	add    $0x10,%esp
   1116f:	89 45 f0             	mov    %eax,-0x10(%ebp)
   11172:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11176:	74 05                	je     1117d <addChunk_tEXt+0x70>
   11178:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1117b:	eb 4e                	jmp    111cb <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   1117d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11180:	83 c0 08             	add    $0x8,%eax
   11183:	ff 75 fc             	pushl  -0x4(%ebp)
   11186:	ff 75 0c             	pushl  0xc(%ebp)
   11189:	50                   	push   %eax
   1118a:	e8 53 27 ff ff       	call   38e2 <lodepng_memcpy>
   1118f:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   11192:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11195:	8b 55 fc             	mov    -0x4(%ebp),%edx
   11198:	83 c2 08             	add    $0x8,%edx
   1119b:	01 d0                	add    %edx,%eax
   1119d:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   111a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   111a3:	8b 55 fc             	mov    -0x4(%ebp),%edx
   111a6:	83 c2 09             	add    $0x9,%edx
   111a9:	01 d0                	add    %edx,%eax
   111ab:	ff 75 f8             	pushl  -0x8(%ebp)
   111ae:	ff 75 10             	pushl  0x10(%ebp)
   111b1:	50                   	push   %eax
   111b2:	e8 2b 27 ff ff       	call   38e2 <lodepng_memcpy>
   111b7:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   111ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
   111bd:	50                   	push   %eax
   111be:	e8 02 78 ff ff       	call   89c5 <lodepng_chunk_generate_crc>
   111c3:	83 c4 04             	add    $0x4,%esp
  return 0;
   111c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   111cb:	c9                   	leave  
   111cc:	c3                   	ret    

000111cd <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   111cd:	55                   	push   %ebp
   111ce:	89 e5                	mov    %esp,%ebp
   111d0:	53                   	push   %ebx
   111d1:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   111d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   111db:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   111e2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   111e9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   111f0:	ff 75 10             	pushl  0x10(%ebp)
   111f3:	e8 48 27 ff ff       	call   3940 <lodepng_strlen>
   111f8:	83 c4 04             	add    $0x4,%esp
   111fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   111fe:	ff 75 0c             	pushl  0xc(%ebp)
   11201:	e8 3a 27 ff ff       	call   3940 <lodepng_strlen>
   11206:	83 c4 04             	add    $0x4,%esp
   11209:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   1120c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11210:	7e 06                	jle    11218 <addChunk_zTXt+0x4b>
   11212:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   11216:	7e 0a                	jle    11222 <addChunk_zTXt+0x55>
   11218:	b8 59 00 00 00       	mov    $0x59,%eax
   1121d:	e9 c8 00 00 00       	jmp    112ea <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   11222:	83 ec 0c             	sub    $0xc,%esp
   11225:	ff 75 14             	pushl  0x14(%ebp)
   11228:	ff 75 f0             	pushl  -0x10(%ebp)
   1122b:	ff 75 10             	pushl  0x10(%ebp)
   1122e:	8d 45 dc             	lea    -0x24(%ebp),%eax
   11231:	50                   	push   %eax
   11232:	8d 45 e0             	lea    -0x20(%ebp),%eax
   11235:	50                   	push   %eax
   11236:	e8 79 73 ff ff       	call   85b4 <zlib_compress>
   1123b:	83 c4 20             	add    $0x20,%esp
   1123e:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   11241:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11245:	75 29                	jne    11270 <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   11247:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1124a:	8d 50 02             	lea    0x2(%eax),%edx
   1124d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11250:	01 d0                	add    %edx,%eax
   11252:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   11255:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11258:	68 1c a6 01 00       	push   $0x1a61c
   1125d:	50                   	push   %eax
   1125e:	ff 75 08             	pushl  0x8(%ebp)
   11261:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   11264:	50                   	push   %eax
   11265:	e8 b2 7a ff ff       	call   8d1c <lodepng_chunk_init>
   1126a:	83 c4 10             	add    $0x10,%esp
   1126d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11270:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11274:	75 62                	jne    112d8 <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   11276:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11279:	83 c0 08             	add    $0x8,%eax
   1127c:	83 ec 04             	sub    $0x4,%esp
   1127f:	ff 75 ec             	pushl  -0x14(%ebp)
   11282:	ff 75 0c             	pushl  0xc(%ebp)
   11285:	50                   	push   %eax
   11286:	e8 57 26 ff ff       	call   38e2 <lodepng_memcpy>
   1128b:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   1128e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11291:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11294:	83 c2 08             	add    $0x8,%edx
   11297:	01 d0                	add    %edx,%eax
   11299:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   1129c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1129f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   112a2:	83 c2 09             	add    $0x9,%edx
   112a5:	01 d0                	add    %edx,%eax
   112a7:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   112aa:	8b 55 dc             	mov    -0x24(%ebp),%edx
   112ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
   112b0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   112b3:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   112b6:	83 c3 0a             	add    $0xa,%ebx
   112b9:	01 d9                	add    %ebx,%ecx
   112bb:	83 ec 04             	sub    $0x4,%esp
   112be:	52                   	push   %edx
   112bf:	50                   	push   %eax
   112c0:	51                   	push   %ecx
   112c1:	e8 1c 26 ff ff       	call   38e2 <lodepng_memcpy>
   112c6:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   112c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   112cc:	83 ec 0c             	sub    $0xc,%esp
   112cf:	50                   	push   %eax
   112d0:	e8 f0 76 ff ff       	call   89c5 <lodepng_chunk_generate_crc>
   112d5:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   112d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   112db:	83 ec 0c             	sub    $0xc,%esp
   112de:	50                   	push   %eax
   112df:	e8 e1 25 ff ff       	call   38c5 <lodepng_free>
   112e4:	83 c4 10             	add    $0x10,%esp
  return error;
   112e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   112ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   112ed:	c9                   	leave  
   112ee:	c3                   	ret    

000112ef <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   112ef:	55                   	push   %ebp
   112f0:	89 e5                	mov    %esp,%ebp
   112f2:	53                   	push   %ebx
   112f3:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   112f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   112fd:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   11304:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   1130b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   11312:	ff 75 1c             	pushl  0x1c(%ebp)
   11315:	e8 26 26 ff ff       	call   3940 <lodepng_strlen>
   1131a:	83 c4 04             	add    $0x4,%esp
   1131d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   11320:	ff 75 10             	pushl  0x10(%ebp)
   11323:	e8 18 26 ff ff       	call   3940 <lodepng_strlen>
   11328:	83 c4 04             	add    $0x4,%esp
   1132b:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1132e:	ff 75 14             	pushl  0x14(%ebp)
   11331:	e8 0a 26 ff ff       	call   3940 <lodepng_strlen>
   11336:	83 c4 04             	add    $0x4,%esp
   11339:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1133c:	ff 75 18             	pushl  0x18(%ebp)
   1133f:	e8 fc 25 ff ff       	call   3940 <lodepng_strlen>
   11344:	83 c4 04             	add    $0x4,%esp
   11347:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   1134a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1134e:	7e 06                	jle    11356 <addChunk_iTXt+0x67>
   11350:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   11354:	7e 0a                	jle    11360 <addChunk_iTXt+0x71>
   11356:	b8 59 00 00 00       	mov    $0x59,%eax
   1135b:	e9 9a 01 00 00       	jmp    114fa <addChunk_iTXt+0x20b>

  if(compress) {
   11360:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11364:	74 1f                	je     11385 <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   11366:	83 ec 0c             	sub    $0xc,%esp
   11369:	ff 75 20             	pushl  0x20(%ebp)
   1136c:	ff 75 f0             	pushl  -0x10(%ebp)
   1136f:	ff 75 1c             	pushl  0x1c(%ebp)
   11372:	8d 45 d0             	lea    -0x30(%ebp),%eax
   11375:	50                   	push   %eax
   11376:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   11379:	50                   	push   %eax
   1137a:	e8 35 72 ff ff       	call   85b4 <zlib_compress>
   1137f:	83 c4 20             	add    $0x20,%esp
   11382:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   11385:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11389:	75 44                	jne    113cf <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   1138b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1138e:	8d 50 03             	lea    0x3(%eax),%edx
   11391:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11394:	01 d0                	add    %edx,%eax
   11396:	8d 50 01             	lea    0x1(%eax),%edx
   11399:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1139c:	01 d0                	add    %edx,%eax
   1139e:	8d 50 01             	lea    0x1(%eax),%edx
   113a1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   113a5:	74 05                	je     113ac <addChunk_iTXt+0xbd>
   113a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
   113aa:	eb 03                	jmp    113af <addChunk_iTXt+0xc0>
   113ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   113af:	01 d0                	add    %edx,%eax
   113b1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   113b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   113b7:	68 21 a6 01 00       	push   $0x1a621
   113bc:	50                   	push   %eax
   113bd:	ff 75 08             	pushl  0x8(%ebp)
   113c0:	8d 45 d8             	lea    -0x28(%ebp),%eax
   113c3:	50                   	push   %eax
   113c4:	e8 53 79 ff ff       	call   8d1c <lodepng_chunk_init>
   113c9:	83 c4 10             	add    $0x10,%esp
   113cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   113cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   113d3:	0f 85 0f 01 00 00    	jne    114e8 <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   113d9:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   113e0:	8b 55 d8             	mov    -0x28(%ebp),%edx
   113e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   113e6:	01 d0                	add    %edx,%eax
   113e8:	83 ec 04             	sub    $0x4,%esp
   113eb:	ff 75 ec             	pushl  -0x14(%ebp)
   113ee:	ff 75 10             	pushl  0x10(%ebp)
   113f1:	50                   	push   %eax
   113f2:	e8 eb 24 ff ff       	call   38e2 <lodepng_memcpy>
   113f7:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   113fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
   113fd:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11400:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11403:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11406:	8d 50 01             	lea    0x1(%eax),%edx
   11409:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1140c:	01 c8                	add    %ecx,%eax
   1140e:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   11411:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11414:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11417:	8d 50 01             	lea    0x1(%eax),%edx
   1141a:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1141d:	01 c8                	add    %ecx,%eax
   1141f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11423:	0f 95 c2             	setne  %dl
   11426:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   11428:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1142b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1142e:	8d 50 01             	lea    0x1(%eax),%edx
   11431:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11434:	01 c8                	add    %ecx,%eax
   11436:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   11439:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1143c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1143f:	01 d0                	add    %edx,%eax
   11441:	83 ec 04             	sub    $0x4,%esp
   11444:	ff 75 e8             	pushl  -0x18(%ebp)
   11447:	ff 75 14             	pushl  0x14(%ebp)
   1144a:	50                   	push   %eax
   1144b:	e8 92 24 ff ff       	call   38e2 <lodepng_memcpy>
   11450:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   11453:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11456:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11459:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1145c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1145f:	8d 50 01             	lea    0x1(%eax),%edx
   11462:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11465:	01 c8                	add    %ecx,%eax
   11467:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   1146a:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1146d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11470:	01 d0                	add    %edx,%eax
   11472:	83 ec 04             	sub    $0x4,%esp
   11475:	ff 75 e4             	pushl  -0x1c(%ebp)
   11478:	ff 75 18             	pushl  0x18(%ebp)
   1147b:	50                   	push   %eax
   1147c:	e8 61 24 ff ff       	call   38e2 <lodepng_memcpy>
   11481:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   11484:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11487:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   1148a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1148d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11490:	8d 50 01             	lea    0x1(%eax),%edx
   11493:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11496:	01 c8                	add    %ecx,%eax
   11498:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   1149b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1149f:	74 1e                	je     114bf <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   114a1:	8b 55 d0             	mov    -0x30(%ebp),%edx
   114a4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   114a7:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   114aa:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   114ad:	01 d9                	add    %ebx,%ecx
   114af:	83 ec 04             	sub    $0x4,%esp
   114b2:	52                   	push   %edx
   114b3:	50                   	push   %eax
   114b4:	51                   	push   %ecx
   114b5:	e8 28 24 ff ff       	call   38e2 <lodepng_memcpy>
   114ba:	83 c4 10             	add    $0x10,%esp
   114bd:	eb 1a                	jmp    114d9 <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   114bf:	8b 55 d8             	mov    -0x28(%ebp),%edx
   114c2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   114c5:	01 d0                	add    %edx,%eax
   114c7:	83 ec 04             	sub    $0x4,%esp
   114ca:	ff 75 f0             	pushl  -0x10(%ebp)
   114cd:	ff 75 1c             	pushl  0x1c(%ebp)
   114d0:	50                   	push   %eax
   114d1:	e8 0c 24 ff ff       	call   38e2 <lodepng_memcpy>
   114d6:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   114d9:	8b 45 d8             	mov    -0x28(%ebp),%eax
   114dc:	83 ec 0c             	sub    $0xc,%esp
   114df:	50                   	push   %eax
   114e0:	e8 e0 74 ff ff       	call   89c5 <lodepng_chunk_generate_crc>
   114e5:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   114e8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   114eb:	83 ec 0c             	sub    $0xc,%esp
   114ee:	50                   	push   %eax
   114ef:	e8 d1 23 ff ff       	call   38c5 <lodepng_free>
   114f4:	83 c4 10             	add    $0x10,%esp
  return error;
   114f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   114fa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   114fd:	c9                   	leave  
   114fe:	c3                   	ret    

000114ff <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   114ff:	55                   	push   %ebp
   11500:	89 e5                	mov    %esp,%ebp
   11502:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   11505:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   1150c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1150f:	8b 40 0c             	mov    0xc(%eax),%eax
   11512:	85 c0                	test   %eax,%eax
   11514:	74 0b                	je     11521 <addChunk_bKGD+0x22>
   11516:	8b 45 0c             	mov    0xc(%ebp),%eax
   11519:	8b 40 0c             	mov    0xc(%eax),%eax
   1151c:	83 f8 04             	cmp    $0x4,%eax
   1151f:	75 4b                	jne    1156c <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   11521:	68 12 a6 01 00       	push   $0x1a612
   11526:	6a 02                	push   $0x2
   11528:	ff 75 08             	pushl  0x8(%ebp)
   1152b:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1152e:	50                   	push   %eax
   1152f:	e8 e8 77 ff ff       	call   8d1c <lodepng_chunk_init>
   11534:	83 c4 10             	add    $0x10,%esp
   11537:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1153a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1153e:	74 08                	je     11548 <addChunk_bKGD+0x49>
   11540:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11543:	e9 19 01 00 00       	jmp    11661 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   11548:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1154b:	8d 50 08             	lea    0x8(%eax),%edx
   1154e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11551:	8b 40 30             	mov    0x30(%eax),%eax
   11554:	c1 e8 08             	shr    $0x8,%eax
   11557:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   11559:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1155c:	8d 50 09             	lea    0x9(%eax),%edx
   1155f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11562:	8b 40 30             	mov    0x30(%eax),%eax
   11565:	88 02                	mov    %al,(%edx)
   11567:	e9 dd 00 00 00       	jmp    11649 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   1156c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1156f:	8b 40 0c             	mov    0xc(%eax),%eax
   11572:	83 f8 02             	cmp    $0x2,%eax
   11575:	74 0f                	je     11586 <addChunk_bKGD+0x87>
   11577:	8b 45 0c             	mov    0xc(%ebp),%eax
   1157a:	8b 40 0c             	mov    0xc(%eax),%eax
   1157d:	83 f8 06             	cmp    $0x6,%eax
   11580:	0f 85 86 00 00 00    	jne    1160c <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   11586:	68 12 a6 01 00       	push   $0x1a612
   1158b:	6a 06                	push   $0x6
   1158d:	ff 75 08             	pushl  0x8(%ebp)
   11590:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11593:	50                   	push   %eax
   11594:	e8 83 77 ff ff       	call   8d1c <lodepng_chunk_init>
   11599:	83 c4 10             	add    $0x10,%esp
   1159c:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1159f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   115a3:	74 08                	je     115ad <addChunk_bKGD+0xae>
   115a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
   115a8:	e9 b4 00 00 00       	jmp    11661 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   115ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   115b0:	8d 50 08             	lea    0x8(%eax),%edx
   115b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   115b6:	8b 40 30             	mov    0x30(%eax),%eax
   115b9:	c1 e8 08             	shr    $0x8,%eax
   115bc:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   115be:	8b 45 f0             	mov    -0x10(%ebp),%eax
   115c1:	8d 50 09             	lea    0x9(%eax),%edx
   115c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   115c7:	8b 40 30             	mov    0x30(%eax),%eax
   115ca:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   115cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   115cf:	8d 50 0a             	lea    0xa(%eax),%edx
   115d2:	8b 45 0c             	mov    0xc(%ebp),%eax
   115d5:	8b 40 34             	mov    0x34(%eax),%eax
   115d8:	c1 e8 08             	shr    $0x8,%eax
   115db:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   115dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   115e0:	8d 50 0b             	lea    0xb(%eax),%edx
   115e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   115e6:	8b 40 34             	mov    0x34(%eax),%eax
   115e9:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   115eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   115ee:	8d 50 0c             	lea    0xc(%eax),%edx
   115f1:	8b 45 0c             	mov    0xc(%ebp),%eax
   115f4:	8b 40 38             	mov    0x38(%eax),%eax
   115f7:	c1 e8 08             	shr    $0x8,%eax
   115fa:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   115fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   115ff:	8d 50 0d             	lea    0xd(%eax),%edx
   11602:	8b 45 0c             	mov    0xc(%ebp),%eax
   11605:	8b 40 38             	mov    0x38(%eax),%eax
   11608:	88 02                	mov    %al,(%edx)
   1160a:	eb 3d                	jmp    11649 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   1160c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1160f:	8b 40 0c             	mov    0xc(%eax),%eax
   11612:	83 f8 03             	cmp    $0x3,%eax
   11615:	75 32                	jne    11649 <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   11617:	68 12 a6 01 00       	push   $0x1a612
   1161c:	6a 01                	push   $0x1
   1161e:	ff 75 08             	pushl  0x8(%ebp)
   11621:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11624:	50                   	push   %eax
   11625:	e8 f2 76 ff ff       	call   8d1c <lodepng_chunk_init>
   1162a:	83 c4 10             	add    $0x10,%esp
   1162d:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11630:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11634:	74 05                	je     1163b <addChunk_bKGD+0x13c>
   11636:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11639:	eb 26                	jmp    11661 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   1163b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1163e:	8d 50 08             	lea    0x8(%eax),%edx
   11641:	8b 45 0c             	mov    0xc(%ebp),%eax
   11644:	8b 40 30             	mov    0x30(%eax),%eax
   11647:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   11649:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1164c:	85 c0                	test   %eax,%eax
   1164e:	74 0c                	je     1165c <addChunk_bKGD+0x15d>
   11650:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11653:	50                   	push   %eax
   11654:	e8 6c 73 ff ff       	call   89c5 <lodepng_chunk_generate_crc>
   11659:	83 c4 04             	add    $0x4,%esp
  return 0;
   1165c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11661:	c9                   	leave  
   11662:	c3                   	ret    

00011663 <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   11663:	55                   	push   %ebp
   11664:	89 e5                	mov    %esp,%ebp
   11666:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   11669:	68 26 a6 01 00       	push   $0x1a626
   1166e:	6a 07                	push   $0x7
   11670:	ff 75 08             	pushl  0x8(%ebp)
   11673:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11676:	50                   	push   %eax
   11677:	e8 a0 76 ff ff       	call   8d1c <lodepng_chunk_init>
   1167c:	83 c4 10             	add    $0x10,%esp
   1167f:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11682:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11686:	74 05                	je     1168d <addChunk_tIME+0x2a>
   11688:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1168b:	eb 74                	jmp    11701 <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   1168d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11690:	8d 50 08             	lea    0x8(%eax),%edx
   11693:	8b 45 0c             	mov    0xc(%ebp),%eax
   11696:	8b 00                	mov    (%eax),%eax
   11698:	c1 e8 08             	shr    $0x8,%eax
   1169b:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   1169d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   116a0:	8d 50 09             	lea    0x9(%eax),%edx
   116a3:	8b 45 0c             	mov    0xc(%ebp),%eax
   116a6:	8b 00                	mov    (%eax),%eax
   116a8:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   116aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
   116ad:	8d 50 0a             	lea    0xa(%eax),%edx
   116b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   116b3:	8b 40 04             	mov    0x4(%eax),%eax
   116b6:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   116b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   116bb:	8d 50 0b             	lea    0xb(%eax),%edx
   116be:	8b 45 0c             	mov    0xc(%ebp),%eax
   116c1:	8b 40 08             	mov    0x8(%eax),%eax
   116c4:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   116c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   116c9:	8d 50 0c             	lea    0xc(%eax),%edx
   116cc:	8b 45 0c             	mov    0xc(%ebp),%eax
   116cf:	8b 40 0c             	mov    0xc(%eax),%eax
   116d2:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   116d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   116d7:	8d 50 0d             	lea    0xd(%eax),%edx
   116da:	8b 45 0c             	mov    0xc(%ebp),%eax
   116dd:	8b 40 10             	mov    0x10(%eax),%eax
   116e0:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   116e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   116e5:	8d 50 0e             	lea    0xe(%eax),%edx
   116e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   116eb:	8b 40 14             	mov    0x14(%eax),%eax
   116ee:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   116f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   116f3:	50                   	push   %eax
   116f4:	e8 cc 72 ff ff       	call   89c5 <lodepng_chunk_generate_crc>
   116f9:	83 c4 04             	add    $0x4,%esp
  return 0;
   116fc:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11701:	c9                   	leave  
   11702:	c3                   	ret    

00011703 <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   11703:	55                   	push   %ebp
   11704:	89 e5                	mov    %esp,%ebp
   11706:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   11709:	68 2b a6 01 00       	push   $0x1a62b
   1170e:	6a 09                	push   $0x9
   11710:	ff 75 08             	pushl  0x8(%ebp)
   11713:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11716:	50                   	push   %eax
   11717:	e8 00 76 ff ff       	call   8d1c <lodepng_chunk_init>
   1171c:	83 c4 10             	add    $0x10,%esp
   1171f:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11722:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11726:	74 05                	je     1172d <addChunk_pHYs+0x2a>
   11728:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1172b:	eb 51                	jmp    1177e <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   1172d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11730:	8b 40 7c             	mov    0x7c(%eax),%eax
   11733:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11736:	83 c2 08             	add    $0x8,%edx
   11739:	50                   	push   %eax
   1173a:	52                   	push   %edx
   1173b:	e8 25 25 ff ff       	call   3c65 <lodepng_set32bitInt>
   11740:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   11743:	8b 45 0c             	mov    0xc(%ebp),%eax
   11746:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   1174c:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1174f:	83 c2 0c             	add    $0xc,%edx
   11752:	50                   	push   %eax
   11753:	52                   	push   %edx
   11754:	e8 0c 25 ff ff       	call   3c65 <lodepng_set32bitInt>
   11759:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   1175c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1175f:	8d 50 10             	lea    0x10(%eax),%edx
   11762:	8b 45 0c             	mov    0xc(%ebp),%eax
   11765:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   1176b:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   1176d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11770:	50                   	push   %eax
   11771:	e8 4f 72 ff ff       	call   89c5 <lodepng_chunk_generate_crc>
   11776:	83 c4 04             	add    $0x4,%esp
  return 0;
   11779:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1177e:	c9                   	leave  
   1177f:	c3                   	ret    

00011780 <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   11780:	55                   	push   %ebp
   11781:	89 e5                	mov    %esp,%ebp
   11783:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   11786:	68 30 a6 01 00       	push   $0x1a630
   1178b:	6a 04                	push   $0x4
   1178d:	ff 75 08             	pushl  0x8(%ebp)
   11790:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11793:	50                   	push   %eax
   11794:	e8 83 75 ff ff       	call   8d1c <lodepng_chunk_init>
   11799:	83 c4 10             	add    $0x10,%esp
   1179c:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1179f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   117a3:	74 05                	je     117aa <addChunk_gAMA+0x2a>
   117a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   117a8:	eb 2a                	jmp    117d4 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   117aa:	8b 45 0c             	mov    0xc(%ebp),%eax
   117ad:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   117b3:	8b 55 f8             	mov    -0x8(%ebp),%edx
   117b6:	83 c2 08             	add    $0x8,%edx
   117b9:	50                   	push   %eax
   117ba:	52                   	push   %edx
   117bb:	e8 a5 24 ff ff       	call   3c65 <lodepng_set32bitInt>
   117c0:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   117c3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   117c6:	50                   	push   %eax
   117c7:	e8 f9 71 ff ff       	call   89c5 <lodepng_chunk_generate_crc>
   117cc:	83 c4 04             	add    $0x4,%esp
  return 0;
   117cf:	b8 00 00 00 00       	mov    $0x0,%eax
}
   117d4:	c9                   	leave  
   117d5:	c3                   	ret    

000117d6 <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   117d6:	55                   	push   %ebp
   117d7:	89 e5                	mov    %esp,%ebp
   117d9:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   117dc:	68 35 a6 01 00       	push   $0x1a635
   117e1:	6a 20                	push   $0x20
   117e3:	ff 75 08             	pushl  0x8(%ebp)
   117e6:	8d 45 f8             	lea    -0x8(%ebp),%eax
   117e9:	50                   	push   %eax
   117ea:	e8 2d 75 ff ff       	call   8d1c <lodepng_chunk_init>
   117ef:	83 c4 10             	add    $0x10,%esp
   117f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
   117f5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   117f9:	74 08                	je     11803 <addChunk_cHRM+0x2d>
   117fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   117fe:	e9 d9 00 00 00       	jmp    118dc <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   11803:	8b 45 0c             	mov    0xc(%ebp),%eax
   11806:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   1180c:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1180f:	83 c2 08             	add    $0x8,%edx
   11812:	50                   	push   %eax
   11813:	52                   	push   %edx
   11814:	e8 4c 24 ff ff       	call   3c65 <lodepng_set32bitInt>
   11819:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   1181c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1181f:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   11825:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11828:	83 c2 0c             	add    $0xc,%edx
   1182b:	50                   	push   %eax
   1182c:	52                   	push   %edx
   1182d:	e8 33 24 ff ff       	call   3c65 <lodepng_set32bitInt>
   11832:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   11835:	8b 45 0c             	mov    0xc(%ebp),%eax
   11838:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   1183e:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11841:	83 c2 10             	add    $0x10,%edx
   11844:	50                   	push   %eax
   11845:	52                   	push   %edx
   11846:	e8 1a 24 ff ff       	call   3c65 <lodepng_set32bitInt>
   1184b:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   1184e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11851:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11857:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1185a:	83 c2 14             	add    $0x14,%edx
   1185d:	50                   	push   %eax
   1185e:	52                   	push   %edx
   1185f:	e8 01 24 ff ff       	call   3c65 <lodepng_set32bitInt>
   11864:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   11867:	8b 45 0c             	mov    0xc(%ebp),%eax
   1186a:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   11870:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11873:	83 c2 18             	add    $0x18,%edx
   11876:	50                   	push   %eax
   11877:	52                   	push   %edx
   11878:	e8 e8 23 ff ff       	call   3c65 <lodepng_set32bitInt>
   1187d:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   11880:	8b 45 0c             	mov    0xc(%ebp),%eax
   11883:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   11889:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1188c:	83 c2 1c             	add    $0x1c,%edx
   1188f:	50                   	push   %eax
   11890:	52                   	push   %edx
   11891:	e8 cf 23 ff ff       	call   3c65 <lodepng_set32bitInt>
   11896:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   11899:	8b 45 0c             	mov    0xc(%ebp),%eax
   1189c:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   118a2:	8b 55 f8             	mov    -0x8(%ebp),%edx
   118a5:	83 c2 20             	add    $0x20,%edx
   118a8:	50                   	push   %eax
   118a9:	52                   	push   %edx
   118aa:	e8 b6 23 ff ff       	call   3c65 <lodepng_set32bitInt>
   118af:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   118b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   118b5:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   118bb:	8b 55 f8             	mov    -0x8(%ebp),%edx
   118be:	83 c2 24             	add    $0x24,%edx
   118c1:	50                   	push   %eax
   118c2:	52                   	push   %edx
   118c3:	e8 9d 23 ff ff       	call   3c65 <lodepng_set32bitInt>
   118c8:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   118cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   118ce:	50                   	push   %eax
   118cf:	e8 f1 70 ff ff       	call   89c5 <lodepng_chunk_generate_crc>
   118d4:	83 c4 04             	add    $0x4,%esp
  return 0;
   118d7:	b8 00 00 00 00       	mov    $0x0,%eax
}
   118dc:	c9                   	leave  
   118dd:	c3                   	ret    

000118de <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   118de:	55                   	push   %ebp
   118df:	89 e5                	mov    %esp,%ebp
   118e1:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   118e4:	8b 45 0c             	mov    0xc(%ebp),%eax
   118e7:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   118ed:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   118f0:	8d 45 ff             	lea    -0x1(%ebp),%eax
   118f3:	50                   	push   %eax
   118f4:	68 3a a6 01 00       	push   $0x1a63a
   118f9:	6a 01                	push   $0x1
   118fb:	ff 75 08             	pushl  0x8(%ebp)
   118fe:	e8 c1 74 ff ff       	call   8dc4 <lodepng_chunk_createv>
   11903:	83 c4 10             	add    $0x10,%esp
}
   11906:	c9                   	leave  
   11907:	c3                   	ret    

00011908 <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   11908:	55                   	push   %ebp
   11909:	89 e5                	mov    %esp,%ebp
   1190b:	53                   	push   %ebx
   1190c:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   1190f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11916:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   1191d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   11924:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   1192b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1192e:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11934:	50                   	push   %eax
   11935:	e8 06 20 ff ff       	call   3940 <lodepng_strlen>
   1193a:	83 c4 04             	add    $0x4,%esp
   1193d:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11940:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11944:	7e 06                	jle    1194c <addChunk_iCCP+0x44>
   11946:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   1194a:	7e 0a                	jle    11956 <addChunk_iCCP+0x4e>
   1194c:	b8 59 00 00 00       	mov    $0x59,%eax
   11951:	e9 df 00 00 00       	jmp    11a35 <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   11956:	8b 45 0c             	mov    0xc(%ebp),%eax
   11959:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   1195f:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   11961:	8b 45 0c             	mov    0xc(%ebp),%eax
   11964:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   1196a:	83 ec 0c             	sub    $0xc,%esp
   1196d:	ff 75 10             	pushl  0x10(%ebp)
   11970:	52                   	push   %edx
   11971:	50                   	push   %eax
   11972:	8d 45 e0             	lea    -0x20(%ebp),%eax
   11975:	50                   	push   %eax
   11976:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   11979:	50                   	push   %eax
   1197a:	e8 35 6c ff ff       	call   85b4 <zlib_compress>
   1197f:	83 c4 20             	add    $0x20,%esp
   11982:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   11985:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11989:	75 29                	jne    119b4 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   1198b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1198e:	8d 50 02             	lea    0x2(%eax),%edx
   11991:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11994:	01 d0                	add    %edx,%eax
   11996:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   11999:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1199c:	68 3f a6 01 00       	push   $0x1a63f
   119a1:	50                   	push   %eax
   119a2:	ff 75 08             	pushl  0x8(%ebp)
   119a5:	8d 45 e8             	lea    -0x18(%ebp),%eax
   119a8:	50                   	push   %eax
   119a9:	e8 6e 73 ff ff       	call   8d1c <lodepng_chunk_init>
   119ae:	83 c4 10             	add    $0x10,%esp
   119b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   119b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   119b8:	75 69                	jne    11a23 <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   119ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   119bd:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   119c3:	8b 55 e8             	mov    -0x18(%ebp),%edx
   119c6:	83 c2 08             	add    $0x8,%edx
   119c9:	83 ec 04             	sub    $0x4,%esp
   119cc:	ff 75 f0             	pushl  -0x10(%ebp)
   119cf:	50                   	push   %eax
   119d0:	52                   	push   %edx
   119d1:	e8 0c 1f ff ff       	call   38e2 <lodepng_memcpy>
   119d6:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   119d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   119dc:	8b 55 f0             	mov    -0x10(%ebp),%edx
   119df:	83 c2 08             	add    $0x8,%edx
   119e2:	01 d0                	add    %edx,%eax
   119e4:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   119e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   119ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
   119ed:	83 c2 09             	add    $0x9,%edx
   119f0:	01 d0                	add    %edx,%eax
   119f2:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   119f5:	8b 55 e0             	mov    -0x20(%ebp),%edx
   119f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119fb:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   119fe:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   11a01:	83 c3 0a             	add    $0xa,%ebx
   11a04:	01 d9                	add    %ebx,%ecx
   11a06:	83 ec 04             	sub    $0x4,%esp
   11a09:	52                   	push   %edx
   11a0a:	50                   	push   %eax
   11a0b:	51                   	push   %ecx
   11a0c:	e8 d1 1e ff ff       	call   38e2 <lodepng_memcpy>
   11a11:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   11a14:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11a17:	83 ec 0c             	sub    $0xc,%esp
   11a1a:	50                   	push   %eax
   11a1b:	e8 a5 6f ff ff       	call   89c5 <lodepng_chunk_generate_crc>
   11a20:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11a23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a26:	83 ec 0c             	sub    $0xc,%esp
   11a29:	50                   	push   %eax
   11a2a:	e8 96 1e ff ff       	call   38c5 <lodepng_free>
   11a2f:	83 c4 10             	add    $0x10,%esp
  return error;
   11a32:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11a35:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11a38:	c9                   	leave  
   11a39:	c3                   	ret    

00011a3a <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   11a3a:	55                   	push   %ebp
   11a3b:	89 e5                	mov    %esp,%ebp
   11a3d:	56                   	push   %esi
   11a3e:	53                   	push   %ebx
   11a3f:	83 ec 14             	sub    $0x14,%esp
   11a42:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11a45:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   11a48:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   11a4c:	83 f8 04             	cmp    $0x4,%eax
   11a4f:	0f 87 41 03 00 00    	ja     11d96 <filterScanline+0x35c>
   11a55:	8b 04 85 50 a6 01 00 	mov    0x1a650(,%eax,4),%eax
   11a5c:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   11a5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11a65:	eb 19                	jmp    11a80 <filterScanline+0x46>
   11a67:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a6a:	8b 45 08             	mov    0x8(%ebp),%eax
   11a6d:	01 c2                	add    %eax,%edx
   11a6f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11a72:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a75:	01 c8                	add    %ecx,%eax
   11a77:	0f b6 00             	movzbl (%eax),%eax
   11a7a:	88 02                	mov    %al,(%edx)
   11a7c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11a80:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a83:	3b 45 14             	cmp    0x14(%ebp),%eax
   11a86:	75 df                	jne    11a67 <filterScanline+0x2d>
      break;
   11a88:	e9 0a 03 00 00       	jmp    11d97 <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11a8d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11a94:	eb 19                	jmp    11aaf <filterScanline+0x75>
   11a96:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a99:	8b 45 08             	mov    0x8(%ebp),%eax
   11a9c:	01 c2                	add    %eax,%edx
   11a9e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11aa1:	8b 45 0c             	mov    0xc(%ebp),%eax
   11aa4:	01 c8                	add    %ecx,%eax
   11aa6:	0f b6 00             	movzbl (%eax),%eax
   11aa9:	88 02                	mov    %al,(%edx)
   11aab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11aaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ab2:	3b 45 18             	cmp    0x18(%ebp),%eax
   11ab5:	75 df                	jne    11a96 <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   11ab7:	8b 45 18             	mov    0x18(%ebp),%eax
   11aba:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11abd:	eb 2d                	jmp    11aec <filterScanline+0xb2>
   11abf:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11ac2:	8b 45 08             	mov    0x8(%ebp),%eax
   11ac5:	01 c2                	add    %eax,%edx
   11ac7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11aca:	8b 45 0c             	mov    0xc(%ebp),%eax
   11acd:	01 c8                	add    %ecx,%eax
   11acf:	0f b6 08             	movzbl (%eax),%ecx
   11ad2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ad5:	2b 45 18             	sub    0x18(%ebp),%eax
   11ad8:	89 c3                	mov    %eax,%ebx
   11ada:	8b 45 0c             	mov    0xc(%ebp),%eax
   11add:	01 d8                	add    %ebx,%eax
   11adf:	0f b6 00             	movzbl (%eax),%eax
   11ae2:	29 c1                	sub    %eax,%ecx
   11ae4:	89 c8                	mov    %ecx,%eax
   11ae6:	88 02                	mov    %al,(%edx)
   11ae8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11aef:	3b 45 14             	cmp    0x14(%ebp),%eax
   11af2:	7c cb                	jl     11abf <filterScanline+0x85>
      break;
   11af4:	e9 9e 02 00 00       	jmp    11d97 <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   11af9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11afd:	74 3e                	je     11b3d <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   11aff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11b06:	eb 28                	jmp    11b30 <filterScanline+0xf6>
   11b08:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11b0b:	8b 45 08             	mov    0x8(%ebp),%eax
   11b0e:	01 d0                	add    %edx,%eax
   11b10:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11b13:	8b 55 0c             	mov    0xc(%ebp),%edx
   11b16:	01 ca                	add    %ecx,%edx
   11b18:	0f b6 0a             	movzbl (%edx),%ecx
   11b1b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11b1e:	8b 55 10             	mov    0x10(%ebp),%edx
   11b21:	01 da                	add    %ebx,%edx
   11b23:	0f b6 12             	movzbl (%edx),%edx
   11b26:	29 d1                	sub    %edx,%ecx
   11b28:	89 ca                	mov    %ecx,%edx
   11b2a:	88 10                	mov    %dl,(%eax)
   11b2c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11b30:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11b33:	3b 45 14             	cmp    0x14(%ebp),%eax
   11b36:	75 d0                	jne    11b08 <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   11b38:	e9 5a 02 00 00       	jmp    11d97 <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   11b3d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11b44:	eb 19                	jmp    11b5f <filterScanline+0x125>
   11b46:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11b49:	8b 45 08             	mov    0x8(%ebp),%eax
   11b4c:	01 c2                	add    %eax,%edx
   11b4e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11b51:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b54:	01 c8                	add    %ecx,%eax
   11b56:	0f b6 00             	movzbl (%eax),%eax
   11b59:	88 02                	mov    %al,(%edx)
   11b5b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11b5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11b62:	3b 45 14             	cmp    0x14(%ebp),%eax
   11b65:	75 df                	jne    11b46 <filterScanline+0x10c>
      }
      break;
   11b67:	e9 2b 02 00 00       	jmp    11d97 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   11b6c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11b70:	0f 84 90 00 00 00    	je     11c06 <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   11b76:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11b7d:	eb 28                	jmp    11ba7 <filterScanline+0x16d>
   11b7f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11b82:	8b 45 08             	mov    0x8(%ebp),%eax
   11b85:	01 d0                	add    %edx,%eax
   11b87:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11b8a:	8b 55 0c             	mov    0xc(%ebp),%edx
   11b8d:	01 ca                	add    %ecx,%edx
   11b8f:	0f b6 12             	movzbl (%edx),%edx
   11b92:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11b95:	8b 4d 10             	mov    0x10(%ebp),%ecx
   11b98:	01 d9                	add    %ebx,%ecx
   11b9a:	0f b6 09             	movzbl (%ecx),%ecx
   11b9d:	d0 e9                	shr    %cl
   11b9f:	29 ca                	sub    %ecx,%edx
   11ba1:	88 10                	mov    %dl,(%eax)
   11ba3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11ba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11baa:	3b 45 18             	cmp    0x18(%ebp),%eax
   11bad:	75 d0                	jne    11b7f <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   11baf:	8b 45 18             	mov    0x18(%ebp),%eax
   11bb2:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11bb5:	eb 42                	jmp    11bf9 <filterScanline+0x1bf>
   11bb7:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11bba:	8b 45 08             	mov    0x8(%ebp),%eax
   11bbd:	01 c2                	add    %eax,%edx
   11bbf:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11bc2:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bc5:	01 c8                	add    %ecx,%eax
   11bc7:	0f b6 08             	movzbl (%eax),%ecx
   11bca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11bcd:	2b 45 18             	sub    0x18(%ebp),%eax
   11bd0:	89 c3                	mov    %eax,%ebx
   11bd2:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bd5:	01 d8                	add    %ebx,%eax
   11bd7:	0f b6 00             	movzbl (%eax),%eax
   11bda:	0f b6 d8             	movzbl %al,%ebx
   11bdd:	8b 75 f4             	mov    -0xc(%ebp),%esi
   11be0:	8b 45 10             	mov    0x10(%ebp),%eax
   11be3:	01 f0                	add    %esi,%eax
   11be5:	0f b6 00             	movzbl (%eax),%eax
   11be8:	0f b6 c0             	movzbl %al,%eax
   11beb:	01 d8                	add    %ebx,%eax
   11bed:	d1 f8                	sar    %eax
   11bef:	29 c1                	sub    %eax,%ecx
   11bf1:	89 c8                	mov    %ecx,%eax
   11bf3:	88 02                	mov    %al,(%edx)
   11bf5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11bf9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11bfc:	3b 45 14             	cmp    0x14(%ebp),%eax
   11bff:	7c b6                	jl     11bb7 <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   11c01:	e9 91 01 00 00       	jmp    11d97 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11c06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11c0d:	eb 19                	jmp    11c28 <filterScanline+0x1ee>
   11c0f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11c12:	8b 45 08             	mov    0x8(%ebp),%eax
   11c15:	01 c2                	add    %eax,%edx
   11c17:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11c1a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c1d:	01 c8                	add    %ecx,%eax
   11c1f:	0f b6 00             	movzbl (%eax),%eax
   11c22:	88 02                	mov    %al,(%edx)
   11c24:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11c28:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c2b:	3b 45 18             	cmp    0x18(%ebp),%eax
   11c2e:	75 df                	jne    11c0f <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   11c30:	8b 45 18             	mov    0x18(%ebp),%eax
   11c33:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11c36:	eb 2f                	jmp    11c67 <filterScanline+0x22d>
   11c38:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11c3b:	8b 45 08             	mov    0x8(%ebp),%eax
   11c3e:	01 c2                	add    %eax,%edx
   11c40:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11c43:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c46:	01 c8                	add    %ecx,%eax
   11c48:	0f b6 08             	movzbl (%eax),%ecx
   11c4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c4e:	2b 45 18             	sub    0x18(%ebp),%eax
   11c51:	89 c3                	mov    %eax,%ebx
   11c53:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c56:	01 d8                	add    %ebx,%eax
   11c58:	0f b6 00             	movzbl (%eax),%eax
   11c5b:	d0 e8                	shr    %al
   11c5d:	29 c1                	sub    %eax,%ecx
   11c5f:	89 c8                	mov    %ecx,%eax
   11c61:	88 02                	mov    %al,(%edx)
   11c63:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11c67:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c6a:	3b 45 14             	cmp    0x14(%ebp),%eax
   11c6d:	7c c9                	jl     11c38 <filterScanline+0x1fe>
      }
      break;
   11c6f:	e9 23 01 00 00       	jmp    11d97 <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   11c74:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11c78:	0f 84 af 00 00 00    	je     11d2d <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   11c7e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11c85:	eb 28                	jmp    11caf <filterScanline+0x275>
   11c87:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11c8a:	8b 45 08             	mov    0x8(%ebp),%eax
   11c8d:	01 d0                	add    %edx,%eax
   11c8f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11c92:	8b 55 0c             	mov    0xc(%ebp),%edx
   11c95:	01 ca                	add    %ecx,%edx
   11c97:	0f b6 0a             	movzbl (%edx),%ecx
   11c9a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11c9d:	8b 55 10             	mov    0x10(%ebp),%edx
   11ca0:	01 da                	add    %ebx,%edx
   11ca2:	0f b6 12             	movzbl (%edx),%edx
   11ca5:	29 d1                	sub    %edx,%ecx
   11ca7:	89 ca                	mov    %ecx,%edx
   11ca9:	88 10                	mov    %dl,(%eax)
   11cab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11caf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11cb2:	3b 45 18             	cmp    0x18(%ebp),%eax
   11cb5:	75 d0                	jne    11c87 <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   11cb7:	8b 45 18             	mov    0x18(%ebp),%eax
   11cba:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11cbd:	eb 64                	jmp    11d23 <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   11cbf:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11cc2:	8b 45 08             	mov    0x8(%ebp),%eax
   11cc5:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   11cc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11ccb:	8b 45 0c             	mov    0xc(%ebp),%eax
   11cce:	01 d0                	add    %edx,%eax
   11cd0:	0f b6 00             	movzbl (%eax),%eax
   11cd3:	88 45 e7             	mov    %al,-0x19(%ebp)
   11cd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11cd9:	2b 45 18             	sub    0x18(%ebp),%eax
   11cdc:	89 c2                	mov    %eax,%edx
   11cde:	8b 45 10             	mov    0x10(%ebp),%eax
   11ce1:	01 d0                	add    %edx,%eax
   11ce3:	0f b6 00             	movzbl (%eax),%eax
   11ce6:	0f b6 c8             	movzbl %al,%ecx
   11ce9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11cec:	8b 45 10             	mov    0x10(%ebp),%eax
   11cef:	01 d0                	add    %edx,%eax
   11cf1:	0f b6 00             	movzbl (%eax),%eax
   11cf4:	0f b6 d0             	movzbl %al,%edx
   11cf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11cfa:	2b 45 18             	sub    0x18(%ebp),%eax
   11cfd:	89 c6                	mov    %eax,%esi
   11cff:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d02:	01 f0                	add    %esi,%eax
   11d04:	0f b6 00             	movzbl (%eax),%eax
   11d07:	0f b6 c0             	movzbl %al,%eax
   11d0a:	51                   	push   %ecx
   11d0b:	52                   	push   %edx
   11d0c:	50                   	push   %eax
   11d0d:	e8 49 b8 ff ff       	call   d55b <paethPredictor>
   11d12:	83 c4 0c             	add    $0xc,%esp
   11d15:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   11d19:	29 c1                	sub    %eax,%ecx
   11d1b:	89 c8                	mov    %ecx,%eax
   11d1d:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   11d1f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11d23:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11d26:	3b 45 14             	cmp    0x14(%ebp),%eax
   11d29:	7c 94                	jl     11cbf <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   11d2b:	eb 6a                	jmp    11d97 <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11d2d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11d34:	eb 19                	jmp    11d4f <filterScanline+0x315>
   11d36:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11d39:	8b 45 08             	mov    0x8(%ebp),%eax
   11d3c:	01 c2                	add    %eax,%edx
   11d3e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11d41:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d44:	01 c8                	add    %ecx,%eax
   11d46:	0f b6 00             	movzbl (%eax),%eax
   11d49:	88 02                	mov    %al,(%edx)
   11d4b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11d4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11d52:	3b 45 18             	cmp    0x18(%ebp),%eax
   11d55:	75 df                	jne    11d36 <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   11d57:	8b 45 18             	mov    0x18(%ebp),%eax
   11d5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11d5d:	eb 2d                	jmp    11d8c <filterScanline+0x352>
   11d5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11d62:	8b 45 08             	mov    0x8(%ebp),%eax
   11d65:	01 c2                	add    %eax,%edx
   11d67:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11d6a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d6d:	01 c8                	add    %ecx,%eax
   11d6f:	0f b6 08             	movzbl (%eax),%ecx
   11d72:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11d75:	2b 45 18             	sub    0x18(%ebp),%eax
   11d78:	89 c3                	mov    %eax,%ebx
   11d7a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d7d:	01 d8                	add    %ebx,%eax
   11d7f:	0f b6 00             	movzbl (%eax),%eax
   11d82:	29 c1                	sub    %eax,%ecx
   11d84:	89 c8                	mov    %ecx,%eax
   11d86:	88 02                	mov    %al,(%edx)
   11d88:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11d8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11d8f:	3b 45 14             	cmp    0x14(%ebp),%eax
   11d92:	7c cb                	jl     11d5f <filterScanline+0x325>
      }
      break;
   11d94:	eb 01                	jmp    11d97 <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   11d96:	90                   	nop
  }
}
   11d97:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11d9a:	5b                   	pop    %ebx
   11d9b:	5e                   	pop    %esi
   11d9c:	5d                   	pop    %ebp
   11d9d:	c3                   	ret    

00011d9e <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   11d9e:	55                   	push   %ebp
   11d9f:	89 e5                	mov    %esp,%ebp
   11da1:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   11da4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   11dab:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   11db2:	7e 08                	jle    11dbc <ilog2+0x1e>
   11db4:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   11db8:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   11dbc:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   11dc3:	7e 08                	jle    11dcd <ilog2+0x2f>
   11dc5:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   11dc9:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   11dcd:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   11dd1:	7e 08                	jle    11ddb <ilog2+0x3d>
   11dd3:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   11dd7:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   11ddb:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   11ddf:	7e 08                	jle    11de9 <ilog2+0x4b>
   11de1:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   11de5:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   11de9:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   11ded:	7e 04                	jle    11df3 <ilog2+0x55>
   11def:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   11df3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11df6:	c9                   	leave  
   11df7:	c3                   	ret    

00011df8 <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   11df8:	55                   	push   %ebp
   11df9:	89 e5                	mov    %esp,%ebp
   11dfb:	56                   	push   %esi
   11dfc:	53                   	push   %ebx
   11dfd:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   11e00:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11e04:	75 07                	jne    11e0d <ilog2i+0x15>
   11e06:	b8 00 00 00 00       	mov    $0x0,%eax
   11e0b:	eb 30                	jmp    11e3d <ilog2i+0x45>
  l = ilog2(i);
   11e0d:	ff 75 08             	pushl  0x8(%ebp)
   11e10:	e8 89 ff ff ff       	call   11d9e <ilog2>
   11e15:	83 c4 04             	add    $0x4,%esp
   11e18:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   11e1b:	8b 45 08             	mov    0x8(%ebp),%eax
   11e1e:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   11e22:	89 c3                	mov    %eax,%ebx
   11e24:	8b 55 08             	mov    0x8(%ebp),%edx
   11e27:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e2a:	be 01 00 00 00       	mov    $0x1,%esi
   11e2f:	89 c1                	mov    %eax,%ecx
   11e31:	d3 e6                	shl    %cl,%esi
   11e33:	89 f0                	mov    %esi,%eax
   11e35:	29 c2                	sub    %eax,%edx
   11e37:	89 d0                	mov    %edx,%eax
   11e39:	01 c0                	add    %eax,%eax
   11e3b:	01 d8                	add    %ebx,%eax
}
   11e3d:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11e40:	5b                   	pop    %ebx
   11e41:	5e                   	pop    %esi
   11e42:	5d                   	pop    %ebp
   11e43:	c3                   	ret    

00011e44 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   11e44:	55                   	push   %ebp
   11e45:	89 e5                	mov    %esp,%ebp
   11e47:	53                   	push   %ebx
   11e48:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   11e4e:	ff 75 18             	pushl  0x18(%ebp)
   11e51:	e8 6a 75 ff ff       	call   93c0 <lodepng_get_bpp>
   11e56:	83 c4 04             	add    $0x4,%esp
   11e59:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   11e5c:	ff 75 b8             	pushl  -0x48(%ebp)
   11e5f:	6a 01                	push   $0x1
   11e61:	ff 75 10             	pushl  0x10(%ebp)
   11e64:	e8 b6 76 ff ff       	call   951f <lodepng_get_raw_size_idat>
   11e69:	83 c4 0c             	add    $0xc,%esp
   11e6c:	83 e8 01             	sub    $0x1,%eax
   11e6f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   11e72:	8b 45 b8             	mov    -0x48(%ebp),%eax
   11e75:	83 c0 07             	add    $0x7,%eax
   11e78:	c1 e8 03             	shr    $0x3,%eax
   11e7b:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   11e7e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   11e85:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   11e8c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11e8f:	8b 40 2c             	mov    0x2c(%eax),%eax
   11e92:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11e95:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11e98:	8b 40 28             	mov    0x28(%eax),%eax
   11e9b:	85 c0                	test   %eax,%eax
   11e9d:	74 1c                	je     11ebb <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11e9f:	8b 45 18             	mov    0x18(%ebp),%eax
   11ea2:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11ea4:	83 f8 03             	cmp    $0x3,%eax
   11ea7:	74 0b                	je     11eb4 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11ea9:	8b 45 18             	mov    0x18(%ebp),%eax
   11eac:	8b 40 04             	mov    0x4(%eax),%eax
   11eaf:	83 f8 07             	cmp    $0x7,%eax
   11eb2:	77 07                	ja     11ebb <filter+0x77>
   11eb4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   11ebb:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   11ebf:	75 0a                	jne    11ecb <filter+0x87>
   11ec1:	b8 1f 00 00 00       	mov    $0x1f,%eax
   11ec6:	e9 5b 07 00 00       	jmp    12626 <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   11ecb:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   11ecf:	77 7b                	ja     11f4c <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   11ed1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11ed4:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   11ed7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11ede:	eb 5f                	jmp    11f3f <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11ee0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ee3:	83 c0 01             	add    $0x1,%eax
   11ee6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11eea:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   11eed:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ef0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ef4:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   11ef7:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11efa:	8b 45 08             	mov    0x8(%ebp),%eax
   11efd:	01 c2                	add    %eax,%edx
   11eff:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11f03:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11f05:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11f09:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   11f0c:	8b 55 0c             	mov    0xc(%ebp),%edx
   11f0f:	01 d1                	add    %edx,%ecx
   11f11:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11f14:	8d 5a 01             	lea    0x1(%edx),%ebx
   11f17:	8b 55 08             	mov    0x8(%ebp),%edx
   11f1a:	01 da                	add    %ebx,%edx
   11f1c:	50                   	push   %eax
   11f1d:	ff 75 b0             	pushl  -0x50(%ebp)
   11f20:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f23:	ff 75 f4             	pushl  -0xc(%ebp)
   11f26:	51                   	push   %ecx
   11f27:	52                   	push   %edx
   11f28:	e8 0d fb ff ff       	call   11a3a <filterScanline>
   11f2d:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   11f30:	8b 55 98             	mov    -0x68(%ebp),%edx
   11f33:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f36:	01 d0                	add    %edx,%eax
   11f38:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   11f3b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11f3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11f42:	3b 45 14             	cmp    0x14(%ebp),%eax
   11f45:	75 99                	jne    11ee0 <filter+0x9c>
   11f47:	e9 d7 06 00 00       	jmp    12623 <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   11f4c:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   11f50:	0f 85 e3 01 00 00    	jne    12139 <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11f56:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   11f5d:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   11f61:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11f65:	eb 2d                	jmp    11f94 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11f67:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   11f6b:	83 ec 0c             	sub    $0xc,%esp
   11f6e:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f71:	e8 2e 19 ff ff       	call   38a4 <lodepng_malloc>
   11f76:	83 c4 10             	add    $0x10,%esp
   11f79:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11f7d:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11f81:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11f85:	85 c0                	test   %eax,%eax
   11f87:	75 07                	jne    11f90 <filter+0x14c>
   11f89:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   11f90:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11f94:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11f98:	75 cd                	jne    11f67 <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11f9a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11f9e:	0f 85 6c 01 00 00    	jne    12110 <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   11fa4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11fab:	e9 54 01 00 00       	jmp    12104 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11fb0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11fb4:	e9 d5 00 00 00       	jmp    1208e <filter+0x24a>
          size_t sum = 0;
   11fb9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11fc0:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   11fc4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11fc7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11fcb:	89 c1                	mov    %eax,%ecx
   11fcd:	8b 45 0c             	mov    0xc(%ebp),%eax
   11fd0:	01 c1                	add    %eax,%ecx
   11fd2:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11fd6:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11fda:	83 ec 08             	sub    $0x8,%esp
   11fdd:	52                   	push   %edx
   11fde:	ff 75 b0             	pushl  -0x50(%ebp)
   11fe1:	ff 75 b4             	pushl  -0x4c(%ebp)
   11fe4:	ff 75 f4             	pushl  -0xc(%ebp)
   11fe7:	51                   	push   %ecx
   11fe8:	50                   	push   %eax
   11fe9:	e8 4c fa ff ff       	call   11a3a <filterScanline>
   11fee:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   11ff1:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11ff5:	75 2d                	jne    12024 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   11ff7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11ffe:	eb 1a                	jmp    1201a <filter+0x1d6>
   12000:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   12004:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   12008:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1200b:	01 d0                	add    %edx,%eax
   1200d:	0f b6 00             	movzbl (%eax),%eax
   12010:	0f b6 c0             	movzbl %al,%eax
   12013:	01 45 d8             	add    %eax,-0x28(%ebp)
   12016:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1201a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1201d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12020:	75 de                	jne    12000 <filter+0x1bc>
   12022:	eb 4b                	jmp    1206f <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   12024:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1202b:	eb 3a                	jmp    12067 <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   1202d:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   12031:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   12035:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12038:	01 d0                	add    %edx,%eax
   1203a:	0f b6 00             	movzbl (%eax),%eax
   1203d:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   12040:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   12044:	84 c0                	test   %al,%al
   12046:	78 06                	js     1204e <filter+0x20a>
   12048:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   1204c:	eb 0d                	jmp    1205b <filter+0x217>
   1204e:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   12052:	ba ff 00 00 00       	mov    $0xff,%edx
   12057:	29 c2                	sub    %eax,%edx
   12059:	89 d0                	mov    %edx,%eax
   1205b:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1205e:	01 d0                	add    %edx,%eax
   12060:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   12063:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12067:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1206a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1206d:	75 be                	jne    1202d <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   1206f:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   12073:	74 08                	je     1207d <filter+0x239>
   12075:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12078:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   1207b:	7d 0d                	jge    1208a <filter+0x246>
            bestType = type;
   1207d:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   12081:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   12084:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12087:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   1208a:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   1208e:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   12092:	0f 85 21 ff ff ff    	jne    11fb9 <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   12098:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1209b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1209f:	89 c2                	mov    %eax,%edx
   120a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   120a4:	01 d0                	add    %edx,%eax
   120a6:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   120a9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120ac:	83 c0 01             	add    $0x1,%eax
   120af:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   120b3:	89 c2                	mov    %eax,%edx
   120b5:	8b 45 08             	mov    0x8(%ebp),%eax
   120b8:	01 c2                	add    %eax,%edx
   120ba:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   120be:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   120c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   120c7:	eb 2f                	jmp    120f8 <filter+0x2b4>
   120c9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120cc:	83 c0 01             	add    $0x1,%eax
   120cf:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   120d3:	89 c2                	mov    %eax,%edx
   120d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120d8:	01 d0                	add    %edx,%eax
   120da:	8d 50 01             	lea    0x1(%eax),%edx
   120dd:	8b 45 08             	mov    0x8(%ebp),%eax
   120e0:	01 c2                	add    %eax,%edx
   120e2:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   120e6:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   120ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120ed:	01 c8                	add    %ecx,%eax
   120ef:	0f b6 00             	movzbl (%eax),%eax
   120f2:	88 02                	mov    %al,(%edx)
   120f4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   120f8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120fb:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   120fe:	75 c9                	jne    120c9 <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   12100:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12104:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12107:	3b 45 14             	cmp    0x14(%ebp),%eax
   1210a:	0f 85 a0 fe ff ff    	jne    11fb0 <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12110:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   12114:	eb 18                	jmp    1212e <filter+0x2ea>
   12116:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   1211a:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   1211e:	83 ec 0c             	sub    $0xc,%esp
   12121:	50                   	push   %eax
   12122:	e8 9e 17 ff ff       	call   38c5 <lodepng_free>
   12127:	83 c4 10             	add    $0x10,%esp
   1212a:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   1212e:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   12132:	75 e2                	jne    12116 <filter+0x2d2>
   12134:	e9 ea 04 00 00       	jmp    12623 <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   12139:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   1213d:	0f 85 17 02 00 00    	jne    1235a <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   12143:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   1214a:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   12151:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   12158:	eb 33                	jmp    1218d <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   1215a:	83 ec 0c             	sub    $0xc,%esp
   1215d:	ff 75 b4             	pushl  -0x4c(%ebp)
   12160:	e8 3f 17 ff ff       	call   38a4 <lodepng_malloc>
   12165:	83 c4 10             	add    $0x10,%esp
   12168:	89 c2                	mov    %eax,%edx
   1216a:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1216d:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   12174:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12177:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   1217e:	85 c0                	test   %eax,%eax
   12180:	75 07                	jne    12189 <filter+0x345>
   12182:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   12189:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   1218d:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   12191:	75 c7                	jne    1215a <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   12193:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12197:	0f 85 8f 01 00 00    	jne    1232c <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   1219d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   121a4:	e9 77 01 00 00       	jmp    12320 <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   121a9:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   121b0:	e9 f4 00 00 00       	jmp    122a9 <filter+0x465>
          size_t sum = 0;
   121b5:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   121bc:	8b 45 d0             	mov    -0x30(%ebp),%eax
   121bf:	0f b6 d0             	movzbl %al,%edx
   121c2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   121c5:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   121c9:	89 c1                	mov    %eax,%ecx
   121cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   121ce:	01 c1                	add    %eax,%ecx
   121d0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   121d3:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   121da:	83 ec 08             	sub    $0x8,%esp
   121dd:	52                   	push   %edx
   121de:	ff 75 b0             	pushl  -0x50(%ebp)
   121e1:	ff 75 b4             	pushl  -0x4c(%ebp)
   121e4:	ff 75 f4             	pushl  -0xc(%ebp)
   121e7:	51                   	push   %ecx
   121e8:	50                   	push   %eax
   121e9:	e8 4c f8 ff ff       	call   11a3a <filterScanline>
   121ee:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   121f1:	83 ec 04             	sub    $0x4,%esp
   121f4:	68 00 04 00 00       	push   $0x400
   121f9:	6a 00                	push   $0x0
   121fb:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   12201:	50                   	push   %eax
   12202:	e8 0e 17 ff ff       	call   3915 <lodepng_memset>
   12207:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   1220a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12211:	eb 2a                	jmp    1223d <filter+0x3f9>
   12213:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12216:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   1221d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12220:	01 d0                	add    %edx,%eax
   12222:	0f b6 00             	movzbl (%eax),%eax
   12225:	0f b6 c0             	movzbl %al,%eax
   12228:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   1222f:	83 c2 01             	add    $0x1,%edx
   12232:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   12239:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1223d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12240:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12243:	75 ce                	jne    12213 <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   12245:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12248:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   1224f:	8d 50 01             	lea    0x1(%eax),%edx
   12252:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12255:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   1225c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12263:	eb 1d                	jmp    12282 <filter+0x43e>
            sum += ilog2i(count[x]);
   12265:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12268:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   1226f:	83 ec 0c             	sub    $0xc,%esp
   12272:	50                   	push   %eax
   12273:	e8 80 fb ff ff       	call   11df8 <ilog2i>
   12278:	83 c4 10             	add    $0x10,%esp
   1227b:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   1227e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12282:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   12289:	75 da                	jne    12265 <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   1228b:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   1228f:	74 08                	je     12299 <filter+0x455>
   12291:	8b 45 c8             	mov    -0x38(%ebp),%eax
   12294:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   12297:	7e 0c                	jle    122a5 <filter+0x461>
            bestType = type;
   12299:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1229c:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   1229f:	8b 45 c8             	mov    -0x38(%ebp),%eax
   122a2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   122a5:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   122a9:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   122ad:	0f 85 02 ff ff ff    	jne    121b5 <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   122b3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   122b6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   122ba:	89 c2                	mov    %eax,%edx
   122bc:	8b 45 0c             	mov    0xc(%ebp),%eax
   122bf:	01 d0                	add    %edx,%eax
   122c1:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   122c4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   122c7:	83 c0 01             	add    $0x1,%eax
   122ca:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   122ce:	89 c2                	mov    %eax,%edx
   122d0:	8b 45 08             	mov    0x8(%ebp),%eax
   122d3:	01 d0                	add    %edx,%eax
   122d5:	8b 55 cc             	mov    -0x34(%ebp),%edx
   122d8:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   122da:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   122e1:	eb 31                	jmp    12314 <filter+0x4d0>
   122e3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   122e6:	83 c0 01             	add    $0x1,%eax
   122e9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   122ed:	89 c2                	mov    %eax,%edx
   122ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
   122f2:	01 d0                	add    %edx,%eax
   122f4:	8d 50 01             	lea    0x1(%eax),%edx
   122f7:	8b 45 08             	mov    0x8(%ebp),%eax
   122fa:	01 c2                	add    %eax,%edx
   122fc:	8b 45 cc             	mov    -0x34(%ebp),%eax
   122ff:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   12306:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12309:	01 c8                	add    %ecx,%eax
   1230b:	0f b6 00             	movzbl (%eax),%eax
   1230e:	88 02                	mov    %al,(%edx)
   12310:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12314:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12317:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1231a:	75 c7                	jne    122e3 <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   1231c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12320:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12323:	3b 45 14             	cmp    0x14(%ebp),%eax
   12326:	0f 85 7d fe ff ff    	jne    121a9 <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   1232c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   12333:	eb 1a                	jmp    1234f <filter+0x50b>
   12335:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12338:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   1233f:	83 ec 0c             	sub    $0xc,%esp
   12342:	50                   	push   %eax
   12343:	e8 7d 15 ff ff       	call   38c5 <lodepng_free>
   12348:	83 c4 10             	add    $0x10,%esp
   1234b:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   1234f:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   12353:	75 e0                	jne    12335 <filter+0x4f1>
   12355:	e9 c9 02 00 00       	jmp    12623 <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   1235a:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   1235e:	0f 85 89 00 00 00    	jne    123ed <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   12364:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1236b:	eb 73                	jmp    123e0 <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   1236d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12370:	83 c0 01             	add    $0x1,%eax
   12373:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12377:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   1237a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1237d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12381:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   12384:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12387:	8b 50 30             	mov    0x30(%eax),%edx
   1238a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1238d:	01 d0                	add    %edx,%eax
   1238f:	0f b6 00             	movzbl (%eax),%eax
   12392:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   12395:	8b 55 a8             	mov    -0x58(%ebp),%edx
   12398:	8b 45 08             	mov    0x8(%ebp),%eax
   1239b:	01 c2                	add    %eax,%edx
   1239d:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   123a1:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   123a3:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   123a7:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   123aa:	8b 55 0c             	mov    0xc(%ebp),%edx
   123ad:	01 d1                	add    %edx,%ecx
   123af:	8b 55 a8             	mov    -0x58(%ebp),%edx
   123b2:	8d 5a 01             	lea    0x1(%edx),%ebx
   123b5:	8b 55 08             	mov    0x8(%ebp),%edx
   123b8:	01 da                	add    %ebx,%edx
   123ba:	83 ec 08             	sub    $0x8,%esp
   123bd:	50                   	push   %eax
   123be:	ff 75 b0             	pushl  -0x50(%ebp)
   123c1:	ff 75 b4             	pushl  -0x4c(%ebp)
   123c4:	ff 75 f4             	pushl  -0xc(%ebp)
   123c7:	51                   	push   %ecx
   123c8:	52                   	push   %edx
   123c9:	e8 6c f6 ff ff       	call   11a3a <filterScanline>
   123ce:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   123d1:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   123d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   123d7:	01 d0                	add    %edx,%eax
   123d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   123dc:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   123e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   123e3:	3b 45 14             	cmp    0x14(%ebp),%eax
   123e6:	75 85                	jne    1236d <filter+0x529>
   123e8:	e9 36 02 00 00       	jmp    12623 <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   123ed:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   123f1:	0f 85 25 02 00 00    	jne    1261c <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   123f7:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   123fe:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12405:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   1240c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1240f:	83 ec 04             	sub    $0x4,%esp
   12412:	6a 24                	push   $0x24
   12414:	50                   	push   %eax
   12415:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   1241b:	50                   	push   %eax
   1241c:	e8 c1 14 ff ff       	call   38e2 <lodepng_memcpy>
   12421:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   12424:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   1242b:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   1242e:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   12435:	00 00 00 
    zlibsettings.custom_deflate = 0;
   12438:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   1243f:	00 00 00 
    for(type = 0; type != 5; ++type) {
   12442:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12449:	eb 33                	jmp    1247e <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   1244b:	83 ec 0c             	sub    $0xc,%esp
   1244e:	ff 75 b4             	pushl  -0x4c(%ebp)
   12451:	e8 4e 14 ff ff       	call   38a4 <lodepng_malloc>
   12456:	83 c4 10             	add    $0x10,%esp
   12459:	89 c2                	mov    %eax,%edx
   1245b:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1245e:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   12465:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12468:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   1246f:	85 c0                	test   %eax,%eax
   12471:	75 07                	jne    1247a <filter+0x636>
   12473:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   1247a:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   1247e:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12482:	75 c7                	jne    1244b <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   12484:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12488:	0f 85 63 01 00 00    	jne    125f1 <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   1248e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12495:	e9 4b 01 00 00       	jmp    125e5 <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   1249a:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   124a1:	e9 c8 00 00 00       	jmp    1256e <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   124a6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   124a9:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   124ac:	8b 45 c0             	mov    -0x40(%ebp),%eax
   124af:	0f b6 d0             	movzbl %al,%edx
   124b2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   124b5:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   124b9:	89 c1                	mov    %eax,%ecx
   124bb:	8b 45 0c             	mov    0xc(%ebp),%eax
   124be:	01 c1                	add    %eax,%ecx
   124c0:	8b 45 c0             	mov    -0x40(%ebp),%eax
   124c3:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   124ca:	83 ec 08             	sub    $0x8,%esp
   124cd:	52                   	push   %edx
   124ce:	ff 75 b0             	pushl  -0x50(%ebp)
   124d1:	ff 75 b4             	pushl  -0x4c(%ebp)
   124d4:	ff 75 f4             	pushl  -0xc(%ebp)
   124d7:	51                   	push   %ecx
   124d8:	50                   	push   %eax
   124d9:	e8 5c f5 ff ff       	call   11a3a <filterScanline>
   124de:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   124e1:	8b 45 c0             	mov    -0x40(%ebp),%eax
   124e4:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   124eb:	00 00 00 00 
          dummy = 0;
   124ef:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   124f6:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   124f9:	8b 55 ac             	mov    -0x54(%ebp),%edx
   124fc:	8b 45 c0             	mov    -0x40(%ebp),%eax
   124ff:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12506:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   1250c:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   1250f:	c1 e3 02             	shl    $0x2,%ebx
   12512:	01 cb                	add    %ecx,%ebx
   12514:	83 ec 0c             	sub    $0xc,%esp
   12517:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   1251d:	51                   	push   %ecx
   1251e:	52                   	push   %edx
   1251f:	50                   	push   %eax
   12520:	53                   	push   %ebx
   12521:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   12527:	50                   	push   %eax
   12528:	e8 87 60 ff ff       	call   85b4 <zlib_compress>
   1252d:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   12530:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   12536:	83 ec 0c             	sub    $0xc,%esp
   12539:	50                   	push   %eax
   1253a:	e8 86 13 ff ff       	call   38c5 <lodepng_free>
   1253f:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   12542:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   12546:	74 0f                	je     12557 <filter+0x713>
   12548:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1254b:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   12552:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   12555:	7d 13                	jge    1256a <filter+0x726>
            bestType = type;
   12557:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1255a:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   1255d:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12560:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   12567:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   1256a:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   1256e:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12572:	0f 85 2e ff ff ff    	jne    124a6 <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   12578:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1257b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1257f:	89 c2                	mov    %eax,%edx
   12581:	8b 45 0c             	mov    0xc(%ebp),%eax
   12584:	01 d0                	add    %edx,%eax
   12586:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   12589:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1258c:	83 c0 01             	add    $0x1,%eax
   1258f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12593:	89 c2                	mov    %eax,%edx
   12595:	8b 45 08             	mov    0x8(%ebp),%eax
   12598:	01 d0                	add    %edx,%eax
   1259a:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1259d:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   1259f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   125a6:	eb 31                	jmp    125d9 <filter+0x795>
   125a8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   125ab:	83 c0 01             	add    $0x1,%eax
   125ae:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   125b2:	89 c2                	mov    %eax,%edx
   125b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   125b7:	01 d0                	add    %edx,%eax
   125b9:	8d 50 01             	lea    0x1(%eax),%edx
   125bc:	8b 45 08             	mov    0x8(%ebp),%eax
   125bf:	01 c2                	add    %eax,%edx
   125c1:	8b 45 bc             	mov    -0x44(%ebp),%eax
   125c4:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   125cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   125ce:	01 c8                	add    %ecx,%eax
   125d0:	0f b6 00             	movzbl (%eax),%eax
   125d3:	88 02                	mov    %al,(%edx)
   125d5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   125d9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   125dc:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   125df:	75 c7                	jne    125a8 <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   125e1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   125e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   125e8:	3b 45 14             	cmp    0x14(%ebp),%eax
   125eb:	0f 85 a9 fe ff ff    	jne    1249a <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   125f1:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   125f8:	eb 1a                	jmp    12614 <filter+0x7d0>
   125fa:	8b 45 c0             	mov    -0x40(%ebp),%eax
   125fd:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12604:	83 ec 0c             	sub    $0xc,%esp
   12607:	50                   	push   %eax
   12608:	e8 b8 12 ff ff       	call   38c5 <lodepng_free>
   1260d:	83 c4 10             	add    $0x10,%esp
   12610:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12614:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12618:	75 e0                	jne    125fa <filter+0x7b6>
   1261a:	eb 07                	jmp    12623 <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   1261c:	b8 58 00 00 00       	mov    $0x58,%eax
   12621:	eb 03                	jmp    12626 <filter+0x7e2>

  return error;
   12623:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   12626:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12629:	c9                   	leave  
   1262a:	c3                   	ret    

0001262b <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   1262b:	55                   	push   %ebp
   1262c:	89 e5                	mov    %esp,%ebp
   1262e:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   12631:	8b 45 10             	mov    0x10(%ebp),%eax
   12634:	2b 45 14             	sub    0x14(%ebp),%eax
   12637:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   1263a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12641:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   12648:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1264f:	eb 65                	jmp    126b6 <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   12651:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12658:	eb 2a                	jmp    12684 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   1265a:	ff 75 0c             	pushl  0xc(%ebp)
   1265d:	8d 45 e8             	lea    -0x18(%ebp),%eax
   12660:	50                   	push   %eax
   12661:	e8 9d 60 ff ff       	call   8703 <readBitFromReversedStream>
   12666:	83 c4 08             	add    $0x8,%esp
   12669:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   1266c:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   12670:	50                   	push   %eax
   12671:	ff 75 08             	pushl  0x8(%ebp)
   12674:	8d 45 ec             	lea    -0x14(%ebp),%eax
   12677:	50                   	push   %eax
   12678:	e8 08 61 ff ff       	call   8785 <setBitOfReversedStream>
   1267d:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   12680:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12684:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12687:	3b 45 14             	cmp    0x14(%ebp),%eax
   1268a:	7c ce                	jl     1265a <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   1268c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12693:	eb 15                	jmp    126aa <addPaddingBits+0x7f>
   12695:	6a 00                	push   $0x0
   12697:	ff 75 08             	pushl  0x8(%ebp)
   1269a:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1269d:	50                   	push   %eax
   1269e:	e8 e2 60 ff ff       	call   8785 <setBitOfReversedStream>
   126a3:	83 c4 0c             	add    $0xc,%esp
   126a6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   126aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
   126ad:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   126b0:	75 e3                	jne    12695 <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   126b2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   126b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   126b9:	3b 45 18             	cmp    0x18(%ebp),%eax
   126bc:	75 93                	jne    12651 <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   126be:	90                   	nop
   126bf:	c9                   	leave  
   126c0:	c3                   	ret    

000126c1 <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   126c1:	55                   	push   %ebp
   126c2:	89 e5                	mov    %esp,%ebp
   126c4:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   126ca:	ff 75 18             	pushl  0x18(%ebp)
   126cd:	ff 75 14             	pushl  0x14(%ebp)
   126d0:	ff 75 10             	pushl  0x10(%ebp)
   126d3:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   126d9:	50                   	push   %eax
   126da:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   126e0:	50                   	push   %eax
   126e1:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   126e7:	50                   	push   %eax
   126e8:	8d 45 94             	lea    -0x6c(%ebp),%eax
   126eb:	50                   	push   %eax
   126ec:	8d 45 b0             	lea    -0x50(%ebp),%eax
   126ef:	50                   	push   %eax
   126f0:	e8 fc ae ff ff       	call   d5f1 <Adam7_getpassvalues>
   126f5:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   126f8:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   126fc:	0f 86 0a 01 00 00    	jbe    1280c <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   12702:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12709:	e9 ef 00 00 00       	jmp    127fd <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   1270e:	8b 45 18             	mov    0x18(%ebp),%eax
   12711:	c1 e8 03             	shr    $0x3,%eax
   12714:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   12717:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1271e:	e9 c6 00 00 00       	jmp    127e9 <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   12723:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1272a:	e9 a6 00 00 00       	jmp    127d5 <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   1272f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12732:	8b 14 85 98 a5 01 00 	mov    0x1a598(,%eax,4),%edx
   12739:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1273c:	8b 04 85 d0 a5 01 00 	mov    0x1a5d0(,%eax,4),%eax
   12743:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   12747:	01 d0                	add    %edx,%eax
   12749:	0f af 45 10          	imul   0x10(%ebp),%eax
   1274d:	89 c2                	mov    %eax,%edx
   1274f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12752:	8b 04 85 b4 a5 01 00 	mov    0x1a5b4(,%eax,4),%eax
   12759:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   1275d:	01 c2                	add    %eax,%edx
   1275f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12762:	8b 04 85 7c a5 01 00 	mov    0x1a57c(,%eax,4),%eax
   12769:	01 c2                	add    %eax,%edx
   1276b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1276e:	0f af c2             	imul   %edx,%eax
   12771:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   12774:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12777:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   1277e:	89 c1                	mov    %eax,%ecx
   12780:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12783:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12787:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   1278b:	89 c2                	mov    %eax,%edx
   1278d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12790:	01 c2                	add    %eax,%edx
   12792:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12795:	0f af c2             	imul   %edx,%eax
   12798:	01 c8                	add    %ecx,%eax
   1279a:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   1279d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   127a4:	eb 23                	jmp    127c9 <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   127a6:	8b 55 d8             	mov    -0x28(%ebp),%edx
   127a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   127ac:	01 c2                	add    %eax,%edx
   127ae:	8b 45 08             	mov    0x8(%ebp),%eax
   127b1:	01 c2                	add    %eax,%edx
   127b3:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   127b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   127b9:	01 c1                	add    %eax,%ecx
   127bb:	8b 45 0c             	mov    0xc(%ebp),%eax
   127be:	01 c8                	add    %ecx,%eax
   127c0:	0f b6 00             	movzbl (%eax),%eax
   127c3:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   127c5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   127c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   127cc:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   127cf:	72 d5                	jb     127a6 <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   127d1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   127d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   127d8:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   127dc:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   127df:	0f 87 4a ff ff ff    	ja     1272f <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   127e5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   127e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   127ec:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   127f0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   127f3:	0f 87 2a ff ff ff    	ja     12723 <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   127f9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   127fd:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12801:	0f 85 07 ff ff ff    	jne    1270e <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12807:	e9 22 01 00 00       	jmp    1292e <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1280c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12813:	e9 0c 01 00 00       	jmp    12924 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   12818:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1281b:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1281f:	0f af 45 18          	imul   0x18(%ebp),%eax
   12823:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   12826:	8b 45 18             	mov    0x18(%ebp),%eax
   12829:	0f af 45 10          	imul   0x10(%ebp),%eax
   1282d:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   12830:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   12837:	e9 d4 00 00 00       	jmp    12910 <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   1283c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12843:	e9 b4 00 00 00       	jmp    128fc <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   12848:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1284b:	8b 14 85 98 a5 01 00 	mov    0x1a598(,%eax,4),%edx
   12852:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12855:	8b 04 85 d0 a5 01 00 	mov    0x1a5d0(,%eax,4),%eax
   1285c:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   12860:	01 d0                	add    %edx,%eax
   12862:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   12866:	89 c2                	mov    %eax,%edx
   12868:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1286b:	8b 0c 85 7c a5 01 00 	mov    0x1a57c(,%eax,4),%ecx
   12872:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12875:	8b 04 85 b4 a5 01 00 	mov    0x1a5b4(,%eax,4),%eax
   1287c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12880:	01 c8                	add    %ecx,%eax
   12882:	0f af 45 18          	imul   0x18(%ebp),%eax
   12886:	01 d0                	add    %edx,%eax
   12888:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   1288e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12891:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   12898:	c1 e0 03             	shl    $0x3,%eax
   1289b:	89 c1                	mov    %eax,%ecx
   1289d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   128a0:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   128a4:	89 c2                	mov    %eax,%edx
   128a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   128a9:	0f af 45 18          	imul   0x18(%ebp),%eax
   128ad:	01 d0                	add    %edx,%eax
   128af:	01 c8                	add    %ecx,%eax
   128b1:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   128b7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   128be:	eb 30                	jmp    128f0 <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   128c0:	ff 75 0c             	pushl  0xc(%ebp)
   128c3:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   128c9:	50                   	push   %eax
   128ca:	e8 34 5e ff ff       	call   8703 <readBitFromReversedStream>
   128cf:	83 c4 08             	add    $0x8,%esp
   128d2:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   128d5:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   128d9:	50                   	push   %eax
   128da:	ff 75 08             	pushl  0x8(%ebp)
   128dd:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   128e3:	50                   	push   %eax
   128e4:	e8 9c 5e ff ff       	call   8785 <setBitOfReversedStream>
   128e9:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   128ec:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   128f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   128f3:	3b 45 18             	cmp    0x18(%ebp),%eax
   128f6:	72 c8                	jb     128c0 <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   128f8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   128fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
   128ff:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12903:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   12906:	0f 87 3c ff ff ff    	ja     12848 <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   1290c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   12910:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12913:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12917:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1291a:	0f 87 1c ff ff ff    	ja     1283c <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   12920:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12924:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12928:	0f 85 ea fe ff ff    	jne    12818 <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   1292e:	90                   	nop
   1292f:	c9                   	leave  
   12930:	c3                   	ret    

00012931 <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   12931:	55                   	push   %ebp
   12932:	89 e5                	mov    %esp,%ebp
   12934:	57                   	push   %edi
   12935:	56                   	push   %esi
   12936:	53                   	push   %ebx
   12937:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   1293d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12940:	83 c0 0c             	add    $0xc,%eax
   12943:	50                   	push   %eax
   12944:	e8 77 6a ff ff       	call   93c0 <lodepng_get_bpp>
   12949:	83 c4 04             	add    $0x4,%esp
   1294c:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   1294f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   12956:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12959:	8b 40 08             	mov    0x8(%eax),%eax
   1295c:	85 c0                	test   %eax,%eax
   1295e:	0f 85 49 01 00 00    	jne    12aad <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   12964:	8b 45 14             	mov    0x14(%ebp),%eax
   12967:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1296b:	83 c0 07             	add    $0x7,%eax
   1296e:	c1 e8 03             	shr    $0x3,%eax
   12971:	83 c0 01             	add    $0x1,%eax
   12974:	0f af 45 18          	imul   0x18(%ebp),%eax
   12978:	89 c2                	mov    %eax,%edx
   1297a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1297d:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   1297f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12982:	8b 00                	mov    (%eax),%eax
   12984:	83 ec 0c             	sub    $0xc,%esp
   12987:	50                   	push   %eax
   12988:	e8 17 0f ff ff       	call   38a4 <lodepng_malloc>
   1298d:	83 c4 10             	add    $0x10,%esp
   12990:	89 c2                	mov    %eax,%edx
   12992:	8b 45 08             	mov    0x8(%ebp),%eax
   12995:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   12997:	8b 45 08             	mov    0x8(%ebp),%eax
   1299a:	8b 00                	mov    (%eax),%eax
   1299c:	85 c0                	test   %eax,%eax
   1299e:	75 10                	jne    129b0 <preProcessScanlines+0x7f>
   129a0:	8b 45 0c             	mov    0xc(%ebp),%eax
   129a3:	8b 00                	mov    (%eax),%eax
   129a5:	85 c0                	test   %eax,%eax
   129a7:	74 07                	je     129b0 <preProcessScanlines+0x7f>
   129a9:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   129b0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   129b4:	0f 85 fb 02 00 00    	jne    12cb5 <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   129ba:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   129be:	0f 87 bd 00 00 00    	ja     12a81 <preProcessScanlines+0x150>
   129c4:	8b 45 14             	mov    0x14(%ebp),%eax
   129c7:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   129cb:	89 c2                	mov    %eax,%edx
   129cd:	8b 45 14             	mov    0x14(%ebp),%eax
   129d0:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   129d4:	83 c0 07             	add    $0x7,%eax
   129d7:	c1 e8 03             	shr    $0x3,%eax
   129da:	c1 e0 03             	shl    $0x3,%eax
   129dd:	39 c2                	cmp    %eax,%edx
   129df:	0f 84 9c 00 00 00    	je     12a81 <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   129e5:	8b 45 14             	mov    0x14(%ebp),%eax
   129e8:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   129ec:	83 c0 07             	add    $0x7,%eax
   129ef:	c1 e8 03             	shr    $0x3,%eax
   129f2:	0f af 45 18          	imul   0x18(%ebp),%eax
   129f6:	83 ec 0c             	sub    $0xc,%esp
   129f9:	50                   	push   %eax
   129fa:	e8 a5 0e ff ff       	call   38a4 <lodepng_malloc>
   129ff:	83 c4 10             	add    $0x10,%esp
   12a02:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   12a05:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12a09:	75 07                	jne    12a12 <preProcessScanlines+0xe1>
   12a0b:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   12a12:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12a16:	75 56                	jne    12a6e <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   12a18:	8b 45 14             	mov    0x14(%ebp),%eax
   12a1b:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12a1f:	89 c2                	mov    %eax,%edx
   12a21:	8b 45 14             	mov    0x14(%ebp),%eax
   12a24:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12a28:	83 c0 07             	add    $0x7,%eax
   12a2b:	c1 e8 03             	shr    $0x3,%eax
   12a2e:	c1 e0 03             	shl    $0x3,%eax
   12a31:	83 ec 0c             	sub    $0xc,%esp
   12a34:	ff 75 18             	pushl  0x18(%ebp)
   12a37:	52                   	push   %edx
   12a38:	50                   	push   %eax
   12a39:	ff 75 10             	pushl  0x10(%ebp)
   12a3c:	ff 75 d8             	pushl  -0x28(%ebp)
   12a3f:	e8 e7 fb ff ff       	call   1262b <addPaddingBits>
   12a44:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   12a47:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a4a:	8d 50 0c             	lea    0xc(%eax),%edx
   12a4d:	8b 45 08             	mov    0x8(%ebp),%eax
   12a50:	8b 00                	mov    (%eax),%eax
   12a52:	83 ec 08             	sub    $0x8,%esp
   12a55:	ff 75 20             	pushl  0x20(%ebp)
   12a58:	52                   	push   %edx
   12a59:	ff 75 18             	pushl  0x18(%ebp)
   12a5c:	ff 75 14             	pushl  0x14(%ebp)
   12a5f:	ff 75 d8             	pushl  -0x28(%ebp)
   12a62:	50                   	push   %eax
   12a63:	e8 dc f3 ff ff       	call   11e44 <filter>
   12a68:	83 c4 20             	add    $0x20,%esp
   12a6b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   12a6e:	83 ec 0c             	sub    $0xc,%esp
   12a71:	ff 75 d8             	pushl  -0x28(%ebp)
   12a74:	e8 4c 0e ff ff       	call   38c5 <lodepng_free>
   12a79:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   12a7c:	e9 34 02 00 00       	jmp    12cb5 <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   12a81:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a84:	8d 50 0c             	lea    0xc(%eax),%edx
   12a87:	8b 45 08             	mov    0x8(%ebp),%eax
   12a8a:	8b 00                	mov    (%eax),%eax
   12a8c:	83 ec 08             	sub    $0x8,%esp
   12a8f:	ff 75 20             	pushl  0x20(%ebp)
   12a92:	52                   	push   %edx
   12a93:	ff 75 18             	pushl  0x18(%ebp)
   12a96:	ff 75 14             	pushl  0x14(%ebp)
   12a99:	ff 75 10             	pushl  0x10(%ebp)
   12a9c:	50                   	push   %eax
   12a9d:	e8 a2 f3 ff ff       	call   11e44 <filter>
   12aa2:	83 c4 20             	add    $0x20,%esp
   12aa5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   12aa8:	e9 08 02 00 00       	jmp    12cb5 <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   12aad:	ff 75 dc             	pushl  -0x24(%ebp)
   12ab0:	ff 75 18             	pushl  0x18(%ebp)
   12ab3:	ff 75 14             	pushl  0x14(%ebp)
   12ab6:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   12abc:	50                   	push   %eax
   12abd:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   12ac3:	50                   	push   %eax
   12ac4:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   12aca:	50                   	push   %eax
   12acb:	8d 45 98             	lea    -0x68(%ebp),%eax
   12ace:	50                   	push   %eax
   12acf:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   12ad2:	50                   	push   %eax
   12ad3:	e8 19 ab ff ff       	call   d5f1 <Adam7_getpassvalues>
   12ad8:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   12adb:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   12ae1:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ae4:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12ae6:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ae9:	8b 00                	mov    (%eax),%eax
   12aeb:	83 ec 0c             	sub    $0xc,%esp
   12aee:	50                   	push   %eax
   12aef:	e8 b0 0d ff ff       	call   38a4 <lodepng_malloc>
   12af4:	83 c4 10             	add    $0x10,%esp
   12af7:	89 c2                	mov    %eax,%edx
   12af9:	8b 45 08             	mov    0x8(%ebp),%eax
   12afc:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   12afe:	8b 45 08             	mov    0x8(%ebp),%eax
   12b01:	8b 00                	mov    (%eax),%eax
   12b03:	85 c0                	test   %eax,%eax
   12b05:	75 07                	jne    12b0e <preProcessScanlines+0x1dd>
   12b07:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   12b0e:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12b11:	83 ec 0c             	sub    $0xc,%esp
   12b14:	50                   	push   %eax
   12b15:	e8 8a 0d ff ff       	call   38a4 <lodepng_malloc>
   12b1a:	83 c4 10             	add    $0x10,%esp
   12b1d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   12b20:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12b24:	75 0e                	jne    12b34 <preProcessScanlines+0x203>
   12b26:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12b29:	85 c0                	test   %eax,%eax
   12b2b:	74 07                	je     12b34 <preProcessScanlines+0x203>
   12b2d:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   12b34:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12b38:	0f 85 69 01 00 00    	jne    12ca7 <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   12b3e:	83 ec 0c             	sub    $0xc,%esp
   12b41:	ff 75 dc             	pushl  -0x24(%ebp)
   12b44:	ff 75 18             	pushl  0x18(%ebp)
   12b47:	ff 75 14             	pushl  0x14(%ebp)
   12b4a:	ff 75 10             	pushl  0x10(%ebp)
   12b4d:	ff 75 d4             	pushl  -0x2c(%ebp)
   12b50:	e8 6c fb ff ff       	call   126c1 <Adam7_interlace>
   12b55:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   12b58:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   12b5f:	e9 36 01 00 00       	jmp    12c9a <preProcessScanlines+0x369>
        if(bpp < 8) {
   12b64:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   12b68:	0f 87 d6 00 00 00    	ja     12c44 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   12b6e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12b71:	83 c0 01             	add    $0x1,%eax
   12b74:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   12b7b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12b7e:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   12b85:	29 c2                	sub    %eax,%edx
   12b87:	89 d0                	mov    %edx,%eax
   12b89:	83 ec 0c             	sub    $0xc,%esp
   12b8c:	50                   	push   %eax
   12b8d:	e8 12 0d ff ff       	call   38a4 <lodepng_malloc>
   12b92:	83 c4 10             	add    $0x10,%esp
   12b95:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   12b98:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   12b9c:	75 0c                	jne    12baa <preProcessScanlines+0x279>
   12b9e:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   12ba5:	e9 fd 00 00 00       	jmp    12ca7 <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   12baa:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12bad:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   12bb1:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12bb4:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12bb8:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   12bbc:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   12bbe:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12bc1:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12bc5:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   12bc9:	83 c2 07             	add    $0x7,%edx
   12bcc:	c1 ea 03             	shr    $0x3,%edx
   12bcf:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   12bd2:	89 d1                	mov    %edx,%ecx
   12bd4:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12bd7:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   12bde:	89 d6                	mov    %edx,%esi
   12be0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   12be3:	01 f2                	add    %esi,%edx
   12be5:	83 ec 0c             	sub    $0xc,%esp
   12be8:	50                   	push   %eax
   12be9:	53                   	push   %ebx
   12bea:	51                   	push   %ecx
   12beb:	52                   	push   %edx
   12bec:	ff 75 d0             	pushl  -0x30(%ebp)
   12bef:	e8 37 fa ff ff       	call   1262b <addPaddingBits>
   12bf4:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   12bf7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bfa:	8d 58 0c             	lea    0xc(%eax),%ebx
   12bfd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12c00:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12c04:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12c07:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   12c0b:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12c0e:	8b 31                	mov    (%ecx),%esi
   12c10:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12c13:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12c1a:	01 f1                	add    %esi,%ecx
   12c1c:	83 ec 08             	sub    $0x8,%esp
   12c1f:	ff 75 20             	pushl  0x20(%ebp)
   12c22:	53                   	push   %ebx
   12c23:	52                   	push   %edx
   12c24:	50                   	push   %eax
   12c25:	ff 75 d0             	pushl  -0x30(%ebp)
   12c28:	51                   	push   %ecx
   12c29:	e8 16 f2 ff ff       	call   11e44 <filter>
   12c2e:	83 c4 20             	add    $0x20,%esp
   12c31:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   12c34:	83 ec 0c             	sub    $0xc,%esp
   12c37:	ff 75 d0             	pushl  -0x30(%ebp)
   12c3a:	e8 86 0c ff ff       	call   38c5 <lodepng_free>
   12c3f:	83 c4 10             	add    $0x10,%esp
   12c42:	eb 4c                	jmp    12c90 <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   12c44:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c47:	8d 70 0c             	lea    0xc(%eax),%esi
   12c4a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12c4d:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12c51:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12c54:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   12c58:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12c5b:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   12c62:	89 cb                	mov    %ecx,%ebx
   12c64:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   12c67:	01 cb                	add    %ecx,%ebx
   12c69:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12c6c:	8b 39                	mov    (%ecx),%edi
   12c6e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12c71:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12c78:	01 f9                	add    %edi,%ecx
   12c7a:	83 ec 08             	sub    $0x8,%esp
   12c7d:	ff 75 20             	pushl  0x20(%ebp)
   12c80:	56                   	push   %esi
   12c81:	52                   	push   %edx
   12c82:	50                   	push   %eax
   12c83:	53                   	push   %ebx
   12c84:	51                   	push   %ecx
   12c85:	e8 ba f1 ff ff       	call   11e44 <filter>
   12c8a:	83 c4 20             	add    $0x20,%esp
   12c8d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12c90:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12c94:	75 10                	jne    12ca6 <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   12c96:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   12c9a:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   12c9e:	0f 85 c0 fe ff ff    	jne    12b64 <preProcessScanlines+0x233>
   12ca4:	eb 01                	jmp    12ca7 <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12ca6:	90                   	nop
      }
    }

    lodepng_free(adam7);
   12ca7:	83 ec 0c             	sub    $0xc,%esp
   12caa:	ff 75 d4             	pushl  -0x2c(%ebp)
   12cad:	e8 13 0c ff ff       	call   38c5 <lodepng_free>
   12cb2:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   12cb5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   12cb8:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12cbb:	5b                   	pop    %ebx
   12cbc:	5e                   	pop    %esi
   12cbd:	5f                   	pop    %edi
   12cbe:	5d                   	pop    %ebp
   12cbf:	c3                   	ret    

00012cc0 <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   12cc0:	55                   	push   %ebp
   12cc1:	89 e5                	mov    %esp,%ebp
   12cc3:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   12cc6:	8b 45 0c             	mov    0xc(%ebp),%eax
   12cc9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   12ccc:	eb 47                	jmp    12d15 <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   12cce:	8b 45 08             	mov    0x8(%ebp),%eax
   12cd1:	8d 50 04             	lea    0x4(%eax),%edx
   12cd4:	8b 45 08             	mov    0x8(%ebp),%eax
   12cd7:	ff 75 fc             	pushl  -0x4(%ebp)
   12cda:	52                   	push   %edx
   12cdb:	50                   	push   %eax
   12cdc:	e8 73 5f ff ff       	call   8c54 <lodepng_chunk_append>
   12ce1:	83 c4 0c             	add    $0xc,%esp
   12ce4:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12ce7:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   12ceb:	74 05                	je     12cf2 <addUnknownChunks+0x32>
   12ced:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12cf0:	eb 37                	jmp    12d29 <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   12cf2:	8b 45 08             	mov    0x8(%ebp),%eax
   12cf5:	8b 50 04             	mov    0x4(%eax),%edx
   12cf8:	8b 45 08             	mov    0x8(%ebp),%eax
   12cfb:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   12cfe:	8b 55 10             	mov    0x10(%ebp),%edx
   12d01:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d04:	01 d0                	add    %edx,%eax
   12d06:	50                   	push   %eax
   12d07:	ff 75 fc             	pushl  -0x4(%ebp)
   12d0a:	e8 ff 5c ff ff       	call   8a0e <lodepng_chunk_next>
   12d0f:	83 c4 08             	add    $0x8,%esp
   12d12:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   12d15:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12d18:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d1b:	29 c2                	sub    %eax,%edx
   12d1d:	89 d0                	mov    %edx,%eax
   12d1f:	3b 45 10             	cmp    0x10(%ebp),%eax
   12d22:	7c aa                	jl     12cce <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   12d24:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12d29:	c9                   	leave  
   12d2a:	c3                   	ret    

00012d2b <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   12d2b:	55                   	push   %ebp
   12d2c:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   12d2e:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12d32:	77 07                	ja     12d3b <isGrayICCProfile+0x10>
   12d34:	b8 00 00 00 00       	mov    $0x0,%eax
   12d39:	eb 40                	jmp    12d7b <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   12d3b:	8b 45 08             	mov    0x8(%ebp),%eax
   12d3e:	83 c0 10             	add    $0x10,%eax
   12d41:	0f b6 00             	movzbl (%eax),%eax
   12d44:	3c 47                	cmp    $0x47,%al
   12d46:	75 2e                	jne    12d76 <isGrayICCProfile+0x4b>
   12d48:	8b 45 08             	mov    0x8(%ebp),%eax
   12d4b:	83 c0 11             	add    $0x11,%eax
   12d4e:	0f b6 00             	movzbl (%eax),%eax
   12d51:	3c 52                	cmp    $0x52,%al
   12d53:	75 21                	jne    12d76 <isGrayICCProfile+0x4b>
   12d55:	8b 45 08             	mov    0x8(%ebp),%eax
   12d58:	83 c0 12             	add    $0x12,%eax
   12d5b:	0f b6 00             	movzbl (%eax),%eax
   12d5e:	3c 41                	cmp    $0x41,%al
   12d60:	75 14                	jne    12d76 <isGrayICCProfile+0x4b>
   12d62:	8b 45 08             	mov    0x8(%ebp),%eax
   12d65:	83 c0 13             	add    $0x13,%eax
   12d68:	0f b6 00             	movzbl (%eax),%eax
   12d6b:	3c 59                	cmp    $0x59,%al
   12d6d:	75 07                	jne    12d76 <isGrayICCProfile+0x4b>
   12d6f:	b8 01 00 00 00       	mov    $0x1,%eax
   12d74:	eb 05                	jmp    12d7b <isGrayICCProfile+0x50>
   12d76:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12d7b:	5d                   	pop    %ebp
   12d7c:	c3                   	ret    

00012d7d <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   12d7d:	55                   	push   %ebp
   12d7e:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   12d80:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12d84:	77 07                	ja     12d8d <isRGBICCProfile+0x10>
   12d86:	b8 00 00 00 00       	mov    $0x0,%eax
   12d8b:	eb 40                	jmp    12dcd <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   12d8d:	8b 45 08             	mov    0x8(%ebp),%eax
   12d90:	83 c0 10             	add    $0x10,%eax
   12d93:	0f b6 00             	movzbl (%eax),%eax
   12d96:	3c 52                	cmp    $0x52,%al
   12d98:	75 2e                	jne    12dc8 <isRGBICCProfile+0x4b>
   12d9a:	8b 45 08             	mov    0x8(%ebp),%eax
   12d9d:	83 c0 11             	add    $0x11,%eax
   12da0:	0f b6 00             	movzbl (%eax),%eax
   12da3:	3c 47                	cmp    $0x47,%al
   12da5:	75 21                	jne    12dc8 <isRGBICCProfile+0x4b>
   12da7:	8b 45 08             	mov    0x8(%ebp),%eax
   12daa:	83 c0 12             	add    $0x12,%eax
   12dad:	0f b6 00             	movzbl (%eax),%eax
   12db0:	3c 42                	cmp    $0x42,%al
   12db2:	75 14                	jne    12dc8 <isRGBICCProfile+0x4b>
   12db4:	8b 45 08             	mov    0x8(%ebp),%eax
   12db7:	83 c0 13             	add    $0x13,%eax
   12dba:	0f b6 00             	movzbl (%eax),%eax
   12dbd:	3c 20                	cmp    $0x20,%al
   12dbf:	75 07                	jne    12dc8 <isRGBICCProfile+0x4b>
   12dc1:	b8 01 00 00 00       	mov    $0x1,%eax
   12dc6:	eb 05                	jmp    12dcd <isRGBICCProfile+0x50>
   12dc8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12dcd:	5d                   	pop    %ebp
   12dce:	c3                   	ret    

00012dcf <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   12dcf:	55                   	push   %ebp
   12dd0:	89 e5                	mov    %esp,%ebp
   12dd2:	57                   	push   %edi
   12dd3:	56                   	push   %esi
   12dd4:	53                   	push   %ebx
   12dd5:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   12ddb:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   12de2:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   12de9:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12dec:	6a 00                	push   $0x0
   12dee:	6a 00                	push   $0x0
   12df0:	50                   	push   %eax
   12df1:	e8 6f 0d ff ff       	call   3b65 <ucvector_init>
   12df6:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   12df9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dfc:	05 98 00 00 00       	add    $0x98,%eax
   12e01:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   12e04:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e0a:	50                   	push   %eax
   12e0b:	e8 3a 71 ff ff       	call   9f4a <lodepng_info_init>
   12e10:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   12e13:	8b 45 08             	mov    0x8(%ebp),%eax
   12e16:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   12e1c:	8b 45 0c             	mov    0xc(%ebp),%eax
   12e1f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   12e25:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e28:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   12e2f:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   12e32:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e35:	8b 40 0c             	mov    0xc(%eax),%eax
   12e38:	83 f8 03             	cmp    $0x3,%eax
   12e3b:	74 0a                	je     12e47 <lodepng_encode+0x78>
   12e3d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e40:	8b 40 6c             	mov    0x6c(%eax),%eax
   12e43:	85 c0                	test   %eax,%eax
   12e45:	74 29                	je     12e70 <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   12e47:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e4a:	8b 40 18             	mov    0x18(%eax),%eax
   12e4d:	85 c0                	test   %eax,%eax
   12e4f:	74 0d                	je     12e5e <lodepng_encode+0x8f>
   12e51:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e54:	8b 40 18             	mov    0x18(%eax),%eax
   12e57:	3d 00 01 00 00       	cmp    $0x100,%eax
   12e5c:	7e 12                	jle    12e70 <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   12e5e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e61:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   12e68:	00 00 00 
    goto cleanup;
   12e6b:	e9 78 0c 00 00       	jmp    13ae8 <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   12e70:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e73:	8b 40 38             	mov    0x38(%eax),%eax
   12e76:	83 f8 02             	cmp    $0x2,%eax
   12e79:	76 12                	jbe    12e8d <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   12e7b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e7e:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   12e85:	00 00 00 
    goto cleanup;
   12e88:	e9 5b 0c 00 00       	jmp    13ae8 <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   12e8d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e90:	8b 40 08             	mov    0x8(%eax),%eax
   12e93:	83 f8 01             	cmp    $0x1,%eax
   12e96:	76 12                	jbe    12eaa <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   12e98:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e9b:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   12ea2:	00 00 00 
    goto cleanup;
   12ea5:	e9 3e 0c 00 00       	jmp    13ae8 <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   12eaa:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ead:	8b 50 10             	mov    0x10(%eax),%edx
   12eb0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12eb3:	8b 40 0c             	mov    0xc(%eax),%eax
   12eb6:	52                   	push   %edx
   12eb7:	50                   	push   %eax
   12eb8:	e8 a4 5f ff ff       	call   8e61 <checkColorValidity>
   12ebd:	83 c4 08             	add    $0x8,%esp
   12ec0:	89 c2                	mov    %eax,%edx
   12ec2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ec5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12ecb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ece:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ed4:	85 c0                	test   %eax,%eax
   12ed6:	0f 85 c6 0b 00 00    	jne    13aa2 <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   12edc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12edf:	8b 50 7c             	mov    0x7c(%eax),%edx
   12ee2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ee5:	8b 40 78             	mov    0x78(%eax),%eax
   12ee8:	52                   	push   %edx
   12ee9:	50                   	push   %eax
   12eea:	e8 72 5f ff ff       	call   8e61 <checkColorValidity>
   12eef:	83 c4 08             	add    $0x8,%esp
   12ef2:	89 c2                	mov    %eax,%edx
   12ef4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ef7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12efd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f00:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f06:	85 c0                	test   %eax,%eax
   12f08:	0f 85 97 0b 00 00    	jne    13aa5 <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   12f0e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f11:	05 98 00 00 00       	add    $0x98,%eax
   12f16:	83 ec 08             	sub    $0x8,%esp
   12f19:	50                   	push   %eax
   12f1a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f20:	50                   	push   %eax
   12f21:	e8 58 71 ff ff       	call   a07e <lodepng_info_copy>
   12f26:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   12f29:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f2c:	8b 40 5c             	mov    0x5c(%eax),%eax
   12f2f:	85 c0                	test   %eax,%eax
   12f31:	0f 84 3c 02 00 00    	je     13173 <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   12f37:	83 ec 0c             	sub    $0xc,%esp
   12f3a:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12f40:	50                   	push   %eax
   12f41:	e8 5f 96 ff ff       	call   c5a5 <lodepng_color_stats_init>
   12f46:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12f49:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12f4c:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12f52:	85 c0                	test   %eax,%eax
   12f54:	74 2d                	je     12f83 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12f56:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12f59:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12f5f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12f62:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12f68:	83 ec 08             	sub    $0x8,%esp
   12f6b:	52                   	push   %edx
   12f6c:	50                   	push   %eax
   12f6d:	e8 b9 fd ff ff       	call   12d2b <isGrayICCProfile>
   12f72:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12f75:	85 c0                	test   %eax,%eax
   12f77:	74 0a                	je     12f83 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   12f79:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   12f80:	00 00 00 
    }
    if(info_png->iccp_defined &&
   12f83:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12f86:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12f8c:	85 c0                	test   %eax,%eax
   12f8e:	74 2d                	je     12fbd <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12f90:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12f93:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12f99:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12f9c:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12fa2:	83 ec 08             	sub    $0x8,%esp
   12fa5:	52                   	push   %edx
   12fa6:	50                   	push   %eax
   12fa7:	e8 d1 fd ff ff       	call   12d7d <isRGBICCProfile>
   12fac:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   12faf:	85 c0                	test   %eax,%eax
   12fb1:	74 0a                	je     12fbd <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   12fb3:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   12fba:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   12fbd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fc0:	83 c0 78             	add    $0x78,%eax
   12fc3:	83 ec 0c             	sub    $0xc,%esp
   12fc6:	50                   	push   %eax
   12fc7:	ff 75 18             	pushl  0x18(%ebp)
   12fca:	ff 75 14             	pushl  0x14(%ebp)
   12fcd:	ff 75 10             	pushl  0x10(%ebp)
   12fd0:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12fd6:	50                   	push   %eax
   12fd7:	e8 e0 96 ff ff       	call   c6bc <lodepng_compute_color_stats>
   12fdc:	83 c4 20             	add    $0x20,%esp
   12fdf:	89 c2                	mov    %eax,%edx
   12fe1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fe4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12fea:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fed:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ff3:	85 c0                	test   %eax,%eax
   12ff5:	0f 85 ad 0a 00 00    	jne    13aa8 <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   12ffb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ffe:	8b 40 2c             	mov    0x2c(%eax),%eax
   13001:	85 c0                	test   %eax,%eax
   13003:	0f 84 be 00 00 00    	je     130c7 <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   13009:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   13010:	00 00 00 
   13013:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   1301a:	00 00 00 
   1301d:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   13024:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   13027:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   1302d:	83 ec 04             	sub    $0x4,%esp
   13030:	6a 10                	push   $0x10
   13032:	6a 02                	push   $0x2
   13034:	50                   	push   %eax
   13035:	e8 15 61 ff ff       	call   914f <lodepng_color_mode_make>
   1303a:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   1303d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13040:	8d 58 0c             	lea    0xc(%eax),%ebx
   13043:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13046:	8b 48 38             	mov    0x38(%eax),%ecx
   13049:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1304c:	8b 50 34             	mov    0x34(%eax),%edx
   1304f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13052:	8b 40 30             	mov    0x30(%eax),%eax
   13055:	53                   	push   %ebx
   13056:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   1305c:	53                   	push   %ebx
   1305d:	51                   	push   %ecx
   1305e:	52                   	push   %edx
   1305f:	50                   	push   %eax
   13060:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   13066:	50                   	push   %eax
   13067:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   1306d:	50                   	push   %eax
   1306e:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   13074:	50                   	push   %eax
   13075:	e8 8a 92 ff ff       	call   c304 <lodepng_convert_rgb>
   1307a:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   1307d:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   13083:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   13089:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   1308f:	83 ec 0c             	sub    $0xc,%esp
   13092:	68 ff ff 00 00       	push   $0xffff
   13097:	51                   	push   %ecx
   13098:	52                   	push   %edx
   13099:	50                   	push   %eax
   1309a:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   130a0:	50                   	push   %eax
   130a1:	e8 26 a1 ff ff       	call   d1cc <lodepng_color_stats_add>
   130a6:	83 c4 20             	add    $0x20,%esp
   130a9:	89 c2                	mov    %eax,%edx
   130ab:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130ae:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   130b4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130b7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130bd:	85 c0                	test   %eax,%eax
   130bf:	74 06                	je     130c7 <lodepng_encode+0x2f8>
   130c1:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   130c2:	e9 e1 09 00 00       	jmp    13aa8 <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   130c7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130ca:	8d 50 78             	lea    0x78(%eax),%edx
   130cd:	83 ec 04             	sub    $0x4,%esp
   130d0:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   130d6:	50                   	push   %eax
   130d7:	52                   	push   %edx
   130d8:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130de:	83 c0 0c             	add    $0xc,%eax
   130e1:	50                   	push   %eax
   130e2:	e8 79 a1 ff ff       	call   d260 <auto_choose_color>
   130e7:	83 c4 10             	add    $0x10,%esp
   130ea:	89 c2                	mov    %eax,%edx
   130ec:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130ef:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   130f5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130f8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130fe:	85 c0                	test   %eax,%eax
   13100:	0f 85 a5 09 00 00    	jne    13aab <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   13106:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13109:	8b 40 2c             	mov    0x2c(%eax),%eax
   1310c:	85 c0                	test   %eax,%eax
   1310e:	74 63                	je     13173 <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   13110:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13113:	8d 58 0c             	lea    0xc(%eax),%ebx
   13116:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13119:	8b 48 38             	mov    0x38(%eax),%ecx
   1311c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1311f:	8b 50 34             	mov    0x34(%eax),%edx
   13122:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13125:	8b 40 30             	mov    0x30(%eax),%eax
   13128:	53                   	push   %ebx
   13129:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   1312f:	83 c3 0c             	add    $0xc,%ebx
   13132:	53                   	push   %ebx
   13133:	51                   	push   %ecx
   13134:	52                   	push   %edx
   13135:	50                   	push   %eax
   13136:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1313c:	83 c0 38             	add    $0x38,%eax
   1313f:	50                   	push   %eax
   13140:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13146:	83 c0 34             	add    $0x34,%eax
   13149:	50                   	push   %eax
   1314a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13150:	83 c0 30             	add    $0x30,%eax
   13153:	50                   	push   %eax
   13154:	e8 ab 91 ff ff       	call   c304 <lodepng_convert_rgb>
   13159:	83 c4 20             	add    $0x20,%esp
   1315c:	85 c0                	test   %eax,%eax
   1315e:	74 13                	je     13173 <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   13160:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13163:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   1316a:	00 00 00 
        goto cleanup;
   1316d:	90                   	nop
   1316e:	e9 75 09 00 00       	jmp    13ae8 <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   13173:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13176:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   1317c:	85 c0                	test   %eax,%eax
   1317e:	0f 84 b2 00 00 00    	je     13236 <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   13184:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13187:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   1318d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13190:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   13196:	83 ec 08             	sub    $0x8,%esp
   13199:	52                   	push   %edx
   1319a:	50                   	push   %eax
   1319b:	e8 8b fb ff ff       	call   12d2b <isGrayICCProfile>
   131a0:	83 c4 10             	add    $0x10,%esp
   131a3:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   131a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   131a9:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   131af:	8b 45 dc             	mov    -0x24(%ebp),%eax
   131b2:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   131b8:	83 ec 08             	sub    $0x8,%esp
   131bb:	52                   	push   %edx
   131bc:	50                   	push   %eax
   131bd:	e8 bb fb ff ff       	call   12d7d <isRGBICCProfile>
   131c2:	83 c4 10             	add    $0x10,%esp
   131c5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   131c8:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   131ce:	85 c0                	test   %eax,%eax
   131d0:	74 0b                	je     131dd <lodepng_encode+0x40e>
   131d2:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   131d8:	83 f8 04             	cmp    $0x4,%eax
   131db:	75 07                	jne    131e4 <lodepng_encode+0x415>
   131dd:	b8 01 00 00 00       	mov    $0x1,%eax
   131e2:	eb 05                	jmp    131e9 <lodepng_encode+0x41a>
   131e4:	b8 00 00 00 00       	mov    $0x0,%eax
   131e9:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   131ec:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   131f0:	75 18                	jne    1320a <lodepng_encode+0x43b>
   131f2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   131f6:	75 12                	jne    1320a <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   131f8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131fb:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   13202:	00 00 00 
      goto cleanup;
   13205:	e9 de 08 00 00       	jmp    13ae8 <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   1320a:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1320d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   13210:	74 24                	je     13236 <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   13212:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13215:	8b 40 5c             	mov    0x5c(%eax),%eax
   13218:	85 c0                	test   %eax,%eax
   1321a:	74 07                	je     13223 <lodepng_encode+0x454>
   1321c:	ba 66 00 00 00       	mov    $0x66,%edx
   13221:	eb 05                	jmp    13228 <lodepng_encode+0x459>
   13223:	ba 65 00 00 00       	mov    $0x65,%edx
   13228:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1322b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   13231:	e9 b2 08 00 00       	jmp    13ae8 <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   13236:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13239:	83 c0 78             	add    $0x78,%eax
   1323c:	83 ec 08             	sub    $0x8,%esp
   1323f:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   13245:	83 c2 0c             	add    $0xc,%edx
   13248:	52                   	push   %edx
   13249:	50                   	push   %eax
   1324a:	e8 57 5f ff ff       	call   91a6 <lodepng_color_mode_equal>
   1324f:	83 c4 10             	add    $0x10,%esp
   13252:	85 c0                	test   %eax,%eax
   13254:	0f 85 f8 00 00 00    	jne    13352 <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   1325a:	8b 55 14             	mov    0x14(%ebp),%edx
   1325d:	8b 45 18             	mov    0x18(%ebp),%eax
   13260:	89 d3                	mov    %edx,%ebx
   13262:	0f af d8             	imul   %eax,%ebx
   13265:	83 ec 0c             	sub    $0xc,%esp
   13268:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1326e:	83 c0 0c             	add    $0xc,%eax
   13271:	50                   	push   %eax
   13272:	e8 49 61 ff ff       	call   93c0 <lodepng_get_bpp>
   13277:	83 c4 10             	add    $0x10,%esp
   1327a:	0f af c3             	imul   %ebx,%eax
   1327d:	83 c0 07             	add    $0x7,%eax
   13280:	c1 e8 03             	shr    $0x3,%eax
   13283:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   13286:	83 ec 0c             	sub    $0xc,%esp
   13289:	ff 75 cc             	pushl  -0x34(%ebp)
   1328c:	e8 13 06 ff ff       	call   38a4 <lodepng_malloc>
   13291:	83 c4 10             	add    $0x10,%esp
   13294:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   13297:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   1329b:	75 13                	jne    132b0 <lodepng_encode+0x4e1>
   1329d:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   132a1:	74 0d                	je     132b0 <lodepng_encode+0x4e1>
   132a3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132a6:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   132ad:	00 00 00 
    if(!state->error) {
   132b0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132b3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   132b9:	85 c0                	test   %eax,%eax
   132bb:	75 33                	jne    132f0 <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   132bd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132c0:	83 c0 78             	add    $0x78,%eax
   132c3:	83 ec 08             	sub    $0x8,%esp
   132c6:	ff 75 18             	pushl  0x18(%ebp)
   132c9:	ff 75 14             	pushl  0x14(%ebp)
   132cc:	50                   	push   %eax
   132cd:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   132d3:	83 c0 0c             	add    $0xc,%eax
   132d6:	50                   	push   %eax
   132d7:	ff 75 10             	pushl  0x10(%ebp)
   132da:	ff 75 c8             	pushl  -0x38(%ebp)
   132dd:	e8 c9 8c ff ff       	call   bfab <lodepng_convert>
   132e2:	83 c4 20             	add    $0x20,%esp
   132e5:	89 c2                	mov    %eax,%edx
   132e7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132ea:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   132f0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132f3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   132f9:	85 c0                	test   %eax,%eax
   132fb:	75 35                	jne    13332 <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   132fd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13300:	83 c0 38             	add    $0x38,%eax
   13303:	83 ec 04             	sub    $0x4,%esp
   13306:	50                   	push   %eax
   13307:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1330d:	50                   	push   %eax
   1330e:	ff 75 18             	pushl  0x18(%ebp)
   13311:	ff 75 14             	pushl  0x14(%ebp)
   13314:	ff 75 c8             	pushl  -0x38(%ebp)
   13317:	8d 45 bc             	lea    -0x44(%ebp),%eax
   1331a:	50                   	push   %eax
   1331b:	8d 45 c0             	lea    -0x40(%ebp),%eax
   1331e:	50                   	push   %eax
   1331f:	e8 0d f6 ff ff       	call   12931 <preProcessScanlines>
   13324:	83 c4 20             	add    $0x20,%esp
   13327:	89 c2                	mov    %eax,%edx
   13329:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1332c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   13332:	83 ec 0c             	sub    $0xc,%esp
   13335:	ff 75 c8             	pushl  -0x38(%ebp)
   13338:	e8 88 05 ff ff       	call   38c5 <lodepng_free>
   1333d:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   13340:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13343:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13349:	85 c0                	test   %eax,%eax
   1334b:	74 4b                	je     13398 <lodepng_encode+0x5c9>
   1334d:	e9 96 07 00 00       	jmp    13ae8 <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   13352:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13355:	83 c0 38             	add    $0x38,%eax
   13358:	83 ec 04             	sub    $0x4,%esp
   1335b:	50                   	push   %eax
   1335c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13362:	50                   	push   %eax
   13363:	ff 75 18             	pushl  0x18(%ebp)
   13366:	ff 75 14             	pushl  0x14(%ebp)
   13369:	ff 75 10             	pushl  0x10(%ebp)
   1336c:	8d 45 bc             	lea    -0x44(%ebp),%eax
   1336f:	50                   	push   %eax
   13370:	8d 45 c0             	lea    -0x40(%ebp),%eax
   13373:	50                   	push   %eax
   13374:	e8 b8 f5 ff ff       	call   12931 <preProcessScanlines>
   13379:	83 c4 20             	add    $0x20,%esp
   1337c:	89 c2                	mov    %eax,%edx
   1337e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13381:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13387:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1338a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13390:	85 c0                	test   %eax,%eax
   13392:	0f 85 16 07 00 00    	jne    13aae <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   13398:	83 ec 0c             	sub    $0xc,%esp
   1339b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1339e:	50                   	push   %eax
   1339f:	e8 21 d9 ff ff       	call   10cc5 <writeSignature>
   133a4:	83 c4 10             	add    $0x10,%esp
   133a7:	89 c2                	mov    %eax,%edx
   133a9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133ac:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   133b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133b5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   133bb:	85 c0                	test   %eax,%eax
   133bd:	0f 85 ee 06 00 00    	jne    13ab1 <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   133c3:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   133c9:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   133cf:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   133d5:	83 ec 08             	sub    $0x8,%esp
   133d8:	51                   	push   %ecx
   133d9:	52                   	push   %edx
   133da:	50                   	push   %eax
   133db:	ff 75 18             	pushl  0x18(%ebp)
   133de:	ff 75 14             	pushl  0x14(%ebp)
   133e1:	8d 45 b0             	lea    -0x50(%ebp),%eax
   133e4:	50                   	push   %eax
   133e5:	e8 4a d9 ff ff       	call   10d34 <addChunk_IHDR>
   133ea:	83 c4 20             	add    $0x20,%esp
   133ed:	89 c2                	mov    %eax,%edx
   133ef:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133f2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   133f8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133fb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13401:	85 c0                	test   %eax,%eax
   13403:	0f 85 ab 06 00 00    	jne    13ab4 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   13409:	8b 45 98             	mov    -0x68(%ebp),%eax
   1340c:	85 c0                	test   %eax,%eax
   1340e:	74 33                	je     13443 <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   13410:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   13413:	8b 45 98             	mov    -0x68(%ebp),%eax
   13416:	83 ec 04             	sub    $0x4,%esp
   13419:	52                   	push   %edx
   1341a:	50                   	push   %eax
   1341b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1341e:	50                   	push   %eax
   1341f:	e8 9c f8 ff ff       	call   12cc0 <addUnknownChunks>
   13424:	83 c4 10             	add    $0x10,%esp
   13427:	89 c2                	mov    %eax,%edx
   13429:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1342c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13432:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13435:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1343b:	85 c0                	test   %eax,%eax
   1343d:	0f 85 74 06 00 00    	jne    13ab7 <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   13443:	8b 45 88             	mov    -0x78(%ebp),%eax
   13446:	85 c0                	test   %eax,%eax
   13448:	74 39                	je     13483 <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   1344a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1344d:	83 c0 38             	add    $0x38,%eax
   13450:	83 ec 04             	sub    $0x4,%esp
   13453:	50                   	push   %eax
   13454:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1345a:	50                   	push   %eax
   1345b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1345e:	50                   	push   %eax
   1345f:	e8 a4 e4 ff ff       	call   11908 <addChunk_iCCP>
   13464:	83 c4 10             	add    $0x10,%esp
   13467:	89 c2                	mov    %eax,%edx
   13469:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1346c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13472:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13475:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1347b:	85 c0                	test   %eax,%eax
   1347d:	0f 85 37 06 00 00    	jne    13aba <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   13483:	8b 45 80             	mov    -0x80(%ebp),%eax
   13486:	85 c0                	test   %eax,%eax
   13488:	74 32                	je     134bc <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   1348a:	83 ec 08             	sub    $0x8,%esp
   1348d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13493:	50                   	push   %eax
   13494:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13497:	50                   	push   %eax
   13498:	e8 41 e4 ff ff       	call   118de <addChunk_sRGB>
   1349d:	83 c4 10             	add    $0x10,%esp
   134a0:	89 c2                	mov    %eax,%edx
   134a2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134a5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   134ab:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134ae:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134b4:	85 c0                	test   %eax,%eax
   134b6:	0f 85 01 06 00 00    	jne    13abd <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   134bc:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   134c2:	85 c0                	test   %eax,%eax
   134c4:	74 32                	je     134f8 <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   134c6:	83 ec 08             	sub    $0x8,%esp
   134c9:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   134cf:	50                   	push   %eax
   134d0:	8d 45 b0             	lea    -0x50(%ebp),%eax
   134d3:	50                   	push   %eax
   134d4:	e8 a7 e2 ff ff       	call   11780 <addChunk_gAMA>
   134d9:	83 c4 10             	add    $0x10,%esp
   134dc:	89 c2                	mov    %eax,%edx
   134de:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134e1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   134e7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134ea:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134f0:	85 c0                	test   %eax,%eax
   134f2:	0f 85 c8 05 00 00    	jne    13ac0 <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   134f8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   134fe:	85 c0                	test   %eax,%eax
   13500:	74 32                	je     13534 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   13502:	83 ec 08             	sub    $0x8,%esp
   13505:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1350b:	50                   	push   %eax
   1350c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1350f:	50                   	push   %eax
   13510:	e8 c1 e2 ff ff       	call   117d6 <addChunk_cHRM>
   13515:	83 c4 10             	add    $0x10,%esp
   13518:	89 c2                	mov    %eax,%edx
   1351a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1351d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13523:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13526:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1352c:	85 c0                	test   %eax,%eax
   1352e:	0f 85 8f 05 00 00    	jne    13ac3 <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   13534:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1353a:	83 f8 03             	cmp    $0x3,%eax
   1353d:	75 35                	jne    13574 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   1353f:	83 ec 08             	sub    $0x8,%esp
   13542:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13548:	83 c0 0c             	add    $0xc,%eax
   1354b:	50                   	push   %eax
   1354c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1354f:	50                   	push   %eax
   13550:	e8 78 d8 ff ff       	call   10dcd <addChunk_PLTE>
   13555:	83 c4 10             	add    $0x10,%esp
   13558:	89 c2                	mov    %eax,%edx
   1355a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1355d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13563:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13566:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1356c:	85 c0                	test   %eax,%eax
   1356e:	0f 85 52 05 00 00    	jne    13ac6 <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   13574:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13577:	8b 40 6c             	mov    0x6c(%eax),%eax
   1357a:	85 c0                	test   %eax,%eax
   1357c:	74 4b                	je     135c9 <lodepng_encode+0x7fa>
   1357e:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13584:	83 f8 02             	cmp    $0x2,%eax
   13587:	74 0b                	je     13594 <lodepng_encode+0x7c5>
   13589:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1358f:	83 f8 06             	cmp    $0x6,%eax
   13592:	75 35                	jne    135c9 <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   13594:	83 ec 08             	sub    $0x8,%esp
   13597:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1359d:	83 c0 0c             	add    $0xc,%eax
   135a0:	50                   	push   %eax
   135a1:	8d 45 b0             	lea    -0x50(%ebp),%eax
   135a4:	50                   	push   %eax
   135a5:	e8 23 d8 ff ff       	call   10dcd <addChunk_PLTE>
   135aa:	83 c4 10             	add    $0x10,%esp
   135ad:	89 c2                	mov    %eax,%edx
   135af:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135b2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   135b8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135bb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   135c1:	85 c0                	test   %eax,%eax
   135c3:	0f 85 00 05 00 00    	jne    13ac9 <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   135c9:	83 ec 08             	sub    $0x8,%esp
   135cc:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   135d2:	83 c0 0c             	add    $0xc,%eax
   135d5:	50                   	push   %eax
   135d6:	8d 45 b0             	lea    -0x50(%ebp),%eax
   135d9:	50                   	push   %eax
   135da:	e8 c4 d8 ff ff       	call   10ea3 <addChunk_tRNS>
   135df:	83 c4 10             	add    $0x10,%esp
   135e2:	89 c2                	mov    %eax,%edx
   135e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135e7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   135ed:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135f0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   135f6:	85 c0                	test   %eax,%eax
   135f8:	0f 85 ce 04 00 00    	jne    13acc <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   135fe:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   13604:	85 c0                	test   %eax,%eax
   13606:	74 32                	je     1363a <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   13608:	83 ec 08             	sub    $0x8,%esp
   1360b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13611:	50                   	push   %eax
   13612:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13615:	50                   	push   %eax
   13616:	e8 e4 de ff ff       	call   114ff <addChunk_bKGD>
   1361b:	83 c4 10             	add    $0x10,%esp
   1361e:	89 c2                	mov    %eax,%edx
   13620:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13623:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13629:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1362c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13632:	85 c0                	test   %eax,%eax
   13634:	0f 85 95 04 00 00    	jne    13acf <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   1363a:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   13640:	85 c0                	test   %eax,%eax
   13642:	74 32                	je     13676 <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   13644:	83 ec 08             	sub    $0x8,%esp
   13647:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1364d:	50                   	push   %eax
   1364e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13651:	50                   	push   %eax
   13652:	e8 ac e0 ff ff       	call   11703 <addChunk_pHYs>
   13657:	83 c4 10             	add    $0x10,%esp
   1365a:	89 c2                	mov    %eax,%edx
   1365c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1365f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13665:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13668:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1366e:	85 c0                	test   %eax,%eax
   13670:	0f 85 5c 04 00 00    	jne    13ad2 <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   13676:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13679:	85 c0                	test   %eax,%eax
   1367b:	74 33                	je     136b0 <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   1367d:	8b 55 a8             	mov    -0x58(%ebp),%edx
   13680:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13683:	83 ec 04             	sub    $0x4,%esp
   13686:	52                   	push   %edx
   13687:	50                   	push   %eax
   13688:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1368b:	50                   	push   %eax
   1368c:	e8 2f f6 ff ff       	call   12cc0 <addUnknownChunks>
   13691:	83 c4 10             	add    $0x10,%esp
   13694:	89 c2                	mov    %eax,%edx
   13696:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13699:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1369f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136a2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   136a8:	85 c0                	test   %eax,%eax
   136aa:	0f 85 25 04 00 00    	jne    13ad5 <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   136b0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136b3:	8d 48 38             	lea    0x38(%eax),%ecx
   136b6:	8b 55 bc             	mov    -0x44(%ebp),%edx
   136b9:	8b 45 c0             	mov    -0x40(%ebp),%eax
   136bc:	51                   	push   %ecx
   136bd:	52                   	push   %edx
   136be:	50                   	push   %eax
   136bf:	8d 45 b0             	lea    -0x50(%ebp),%eax
   136c2:	50                   	push   %eax
   136c3:	e8 bd d9 ff ff       	call   11085 <addChunk_IDAT>
   136c8:	83 c4 10             	add    $0x10,%esp
   136cb:	89 c2                	mov    %eax,%edx
   136cd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136d0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   136d6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136d9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   136df:	85 c0                	test   %eax,%eax
   136e1:	0f 85 f1 03 00 00    	jne    13ad8 <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   136e7:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   136ed:	85 c0                	test   %eax,%eax
   136ef:	74 35                	je     13726 <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   136f1:	83 ec 08             	sub    $0x8,%esp
   136f4:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   136fa:	83 c0 60             	add    $0x60,%eax
   136fd:	50                   	push   %eax
   136fe:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13701:	50                   	push   %eax
   13702:	e8 5c df ff ff       	call   11663 <addChunk_tIME>
   13707:	83 c4 10             	add    $0x10,%esp
   1370a:	89 c2                	mov    %eax,%edx
   1370c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1370f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13715:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13718:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1371e:	85 c0                	test   %eax,%eax
   13720:	0f 85 b5 03 00 00    	jne    13adb <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13726:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1372d:	e9 12 01 00 00       	jmp    13844 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   13732:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13738:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1373b:	c1 e2 02             	shl    $0x2,%edx
   1373e:	01 d0                	add    %edx,%eax
   13740:	8b 00                	mov    (%eax),%eax
   13742:	83 ec 0c             	sub    $0xc,%esp
   13745:	50                   	push   %eax
   13746:	e8 f5 01 ff ff       	call   3940 <lodepng_strlen>
   1374b:	83 c4 10             	add    $0x10,%esp
   1374e:	83 f8 4f             	cmp    $0x4f,%eax
   13751:	7e 12                	jle    13765 <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   13753:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13756:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   1375d:	00 00 00 
        goto cleanup;
   13760:	e9 83 03 00 00       	jmp    13ae8 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   13765:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1376b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1376e:	c1 e2 02             	shl    $0x2,%edx
   13771:	01 d0                	add    %edx,%eax
   13773:	8b 00                	mov    (%eax),%eax
   13775:	83 ec 0c             	sub    $0xc,%esp
   13778:	50                   	push   %eax
   13779:	e8 c2 01 ff ff       	call   3940 <lodepng_strlen>
   1377e:	83 c4 10             	add    $0x10,%esp
   13781:	85 c0                	test   %eax,%eax
   13783:	7f 12                	jg     13797 <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   13785:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13788:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   1378f:	00 00 00 
        goto cleanup;
   13792:	e9 51 03 00 00       	jmp    13ae8 <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   13797:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1379a:	8b 40 74             	mov    0x74(%eax),%eax
   1379d:	85 c0                	test   %eax,%eax
   1379f:	74 52                	je     137f3 <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   137a1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137a4:	8d 48 38             	lea    0x38(%eax),%ecx
   137a7:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   137ad:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   137b0:	c1 e2 02             	shl    $0x2,%edx
   137b3:	01 d0                	add    %edx,%eax
   137b5:	8b 10                	mov    (%eax),%edx
   137b7:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   137bd:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   137c0:	c1 e3 02             	shl    $0x2,%ebx
   137c3:	01 d8                	add    %ebx,%eax
   137c5:	8b 00                	mov    (%eax),%eax
   137c7:	51                   	push   %ecx
   137c8:	52                   	push   %edx
   137c9:	50                   	push   %eax
   137ca:	8d 45 b0             	lea    -0x50(%ebp),%eax
   137cd:	50                   	push   %eax
   137ce:	e8 fa d9 ff ff       	call   111cd <addChunk_zTXt>
   137d3:	83 c4 10             	add    $0x10,%esp
   137d6:	89 c2                	mov    %eax,%edx
   137d8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137db:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   137e1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137e4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   137ea:	85 c0                	test   %eax,%eax
   137ec:	74 52                	je     13840 <lodepng_encode+0xa71>
   137ee:	e9 f5 02 00 00       	jmp    13ae8 <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   137f3:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   137f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   137fc:	c1 e2 02             	shl    $0x2,%edx
   137ff:	01 d0                	add    %edx,%eax
   13801:	8b 10                	mov    (%eax),%edx
   13803:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13809:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   1380c:	c1 e1 02             	shl    $0x2,%ecx
   1380f:	01 c8                	add    %ecx,%eax
   13811:	8b 00                	mov    (%eax),%eax
   13813:	83 ec 04             	sub    $0x4,%esp
   13816:	52                   	push   %edx
   13817:	50                   	push   %eax
   13818:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1381b:	50                   	push   %eax
   1381c:	e8 ec d8 ff ff       	call   1110d <addChunk_tEXt>
   13821:	83 c4 10             	add    $0x10,%esp
   13824:	89 c2                	mov    %eax,%edx
   13826:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13829:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   1382f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13832:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13838:	85 c0                	test   %eax,%eax
   1383a:	0f 85 9e 02 00 00    	jne    13ade <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13840:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13844:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   1384a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1384d:	0f 85 df fe ff ff    	jne    13732 <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   13853:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13856:	8b 40 70             	mov    0x70(%eax),%eax
   13859:	85 c0                	test   %eax,%eax
   1385b:	0f 84 e3 00 00 00    	je     13944 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   13861:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   13868:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1386f:	e9 85 00 00 00       	jmp    138f9 <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   13874:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1387a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1387d:	c1 e2 02             	shl    $0x2,%edx
   13880:	01 d0                	add    %edx,%eax
   13882:	8b 00                	mov    (%eax),%eax
   13884:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13887:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1388a:	0f b6 00             	movzbl (%eax),%eax
   1388d:	3c 4c                	cmp    $0x4c,%al
   1388f:	75 64                	jne    138f5 <lodepng_encode+0xb26>
   13891:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13894:	83 c0 01             	add    $0x1,%eax
   13897:	0f b6 00             	movzbl (%eax),%eax
   1389a:	3c 6f                	cmp    $0x6f,%al
   1389c:	75 57                	jne    138f5 <lodepng_encode+0xb26>
   1389e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   138a1:	83 c0 02             	add    $0x2,%eax
   138a4:	0f b6 00             	movzbl (%eax),%eax
   138a7:	3c 64                	cmp    $0x64,%al
   138a9:	75 4a                	jne    138f5 <lodepng_encode+0xb26>
   138ab:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   138ae:	83 c0 03             	add    $0x3,%eax
   138b1:	0f b6 00             	movzbl (%eax),%eax
   138b4:	3c 65                	cmp    $0x65,%al
   138b6:	75 3d                	jne    138f5 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   138b8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   138bb:	83 c0 04             	add    $0x4,%eax
   138be:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   138c1:	3c 50                	cmp    $0x50,%al
   138c3:	75 30                	jne    138f5 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   138c5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   138c8:	83 c0 05             	add    $0x5,%eax
   138cb:	0f b6 00             	movzbl (%eax),%eax
   138ce:	3c 4e                	cmp    $0x4e,%al
   138d0:	75 23                	jne    138f5 <lodepng_encode+0xb26>
   138d2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   138d5:	83 c0 06             	add    $0x6,%eax
   138d8:	0f b6 00             	movzbl (%eax),%eax
   138db:	3c 47                	cmp    $0x47,%al
   138dd:	75 16                	jne    138f5 <lodepng_encode+0xb26>
   138df:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   138e2:	83 c0 07             	add    $0x7,%eax
   138e5:	0f b6 00             	movzbl (%eax),%eax
   138e8:	84 c0                	test   %al,%al
   138ea:	75 09                	jne    138f5 <lodepng_encode+0xb26>
          already_added_id_text = 1;
   138ec:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   138f3:	eb 13                	jmp    13908 <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   138f5:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   138f9:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   138ff:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13902:	0f 85 6c ff ff ff    	jne    13874 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   13908:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1390c:	75 36                	jne    13944 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   1390e:	a1 00 e7 01 00       	mov    0x1e700,%eax
   13913:	83 ec 04             	sub    $0x4,%esp
   13916:	50                   	push   %eax
   13917:	68 64 a6 01 00       	push   $0x1a664
   1391c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1391f:	50                   	push   %eax
   13920:	e8 e8 d7 ff ff       	call   1110d <addChunk_tEXt>
   13925:	83 c4 10             	add    $0x10,%esp
   13928:	89 c2                	mov    %eax,%edx
   1392a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1392d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13933:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13936:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1393c:	85 c0                	test   %eax,%eax
   1393e:	0f 85 9d 01 00 00    	jne    13ae1 <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13944:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1394b:	e9 e6 00 00 00       	jmp    13a36 <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   13950:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13956:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13959:	c1 e2 02             	shl    $0x2,%edx
   1395c:	01 d0                	add    %edx,%eax
   1395e:	8b 00                	mov    (%eax),%eax
   13960:	83 ec 0c             	sub    $0xc,%esp
   13963:	50                   	push   %eax
   13964:	e8 d7 ff fe ff       	call   3940 <lodepng_strlen>
   13969:	83 c4 10             	add    $0x10,%esp
   1396c:	83 f8 4f             	cmp    $0x4f,%eax
   1396f:	7e 12                	jle    13983 <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   13971:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13974:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   1397b:	00 00 00 
        goto cleanup;
   1397e:	e9 65 01 00 00       	jmp    13ae8 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   13983:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13989:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1398c:	c1 e2 02             	shl    $0x2,%edx
   1398f:	01 d0                	add    %edx,%eax
   13991:	8b 00                	mov    (%eax),%eax
   13993:	83 ec 0c             	sub    $0xc,%esp
   13996:	50                   	push   %eax
   13997:	e8 a4 ff fe ff       	call   3940 <lodepng_strlen>
   1399c:	83 c4 10             	add    $0x10,%esp
   1399f:	85 c0                	test   %eax,%eax
   139a1:	7f 12                	jg     139b5 <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   139a3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   139a6:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   139ad:	00 00 00 
        goto cleanup;
   139b0:	e9 33 01 00 00       	jmp    13ae8 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   139b5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   139b8:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   139bb:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   139c1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   139c4:	c1 e2 02             	shl    $0x2,%edx
   139c7:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   139c9:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   139cb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   139d1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   139d4:	c1 e2 02             	shl    $0x2,%edx
   139d7:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   139d9:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   139db:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   139e1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   139e4:	c1 e2 02             	shl    $0x2,%edx
   139e7:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   139e9:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   139eb:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   139f1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   139f4:	c1 e2 02             	shl    $0x2,%edx
   139f7:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   139f9:	8b 10                	mov    (%eax),%edx
   139fb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   139fe:	8b 40 74             	mov    0x74(%eax),%eax
   13a01:	83 ec 04             	sub    $0x4,%esp
   13a04:	57                   	push   %edi
   13a05:	56                   	push   %esi
   13a06:	53                   	push   %ebx
   13a07:	51                   	push   %ecx
   13a08:	52                   	push   %edx
   13a09:	50                   	push   %eax
   13a0a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13a0d:	50                   	push   %eax
   13a0e:	e8 dc d8 ff ff       	call   112ef <addChunk_iTXt>
   13a13:	83 c4 20             	add    $0x20,%esp
   13a16:	89 c2                	mov    %eax,%edx
   13a18:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a1b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13a21:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a24:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13a2a:	85 c0                	test   %eax,%eax
   13a2c:	0f 85 b2 00 00 00    	jne    13ae4 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13a32:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13a36:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   13a3c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13a3f:	0f 85 0b ff ff ff    	jne    13950 <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   13a45:	8b 45 a0             	mov    -0x60(%ebp),%eax
   13a48:	85 c0                	test   %eax,%eax
   13a4a:	74 2f                	je     13a7b <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   13a4c:	8b 55 ac             	mov    -0x54(%ebp),%edx
   13a4f:	8b 45 a0             	mov    -0x60(%ebp),%eax
   13a52:	83 ec 04             	sub    $0x4,%esp
   13a55:	52                   	push   %edx
   13a56:	50                   	push   %eax
   13a57:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13a5a:	50                   	push   %eax
   13a5b:	e8 60 f2 ff ff       	call   12cc0 <addUnknownChunks>
   13a60:	83 c4 10             	add    $0x10,%esp
   13a63:	89 c2                	mov    %eax,%edx
   13a65:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a68:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13a6e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a71:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13a77:	85 c0                	test   %eax,%eax
   13a79:	75 6c                	jne    13ae7 <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   13a7b:	83 ec 0c             	sub    $0xc,%esp
   13a7e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13a81:	50                   	push   %eax
   13a82:	e8 6d d6 ff ff       	call   110f4 <addChunk_IEND>
   13a87:	83 c4 10             	add    $0x10,%esp
   13a8a:	89 c2                	mov    %eax,%edx
   13a8c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a8f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13a95:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a98:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13a9e:	85 c0                	test   %eax,%eax
   13aa0:	eb 46                	jmp    13ae8 <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13aa2:	90                   	nop
   13aa3:	eb 43                	jmp    13ae8 <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13aa5:	90                   	nop
   13aa6:	eb 40                	jmp    13ae8 <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   13aa8:	90                   	nop
   13aa9:	eb 3d                	jmp    13ae8 <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   13aab:	90                   	nop
   13aac:	eb 3a                	jmp    13ae8 <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   13aae:	90                   	nop
   13aaf:	eb 37                	jmp    13ae8 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   13ab1:	90                   	nop
   13ab2:	eb 34                	jmp    13ae8 <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   13ab4:	90                   	nop
   13ab5:	eb 31                	jmp    13ae8 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   13ab7:	90                   	nop
   13ab8:	eb 2e                	jmp    13ae8 <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13aba:	90                   	nop
   13abb:	eb 2b                	jmp    13ae8 <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   13abd:	90                   	nop
   13abe:	eb 28                	jmp    13ae8 <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   13ac0:	90                   	nop
   13ac1:	eb 25                	jmp    13ae8 <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   13ac3:	90                   	nop
   13ac4:	eb 22                	jmp    13ae8 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13ac6:	90                   	nop
   13ac7:	eb 1f                	jmp    13ae8 <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13ac9:	90                   	nop
   13aca:	eb 1c                	jmp    13ae8 <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   13acc:	90                   	nop
   13acd:	eb 19                	jmp    13ae8 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   13acf:	90                   	nop
   13ad0:	eb 16                	jmp    13ae8 <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   13ad2:	90                   	nop
   13ad3:	eb 13                	jmp    13ae8 <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   13ad5:	90                   	nop
   13ad6:	eb 10                	jmp    13ae8 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   13ad8:	90                   	nop
   13ad9:	eb 0d                	jmp    13ae8 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   13adb:	90                   	nop
   13adc:	eb 0a                	jmp    13ae8 <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   13ade:	90                   	nop
   13adf:	eb 07                	jmp    13ae8 <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   13ae1:	90                   	nop
   13ae2:	eb 04                	jmp    13ae8 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13ae4:	90                   	nop
   13ae5:	eb 01                	jmp    13ae8 <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   13ae7:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   13ae8:	83 ec 0c             	sub    $0xc,%esp
   13aeb:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13af1:	50                   	push   %eax
   13af2:	e8 34 65 ff ff       	call   a02b <lodepng_info_cleanup>
   13af7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   13afa:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13afd:	83 ec 0c             	sub    $0xc,%esp
   13b00:	50                   	push   %eax
   13b01:	e8 bf fd fe ff       	call   38c5 <lodepng_free>
   13b06:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   13b09:	8b 55 b0             	mov    -0x50(%ebp),%edx
   13b0c:	8b 45 08             	mov    0x8(%ebp),%eax
   13b0f:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   13b11:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   13b14:	8b 45 0c             	mov    0xc(%ebp),%eax
   13b17:	89 10                	mov    %edx,(%eax)

  return state->error;
   13b19:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b1c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   13b22:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13b25:	5b                   	pop    %ebx
   13b26:	5e                   	pop    %esi
   13b27:	5f                   	pop    %edi
   13b28:	5d                   	pop    %ebp
   13b29:	c3                   	ret    

00013b2a <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   13b2a:	55                   	push   %ebp
   13b2b:	89 e5                	mov    %esp,%ebp
   13b2d:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   13b33:	83 ec 0c             	sub    $0xc,%esp
   13b36:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13b3c:	50                   	push   %eax
   13b3d:	e8 38 d0 ff ff       	call   10b7a <lodepng_state_init>
   13b42:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   13b45:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b48:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   13b4e:	8b 45 20             	mov    0x20(%ebp),%eax
   13b51:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   13b57:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b5a:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   13b60:	8b 45 20             	mov    0x20(%ebp),%eax
   13b63:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   13b69:	83 ec 08             	sub    $0x8,%esp
   13b6c:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13b72:	50                   	push   %eax
   13b73:	ff 75 18             	pushl  0x18(%ebp)
   13b76:	ff 75 14             	pushl  0x14(%ebp)
   13b79:	ff 75 10             	pushl  0x10(%ebp)
   13b7c:	ff 75 0c             	pushl  0xc(%ebp)
   13b7f:	ff 75 08             	pushl  0x8(%ebp)
   13b82:	e8 48 f2 ff ff       	call   12dcf <lodepng_encode>
   13b87:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   13b8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13b8d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   13b90:	83 ec 0c             	sub    $0xc,%esp
   13b93:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13b99:	50                   	push   %eax
   13b9a:	e8 35 d0 ff ff       	call   10bd4 <lodepng_state_cleanup>
   13b9f:	83 c4 10             	add    $0x10,%esp
  return error;
   13ba2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13ba5:	c9                   	leave  
   13ba6:	c3                   	ret    

00013ba7 <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13ba7:	55                   	push   %ebp
   13ba8:	89 e5                	mov    %esp,%ebp
   13baa:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   13bad:	83 ec 04             	sub    $0x4,%esp
   13bb0:	6a 08                	push   $0x8
   13bb2:	6a 06                	push   $0x6
   13bb4:	ff 75 18             	pushl  0x18(%ebp)
   13bb7:	ff 75 14             	pushl  0x14(%ebp)
   13bba:	ff 75 10             	pushl  0x10(%ebp)
   13bbd:	ff 75 0c             	pushl  0xc(%ebp)
   13bc0:	ff 75 08             	pushl  0x8(%ebp)
   13bc3:	e8 62 ff ff ff       	call   13b2a <lodepng_encode_memory>
   13bc8:	83 c4 20             	add    $0x20,%esp
}
   13bcb:	c9                   	leave  
   13bcc:	c3                   	ret    

00013bcd <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13bcd:	55                   	push   %ebp
   13bce:	89 e5                	mov    %esp,%ebp
   13bd0:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   13bd3:	83 ec 04             	sub    $0x4,%esp
   13bd6:	6a 08                	push   $0x8
   13bd8:	6a 02                	push   $0x2
   13bda:	ff 75 18             	pushl  0x18(%ebp)
   13bdd:	ff 75 14             	pushl  0x14(%ebp)
   13be0:	ff 75 10             	pushl  0x10(%ebp)
   13be3:	ff 75 0c             	pushl  0xc(%ebp)
   13be6:	ff 75 08             	pushl  0x8(%ebp)
   13be9:	e8 3c ff ff ff       	call   13b2a <lodepng_encode_memory>
   13bee:	83 c4 20             	add    $0x20,%esp
}
   13bf1:	c9                   	leave  
   13bf2:	c3                   	ret    

00013bf3 <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   13bf3:	55                   	push   %ebp
   13bf4:	89 e5                	mov    %esp,%ebp
   13bf6:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   13bf9:	83 ec 04             	sub    $0x4,%esp
   13bfc:	ff 75 1c             	pushl  0x1c(%ebp)
   13bff:	ff 75 18             	pushl  0x18(%ebp)
   13c02:	ff 75 14             	pushl  0x14(%ebp)
   13c05:	ff 75 10             	pushl  0x10(%ebp)
   13c08:	ff 75 0c             	pushl  0xc(%ebp)
   13c0b:	8d 45 ec             	lea    -0x14(%ebp),%eax
   13c0e:	50                   	push   %eax
   13c0f:	8d 45 f0             	lea    -0x10(%ebp),%eax
   13c12:	50                   	push   %eax
   13c13:	e8 12 ff ff ff       	call   13b2a <lodepng_encode_memory>
   13c18:	83 c4 20             	add    $0x20,%esp
   13c1b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   13c1e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13c22:	75 19                	jne    13c3d <lodepng_encode_file+0x4a>
   13c24:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13c27:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13c2a:	83 ec 04             	sub    $0x4,%esp
   13c2d:	ff 75 08             	pushl  0x8(%ebp)
   13c30:	52                   	push   %edx
   13c31:	50                   	push   %eax
   13c32:	e8 36 01 ff ff       	call   3d6d <lodepng_save_file>
   13c37:	83 c4 10             	add    $0x10,%esp
   13c3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   13c3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13c40:	83 ec 0c             	sub    $0xc,%esp
   13c43:	50                   	push   %eax
   13c44:	e8 7c fc fe ff       	call   38c5 <lodepng_free>
   13c49:	83 c4 10             	add    $0x10,%esp
  return error;
   13c4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13c4f:	c9                   	leave  
   13c50:	c3                   	ret    

00013c51 <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   13c51:	55                   	push   %ebp
   13c52:	89 e5                	mov    %esp,%ebp
   13c54:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   13c57:	83 ec 08             	sub    $0x8,%esp
   13c5a:	6a 08                	push   $0x8
   13c5c:	6a 06                	push   $0x6
   13c5e:	ff 75 14             	pushl  0x14(%ebp)
   13c61:	ff 75 10             	pushl  0x10(%ebp)
   13c64:	ff 75 0c             	pushl  0xc(%ebp)
   13c67:	ff 75 08             	pushl  0x8(%ebp)
   13c6a:	e8 84 ff ff ff       	call   13bf3 <lodepng_encode_file>
   13c6f:	83 c4 20             	add    $0x20,%esp
}
   13c72:	c9                   	leave  
   13c73:	c3                   	ret    

00013c74 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   13c74:	55                   	push   %ebp
   13c75:	89 e5                	mov    %esp,%ebp
   13c77:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   13c7a:	83 ec 08             	sub    $0x8,%esp
   13c7d:	6a 08                	push   $0x8
   13c7f:	6a 02                	push   $0x2
   13c81:	ff 75 14             	pushl  0x14(%ebp)
   13c84:	ff 75 10             	pushl  0x10(%ebp)
   13c87:	ff 75 0c             	pushl  0xc(%ebp)
   13c8a:	ff 75 08             	pushl  0x8(%ebp)
   13c8d:	e8 61 ff ff ff       	call   13bf3 <lodepng_encode_file>
   13c92:	83 c4 20             	add    $0x20,%esp
}
   13c95:	c9                   	leave  
   13c96:	c3                   	ret    

00013c97 <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   13c97:	55                   	push   %ebp
   13c98:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   13c9a:	8b 45 08             	mov    0x8(%ebp),%eax
   13c9d:	50                   	push   %eax
   13c9e:	e8 71 49 ff ff       	call   8614 <lodepng_compress_settings_init>
   13ca3:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   13ca6:	8b 45 08             	mov    0x8(%ebp),%eax
   13ca9:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   13cb0:	8b 45 08             	mov    0x8(%ebp),%eax
   13cb3:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   13cba:	8b 45 08             	mov    0x8(%ebp),%eax
   13cbd:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   13cc4:	8b 45 08             	mov    0x8(%ebp),%eax
   13cc7:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   13cce:	8b 45 08             	mov    0x8(%ebp),%eax
   13cd1:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   13cd8:	8b 45 08             	mov    0x8(%ebp),%eax
   13cdb:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   13ce2:	8b 45 08             	mov    0x8(%ebp),%eax
   13ce5:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   13cec:	90                   	nop
   13ced:	c9                   	leave  
   13cee:	c3                   	ret    

00013cef <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   13cef:	55                   	push   %ebp
   13cf0:	89 e5                	mov    %esp,%ebp
  switch(code) {
   13cf2:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   13cf6:	0f 87 c1 03 00 00    	ja     140bd <lodepng_error_text+0x3ce>
   13cfc:	8b 45 08             	mov    0x8(%ebp),%eax
   13cff:	c1 e0 02             	shl    $0x2,%eax
   13d02:	05 a0 b9 01 00       	add    $0x1b9a0,%eax
   13d07:	8b 00                	mov    (%eax),%eax
   13d09:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   13d0b:	b8 6c a6 01 00       	mov    $0x1a66c,%eax
   13d10:	e9 ad 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   13d15:	b8 89 a6 01 00       	mov    $0x1a689,%eax
   13d1a:	e9 a3 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   13d1f:	b8 9c a6 01 00       	mov    $0x1a69c,%eax
   13d24:	e9 99 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   13d29:	b8 d4 a6 01 00       	mov    $0x1a6d4,%eax
   13d2e:	e9 8f 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   13d33:	b8 0c a7 01 00       	mov    $0x1a70c,%eax
   13d38:	e9 85 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   13d3d:	b8 0c a7 01 00       	mov    $0x1a70c,%eax
   13d42:	e9 7b 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   13d47:	b8 0c a7 01 00       	mov    $0x1a70c,%eax
   13d4c:	e9 71 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   13d51:	b8 3c a7 01 00       	mov    $0x1a73c,%eax
   13d56:	e9 67 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   13d5b:	b8 70 a7 01 00       	mov    $0x1a770,%eax
   13d60:	e9 5d 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   13d65:	b8 a4 a7 01 00       	mov    $0x1a7a4,%eax
   13d6a:	e9 53 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   13d6f:	b8 70 a7 01 00       	mov    $0x1a770,%eax
   13d74:	e9 49 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   13d79:	b8 cc a7 01 00       	mov    $0x1a7cc,%eax
   13d7e:	e9 3f 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   13d83:	b8 04 a8 01 00       	mov    $0x1a804,%eax
   13d88:	e9 35 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   13d8d:	b8 70 a7 01 00       	mov    $0x1a770,%eax
   13d92:	e9 2b 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   13d97:	b8 3c a8 01 00       	mov    $0x1a83c,%eax
   13d9c:	e9 21 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   13da1:	b8 6c a8 01 00       	mov    $0x1a86c,%eax
   13da6:	e9 17 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   13dab:	b8 8c a8 01 00       	mov    $0x1a88c,%eax
   13db0:	e9 0d 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   13db5:	b8 b8 a8 01 00       	mov    $0x1a8b8,%eax
   13dba:	e9 03 03 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   13dbf:	b8 f8 a8 01 00       	mov    $0x1a8f8,%eax
   13dc4:	e9 f9 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   13dc9:	b8 20 a9 01 00       	mov    $0x1a920,%eax
   13dce:	e9 ef 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   13dd3:	b8 54 a9 01 00       	mov    $0x1a954,%eax
   13dd8:	e9 e5 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   13ddd:	b8 78 a9 01 00       	mov    $0x1a978,%eax
   13de2:	e9 db 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   13de7:	b8 b0 a9 01 00       	mov    $0x1a9b0,%eax
   13dec:	e9 d1 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   13df1:	b8 d0 a9 01 00       	mov    $0x1a9d0,%eax
   13df6:	e9 c7 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   13dfb:	b8 ef a9 01 00       	mov    $0x1a9ef,%eax
   13e00:	e9 bd 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   13e05:	b8 09 aa 01 00       	mov    $0x1aa09,%eax
   13e0a:	e9 b3 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   13e0f:	b8 28 aa 01 00       	mov    $0x1aa28,%eax
   13e14:	e9 a9 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   13e19:	b8 64 aa 01 00       	mov    $0x1aa64,%eax
   13e1e:	e9 9f 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   13e23:	b8 88 aa 01 00       	mov    $0x1aa88,%eax
   13e28:	e9 95 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   13e2d:	b8 b4 aa 01 00       	mov    $0x1aab4,%eax
   13e32:	e9 8b 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   13e37:	b8 d8 aa 01 00       	mov    $0x1aad8,%eax
   13e3c:	e9 81 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   13e41:	b8 18 ab 01 00       	mov    $0x1ab18,%eax
   13e46:	e9 77 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   13e4b:	b8 48 ab 01 00       	mov    $0x1ab48,%eax
   13e50:	e9 6d 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   13e55:	b8 70 ab 01 00       	mov    $0x1ab70,%eax
   13e5a:	e9 63 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   13e5f:	b8 b4 ab 01 00       	mov    $0x1abb4,%eax
   13e64:	e9 59 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   13e69:	b8 e0 ab 01 00       	mov    $0x1abe0,%eax
   13e6e:	e9 4f 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   13e73:	b8 10 ac 01 00       	mov    $0x1ac10,%eax
   13e78:	e9 45 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   13e7d:	b8 38 ac 01 00       	mov    $0x1ac38,%eax
   13e82:	e9 3b 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   13e87:	b8 80 ac 01 00       	mov    $0x1ac80,%eax
   13e8c:	e9 31 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   13e91:	b8 80 ac 01 00       	mov    $0x1ac80,%eax
   13e96:	e9 27 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   13e9b:	b8 bc ac 01 00       	mov    $0x1acbc,%eax
   13ea0:	e9 1d 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   13ea5:	b8 f0 ac 01 00       	mov    $0x1acf0,%eax
   13eaa:	e9 13 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   13eaf:	b8 13 ad 01 00       	mov    $0x1ad13,%eax
   13eb4:	e9 09 02 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   13eb9:	b8 30 ad 01 00       	mov    $0x1ad30,%eax
   13ebe:	e9 ff 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   13ec3:	b8 6c ad 01 00       	mov    $0x1ad6c,%eax
   13ec8:	e9 f5 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   13ecd:	b8 9c ad 01 00       	mov    $0x1ad9c,%eax
   13ed2:	e9 eb 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   13ed7:	b8 e8 ad 01 00       	mov    $0x1ade8,%eax
   13edc:	e9 e1 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   13ee1:	b8 20 ae 01 00       	mov    $0x1ae20,%eax
   13ee6:	e9 d7 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   13eeb:	b8 60 ae 01 00       	mov    $0x1ae60,%eax
   13ef0:	e9 cd 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   13ef5:	b8 8c ae 01 00       	mov    $0x1ae8c,%eax
   13efa:	e9 c3 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   13eff:	b8 d8 ae 01 00       	mov    $0x1aed8,%eax
   13f04:	e9 b9 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   13f09:	b8 2c af 01 00       	mov    $0x1af2c,%eax
   13f0e:	e9 af 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   13f13:	b8 60 af 01 00       	mov    $0x1af60,%eax
   13f18:	e9 a5 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   13f1d:	b8 b0 af 01 00       	mov    $0x1afb0,%eax
   13f22:	e9 9b 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   13f27:	b8 ec af 01 00       	mov    $0x1afec,%eax
   13f2c:	e9 91 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   13f31:	b8 4c b0 01 00       	mov    $0x1b04c,%eax
   13f36:	e9 87 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   13f3b:	b8 ac b0 01 00       	mov    $0x1b0ac,%eax
   13f40:	e9 7d 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   13f45:	b8 08 b1 01 00       	mov    $0x1b108,%eax
   13f4a:	e9 73 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   13f4f:	b8 4c b1 01 00       	mov    $0x1b14c,%eax
   13f54:	e9 69 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   13f59:	b8 88 b1 01 00       	mov    $0x1b188,%eax
   13f5e:	e9 5f 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   13f63:	b8 e5 b1 01 00       	mov    $0x1b1e5,%eax
   13f68:	e9 55 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   13f6d:	b8 fd b1 01 00       	mov    $0x1b1fd,%eax
   13f72:	e9 4b 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   13f77:	b8 18 b2 01 00       	mov    $0x1b218,%eax
   13f7c:	e9 41 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   13f81:	b8 54 b2 01 00       	mov    $0x1b254,%eax
   13f86:	e9 37 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   13f8b:	b8 84 b2 01 00       	mov    $0x1b284,%eax
   13f90:	e9 2d 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   13f95:	b8 a4 b2 01 00       	mov    $0x1b2a4,%eax
   13f9a:	e9 23 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   13f9f:	b8 c4 b2 01 00       	mov    $0x1b2c4,%eax
   13fa4:	e9 19 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   13fa9:	b8 e4 b2 01 00       	mov    $0x1b2e4,%eax
   13fae:	e9 0f 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   13fb3:	b8 08 b3 01 00       	mov    $0x1b308,%eax
   13fb8:	e9 05 01 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   13fbd:	b8 30 b3 01 00       	mov    $0x1b330,%eax
   13fc2:	e9 fb 00 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   13fc7:	b8 8d b3 01 00       	mov    $0x1b38d,%eax
   13fcc:	e9 f1 00 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   13fd1:	b8 a8 b3 01 00       	mov    $0x1b3a8,%eax
   13fd6:	e9 e7 00 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   13fdb:	b8 e4 b3 01 00       	mov    $0x1b3e4,%eax
   13fe0:	e9 dd 00 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   13fe5:	b8 18 b4 01 00       	mov    $0x1b418,%eax
   13fea:	e9 d3 00 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   13fef:	b8 6c b4 01 00       	mov    $0x1b46c,%eax
   13ff4:	e9 c9 00 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   13ff9:	b8 b8 b4 01 00       	mov    $0x1b4b8,%eax
   13ffe:	e9 bf 00 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   14003:	b8 f4 b4 01 00       	mov    $0x1b4f4,%eax
   14008:	e9 b5 00 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   1400d:	b8 18 b5 01 00       	mov    $0x1b518,%eax
   14012:	e9 ab 00 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   14017:	b8 38 b5 01 00       	mov    $0x1b538,%eax
   1401c:	e9 a1 00 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   14021:	b8 60 b5 01 00       	mov    $0x1b560,%eax
   14026:	e9 97 00 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   1402b:	b8 80 b5 01 00       	mov    $0x1b580,%eax
   14030:	e9 8d 00 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   14035:	b8 ac b5 01 00       	mov    $0x1b5ac,%eax
   1403a:	e9 83 00 00 00       	jmp    140c2 <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   1403f:	b8 db b5 01 00       	mov    $0x1b5db,%eax
   14044:	eb 7c                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   14046:	b8 f3 b5 01 00       	mov    $0x1b5f3,%eax
   1404b:	eb 75                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   1404d:	b8 0b b6 01 00       	mov    $0x1b60b,%eax
   14052:	eb 6e                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   14054:	b8 23 b6 01 00       	mov    $0x1b623,%eax
   14059:	eb 67                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   1405b:	b8 44 b6 01 00       	mov    $0x1b644,%eax
   14060:	eb 60                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   14062:	b8 94 b6 01 00       	mov    $0x1b694,%eax
   14067:	eb 59                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   14069:	b8 e8 b6 01 00       	mov    $0x1b6e8,%eax
   1406e:	eb 52                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   14070:	b8 3c b7 01 00       	mov    $0x1b73c,%eax
   14075:	eb 4b                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   14077:	b8 84 b7 01 00       	mov    $0x1b784,%eax
   1407c:	eb 44                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   1407e:	b8 c8 b7 01 00       	mov    $0x1b7c8,%eax
   14083:	eb 3d                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   14085:	b8 e4 b7 01 00       	mov    $0x1b7e4,%eax
   1408a:	eb 36                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   1408c:	b8 1c b8 01 00       	mov    $0x1b81c,%eax
   14091:	eb 2f                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   14093:	b8 70 b8 01 00       	mov    $0x1b870,%eax
   14098:	eb 28                	jmp    140c2 <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   1409a:	b8 a0 b8 01 00       	mov    $0x1b8a0,%eax
   1409f:	eb 21                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   140a1:	b8 f0 b8 01 00       	mov    $0x1b8f0,%eax
   140a6:	eb 1a                	jmp    140c2 <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   140a8:	b8 1c b9 01 00       	mov    $0x1b91c,%eax
   140ad:	eb 13                	jmp    140c2 <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   140af:	b8 48 b9 01 00       	mov    $0x1b948,%eax
   140b4:	eb 0c                	jmp    140c2 <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   140b6:	b8 6c b9 01 00       	mov    $0x1b96c,%eax
   140bb:	eb 05                	jmp    140c2 <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   140bd:	b8 8b b9 01 00       	mov    $0x1b98b,%eax
}
   140c2:	5d                   	pop    %ebp
   140c3:	c3                   	ret    

000140c4 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   140c4:	55                   	push   %ebp
   140c5:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   140c7:	8b 45 08             	mov    0x8(%ebp),%eax
   140ca:	8b 40 28             	mov    0x28(%eax),%eax
   140cd:	83 f8 01             	cmp    $0x1,%eax
   140d0:	75 08                	jne    140da <GetImage+0x16>
   140d2:	8b 45 08             	mov    0x8(%ebp),%eax
   140d5:	8b 40 54             	mov    0x54(%eax),%eax
   140d8:	eb 09                	jmp    140e3 <GetImage+0x1f>
   140da:	8b 45 08             	mov    0x8(%ebp),%eax
   140dd:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   140e3:	5d                   	pop    %ebp
   140e4:	c3                   	ret    

000140e5 <GetWidth>:

int GetWidth(Context* ctx){
   140e5:	55                   	push   %ebp
   140e6:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   140e8:	8b 45 08             	mov    0x8(%ebp),%eax
   140eb:	8b 40 10             	mov    0x10(%eax),%eax
}
   140ee:	5d                   	pop    %ebp
   140ef:	c3                   	ret    

000140f0 <GetHeight>:

int GetHeight(Context* ctx){
   140f0:	55                   	push   %ebp
   140f1:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   140f3:	8b 45 08             	mov    0x8(%ebp),%eax
   140f6:	8b 40 14             	mov    0x14(%eax),%eax
}
   140f9:	5d                   	pop    %ebp
   140fa:	c3                   	ret    

000140fb <GetImageSize>:

uint GetImageSize(Context* ctx){
   140fb:	55                   	push   %ebp
   140fc:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   140fe:	8b 45 08             	mov    0x8(%ebp),%eax
   14101:	8b 50 10             	mov    0x10(%eax),%edx
   14104:	8b 45 08             	mov    0x8(%ebp),%eax
   14107:	8b 40 14             	mov    0x14(%eax),%eax
   1410a:	0f af d0             	imul   %eax,%edx
   1410d:	8b 45 08             	mov    0x8(%ebp),%eax
   14110:	8b 40 28             	mov    0x28(%eax),%eax
   14113:	0f af c2             	imul   %edx,%eax
}
   14116:	5d                   	pop    %ebp
   14117:	c3                   	ret    

00014118 <_Clip>:

uchar _Clip(const int x){
   14118:	55                   	push   %ebp
   14119:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   1411b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1411f:	78 15                	js     14136 <_Clip+0x1e>
   14121:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   14128:	7f 05                	jg     1412f <_Clip+0x17>
   1412a:	8b 45 08             	mov    0x8(%ebp),%eax
   1412d:	eb 0c                	jmp    1413b <_Clip+0x23>
   1412f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14134:	eb 05                	jmp    1413b <_Clip+0x23>
   14136:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1413b:	5d                   	pop    %ebp
   1413c:	c3                   	ret    

0001413d <_Skip>:

void _Skip(Context* ctx, int c){
   1413d:	55                   	push   %ebp
   1413e:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   14140:	8b 45 08             	mov    0x8(%ebp),%eax
   14143:	8b 50 04             	mov    0x4(%eax),%edx
   14146:	8b 45 0c             	mov    0xc(%ebp),%eax
   14149:	01 c2                	add    %eax,%edx
   1414b:	8b 45 08             	mov    0x8(%ebp),%eax
   1414e:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   14151:	8b 45 08             	mov    0x8(%ebp),%eax
   14154:	8b 40 08             	mov    0x8(%eax),%eax
   14157:	2b 45 0c             	sub    0xc(%ebp),%eax
   1415a:	89 c2                	mov    %eax,%edx
   1415c:	8b 45 08             	mov    0x8(%ebp),%eax
   1415f:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   14162:	8b 45 08             	mov    0x8(%ebp),%eax
   14165:	8b 40 0c             	mov    0xc(%eax),%eax
   14168:	2b 45 0c             	sub    0xc(%ebp),%eax
   1416b:	89 c2                	mov    %eax,%edx
   1416d:	8b 45 08             	mov    0x8(%ebp),%eax
   14170:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   14173:	8b 45 08             	mov    0x8(%ebp),%eax
   14176:	8b 40 08             	mov    0x8(%eax),%eax
   14179:	85 c0                	test   %eax,%eax
   1417b:	79 09                	jns    14186 <_Skip+0x49>
   1417d:	8b 45 08             	mov    0x8(%ebp),%eax
   14180:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   14186:	90                   	nop
   14187:	5d                   	pop    %ebp
   14188:	c3                   	ret    

00014189 <_DecodeLength>:

void _DecodeLength(Context* ctx){
   14189:	55                   	push   %ebp
   1418a:	89 e5                	mov    %esp,%ebp
   1418c:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   1418f:	8b 45 08             	mov    0x8(%ebp),%eax
   14192:	8b 40 08             	mov    0x8(%eax),%eax
   14195:	83 f8 01             	cmp    $0x1,%eax
   14198:	7f 0b                	jg     141a5 <_DecodeLength+0x1c>
   1419a:	8b 45 08             	mov    0x8(%ebp),%eax
   1419d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   141a3:	eb 45                	jmp    141ea <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   141a5:	8b 45 08             	mov    0x8(%ebp),%eax
   141a8:	8b 40 04             	mov    0x4(%eax),%eax
   141ab:	83 ec 0c             	sub    $0xc,%esp
   141ae:	50                   	push   %eax
   141af:	e8 38 00 00 00       	call   141ec <_Decode2Bytes>
   141b4:	83 c4 10             	add    $0x10,%esp
   141b7:	89 c2                	mov    %eax,%edx
   141b9:	8b 45 08             	mov    0x8(%ebp),%eax
   141bc:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   141bf:	8b 45 08             	mov    0x8(%ebp),%eax
   141c2:	8b 50 0c             	mov    0xc(%eax),%edx
   141c5:	8b 45 08             	mov    0x8(%ebp),%eax
   141c8:	8b 40 08             	mov    0x8(%eax),%eax
   141cb:	39 c2                	cmp    %eax,%edx
   141cd:	7e 0b                	jle    141da <_DecodeLength+0x51>
   141cf:	8b 45 08             	mov    0x8(%ebp),%eax
   141d2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   141d8:	eb 10                	jmp    141ea <_DecodeLength+0x61>
    _Skip(ctx, 2);
   141da:	83 ec 08             	sub    $0x8,%esp
   141dd:	6a 02                	push   $0x2
   141df:	ff 75 08             	pushl  0x8(%ebp)
   141e2:	e8 56 ff ff ff       	call   1413d <_Skip>
   141e7:	83 c4 10             	add    $0x10,%esp
}
   141ea:	c9                   	leave  
   141eb:	c3                   	ret    

000141ec <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   141ec:	55                   	push   %ebp
   141ed:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   141ef:	8b 45 08             	mov    0x8(%ebp),%eax
   141f2:	0f b6 00             	movzbl (%eax),%eax
   141f5:	0f b6 c0             	movzbl %al,%eax
   141f8:	c1 e0 08             	shl    $0x8,%eax
   141fb:	89 c2                	mov    %eax,%edx
   141fd:	8b 45 08             	mov    0x8(%ebp),%eax
   14200:	83 c0 01             	add    $0x1,%eax
   14203:	0f b6 00             	movzbl (%eax),%eax
   14206:	0f b6 c0             	movzbl %al,%eax
   14209:	09 d0                	or     %edx,%eax
}
   1420b:	5d                   	pop    %ebp
   1420c:	c3                   	ret    

0001420d <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   1420d:	55                   	push   %ebp
   1420e:	89 e5                	mov    %esp,%ebp
   14210:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   14213:	8b 45 08             	mov    0x8(%ebp),%eax
   14216:	8b 55 10             	mov    0x10(%ebp),%edx
   14219:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   1421c:	8b 45 14             	mov    0x14(%ebp),%eax
   1421f:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   14224:	89 c2                	mov    %eax,%edx
   14226:	8b 45 08             	mov    0x8(%ebp),%eax
   14229:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   1422c:	8b 45 08             	mov    0x8(%ebp),%eax
   1422f:	8b 40 08             	mov    0x8(%eax),%eax
   14232:	83 f8 01             	cmp    $0x1,%eax
   14235:	7e 1d                	jle    14254 <_DecodeJPEG+0x47>
   14237:	8b 45 08             	mov    0x8(%ebp),%eax
   1423a:	8b 40 04             	mov    0x4(%eax),%eax
   1423d:	0f b6 00             	movzbl (%eax),%eax
   14240:	3c ff                	cmp    $0xff,%al
   14242:	75 10                	jne    14254 <_DecodeJPEG+0x47>
   14244:	8b 45 08             	mov    0x8(%ebp),%eax
   14247:	8b 40 04             	mov    0x4(%eax),%eax
   1424a:	83 c0 01             	add    $0x1,%eax
   1424d:	0f b6 00             	movzbl (%eax),%eax
   14250:	3c d8                	cmp    $0xd8,%al
   14252:	74 0a                	je     1425e <_DecodeJPEG+0x51>
   14254:	b8 01 00 00 00       	mov    $0x1,%eax
   14259:	e9 56 01 00 00       	jmp    143b4 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   1425e:	6a 02                	push   $0x2
   14260:	ff 75 08             	pushl  0x8(%ebp)
   14263:	e8 d5 fe ff ff       	call   1413d <_Skip>
   14268:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   1426b:	e9 0a 01 00 00       	jmp    1437a <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   14270:	8b 45 08             	mov    0x8(%ebp),%eax
   14273:	8b 40 08             	mov    0x8(%eax),%eax
   14276:	85 c0                	test   %eax,%eax
   14278:	78 0d                	js     14287 <_DecodeJPEG+0x7a>
   1427a:	8b 45 08             	mov    0x8(%ebp),%eax
   1427d:	8b 40 04             	mov    0x4(%eax),%eax
   14280:	0f b6 00             	movzbl (%eax),%eax
   14283:	3c ff                	cmp    $0xff,%al
   14285:	74 0a                	je     14291 <_DecodeJPEG+0x84>
   14287:	b8 05 00 00 00       	mov    $0x5,%eax
   1428c:	e9 23 01 00 00       	jmp    143b4 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   14291:	6a 02                	push   $0x2
   14293:	ff 75 08             	pushl  0x8(%ebp)
   14296:	e8 a2 fe ff ff       	call   1413d <_Skip>
   1429b:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   1429e:	8b 45 08             	mov    0x8(%ebp),%eax
   142a1:	8b 40 04             	mov    0x4(%eax),%eax
   142a4:	83 e8 01             	sub    $0x1,%eax
   142a7:	0f b6 00             	movzbl (%eax),%eax
   142aa:	0f b6 c0             	movzbl %al,%eax
   142ad:	3d da 00 00 00       	cmp    $0xda,%eax
   142b2:	74 71                	je     14325 <_DecodeJPEG+0x118>
   142b4:	3d da 00 00 00       	cmp    $0xda,%eax
   142b9:	7f 10                	jg     142cb <_DecodeJPEG+0xbe>
   142bb:	3d c0 00 00 00       	cmp    $0xc0,%eax
   142c0:	74 20                	je     142e2 <_DecodeJPEG+0xd5>
   142c2:	3d c4 00 00 00       	cmp    $0xc4,%eax
   142c7:	74 2c                	je     142f5 <_DecodeJPEG+0xe8>
   142c9:	eb 7d                	jmp    14348 <_DecodeJPEG+0x13b>
   142cb:	3d dd 00 00 00       	cmp    $0xdd,%eax
   142d0:	74 43                	je     14315 <_DecodeJPEG+0x108>
   142d2:	3d fe 00 00 00       	cmp    $0xfe,%eax
   142d7:	74 5f                	je     14338 <_DecodeJPEG+0x12b>
   142d9:	3d db 00 00 00       	cmp    $0xdb,%eax
   142de:	74 25                	je     14305 <_DecodeJPEG+0xf8>
   142e0:	eb 66                	jmp    14348 <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   142e2:	83 ec 0c             	sub    $0xc,%esp
   142e5:	ff 75 08             	pushl  0x8(%ebp)
   142e8:	e8 c9 00 00 00       	call   143b6 <_DecodeSOF>
   142ed:	83 c4 10             	add    $0x10,%esp
   142f0:	e9 85 00 00 00       	jmp    1437a <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   142f5:	83 ec 0c             	sub    $0xc,%esp
   142f8:	ff 75 08             	pushl  0x8(%ebp)
   142fb:	e8 28 05 00 00       	call   14828 <_DecodeDHT>
   14300:	83 c4 10             	add    $0x10,%esp
   14303:	eb 75                	jmp    1437a <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   14305:	83 ec 0c             	sub    $0xc,%esp
   14308:	ff 75 08             	pushl  0x8(%ebp)
   1430b:	e8 05 07 00 00       	call   14a15 <_DecodeDQT>
   14310:	83 c4 10             	add    $0x10,%esp
   14313:	eb 65                	jmp    1437a <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   14315:	83 ec 0c             	sub    $0xc,%esp
   14318:	ff 75 08             	pushl  0x8(%ebp)
   1431b:	e8 ff 07 00 00       	call   14b1f <_DecodeDRI>
   14320:	83 c4 10             	add    $0x10,%esp
   14323:	eb 55                	jmp    1437a <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   14325:	83 ec 08             	sub    $0x8,%esp
   14328:	ff 75 0c             	pushl  0xc(%ebp)
   1432b:	ff 75 08             	pushl  0x8(%ebp)
   1432e:	e8 56 08 00 00       	call   14b89 <_DecodeSOS>
   14333:	83 c4 10             	add    $0x10,%esp
   14336:	eb 42                	jmp    1437a <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   14338:	83 ec 0c             	sub    $0xc,%esp
   1433b:	ff 75 08             	pushl  0x8(%ebp)
   1433e:	e8 a8 15 00 00       	call   158eb <_SkipMarker>
   14343:	83 c4 10             	add    $0x10,%esp
   14346:	eb 32                	jmp    1437a <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   14348:	8b 45 08             	mov    0x8(%ebp),%eax
   1434b:	8b 40 04             	mov    0x4(%eax),%eax
   1434e:	83 e8 01             	sub    $0x1,%eax
   14351:	0f b6 00             	movzbl (%eax),%eax
   14354:	0f b6 c0             	movzbl %al,%eax
   14357:	25 f0 00 00 00       	and    $0xf0,%eax
   1435c:	3d e0 00 00 00       	cmp    $0xe0,%eax
   14361:	75 10                	jne    14373 <_DecodeJPEG+0x166>
   14363:	83 ec 0c             	sub    $0xc,%esp
   14366:	ff 75 08             	pushl  0x8(%ebp)
   14369:	e8 7d 15 00 00       	call   158eb <_SkipMarker>
   1436e:	83 c4 10             	add    $0x10,%esp
   14371:	eb 07                	jmp    1437a <_DecodeJPEG+0x16d>
                else return Unsupported;
   14373:	b8 02 00 00 00       	mov    $0x2,%eax
   14378:	eb 3a                	jmp    143b4 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   1437a:	8b 45 08             	mov    0x8(%ebp),%eax
   1437d:	8b 00                	mov    (%eax),%eax
   1437f:	85 c0                	test   %eax,%eax
   14381:	0f 84 e9 fe ff ff    	je     14270 <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   14387:	8b 45 08             	mov    0x8(%ebp),%eax
   1438a:	8b 00                	mov    (%eax),%eax
   1438c:	83 f8 06             	cmp    $0x6,%eax
   1438f:	74 07                	je     14398 <_DecodeJPEG+0x18b>
   14391:	8b 45 08             	mov    0x8(%ebp),%eax
   14394:	8b 00                	mov    (%eax),%eax
   14396:	eb 1c                	jmp    143b4 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   14398:	8b 45 08             	mov    0x8(%ebp),%eax
   1439b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   143a1:	83 ec 0c             	sub    $0xc,%esp
   143a4:	ff 75 08             	pushl  0x8(%ebp)
   143a7:	e8 6b 15 00 00       	call   15917 <_Convert>
   143ac:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   143af:	8b 45 08             	mov    0x8(%ebp),%eax
   143b2:	8b 00                	mov    (%eax),%eax
 }
   143b4:	c9                   	leave  
   143b5:	c3                   	ret    

000143b6 <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   143b6:	55                   	push   %ebp
   143b7:	89 e5                	mov    %esp,%ebp
   143b9:	53                   	push   %ebx
   143ba:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   143bd:	83 ec 0c             	sub    $0xc,%esp
   143c0:	ff 75 08             	pushl  0x8(%ebp)
   143c3:	e8 c1 fd ff ff       	call   14189 <_DecodeLength>
   143c8:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   143cb:	8b 45 08             	mov    0x8(%ebp),%eax
   143ce:	8b 00                	mov    (%eax),%eax
   143d0:	85 c0                	test   %eax,%eax
   143d2:	0f 85 4a 04 00 00    	jne    14822 <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   143d8:	8b 45 08             	mov    0x8(%ebp),%eax
   143db:	8b 40 0c             	mov    0xc(%eax),%eax
   143de:	83 f8 08             	cmp    $0x8,%eax
   143e1:	7f 0e                	jg     143f1 <_DecodeSOF+0x3b>
   143e3:	8b 45 08             	mov    0x8(%ebp),%eax
   143e6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   143ec:	e9 32 04 00 00       	jmp    14823 <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   143f1:	8b 45 08             	mov    0x8(%ebp),%eax
   143f4:	8b 40 04             	mov    0x4(%eax),%eax
   143f7:	0f b6 00             	movzbl (%eax),%eax
   143fa:	3c 08                	cmp    $0x8,%al
   143fc:	74 0e                	je     1440c <_DecodeSOF+0x56>
   143fe:	8b 45 08             	mov    0x8(%ebp),%eax
   14401:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14407:	e9 17 04 00 00       	jmp    14823 <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   1440c:	8b 45 08             	mov    0x8(%ebp),%eax
   1440f:	8b 40 04             	mov    0x4(%eax),%eax
   14412:	83 c0 01             	add    $0x1,%eax
   14415:	83 ec 0c             	sub    $0xc,%esp
   14418:	50                   	push   %eax
   14419:	e8 ce fd ff ff       	call   141ec <_Decode2Bytes>
   1441e:	83 c4 10             	add    $0x10,%esp
   14421:	89 c2                	mov    %eax,%edx
   14423:	8b 45 08             	mov    0x8(%ebp),%eax
   14426:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   14429:	8b 45 08             	mov    0x8(%ebp),%eax
   1442c:	8b 40 04             	mov    0x4(%eax),%eax
   1442f:	83 c0 03             	add    $0x3,%eax
   14432:	83 ec 0c             	sub    $0xc,%esp
   14435:	50                   	push   %eax
   14436:	e8 b1 fd ff ff       	call   141ec <_Decode2Bytes>
   1443b:	83 c4 10             	add    $0x10,%esp
   1443e:	89 c2                	mov    %eax,%edx
   14440:	8b 45 08             	mov    0x8(%ebp),%eax
   14443:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   14446:	8b 45 08             	mov    0x8(%ebp),%eax
   14449:	8b 40 04             	mov    0x4(%eax),%eax
   1444c:	83 c0 05             	add    $0x5,%eax
   1444f:	0f b6 00             	movzbl (%eax),%eax
   14452:	0f b6 d0             	movzbl %al,%edx
   14455:	8b 45 08             	mov    0x8(%ebp),%eax
   14458:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   1445b:	83 ec 08             	sub    $0x8,%esp
   1445e:	6a 06                	push   $0x6
   14460:	ff 75 08             	pushl  0x8(%ebp)
   14463:	e8 d5 fc ff ff       	call   1413d <_Skip>
   14468:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   1446b:	8b 45 08             	mov    0x8(%ebp),%eax
   1446e:	8b 40 28             	mov    0x28(%eax),%eax
   14471:	83 f8 01             	cmp    $0x1,%eax
   14474:	74 13                	je     14489 <_DecodeSOF+0xd3>
   14476:	83 f8 03             	cmp    $0x3,%eax
   14479:	74 0e                	je     14489 <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   1447b:	8b 45 08             	mov    0x8(%ebp),%eax
   1447e:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14484:	e9 9a 03 00 00       	jmp    14823 <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   14489:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   1448a:	8b 45 08             	mov    0x8(%ebp),%eax
   1448d:	8b 48 0c             	mov    0xc(%eax),%ecx
   14490:	8b 45 08             	mov    0x8(%ebp),%eax
   14493:	8b 50 28             	mov    0x28(%eax),%edx
   14496:	89 d0                	mov    %edx,%eax
   14498:	01 c0                	add    %eax,%eax
   1449a:	01 d0                	add    %edx,%eax
   1449c:	39 c1                	cmp    %eax,%ecx
   1449e:	7d 0e                	jge    144ae <_DecodeSOF+0xf8>
   144a0:	8b 45 08             	mov    0x8(%ebp),%eax
   144a3:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   144a9:	e9 75 03 00 00       	jmp    14823 <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   144ae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   144b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   144bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   144c3:	8b 45 08             	mov    0x8(%ebp),%eax
   144c6:	83 c0 2c             	add    $0x2c,%eax
   144c9:	89 45 e8             	mov    %eax,-0x18(%ebp)
   144cc:	e9 50 01 00 00       	jmp    14621 <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   144d1:	8b 45 08             	mov    0x8(%ebp),%eax
   144d4:	8b 40 04             	mov    0x4(%eax),%eax
   144d7:	0f b6 00             	movzbl (%eax),%eax
   144da:	0f b6 d0             	movzbl %al,%edx
   144dd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   144e0:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   144e2:	8b 45 08             	mov    0x8(%ebp),%eax
   144e5:	8b 40 04             	mov    0x4(%eax),%eax
   144e8:	83 c0 01             	add    $0x1,%eax
   144eb:	0f b6 00             	movzbl (%eax),%eax
   144ee:	c0 e8 04             	shr    $0x4,%al
   144f1:	0f b6 d0             	movzbl %al,%edx
   144f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   144f7:	89 50 04             	mov    %edx,0x4(%eax)
   144fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   144fd:	8b 40 04             	mov    0x4(%eax),%eax
   14500:	85 c0                	test   %eax,%eax
   14502:	75 0e                	jne    14512 <_DecodeSOF+0x15c>
   14504:	8b 45 08             	mov    0x8(%ebp),%eax
   14507:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1450d:	e9 11 03 00 00       	jmp    14823 <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   14512:	8b 45 08             	mov    0x8(%ebp),%eax
   14515:	8b 40 04             	mov    0x4(%eax),%eax
   14518:	83 c0 01             	add    $0x1,%eax
   1451b:	0f b6 00             	movzbl (%eax),%eax
   1451e:	0f b6 c0             	movzbl %al,%eax
   14521:	83 e0 0f             	and    $0xf,%eax
   14524:	89 c2                	mov    %eax,%edx
   14526:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14529:	89 50 08             	mov    %edx,0x8(%eax)
   1452c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1452f:	8b 40 08             	mov    0x8(%eax),%eax
   14532:	85 c0                	test   %eax,%eax
   14534:	75 0e                	jne    14544 <_DecodeSOF+0x18e>
   14536:	8b 45 08             	mov    0x8(%ebp),%eax
   14539:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1453f:	e9 df 02 00 00       	jmp    14823 <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   14544:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14547:	8b 50 04             	mov    0x4(%eax),%edx
   1454a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1454d:	8b 40 04             	mov    0x4(%eax),%eax
   14550:	83 e8 01             	sub    $0x1,%eax
   14553:	21 d0                	and    %edx,%eax
   14555:	85 c0                	test   %eax,%eax
   14557:	74 0e                	je     14567 <_DecodeSOF+0x1b1>
   14559:	8b 45 08             	mov    0x8(%ebp),%eax
   1455c:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14562:	e9 bc 02 00 00       	jmp    14823 <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   14567:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1456a:	8b 50 08             	mov    0x8(%eax),%edx
   1456d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14570:	8b 40 08             	mov    0x8(%eax),%eax
   14573:	83 e8 01             	sub    $0x1,%eax
   14576:	21 d0                	and    %edx,%eax
   14578:	85 c0                	test   %eax,%eax
   1457a:	74 0e                	je     1458a <_DecodeSOF+0x1d4>
   1457c:	8b 45 08             	mov    0x8(%ebp),%eax
   1457f:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14585:	e9 99 02 00 00       	jmp    14823 <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   1458a:	8b 45 08             	mov    0x8(%ebp),%eax
   1458d:	8b 40 04             	mov    0x4(%eax),%eax
   14590:	83 c0 02             	add    $0x2,%eax
   14593:	0f b6 00             	movzbl (%eax),%eax
   14596:	0f b6 d0             	movzbl %al,%edx
   14599:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1459c:	89 50 18             	mov    %edx,0x18(%eax)
   1459f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   145a2:	8b 40 18             	mov    0x18(%eax),%eax
   145a5:	25 fc 00 00 00       	and    $0xfc,%eax
   145aa:	85 c0                	test   %eax,%eax
   145ac:	74 0e                	je     145bc <_DecodeSOF+0x206>
   145ae:	8b 45 08             	mov    0x8(%ebp),%eax
   145b1:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   145b7:	e9 67 02 00 00       	jmp    14823 <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   145bc:	83 ec 08             	sub    $0x8,%esp
   145bf:	6a 03                	push   $0x3
   145c1:	ff 75 08             	pushl  0x8(%ebp)
   145c4:	e8 74 fb ff ff       	call   1413d <_Skip>
   145c9:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   145cc:	8b 45 08             	mov    0x8(%ebp),%eax
   145cf:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   145d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   145d8:	8b 40 18             	mov    0x18(%eax),%eax
   145db:	bb 01 00 00 00       	mov    $0x1,%ebx
   145e0:	89 c1                	mov    %eax,%ecx
   145e2:	d3 e3                	shl    %cl,%ebx
   145e4:	89 d8                	mov    %ebx,%eax
   145e6:	09 c2                	or     %eax,%edx
   145e8:	8b 45 08             	mov    0x8(%ebp),%eax
   145eb:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   145f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   145f4:	8b 40 04             	mov    0x4(%eax),%eax
   145f7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   145fa:	7e 09                	jle    14605 <_DecodeSOF+0x24f>
   145fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   145ff:	8b 40 04             	mov    0x4(%eax),%eax
   14602:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   14605:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14608:	8b 40 08             	mov    0x8(%eax),%eax
   1460b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1460e:	7e 09                	jle    14619 <_DecodeSOF+0x263>
   14610:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14613:	8b 40 08             	mov    0x8(%eax),%eax
   14616:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14619:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1461d:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   14621:	8b 45 08             	mov    0x8(%ebp),%eax
   14624:	8b 40 28             	mov    0x28(%eax),%eax
   14627:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1462a:	0f 8f a1 fe ff ff    	jg     144d1 <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   14630:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14633:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1463a:	8b 45 08             	mov    0x8(%ebp),%eax
   1463d:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   14640:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14643:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1464a:	8b 45 08             	mov    0x8(%ebp),%eax
   1464d:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   14650:	8b 45 08             	mov    0x8(%ebp),%eax
   14653:	8b 50 10             	mov    0x10(%eax),%edx
   14656:	8b 45 08             	mov    0x8(%ebp),%eax
   14659:	8b 40 20             	mov    0x20(%eax),%eax
   1465c:	01 d0                	add    %edx,%eax
   1465e:	8d 48 ff             	lea    -0x1(%eax),%ecx
   14661:	8b 45 08             	mov    0x8(%ebp),%eax
   14664:	8b 58 20             	mov    0x20(%eax),%ebx
   14667:	89 c8                	mov    %ecx,%eax
   14669:	99                   	cltd   
   1466a:	f7 fb                	idiv   %ebx
   1466c:	89 c2                	mov    %eax,%edx
   1466e:	8b 45 08             	mov    0x8(%ebp),%eax
   14671:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   14674:	8b 45 08             	mov    0x8(%ebp),%eax
   14677:	8b 50 14             	mov    0x14(%eax),%edx
   1467a:	8b 45 08             	mov    0x8(%ebp),%eax
   1467d:	8b 40 24             	mov    0x24(%eax),%eax
   14680:	01 d0                	add    %edx,%eax
   14682:	8d 48 ff             	lea    -0x1(%eax),%ecx
   14685:	8b 45 08             	mov    0x8(%ebp),%eax
   14688:	8b 58 24             	mov    0x24(%eax),%ebx
   1468b:	89 c8                	mov    %ecx,%eax
   1468d:	99                   	cltd   
   1468e:	f7 fb                	idiv   %ebx
   14690:	89 c2                	mov    %eax,%edx
   14692:	8b 45 08             	mov    0x8(%ebp),%eax
   14695:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   14698:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1469f:	8b 45 08             	mov    0x8(%ebp),%eax
   146a2:	83 c0 2c             	add    $0x2c,%eax
   146a5:	89 45 e8             	mov    %eax,-0x18(%ebp)
   146a8:	e9 fd 00 00 00       	jmp    147aa <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   146ad:	8b 45 08             	mov    0x8(%ebp),%eax
   146b0:	8b 50 10             	mov    0x10(%eax),%edx
   146b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146b6:	8b 40 04             	mov    0x4(%eax),%eax
   146b9:	0f af d0             	imul   %eax,%edx
   146bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   146bf:	01 d0                	add    %edx,%eax
   146c1:	83 e8 01             	sub    $0x1,%eax
   146c4:	99                   	cltd   
   146c5:	f7 7d ec             	idivl  -0x14(%ebp)
   146c8:	89 c2                	mov    %eax,%edx
   146ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146cd:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   146d0:	8b 45 08             	mov    0x8(%ebp),%eax
   146d3:	8b 50 14             	mov    0x14(%eax),%edx
   146d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146d9:	8b 40 08             	mov    0x8(%eax),%eax
   146dc:	0f af d0             	imul   %eax,%edx
   146df:	8b 45 f0             	mov    -0x10(%ebp),%eax
   146e2:	01 d0                	add    %edx,%eax
   146e4:	83 e8 01             	sub    $0x1,%eax
   146e7:	99                   	cltd   
   146e8:	f7 7d f0             	idivl  -0x10(%ebp)
   146eb:	89 c2                	mov    %eax,%edx
   146ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146f0:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   146f3:	8b 45 08             	mov    0x8(%ebp),%eax
   146f6:	8b 50 18             	mov    0x18(%eax),%edx
   146f9:	8b 45 08             	mov    0x8(%ebp),%eax
   146fc:	8b 40 20             	mov    0x20(%eax),%eax
   146ff:	0f af d0             	imul   %eax,%edx
   14702:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14705:	8b 40 04             	mov    0x4(%eax),%eax
   14708:	0f af c2             	imul   %edx,%eax
   1470b:	99                   	cltd   
   1470c:	f7 7d ec             	idivl  -0x14(%ebp)
   1470f:	89 c2                	mov    %eax,%edx
   14711:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14714:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   14717:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1471a:	8b 40 0c             	mov    0xc(%eax),%eax
   1471d:	83 f8 02             	cmp    $0x2,%eax
   14720:	7f 0b                	jg     1472d <_DecodeSOF+0x377>
   14722:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14725:	8b 40 04             	mov    0x4(%eax),%eax
   14728:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1472b:	75 16                	jne    14743 <_DecodeSOF+0x38d>
   1472d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14730:	8b 40 10             	mov    0x10(%eax),%eax
   14733:	83 f8 02             	cmp    $0x2,%eax
   14736:	7f 19                	jg     14751 <_DecodeSOF+0x39b>
   14738:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1473b:	8b 40 08             	mov    0x8(%eax),%eax
   1473e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14741:	74 0e                	je     14751 <_DecodeSOF+0x39b>
   14743:	8b 45 08             	mov    0x8(%ebp),%eax
   14746:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1474c:	e9 d2 00 00 00       	jmp    14823 <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   14751:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14754:	8b 48 14             	mov    0x14(%eax),%ecx
   14757:	8b 45 08             	mov    0x8(%ebp),%eax
   1475a:	8b 50 1c             	mov    0x1c(%eax),%edx
   1475d:	8b 45 08             	mov    0x8(%ebp),%eax
   14760:	8b 40 24             	mov    0x24(%eax),%eax
   14763:	0f af d0             	imul   %eax,%edx
   14766:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14769:	8b 40 08             	mov    0x8(%eax),%eax
   1476c:	0f af c2             	imul   %edx,%eax
   1476f:	99                   	cltd   
   14770:	f7 7d f0             	idivl  -0x10(%ebp)
   14773:	0f af c1             	imul   %ecx,%eax
   14776:	83 ec 0c             	sub    $0xc,%esp
   14779:	50                   	push   %eax
   1477a:	e8 45 c5 fe ff       	call   cc4 <malloc>
   1477f:	83 c4 10             	add    $0x10,%esp
   14782:	89 c2                	mov    %eax,%edx
   14784:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14787:	89 50 28             	mov    %edx,0x28(%eax)
   1478a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1478d:	8b 40 28             	mov    0x28(%eax),%eax
   14790:	85 c0                	test   %eax,%eax
   14792:	75 0e                	jne    147a2 <_DecodeSOF+0x3ec>
   14794:	8b 45 08             	mov    0x8(%ebp),%eax
   14797:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1479d:	e9 81 00 00 00       	jmp    14823 <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   147a2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   147a6:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   147aa:	8b 45 08             	mov    0x8(%ebp),%eax
   147ad:	8b 40 28             	mov    0x28(%eax),%eax
   147b0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   147b3:	0f 8f f4 fe ff ff    	jg     146ad <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   147b9:	8b 45 08             	mov    0x8(%ebp),%eax
   147bc:	8b 40 28             	mov    0x28(%eax),%eax
   147bf:	83 f8 03             	cmp    $0x3,%eax
   147c2:	75 47                	jne    1480b <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   147c4:	8b 45 08             	mov    0x8(%ebp),%eax
   147c7:	8b 50 10             	mov    0x10(%eax),%edx
   147ca:	8b 45 08             	mov    0x8(%ebp),%eax
   147cd:	8b 40 14             	mov    0x14(%eax),%eax
   147d0:	0f af d0             	imul   %eax,%edx
   147d3:	8b 45 08             	mov    0x8(%ebp),%eax
   147d6:	8b 40 28             	mov    0x28(%eax),%eax
   147d9:	0f af c2             	imul   %edx,%eax
   147dc:	83 ec 0c             	sub    $0xc,%esp
   147df:	50                   	push   %eax
   147e0:	e8 df c4 fe ff       	call   cc4 <malloc>
   147e5:	83 c4 10             	add    $0x10,%esp
   147e8:	89 c2                	mov    %eax,%edx
   147ea:	8b 45 08             	mov    0x8(%ebp),%eax
   147ed:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   147f3:	8b 45 08             	mov    0x8(%ebp),%eax
   147f6:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   147fc:	85 c0                	test   %eax,%eax
   147fe:	75 0b                	jne    1480b <_DecodeSOF+0x455>
   14800:	8b 45 08             	mov    0x8(%ebp),%eax
   14803:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   14809:	eb 18                	jmp    14823 <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   1480b:	8b 45 08             	mov    0x8(%ebp),%eax
   1480e:	8b 40 0c             	mov    0xc(%eax),%eax
   14811:	83 ec 08             	sub    $0x8,%esp
   14814:	50                   	push   %eax
   14815:	ff 75 08             	pushl  0x8(%ebp)
   14818:	e8 20 f9 ff ff       	call   1413d <_Skip>
   1481d:	83 c4 10             	add    $0x10,%esp
   14820:	eb 01                	jmp    14823 <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   14822:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   14823:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14826:	c9                   	leave  
   14827:	c3                   	ret    

00014828 <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   14828:	55                   	push   %ebp
   14829:	89 e5                	mov    %esp,%ebp
   1482b:	53                   	push   %ebx
   1482c:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   1482f:	83 ec 0c             	sub    $0xc,%esp
   14832:	ff 75 08             	pushl  0x8(%ebp)
   14835:	e8 4f f9 ff ff       	call   14189 <_DecodeLength>
   1483a:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1483d:	8b 45 08             	mov    0x8(%ebp),%eax
   14840:	8b 00                	mov    (%eax),%eax
   14842:	85 c0                	test   %eax,%eax
   14844:	0f 85 c5 01 00 00    	jne    14a0f <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   1484a:	e9 9c 01 00 00       	jmp    149eb <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   1484f:	8b 45 08             	mov    0x8(%ebp),%eax
   14852:	8b 40 04             	mov    0x4(%eax),%eax
   14855:	0f b6 00             	movzbl (%eax),%eax
   14858:	0f b6 c0             	movzbl %al,%eax
   1485b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   1485e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14861:	25 ec 00 00 00       	and    $0xec,%eax
   14866:	85 c0                	test   %eax,%eax
   14868:	74 0e                	je     14878 <_DecodeDHT+0x50>
   1486a:	8b 45 08             	mov    0x8(%ebp),%eax
   1486d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14873:	e9 98 01 00 00       	jmp    14a10 <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   14878:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1487b:	83 e0 02             	and    $0x2,%eax
   1487e:	85 c0                	test   %eax,%eax
   14880:	74 0e                	je     14890 <_DecodeDHT+0x68>
   14882:	8b 45 08             	mov    0x8(%ebp),%eax
   14885:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1488b:	e9 80 01 00 00       	jmp    14a10 <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   14890:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14893:	c1 f8 03             	sar    $0x3,%eax
   14896:	0b 45 f4             	or     -0xc(%ebp),%eax
   14899:	83 e0 03             	and    $0x3,%eax
   1489c:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   1489f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   148a6:	eb 1c                	jmp    148c4 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   148a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   148ab:	8d 50 ff             	lea    -0x1(%eax),%edx
   148ae:	8b 45 08             	mov    0x8(%ebp),%eax
   148b1:	8b 48 04             	mov    0x4(%eax),%ecx
   148b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   148b7:	01 c8                	add    %ecx,%eax
   148b9:	0f b6 00             	movzbl (%eax),%eax
   148bc:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   148c0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   148c4:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   148c8:	7e de                	jle    148a8 <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   148ca:	83 ec 08             	sub    $0x8,%esp
   148cd:	6a 11                	push   $0x11
   148cf:	ff 75 08             	pushl  0x8(%ebp)
   148d2:	e8 66 f8 ff ff       	call   1413d <_Skip>
   148d7:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   148da:	8b 45 f4             	mov    -0xc(%ebp),%eax
   148dd:	c1 e0 11             	shl    $0x11,%eax
   148e0:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   148e6:	8b 45 08             	mov    0x8(%ebp),%eax
   148e9:	01 d0                	add    %edx,%eax
   148eb:	83 c0 08             	add    $0x8,%eax
   148ee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   148f1:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   148f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   148fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   148fe:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14905:	e9 be 00 00 00       	jmp    149c8 <_DecodeDHT+0x1a0>
            spread >>= 1;
   1490a:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   1490d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14910:	83 e8 01             	sub    $0x1,%eax
   14913:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   14918:	0f b6 c0             	movzbl %al,%eax
   1491b:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   1491e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14922:	0f 84 9b 00 00 00    	je     149c3 <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   14928:	8b 45 08             	mov    0x8(%ebp),%eax
   1492b:	8b 40 0c             	mov    0xc(%eax),%eax
   1492e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   14931:	7d 0e                	jge    14941 <_DecodeDHT+0x119>
   14933:	8b 45 08             	mov    0x8(%ebp),%eax
   14936:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1493c:	e9 cf 00 00 00       	jmp    14a10 <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   14941:	b8 10 00 00 00       	mov    $0x10,%eax
   14946:	2b 45 f0             	sub    -0x10(%ebp),%eax
   14949:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1494c:	89 c1                	mov    %eax,%ecx
   1494e:	d3 e2                	shl    %cl,%edx
   14950:	89 d0                	mov    %edx,%eax
   14952:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   14955:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14959:	79 0e                	jns    14969 <_DecodeDHT+0x141>
   1495b:	8b 45 08             	mov    0x8(%ebp),%eax
   1495e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14964:	e9 a7 00 00 00       	jmp    14a10 <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   14969:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14970:	eb 36                	jmp    149a8 <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   14972:	8b 45 08             	mov    0x8(%ebp),%eax
   14975:	8b 50 04             	mov    0x4(%eax),%edx
   14978:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1497b:	01 d0                	add    %edx,%eax
   1497d:	0f b6 00             	movzbl (%eax),%eax
   14980:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   14982:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   14985:	eb 14                	jmp    1499b <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   14987:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1498a:	89 c2                	mov    %eax,%edx
   1498c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1498f:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   14991:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14994:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   14997:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   1499b:	89 d8                	mov    %ebx,%eax
   1499d:	8d 58 ff             	lea    -0x1(%eax),%ebx
   149a0:	85 c0                	test   %eax,%eax
   149a2:	75 e3                	jne    14987 <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   149a4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   149a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   149ab:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   149ae:	7c c2                	jl     14972 <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   149b0:	83 ec 08             	sub    $0x8,%esp
   149b3:	ff 75 e0             	pushl  -0x20(%ebp)
   149b6:	ff 75 08             	pushl  0x8(%ebp)
   149b9:	e8 7f f7 ff ff       	call   1413d <_Skip>
   149be:	83 c4 10             	add    $0x10,%esp
   149c1:	eb 01                	jmp    149c4 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   149c3:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   149c4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   149c8:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   149cc:	0f 8e 38 ff ff ff    	jle    1490a <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   149d2:	eb 0a                	jmp    149de <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   149d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   149d7:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   149da:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   149de:	8b 45 ec             	mov    -0x14(%ebp),%eax
   149e1:	8d 50 ff             	lea    -0x1(%eax),%edx
   149e4:	89 55 ec             	mov    %edx,-0x14(%ebp)
   149e7:	85 c0                	test   %eax,%eax
   149e9:	75 e9                	jne    149d4 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   149eb:	8b 45 08             	mov    0x8(%ebp),%eax
   149ee:	8b 40 0c             	mov    0xc(%eax),%eax
   149f1:	83 f8 10             	cmp    $0x10,%eax
   149f4:	0f 8f 55 fe ff ff    	jg     1484f <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   149fa:	8b 45 08             	mov    0x8(%ebp),%eax
   149fd:	8b 40 0c             	mov    0xc(%eax),%eax
   14a00:	85 c0                	test   %eax,%eax
   14a02:	74 0c                	je     14a10 <_DecodeDHT+0x1e8>
   14a04:	8b 45 08             	mov    0x8(%ebp),%eax
   14a07:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a0d:	eb 01                	jmp    14a10 <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   14a0f:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14a10:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14a13:	c9                   	leave  
   14a14:	c3                   	ret    

00014a15 <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   14a15:	55                   	push   %ebp
   14a16:	89 e5                	mov    %esp,%ebp
   14a18:	53                   	push   %ebx
   14a19:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   14a1c:	83 ec 0c             	sub    $0xc,%esp
   14a1f:	ff 75 08             	pushl  0x8(%ebp)
   14a22:	e8 62 f7 ff ff       	call   14189 <_DecodeLength>
   14a27:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14a2a:	8b 45 08             	mov    0x8(%ebp),%eax
   14a2d:	8b 00                	mov    (%eax),%eax
   14a2f:	85 c0                	test   %eax,%eax
   14a31:	0f 85 e2 00 00 00    	jne    14b19 <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   14a37:	e9 b8 00 00 00       	jmp    14af4 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   14a3c:	8b 45 08             	mov    0x8(%ebp),%eax
   14a3f:	8b 40 04             	mov    0x4(%eax),%eax
   14a42:	0f b6 00             	movzbl (%eax),%eax
   14a45:	0f b6 c0             	movzbl %al,%eax
   14a48:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   14a4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a4e:	25 ec 00 00 00       	and    $0xec,%eax
   14a53:	85 c0                	test   %eax,%eax
   14a55:	74 0e                	je     14a65 <_DecodeDQT+0x50>
   14a57:	8b 45 08             	mov    0x8(%ebp),%eax
   14a5a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a60:	e9 b5 00 00 00       	jmp    14b1a <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   14a65:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a68:	83 e0 10             	and    $0x10,%eax
   14a6b:	85 c0                	test   %eax,%eax
   14a6d:	74 0e                	je     14a7d <_DecodeDQT+0x68>
   14a6f:	8b 45 08             	mov    0x8(%ebp),%eax
   14a72:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14a78:	e9 9d 00 00 00       	jmp    14b1a <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   14a7d:	8b 45 08             	mov    0x8(%ebp),%eax
   14a80:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   14a86:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a89:	bb 01 00 00 00       	mov    $0x1,%ebx
   14a8e:	89 c1                	mov    %eax,%ecx
   14a90:	d3 e3                	shl    %cl,%ebx
   14a92:	89 d8                	mov    %ebx,%eax
   14a94:	09 c2                	or     %eax,%edx
   14a96:	8b 45 08             	mov    0x8(%ebp),%eax
   14a99:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   14a9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14aa2:	c1 e0 06             	shl    $0x6,%eax
   14aa5:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   14aab:	8b 45 08             	mov    0x8(%ebp),%eax
   14aae:	01 d0                	add    %edx,%eax
   14ab0:	83 c0 08             	add    $0x8,%eax
   14ab3:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   14ab6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14abd:	eb 1f                	jmp    14ade <_DecodeDQT+0xc9>
   14abf:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14ac2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ac5:	01 c2                	add    %eax,%edx
   14ac7:	8b 45 08             	mov    0x8(%ebp),%eax
   14aca:	8b 40 04             	mov    0x4(%eax),%eax
   14acd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14ad0:	83 c1 01             	add    $0x1,%ecx
   14ad3:	01 c8                	add    %ecx,%eax
   14ad5:	0f b6 00             	movzbl (%eax),%eax
   14ad8:	88 02                	mov    %al,(%edx)
   14ada:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14ade:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14ae2:	7e db                	jle    14abf <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   14ae4:	83 ec 08             	sub    $0x8,%esp
   14ae7:	6a 41                	push   $0x41
   14ae9:	ff 75 08             	pushl  0x8(%ebp)
   14aec:	e8 4c f6 ff ff       	call   1413d <_Skip>
   14af1:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   14af4:	8b 45 08             	mov    0x8(%ebp),%eax
   14af7:	8b 40 0c             	mov    0xc(%eax),%eax
   14afa:	83 f8 40             	cmp    $0x40,%eax
   14afd:	0f 8f 39 ff ff ff    	jg     14a3c <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14b03:	8b 45 08             	mov    0x8(%ebp),%eax
   14b06:	8b 40 0c             	mov    0xc(%eax),%eax
   14b09:	85 c0                	test   %eax,%eax
   14b0b:	74 0d                	je     14b1a <_DecodeDQT+0x105>
   14b0d:	8b 45 08             	mov    0x8(%ebp),%eax
   14b10:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14b16:	90                   	nop
   14b17:	eb 01                	jmp    14b1a <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   14b19:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14b1a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14b1d:	c9                   	leave  
   14b1e:	c3                   	ret    

00014b1f <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   14b1f:	55                   	push   %ebp
   14b20:	89 e5                	mov    %esp,%ebp
   14b22:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   14b25:	83 ec 0c             	sub    $0xc,%esp
   14b28:	ff 75 08             	pushl  0x8(%ebp)
   14b2b:	e8 59 f6 ff ff       	call   14189 <_DecodeLength>
   14b30:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14b33:	8b 45 08             	mov    0x8(%ebp),%eax
   14b36:	8b 00                	mov    (%eax),%eax
   14b38:	85 c0                	test   %eax,%eax
   14b3a:	75 4a                	jne    14b86 <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   14b3c:	8b 45 08             	mov    0x8(%ebp),%eax
   14b3f:	8b 40 0c             	mov    0xc(%eax),%eax
   14b42:	83 f8 01             	cmp    $0x1,%eax
   14b45:	7f 0b                	jg     14b52 <_DecodeDRI+0x33>
   14b47:	8b 45 08             	mov    0x8(%ebp),%eax
   14b4a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14b50:	eb 35                	jmp    14b87 <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   14b52:	8b 45 08             	mov    0x8(%ebp),%eax
   14b55:	8b 40 04             	mov    0x4(%eax),%eax
   14b58:	83 ec 0c             	sub    $0xc,%esp
   14b5b:	50                   	push   %eax
   14b5c:	e8 8b f6 ff ff       	call   141ec <_Decode2Bytes>
   14b61:	83 c4 10             	add    $0x10,%esp
   14b64:	89 c2                	mov    %eax,%edx
   14b66:	8b 45 08             	mov    0x8(%ebp),%eax
   14b69:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   14b6f:	8b 45 08             	mov    0x8(%ebp),%eax
   14b72:	8b 40 0c             	mov    0xc(%eax),%eax
   14b75:	83 ec 08             	sub    $0x8,%esp
   14b78:	50                   	push   %eax
   14b79:	ff 75 08             	pushl  0x8(%ebp)
   14b7c:	e8 bc f5 ff ff       	call   1413d <_Skip>
   14b81:	83 c4 10             	add    $0x10,%esp
   14b84:	eb 01                	jmp    14b87 <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   14b86:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   14b87:	c9                   	leave  
   14b88:	c3                   	ret    

00014b89 <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   14b89:	55                   	push   %ebp
   14b8a:	89 e5                	mov    %esp,%ebp
   14b8c:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   14b8f:	8b 45 08             	mov    0x8(%ebp),%eax
   14b92:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14b98:	89 45 e0             	mov    %eax,-0x20(%ebp)
   14b9b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   14ba2:	83 ec 0c             	sub    $0xc,%esp
   14ba5:	ff 75 08             	pushl  0x8(%ebp)
   14ba8:	e8 dc f5 ff ff       	call   14189 <_DecodeLength>
   14bad:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14bb0:	8b 45 08             	mov    0x8(%ebp),%eax
   14bb3:	8b 00                	mov    (%eax),%eax
   14bb5:	85 c0                	test   %eax,%eax
   14bb7:	0f 85 c2 02 00 00    	jne    14e7f <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   14bbd:	8b 45 08             	mov    0x8(%ebp),%eax
   14bc0:	8b 50 0c             	mov    0xc(%eax),%edx
   14bc3:	8b 45 08             	mov    0x8(%ebp),%eax
   14bc6:	8b 40 28             	mov    0x28(%eax),%eax
   14bc9:	83 c0 02             	add    $0x2,%eax
   14bcc:	01 c0                	add    %eax,%eax
   14bce:	39 c2                	cmp    %eax,%edx
   14bd0:	7c 16                	jl     14be8 <_DecodeSOS+0x5f>
   14bd2:	8b 45 08             	mov    0x8(%ebp),%eax
   14bd5:	8b 40 04             	mov    0x4(%eax),%eax
   14bd8:	0f b6 00             	movzbl (%eax),%eax
   14bdb:	0f b6 d0             	movzbl %al,%edx
   14bde:	8b 45 08             	mov    0x8(%ebp),%eax
   14be1:	8b 40 28             	mov    0x28(%eax),%eax
   14be4:	39 c2                	cmp    %eax,%edx
   14be6:	74 0e                	je     14bf6 <_DecodeSOS+0x6d>
   14be8:	8b 45 08             	mov    0x8(%ebp),%eax
   14beb:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14bf1:	e9 8d 02 00 00       	jmp    14e83 <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   14bf6:	83 ec 08             	sub    $0x8,%esp
   14bf9:	6a 01                	push   $0x1
   14bfb:	ff 75 08             	pushl  0x8(%ebp)
   14bfe:	e8 3a f5 ff ff       	call   1413d <_Skip>
   14c03:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14c06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14c0d:	8b 45 08             	mov    0x8(%ebp),%eax
   14c10:	83 c0 2c             	add    $0x2c,%eax
   14c13:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14c16:	e9 ba 00 00 00       	jmp    14cd5 <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   14c1b:	8b 45 08             	mov    0x8(%ebp),%eax
   14c1e:	8b 40 04             	mov    0x4(%eax),%eax
   14c21:	0f b6 00             	movzbl (%eax),%eax
   14c24:	0f b6 d0             	movzbl %al,%edx
   14c27:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14c2a:	8b 00                	mov    (%eax),%eax
   14c2c:	39 c2                	cmp    %eax,%edx
   14c2e:	74 0e                	je     14c3e <_DecodeSOS+0xb5>
   14c30:	8b 45 08             	mov    0x8(%ebp),%eax
   14c33:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14c39:	e9 45 02 00 00       	jmp    14e83 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   14c3e:	8b 45 08             	mov    0x8(%ebp),%eax
   14c41:	8b 40 04             	mov    0x4(%eax),%eax
   14c44:	83 c0 01             	add    $0x1,%eax
   14c47:	0f b6 00             	movzbl (%eax),%eax
   14c4a:	0f b6 c0             	movzbl %al,%eax
   14c4d:	25 ec 00 00 00       	and    $0xec,%eax
   14c52:	85 c0                	test   %eax,%eax
   14c54:	74 0e                	je     14c64 <_DecodeSOS+0xdb>
   14c56:	8b 45 08             	mov    0x8(%ebp),%eax
   14c59:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14c5f:	e9 1f 02 00 00       	jmp    14e83 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   14c64:	8b 45 08             	mov    0x8(%ebp),%eax
   14c67:	8b 40 04             	mov    0x4(%eax),%eax
   14c6a:	83 c0 01             	add    $0x1,%eax
   14c6d:	0f b6 00             	movzbl (%eax),%eax
   14c70:	0f b6 c0             	movzbl %al,%eax
   14c73:	83 e0 02             	and    $0x2,%eax
   14c76:	85 c0                	test   %eax,%eax
   14c78:	74 0e                	je     14c88 <_DecodeSOS+0xff>
   14c7a:	8b 45 08             	mov    0x8(%ebp),%eax
   14c7d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14c83:	e9 fb 01 00 00       	jmp    14e83 <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   14c88:	8b 45 08             	mov    0x8(%ebp),%eax
   14c8b:	8b 40 04             	mov    0x4(%eax),%eax
   14c8e:	83 c0 01             	add    $0x1,%eax
   14c91:	0f b6 00             	movzbl (%eax),%eax
   14c94:	c0 e8 04             	shr    $0x4,%al
   14c97:	0f b6 d0             	movzbl %al,%edx
   14c9a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14c9d:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   14ca0:	8b 45 08             	mov    0x8(%ebp),%eax
   14ca3:	8b 40 04             	mov    0x4(%eax),%eax
   14ca6:	83 c0 01             	add    $0x1,%eax
   14ca9:	0f b6 00             	movzbl (%eax),%eax
   14cac:	0f b6 c0             	movzbl %al,%eax
   14caf:	83 e0 01             	and    $0x1,%eax
   14cb2:	83 c8 02             	or     $0x2,%eax
   14cb5:	89 c2                	mov    %eax,%edx
   14cb7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14cba:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   14cbd:	83 ec 08             	sub    $0x8,%esp
   14cc0:	6a 02                	push   $0x2
   14cc2:	ff 75 08             	pushl  0x8(%ebp)
   14cc5:	e8 73 f4 ff ff       	call   1413d <_Skip>
   14cca:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14ccd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14cd1:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14cd5:	8b 45 08             	mov    0x8(%ebp),%eax
   14cd8:	8b 40 28             	mov    0x28(%eax),%eax
   14cdb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14cde:	0f 8f 37 ff ff ff    	jg     14c1b <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   14ce4:	8b 45 08             	mov    0x8(%ebp),%eax
   14ce7:	8b 40 04             	mov    0x4(%eax),%eax
   14cea:	0f b6 00             	movzbl (%eax),%eax
   14ced:	84 c0                	test   %al,%al
   14cef:	75 10                	jne    14d01 <_DecodeSOS+0x178>
   14cf1:	8b 45 08             	mov    0x8(%ebp),%eax
   14cf4:	8b 40 04             	mov    0x4(%eax),%eax
   14cf7:	83 c0 01             	add    $0x1,%eax
   14cfa:	0f b6 00             	movzbl (%eax),%eax
   14cfd:	3c 3f                	cmp    $0x3f,%al
   14cff:	74 0e                	je     14d0f <_DecodeSOS+0x186>
   14d01:	8b 45 08             	mov    0x8(%ebp),%eax
   14d04:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14d0a:	e9 74 01 00 00       	jmp    14e83 <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   14d0f:	8b 45 08             	mov    0x8(%ebp),%eax
   14d12:	8b 40 04             	mov    0x4(%eax),%eax
   14d15:	83 c0 02             	add    $0x2,%eax
   14d18:	0f b6 00             	movzbl (%eax),%eax
   14d1b:	84 c0                	test   %al,%al
   14d1d:	74 0e                	je     14d2d <_DecodeSOS+0x1a4>
   14d1f:	8b 45 08             	mov    0x8(%ebp),%eax
   14d22:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14d28:	e9 56 01 00 00       	jmp    14e83 <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   14d2d:	8b 45 08             	mov    0x8(%ebp),%eax
   14d30:	8b 40 0c             	mov    0xc(%eax),%eax
   14d33:	83 ec 08             	sub    $0x8,%esp
   14d36:	50                   	push   %eax
   14d37:	ff 75 08             	pushl  0x8(%ebp)
   14d3a:	e8 fe f3 ff ff       	call   1413d <_Skip>
   14d3f:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   14d42:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   14d49:	e9 17 01 00 00       	jmp    14e65 <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14d4e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14d55:	e9 f8 00 00 00       	jmp    14e52 <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14d5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14d61:	8b 45 08             	mov    0x8(%ebp),%eax
   14d64:	83 c0 2c             	add    $0x2c,%eax
   14d67:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14d6a:	e9 8d 00 00 00       	jmp    14dfc <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   14d6f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   14d76:	eb 71                	jmp    14de9 <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14d78:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   14d7f:	eb 59                	jmp    14dda <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   14d81:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14d84:	8b 50 28             	mov    0x28(%eax),%edx
   14d87:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14d8a:	8b 40 08             	mov    0x8(%eax),%eax
   14d8d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   14d91:	89 c1                	mov    %eax,%ecx
   14d93:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14d96:	01 c1                	add    %eax,%ecx
   14d98:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14d9b:	8b 40 14             	mov    0x14(%eax),%eax
   14d9e:	0f af c8             	imul   %eax,%ecx
   14da1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14da4:	8b 40 04             	mov    0x4(%eax),%eax
   14da7:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14dab:	01 c1                	add    %eax,%ecx
   14dad:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14db0:	01 c8                	add    %ecx,%eax
   14db2:	c1 e0 03             	shl    $0x3,%eax
   14db5:	01 d0                	add    %edx,%eax
   14db7:	50                   	push   %eax
   14db8:	ff 75 dc             	pushl  -0x24(%ebp)
   14dbb:	ff 75 0c             	pushl  0xc(%ebp)
   14dbe:	ff 75 08             	pushl  0x8(%ebp)
   14dc1:	e8 bf 00 00 00       	call   14e85 <_DecodeBlock>
   14dc6:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   14dc9:	8b 45 08             	mov    0x8(%ebp),%eax
   14dcc:	8b 00                	mov    (%eax),%eax
   14dce:	85 c0                	test   %eax,%eax
   14dd0:	0f 85 ac 00 00 00    	jne    14e82 <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14dd6:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   14dda:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14ddd:	8b 40 04             	mov    0x4(%eax),%eax
   14de0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   14de3:	7f 9c                	jg     14d81 <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   14de5:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   14de9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14dec:	8b 40 08             	mov    0x8(%eax),%eax
   14def:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   14df2:	7f 84                	jg     14d78 <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14df4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14df8:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14dfc:	8b 45 08             	mov    0x8(%ebp),%eax
   14dff:	8b 40 28             	mov    0x28(%eax),%eax
   14e02:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14e05:	0f 8f 64 ff ff ff    	jg     14d6f <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   14e0b:	8b 45 08             	mov    0x8(%ebp),%eax
   14e0e:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14e14:	85 c0                	test   %eax,%eax
   14e16:	74 36                	je     14e4e <_DecodeSOS+0x2c5>
   14e18:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   14e1c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14e20:	75 2c                	jne    14e4e <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   14e22:	83 ec 0c             	sub    $0xc,%esp
   14e25:	ff 75 08             	pushl  0x8(%ebp)
   14e28:	e8 9f 0a 00 00       	call   158cc <_ByteAlign>
   14e2d:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   14e30:	83 ec 08             	sub    $0x8,%esp
   14e33:	6a 10                	push   $0x10
   14e35:	ff 75 08             	pushl  0x8(%ebp)
   14e38:	e8 ce 04 00 00       	call   1530b <_GetBits>
   14e3d:	83 c4 10             	add    $0x10,%esp
   14e40:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   14e43:	8b 45 08             	mov    0x8(%ebp),%eax
   14e46:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14e4c:	eb 35                	jmp    14e83 <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14e4e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14e52:	8b 45 08             	mov    0x8(%ebp),%eax
   14e55:	8b 40 18             	mov    0x18(%eax),%eax
   14e58:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14e5b:	0f 8f f9 fe ff ff    	jg     14d5a <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   14e61:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   14e65:	8b 45 08             	mov    0x8(%ebp),%eax
   14e68:	8b 40 1c             	mov    0x1c(%eax),%eax
   14e6b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14e6e:	0f 8f da fe ff ff    	jg     14d4e <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   14e74:	8b 45 08             	mov    0x8(%ebp),%eax
   14e77:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   14e7d:	eb 04                	jmp    14e83 <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   14e7f:	90                   	nop
   14e80:	eb 01                	jmp    14e83 <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   14e82:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   14e83:	c9                   	leave  
   14e84:	c3                   	ret    

00014e85 <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   14e85:	55                   	push   %ebp
   14e86:	89 e5                	mov    %esp,%ebp
   14e88:	53                   	push   %ebx
   14e89:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   14e8c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   14e93:	8b 45 08             	mov    0x8(%ebp),%eax
   14e96:	05 c0 01 08 00       	add    $0x801c0,%eax
   14e9b:	83 ec 04             	sub    $0x4,%esp
   14e9e:	68 00 01 00 00       	push   $0x100
   14ea3:	6a 00                	push   $0x0
   14ea5:	50                   	push   %eax
   14ea6:	e8 04 b8 fe ff       	call   6af <memset>
   14eab:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   14eae:	8b 45 10             	mov    0x10(%ebp),%eax
   14eb1:	8b 40 20             	mov    0x20(%eax),%eax
   14eb4:	c1 e0 11             	shl    $0x11,%eax
   14eb7:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14ebd:	8b 45 08             	mov    0x8(%ebp),%eax
   14ec0:	01 d0                	add    %edx,%eax
   14ec2:	83 c0 08             	add    $0x8,%eax
   14ec5:	83 ec 04             	sub    $0x4,%esp
   14ec8:	6a 00                	push   $0x0
   14eca:	50                   	push   %eax
   14ecb:	ff 75 08             	pushl  0x8(%ebp)
   14ece:	e8 86 01 00 00       	call   15059 <_GetVLC>
   14ed3:	83 c4 10             	add    $0x10,%esp
   14ed6:	89 c2                	mov    %eax,%edx
   14ed8:	8b 45 10             	mov    0x10(%ebp),%eax
   14edb:	8b 40 24             	mov    0x24(%eax),%eax
   14ede:	01 c2                	add    %eax,%edx
   14ee0:	8b 45 10             	mov    0x10(%ebp),%eax
   14ee3:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   14ee6:	8b 45 10             	mov    0x10(%ebp),%eax
   14ee9:	8b 50 24             	mov    0x24(%eax),%edx
   14eec:	8b 45 10             	mov    0x10(%ebp),%eax
   14eef:	8b 48 18             	mov    0x18(%eax),%ecx
   14ef2:	8b 45 08             	mov    0x8(%ebp),%eax
   14ef5:	c1 e1 06             	shl    $0x6,%ecx
   14ef8:	01 c8                	add    %ecx,%eax
   14efa:	05 b8 00 00 00       	add    $0xb8,%eax
   14eff:	0f b6 00             	movzbl (%eax),%eax
   14f02:	0f b6 c0             	movzbl %al,%eax
   14f05:	0f af d0             	imul   %eax,%edx
   14f08:	8b 45 08             	mov    0x8(%ebp),%eax
   14f0b:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   14f11:	8b 45 10             	mov    0x10(%ebp),%eax
   14f14:	8b 40 1c             	mov    0x1c(%eax),%eax
   14f17:	c1 e0 11             	shl    $0x11,%eax
   14f1a:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14f20:	8b 45 08             	mov    0x8(%ebp),%eax
   14f23:	01 d0                	add    %edx,%eax
   14f25:	8d 50 08             	lea    0x8(%eax),%edx
   14f28:	83 ec 04             	sub    $0x4,%esp
   14f2b:	8d 45 ef             	lea    -0x11(%ebp),%eax
   14f2e:	50                   	push   %eax
   14f2f:	52                   	push   %edx
   14f30:	ff 75 08             	pushl  0x8(%ebp)
   14f33:	e8 21 01 00 00       	call   15059 <_GetVLC>
   14f38:	83 c4 10             	add    $0x10,%esp
   14f3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   14f3e:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14f42:	84 c0                	test   %al,%al
   14f44:	0f 84 92 00 00 00    	je     14fdc <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   14f4a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14f4e:	0f b6 c0             	movzbl %al,%eax
   14f51:	83 e0 0f             	and    $0xf,%eax
   14f54:	85 c0                	test   %eax,%eax
   14f56:	75 16                	jne    14f6e <_DecodeBlock+0xe9>
   14f58:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14f5c:	3c f0                	cmp    $0xf0,%al
   14f5e:	74 0e                	je     14f6e <_DecodeBlock+0xe9>
   14f60:	8b 45 08             	mov    0x8(%ebp),%eax
   14f63:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14f69:	e9 e6 00 00 00       	jmp    15054 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   14f6e:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14f72:	c0 e8 04             	shr    $0x4,%al
   14f75:	0f b6 c0             	movzbl %al,%eax
   14f78:	83 c0 01             	add    $0x1,%eax
   14f7b:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   14f7e:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14f82:	7e 0e                	jle    14f92 <_DecodeBlock+0x10d>
   14f84:	8b 45 08             	mov    0x8(%ebp),%eax
   14f87:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14f8d:	e9 c2 00 00 00       	jmp    15054 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   14f92:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14f95:	8b 45 0c             	mov    0xc(%ebp),%eax
   14f98:	01 d0                	add    %edx,%eax
   14f9a:	0f b6 00             	movzbl (%eax),%eax
   14f9d:	0f be c8             	movsbl %al,%ecx
   14fa0:	8b 45 10             	mov    0x10(%ebp),%eax
   14fa3:	8b 50 18             	mov    0x18(%eax),%edx
   14fa6:	8b 45 08             	mov    0x8(%ebp),%eax
   14fa9:	c1 e2 06             	shl    $0x6,%edx
   14fac:	01 c2                	add    %eax,%edx
   14fae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14fb1:	01 d0                	add    %edx,%eax
   14fb3:	05 b8 00 00 00       	add    $0xb8,%eax
   14fb8:	0f b6 00             	movzbl (%eax),%eax
   14fbb:	0f b6 c0             	movzbl %al,%eax
   14fbe:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14fc2:	89 c2                	mov    %eax,%edx
   14fc4:	8b 45 08             	mov    0x8(%ebp),%eax
   14fc7:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   14fcd:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   14fd0:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   14fd4:	0f 8e 37 ff ff ff    	jle    14f11 <_DecodeBlock+0x8c>
   14fda:	eb 01                	jmp    14fdd <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   14fdc:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   14fdd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14fe4:	eb 24                	jmp    1500a <_DecodeBlock+0x185>
   14fe6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14fe9:	05 70 00 02 00       	add    $0x20070,%eax
   14fee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14ff5:	8b 45 08             	mov    0x8(%ebp),%eax
   14ff8:	01 d0                	add    %edx,%eax
   14ffa:	83 ec 0c             	sub    $0xc,%esp
   14ffd:	50                   	push   %eax
   14ffe:	e8 32 03 00 00       	call   15335 <_RowIDCT>
   15003:	83 c4 10             	add    $0x10,%esp
   15006:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   1500a:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   1500e:	7e d6                	jle    14fe6 <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   15010:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15017:	eb 35                	jmp    1504e <_DecodeBlock+0x1c9>
   15019:	8b 45 10             	mov    0x10(%ebp),%eax
   1501c:	8b 40 14             	mov    0x14(%eax),%eax
   1501f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   15022:	8b 55 14             	mov    0x14(%ebp),%edx
   15025:	01 d1                	add    %edx,%ecx
   15027:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1502a:	81 c2 70 00 02 00    	add    $0x20070,%edx
   15030:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   15037:	8b 55 08             	mov    0x8(%ebp),%edx
   1503a:	01 da                	add    %ebx,%edx
   1503c:	83 ec 04             	sub    $0x4,%esp
   1503f:	50                   	push   %eax
   15040:	51                   	push   %ecx
   15041:	52                   	push   %edx
   15042:	e8 7b 05 00 00       	call   155c2 <_ColIDCT>
   15047:	83 c4 10             	add    $0x10,%esp
   1504a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1504e:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   15052:	7e c5                	jle    15019 <_DecodeBlock+0x194>
}
   15054:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15057:	c9                   	leave  
   15058:	c3                   	ret    

00015059 <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   15059:	55                   	push   %ebp
   1505a:	89 e5                	mov    %esp,%ebp
   1505c:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   1505f:	83 ec 08             	sub    $0x8,%esp
   15062:	6a 10                	push   $0x10
   15064:	ff 75 08             	pushl  0x8(%ebp)
   15067:	e8 c2 00 00 00       	call   1512e <_ShowBits>
   1506c:	83 c4 10             	add    $0x10,%esp
   1506f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   15072:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15075:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15078:	8b 45 0c             	mov    0xc(%ebp),%eax
   1507b:	01 d0                	add    %edx,%eax
   1507d:	0f b6 00             	movzbl (%eax),%eax
   15080:	0f b6 c0             	movzbl %al,%eax
   15083:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   15086:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1508a:	75 13                	jne    1509f <_GetVLC+0x46>
   1508c:	8b 45 08             	mov    0x8(%ebp),%eax
   1508f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15095:	b8 00 00 00 00       	mov    $0x0,%eax
   1509a:	e9 8d 00 00 00       	jmp    1512c <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   1509f:	83 ec 08             	sub    $0x8,%esp
   150a2:	ff 75 f0             	pushl  -0x10(%ebp)
   150a5:	ff 75 08             	pushl  0x8(%ebp)
   150a8:	e8 25 02 00 00       	call   152d2 <_SkipBits>
   150ad:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   150b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   150b3:	8d 14 00             	lea    (%eax,%eax,1),%edx
   150b6:	8b 45 0c             	mov    0xc(%ebp),%eax
   150b9:	01 d0                	add    %edx,%eax
   150bb:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   150bf:	0f b6 c0             	movzbl %al,%eax
   150c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   150c5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   150c9:	74 0a                	je     150d5 <_GetVLC+0x7c>
   150cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   150ce:	89 c2                	mov    %eax,%edx
   150d0:	8b 45 10             	mov    0x10(%ebp),%eax
   150d3:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   150d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   150d8:	83 e0 0f             	and    $0xf,%eax
   150db:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   150de:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   150e2:	75 07                	jne    150eb <_GetVLC+0x92>
   150e4:	b8 00 00 00 00       	mov    $0x0,%eax
   150e9:	eb 41                	jmp    1512c <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   150eb:	83 ec 08             	sub    $0x8,%esp
   150ee:	ff 75 f0             	pushl  -0x10(%ebp)
   150f1:	ff 75 08             	pushl  0x8(%ebp)
   150f4:	e8 12 02 00 00       	call   1530b <_GetBits>
   150f9:	83 c4 10             	add    $0x10,%esp
   150fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   150ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15102:	83 e8 01             	sub    $0x1,%eax
   15105:	ba 01 00 00 00       	mov    $0x1,%edx
   1510a:	89 c1                	mov    %eax,%ecx
   1510c:	d3 e2                	shl    %cl,%edx
   1510e:	89 d0                	mov    %edx,%eax
   15110:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   15113:	7e 14                	jle    15129 <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   15115:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15118:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   1511d:	89 c1                	mov    %eax,%ecx
   1511f:	d3 e2                	shl    %cl,%edx
   15121:	89 d0                	mov    %edx,%eax
   15123:	83 c0 01             	add    $0x1,%eax
   15126:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   15129:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1512c:	c9                   	leave  
   1512d:	c3                   	ret    

0001512e <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   1512e:	55                   	push   %ebp
   1512f:	89 e5                	mov    %esp,%ebp
   15131:	53                   	push   %ebx
   15132:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   15135:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   15139:	0f 85 4f 01 00 00    	jne    1528e <_ShowBits+0x160>
   1513f:	b8 00 00 00 00       	mov    $0x0,%eax
   15144:	e9 83 01 00 00       	jmp    152cc <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   15149:	8b 45 08             	mov    0x8(%ebp),%eax
   1514c:	8b 40 08             	mov    0x8(%eax),%eax
   1514f:	85 c0                	test   %eax,%eax
   15151:	7f 33                	jg     15186 <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   15153:	8b 45 08             	mov    0x8(%ebp),%eax
   15156:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   1515c:	c1 e0 08             	shl    $0x8,%eax
   1515f:	0c ff                	or     $0xff,%al
   15161:	89 c2                	mov    %eax,%edx
   15163:	8b 45 08             	mov    0x8(%ebp),%eax
   15166:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   1516c:	8b 45 08             	mov    0x8(%ebp),%eax
   1516f:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15175:	8d 50 08             	lea    0x8(%eax),%edx
   15178:	8b 45 08             	mov    0x8(%ebp),%eax
   1517b:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   15181:	e9 08 01 00 00       	jmp    1528e <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   15186:	8b 45 08             	mov    0x8(%ebp),%eax
   15189:	8b 40 04             	mov    0x4(%eax),%eax
   1518c:	8d 48 01             	lea    0x1(%eax),%ecx
   1518f:	8b 55 08             	mov    0x8(%ebp),%edx
   15192:	89 4a 04             	mov    %ecx,0x4(%edx)
   15195:	0f b6 00             	movzbl (%eax),%eax
   15198:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   1519b:	8b 45 08             	mov    0x8(%ebp),%eax
   1519e:	8b 40 08             	mov    0x8(%eax),%eax
   151a1:	8d 50 ff             	lea    -0x1(%eax),%edx
   151a4:	8b 45 08             	mov    0x8(%ebp),%eax
   151a7:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   151aa:	8b 45 08             	mov    0x8(%ebp),%eax
   151ad:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   151b3:	8d 50 08             	lea    0x8(%eax),%edx
   151b6:	8b 45 08             	mov    0x8(%ebp),%eax
   151b9:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   151bf:	8b 45 08             	mov    0x8(%ebp),%eax
   151c2:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   151c8:	c1 e0 08             	shl    $0x8,%eax
   151cb:	89 c2                	mov    %eax,%edx
   151cd:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   151d1:	09 c2                	or     %eax,%edx
   151d3:	8b 45 08             	mov    0x8(%ebp),%eax
   151d6:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   151dc:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   151e0:	0f 85 a8 00 00 00    	jne    1528e <_ShowBits+0x160>
            if(ctx->size){
   151e6:	8b 45 08             	mov    0x8(%ebp),%eax
   151e9:	8b 40 08             	mov    0x8(%eax),%eax
   151ec:	85 c0                	test   %eax,%eax
   151ee:	0f 84 91 00 00 00    	je     15285 <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   151f4:	8b 45 08             	mov    0x8(%ebp),%eax
   151f7:	8b 40 04             	mov    0x4(%eax),%eax
   151fa:	8d 48 01             	lea    0x1(%eax),%ecx
   151fd:	8b 55 08             	mov    0x8(%ebp),%edx
   15200:	89 4a 04             	mov    %ecx,0x4(%edx)
   15203:	0f b6 00             	movzbl (%eax),%eax
   15206:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   15209:	8b 45 08             	mov    0x8(%ebp),%eax
   1520c:	8b 40 08             	mov    0x8(%eax),%eax
   1520f:	8d 50 ff             	lea    -0x1(%eax),%edx
   15212:	8b 45 08             	mov    0x8(%ebp),%eax
   15215:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   15218:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   1521c:	85 c0                	test   %eax,%eax
   1521e:	74 62                	je     15282 <_ShowBits+0x154>
   15220:	3d d9 00 00 00       	cmp    $0xd9,%eax
   15225:	75 0c                	jne    15233 <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   15227:	8b 45 08             	mov    0x8(%ebp),%eax
   1522a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   15231:	eb 5b                	jmp    1528e <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   15233:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   15237:	25 f8 00 00 00       	and    $0xf8,%eax
   1523c:	3d d0 00 00 00       	cmp    $0xd0,%eax
   15241:	74 0b                	je     1524e <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   15243:	8b 45 08             	mov    0x8(%ebp),%eax
   15246:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1524c:	eb 40                	jmp    1528e <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   1524e:	8b 45 08             	mov    0x8(%ebp),%eax
   15251:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   15257:	c1 e0 08             	shl    $0x8,%eax
   1525a:	89 c2                	mov    %eax,%edx
   1525c:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   15260:	09 c2                	or     %eax,%edx
   15262:	8b 45 08             	mov    0x8(%ebp),%eax
   15265:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   1526b:	8b 45 08             	mov    0x8(%ebp),%eax
   1526e:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15274:	8d 50 08             	lea    0x8(%eax),%edx
   15277:	8b 45 08             	mov    0x8(%ebp),%eax
   1527a:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   15280:	eb 0c                	jmp    1528e <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   15282:	90                   	nop
   15283:	eb 09                	jmp    1528e <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   15285:	8b 45 08             	mov    0x8(%ebp),%eax
   15288:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   1528e:	8b 45 08             	mov    0x8(%ebp),%eax
   15291:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15297:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1529a:	0f 8c a9 fe ff ff    	jl     15149 <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   152a0:	8b 45 08             	mov    0x8(%ebp),%eax
   152a3:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   152a9:	8b 45 08             	mov    0x8(%ebp),%eax
   152ac:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   152b2:	2b 45 0c             	sub    0xc(%ebp),%eax
   152b5:	89 c1                	mov    %eax,%ecx
   152b7:	d3 fa                	sar    %cl,%edx
   152b9:	8b 45 0c             	mov    0xc(%ebp),%eax
   152bc:	bb 01 00 00 00       	mov    $0x1,%ebx
   152c1:	89 c1                	mov    %eax,%ecx
   152c3:	d3 e3                	shl    %cl,%ebx
   152c5:	89 d8                	mov    %ebx,%eax
   152c7:	83 e8 01             	sub    $0x1,%eax
   152ca:	21 d0                	and    %edx,%eax
}
   152cc:	83 c4 10             	add    $0x10,%esp
   152cf:	5b                   	pop    %ebx
   152d0:	5d                   	pop    %ebp
   152d1:	c3                   	ret    

000152d2 <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   152d2:	55                   	push   %ebp
   152d3:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   152d5:	8b 45 08             	mov    0x8(%ebp),%eax
   152d8:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   152de:	3b 45 0c             	cmp    0xc(%ebp),%eax
   152e1:	7d 0e                	jge    152f1 <_SkipBits+0x1f>
   152e3:	ff 75 0c             	pushl  0xc(%ebp)
   152e6:	ff 75 08             	pushl  0x8(%ebp)
   152e9:	e8 40 fe ff ff       	call   1512e <_ShowBits>
   152ee:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   152f1:	8b 45 08             	mov    0x8(%ebp),%eax
   152f4:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   152fa:	2b 45 0c             	sub    0xc(%ebp),%eax
   152fd:	89 c2                	mov    %eax,%edx
   152ff:	8b 45 08             	mov    0x8(%ebp),%eax
   15302:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   15308:	90                   	nop
   15309:	c9                   	leave  
   1530a:	c3                   	ret    

0001530b <_GetBits>:

int _GetBits(Context* ctx, int bits){
   1530b:	55                   	push   %ebp
   1530c:	89 e5                	mov    %esp,%ebp
   1530e:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   15311:	ff 75 0c             	pushl  0xc(%ebp)
   15314:	ff 75 08             	pushl  0x8(%ebp)
   15317:	e8 12 fe ff ff       	call   1512e <_ShowBits>
   1531c:	83 c4 08             	add    $0x8,%esp
   1531f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   15322:	ff 75 0c             	pushl  0xc(%ebp)
   15325:	ff 75 08             	pushl  0x8(%ebp)
   15328:	e8 a5 ff ff ff       	call   152d2 <_SkipBits>
   1532d:	83 c4 08             	add    $0x8,%esp
    return res;
   15330:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   15333:	c9                   	leave  
   15334:	c3                   	ret    

00015335 <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   15335:	55                   	push   %ebp
   15336:	89 e5                	mov    %esp,%ebp
   15338:	57                   	push   %edi
   15339:	56                   	push   %esi
   1533a:	53                   	push   %ebx
   1533b:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   1533e:	8b 45 08             	mov    0x8(%ebp),%eax
   15341:	83 c0 10             	add    $0x10,%eax
   15344:	8b 00                	mov    (%eax),%eax
   15346:	c1 e0 0b             	shl    $0xb,%eax
   15349:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   1534c:	8b 45 08             	mov    0x8(%ebp),%eax
   1534f:	8b 40 18             	mov    0x18(%eax),%eax
   15352:	89 45 ec             	mov    %eax,-0x14(%ebp)
   15355:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15358:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   1535b:	8b 55 08             	mov    0x8(%ebp),%edx
   1535e:	8b 52 08             	mov    0x8(%edx),%edx
   15361:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15364:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   15367:	8b 55 08             	mov    0x8(%ebp),%edx
   1536a:	8b 52 04             	mov    0x4(%edx),%edx
   1536d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   15370:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   15373:	8b 55 08             	mov    0x8(%ebp),%edx
   15376:	8b 52 1c             	mov    0x1c(%edx),%edx
   15379:	89 55 e0             	mov    %edx,-0x20(%ebp)
   1537c:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   1537f:	8b 55 08             	mov    0x8(%ebp),%edx
   15382:	8b 52 14             	mov    0x14(%edx),%edx
   15385:	89 55 dc             	mov    %edx,-0x24(%ebp)
   15388:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   1538b:	8b 55 08             	mov    0x8(%ebp),%edx
   1538e:	8b 52 0c             	mov    0xc(%edx),%edx
   15391:	89 55 d8             	mov    %edx,-0x28(%ebp)
   15394:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   15397:	85 c0                	test   %eax,%eax
   15399:	75 68                	jne    15403 <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   1539b:	8b 45 08             	mov    0x8(%ebp),%eax
   1539e:	8d 48 04             	lea    0x4(%eax),%ecx
   153a1:	8b 45 08             	mov    0x8(%ebp),%eax
   153a4:	8d 58 08             	lea    0x8(%eax),%ebx
   153a7:	8b 45 08             	mov    0x8(%ebp),%eax
   153aa:	8d 70 0c             	lea    0xc(%eax),%esi
   153ad:	8b 45 08             	mov    0x8(%ebp),%eax
   153b0:	8d 78 10             	lea    0x10(%eax),%edi
   153b3:	8b 45 08             	mov    0x8(%ebp),%eax
   153b6:	83 c0 14             	add    $0x14,%eax
   153b9:	89 45 c0             	mov    %eax,-0x40(%ebp)
   153bc:	8b 45 08             	mov    0x8(%ebp),%eax
   153bf:	83 c0 18             	add    $0x18,%eax
   153c2:	89 45 bc             	mov    %eax,-0x44(%ebp)
   153c5:	8b 45 08             	mov    0x8(%ebp),%eax
   153c8:	8d 50 1c             	lea    0x1c(%eax),%edx
   153cb:	8b 45 08             	mov    0x8(%ebp),%eax
   153ce:	8b 00                	mov    (%eax),%eax
   153d0:	c1 e0 03             	shl    $0x3,%eax
   153d3:	89 02                	mov    %eax,(%edx)
   153d5:	8b 02                	mov    (%edx),%eax
   153d7:	8b 55 bc             	mov    -0x44(%ebp),%edx
   153da:	89 02                	mov    %eax,(%edx)
   153dc:	89 d0                	mov    %edx,%eax
   153de:	8b 00                	mov    (%eax),%eax
   153e0:	8b 55 c0             	mov    -0x40(%ebp),%edx
   153e3:	89 02                	mov    %eax,(%edx)
   153e5:	89 d0                	mov    %edx,%eax
   153e7:	8b 00                	mov    (%eax),%eax
   153e9:	89 07                	mov    %eax,(%edi)
   153eb:	8b 07                	mov    (%edi),%eax
   153ed:	89 06                	mov    %eax,(%esi)
   153ef:	8b 06                	mov    (%esi),%eax
   153f1:	89 03                	mov    %eax,(%ebx)
   153f3:	8b 03                	mov    (%ebx),%eax
   153f5:	89 01                	mov    %eax,(%ecx)
   153f7:	8b 11                	mov    (%ecx),%edx
   153f9:	8b 45 08             	mov    0x8(%ebp),%eax
   153fc:	89 10                	mov    %edx,(%eax)
        return;
   153fe:	e9 b7 01 00 00       	jmp    155ba <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   15403:	8b 45 08             	mov    0x8(%ebp),%eax
   15406:	8b 00                	mov    (%eax),%eax
   15408:	c1 e0 0b             	shl    $0xb,%eax
   1540b:	83 e8 80             	sub    $0xffffff80,%eax
   1540e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   15411:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15414:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15417:	01 d0                	add    %edx,%eax
   15419:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   1541f:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   15422:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15425:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   1542b:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1542e:	01 d0                	add    %edx,%eax
   15430:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   15433:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15436:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   1543c:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1543f:	01 d0                	add    %edx,%eax
   15441:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   15444:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15447:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1544a:	01 d0                	add    %edx,%eax
   1544c:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   15452:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   15455:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15458:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   1545e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15461:	01 d0                	add    %edx,%eax
   15463:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   15466:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15469:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   1546f:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15472:	01 d0                	add    %edx,%eax
   15474:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   15477:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   1547a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1547d:	01 d0                	add    %edx,%eax
   1547f:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   15482:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15485:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   15488:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1548b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1548e:	01 d0                	add    %edx,%eax
   15490:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   15496:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   15499:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1549c:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   154a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   154a5:	01 d0                	add    %edx,%eax
   154a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   154aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   154ad:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   154b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   154b6:	01 d0                	add    %edx,%eax
   154b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   154bb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   154be:	8b 45 dc             	mov    -0x24(%ebp),%eax
   154c1:	01 d0                	add    %edx,%eax
   154c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   154c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   154c9:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   154cc:	8b 55 e0             	mov    -0x20(%ebp),%edx
   154cf:	8b 45 d8             	mov    -0x28(%ebp),%eax
   154d2:	01 d0                	add    %edx,%eax
   154d4:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   154d7:	8b 45 d8             	mov    -0x28(%ebp),%eax
   154da:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   154dd:	8b 55 d0             	mov    -0x30(%ebp),%edx
   154e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   154e3:	01 d0                	add    %edx,%eax
   154e5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   154e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   154eb:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   154ee:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   154f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   154f4:	01 d0                	add    %edx,%eax
   154f6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   154f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   154fc:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   154ff:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15502:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15505:	01 d0                	add    %edx,%eax
   15507:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1550d:	83 e8 80             	sub    $0xffffff80,%eax
   15510:	c1 f8 08             	sar    $0x8,%eax
   15513:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   15516:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15519:	2b 45 e0             	sub    -0x20(%ebp),%eax
   1551c:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15522:	83 e8 80             	sub    $0xffffff80,%eax
   15525:	c1 f8 08             	sar    $0x8,%eax
   15528:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   1552b:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1552e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15531:	01 d0                	add    %edx,%eax
   15533:	c1 f8 08             	sar    $0x8,%eax
   15536:	89 c2                	mov    %eax,%edx
   15538:	8b 45 08             	mov    0x8(%ebp),%eax
   1553b:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   1553d:	8b 45 08             	mov    0x8(%ebp),%eax
   15540:	83 c0 04             	add    $0x4,%eax
   15543:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   15546:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15549:	01 ca                	add    %ecx,%edx
   1554b:	c1 fa 08             	sar    $0x8,%edx
   1554e:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   15550:	8b 45 08             	mov    0x8(%ebp),%eax
   15553:	83 c0 08             	add    $0x8,%eax
   15556:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   15559:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1555c:	01 ca                	add    %ecx,%edx
   1555e:	c1 fa 08             	sar    $0x8,%edx
   15561:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   15563:	8b 45 08             	mov    0x8(%ebp),%eax
   15566:	83 c0 0c             	add    $0xc,%eax
   15569:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   1556c:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1556f:	01 ca                	add    %ecx,%edx
   15571:	c1 fa 08             	sar    $0x8,%edx
   15574:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   15576:	8b 45 08             	mov    0x8(%ebp),%eax
   15579:	8d 50 10             	lea    0x10(%eax),%edx
   1557c:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1557f:	2b 45 dc             	sub    -0x24(%ebp),%eax
   15582:	c1 f8 08             	sar    $0x8,%eax
   15585:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   15587:	8b 45 08             	mov    0x8(%ebp),%eax
   1558a:	8d 50 14             	lea    0x14(%eax),%edx
   1558d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   15590:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   15593:	c1 f8 08             	sar    $0x8,%eax
   15596:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   15598:	8b 45 08             	mov    0x8(%ebp),%eax
   1559b:	8d 50 18             	lea    0x18(%eax),%edx
   1559e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   155a1:	2b 45 ec             	sub    -0x14(%ebp),%eax
   155a4:	c1 f8 08             	sar    $0x8,%eax
   155a7:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   155a9:	8b 45 08             	mov    0x8(%ebp),%eax
   155ac:	8d 50 1c             	lea    0x1c(%eax),%edx
   155af:	8b 45 d8             	mov    -0x28(%ebp),%eax
   155b2:	2b 45 f0             	sub    -0x10(%ebp),%eax
   155b5:	c1 f8 08             	sar    $0x8,%eax
   155b8:	89 02                	mov    %eax,(%edx)
}
   155ba:	83 c4 38             	add    $0x38,%esp
   155bd:	5b                   	pop    %ebx
   155be:	5e                   	pop    %esi
   155bf:	5f                   	pop    %edi
   155c0:	5d                   	pop    %ebp
   155c1:	c3                   	ret    

000155c2 <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   155c2:	55                   	push   %ebp
   155c3:	89 e5                	mov    %esp,%ebp
   155c5:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   155c8:	8b 45 08             	mov    0x8(%ebp),%eax
   155cb:	83 e8 80             	sub    $0xffffff80,%eax
   155ce:	8b 00                	mov    (%eax),%eax
   155d0:	c1 e0 08             	shl    $0x8,%eax
   155d3:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   155d6:	8b 45 08             	mov    0x8(%ebp),%eax
   155d9:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   155df:	89 45 f4             	mov    %eax,-0xc(%ebp)
   155e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   155e5:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   155e8:	8b 55 08             	mov    0x8(%ebp),%edx
   155eb:	8b 52 40             	mov    0x40(%edx),%edx
   155ee:	89 55 f0             	mov    %edx,-0x10(%ebp)
   155f1:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   155f4:	8b 55 08             	mov    0x8(%ebp),%edx
   155f7:	8b 52 20             	mov    0x20(%edx),%edx
   155fa:	89 55 ec             	mov    %edx,-0x14(%ebp)
   155fd:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   15600:	8b 55 08             	mov    0x8(%ebp),%edx
   15603:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   15609:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1560c:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   1560f:	8b 55 08             	mov    0x8(%ebp),%edx
   15612:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   15618:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   1561b:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   1561e:	8b 55 08             	mov    0x8(%ebp),%edx
   15621:	8b 52 60             	mov    0x60(%edx),%edx
   15624:	89 55 e0             	mov    %edx,-0x20(%ebp)
   15627:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   1562a:	85 c0                	test   %eax,%eax
   1562c:	75 45                	jne    15673 <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   1562e:	8b 45 08             	mov    0x8(%ebp),%eax
   15631:	8b 00                	mov    (%eax),%eax
   15633:	83 c0 20             	add    $0x20,%eax
   15636:	c1 f8 06             	sar    $0x6,%eax
   15639:	83 e8 80             	sub    $0xffffff80,%eax
   1563c:	50                   	push   %eax
   1563d:	e8 d6 ea ff ff       	call   14118 <_Clip>
   15642:	83 c4 04             	add    $0x4,%esp
   15645:	0f b6 c0             	movzbl %al,%eax
   15648:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   1564b:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   15652:	eb 14                	jmp    15668 <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   15654:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15657:	89 c2                	mov    %eax,%edx
   15659:	8b 45 0c             	mov    0xc(%ebp),%eax
   1565c:	88 10                	mov    %dl,(%eax)
            out += stride;
   1565e:	8b 45 10             	mov    0x10(%ebp),%eax
   15661:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   15664:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   15668:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1566c:	75 e6                	jne    15654 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   1566e:	e9 57 02 00 00       	jmp    158ca <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   15673:	8b 45 08             	mov    0x8(%ebp),%eax
   15676:	8b 00                	mov    (%eax),%eax
   15678:	c1 e0 08             	shl    $0x8,%eax
   1567b:	05 00 20 00 00       	add    $0x2000,%eax
   15680:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   15683:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15686:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15689:	01 d0                	add    %edx,%eax
   1568b:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   15691:	83 c0 04             	add    $0x4,%eax
   15694:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   15697:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1569a:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   156a0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   156a3:	01 d0                	add    %edx,%eax
   156a5:	c1 f8 03             	sar    $0x3,%eax
   156a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   156ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
   156ae:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   156b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   156b7:	01 d0                	add    %edx,%eax
   156b9:	c1 f8 03             	sar    $0x3,%eax
   156bc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   156bf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   156c2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   156c5:	01 d0                	add    %edx,%eax
   156c7:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   156cd:	83 c0 04             	add    $0x4,%eax
   156d0:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   156d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   156d6:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   156dc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   156df:	01 d0                	add    %edx,%eax
   156e1:	c1 f8 03             	sar    $0x3,%eax
   156e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   156e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   156ea:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   156f0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   156f3:	01 d0                	add    %edx,%eax
   156f5:	c1 f8 03             	sar    $0x3,%eax
   156f8:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   156fb:	8b 55 fc             	mov    -0x4(%ebp),%edx
   156fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15701:	01 d0                	add    %edx,%eax
   15703:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   15706:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15709:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   1570c:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1570f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15712:	01 d0                	add    %edx,%eax
   15714:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   1571a:	83 c0 04             	add    $0x4,%eax
   1571d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   15720:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15723:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   15729:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1572c:	01 d0                	add    %edx,%eax
   1572e:	c1 f8 03             	sar    $0x3,%eax
   15731:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   15734:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15737:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   1573d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15740:	01 d0                	add    %edx,%eax
   15742:	c1 f8 03             	sar    $0x3,%eax
   15745:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   15748:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1574b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1574e:	01 d0                	add    %edx,%eax
   15750:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   15753:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15756:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   15759:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1575c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1575f:	01 d0                	add    %edx,%eax
   15761:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   15764:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15767:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   1576a:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1576d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15770:	01 d0                	add    %edx,%eax
   15772:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   15775:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15778:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   1577b:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1577e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15781:	01 d0                	add    %edx,%eax
   15783:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   15786:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15789:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   1578c:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1578f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15792:	01 d0                	add    %edx,%eax
   15794:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1579a:	83 e8 80             	sub    $0xffffff80,%eax
   1579d:	c1 f8 08             	sar    $0x8,%eax
   157a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   157a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   157a6:	2b 45 e8             	sub    -0x18(%ebp),%eax
   157a9:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   157af:	83 e8 80             	sub    $0xffffff80,%eax
   157b2:	c1 f8 08             	sar    $0x8,%eax
   157b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   157b8:	8b 55 e0             	mov    -0x20(%ebp),%edx
   157bb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   157be:	01 d0                	add    %edx,%eax
   157c0:	c1 f8 0e             	sar    $0xe,%eax
   157c3:	83 e8 80             	sub    $0xffffff80,%eax
   157c6:	50                   	push   %eax
   157c7:	e8 4c e9 ff ff       	call   14118 <_Clip>
   157cc:	83 c4 04             	add    $0x4,%esp
   157cf:	89 c2                	mov    %eax,%edx
   157d1:	8b 45 0c             	mov    0xc(%ebp),%eax
   157d4:	88 10                	mov    %dl,(%eax)
   157d6:	8b 45 10             	mov    0x10(%ebp),%eax
   157d9:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   157dc:	8b 55 f0             	mov    -0x10(%ebp),%edx
   157df:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157e2:	01 d0                	add    %edx,%eax
   157e4:	c1 f8 0e             	sar    $0xe,%eax
   157e7:	83 e8 80             	sub    $0xffffff80,%eax
   157ea:	50                   	push   %eax
   157eb:	e8 28 e9 ff ff       	call   14118 <_Clip>
   157f0:	83 c4 04             	add    $0x4,%esp
   157f3:	89 c2                	mov    %eax,%edx
   157f5:	8b 45 0c             	mov    0xc(%ebp),%eax
   157f8:	88 10                	mov    %dl,(%eax)
   157fa:	8b 45 10             	mov    0x10(%ebp),%eax
   157fd:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   15800:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15803:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15806:	01 d0                	add    %edx,%eax
   15808:	c1 f8 0e             	sar    $0xe,%eax
   1580b:	83 e8 80             	sub    $0xffffff80,%eax
   1580e:	50                   	push   %eax
   1580f:	e8 04 e9 ff ff       	call   14118 <_Clip>
   15814:	83 c4 04             	add    $0x4,%esp
   15817:	89 c2                	mov    %eax,%edx
   15819:	8b 45 0c             	mov    0xc(%ebp),%eax
   1581c:	88 10                	mov    %dl,(%eax)
   1581e:	8b 45 10             	mov    0x10(%ebp),%eax
   15821:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   15824:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15827:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1582a:	01 d0                	add    %edx,%eax
   1582c:	c1 f8 0e             	sar    $0xe,%eax
   1582f:	83 e8 80             	sub    $0xffffff80,%eax
   15832:	50                   	push   %eax
   15833:	e8 e0 e8 ff ff       	call   14118 <_Clip>
   15838:	83 c4 04             	add    $0x4,%esp
   1583b:	89 c2                	mov    %eax,%edx
   1583d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15840:	88 10                	mov    %dl,(%eax)
   15842:	8b 45 10             	mov    0x10(%ebp),%eax
   15845:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   15848:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1584b:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   1584e:	c1 f8 0e             	sar    $0xe,%eax
   15851:	83 e8 80             	sub    $0xffffff80,%eax
   15854:	50                   	push   %eax
   15855:	e8 be e8 ff ff       	call   14118 <_Clip>
   1585a:	83 c4 04             	add    $0x4,%esp
   1585d:	89 c2                	mov    %eax,%edx
   1585f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15862:	88 10                	mov    %dl,(%eax)
   15864:	8b 45 10             	mov    0x10(%ebp),%eax
   15867:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   1586a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1586d:	2b 45 ec             	sub    -0x14(%ebp),%eax
   15870:	c1 f8 0e             	sar    $0xe,%eax
   15873:	83 e8 80             	sub    $0xffffff80,%eax
   15876:	50                   	push   %eax
   15877:	e8 9c e8 ff ff       	call   14118 <_Clip>
   1587c:	83 c4 04             	add    $0x4,%esp
   1587f:	89 c2                	mov    %eax,%edx
   15881:	8b 45 0c             	mov    0xc(%ebp),%eax
   15884:	88 10                	mov    %dl,(%eax)
   15886:	8b 45 10             	mov    0x10(%ebp),%eax
   15889:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   1588c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1588f:	2b 45 f4             	sub    -0xc(%ebp),%eax
   15892:	c1 f8 0e             	sar    $0xe,%eax
   15895:	83 e8 80             	sub    $0xffffff80,%eax
   15898:	50                   	push   %eax
   15899:	e8 7a e8 ff ff       	call   14118 <_Clip>
   1589e:	83 c4 04             	add    $0x4,%esp
   158a1:	89 c2                	mov    %eax,%edx
   158a3:	8b 45 0c             	mov    0xc(%ebp),%eax
   158a6:	88 10                	mov    %dl,(%eax)
   158a8:	8b 45 10             	mov    0x10(%ebp),%eax
   158ab:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   158ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
   158b1:	2b 45 f8             	sub    -0x8(%ebp),%eax
   158b4:	c1 f8 0e             	sar    $0xe,%eax
   158b7:	83 e8 80             	sub    $0xffffff80,%eax
   158ba:	50                   	push   %eax
   158bb:	e8 58 e8 ff ff       	call   14118 <_Clip>
   158c0:	83 c4 04             	add    $0x4,%esp
   158c3:	89 c2                	mov    %eax,%edx
   158c5:	8b 45 0c             	mov    0xc(%ebp),%eax
   158c8:	88 10                	mov    %dl,(%eax)
}
   158ca:	c9                   	leave  
   158cb:	c3                   	ret    

000158cc <_ByteAlign>:

void _ByteAlign(Context* ctx){
   158cc:	55                   	push   %ebp
   158cd:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   158cf:	8b 45 08             	mov    0x8(%ebp),%eax
   158d2:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   158d8:	25 f8 00 00 00       	and    $0xf8,%eax
   158dd:	89 c2                	mov    %eax,%edx
   158df:	8b 45 08             	mov    0x8(%ebp),%eax
   158e2:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   158e8:	90                   	nop
   158e9:	5d                   	pop    %ebp
   158ea:	c3                   	ret    

000158eb <_SkipMarker>:

void _SkipMarker(Context* ctx){
   158eb:	55                   	push   %ebp
   158ec:	89 e5                	mov    %esp,%ebp
   158ee:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   158f1:	83 ec 0c             	sub    $0xc,%esp
   158f4:	ff 75 08             	pushl  0x8(%ebp)
   158f7:	e8 8d e8 ff ff       	call   14189 <_DecodeLength>
   158fc:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   158ff:	8b 45 08             	mov    0x8(%ebp),%eax
   15902:	8b 40 0c             	mov    0xc(%eax),%eax
   15905:	83 ec 08             	sub    $0x8,%esp
   15908:	50                   	push   %eax
   15909:	ff 75 08             	pushl  0x8(%ebp)
   1590c:	e8 2c e8 ff ff       	call   1413d <_Skip>
   15911:	83 c4 10             	add    $0x10,%esp
}
   15914:	90                   	nop
   15915:	c9                   	leave  
   15916:	c3                   	ret    

00015917 <_Convert>:

void _Convert(Context* ctx){
   15917:	55                   	push   %ebp
   15918:	89 e5                	mov    %esp,%ebp
   1591a:	57                   	push   %edi
   1591b:	56                   	push   %esi
   1591c:	53                   	push   %ebx
   1591d:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15920:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   15927:	8b 45 08             	mov    0x8(%ebp),%eax
   1592a:	83 c0 2c             	add    $0x2c,%eax
   1592d:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15930:	e9 b2 00 00 00       	jmp    159e7 <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   15935:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15938:	8b 50 0c             	mov    0xc(%eax),%edx
   1593b:	8b 45 08             	mov    0x8(%ebp),%eax
   1593e:	8b 40 10             	mov    0x10(%eax),%eax
   15941:	39 c2                	cmp    %eax,%edx
   15943:	7d 11                	jge    15956 <_Convert+0x3f>
   15945:	83 ec 08             	sub    $0x8,%esp
   15948:	ff 75 e0             	pushl  -0x20(%ebp)
   1594b:	ff 75 08             	pushl  0x8(%ebp)
   1594e:	e8 79 02 00 00       	call   15bcc <_UpsampleH>
   15953:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15956:	8b 45 08             	mov    0x8(%ebp),%eax
   15959:	8b 00                	mov    (%eax),%eax
   1595b:	85 c0                	test   %eax,%eax
   1595d:	0f 85 5d 02 00 00    	jne    15bc0 <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   15963:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15966:	8b 50 10             	mov    0x10(%eax),%edx
   15969:	8b 45 08             	mov    0x8(%ebp),%eax
   1596c:	8b 40 14             	mov    0x14(%eax),%eax
   1596f:	39 c2                	cmp    %eax,%edx
   15971:	7d 11                	jge    15984 <_Convert+0x6d>
   15973:	83 ec 08             	sub    $0x8,%esp
   15976:	ff 75 e0             	pushl  -0x20(%ebp)
   15979:	ff 75 08             	pushl  0x8(%ebp)
   1597c:	e8 db 05 00 00       	call   15f5c <_UpsampleV>
   15981:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15984:	8b 45 08             	mov    0x8(%ebp),%eax
   15987:	8b 00                	mov    (%eax),%eax
   15989:	85 c0                	test   %eax,%eax
   1598b:	0f 85 32 02 00 00    	jne    15bc3 <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   15991:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15994:	8b 50 0c             	mov    0xc(%eax),%edx
   15997:	8b 45 08             	mov    0x8(%ebp),%eax
   1599a:	8b 40 10             	mov    0x10(%eax),%eax
   1599d:	39 c2                	cmp    %eax,%edx
   1599f:	7c 94                	jl     15935 <_Convert+0x1e>
   159a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   159a4:	8b 50 10             	mov    0x10(%eax),%edx
   159a7:	8b 45 08             	mov    0x8(%ebp),%eax
   159aa:	8b 40 14             	mov    0x14(%eax),%eax
   159ad:	39 c2                	cmp    %eax,%edx
   159af:	7c 84                	jl     15935 <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   159b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   159b4:	8b 50 0c             	mov    0xc(%eax),%edx
   159b7:	8b 45 08             	mov    0x8(%ebp),%eax
   159ba:	8b 40 10             	mov    0x10(%eax),%eax
   159bd:	39 c2                	cmp    %eax,%edx
   159bf:	7c 10                	jl     159d1 <_Convert+0xba>
   159c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   159c4:	8b 50 10             	mov    0x10(%eax),%edx
   159c7:	8b 45 08             	mov    0x8(%ebp),%eax
   159ca:	8b 40 14             	mov    0x14(%eax),%eax
   159cd:	39 c2                	cmp    %eax,%edx
   159cf:	7d 0e                	jge    159df <_Convert+0xc8>
   159d1:	8b 45 08             	mov    0x8(%ebp),%eax
   159d4:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   159da:	e9 e5 01 00 00       	jmp    15bc4 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   159df:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   159e3:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   159e7:	8b 45 08             	mov    0x8(%ebp),%eax
   159ea:	8b 40 28             	mov    0x28(%eax),%eax
   159ed:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   159f0:	7f 9f                	jg     15991 <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   159f2:	8b 45 08             	mov    0x8(%ebp),%eax
   159f5:	8b 40 28             	mov    0x28(%eax),%eax
   159f8:	83 f8 03             	cmp    $0x3,%eax
   159fb:	0f 85 3d 01 00 00    	jne    15b3e <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   15a01:	8b 45 08             	mov    0x8(%ebp),%eax
   15a04:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   15a0a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   15a0d:	8b 45 08             	mov    0x8(%ebp),%eax
   15a10:	8b 40 54             	mov    0x54(%eax),%eax
   15a13:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   15a16:	8b 45 08             	mov    0x8(%ebp),%eax
   15a19:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   15a1f:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   15a22:	8b 45 08             	mov    0x8(%ebp),%eax
   15a25:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   15a2b:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   15a2e:	8b 45 08             	mov    0x8(%ebp),%eax
   15a31:	8b 40 14             	mov    0x14(%eax),%eax
   15a34:	89 45 d8             	mov    %eax,-0x28(%ebp)
   15a37:	e9 f3 00 00 00       	jmp    15b2f <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   15a3c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   15a43:	e9 b6 00 00 00       	jmp    15afe <_Convert+0x1e7>
                register int y = py[x] << 8;
   15a48:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15a4b:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15a4e:	01 d0                	add    %edx,%eax
   15a50:	0f b6 00             	movzbl (%eax),%eax
   15a53:	0f b6 c0             	movzbl %al,%eax
   15a56:	c1 e0 08             	shl    $0x8,%eax
   15a59:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   15a5b:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15a5e:	8b 45 cc             	mov    -0x34(%ebp),%eax
   15a61:	01 d0                	add    %edx,%eax
   15a63:	0f b6 00             	movzbl (%eax),%eax
   15a66:	0f b6 c0             	movzbl %al,%eax
   15a69:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   15a6c:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15a6f:	8b 45 c8             	mov    -0x38(%ebp),%eax
   15a72:	01 d0                	add    %edx,%eax
   15a74:	0f b6 00             	movzbl (%eax),%eax
   15a77:	0f b6 c0             	movzbl %al,%eax
   15a7a:	83 c0 80             	add    $0xffffff80,%eax
   15a7d:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   15a7f:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15a82:	8d 46 01             	lea    0x1(%esi),%eax
   15a85:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15a88:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   15a8b:	89 c8                	mov    %ecx,%eax
   15a8d:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   15a93:	01 d8                	add    %ebx,%eax
   15a95:	83 e8 80             	sub    $0xffffff80,%eax
   15a98:	c1 f8 08             	sar    $0x8,%eax
   15a9b:	83 ec 0c             	sub    $0xc,%esp
   15a9e:	50                   	push   %eax
   15a9f:	e8 74 e6 ff ff       	call   14118 <_Clip>
   15aa4:	83 c4 10             	add    $0x10,%esp
   15aa7:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   15aa9:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15aac:	8d 46 01             	lea    0x1(%esi),%eax
   15aaf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15ab2:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   15ab5:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   15ab8:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   15abf:	01 d0                	add    %edx,%eax
   15ac1:	83 e8 80             	sub    $0xffffff80,%eax
   15ac4:	c1 f8 08             	sar    $0x8,%eax
   15ac7:	83 ec 0c             	sub    $0xc,%esp
   15aca:	50                   	push   %eax
   15acb:	e8 48 e6 ff ff       	call   14118 <_Clip>
   15ad0:	83 c4 10             	add    $0x10,%esp
   15ad3:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   15ad5:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15ad8:	8d 46 01             	lea    0x1(%esi),%eax
   15adb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15ade:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   15ae4:	01 d8                	add    %ebx,%eax
   15ae6:	83 e8 80             	sub    $0xffffff80,%eax
   15ae9:	c1 f8 08             	sar    $0x8,%eax
   15aec:	83 ec 0c             	sub    $0xc,%esp
   15aef:	50                   	push   %eax
   15af0:	e8 23 e6 ff ff       	call   14118 <_Clip>
   15af5:	83 c4 10             	add    $0x10,%esp
   15af8:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   15afa:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   15afe:	8b 45 08             	mov    0x8(%ebp),%eax
   15b01:	8b 40 10             	mov    0x10(%eax),%eax
   15b04:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   15b07:	0f 8f 3b ff ff ff    	jg     15a48 <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   15b0d:	8b 45 08             	mov    0x8(%ebp),%eax
   15b10:	8b 40 40             	mov    0x40(%eax),%eax
   15b13:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   15b16:	8b 45 08             	mov    0x8(%ebp),%eax
   15b19:	8b 40 6c             	mov    0x6c(%eax),%eax
   15b1c:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   15b1f:	8b 45 08             	mov    0x8(%ebp),%eax
   15b22:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   15b28:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   15b2b:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   15b2f:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15b33:	0f 85 03 ff ff ff    	jne    15a3c <_Convert+0x125>
   15b39:	e9 86 00 00 00       	jmp    15bc4 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   15b3e:	8b 45 08             	mov    0x8(%ebp),%eax
   15b41:	8b 50 38             	mov    0x38(%eax),%edx
   15b44:	8b 45 08             	mov    0x8(%ebp),%eax
   15b47:	8b 40 40             	mov    0x40(%eax),%eax
   15b4a:	39 c2                	cmp    %eax,%edx
   15b4c:	74 76                	je     15bc4 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   15b4e:	8b 45 08             	mov    0x8(%ebp),%eax
   15b51:	8b 50 54             	mov    0x54(%eax),%edx
   15b54:	8b 45 08             	mov    0x8(%ebp),%eax
   15b57:	8b 40 40             	mov    0x40(%eax),%eax
   15b5a:	01 d0                	add    %edx,%eax
   15b5c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   15b5f:	8b 45 08             	mov    0x8(%ebp),%eax
   15b62:	8b 50 54             	mov    0x54(%eax),%edx
   15b65:	8b 45 08             	mov    0x8(%ebp),%eax
   15b68:	8b 40 38             	mov    0x38(%eax),%eax
   15b6b:	01 d0                	add    %edx,%eax
   15b6d:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   15b70:	8b 45 08             	mov    0x8(%ebp),%eax
   15b73:	8b 40 3c             	mov    0x3c(%eax),%eax
   15b76:	83 e8 01             	sub    $0x1,%eax
   15b79:	89 45 bc             	mov    %eax,-0x44(%ebp)
   15b7c:	eb 2e                	jmp    15bac <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   15b7e:	8b 45 08             	mov    0x8(%ebp),%eax
   15b81:	8b 40 38             	mov    0x38(%eax),%eax
   15b84:	83 ec 04             	sub    $0x4,%esp
   15b87:	50                   	push   %eax
   15b88:	ff 75 c4             	pushl  -0x3c(%ebp)
   15b8b:	ff 75 c0             	pushl  -0x40(%ebp)
   15b8e:	e8 72 ac fe ff       	call   805 <memmove>
   15b93:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   15b96:	8b 45 08             	mov    0x8(%ebp),%eax
   15b99:	8b 40 40             	mov    0x40(%eax),%eax
   15b9c:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   15b9f:	8b 45 08             	mov    0x8(%ebp),%eax
   15ba2:	8b 40 38             	mov    0x38(%eax),%eax
   15ba5:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   15ba8:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   15bac:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   15bb0:	75 cc                	jne    15b7e <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   15bb2:	8b 45 08             	mov    0x8(%ebp),%eax
   15bb5:	8b 50 38             	mov    0x38(%eax),%edx
   15bb8:	8b 45 08             	mov    0x8(%ebp),%eax
   15bbb:	89 50 40             	mov    %edx,0x40(%eax)
   15bbe:	eb 04                	jmp    15bc4 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   15bc0:	90                   	nop
   15bc1:	eb 01                	jmp    15bc4 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   15bc3:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   15bc4:	8d 65 f4             	lea    -0xc(%ebp),%esp
   15bc7:	5b                   	pop    %ebx
   15bc8:	5e                   	pop    %esi
   15bc9:	5f                   	pop    %edi
   15bca:	5d                   	pop    %ebp
   15bcb:	c3                   	ret    

00015bcc <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   15bcc:	55                   	push   %ebp
   15bcd:	89 e5                	mov    %esp,%ebp
   15bcf:	53                   	push   %ebx
   15bd0:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   15bd3:	8b 45 0c             	mov    0xc(%ebp),%eax
   15bd6:	8b 40 0c             	mov    0xc(%eax),%eax
   15bd9:	83 e8 03             	sub    $0x3,%eax
   15bdc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15bdf:	8b 45 0c             	mov    0xc(%ebp),%eax
   15be2:	8b 50 0c             	mov    0xc(%eax),%edx
   15be5:	8b 45 0c             	mov    0xc(%ebp),%eax
   15be8:	8b 40 10             	mov    0x10(%eax),%eax
   15beb:	0f af c2             	imul   %edx,%eax
   15bee:	01 c0                	add    %eax,%eax
   15bf0:	83 ec 0c             	sub    $0xc,%esp
   15bf3:	50                   	push   %eax
   15bf4:	e8 cb b0 fe ff       	call   cc4 <malloc>
   15bf9:	83 c4 10             	add    $0x10,%esp
   15bfc:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15bff:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15c03:	75 0e                	jne    15c13 <_UpsampleH+0x47>
   15c05:	8b 45 08             	mov    0x8(%ebp),%eax
   15c08:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15c0e:	e9 44 03 00 00       	jmp    15f57 <_UpsampleH+0x38b>
    lin = c->pixels;
   15c13:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c16:	8b 40 28             	mov    0x28(%eax),%eax
   15c19:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   15c1c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c1f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   15c22:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c25:	8b 40 10             	mov    0x10(%eax),%eax
   15c28:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   15c2b:	e9 e0 02 00 00       	jmp    15f10 <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   15c30:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c33:	0f b6 00             	movzbl (%eax),%eax
   15c36:	0f b6 c0             	movzbl %al,%eax
   15c39:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15c3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c42:	83 c0 01             	add    $0x1,%eax
   15c45:	0f b6 00             	movzbl (%eax),%eax
   15c48:	0f b6 c0             	movzbl %al,%eax
   15c4b:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15c4e:	01 d0                	add    %edx,%eax
   15c50:	83 ec 0c             	sub    $0xc,%esp
   15c53:	50                   	push   %eax
   15c54:	e8 c4 06 00 00       	call   1631d <CF>
   15c59:	83 c4 10             	add    $0x10,%esp
   15c5c:	89 c2                	mov    %eax,%edx
   15c5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c61:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   15c63:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c66:	8d 58 01             	lea    0x1(%eax),%ebx
   15c69:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c6c:	0f b6 00             	movzbl (%eax),%eax
   15c6f:	0f b6 c0             	movzbl %al,%eax
   15c72:	6b c8 68             	imul   $0x68,%eax,%ecx
   15c75:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c78:	83 c0 01             	add    $0x1,%eax
   15c7b:	0f b6 00             	movzbl (%eax),%eax
   15c7e:	0f b6 d0             	movzbl %al,%edx
   15c81:	89 d0                	mov    %edx,%eax
   15c83:	01 c0                	add    %eax,%eax
   15c85:	01 d0                	add    %edx,%eax
   15c87:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15c8e:	01 d0                	add    %edx,%eax
   15c90:	01 c1                	add    %eax,%ecx
   15c92:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c95:	83 c0 02             	add    $0x2,%eax
   15c98:	0f b6 00             	movzbl (%eax),%eax
   15c9b:	0f b6 d0             	movzbl %al,%edx
   15c9e:	89 d0                	mov    %edx,%eax
   15ca0:	01 c0                	add    %eax,%eax
   15ca2:	01 d0                	add    %edx,%eax
   15ca4:	f7 d8                	neg    %eax
   15ca6:	01 c8                	add    %ecx,%eax
   15ca8:	83 ec 0c             	sub    $0xc,%esp
   15cab:	50                   	push   %eax
   15cac:	e8 6c 06 00 00       	call   1631d <CF>
   15cb1:	83 c4 10             	add    $0x10,%esp
   15cb4:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   15cb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15cb9:	8d 58 02             	lea    0x2(%eax),%ebx
   15cbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cbf:	0f b6 00             	movzbl (%eax),%eax
   15cc2:	0f b6 c0             	movzbl %al,%eax
   15cc5:	c1 e0 02             	shl    $0x2,%eax
   15cc8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15ccf:	29 c2                	sub    %eax,%edx
   15cd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cd4:	83 c0 01             	add    $0x1,%eax
   15cd7:	0f b6 00             	movzbl (%eax),%eax
   15cda:	0f b6 c0             	movzbl %al,%eax
   15cdd:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15ce0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15ce3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ce6:	83 c0 02             	add    $0x2,%eax
   15ce9:	0f b6 00             	movzbl (%eax),%eax
   15cec:	0f b6 d0             	movzbl %al,%edx
   15cef:	89 d0                	mov    %edx,%eax
   15cf1:	c1 e0 03             	shl    $0x3,%eax
   15cf4:	01 d0                	add    %edx,%eax
   15cf6:	f7 d8                	neg    %eax
   15cf8:	01 c8                	add    %ecx,%eax
   15cfa:	83 ec 0c             	sub    $0xc,%esp
   15cfd:	50                   	push   %eax
   15cfe:	e8 1a 06 00 00       	call   1631d <CF>
   15d03:	83 c4 10             	add    $0x10,%esp
   15d06:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   15d08:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15d0f:	e9 fa 00 00 00       	jmp    15e0e <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   15d14:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d17:	01 c0                	add    %eax,%eax
   15d19:	8d 50 03             	lea    0x3(%eax),%edx
   15d1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d1f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15d22:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15d25:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d28:	01 d0                	add    %edx,%eax
   15d2a:	0f b6 00             	movzbl (%eax),%eax
   15d2d:	0f b6 d0             	movzbl %al,%edx
   15d30:	89 d0                	mov    %edx,%eax
   15d32:	c1 e0 03             	shl    $0x3,%eax
   15d35:	01 d0                	add    %edx,%eax
   15d37:	f7 d8                	neg    %eax
   15d39:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15d3c:	8d 4a 01             	lea    0x1(%edx),%ecx
   15d3f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15d42:	01 ca                	add    %ecx,%edx
   15d44:	0f b6 12             	movzbl (%edx),%edx
   15d47:	0f b6 d2             	movzbl %dl,%edx
   15d4a:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15d4d:	01 c2                	add    %eax,%edx
   15d4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d52:	8d 48 02             	lea    0x2(%eax),%ecx
   15d55:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d58:	01 c8                	add    %ecx,%eax
   15d5a:	0f b6 00             	movzbl (%eax),%eax
   15d5d:	0f b6 c0             	movzbl %al,%eax
   15d60:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15d63:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15d66:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d69:	8d 50 03             	lea    0x3(%eax),%edx
   15d6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d6f:	01 d0                	add    %edx,%eax
   15d71:	0f b6 00             	movzbl (%eax),%eax
   15d74:	0f b6 d0             	movzbl %al,%edx
   15d77:	89 d0                	mov    %edx,%eax
   15d79:	01 c0                	add    %eax,%eax
   15d7b:	01 d0                	add    %edx,%eax
   15d7d:	f7 d8                	neg    %eax
   15d7f:	01 c8                	add    %ecx,%eax
   15d81:	83 ec 0c             	sub    $0xc,%esp
   15d84:	50                   	push   %eax
   15d85:	e8 93 05 00 00       	call   1631d <CF>
   15d8a:	83 c4 10             	add    $0x10,%esp
   15d8d:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   15d8f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d92:	01 c0                	add    %eax,%eax
   15d94:	8d 50 04             	lea    0x4(%eax),%edx
   15d97:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d9a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15d9d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15da0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15da3:	01 d0                	add    %edx,%eax
   15da5:	0f b6 00             	movzbl (%eax),%eax
   15da8:	0f b6 d0             	movzbl %al,%edx
   15dab:	89 d0                	mov    %edx,%eax
   15dad:	01 c0                	add    %eax,%eax
   15daf:	01 d0                	add    %edx,%eax
   15db1:	f7 d8                	neg    %eax
   15db3:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15db6:	8d 4a 01             	lea    0x1(%edx),%ecx
   15db9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15dbc:	01 ca                	add    %ecx,%edx
   15dbe:	0f b6 12             	movzbl (%edx),%edx
   15dc1:	0f b6 d2             	movzbl %dl,%edx
   15dc4:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15dc7:	01 c2                	add    %eax,%edx
   15dc9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15dcc:	8d 48 02             	lea    0x2(%eax),%ecx
   15dcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dd2:	01 c8                	add    %ecx,%eax
   15dd4:	0f b6 00             	movzbl (%eax),%eax
   15dd7:	0f b6 c0             	movzbl %al,%eax
   15dda:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15ddd:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15de0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15de3:	8d 50 03             	lea    0x3(%eax),%edx
   15de6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15de9:	01 d0                	add    %edx,%eax
   15deb:	0f b6 00             	movzbl (%eax),%eax
   15dee:	0f b6 d0             	movzbl %al,%edx
   15df1:	89 d0                	mov    %edx,%eax
   15df3:	c1 e0 03             	shl    $0x3,%eax
   15df6:	01 d0                	add    %edx,%eax
   15df8:	f7 d8                	neg    %eax
   15dfa:	01 c8                	add    %ecx,%eax
   15dfc:	83 ec 0c             	sub    $0xc,%esp
   15dff:	50                   	push   %eax
   15e00:	e8 18 05 00 00       	call   1631d <CF>
   15e05:	83 c4 10             	add    $0x10,%esp
   15e08:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   15e0a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15e0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15e11:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15e14:	0f 8c fa fe ff ff    	jl     15d14 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   15e1a:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e1d:	8b 40 14             	mov    0x14(%eax),%eax
   15e20:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   15e23:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e26:	8b 40 0c             	mov    0xc(%eax),%eax
   15e29:	01 c0                	add    %eax,%eax
   15e2b:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   15e2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e31:	8d 58 fd             	lea    -0x3(%eax),%ebx
   15e34:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e37:	83 e8 01             	sub    $0x1,%eax
   15e3a:	0f b6 00             	movzbl (%eax),%eax
   15e3d:	0f b6 c0             	movzbl %al,%eax
   15e40:	c1 e0 02             	shl    $0x2,%eax
   15e43:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15e4a:	29 c2                	sub    %eax,%edx
   15e4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e4f:	83 e8 02             	sub    $0x2,%eax
   15e52:	0f b6 00             	movzbl (%eax),%eax
   15e55:	0f b6 c0             	movzbl %al,%eax
   15e58:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15e5b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15e5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e61:	83 e8 03             	sub    $0x3,%eax
   15e64:	0f b6 00             	movzbl (%eax),%eax
   15e67:	0f b6 d0             	movzbl %al,%edx
   15e6a:	89 d0                	mov    %edx,%eax
   15e6c:	c1 e0 03             	shl    $0x3,%eax
   15e6f:	01 d0                	add    %edx,%eax
   15e71:	f7 d8                	neg    %eax
   15e73:	01 c8                	add    %ecx,%eax
   15e75:	83 ec 0c             	sub    $0xc,%esp
   15e78:	50                   	push   %eax
   15e79:	e8 9f 04 00 00       	call   1631d <CF>
   15e7e:	83 c4 10             	add    $0x10,%esp
   15e81:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   15e83:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e86:	8d 58 fe             	lea    -0x2(%eax),%ebx
   15e89:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e8c:	83 e8 01             	sub    $0x1,%eax
   15e8f:	0f b6 00             	movzbl (%eax),%eax
   15e92:	0f b6 c0             	movzbl %al,%eax
   15e95:	6b c8 68             	imul   $0x68,%eax,%ecx
   15e98:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e9b:	83 e8 02             	sub    $0x2,%eax
   15e9e:	0f b6 00             	movzbl (%eax),%eax
   15ea1:	0f b6 d0             	movzbl %al,%edx
   15ea4:	89 d0                	mov    %edx,%eax
   15ea6:	01 c0                	add    %eax,%eax
   15ea8:	01 d0                	add    %edx,%eax
   15eaa:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15eb1:	01 d0                	add    %edx,%eax
   15eb3:	01 c1                	add    %eax,%ecx
   15eb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15eb8:	83 e8 03             	sub    $0x3,%eax
   15ebb:	0f b6 00             	movzbl (%eax),%eax
   15ebe:	0f b6 d0             	movzbl %al,%edx
   15ec1:	89 d0                	mov    %edx,%eax
   15ec3:	01 c0                	add    %eax,%eax
   15ec5:	01 d0                	add    %edx,%eax
   15ec7:	f7 d8                	neg    %eax
   15ec9:	01 c8                	add    %ecx,%eax
   15ecb:	83 ec 0c             	sub    $0xc,%esp
   15ece:	50                   	push   %eax
   15ecf:	e8 49 04 00 00       	call   1631d <CF>
   15ed4:	83 c4 10             	add    $0x10,%esp
   15ed7:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   15ed9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15edc:	8d 58 ff             	lea    -0x1(%eax),%ebx
   15edf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ee2:	83 e8 01             	sub    $0x1,%eax
   15ee5:	0f b6 00             	movzbl (%eax),%eax
   15ee8:	0f b6 c0             	movzbl %al,%eax
   15eeb:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15ef1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ef4:	83 e8 02             	sub    $0x2,%eax
   15ef7:	0f b6 00             	movzbl (%eax),%eax
   15efa:	0f b6 c0             	movzbl %al,%eax
   15efd:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15f00:	01 d0                	add    %edx,%eax
   15f02:	83 ec 0c             	sub    $0xc,%esp
   15f05:	50                   	push   %eax
   15f06:	e8 12 04 00 00       	call   1631d <CF>
   15f0b:	83 c4 10             	add    $0x10,%esp
   15f0e:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   15f10:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f13:	8d 50 ff             	lea    -0x1(%eax),%edx
   15f16:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15f19:	85 c0                	test   %eax,%eax
   15f1b:	0f 85 0f fd ff ff    	jne    15c30 <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   15f21:	8b 45 0c             	mov    0xc(%ebp),%eax
   15f24:	8b 40 0c             	mov    0xc(%eax),%eax
   15f27:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15f2a:	8b 45 0c             	mov    0xc(%ebp),%eax
   15f2d:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   15f30:	8b 45 0c             	mov    0xc(%ebp),%eax
   15f33:	8b 50 0c             	mov    0xc(%eax),%edx
   15f36:	8b 45 0c             	mov    0xc(%ebp),%eax
   15f39:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15f3c:	8b 45 0c             	mov    0xc(%ebp),%eax
   15f3f:	8b 40 28             	mov    0x28(%eax),%eax
   15f42:	83 ec 0c             	sub    $0xc,%esp
   15f45:	50                   	push   %eax
   15f46:	e8 37 ac fe ff       	call   b82 <free>
   15f4b:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15f4e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15f51:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15f54:	89 50 28             	mov    %edx,0x28(%eax)
}
   15f57:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15f5a:	c9                   	leave  
   15f5b:	c3                   	ret    

00015f5c <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   15f5c:	55                   	push   %ebp
   15f5d:	89 e5                	mov    %esp,%ebp
   15f5f:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   15f62:	8b 45 0c             	mov    0xc(%ebp),%eax
   15f65:	8b 40 0c             	mov    0xc(%eax),%eax
   15f68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   15f6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   15f6e:	8b 40 14             	mov    0x14(%eax),%eax
   15f71:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15f74:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f77:	01 c0                	add    %eax,%eax
   15f79:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15f7c:	8b 45 0c             	mov    0xc(%ebp),%eax
   15f7f:	8b 50 0c             	mov    0xc(%eax),%edx
   15f82:	8b 45 0c             	mov    0xc(%ebp),%eax
   15f85:	8b 40 10             	mov    0x10(%eax),%eax
   15f88:	0f af c2             	imul   %edx,%eax
   15f8b:	01 c0                	add    %eax,%eax
   15f8d:	83 ec 0c             	sub    $0xc,%esp
   15f90:	50                   	push   %eax
   15f91:	e8 2e ad fe ff       	call   cc4 <malloc>
   15f96:	83 c4 10             	add    $0x10,%esp
   15f99:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15f9c:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15fa0:	75 0e                	jne    15fb0 <_UpsampleV+0x54>
   15fa2:	8b 45 08             	mov    0x8(%ebp),%eax
   15fa5:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15fab:	e9 6b 03 00 00       	jmp    1631b <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   15fb0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15fb7:	e9 1d 03 00 00       	jmp    162d9 <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   15fbc:	8b 45 0c             	mov    0xc(%ebp),%eax
   15fbf:	8b 50 28             	mov    0x28(%eax),%edx
   15fc2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15fc5:	01 d0                	add    %edx,%eax
   15fc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   15fca:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15fcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15fd0:	01 d0                	add    %edx,%eax
   15fd2:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   15fd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15fd8:	0f b6 00             	movzbl (%eax),%eax
   15fdb:	0f b6 c0             	movzbl %al,%eax
   15fde:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15fe4:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15fe7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15fea:	01 c8                	add    %ecx,%eax
   15fec:	0f b6 00             	movzbl (%eax),%eax
   15fef:	0f b6 c0             	movzbl %al,%eax
   15ff2:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15ff5:	01 d0                	add    %edx,%eax
   15ff7:	83 ec 0c             	sub    $0xc,%esp
   15ffa:	50                   	push   %eax
   15ffb:	e8 1d 03 00 00       	call   1631d <CF>
   16000:	83 c4 10             	add    $0x10,%esp
   16003:	89 c2                	mov    %eax,%edx
   16005:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16008:	88 10                	mov    %dl,(%eax)
   1600a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1600d:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   16010:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16013:	0f b6 00             	movzbl (%eax),%eax
   16016:	0f b6 c0             	movzbl %al,%eax
   16019:	6b c8 68             	imul   $0x68,%eax,%ecx
   1601c:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1601f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16022:	01 d0                	add    %edx,%eax
   16024:	0f b6 00             	movzbl (%eax),%eax
   16027:	0f b6 d0             	movzbl %al,%edx
   1602a:	89 d0                	mov    %edx,%eax
   1602c:	01 c0                	add    %eax,%eax
   1602e:	01 d0                	add    %edx,%eax
   16030:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16037:	01 d0                	add    %edx,%eax
   16039:	01 c1                	add    %eax,%ecx
   1603b:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1603e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16041:	01 d0                	add    %edx,%eax
   16043:	0f b6 00             	movzbl (%eax),%eax
   16046:	0f b6 d0             	movzbl %al,%edx
   16049:	89 d0                	mov    %edx,%eax
   1604b:	01 c0                	add    %eax,%eax
   1604d:	01 d0                	add    %edx,%eax
   1604f:	f7 d8                	neg    %eax
   16051:	01 c8                	add    %ecx,%eax
   16053:	83 ec 0c             	sub    $0xc,%esp
   16056:	50                   	push   %eax
   16057:	e8 c1 02 00 00       	call   1631d <CF>
   1605c:	83 c4 10             	add    $0x10,%esp
   1605f:	89 c2                	mov    %eax,%edx
   16061:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16064:	88 10                	mov    %dl,(%eax)
   16066:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16069:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   1606c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1606f:	0f b6 00             	movzbl (%eax),%eax
   16072:	0f b6 c0             	movzbl %al,%eax
   16075:	c1 e0 02             	shl    $0x2,%eax
   16078:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1607f:	89 d1                	mov    %edx,%ecx
   16081:	29 c1                	sub    %eax,%ecx
   16083:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16086:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16089:	01 d0                	add    %edx,%eax
   1608b:	0f b6 00             	movzbl (%eax),%eax
   1608e:	0f b6 c0             	movzbl %al,%eax
   16091:	6b c0 6d             	imul   $0x6d,%eax,%eax
   16094:	01 c1                	add    %eax,%ecx
   16096:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16099:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1609c:	01 d0                	add    %edx,%eax
   1609e:	0f b6 00             	movzbl (%eax),%eax
   160a1:	0f b6 d0             	movzbl %al,%edx
   160a4:	89 d0                	mov    %edx,%eax
   160a6:	c1 e0 03             	shl    $0x3,%eax
   160a9:	01 d0                	add    %edx,%eax
   160ab:	f7 d8                	neg    %eax
   160ad:	01 c8                	add    %ecx,%eax
   160af:	83 ec 0c             	sub    $0xc,%esp
   160b2:	50                   	push   %eax
   160b3:	e8 65 02 00 00       	call   1631d <CF>
   160b8:	83 c4 10             	add    $0x10,%esp
   160bb:	89 c2                	mov    %eax,%edx
   160bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   160c0:	88 10                	mov    %dl,(%eax)
   160c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   160c5:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   160c8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   160cb:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   160ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   160d1:	8b 40 10             	mov    0x10(%eax),%eax
   160d4:	83 e8 03             	sub    $0x3,%eax
   160d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
   160da:	e9 e6 00 00 00       	jmp    161c5 <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   160df:	8b 45 e0             	mov    -0x20(%ebp),%eax
   160e2:	f7 d8                	neg    %eax
   160e4:	89 c2                	mov    %eax,%edx
   160e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   160e9:	01 d0                	add    %edx,%eax
   160eb:	0f b6 00             	movzbl (%eax),%eax
   160ee:	0f b6 d0             	movzbl %al,%edx
   160f1:	89 d0                	mov    %edx,%eax
   160f3:	c1 e0 03             	shl    $0x3,%eax
   160f6:	01 d0                	add    %edx,%eax
   160f8:	f7 d8                	neg    %eax
   160fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
   160fd:	0f b6 12             	movzbl (%edx),%edx
   16100:	0f b6 d2             	movzbl %dl,%edx
   16103:	6b d2 6f             	imul   $0x6f,%edx,%edx
   16106:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   16109:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1610c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1610f:	01 d0                	add    %edx,%eax
   16111:	0f b6 00             	movzbl (%eax),%eax
   16114:	0f b6 c0             	movzbl %al,%eax
   16117:	6b c0 1d             	imul   $0x1d,%eax,%eax
   1611a:	01 c1                	add    %eax,%ecx
   1611c:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1611f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16122:	01 d0                	add    %edx,%eax
   16124:	0f b6 00             	movzbl (%eax),%eax
   16127:	0f b6 d0             	movzbl %al,%edx
   1612a:	89 d0                	mov    %edx,%eax
   1612c:	01 c0                	add    %eax,%eax
   1612e:	01 d0                	add    %edx,%eax
   16130:	f7 d8                	neg    %eax
   16132:	01 c8                	add    %ecx,%eax
   16134:	83 ec 0c             	sub    $0xc,%esp
   16137:	50                   	push   %eax
   16138:	e8 e0 01 00 00       	call   1631d <CF>
   1613d:	83 c4 10             	add    $0x10,%esp
   16140:	89 c2                	mov    %eax,%edx
   16142:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16145:	88 10                	mov    %dl,(%eax)
   16147:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1614a:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   1614d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16150:	f7 d8                	neg    %eax
   16152:	89 c2                	mov    %eax,%edx
   16154:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16157:	01 d0                	add    %edx,%eax
   16159:	0f b6 00             	movzbl (%eax),%eax
   1615c:	0f b6 d0             	movzbl %al,%edx
   1615f:	89 d0                	mov    %edx,%eax
   16161:	01 c0                	add    %eax,%eax
   16163:	01 d0                	add    %edx,%eax
   16165:	f7 d8                	neg    %eax
   16167:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1616a:	0f b6 12             	movzbl (%edx),%edx
   1616d:	0f b6 d2             	movzbl %dl,%edx
   16170:	6b d2 1d             	imul   $0x1d,%edx,%edx
   16173:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   16176:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16179:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1617c:	01 d0                	add    %edx,%eax
   1617e:	0f b6 00             	movzbl (%eax),%eax
   16181:	0f b6 c0             	movzbl %al,%eax
   16184:	6b c0 6f             	imul   $0x6f,%eax,%eax
   16187:	01 c1                	add    %eax,%ecx
   16189:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1618c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1618f:	01 d0                	add    %edx,%eax
   16191:	0f b6 00             	movzbl (%eax),%eax
   16194:	0f b6 d0             	movzbl %al,%edx
   16197:	89 d0                	mov    %edx,%eax
   16199:	c1 e0 03             	shl    $0x3,%eax
   1619c:	01 d0                	add    %edx,%eax
   1619e:	f7 d8                	neg    %eax
   161a0:	01 c8                	add    %ecx,%eax
   161a2:	83 ec 0c             	sub    $0xc,%esp
   161a5:	50                   	push   %eax
   161a6:	e8 72 01 00 00       	call   1631d <CF>
   161ab:	83 c4 10             	add    $0x10,%esp
   161ae:	89 c2                	mov    %eax,%edx
   161b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   161b3:	88 10                	mov    %dl,(%eax)
   161b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   161b8:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   161bb:	8b 45 e0             	mov    -0x20(%ebp),%eax
   161be:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   161c1:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   161c5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   161c9:	0f 85 10 ff ff ff    	jne    160df <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   161cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
   161d2:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   161d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   161d8:	0f b6 00             	movzbl (%eax),%eax
   161db:	0f b6 c0             	movzbl %al,%eax
   161de:	c1 e0 02             	shl    $0x2,%eax
   161e1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   161e8:	29 c2                	sub    %eax,%edx
   161ea:	8b 45 e0             	mov    -0x20(%ebp),%eax
   161ed:	f7 d8                	neg    %eax
   161ef:	89 c1                	mov    %eax,%ecx
   161f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   161f4:	01 c8                	add    %ecx,%eax
   161f6:	0f b6 00             	movzbl (%eax),%eax
   161f9:	0f b6 c0             	movzbl %al,%eax
   161fc:	6b c0 6d             	imul   $0x6d,%eax,%eax
   161ff:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   16202:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16205:	f7 d8                	neg    %eax
   16207:	89 c2                	mov    %eax,%edx
   16209:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1620c:	01 d0                	add    %edx,%eax
   1620e:	0f b6 00             	movzbl (%eax),%eax
   16211:	0f b6 d0             	movzbl %al,%edx
   16214:	89 d0                	mov    %edx,%eax
   16216:	c1 e0 03             	shl    $0x3,%eax
   16219:	01 d0                	add    %edx,%eax
   1621b:	f7 d8                	neg    %eax
   1621d:	01 c8                	add    %ecx,%eax
   1621f:	83 ec 0c             	sub    $0xc,%esp
   16222:	50                   	push   %eax
   16223:	e8 f5 00 00 00       	call   1631d <CF>
   16228:	83 c4 10             	add    $0x10,%esp
   1622b:	89 c2                	mov    %eax,%edx
   1622d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16230:	88 10                	mov    %dl,(%eax)
   16232:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16235:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   16238:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1623b:	0f b6 00             	movzbl (%eax),%eax
   1623e:	0f b6 c0             	movzbl %al,%eax
   16241:	6b c8 68             	imul   $0x68,%eax,%ecx
   16244:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16247:	f7 d8                	neg    %eax
   16249:	89 c2                	mov    %eax,%edx
   1624b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1624e:	01 d0                	add    %edx,%eax
   16250:	0f b6 00             	movzbl (%eax),%eax
   16253:	0f b6 d0             	movzbl %al,%edx
   16256:	89 d0                	mov    %edx,%eax
   16258:	01 c0                	add    %eax,%eax
   1625a:	01 d0                	add    %edx,%eax
   1625c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16263:	01 d0                	add    %edx,%eax
   16265:	01 c1                	add    %eax,%ecx
   16267:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1626a:	f7 d8                	neg    %eax
   1626c:	89 c2                	mov    %eax,%edx
   1626e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16271:	01 d0                	add    %edx,%eax
   16273:	0f b6 00             	movzbl (%eax),%eax
   16276:	0f b6 d0             	movzbl %al,%edx
   16279:	89 d0                	mov    %edx,%eax
   1627b:	01 c0                	add    %eax,%eax
   1627d:	01 d0                	add    %edx,%eax
   1627f:	f7 d8                	neg    %eax
   16281:	01 c8                	add    %ecx,%eax
   16283:	83 ec 0c             	sub    $0xc,%esp
   16286:	50                   	push   %eax
   16287:	e8 91 00 00 00       	call   1631d <CF>
   1628c:	83 c4 10             	add    $0x10,%esp
   1628f:	89 c2                	mov    %eax,%edx
   16291:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16294:	88 10                	mov    %dl,(%eax)
   16296:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16299:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   1629c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1629f:	0f b6 00             	movzbl (%eax),%eax
   162a2:	0f b6 c0             	movzbl %al,%eax
   162a5:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   162ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
   162ae:	f7 d8                	neg    %eax
   162b0:	89 c1                	mov    %eax,%ecx
   162b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   162b5:	01 c8                	add    %ecx,%eax
   162b7:	0f b6 00             	movzbl (%eax),%eax
   162ba:	0f b6 c0             	movzbl %al,%eax
   162bd:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   162c0:	01 d0                	add    %edx,%eax
   162c2:	83 ec 0c             	sub    $0xc,%esp
   162c5:	50                   	push   %eax
   162c6:	e8 52 00 00 00       	call   1631d <CF>
   162cb:	83 c4 10             	add    $0x10,%esp
   162ce:	89 c2                	mov    %eax,%edx
   162d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   162d3:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   162d5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   162d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   162dc:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   162df:	0f 8c d7 fc ff ff    	jl     15fbc <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   162e5:	8b 45 0c             	mov    0xc(%ebp),%eax
   162e8:	8b 40 10             	mov    0x10(%eax),%eax
   162eb:	8d 14 00             	lea    (%eax,%eax,1),%edx
   162ee:	8b 45 0c             	mov    0xc(%ebp),%eax
   162f1:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   162f4:	8b 45 0c             	mov    0xc(%ebp),%eax
   162f7:	8b 50 0c             	mov    0xc(%eax),%edx
   162fa:	8b 45 0c             	mov    0xc(%ebp),%eax
   162fd:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   16300:	8b 45 0c             	mov    0xc(%ebp),%eax
   16303:	8b 40 28             	mov    0x28(%eax),%eax
   16306:	83 ec 0c             	sub    $0xc,%esp
   16309:	50                   	push   %eax
   1630a:	e8 73 a8 fe ff       	call   b82 <free>
   1630f:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   16312:	8b 45 0c             	mov    0xc(%ebp),%eax
   16315:	8b 55 d8             	mov    -0x28(%ebp),%edx
   16318:	89 50 28             	mov    %edx,0x28(%eax)
}
   1631b:	c9                   	leave  
   1631c:	c3                   	ret    

0001631d <CF>:

uchar CF(const int x){
   1631d:	55                   	push   %ebp
   1631e:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   16320:	8b 45 08             	mov    0x8(%ebp),%eax
   16323:	83 c0 40             	add    $0x40,%eax
   16326:	c1 f8 07             	sar    $0x7,%eax
   16329:	50                   	push   %eax
   1632a:	e8 e9 dd ff ff       	call   14118 <_Clip>
   1632f:	83 c4 04             	add    $0x4,%esp
}
   16332:	c9                   	leave  
   16333:	c3                   	ret    
