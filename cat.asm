
_cat：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <cat>:

char buf[512];

void
cat(int fd)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	83 ec 18             	sub    $0x18,%esp
  int n;

  while((n = read(fd, buf, sizeof(buf))) > 0)
       6:	eb 15                	jmp    1d <cat+0x1d>
    write(1, buf, n);
       8:	83 ec 04             	sub    $0x4,%esp
       b:	ff 75 f4             	pushl  -0xc(%ebp)
       e:	68 00 e6 01 00       	push   $0x1e600
      13:	6a 01                	push   $0x1
      15:	e8 6c 03 00 00       	call   386 <write>
      1a:	83 c4 10             	add    $0x10,%esp
void
cat(int fd)
{
  int n;

  while((n = read(fd, buf, sizeof(buf))) > 0)
      1d:	83 ec 04             	sub    $0x4,%esp
      20:	68 00 02 00 00       	push   $0x200
      25:	68 00 e6 01 00       	push   $0x1e600
      2a:	ff 75 08             	pushl  0x8(%ebp)
      2d:	e8 4c 03 00 00       	call   37e <read>
      32:	83 c4 10             	add    $0x10,%esp
      35:	89 45 f4             	mov    %eax,-0xc(%ebp)
      38:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
      3c:	7f ca                	jg     8 <cat+0x8>
    write(1, buf, n);
  if(n < 0){
      3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
      42:	79 17                	jns    5b <cat+0x5b>
    printf(1, "cat: read error\n");
      44:	83 ec 08             	sub    $0x8,%esp
      47:	68 60 5e 01 00       	push   $0x15e60
      4c:	6a 01                	push   $0x1
      4e:	e8 ba 04 00 00       	call   50d <printf>
      53:	83 c4 10             	add    $0x10,%esp
    exit();
      56:	e8 0b 03 00 00       	call   366 <exit>
  }
}
      5b:	90                   	nop
      5c:	c9                   	leave  
      5d:	c3                   	ret    

0000005e <main>:

int
main(int argc, char *argv[])
{
      5e:	8d 4c 24 04          	lea    0x4(%esp),%ecx
      62:	83 e4 f0             	and    $0xfffffff0,%esp
      65:	ff 71 fc             	pushl  -0x4(%ecx)
      68:	55                   	push   %ebp
      69:	89 e5                	mov    %esp,%ebp
      6b:	53                   	push   %ebx
      6c:	51                   	push   %ecx
      6d:	83 ec 10             	sub    $0x10,%esp
      70:	89 cb                	mov    %ecx,%ebx
  int fd, i;

  if(argc <= 1){
      72:	83 3b 01             	cmpl   $0x1,(%ebx)
      75:	7f 12                	jg     89 <main+0x2b>
    cat(0);
      77:	83 ec 0c             	sub    $0xc,%esp
      7a:	6a 00                	push   $0x0
      7c:	e8 7f ff ff ff       	call   0 <cat>
      81:	83 c4 10             	add    $0x10,%esp
    exit();
      84:	e8 dd 02 00 00       	call   366 <exit>
  }

  for(i = 1; i < argc; i++){
      89:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
      90:	eb 71                	jmp    103 <main+0xa5>
    if((fd = open(argv[i], 0)) < 0){
      92:	8b 45 f4             	mov    -0xc(%ebp),%eax
      95:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
      9c:	8b 43 04             	mov    0x4(%ebx),%eax
      9f:	01 d0                	add    %edx,%eax
      a1:	8b 00                	mov    (%eax),%eax
      a3:	83 ec 08             	sub    $0x8,%esp
      a6:	6a 00                	push   $0x0
      a8:	50                   	push   %eax
      a9:	e8 f8 02 00 00       	call   3a6 <open>
      ae:	83 c4 10             	add    $0x10,%esp
      b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
      b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
      b8:	79 29                	jns    e3 <main+0x85>
      printf(1, "cat: cannot open %s\n", argv[i]);
      ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
      bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
      c4:	8b 43 04             	mov    0x4(%ebx),%eax
      c7:	01 d0                	add    %edx,%eax
      c9:	8b 00                	mov    (%eax),%eax
      cb:	83 ec 04             	sub    $0x4,%esp
      ce:	50                   	push   %eax
      cf:	68 71 5e 01 00       	push   $0x15e71
      d4:	6a 01                	push   $0x1
      d6:	e8 32 04 00 00       	call   50d <printf>
      db:	83 c4 10             	add    $0x10,%esp
      exit();
      de:	e8 83 02 00 00       	call   366 <exit>
    }
    cat(fd);
      e3:	83 ec 0c             	sub    $0xc,%esp
      e6:	ff 75 f0             	pushl  -0x10(%ebp)
      e9:	e8 12 ff ff ff       	call   0 <cat>
      ee:	83 c4 10             	add    $0x10,%esp
    close(fd);
      f1:	83 ec 0c             	sub    $0xc,%esp
      f4:	ff 75 f0             	pushl  -0x10(%ebp)
      f7:	e8 92 02 00 00       	call   38e <close>
      fc:	83 c4 10             	add    $0x10,%esp
  if(argc <= 1){
    cat(0);
    exit();
  }

  for(i = 1; i < argc; i++){
      ff:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     103:	8b 45 f4             	mov    -0xc(%ebp),%eax
     106:	3b 03                	cmp    (%ebx),%eax
     108:	7c 88                	jl     92 <main+0x34>
      exit();
    }
    cat(fd);
    close(fd);
  }
  exit();
     10a:	e8 57 02 00 00       	call   366 <exit>

0000010f <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
     10f:	55                   	push   %ebp
     110:	89 e5                	mov    %esp,%ebp
     112:	57                   	push   %edi
     113:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
     114:	8b 4d 08             	mov    0x8(%ebp),%ecx
     117:	8b 55 10             	mov    0x10(%ebp),%edx
     11a:	8b 45 0c             	mov    0xc(%ebp),%eax
     11d:	89 cb                	mov    %ecx,%ebx
     11f:	89 df                	mov    %ebx,%edi
     121:	89 d1                	mov    %edx,%ecx
     123:	fc                   	cld    
     124:	f3 aa                	rep stos %al,%es:(%edi)
     126:	89 ca                	mov    %ecx,%edx
     128:	89 fb                	mov    %edi,%ebx
     12a:	89 5d 08             	mov    %ebx,0x8(%ebp)
     12d:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
     130:	90                   	nop
     131:	5b                   	pop    %ebx
     132:	5f                   	pop    %edi
     133:	5d                   	pop    %ebp
     134:	c3                   	ret    

00000135 <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
     135:	55                   	push   %ebp
     136:	89 e5                	mov    %esp,%ebp
     138:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
     13b:	8b 45 08             	mov    0x8(%ebp),%eax
     13e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
     141:	90                   	nop
     142:	8b 45 08             	mov    0x8(%ebp),%eax
     145:	8d 50 01             	lea    0x1(%eax),%edx
     148:	89 55 08             	mov    %edx,0x8(%ebp)
     14b:	8b 55 0c             	mov    0xc(%ebp),%edx
     14e:	8d 4a 01             	lea    0x1(%edx),%ecx
     151:	89 4d 0c             	mov    %ecx,0xc(%ebp)
     154:	0f b6 12             	movzbl (%edx),%edx
     157:	88 10                	mov    %dl,(%eax)
     159:	0f b6 00             	movzbl (%eax),%eax
     15c:	84 c0                	test   %al,%al
     15e:	75 e2                	jne    142 <strcpy+0xd>
    ;
  return os;
     160:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     163:	c9                   	leave  
     164:	c3                   	ret    

00000165 <strcmp>:

int
strcmp(const char *p, const char *q)
{
     165:	55                   	push   %ebp
     166:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
     168:	eb 08                	jmp    172 <strcmp+0xd>
    p++, q++;
     16a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     16e:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
     172:	8b 45 08             	mov    0x8(%ebp),%eax
     175:	0f b6 00             	movzbl (%eax),%eax
     178:	84 c0                	test   %al,%al
     17a:	74 10                	je     18c <strcmp+0x27>
     17c:	8b 45 08             	mov    0x8(%ebp),%eax
     17f:	0f b6 10             	movzbl (%eax),%edx
     182:	8b 45 0c             	mov    0xc(%ebp),%eax
     185:	0f b6 00             	movzbl (%eax),%eax
     188:	38 c2                	cmp    %al,%dl
     18a:	74 de                	je     16a <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
     18c:	8b 45 08             	mov    0x8(%ebp),%eax
     18f:	0f b6 00             	movzbl (%eax),%eax
     192:	0f b6 d0             	movzbl %al,%edx
     195:	8b 45 0c             	mov    0xc(%ebp),%eax
     198:	0f b6 00             	movzbl (%eax),%eax
     19b:	0f b6 c0             	movzbl %al,%eax
     19e:	29 c2                	sub    %eax,%edx
     1a0:	89 d0                	mov    %edx,%eax
}
     1a2:	5d                   	pop    %ebp
     1a3:	c3                   	ret    

000001a4 <strlen>:

uint
strlen(char *s)
{
     1a4:	55                   	push   %ebp
     1a5:	89 e5                	mov    %esp,%ebp
     1a7:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     1aa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     1b1:	eb 04                	jmp    1b7 <strlen+0x13>
     1b3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     1b7:	8b 55 fc             	mov    -0x4(%ebp),%edx
     1ba:	8b 45 08             	mov    0x8(%ebp),%eax
     1bd:	01 d0                	add    %edx,%eax
     1bf:	0f b6 00             	movzbl (%eax),%eax
     1c2:	84 c0                	test   %al,%al
     1c4:	75 ed                	jne    1b3 <strlen+0xf>
    ;
  return n;
     1c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     1c9:	c9                   	leave  
     1ca:	c3                   	ret    

000001cb <memset>:

void*
memset(void *dst, int c, uint n)
{
     1cb:	55                   	push   %ebp
     1cc:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     1ce:	8b 45 10             	mov    0x10(%ebp),%eax
     1d1:	50                   	push   %eax
     1d2:	ff 75 0c             	pushl  0xc(%ebp)
     1d5:	ff 75 08             	pushl  0x8(%ebp)
     1d8:	e8 32 ff ff ff       	call   10f <stosb>
     1dd:	83 c4 0c             	add    $0xc,%esp
  return dst;
     1e0:	8b 45 08             	mov    0x8(%ebp),%eax
}
     1e3:	c9                   	leave  
     1e4:	c3                   	ret    

000001e5 <strchr>:

char*
strchr(const char *s, char c)
{
     1e5:	55                   	push   %ebp
     1e6:	89 e5                	mov    %esp,%ebp
     1e8:	83 ec 04             	sub    $0x4,%esp
     1eb:	8b 45 0c             	mov    0xc(%ebp),%eax
     1ee:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     1f1:	eb 14                	jmp    207 <strchr+0x22>
    if(*s == c)
     1f3:	8b 45 08             	mov    0x8(%ebp),%eax
     1f6:	0f b6 00             	movzbl (%eax),%eax
     1f9:	3a 45 fc             	cmp    -0x4(%ebp),%al
     1fc:	75 05                	jne    203 <strchr+0x1e>
      return (char*)s;
     1fe:	8b 45 08             	mov    0x8(%ebp),%eax
     201:	eb 13                	jmp    216 <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     203:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     207:	8b 45 08             	mov    0x8(%ebp),%eax
     20a:	0f b6 00             	movzbl (%eax),%eax
     20d:	84 c0                	test   %al,%al
     20f:	75 e2                	jne    1f3 <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     211:	b8 00 00 00 00       	mov    $0x0,%eax
}
     216:	c9                   	leave  
     217:	c3                   	ret    

00000218 <gets>:

char*
gets(char *buf, int max)
{
     218:	55                   	push   %ebp
     219:	89 e5                	mov    %esp,%ebp
     21b:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     21e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     225:	eb 42                	jmp    269 <gets+0x51>
    cc = read(0, &c, 1);
     227:	83 ec 04             	sub    $0x4,%esp
     22a:	6a 01                	push   $0x1
     22c:	8d 45 ef             	lea    -0x11(%ebp),%eax
     22f:	50                   	push   %eax
     230:	6a 00                	push   $0x0
     232:	e8 47 01 00 00       	call   37e <read>
     237:	83 c4 10             	add    $0x10,%esp
     23a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     23d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     241:	7e 33                	jle    276 <gets+0x5e>
      break;
    buf[i++] = c;
     243:	8b 45 f4             	mov    -0xc(%ebp),%eax
     246:	8d 50 01             	lea    0x1(%eax),%edx
     249:	89 55 f4             	mov    %edx,-0xc(%ebp)
     24c:	89 c2                	mov    %eax,%edx
     24e:	8b 45 08             	mov    0x8(%ebp),%eax
     251:	01 c2                	add    %eax,%edx
     253:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     257:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     259:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     25d:	3c 0a                	cmp    $0xa,%al
     25f:	74 16                	je     277 <gets+0x5f>
     261:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     265:	3c 0d                	cmp    $0xd,%al
     267:	74 0e                	je     277 <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     269:	8b 45 f4             	mov    -0xc(%ebp),%eax
     26c:	83 c0 01             	add    $0x1,%eax
     26f:	3b 45 0c             	cmp    0xc(%ebp),%eax
     272:	7c b3                	jl     227 <gets+0xf>
     274:	eb 01                	jmp    277 <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     276:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     277:	8b 55 f4             	mov    -0xc(%ebp),%edx
     27a:	8b 45 08             	mov    0x8(%ebp),%eax
     27d:	01 d0                	add    %edx,%eax
     27f:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     282:	8b 45 08             	mov    0x8(%ebp),%eax
}
     285:	c9                   	leave  
     286:	c3                   	ret    

00000287 <stat>:

int
stat(char *n, struct stat *st)
{
     287:	55                   	push   %ebp
     288:	89 e5                	mov    %esp,%ebp
     28a:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     28d:	83 ec 08             	sub    $0x8,%esp
     290:	6a 00                	push   $0x0
     292:	ff 75 08             	pushl  0x8(%ebp)
     295:	e8 0c 01 00 00       	call   3a6 <open>
     29a:	83 c4 10             	add    $0x10,%esp
     29d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     2a0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     2a4:	79 07                	jns    2ad <stat+0x26>
    return -1;
     2a6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     2ab:	eb 25                	jmp    2d2 <stat+0x4b>
  r = fstat(fd, st);
     2ad:	83 ec 08             	sub    $0x8,%esp
     2b0:	ff 75 0c             	pushl  0xc(%ebp)
     2b3:	ff 75 f4             	pushl  -0xc(%ebp)
     2b6:	e8 03 01 00 00       	call   3be <fstat>
     2bb:	83 c4 10             	add    $0x10,%esp
     2be:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     2c1:	83 ec 0c             	sub    $0xc,%esp
     2c4:	ff 75 f4             	pushl  -0xc(%ebp)
     2c7:	e8 c2 00 00 00       	call   38e <close>
     2cc:	83 c4 10             	add    $0x10,%esp
  return r;
     2cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     2d2:	c9                   	leave  
     2d3:	c3                   	ret    

000002d4 <atoi>:

int
atoi(const char *s)
{
     2d4:	55                   	push   %ebp
     2d5:	89 e5                	mov    %esp,%ebp
     2d7:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     2da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     2e1:	eb 25                	jmp    308 <atoi+0x34>
    n = n*10 + *s++ - '0';
     2e3:	8b 55 fc             	mov    -0x4(%ebp),%edx
     2e6:	89 d0                	mov    %edx,%eax
     2e8:	c1 e0 02             	shl    $0x2,%eax
     2eb:	01 d0                	add    %edx,%eax
     2ed:	01 c0                	add    %eax,%eax
     2ef:	89 c1                	mov    %eax,%ecx
     2f1:	8b 45 08             	mov    0x8(%ebp),%eax
     2f4:	8d 50 01             	lea    0x1(%eax),%edx
     2f7:	89 55 08             	mov    %edx,0x8(%ebp)
     2fa:	0f b6 00             	movzbl (%eax),%eax
     2fd:	0f be c0             	movsbl %al,%eax
     300:	01 c8                	add    %ecx,%eax
     302:	83 e8 30             	sub    $0x30,%eax
     305:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     308:	8b 45 08             	mov    0x8(%ebp),%eax
     30b:	0f b6 00             	movzbl (%eax),%eax
     30e:	3c 2f                	cmp    $0x2f,%al
     310:	7e 0a                	jle    31c <atoi+0x48>
     312:	8b 45 08             	mov    0x8(%ebp),%eax
     315:	0f b6 00             	movzbl (%eax),%eax
     318:	3c 39                	cmp    $0x39,%al
     31a:	7e c7                	jle    2e3 <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     31c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     31f:	c9                   	leave  
     320:	c3                   	ret    

00000321 <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     321:	55                   	push   %ebp
     322:	89 e5                	mov    %esp,%ebp
     324:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     327:	8b 45 08             	mov    0x8(%ebp),%eax
     32a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     32d:	8b 45 0c             	mov    0xc(%ebp),%eax
     330:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     333:	eb 17                	jmp    34c <memmove+0x2b>
    *dst++ = *src++;
     335:	8b 45 fc             	mov    -0x4(%ebp),%eax
     338:	8d 50 01             	lea    0x1(%eax),%edx
     33b:	89 55 fc             	mov    %edx,-0x4(%ebp)
     33e:	8b 55 f8             	mov    -0x8(%ebp),%edx
     341:	8d 4a 01             	lea    0x1(%edx),%ecx
     344:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     347:	0f b6 12             	movzbl (%edx),%edx
     34a:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     34c:	8b 45 10             	mov    0x10(%ebp),%eax
     34f:	8d 50 ff             	lea    -0x1(%eax),%edx
     352:	89 55 10             	mov    %edx,0x10(%ebp)
     355:	85 c0                	test   %eax,%eax
     357:	7f dc                	jg     335 <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     359:	8b 45 08             	mov    0x8(%ebp),%eax
}
     35c:	c9                   	leave  
     35d:	c3                   	ret    

0000035e <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     35e:	b8 01 00 00 00       	mov    $0x1,%eax
     363:	cd 40                	int    $0x40
     365:	c3                   	ret    

00000366 <exit>:
SYSCALL(exit)
     366:	b8 02 00 00 00       	mov    $0x2,%eax
     36b:	cd 40                	int    $0x40
     36d:	c3                   	ret    

0000036e <wait>:
SYSCALL(wait)
     36e:	b8 03 00 00 00       	mov    $0x3,%eax
     373:	cd 40                	int    $0x40
     375:	c3                   	ret    

00000376 <pipe>:
SYSCALL(pipe)
     376:	b8 04 00 00 00       	mov    $0x4,%eax
     37b:	cd 40                	int    $0x40
     37d:	c3                   	ret    

0000037e <read>:
SYSCALL(read)
     37e:	b8 05 00 00 00       	mov    $0x5,%eax
     383:	cd 40                	int    $0x40
     385:	c3                   	ret    

00000386 <write>:
SYSCALL(write)
     386:	b8 10 00 00 00       	mov    $0x10,%eax
     38b:	cd 40                	int    $0x40
     38d:	c3                   	ret    

0000038e <close>:
SYSCALL(close)
     38e:	b8 15 00 00 00       	mov    $0x15,%eax
     393:	cd 40                	int    $0x40
     395:	c3                   	ret    

00000396 <kill>:
SYSCALL(kill)
     396:	b8 06 00 00 00       	mov    $0x6,%eax
     39b:	cd 40                	int    $0x40
     39d:	c3                   	ret    

0000039e <exec>:
SYSCALL(exec)
     39e:	b8 07 00 00 00       	mov    $0x7,%eax
     3a3:	cd 40                	int    $0x40
     3a5:	c3                   	ret    

000003a6 <open>:
SYSCALL(open)
     3a6:	b8 0f 00 00 00       	mov    $0xf,%eax
     3ab:	cd 40                	int    $0x40
     3ad:	c3                   	ret    

000003ae <mknod>:
SYSCALL(mknod)
     3ae:	b8 11 00 00 00       	mov    $0x11,%eax
     3b3:	cd 40                	int    $0x40
     3b5:	c3                   	ret    

000003b6 <unlink>:
SYSCALL(unlink)
     3b6:	b8 12 00 00 00       	mov    $0x12,%eax
     3bb:	cd 40                	int    $0x40
     3bd:	c3                   	ret    

000003be <fstat>:
SYSCALL(fstat)
     3be:	b8 08 00 00 00       	mov    $0x8,%eax
     3c3:	cd 40                	int    $0x40
     3c5:	c3                   	ret    

000003c6 <link>:
SYSCALL(link)
     3c6:	b8 13 00 00 00       	mov    $0x13,%eax
     3cb:	cd 40                	int    $0x40
     3cd:	c3                   	ret    

000003ce <mkdir>:
SYSCALL(mkdir)
     3ce:	b8 14 00 00 00       	mov    $0x14,%eax
     3d3:	cd 40                	int    $0x40
     3d5:	c3                   	ret    

000003d6 <chdir>:
SYSCALL(chdir)
     3d6:	b8 09 00 00 00       	mov    $0x9,%eax
     3db:	cd 40                	int    $0x40
     3dd:	c3                   	ret    

000003de <dup>:
SYSCALL(dup)
     3de:	b8 0a 00 00 00       	mov    $0xa,%eax
     3e3:	cd 40                	int    $0x40
     3e5:	c3                   	ret    

000003e6 <getpid>:
SYSCALL(getpid)
     3e6:	b8 0b 00 00 00       	mov    $0xb,%eax
     3eb:	cd 40                	int    $0x40
     3ed:	c3                   	ret    

000003ee <sbrk>:
SYSCALL(sbrk)
     3ee:	b8 0c 00 00 00       	mov    $0xc,%eax
     3f3:	cd 40                	int    $0x40
     3f5:	c3                   	ret    

000003f6 <sleep>:
SYSCALL(sleep)
     3f6:	b8 0d 00 00 00       	mov    $0xd,%eax
     3fb:	cd 40                	int    $0x40
     3fd:	c3                   	ret    

000003fe <uptime>:
SYSCALL(uptime)
     3fe:	b8 0e 00 00 00       	mov    $0xe,%eax
     403:	cd 40                	int    $0x40
     405:	c3                   	ret    

00000406 <createwindow>:
SYSCALL(createwindow)
     406:	b8 16 00 00 00       	mov    $0x16,%eax
     40b:	cd 40                	int    $0x40
     40d:	c3                   	ret    

0000040e <repaintwindow>:
SYSCALL(repaintwindow)
     40e:	b8 17 00 00 00       	mov    $0x17,%eax
     413:	cd 40                	int    $0x40
     415:	c3                   	ret    

00000416 <getmessage>:
SYSCALL(getmessage)
     416:	b8 18 00 00 00       	mov    $0x18,%eax
     41b:	cd 40                	int    $0x40
     41d:	c3                   	ret    

0000041e <settimer>:
SYSCALL(settimer)
     41e:	b8 19 00 00 00       	mov    $0x19,%eax
     423:	cd 40                	int    $0x40
     425:	c3                   	ret    

00000426 <updatewindow>:
SYSCALL(updatewindow)
     426:	b8 1a 00 00 00       	mov    $0x1a,%eax
     42b:	cd 40                	int    $0x40
     42d:	c3                   	ret    

0000042e <destroywindow>:
SYSCALL(destroywindow)
     42e:	b8 1b 00 00 00       	mov    $0x1b,%eax
     433:	cd 40                	int    $0x40
     435:	c3                   	ret    

00000436 <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     436:	55                   	push   %ebp
     437:	89 e5                	mov    %esp,%ebp
     439:	83 ec 18             	sub    $0x18,%esp
     43c:	8b 45 0c             	mov    0xc(%ebp),%eax
     43f:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     442:	83 ec 04             	sub    $0x4,%esp
     445:	6a 01                	push   $0x1
     447:	8d 45 f4             	lea    -0xc(%ebp),%eax
     44a:	50                   	push   %eax
     44b:	ff 75 08             	pushl  0x8(%ebp)
     44e:	e8 33 ff ff ff       	call   386 <write>
     453:	83 c4 10             	add    $0x10,%esp
}
     456:	90                   	nop
     457:	c9                   	leave  
     458:	c3                   	ret    

00000459 <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     459:	55                   	push   %ebp
     45a:	89 e5                	mov    %esp,%ebp
     45c:	53                   	push   %ebx
     45d:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     460:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     467:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     46b:	74 17                	je     484 <printint+0x2b>
     46d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     471:	79 11                	jns    484 <printint+0x2b>
    neg = 1;
     473:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     47a:	8b 45 0c             	mov    0xc(%ebp),%eax
     47d:	f7 d8                	neg    %eax
     47f:	89 45 ec             	mov    %eax,-0x14(%ebp)
     482:	eb 06                	jmp    48a <printint+0x31>
  } else {
    x = xx;
     484:	8b 45 0c             	mov    0xc(%ebp),%eax
     487:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     48a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     491:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     494:	8d 41 01             	lea    0x1(%ecx),%eax
     497:	89 45 f4             	mov    %eax,-0xc(%ebp)
     49a:	8b 5d 10             	mov    0x10(%ebp),%ebx
     49d:	8b 45 ec             	mov    -0x14(%ebp),%eax
     4a0:	ba 00 00 00 00       	mov    $0x0,%edx
     4a5:	f7 f3                	div    %ebx
     4a7:	89 d0                	mov    %edx,%eax
     4a9:	0f b6 80 a0 e1 01 00 	movzbl 0x1e1a0(%eax),%eax
     4b0:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     4b4:	8b 5d 10             	mov    0x10(%ebp),%ebx
     4b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
     4ba:	ba 00 00 00 00       	mov    $0x0,%edx
     4bf:	f7 f3                	div    %ebx
     4c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
     4c4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     4c8:	75 c7                	jne    491 <printint+0x38>
  if(neg)
     4ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     4ce:	74 2d                	je     4fd <printint+0xa4>
    buf[i++] = '-';
     4d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
     4d3:	8d 50 01             	lea    0x1(%eax),%edx
     4d6:	89 55 f4             	mov    %edx,-0xc(%ebp)
     4d9:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     4de:	eb 1d                	jmp    4fd <printint+0xa4>
    putc(fd, buf[i]);
     4e0:	8d 55 dc             	lea    -0x24(%ebp),%edx
     4e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
     4e6:	01 d0                	add    %edx,%eax
     4e8:	0f b6 00             	movzbl (%eax),%eax
     4eb:	0f be c0             	movsbl %al,%eax
     4ee:	83 ec 08             	sub    $0x8,%esp
     4f1:	50                   	push   %eax
     4f2:	ff 75 08             	pushl  0x8(%ebp)
     4f5:	e8 3c ff ff ff       	call   436 <putc>
     4fa:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     4fd:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     501:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     505:	79 d9                	jns    4e0 <printint+0x87>
    putc(fd, buf[i]);
}
     507:	90                   	nop
     508:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     50b:	c9                   	leave  
     50c:	c3                   	ret    

0000050d <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     50d:	55                   	push   %ebp
     50e:	89 e5                	mov    %esp,%ebp
     510:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     513:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     51a:	8d 45 0c             	lea    0xc(%ebp),%eax
     51d:	83 c0 04             	add    $0x4,%eax
     520:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     523:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     52a:	e9 59 01 00 00       	jmp    688 <printf+0x17b>
    c = fmt[i] & 0xff;
     52f:	8b 55 0c             	mov    0xc(%ebp),%edx
     532:	8b 45 f0             	mov    -0x10(%ebp),%eax
     535:	01 d0                	add    %edx,%eax
     537:	0f b6 00             	movzbl (%eax),%eax
     53a:	0f be c0             	movsbl %al,%eax
     53d:	25 ff 00 00 00       	and    $0xff,%eax
     542:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     545:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     549:	75 2c                	jne    577 <printf+0x6a>
      if(c == '%'){
     54b:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     54f:	75 0c                	jne    55d <printf+0x50>
        state = '%';
     551:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     558:	e9 27 01 00 00       	jmp    684 <printf+0x177>
      } else {
        putc(fd, c);
     55d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     560:	0f be c0             	movsbl %al,%eax
     563:	83 ec 08             	sub    $0x8,%esp
     566:	50                   	push   %eax
     567:	ff 75 08             	pushl  0x8(%ebp)
     56a:	e8 c7 fe ff ff       	call   436 <putc>
     56f:	83 c4 10             	add    $0x10,%esp
     572:	e9 0d 01 00 00       	jmp    684 <printf+0x177>
      }
    } else if(state == '%'){
     577:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     57b:	0f 85 03 01 00 00    	jne    684 <printf+0x177>
      if(c == 'd'){
     581:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     585:	75 1e                	jne    5a5 <printf+0x98>
        printint(fd, *ap, 10, 1);
     587:	8b 45 e8             	mov    -0x18(%ebp),%eax
     58a:	8b 00                	mov    (%eax),%eax
     58c:	6a 01                	push   $0x1
     58e:	6a 0a                	push   $0xa
     590:	50                   	push   %eax
     591:	ff 75 08             	pushl  0x8(%ebp)
     594:	e8 c0 fe ff ff       	call   459 <printint>
     599:	83 c4 10             	add    $0x10,%esp
        ap++;
     59c:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     5a0:	e9 d8 00 00 00       	jmp    67d <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     5a5:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     5a9:	74 06                	je     5b1 <printf+0xa4>
     5ab:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     5af:	75 1e                	jne    5cf <printf+0xc2>
        printint(fd, *ap, 16, 0);
     5b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
     5b4:	8b 00                	mov    (%eax),%eax
     5b6:	6a 00                	push   $0x0
     5b8:	6a 10                	push   $0x10
     5ba:	50                   	push   %eax
     5bb:	ff 75 08             	pushl  0x8(%ebp)
     5be:	e8 96 fe ff ff       	call   459 <printint>
     5c3:	83 c4 10             	add    $0x10,%esp
        ap++;
     5c6:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     5ca:	e9 ae 00 00 00       	jmp    67d <printf+0x170>
      } else if(c == 's'){
     5cf:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     5d3:	75 43                	jne    618 <printf+0x10b>
        s = (char*)*ap;
     5d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
     5d8:	8b 00                	mov    (%eax),%eax
     5da:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     5dd:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     5e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     5e5:	75 25                	jne    60c <printf+0xff>
          s = "(null)";
     5e7:	c7 45 f4 86 5e 01 00 	movl   $0x15e86,-0xc(%ebp)
        while(*s != 0){
     5ee:	eb 1c                	jmp    60c <printf+0xff>
          putc(fd, *s);
     5f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
     5f3:	0f b6 00             	movzbl (%eax),%eax
     5f6:	0f be c0             	movsbl %al,%eax
     5f9:	83 ec 08             	sub    $0x8,%esp
     5fc:	50                   	push   %eax
     5fd:	ff 75 08             	pushl  0x8(%ebp)
     600:	e8 31 fe ff ff       	call   436 <putc>
     605:	83 c4 10             	add    $0x10,%esp
          s++;
     608:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     60c:	8b 45 f4             	mov    -0xc(%ebp),%eax
     60f:	0f b6 00             	movzbl (%eax),%eax
     612:	84 c0                	test   %al,%al
     614:	75 da                	jne    5f0 <printf+0xe3>
     616:	eb 65                	jmp    67d <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     618:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     61c:	75 1d                	jne    63b <printf+0x12e>
        putc(fd, *ap);
     61e:	8b 45 e8             	mov    -0x18(%ebp),%eax
     621:	8b 00                	mov    (%eax),%eax
     623:	0f be c0             	movsbl %al,%eax
     626:	83 ec 08             	sub    $0x8,%esp
     629:	50                   	push   %eax
     62a:	ff 75 08             	pushl  0x8(%ebp)
     62d:	e8 04 fe ff ff       	call   436 <putc>
     632:	83 c4 10             	add    $0x10,%esp
        ap++;
     635:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     639:	eb 42                	jmp    67d <printf+0x170>
      } else if(c == '%'){
     63b:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     63f:	75 17                	jne    658 <printf+0x14b>
        putc(fd, c);
     641:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     644:	0f be c0             	movsbl %al,%eax
     647:	83 ec 08             	sub    $0x8,%esp
     64a:	50                   	push   %eax
     64b:	ff 75 08             	pushl  0x8(%ebp)
     64e:	e8 e3 fd ff ff       	call   436 <putc>
     653:	83 c4 10             	add    $0x10,%esp
     656:	eb 25                	jmp    67d <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     658:	83 ec 08             	sub    $0x8,%esp
     65b:	6a 25                	push   $0x25
     65d:	ff 75 08             	pushl  0x8(%ebp)
     660:	e8 d1 fd ff ff       	call   436 <putc>
     665:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     668:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     66b:	0f be c0             	movsbl %al,%eax
     66e:	83 ec 08             	sub    $0x8,%esp
     671:	50                   	push   %eax
     672:	ff 75 08             	pushl  0x8(%ebp)
     675:	e8 bc fd ff ff       	call   436 <putc>
     67a:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     67d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     684:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     688:	8b 55 0c             	mov    0xc(%ebp),%edx
     68b:	8b 45 f0             	mov    -0x10(%ebp),%eax
     68e:	01 d0                	add    %edx,%eax
     690:	0f b6 00             	movzbl (%eax),%eax
     693:	84 c0                	test   %al,%al
     695:	0f 85 94 fe ff ff    	jne    52f <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     69b:	90                   	nop
     69c:	c9                   	leave  
     69d:	c3                   	ret    

0000069e <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     69e:	55                   	push   %ebp
     69f:	89 e5                	mov    %esp,%ebp
     6a1:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     6a4:	8b 45 08             	mov    0x8(%ebp),%eax
     6a7:	83 e8 08             	sub    $0x8,%eax
     6aa:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     6ad:	a1 e8 e5 01 00       	mov    0x1e5e8,%eax
     6b2:	89 45 fc             	mov    %eax,-0x4(%ebp)
     6b5:	eb 24                	jmp    6db <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     6b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6ba:	8b 00                	mov    (%eax),%eax
     6bc:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     6bf:	77 12                	ja     6d3 <free+0x35>
     6c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6c4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     6c7:	77 24                	ja     6ed <free+0x4f>
     6c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6cc:	8b 00                	mov    (%eax),%eax
     6ce:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     6d1:	77 1a                	ja     6ed <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     6d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6d6:	8b 00                	mov    (%eax),%eax
     6d8:	89 45 fc             	mov    %eax,-0x4(%ebp)
     6db:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6de:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     6e1:	76 d4                	jbe    6b7 <free+0x19>
     6e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6e6:	8b 00                	mov    (%eax),%eax
     6e8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     6eb:	76 ca                	jbe    6b7 <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     6ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6f0:	8b 40 04             	mov    0x4(%eax),%eax
     6f3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     6fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6fd:	01 c2                	add    %eax,%edx
     6ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
     702:	8b 00                	mov    (%eax),%eax
     704:	39 c2                	cmp    %eax,%edx
     706:	75 24                	jne    72c <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     708:	8b 45 f8             	mov    -0x8(%ebp),%eax
     70b:	8b 50 04             	mov    0x4(%eax),%edx
     70e:	8b 45 fc             	mov    -0x4(%ebp),%eax
     711:	8b 00                	mov    (%eax),%eax
     713:	8b 40 04             	mov    0x4(%eax),%eax
     716:	01 c2                	add    %eax,%edx
     718:	8b 45 f8             	mov    -0x8(%ebp),%eax
     71b:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     71e:	8b 45 fc             	mov    -0x4(%ebp),%eax
     721:	8b 00                	mov    (%eax),%eax
     723:	8b 10                	mov    (%eax),%edx
     725:	8b 45 f8             	mov    -0x8(%ebp),%eax
     728:	89 10                	mov    %edx,(%eax)
     72a:	eb 0a                	jmp    736 <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     72c:	8b 45 fc             	mov    -0x4(%ebp),%eax
     72f:	8b 10                	mov    (%eax),%edx
     731:	8b 45 f8             	mov    -0x8(%ebp),%eax
     734:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     736:	8b 45 fc             	mov    -0x4(%ebp),%eax
     739:	8b 40 04             	mov    0x4(%eax),%eax
     73c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     743:	8b 45 fc             	mov    -0x4(%ebp),%eax
     746:	01 d0                	add    %edx,%eax
     748:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     74b:	75 20                	jne    76d <free+0xcf>
    p->s.size += bp->s.size;
     74d:	8b 45 fc             	mov    -0x4(%ebp),%eax
     750:	8b 50 04             	mov    0x4(%eax),%edx
     753:	8b 45 f8             	mov    -0x8(%ebp),%eax
     756:	8b 40 04             	mov    0x4(%eax),%eax
     759:	01 c2                	add    %eax,%edx
     75b:	8b 45 fc             	mov    -0x4(%ebp),%eax
     75e:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     761:	8b 45 f8             	mov    -0x8(%ebp),%eax
     764:	8b 10                	mov    (%eax),%edx
     766:	8b 45 fc             	mov    -0x4(%ebp),%eax
     769:	89 10                	mov    %edx,(%eax)
     76b:	eb 08                	jmp    775 <free+0xd7>
  } else
    p->s.ptr = bp;
     76d:	8b 45 fc             	mov    -0x4(%ebp),%eax
     770:	8b 55 f8             	mov    -0x8(%ebp),%edx
     773:	89 10                	mov    %edx,(%eax)
  freep = p;
     775:	8b 45 fc             	mov    -0x4(%ebp),%eax
     778:	a3 e8 e5 01 00       	mov    %eax,0x1e5e8
}
     77d:	90                   	nop
     77e:	c9                   	leave  
     77f:	c3                   	ret    

00000780 <morecore>:

static Header*
morecore(uint nu)
{
     780:	55                   	push   %ebp
     781:	89 e5                	mov    %esp,%ebp
     783:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     786:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     78d:	77 07                	ja     796 <morecore+0x16>
    nu = 4096;
     78f:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     796:	8b 45 08             	mov    0x8(%ebp),%eax
     799:	c1 e0 03             	shl    $0x3,%eax
     79c:	83 ec 0c             	sub    $0xc,%esp
     79f:	50                   	push   %eax
     7a0:	e8 49 fc ff ff       	call   3ee <sbrk>
     7a5:	83 c4 10             	add    $0x10,%esp
     7a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     7ab:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     7af:	75 07                	jne    7b8 <morecore+0x38>
    return 0;
     7b1:	b8 00 00 00 00       	mov    $0x0,%eax
     7b6:	eb 26                	jmp    7de <morecore+0x5e>
  hp = (Header*)p;
     7b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     7be:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7c1:	8b 55 08             	mov    0x8(%ebp),%edx
     7c4:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     7c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7ca:	83 c0 08             	add    $0x8,%eax
     7cd:	83 ec 0c             	sub    $0xc,%esp
     7d0:	50                   	push   %eax
     7d1:	e8 c8 fe ff ff       	call   69e <free>
     7d6:	83 c4 10             	add    $0x10,%esp
  return freep;
     7d9:	a1 e8 e5 01 00       	mov    0x1e5e8,%eax
}
     7de:	c9                   	leave  
     7df:	c3                   	ret    

000007e0 <malloc>:

void*
malloc(uint nbytes)
{
     7e0:	55                   	push   %ebp
     7e1:	89 e5                	mov    %esp,%ebp
     7e3:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     7e6:	8b 45 08             	mov    0x8(%ebp),%eax
     7e9:	83 c0 07             	add    $0x7,%eax
     7ec:	c1 e8 03             	shr    $0x3,%eax
     7ef:	83 c0 01             	add    $0x1,%eax
     7f2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     7f5:	a1 e8 e5 01 00       	mov    0x1e5e8,%eax
     7fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
     7fd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     801:	75 23                	jne    826 <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     803:	c7 45 f0 e0 e5 01 00 	movl   $0x1e5e0,-0x10(%ebp)
     80a:	8b 45 f0             	mov    -0x10(%ebp),%eax
     80d:	a3 e8 e5 01 00       	mov    %eax,0x1e5e8
     812:	a1 e8 e5 01 00       	mov    0x1e5e8,%eax
     817:	a3 e0 e5 01 00       	mov    %eax,0x1e5e0
    base.s.size = 0;
     81c:	c7 05 e4 e5 01 00 00 	movl   $0x0,0x1e5e4
     823:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     826:	8b 45 f0             	mov    -0x10(%ebp),%eax
     829:	8b 00                	mov    (%eax),%eax
     82b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     82e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     831:	8b 40 04             	mov    0x4(%eax),%eax
     834:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     837:	72 4d                	jb     886 <malloc+0xa6>
      if(p->s.size == nunits)
     839:	8b 45 f4             	mov    -0xc(%ebp),%eax
     83c:	8b 40 04             	mov    0x4(%eax),%eax
     83f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     842:	75 0c                	jne    850 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     844:	8b 45 f4             	mov    -0xc(%ebp),%eax
     847:	8b 10                	mov    (%eax),%edx
     849:	8b 45 f0             	mov    -0x10(%ebp),%eax
     84c:	89 10                	mov    %edx,(%eax)
     84e:	eb 26                	jmp    876 <malloc+0x96>
      else {
        p->s.size -= nunits;
     850:	8b 45 f4             	mov    -0xc(%ebp),%eax
     853:	8b 40 04             	mov    0x4(%eax),%eax
     856:	2b 45 ec             	sub    -0x14(%ebp),%eax
     859:	89 c2                	mov    %eax,%edx
     85b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     85e:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     861:	8b 45 f4             	mov    -0xc(%ebp),%eax
     864:	8b 40 04             	mov    0x4(%eax),%eax
     867:	c1 e0 03             	shl    $0x3,%eax
     86a:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     86d:	8b 45 f4             	mov    -0xc(%ebp),%eax
     870:	8b 55 ec             	mov    -0x14(%ebp),%edx
     873:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     876:	8b 45 f0             	mov    -0x10(%ebp),%eax
     879:	a3 e8 e5 01 00       	mov    %eax,0x1e5e8
      return (void*)(p + 1);
     87e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     881:	83 c0 08             	add    $0x8,%eax
     884:	eb 3b                	jmp    8c1 <malloc+0xe1>
    }
    if(p == freep)
     886:	a1 e8 e5 01 00       	mov    0x1e5e8,%eax
     88b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     88e:	75 1e                	jne    8ae <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     890:	83 ec 0c             	sub    $0xc,%esp
     893:	ff 75 ec             	pushl  -0x14(%ebp)
     896:	e8 e5 fe ff ff       	call   780 <morecore>
     89b:	83 c4 10             	add    $0x10,%esp
     89e:	89 45 f4             	mov    %eax,-0xc(%ebp)
     8a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     8a5:	75 07                	jne    8ae <malloc+0xce>
        return 0;
     8a7:	b8 00 00 00 00       	mov    $0x0,%eax
     8ac:	eb 13                	jmp    8c1 <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     8ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
     8b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8b7:	8b 00                	mov    (%eax),%eax
     8b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     8bc:	e9 6d ff ff ff       	jmp    82e <malloc+0x4e>
}
     8c1:	c9                   	leave  
     8c2:	c3                   	ret    

000008c3 <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     8c3:	55                   	push   %ebp
     8c4:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     8c6:	a1 ec e5 01 00       	mov    0x1e5ec,%eax
     8cb:	83 c0 01             	add    $0x1,%eax
     8ce:	a3 ec e5 01 00       	mov    %eax,0x1e5ec
    g_seed = (214013*g_seed+2531011);
     8d3:	a1 ec e5 01 00       	mov    0x1e5ec,%eax
     8d8:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     8de:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     8e3:	a3 ec e5 01 00       	mov    %eax,0x1e5ec
    return (g_seed>>16)&0x7FFF;
     8e8:	a1 ec e5 01 00       	mov    0x1e5ec,%eax
     8ed:	c1 e8 10             	shr    $0x10,%eax
     8f0:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     8f5:	5d                   	pop    %ebp
     8f6:	c3                   	ret    

000008f7 <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     8f7:	55                   	push   %ebp
     8f8:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     8fa:	d9 45 08             	flds   0x8(%ebp)
     8fd:	d9 ee                	fldz   
     8ff:	d9 c9                	fxch   %st(1)
     901:	df e9                	fucomip %st(1),%st
     903:	dd d8                	fstp   %st(0)
     905:	76 05                	jbe    90c <abs+0x15>
     907:	d9 45 08             	flds   0x8(%ebp)
     90a:	eb 05                	jmp    911 <abs+0x1a>
	return -x;
     90c:	d9 45 08             	flds   0x8(%ebp)
     90f:	d9 e0                	fchs   
}
     911:	5d                   	pop    %ebp
     912:	c3                   	ret    

00000913 <pow>:

float pow(float a, int b)
{
     913:	55                   	push   %ebp
     914:	89 e5                	mov    %esp,%ebp
     916:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     919:	d9 45 08             	flds   0x8(%ebp)
     91c:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     91f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     923:	7e 17                	jle    93c <pow+0x29>
		while (--b)
     925:	eb 09                	jmp    930 <pow+0x1d>
			r *= a;
     927:	d9 45 fc             	flds   -0x4(%ebp)
     92a:	d8 4d 08             	fmuls  0x8(%ebp)
     92d:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     930:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     934:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     938:	75 ed                	jne    927 <pow+0x14>
     93a:	eb 2a                	jmp    966 <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     93c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     940:	79 1f                	jns    961 <pow+0x4e>
		while (++b)
     942:	eb 09                	jmp    94d <pow+0x3a>
			r *= a;
     944:	d9 45 fc             	flds   -0x4(%ebp)
     947:	d8 4d 08             	fmuls  0x8(%ebp)
     94a:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     94d:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     951:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     955:	75 ed                	jne    944 <pow+0x31>
			r *= a;
		r = 1.0 / r;
     957:	d9 e8                	fld1   
     959:	d8 75 fc             	fdivs  -0x4(%ebp)
     95c:	d9 5d fc             	fstps  -0x4(%ebp)
     95f:	eb 05                	jmp    966 <pow+0x53>
	}
	else r = 0;
     961:	d9 ee                	fldz   
     963:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     966:	d9 45 fc             	flds   -0x4(%ebp)
}
     969:	c9                   	leave  
     96a:	c3                   	ret    

0000096b <sqrt>:

float sqrt(float number) {
     96b:	55                   	push   %ebp
     96c:	89 e5                	mov    %esp,%ebp
     96e:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     971:	d9 ee                	fldz   
     973:	d9 45 08             	flds   0x8(%ebp)
     976:	d9 c9                	fxch   %st(1)
     978:	df e9                	fucomip %st(1),%st
     97a:	dd d8                	fstp   %st(0)
     97c:	76 06                	jbe    984 <sqrt+0x19>
		return -1;
     97e:	d9 e8                	fld1   
     980:	d9 e0                	fchs   
     982:	eb 3a                	jmp    9be <sqrt+0x53>
	}

	new_guess = 1;
     984:	d9 e8                	fld1   
     986:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
     989:	d9 45 fc             	flds   -0x4(%ebp)
     98c:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
     98f:	d9 45 08             	flds   0x8(%ebp)
     992:	d8 75 f8             	fdivs  -0x8(%ebp)
     995:	d8 45 f8             	fadds  -0x8(%ebp)
     998:	d9 05 90 5e 01 00    	flds   0x15e90
     99e:	de f9                	fdivrp %st,%st(1)
     9a0:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
     9a3:	d9 45 fc             	flds   -0x4(%ebp)
     9a6:	d9 45 f8             	flds   -0x8(%ebp)
     9a9:	df e9                	fucomip %st(1),%st
     9ab:	dd d8                	fstp   %st(0)
     9ad:	7a da                	jp     989 <sqrt+0x1e>
     9af:	d9 45 fc             	flds   -0x4(%ebp)
     9b2:	d9 45 f8             	flds   -0x8(%ebp)
     9b5:	df e9                	fucomip %st(1),%st
     9b7:	dd d8                	fstp   %st(0)
     9b9:	75 ce                	jne    989 <sqrt+0x1e>

	return new_guess;
     9bb:	d9 45 fc             	flds   -0x4(%ebp)
}
     9be:	c9                   	leave  
     9bf:	c3                   	ret    

000009c0 <cos>:

float cos(float x)
{
     9c0:	55                   	push   %ebp
     9c1:	89 e5                	mov    %esp,%ebp
     9c3:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     9c6:	d9 e8                	fld1   
     9c8:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     9cb:	d9 45 08             	flds   0x8(%ebp)
     9ce:	dd 05 98 5e 01 00    	fldl   0x15e98
     9d4:	d9 c9                	fxch   %st(1)
     9d6:	df e9                	fucomip %st(1),%st
     9d8:	dd d8                	fstp   %st(0)
     9da:	77 0f                	ja     9eb <cos+0x2b>
     9dc:	d9 45 08             	flds   0x8(%ebp)
     9df:	dd 05 a0 5e 01 00    	fldl   0x15ea0
     9e5:	df e9                	fucomip %st(1),%st
     9e7:	dd d8                	fstp   %st(0)
     9e9:	76 3c                	jbe    a27 <cos+0x67>
     9eb:	d9 45 08             	flds   0x8(%ebp)
     9ee:	d9 45 08             	flds   0x8(%ebp)
     9f1:	dd 05 98 5e 01 00    	fldl   0x15e98
     9f7:	de f9                	fdivrp %st,%st(1)
     9f9:	d9 7d e2             	fnstcw -0x1e(%ebp)
     9fc:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     a00:	b4 0c                	mov    $0xc,%ah
     a02:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     a06:	d9 6d e0             	fldcw  -0x20(%ebp)
     a09:	db 5d dc             	fistpl -0x24(%ebp)
     a0c:	d9 6d e2             	fldcw  -0x1e(%ebp)
     a0f:	8b 45 dc             	mov    -0x24(%ebp),%eax
     a12:	01 c0                	add    %eax,%eax
     a14:	89 45 d8             	mov    %eax,-0x28(%ebp)
     a17:	db 45 d8             	fildl  -0x28(%ebp)
     a1a:	dd 05 a8 5e 01 00    	fldl   0x15ea8
     a20:	de c9                	fmulp  %st,%st(1)
     a22:	de e9                	fsubrp %st,%st(1)
     a24:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     a27:	d9 45 08             	flds   0x8(%ebp)
     a2a:	dd 05 a8 5e 01 00    	fldl   0x15ea8
     a30:	d9 c9                	fxch   %st(1)
     a32:	df e9                	fucomip %st(1),%st
     a34:	dd d8                	fstp   %st(0)
     a36:	76 0e                	jbe    a46 <cos+0x86>
     a38:	d9 45 08             	flds   0x8(%ebp)
     a3b:	dd 05 98 5e 01 00    	fldl   0x15e98
     a41:	de e9                	fsubrp %st,%st(1)
     a43:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     a46:	d9 45 08             	flds   0x8(%ebp)
     a49:	dd 05 b0 5e 01 00    	fldl   0x15eb0
     a4f:	df e9                	fucomip %st(1),%st
     a51:	dd d8                	fstp   %st(0)
     a53:	76 0e                	jbe    a63 <cos+0xa3>
     a55:	d9 45 08             	flds   0x8(%ebp)
     a58:	dd 05 98 5e 01 00    	fldl   0x15e98
     a5e:	de c1                	faddp  %st,%st(1)
     a60:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     a63:	d9 45 08             	flds   0x8(%ebp)
     a66:	dd 05 b8 5e 01 00    	fldl   0x15eb8
     a6c:	d9 c9                	fxch   %st(1)
     a6e:	df e9                	fucomip %st(1),%st
     a70:	dd d8                	fstp   %st(0)
     a72:	76 16                	jbe    a8a <cos+0xca>
    {
        x -= PI;
     a74:	d9 45 08             	flds   0x8(%ebp)
     a77:	dd 05 a8 5e 01 00    	fldl   0x15ea8
     a7d:	de e9                	fsubrp %st,%st(1)
     a7f:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     a82:	d9 45 f4             	flds   -0xc(%ebp)
     a85:	d9 e0                	fchs   
     a87:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     a8a:	d9 45 08             	flds   0x8(%ebp)
     a8d:	dd 05 c0 5e 01 00    	fldl   0x15ec0
     a93:	df e9                	fucomip %st(1),%st
     a95:	dd d8                	fstp   %st(0)
     a97:	76 16                	jbe    aaf <cos+0xef>
    {
        x += PI;
     a99:	d9 45 08             	flds   0x8(%ebp)
     a9c:	dd 05 a8 5e 01 00    	fldl   0x15ea8
     aa2:	de c1                	faddp  %st,%st(1)
     aa4:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     aa7:	d9 45 f4             	flds   -0xc(%ebp)
     aaa:	d9 e0                	fchs   
     aac:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
     aaf:	d9 45 08             	flds   0x8(%ebp)
     ab2:	dd 05 c8 5e 01 00    	fldl   0x15ec8
     ab8:	d9 c9                	fxch   %st(1)
     aba:	df e9                	fucomip %st(1),%st
     abc:	dd d8                	fstp   %st(0)
     abe:	76 28                	jbe    ae8 <cos+0x128>
     ac0:	d9 45 08             	flds   0x8(%ebp)
     ac3:	dd 05 b8 5e 01 00    	fldl   0x15eb8
     ac9:	de e1                	fsubp  %st,%st(1)
     acb:	d9 5d e4             	fstps  -0x1c(%ebp)
     ace:	d9 45 e4             	flds   -0x1c(%ebp)
     ad1:	83 ec 0c             	sub    $0xc,%esp
     ad4:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     ad8:	d9 1c 24             	fstps  (%esp)
     adb:	e8 83 00 00 00       	call   b63 <sin>
     ae0:	83 c4 10             	add    $0x10,%esp
     ae3:	d8 4d f4             	fmuls  -0xc(%ebp)
     ae6:	eb 79                	jmp    b61 <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
     ae8:	83 ec 08             	sub    $0x8,%esp
     aeb:	6a 02                	push   $0x2
     aed:	ff 75 08             	pushl  0x8(%ebp)
     af0:	e8 1e fe ff ff       	call   913 <pow>
     af5:	83 c4 10             	add    $0x10,%esp
     af8:	d9 05 90 5e 01 00    	flds   0x15e90
     afe:	de f9                	fdivrp %st,%st(1)
     b00:	d9 e8                	fld1   
     b02:	de e1                	fsubp  %st,%st(1)
     b04:	d9 5d d8             	fstps  -0x28(%ebp)
     b07:	83 ec 08             	sub    $0x8,%esp
     b0a:	6a 04                	push   $0x4
     b0c:	ff 75 08             	pushl  0x8(%ebp)
     b0f:	e8 ff fd ff ff       	call   913 <pow>
     b14:	83 c4 10             	add    $0x10,%esp
     b17:	d9 05 d0 5e 01 00    	flds   0x15ed0
     b1d:	de f9                	fdivrp %st,%st(1)
     b1f:	d8 45 d8             	fadds  -0x28(%ebp)
     b22:	d9 5d d8             	fstps  -0x28(%ebp)
     b25:	83 ec 08             	sub    $0x8,%esp
     b28:	6a 06                	push   $0x6
     b2a:	ff 75 08             	pushl  0x8(%ebp)
     b2d:	e8 e1 fd ff ff       	call   913 <pow>
     b32:	83 c4 10             	add    $0x10,%esp
     b35:	d9 05 d4 5e 01 00    	flds   0x15ed4
     b3b:	de f9                	fdivrp %st,%st(1)
     b3d:	d8 6d d8             	fsubrs -0x28(%ebp)
     b40:	d9 5d d8             	fstps  -0x28(%ebp)
     b43:	83 ec 08             	sub    $0x8,%esp
     b46:	6a 08                	push   $0x8
     b48:	ff 75 08             	pushl  0x8(%ebp)
     b4b:	e8 c3 fd ff ff       	call   913 <pow>
     b50:	83 c4 10             	add    $0x10,%esp
     b53:	d9 05 d8 5e 01 00    	flds   0x15ed8
     b59:	de f9                	fdivrp %st,%st(1)
     b5b:	d8 45 d8             	fadds  -0x28(%ebp)
     b5e:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     b61:	c9                   	leave  
     b62:	c3                   	ret    

00000b63 <sin>:

float sin(float x)
{
     b63:	55                   	push   %ebp
     b64:	89 e5                	mov    %esp,%ebp
     b66:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     b69:	d9 e8                	fld1   
     b6b:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     b6e:	d9 45 08             	flds   0x8(%ebp)
     b71:	dd 05 98 5e 01 00    	fldl   0x15e98
     b77:	d9 c9                	fxch   %st(1)
     b79:	df e9                	fucomip %st(1),%st
     b7b:	dd d8                	fstp   %st(0)
     b7d:	77 0f                	ja     b8e <sin+0x2b>
     b7f:	d9 45 08             	flds   0x8(%ebp)
     b82:	dd 05 a0 5e 01 00    	fldl   0x15ea0
     b88:	df e9                	fucomip %st(1),%st
     b8a:	dd d8                	fstp   %st(0)
     b8c:	76 3c                	jbe    bca <sin+0x67>
     b8e:	d9 45 08             	flds   0x8(%ebp)
     b91:	d9 45 08             	flds   0x8(%ebp)
     b94:	dd 05 98 5e 01 00    	fldl   0x15e98
     b9a:	de f9                	fdivrp %st,%st(1)
     b9c:	d9 7d e2             	fnstcw -0x1e(%ebp)
     b9f:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     ba3:	b4 0c                	mov    $0xc,%ah
     ba5:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     ba9:	d9 6d e0             	fldcw  -0x20(%ebp)
     bac:	db 5d dc             	fistpl -0x24(%ebp)
     baf:	d9 6d e2             	fldcw  -0x1e(%ebp)
     bb2:	8b 45 dc             	mov    -0x24(%ebp),%eax
     bb5:	01 c0                	add    %eax,%eax
     bb7:	89 45 d8             	mov    %eax,-0x28(%ebp)
     bba:	db 45 d8             	fildl  -0x28(%ebp)
     bbd:	dd 05 a8 5e 01 00    	fldl   0x15ea8
     bc3:	de c9                	fmulp  %st,%st(1)
     bc5:	de e9                	fsubrp %st,%st(1)
     bc7:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     bca:	d9 45 08             	flds   0x8(%ebp)
     bcd:	dd 05 a8 5e 01 00    	fldl   0x15ea8
     bd3:	d9 c9                	fxch   %st(1)
     bd5:	df e9                	fucomip %st(1),%st
     bd7:	dd d8                	fstp   %st(0)
     bd9:	76 0e                	jbe    be9 <sin+0x86>
     bdb:	d9 45 08             	flds   0x8(%ebp)
     bde:	dd 05 98 5e 01 00    	fldl   0x15e98
     be4:	de e9                	fsubrp %st,%st(1)
     be6:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     be9:	d9 45 08             	flds   0x8(%ebp)
     bec:	dd 05 b0 5e 01 00    	fldl   0x15eb0
     bf2:	df e9                	fucomip %st(1),%st
     bf4:	dd d8                	fstp   %st(0)
     bf6:	76 0e                	jbe    c06 <sin+0xa3>
     bf8:	d9 45 08             	flds   0x8(%ebp)
     bfb:	dd 05 98 5e 01 00    	fldl   0x15e98
     c01:	de c1                	faddp  %st,%st(1)
     c03:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     c06:	d9 45 08             	flds   0x8(%ebp)
     c09:	dd 05 b8 5e 01 00    	fldl   0x15eb8
     c0f:	d9 c9                	fxch   %st(1)
     c11:	df e9                	fucomip %st(1),%st
     c13:	dd d8                	fstp   %st(0)
     c15:	76 16                	jbe    c2d <sin+0xca>
    {
        x -= PI;
     c17:	d9 45 08             	flds   0x8(%ebp)
     c1a:	dd 05 a8 5e 01 00    	fldl   0x15ea8
     c20:	de e9                	fsubrp %st,%st(1)
     c22:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     c25:	d9 45 f4             	flds   -0xc(%ebp)
     c28:	d9 e0                	fchs   
     c2a:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     c2d:	d9 45 08             	flds   0x8(%ebp)
     c30:	dd 05 c0 5e 01 00    	fldl   0x15ec0
     c36:	df e9                	fucomip %st(1),%st
     c38:	dd d8                	fstp   %st(0)
     c3a:	76 16                	jbe    c52 <sin+0xef>
    {
        x += PI;
     c3c:	d9 45 08             	flds   0x8(%ebp)
     c3f:	dd 05 a8 5e 01 00    	fldl   0x15ea8
     c45:	de c1                	faddp  %st,%st(1)
     c47:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     c4a:	d9 45 f4             	flds   -0xc(%ebp)
     c4d:	d9 e0                	fchs   
     c4f:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
     c52:	d9 ee                	fldz   
     c54:	d9 45 08             	flds   0x8(%ebp)
     c57:	d9 c9                	fxch   %st(1)
     c59:	df e9                	fucomip %st(1),%st
     c5b:	dd d8                	fstp   %st(0)
     c5d:	76 10                	jbe    c6f <sin+0x10c>
    {
        x *= -1;
     c5f:	d9 45 08             	flds   0x8(%ebp)
     c62:	d9 e0                	fchs   
     c64:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     c67:	d9 45 f4             	flds   -0xc(%ebp)
     c6a:	d9 e0                	fchs   
     c6c:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
     c6f:	d9 45 08             	flds   0x8(%ebp)
     c72:	dd 05 c8 5e 01 00    	fldl   0x15ec8
     c78:	d9 c9                	fxch   %st(1)
     c7a:	df e9                	fucomip %st(1),%st
     c7c:	dd d8                	fstp   %st(0)
     c7e:	76 28                	jbe    ca8 <sin+0x145>
     c80:	d9 45 08             	flds   0x8(%ebp)
     c83:	dd 05 b8 5e 01 00    	fldl   0x15eb8
     c89:	de e1                	fsubp  %st,%st(1)
     c8b:	d9 5d e4             	fstps  -0x1c(%ebp)
     c8e:	d9 45 e4             	flds   -0x1c(%ebp)
     c91:	83 ec 0c             	sub    $0xc,%esp
     c94:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     c98:	d9 1c 24             	fstps  (%esp)
     c9b:	e8 20 fd ff ff       	call   9c0 <cos>
     ca0:	83 c4 10             	add    $0x10,%esp
     ca3:	d8 4d f4             	fmuls  -0xc(%ebp)
     ca6:	eb 7a                	jmp    d22 <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
     ca8:	83 ec 08             	sub    $0x8,%esp
     cab:	6a 03                	push   $0x3
     cad:	ff 75 08             	pushl  0x8(%ebp)
     cb0:	e8 5e fc ff ff       	call   913 <pow>
     cb5:	83 c4 10             	add    $0x10,%esp
     cb8:	d9 05 dc 5e 01 00    	flds   0x15edc
     cbe:	de f9                	fdivrp %st,%st(1)
     cc0:	d9 45 08             	flds   0x8(%ebp)
     cc3:	de e1                	fsubp  %st,%st(1)
     cc5:	d9 5d d8             	fstps  -0x28(%ebp)
     cc8:	83 ec 08             	sub    $0x8,%esp
     ccb:	6a 05                	push   $0x5
     ccd:	ff 75 08             	pushl  0x8(%ebp)
     cd0:	e8 3e fc ff ff       	call   913 <pow>
     cd5:	83 c4 10             	add    $0x10,%esp
     cd8:	d9 05 e0 5e 01 00    	flds   0x15ee0
     cde:	de f9                	fdivrp %st,%st(1)
     ce0:	d8 45 d8             	fadds  -0x28(%ebp)
     ce3:	d9 5d d8             	fstps  -0x28(%ebp)
     ce6:	83 ec 08             	sub    $0x8,%esp
     ce9:	6a 07                	push   $0x7
     ceb:	ff 75 08             	pushl  0x8(%ebp)
     cee:	e8 20 fc ff ff       	call   913 <pow>
     cf3:	83 c4 10             	add    $0x10,%esp
     cf6:	d9 05 e4 5e 01 00    	flds   0x15ee4
     cfc:	de f9                	fdivrp %st,%st(1)
     cfe:	d8 6d d8             	fsubrs -0x28(%ebp)
     d01:	d9 5d d8             	fstps  -0x28(%ebp)
     d04:	83 ec 08             	sub    $0x8,%esp
     d07:	6a 09                	push   $0x9
     d09:	ff 75 08             	pushl  0x8(%ebp)
     d0c:	e8 02 fc ff ff       	call   913 <pow>
     d11:	83 c4 10             	add    $0x10,%esp
     d14:	d9 05 e8 5e 01 00    	flds   0x15ee8
     d1a:	de f9                	fdivrp %st,%st(1)
     d1c:	d8 45 d8             	fadds  -0x28(%ebp)
     d1f:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     d22:	c9                   	leave  
     d23:	c3                   	ret    

00000d24 <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
     d24:	55                   	push   %ebp
     d25:	89 e5                	mov    %esp,%ebp
     d27:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
     d2a:	83 ec 04             	sub    $0x4,%esp
     d2d:	6a 0e                	push   $0xe
     d2f:	ff 75 0c             	pushl  0xc(%ebp)
     d32:	ff 75 08             	pushl  0x8(%ebp)
     d35:	e8 44 f6 ff ff       	call   37e <read>
     d3a:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
     d3d:	83 ec 04             	sub    $0x4,%esp
     d40:	6a 28                	push   $0x28
     d42:	ff 75 10             	pushl  0x10(%ebp)
     d45:	ff 75 08             	pushl  0x8(%ebp)
     d48:	e8 31 f6 ff ff       	call   37e <read>
     d4d:	83 c4 10             	add    $0x10,%esp
}
     d50:	90                   	nop
     d51:	c9                   	leave  
     d52:	c3                   	ret    

00000d53 <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
     d53:	55                   	push   %ebp
     d54:	89 e5                	mov    %esp,%ebp
     d56:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     d5c:	83 ec 08             	sub    $0x8,%esp
     d5f:	6a 00                	push   $0x0
     d61:	ff 75 08             	pushl  0x8(%ebp)
     d64:	e8 3d f6 ff ff       	call   3a6 <open>
     d69:	83 c4 10             	add    $0x10,%esp
     d6c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     d6f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     d73:	79 0a                	jns    d7f <readBitmapFile+0x2c>
        return -1;
     d75:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     d7a:	e9 6e 01 00 00       	jmp    eed <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     d7f:	83 ec 04             	sub    $0x4,%esp
     d82:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     d85:	50                   	push   %eax
     d86:	8d 45 ca             	lea    -0x36(%ebp),%eax
     d89:	50                   	push   %eax
     d8a:	ff 75 ec             	pushl  -0x14(%ebp)
     d8d:	e8 92 ff ff ff       	call   d24 <readBitmapHeader>
     d92:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     d95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     d98:	83 e8 36             	sub    $0x36,%eax
     d9b:	83 ec 04             	sub    $0x4,%esp
     d9e:	50                   	push   %eax
     d9f:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     da5:	50                   	push   %eax
     da6:	ff 75 ec             	pushl  -0x14(%ebp)
     da9:	e8 d0 f5 ff ff       	call   37e <read>
     dae:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     db1:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     db4:	8b 45 14             	mov    0x14(%ebp),%eax
     db7:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     db9:	8b 55 aa             	mov    -0x56(%ebp),%edx
     dbc:	8b 45 10             	mov    0x10(%ebp),%eax
     dbf:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     dc1:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     dc4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     dc7:	8b 45 aa             	mov    -0x56(%ebp),%eax
     dca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     dcd:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     dd1:	0f b7 c0             	movzwl %ax,%eax
     dd4:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
     dd7:	8b 45 e8             	mov    -0x18(%ebp),%eax
     dda:	0f af 45 e0          	imul   -0x20(%ebp),%eax
     dde:	8d 50 07             	lea    0x7(%eax),%edx
     de1:	85 c0                	test   %eax,%eax
     de3:	0f 48 c2             	cmovs  %edx,%eax
     de6:	c1 f8 03             	sar    $0x3,%eax
     de9:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     dec:	8b 45 0c             	mov    0xc(%ebp),%eax
     def:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     df2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     df5:	83 e8 01             	sub    $0x1,%eax
     df8:	89 45 f4             	mov    %eax,-0xc(%ebp)
     dfb:	e9 d0 00 00 00       	jmp    ed0 <readBitmapFile+0x17d>
        if (bits == 32) {
     e00:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
     e04:	75 22                	jne    e28 <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     e06:	8b 45 f4             	mov    -0xc(%ebp),%eax
     e09:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     e0d:	89 c2                	mov    %eax,%edx
     e0f:	8b 45 d8             	mov    -0x28(%ebp),%eax
     e12:	01 d0                	add    %edx,%eax
     e14:	83 ec 04             	sub    $0x4,%esp
     e17:	ff 75 dc             	pushl  -0x24(%ebp)
     e1a:	50                   	push   %eax
     e1b:	ff 75 ec             	pushl  -0x14(%ebp)
     e1e:	e8 5b f5 ff ff       	call   37e <read>
     e23:	83 c4 10             	add    $0x10,%esp
     e26:	eb 65                	jmp    e8d <readBitmapFile+0x13a>
        } else {
            int j = 0;
     e28:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     e2f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     e36:	eb 4d                	jmp    e85 <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
     e38:	8b 45 f4             	mov    -0xc(%ebp),%eax
     e3b:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     e3f:	c1 e0 02             	shl    $0x2,%eax
     e42:	89 c2                	mov    %eax,%edx
     e44:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e47:	c1 e0 02             	shl    $0x2,%eax
     e4a:	01 c2                	add    %eax,%edx
     e4c:	8b 45 d8             	mov    -0x28(%ebp),%eax
     e4f:	01 d0                	add    %edx,%eax
     e51:	83 ec 04             	sub    $0x4,%esp
     e54:	6a 03                	push   $0x3
     e56:	50                   	push   %eax
     e57:	ff 75 ec             	pushl  -0x14(%ebp)
     e5a:	e8 1f f5 ff ff       	call   37e <read>
     e5f:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
     e62:	8b 45 f4             	mov    -0xc(%ebp),%eax
     e65:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     e69:	c1 e0 02             	shl    $0x2,%eax
     e6c:	89 c2                	mov    %eax,%edx
     e6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e71:	c1 e0 02             	shl    $0x2,%eax
     e74:	01 d0                	add    %edx,%eax
     e76:	8d 50 03             	lea    0x3(%eax),%edx
     e79:	8b 45 d8             	mov    -0x28(%ebp),%eax
     e7c:	01 d0                	add    %edx,%eax
     e7e:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     e81:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     e85:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e88:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     e8b:	7c ab                	jl     e38 <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
     e8d:	8b 45 dc             	mov    -0x24(%ebp),%eax
     e90:	99                   	cltd   
     e91:	c1 ea 1e             	shr    $0x1e,%edx
     e94:	01 d0                	add    %edx,%eax
     e96:	83 e0 03             	and    $0x3,%eax
     e99:	29 d0                	sub    %edx,%eax
     e9b:	85 c0                	test   %eax,%eax
     e9d:	7e 2d                	jle    ecc <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     e9f:	8b 45 dc             	mov    -0x24(%ebp),%eax
     ea2:	99                   	cltd   
     ea3:	c1 ea 1e             	shr    $0x1e,%edx
     ea6:	01 d0                	add    %edx,%eax
     ea8:	83 e0 03             	and    $0x3,%eax
     eab:	29 d0                	sub    %edx,%eax
     ead:	ba 04 00 00 00       	mov    $0x4,%edx
     eb2:	29 c2                	sub    %eax,%edx
     eb4:	89 d0                	mov    %edx,%eax
     eb6:	83 ec 04             	sub    $0x4,%esp
     eb9:	50                   	push   %eax
     eba:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     ec0:	50                   	push   %eax
     ec1:	ff 75 ec             	pushl  -0x14(%ebp)
     ec4:	e8 b5 f4 ff ff       	call   37e <read>
     ec9:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     ecc:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     ed0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     ed4:	0f 89 26 ff ff ff    	jns    e00 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     eda:	83 ec 0c             	sub    $0xc,%esp
     edd:	ff 75 ec             	pushl  -0x14(%ebp)
     ee0:	e8 a9 f4 ff ff       	call   38e <close>
     ee5:	83 c4 10             	add    $0x10,%esp
    return 0;
     ee8:	b8 00 00 00 00       	mov    $0x0,%eax
}
     eed:	c9                   	leave  
     eee:	c3                   	ret    

00000eef <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
     eef:	55                   	push   %ebp
     ef0:	89 e5                	mov    %esp,%ebp
     ef2:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     ef8:	83 ec 08             	sub    $0x8,%esp
     efb:	6a 00                	push   $0x0
     efd:	ff 75 08             	pushl  0x8(%ebp)
     f00:	e8 a1 f4 ff ff       	call   3a6 <open>
     f05:	83 c4 10             	add    $0x10,%esp
     f08:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     f0b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     f0f:	79 0a                	jns    f1b <read24BitmapFile+0x2c>
        return -1;
     f11:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     f16:	e9 66 01 00 00       	jmp    1081 <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     f1b:	83 ec 04             	sub    $0x4,%esp
     f1e:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     f21:	50                   	push   %eax
     f22:	8d 45 ca             	lea    -0x36(%ebp),%eax
     f25:	50                   	push   %eax
     f26:	ff 75 ec             	pushl  -0x14(%ebp)
     f29:	e8 f6 fd ff ff       	call   d24 <readBitmapHeader>
     f2e:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     f31:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     f34:	83 e8 36             	sub    $0x36,%eax
     f37:	83 ec 04             	sub    $0x4,%esp
     f3a:	50                   	push   %eax
     f3b:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     f41:	50                   	push   %eax
     f42:	ff 75 ec             	pushl  -0x14(%ebp)
     f45:	e8 34 f4 ff ff       	call   37e <read>
     f4a:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     f4d:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     f50:	8b 45 14             	mov    0x14(%ebp),%eax
     f53:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     f55:	8b 55 aa             	mov    -0x56(%ebp),%edx
     f58:	8b 45 10             	mov    0x10(%ebp),%eax
     f5b:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     f5d:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     f60:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     f63:	8b 45 aa             	mov    -0x56(%ebp),%eax
     f66:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     f69:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     f6d:	0f b7 c0             	movzwl %ax,%eax
     f70:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
     f73:	8b 55 e8             	mov    -0x18(%ebp),%edx
     f76:	89 d0                	mov    %edx,%eax
     f78:	01 c0                	add    %eax,%eax
     f7a:	01 d0                	add    %edx,%eax
     f7c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     f7f:	8b 45 0c             	mov    0xc(%ebp),%eax
     f82:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     f85:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     f88:	83 e8 01             	sub    $0x1,%eax
     f8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
     f8e:	e9 d1 00 00 00       	jmp    1064 <read24BitmapFile+0x175>
        if (bits == 24) {
     f93:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
     f97:	75 22                	jne    fbb <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     f99:	8b 45 f4             	mov    -0xc(%ebp),%eax
     f9c:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     fa0:	89 c2                	mov    %eax,%edx
     fa2:	8b 45 d8             	mov    -0x28(%ebp),%eax
     fa5:	01 d0                	add    %edx,%eax
     fa7:	83 ec 04             	sub    $0x4,%esp
     faa:	ff 75 dc             	pushl  -0x24(%ebp)
     fad:	50                   	push   %eax
     fae:	ff 75 ec             	pushl  -0x14(%ebp)
     fb1:	e8 c8 f3 ff ff       	call   37e <read>
     fb6:	83 c4 10             	add    $0x10,%esp
     fb9:	eb 66                	jmp    1021 <read24BitmapFile+0x132>
        } else {
            int j = 0;
     fbb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     fc2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     fc9:	eb 4e                	jmp    1019 <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
     fcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
     fce:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     fd2:	89 c2                	mov    %eax,%edx
     fd4:	89 d0                	mov    %edx,%eax
     fd6:	01 c0                	add    %eax,%eax
     fd8:	01 d0                	add    %edx,%eax
     fda:	89 c1                	mov    %eax,%ecx
     fdc:	8b 55 f0             	mov    -0x10(%ebp),%edx
     fdf:	89 d0                	mov    %edx,%eax
     fe1:	01 c0                	add    %eax,%eax
     fe3:	01 d0                	add    %edx,%eax
     fe5:	8d 14 01             	lea    (%ecx,%eax,1),%edx
     fe8:	8b 45 d8             	mov    -0x28(%ebp),%eax
     feb:	01 d0                	add    %edx,%eax
     fed:	83 ec 04             	sub    $0x4,%esp
     ff0:	6a 03                	push   $0x3
     ff2:	50                   	push   %eax
     ff3:	ff 75 ec             	pushl  -0x14(%ebp)
     ff6:	e8 83 f3 ff ff       	call   37e <read>
     ffb:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
     ffe:	83 ec 04             	sub    $0x4,%esp
    1001:	6a 01                	push   $0x1
    1003:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    1009:	50                   	push   %eax
    100a:	ff 75 ec             	pushl  -0x14(%ebp)
    100d:	e8 6c f3 ff ff       	call   37e <read>
    1012:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    1015:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1019:	8b 45 f0             	mov    -0x10(%ebp),%eax
    101c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    101f:	7c aa                	jl     fcb <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    1021:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1024:	99                   	cltd   
    1025:	c1 ea 1e             	shr    $0x1e,%edx
    1028:	01 d0                	add    %edx,%eax
    102a:	83 e0 03             	and    $0x3,%eax
    102d:	29 d0                	sub    %edx,%eax
    102f:	85 c0                	test   %eax,%eax
    1031:	7e 2d                	jle    1060 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1033:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1036:	99                   	cltd   
    1037:	c1 ea 1e             	shr    $0x1e,%edx
    103a:	01 d0                	add    %edx,%eax
    103c:	83 e0 03             	and    $0x3,%eax
    103f:	29 d0                	sub    %edx,%eax
    1041:	ba 04 00 00 00       	mov    $0x4,%edx
    1046:	29 c2                	sub    %eax,%edx
    1048:	89 d0                	mov    %edx,%eax
    104a:	83 ec 04             	sub    $0x4,%esp
    104d:	50                   	push   %eax
    104e:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    1054:	50                   	push   %eax
    1055:	ff 75 ec             	pushl  -0x14(%ebp)
    1058:	e8 21 f3 ff ff       	call   37e <read>
    105d:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    1060:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1064:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1068:	0f 89 25 ff ff ff    	jns    f93 <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    106e:	83 ec 0c             	sub    $0xc,%esp
    1071:	ff 75 ec             	pushl  -0x14(%ebp)
    1074:	e8 15 f3 ff ff       	call   38e <close>
    1079:	83 c4 10             	add    $0x10,%esp
    return 0;
    107c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1081:	c9                   	leave  
    1082:	c3                   	ret    

00001083 <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    1083:	55                   	push   %ebp
    1084:	89 e5                	mov    %esp,%ebp
    1086:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    1089:	8b 55 10             	mov    0x10(%ebp),%edx
    108c:	89 d0                	mov    %edx,%eax
    108e:	01 c0                	add    %eax,%eax
    1090:	01 d0                	add    %edx,%eax
    1092:	c1 e0 03             	shl    $0x3,%eax
    1095:	83 c0 1f             	add    $0x1f,%eax
    1098:	8d 50 1f             	lea    0x1f(%eax),%edx
    109b:	85 c0                	test   %eax,%eax
    109d:	0f 48 c2             	cmovs  %edx,%eax
    10a0:	c1 f8 05             	sar    $0x5,%eax
    10a3:	c1 e0 02             	shl    $0x2,%eax
    10a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    10a9:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    10af:	8b 45 f4             	mov    -0xc(%ebp),%eax
    10b2:	0f af 45 0c          	imul   0xc(%ebp),%eax
    10b6:	83 c0 36             	add    $0x36,%eax
    10b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    10bc:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    10c2:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    10c8:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    10cf:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    10d6:	8b 45 10             	mov    0x10(%ebp),%eax
    10d9:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    10dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    10df:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    10e2:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    10e8:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    10ee:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    10f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    10f8:	0f af 45 0c          	imul   0xc(%ebp),%eax
    10fc:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    10ff:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    1106:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    110d:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    1114:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    111b:	83 ec 04             	sub    $0x4,%esp
    111e:	6a 0e                	push   $0xe
    1120:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    1123:	50                   	push   %eax
    1124:	ff 75 08             	pushl  0x8(%ebp)
    1127:	e8 5a f2 ff ff       	call   386 <write>
    112c:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    112f:	83 ec 04             	sub    $0x4,%esp
    1132:	6a 28                	push   $0x28
    1134:	8d 45 be             	lea    -0x42(%ebp),%eax
    1137:	50                   	push   %eax
    1138:	ff 75 08             	pushl  0x8(%ebp)
    113b:	e8 46 f2 ff ff       	call   386 <write>
    1140:	83 c4 10             	add    $0x10,%esp
}
    1143:	90                   	nop
    1144:	c9                   	leave  
    1145:	c3                   	ret    

00001146 <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    1146:	55                   	push   %ebp
    1147:	89 e5                	mov    %esp,%ebp
    1149:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    114c:	83 ec 08             	sub    $0x8,%esp
    114f:	68 02 02 00 00       	push   $0x202
    1154:	ff 75 08             	pushl  0x8(%ebp)
    1157:	e8 4a f2 ff ff       	call   3a6 <open>
    115c:	83 c4 10             	add    $0x10,%esp
    115f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    1162:	8b 55 14             	mov    0x14(%ebp),%edx
    1165:	89 d0                	mov    %edx,%eax
    1167:	01 c0                	add    %eax,%eax
    1169:	01 d0                	add    %edx,%eax
    116b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    116e:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    1172:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    1176:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    117a:	83 ec 04             	sub    $0x4,%esp
    117d:	ff 75 14             	pushl  0x14(%ebp)
    1180:	ff 75 10             	pushl  0x10(%ebp)
    1183:	ff 75 f0             	pushl  -0x10(%ebp)
    1186:	e8 f8 fe ff ff       	call   1083 <write24BitmapFileHeader>
    118b:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    118e:	8b 45 10             	mov    0x10(%ebp),%eax
    1191:	83 e8 01             	sub    $0x1,%eax
    1194:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1197:	eb 66                	jmp    11ff <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    1199:	8b 45 f4             	mov    -0xc(%ebp),%eax
    119c:	0f af 45 14          	imul   0x14(%ebp),%eax
    11a0:	89 c2                	mov    %eax,%edx
    11a2:	89 d0                	mov    %edx,%eax
    11a4:	01 c0                	add    %eax,%eax
    11a6:	01 c2                	add    %eax,%edx
    11a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    11ab:	01 d0                	add    %edx,%eax
    11ad:	83 ec 04             	sub    $0x4,%esp
    11b0:	ff 75 ec             	pushl  -0x14(%ebp)
    11b3:	50                   	push   %eax
    11b4:	ff 75 f0             	pushl  -0x10(%ebp)
    11b7:	e8 ca f1 ff ff       	call   386 <write>
    11bc:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    11bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    11c2:	99                   	cltd   
    11c3:	c1 ea 1e             	shr    $0x1e,%edx
    11c6:	01 d0                	add    %edx,%eax
    11c8:	83 e0 03             	and    $0x3,%eax
    11cb:	29 d0                	sub    %edx,%eax
    11cd:	85 c0                	test   %eax,%eax
    11cf:	7e 2a                	jle    11fb <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    11d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    11d4:	99                   	cltd   
    11d5:	c1 ea 1e             	shr    $0x1e,%edx
    11d8:	01 d0                	add    %edx,%eax
    11da:	83 e0 03             	and    $0x3,%eax
    11dd:	29 d0                	sub    %edx,%eax
    11df:	ba 04 00 00 00       	mov    $0x4,%edx
    11e4:	29 c2                	sub    %eax,%edx
    11e6:	89 d0                	mov    %edx,%eax
    11e8:	83 ec 04             	sub    $0x4,%esp
    11eb:	50                   	push   %eax
    11ec:	8d 45 e9             	lea    -0x17(%ebp),%eax
    11ef:	50                   	push   %eax
    11f0:	ff 75 f0             	pushl  -0x10(%ebp)
    11f3:	e8 8e f1 ff ff       	call   386 <write>
    11f8:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    11fb:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    11ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1203:	79 94                	jns    1199 <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1205:	83 ec 0c             	sub    $0xc,%esp
    1208:	ff 75 f0             	pushl  -0x10(%ebp)
    120b:	e8 7e f1 ff ff       	call   38e <close>
    1210:	83 c4 10             	add    $0x10,%esp
    return 0;
    1213:	b8 00 00 00 00       	mov    $0x0,%eax
    1218:	c9                   	leave  
    1219:	c3                   	ret    

0000121a <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    121a:	55                   	push   %ebp
    121b:	89 e5                	mov    %esp,%ebp
    121d:	57                   	push   %edi
    121e:	56                   	push   %esi
    121f:	53                   	push   %ebx
    1220:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    1223:	8b 45 08             	mov    0x8(%ebp),%eax
    1226:	8b 50 10             	mov    0x10(%eax),%edx
    1229:	8b 40 0c             	mov    0xc(%eax),%eax
    122c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    122f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    1232:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1235:	8b 55 e0             	mov    -0x20(%ebp),%edx
    1238:	83 c2 1e             	add    $0x1e,%edx
    123b:	0f af d0             	imul   %eax,%edx
    123e:	89 d0                	mov    %edx,%eax
    1240:	01 c0                	add    %eax,%eax
    1242:	01 d0                	add    %edx,%eax
    1244:	83 ec 0c             	sub    $0xc,%esp
    1247:	50                   	push   %eax
    1248:	e8 93 f5 ff ff       	call   7e0 <malloc>
    124d:	83 c4 10             	add    $0x10,%esp
    1250:	89 c2                	mov    %eax,%edx
    1252:	8b 45 08             	mov    0x8(%ebp),%eax
    1255:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    1258:	8b 45 08             	mov    0x8(%ebp),%eax
    125b:	8b 40 1c             	mov    0x1c(%eax),%eax
    125e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    1261:	6b d2 5a             	imul   $0x5a,%edx,%edx
    1264:	01 c2                	add    %eax,%edx
    1266:	8b 45 08             	mov    0x8(%ebp),%eax
    1269:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    126c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    126f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    1272:	0f af d0             	imul   %eax,%edx
    1275:	89 d0                	mov    %edx,%eax
    1277:	01 c0                	add    %eax,%eax
    1279:	01 d0                	add    %edx,%eax
    127b:	89 c2                	mov    %eax,%edx
    127d:	8b 45 08             	mov    0x8(%ebp),%eax
    1280:	8b 40 18             	mov    0x18(%eax),%eax
    1283:	83 ec 04             	sub    $0x4,%esp
    1286:	52                   	push   %edx
    1287:	68 ff 00 00 00       	push   $0xff
    128c:	50                   	push   %eax
    128d:	e8 39 ef ff ff       	call   1cb <memset>
    1292:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    1295:	8b 45 08             	mov    0x8(%ebp),%eax
    1298:	8b 78 1c             	mov    0x1c(%eax),%edi
    129b:	8b 45 08             	mov    0x8(%ebp),%eax
    129e:	8b 70 14             	mov    0x14(%eax),%esi
    12a1:	8b 45 08             	mov    0x8(%ebp),%eax
    12a4:	8b 58 0c             	mov    0xc(%eax),%ebx
    12a7:	8b 45 08             	mov    0x8(%ebp),%eax
    12aa:	8b 48 10             	mov    0x10(%eax),%ecx
    12ad:	8b 45 08             	mov    0x8(%ebp),%eax
    12b0:	8b 50 08             	mov    0x8(%eax),%edx
    12b3:	8b 45 08             	mov    0x8(%ebp),%eax
    12b6:	8b 40 04             	mov    0x4(%eax),%eax
    12b9:	83 ec 08             	sub    $0x8,%esp
    12bc:	57                   	push   %edi
    12bd:	56                   	push   %esi
    12be:	53                   	push   %ebx
    12bf:	51                   	push   %ecx
    12c0:	52                   	push   %edx
    12c1:	50                   	push   %eax
    12c2:	e8 3f f1 ff ff       	call   406 <createwindow>
    12c7:	83 c4 20             	add    $0x20,%esp
    12ca:	89 c2                	mov    %eax,%edx
    12cc:	8b 45 08             	mov    0x8(%ebp),%eax
    12cf:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    12d1:	8b 45 08             	mov    0x8(%ebp),%eax
    12d4:	8b 00                	mov    (%eax),%eax
}
    12d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
    12d9:	5b                   	pop    %ebx
    12da:	5e                   	pop    %esi
    12db:	5f                   	pop    %edi
    12dc:	5d                   	pop    %ebp
    12dd:	c3                   	ret    

000012de <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    12de:	55                   	push   %ebp
    12df:	89 e5                	mov    %esp,%ebp
    12e1:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    12e4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    12eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    12f2:	8b 45 08             	mov    0x8(%ebp),%eax
    12f5:	8b 40 18             	mov    0x18(%eax),%eax
    12f8:	ff 75 1c             	pushl  0x1c(%ebp)
    12fb:	ff 75 18             	pushl  0x18(%ebp)
    12fe:	ff 75 1c             	pushl  0x1c(%ebp)
    1301:	ff 75 18             	pushl  0x18(%ebp)
    1304:	8b 55 08             	mov    0x8(%ebp),%edx
    1307:	ff 72 10             	pushl  0x10(%edx)
    130a:	ff 72 0c             	pushl  0xc(%edx)
    130d:	ff 75 f4             	pushl  -0xc(%ebp)
    1310:	ff 75 f0             	pushl  -0x10(%ebp)
    1313:	ff 75 14             	pushl  0x14(%ebp)
    1316:	ff 75 10             	pushl  0x10(%ebp)
    1319:	ff 75 0c             	pushl  0xc(%ebp)
    131c:	50                   	push   %eax
    131d:	e8 d5 07 00 00       	call   1af7 <drawBitmap>
    1322:	83 c4 30             	add    $0x30,%esp
    return 0;
    1325:	b8 00 00 00 00       	mov    $0x0,%eax
}
    132a:	c9                   	leave  
    132b:	c3                   	ret    

0000132c <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    132c:	55                   	push   %ebp
    132d:	89 e5                	mov    %esp,%ebp
    132f:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1332:	8b 45 08             	mov    0x8(%ebp),%eax
    1335:	8b 40 18             	mov    0x18(%eax),%eax
    1338:	ff 75 2c             	pushl  0x2c(%ebp)
    133b:	ff 75 28             	pushl  0x28(%ebp)
    133e:	ff 75 24             	pushl  0x24(%ebp)
    1341:	ff 75 20             	pushl  0x20(%ebp)
    1344:	8b 55 08             	mov    0x8(%ebp),%edx
    1347:	ff 72 10             	pushl  0x10(%edx)
    134a:	ff 72 0c             	pushl  0xc(%edx)
    134d:	ff 75 1c             	pushl  0x1c(%ebp)
    1350:	ff 75 18             	pushl  0x18(%ebp)
    1353:	ff 75 14             	pushl  0x14(%ebp)
    1356:	ff 75 10             	pushl  0x10(%ebp)
    1359:	ff 75 0c             	pushl  0xc(%ebp)
    135c:	50                   	push   %eax
    135d:	e8 95 07 00 00       	call   1af7 <drawBitmap>
    1362:	83 c4 30             	add    $0x30,%esp
    return 0;
    1365:	b8 00 00 00 00       	mov    $0x0,%eax
}
    136a:	c9                   	leave  
    136b:	c3                   	ret    

0000136c <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    136c:	55                   	push   %ebp
    136d:	89 e5                	mov    %esp,%ebp
    136f:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1372:	8b 45 08             	mov    0x8(%ebp),%eax
    1375:	8b 40 18             	mov    0x18(%eax),%eax
    1378:	ff 75 2c             	pushl  0x2c(%ebp)
    137b:	ff 75 28             	pushl  0x28(%ebp)
    137e:	ff 75 24             	pushl  0x24(%ebp)
    1381:	ff 75 20             	pushl  0x20(%ebp)
    1384:	8b 55 08             	mov    0x8(%ebp),%edx
    1387:	ff 72 10             	pushl  0x10(%edx)
    138a:	ff 72 0c             	pushl  0xc(%edx)
    138d:	ff 75 1c             	pushl  0x1c(%ebp)
    1390:	ff 75 18             	pushl  0x18(%ebp)
    1393:	ff 75 14             	pushl  0x14(%ebp)
    1396:	ff 75 10             	pushl  0x10(%ebp)
    1399:	ff 75 0c             	pushl  0xc(%ebp)
    139c:	50                   	push   %eax
    139d:	e8 75 08 00 00       	call   1c17 <drawTransparentBitmap>
    13a2:	83 c4 30             	add    $0x30,%esp
    return 0;
    13a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13aa:	c9                   	leave  
    13ab:	c3                   	ret    

000013ac <api_repaint>:

int api_repaint(Window* wnd)
{
    13ac:	55                   	push   %ebp
    13ad:	89 e5                	mov    %esp,%ebp
    13af:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    13b2:	8b 45 08             	mov    0x8(%ebp),%eax
    13b5:	8b 00                	mov    (%eax),%eax
    13b7:	83 ec 0c             	sub    $0xc,%esp
    13ba:	50                   	push   %eax
    13bb:	e8 4e f0 ff ff       	call   40e <repaintwindow>
    13c0:	83 c4 10             	add    $0x10,%esp
    return 0;
    13c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13c8:	c9                   	leave  
    13c9:	c3                   	ret    

000013ca <api_update>:

int api_update(Window* wnd, Rect rect)
{
    13ca:	55                   	push   %ebp
    13cb:	89 e5                	mov    %esp,%ebp
    13cd:	56                   	push   %esi
    13ce:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    13cf:	8b 75 18             	mov    0x18(%ebp),%esi
    13d2:	8b 5d 14             	mov    0x14(%ebp),%ebx
    13d5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    13d8:	8b 55 0c             	mov    0xc(%ebp),%edx
    13db:	8b 45 08             	mov    0x8(%ebp),%eax
    13de:	8b 00                	mov    (%eax),%eax
    13e0:	83 ec 0c             	sub    $0xc,%esp
    13e3:	56                   	push   %esi
    13e4:	53                   	push   %ebx
    13e5:	51                   	push   %ecx
    13e6:	52                   	push   %edx
    13e7:	50                   	push   %eax
    13e8:	e8 39 f0 ff ff       	call   426 <updatewindow>
    13ed:	83 c4 20             	add    $0x20,%esp
    return 0;
    13f0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13f5:	8d 65 f8             	lea    -0x8(%ebp),%esp
    13f8:	5b                   	pop    %ebx
    13f9:	5e                   	pop    %esi
    13fa:	5d                   	pop    %ebp
    13fb:	c3                   	ret    

000013fc <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    13fc:	55                   	push   %ebp
    13fd:	89 e5                	mov    %esp,%ebp
    13ff:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    1402:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    1409:	8b 45 08             	mov    0x8(%ebp),%eax
    140c:	8b 00                	mov    (%eax),%eax
    140e:	83 ec 08             	sub    $0x8,%esp
    1411:	8d 55 c8             	lea    -0x38(%ebp),%edx
    1414:	52                   	push   %edx
    1415:	50                   	push   %eax
    1416:	e8 fb ef ff ff       	call   416 <getmessage>
    141b:	83 c4 10             	add    $0x10,%esp
    141e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    1421:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1425:	74 e2                	je     1409 <api_exec+0xd>
        {
            pf(&msg);
    1427:	83 ec 0c             	sub    $0xc,%esp
    142a:	8d 45 c8             	lea    -0x38(%ebp),%eax
    142d:	50                   	push   %eax
    142e:	8b 45 0c             	mov    0xc(%ebp),%eax
    1431:	ff d0                	call   *%eax
    1433:	83 c4 10             	add    $0x10,%esp
        }
    }
    1436:	eb d1                	jmp    1409 <api_exec+0xd>

00001438 <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    1438:	55                   	push   %ebp
    1439:	89 e5                	mov    %esp,%ebp
    143b:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    143e:	8b 45 08             	mov    0x8(%ebp),%eax
    1441:	8b 00                	mov    (%eax),%eax
    1443:	83 ec 08             	sub    $0x8,%esp
    1446:	ff 75 0c             	pushl  0xc(%ebp)
    1449:	50                   	push   %eax
    144a:	e8 cf ef ff ff       	call   41e <settimer>
    144f:	83 c4 10             	add    $0x10,%esp
    return 0;
    1452:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1457:	c9                   	leave  
    1458:	c3                   	ret    

00001459 <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    1459:	55                   	push   %ebp
    145a:	89 e5                	mov    %esp,%ebp
    145c:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    145f:	8b 45 08             	mov    0x8(%ebp),%eax
    1462:	8b 50 18             	mov    0x18(%eax),%edx
    1465:	ff 75 18             	pushl  0x18(%ebp)
    1468:	ff 75 14             	pushl  0x14(%ebp)
    146b:	83 ec 04             	sub    $0x4,%esp
    146e:	89 e0                	mov    %esp,%eax
    1470:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    1474:	66 89 08             	mov    %cx,(%eax)
    1477:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    147b:	88 48 02             	mov    %cl,0x2(%eax)
    147e:	8b 45 08             	mov    0x8(%ebp),%eax
    1481:	ff 70 10             	pushl  0x10(%eax)
    1484:	ff 70 0c             	pushl  0xc(%eax)
    1487:	ff 75 10             	pushl  0x10(%ebp)
    148a:	ff 75 0c             	pushl  0xc(%ebp)
    148d:	52                   	push   %edx
    148e:	e8 6f 04 00 00       	call   1902 <drawRect>
    1493:	83 c4 20             	add    $0x20,%esp
    return 0;
    1496:	b8 00 00 00 00       	mov    $0x0,%eax
}
    149b:	c9                   	leave  
    149c:	c3                   	ret    

0000149d <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    149d:	55                   	push   %ebp
    149e:	89 e5                	mov    %esp,%ebp
    14a0:	83 ec 28             	sub    $0x28,%esp
    14a3:	8b 45 14             	mov    0x14(%ebp),%eax
    14a6:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    14a9:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    14ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    14b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    14b3:	8b 45 10             	mov    0x10(%ebp),%eax
    14b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    14b9:	8b 45 08             	mov    0x8(%ebp),%eax
    14bc:	8b 40 18             	mov    0x18(%eax),%eax
    14bf:	83 ec 04             	sub    $0x4,%esp
    14c2:	ff 75 18             	pushl  0x18(%ebp)
    14c5:	52                   	push   %edx
    14c6:	8b 55 08             	mov    0x8(%ebp),%edx
    14c9:	ff 72 10             	pushl  0x10(%edx)
    14cc:	ff 72 0c             	pushl  0xc(%edx)
    14cf:	ff 75 f4             	pushl  -0xc(%ebp)
    14d2:	ff 75 f0             	pushl  -0x10(%ebp)
    14d5:	50                   	push   %eax
    14d6:	e8 d4 02 00 00       	call   17af <drawCharacter>
    14db:	83 c4 20             	add    $0x20,%esp
    return 0;
    14de:	b8 00 00 00 00       	mov    $0x0,%eax
}
    14e3:	c9                   	leave  
    14e4:	c3                   	ret    

000014e5 <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    14e5:	55                   	push   %ebp
    14e6:	89 e5                	mov    %esp,%ebp
    14e8:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    14eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    14ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
    14f1:	8b 45 10             	mov    0x10(%ebp),%eax
    14f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    14f7:	8b 45 08             	mov    0x8(%ebp),%eax
    14fa:	8b 40 18             	mov    0x18(%eax),%eax
    14fd:	83 ec 04             	sub    $0x4,%esp
    1500:	ff 75 18             	pushl  0x18(%ebp)
    1503:	ff 75 14             	pushl  0x14(%ebp)
    1506:	8b 55 08             	mov    0x8(%ebp),%edx
    1509:	ff 72 10             	pushl  0x10(%edx)
    150c:	ff 72 0c             	pushl  0xc(%edx)
    150f:	ff 75 f4             	pushl  -0xc(%ebp)
    1512:	ff 75 f0             	pushl  -0x10(%ebp)
    1515:	50                   	push   %eax
    1516:	e8 8e 03 00 00       	call   18a9 <drawString>
    151b:	83 c4 20             	add    $0x20,%esp
    return 0;
    151e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1523:	c9                   	leave  
    1524:	c3                   	ret    

00001525 <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    1525:	55                   	push   %ebp
    1526:	89 e5                	mov    %esp,%ebp
    1528:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    152b:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    152f:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    1533:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    1537:	83 ec 08             	sub    $0x8,%esp
    153a:	83 ec 04             	sub    $0x4,%esp
    153d:	89 e0                	mov    %esp,%eax
    153f:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    1543:	66 89 10             	mov    %dx,(%eax)
    1546:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    154a:	88 50 02             	mov    %dl,0x2(%eax)
    154d:	ff 75 18             	pushl  0x18(%ebp)
    1550:	ff 75 14             	pushl  0x14(%ebp)
    1553:	ff 75 10             	pushl  0x10(%ebp)
    1556:	ff 75 0c             	pushl  0xc(%ebp)
    1559:	ff 75 08             	pushl  0x8(%ebp)
    155c:	e8 f8 fe ff ff       	call   1459 <api_drawRect>
    1561:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    1564:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    1568:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    156c:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    1570:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    1574:	8b 45 10             	mov    0x10(%ebp),%eax
    1577:	8d 50 0a             	lea    0xa(%eax),%edx
    157a:	8b 45 0c             	mov    0xc(%ebp),%eax
    157d:	83 c0 0a             	add    $0xa,%eax
    1580:	83 ec 0c             	sub    $0xc,%esp
    1583:	ff 75 f4             	pushl  -0xc(%ebp)
    1586:	ff 75 1c             	pushl  0x1c(%ebp)
    1589:	52                   	push   %edx
    158a:	50                   	push   %eax
    158b:	ff 75 08             	pushl  0x8(%ebp)
    158e:	e8 52 ff ff ff       	call   14e5 <api_drawString>
    1593:	83 c4 20             	add    $0x20,%esp
    return 0;
    1596:	b8 00 00 00 00       	mov    $0x0,%eax
}
    159b:	c9                   	leave  
    159c:	c3                   	ret    

0000159d <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    159d:	55                   	push   %ebp
    159e:	89 e5                	mov    %esp,%ebp
    15a0:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    15a3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    15aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    15b1:	8b 45 08             	mov    0x8(%ebp),%eax
    15b4:	8b 40 18             	mov    0x18(%eax),%eax
    15b7:	ff 75 1c             	pushl  0x1c(%ebp)
    15ba:	ff 75 18             	pushl  0x18(%ebp)
    15bd:	ff 75 1c             	pushl  0x1c(%ebp)
    15c0:	ff 75 18             	pushl  0x18(%ebp)
    15c3:	8b 55 08             	mov    0x8(%ebp),%edx
    15c6:	ff 72 10             	pushl  0x10(%edx)
    15c9:	ff 72 0c             	pushl  0xc(%edx)
    15cc:	ff 75 f4             	pushl  -0xc(%ebp)
    15cf:	ff 75 f0             	pushl  -0x10(%ebp)
    15d2:	ff 75 14             	pushl  0x14(%ebp)
    15d5:	ff 75 10             	pushl  0x10(%ebp)
    15d8:	ff 75 0c             	pushl  0xc(%ebp)
    15db:	50                   	push   %eax
    15dc:	e8 16 05 00 00       	call   1af7 <drawBitmap>
    15e1:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    15e4:	8b 45 08             	mov    0x8(%ebp),%eax
    15e7:	8b 40 18             	mov    0x18(%eax),%eax
    15ea:	ff 75 28             	pushl  0x28(%ebp)
    15ed:	ff 75 1c             	pushl  0x1c(%ebp)
    15f0:	ff 75 18             	pushl  0x18(%ebp)
    15f3:	8b 55 08             	mov    0x8(%ebp),%edx
    15f6:	ff 72 10             	pushl  0x10(%edx)
    15f9:	ff 72 0c             	pushl  0xc(%edx)
    15fc:	ff 75 14             	pushl  0x14(%ebp)
    15ff:	ff 75 10             	pushl  0x10(%ebp)
    1602:	50                   	push   %eax
    1603:	e8 99 07 00 00       	call   1da1 <colorShift>
    1608:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    160b:	8b 45 08             	mov    0x8(%ebp),%eax
    160e:	8b 50 18             	mov    0x18(%eax),%edx
    1611:	83 ec 0c             	sub    $0xc,%esp
    1614:	ff 75 20             	pushl  0x20(%ebp)
    1617:	ff 75 1c             	pushl  0x1c(%ebp)
    161a:	ff 75 18             	pushl  0x18(%ebp)
    161d:	83 ec 04             	sub    $0x4,%esp
    1620:	89 e0                	mov    %esp,%eax
    1622:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    1626:	66 89 08             	mov    %cx,(%eax)
    1629:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    162d:	88 48 02             	mov    %cl,0x2(%eax)
    1630:	8b 45 08             	mov    0x8(%ebp),%eax
    1633:	ff 70 10             	pushl  0x10(%eax)
    1636:	ff 70 0c             	pushl  0xc(%eax)
    1639:	ff 75 14             	pushl  0x14(%ebp)
    163c:	ff 75 10             	pushl  0x10(%ebp)
    163f:	52                   	push   %edx
    1640:	e8 6d 03 00 00       	call   19b2 <drawBorder>
    1645:	83 c4 30             	add    $0x30,%esp
    return 0;
    1648:	b8 00 00 00 00       	mov    $0x0,%eax
}
    164d:	c9                   	leave  
    164e:	c3                   	ret    

0000164f <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    164f:	55                   	push   %ebp
    1650:	89 e5                	mov    %esp,%ebp
    1652:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    1655:	8b 45 08             	mov    0x8(%ebp),%eax
    1658:	8b 00                	mov    (%eax),%eax
    165a:	83 ec 0c             	sub    $0xc,%esp
    165d:	50                   	push   %eax
    165e:	e8 cb ed ff ff       	call   42e <destroywindow>
    1663:	83 c4 10             	add    $0x10,%esp
    return 0;
    1666:	b8 00 00 00 00       	mov    $0x0,%eax
    166b:	c9                   	leave  
    166c:	c3                   	ret    

0000166d <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    166d:	55                   	push   %ebp
    166e:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    1670:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    1674:	8b 45 08             	mov    0x8(%ebp),%eax
    1677:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    167a:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    167e:	8b 45 08             	mov    0x8(%ebp),%eax
    1681:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    1684:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    1688:	8b 45 08             	mov    0x8(%ebp),%eax
    168b:	88 10                	mov    %dl,(%eax)
}
    168d:	90                   	nop
    168e:	5d                   	pop    %ebp
    168f:	c3                   	ret    

00001690 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    1690:	55                   	push   %ebp
    1691:	89 e5                	mov    %esp,%ebp
    1693:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    1696:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    169a:	3c ff                	cmp    $0xff,%al
    169c:	75 22                	jne    16c0 <drawPointAlpha+0x30>
        color->R = origin.R;
    169e:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    16a2:	8b 45 08             	mov    0x8(%ebp),%eax
    16a5:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    16a8:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    16ac:	8b 45 08             	mov    0x8(%ebp),%eax
    16af:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    16b2:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    16b6:	8b 45 08             	mov    0x8(%ebp),%eax
    16b9:	88 10                	mov    %dl,(%eax)
        return;
    16bb:	e9 ed 00 00 00       	jmp    17ad <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    16c0:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    16c4:	84 c0                	test   %al,%al
    16c6:	0f 84 e0 00 00 00    	je     17ac <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    16cc:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    16d0:	0f b6 c0             	movzbl %al,%eax
    16d3:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    16d7:	df 45 e4             	fild   -0x1c(%ebp)
    16da:	d9 05 40 9d 01 00    	flds   0x19d40
    16e0:	de f9                	fdivrp %st,%st(1)
    16e2:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    16e5:	8b 45 08             	mov    0x8(%ebp),%eax
    16e8:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    16ec:	0f b6 c0             	movzbl %al,%eax
    16ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16f2:	db 45 e4             	fildl  -0x1c(%ebp)
    16f5:	d9 e8                	fld1   
    16f7:	d8 65 fc             	fsubs  -0x4(%ebp)
    16fa:	de c9                	fmulp  %st,%st(1)
    16fc:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    1700:	0f b6 c0             	movzbl %al,%eax
    1703:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1706:	db 45 e4             	fildl  -0x1c(%ebp)
    1709:	d8 4d fc             	fmuls  -0x4(%ebp)
    170c:	de c1                	faddp  %st,%st(1)
    170e:	d9 7d ee             	fnstcw -0x12(%ebp)
    1711:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    1715:	b4 0c                	mov    $0xc,%ah
    1717:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    171b:	d9 6d ec             	fldcw  -0x14(%ebp)
    171e:	df 5d ea             	fistp  -0x16(%ebp)
    1721:	d9 6d ee             	fldcw  -0x12(%ebp)
    1724:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1728:	89 c2                	mov    %eax,%edx
    172a:	8b 45 08             	mov    0x8(%ebp),%eax
    172d:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    1730:	8b 45 08             	mov    0x8(%ebp),%eax
    1733:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1737:	0f b6 c0             	movzbl %al,%eax
    173a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    173d:	db 45 e4             	fildl  -0x1c(%ebp)
    1740:	d9 e8                	fld1   
    1742:	d8 65 fc             	fsubs  -0x4(%ebp)
    1745:	de c9                	fmulp  %st,%st(1)
    1747:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    174b:	0f b6 c0             	movzbl %al,%eax
    174e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1751:	db 45 e4             	fildl  -0x1c(%ebp)
    1754:	d8 4d fc             	fmuls  -0x4(%ebp)
    1757:	de c1                	faddp  %st,%st(1)
    1759:	d9 6d ec             	fldcw  -0x14(%ebp)
    175c:	df 5d ea             	fistp  -0x16(%ebp)
    175f:	d9 6d ee             	fldcw  -0x12(%ebp)
    1762:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1766:	89 c2                	mov    %eax,%edx
    1768:	8b 45 08             	mov    0x8(%ebp),%eax
    176b:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    176e:	8b 45 08             	mov    0x8(%ebp),%eax
    1771:	0f b6 00             	movzbl (%eax),%eax
    1774:	0f b6 c0             	movzbl %al,%eax
    1777:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    177a:	db 45 e4             	fildl  -0x1c(%ebp)
    177d:	d9 e8                	fld1   
    177f:	d8 65 fc             	fsubs  -0x4(%ebp)
    1782:	de c9                	fmulp  %st,%st(1)
    1784:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    1788:	0f b6 c0             	movzbl %al,%eax
    178b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    178e:	db 45 e4             	fildl  -0x1c(%ebp)
    1791:	d8 4d fc             	fmuls  -0x4(%ebp)
    1794:	de c1                	faddp  %st,%st(1)
    1796:	d9 6d ec             	fldcw  -0x14(%ebp)
    1799:	df 5d ea             	fistp  -0x16(%ebp)
    179c:	d9 6d ee             	fldcw  -0x12(%ebp)
    179f:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    17a3:	89 c2                	mov    %eax,%edx
    17a5:	8b 45 08             	mov    0x8(%ebp),%eax
    17a8:	88 10                	mov    %dl,(%eax)
    17aa:	eb 01                	jmp    17ad <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    17ac:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    17ad:	c9                   	leave  
    17ae:	c3                   	ret    

000017af <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    17af:	55                   	push   %ebp
    17b0:	89 e5                	mov    %esp,%ebp
    17b2:	83 ec 14             	sub    $0x14,%esp
    17b5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    17b8:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    17bb:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    17bf:	83 e8 20             	sub    $0x20,%eax
    17c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    17c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    17c9:	0f 88 d7 00 00 00    	js     18a6 <drawCharacter+0xf7>
    17cf:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    17d3:	0f 8f cd 00 00 00    	jg     18a6 <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    17d9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    17e0:	e9 b5 00 00 00       	jmp    189a <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    17e5:	8b 55 10             	mov    0x10(%ebp),%edx
    17e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    17eb:	01 c2                	add    %eax,%edx
    17ed:	8b 45 14             	mov    0x14(%ebp),%eax
    17f0:	39 c2                	cmp    %eax,%edx
    17f2:	0f 8f af 00 00 00    	jg     18a7 <drawCharacter+0xf8>
    17f8:	8b 55 10             	mov    0x10(%ebp),%edx
    17fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    17fe:	01 d0                	add    %edx,%eax
    1800:	85 c0                	test   %eax,%eax
    1802:	0f 88 9f 00 00 00    	js     18a7 <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1808:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    180f:	eb 7b                	jmp    188c <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    1811:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1814:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    1817:	89 d0                	mov    %edx,%eax
    1819:	c1 e0 03             	shl    $0x3,%eax
    181c:	01 d0                	add    %edx,%eax
    181e:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    1824:	01 c2                	add    %eax,%edx
    1826:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1829:	01 d0                	add    %edx,%eax
    182b:	05 20 61 01 00       	add    $0x16120,%eax
    1830:	0f b6 00             	movzbl (%eax),%eax
    1833:	3c 01                	cmp    $0x1,%al
    1835:	75 51                	jne    1888 <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    1837:	8b 55 0c             	mov    0xc(%ebp),%edx
    183a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    183d:	01 c2                	add    %eax,%edx
    183f:	8b 45 18             	mov    0x18(%ebp),%eax
    1842:	39 c2                	cmp    %eax,%edx
    1844:	7f 50                	jg     1896 <drawCharacter+0xe7>
    1846:	8b 55 0c             	mov    0xc(%ebp),%edx
    1849:	8b 45 f8             	mov    -0x8(%ebp),%eax
    184c:	01 d0                	add    %edx,%eax
    184e:	85 c0                	test   %eax,%eax
    1850:	78 44                	js     1896 <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    1852:	8b 55 10             	mov    0x10(%ebp),%edx
    1855:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1858:	01 c2                	add    %eax,%edx
    185a:	8b 45 18             	mov    0x18(%ebp),%eax
    185d:	0f af c2             	imul   %edx,%eax
    1860:	89 c2                	mov    %eax,%edx
    1862:	8b 45 0c             	mov    0xc(%ebp),%eax
    1865:	01 c2                	add    %eax,%edx
    1867:	8b 45 f8             	mov    -0x8(%ebp),%eax
    186a:	01 c2                	add    %eax,%edx
    186c:	89 d0                	mov    %edx,%eax
    186e:	01 c0                	add    %eax,%eax
    1870:	01 c2                	add    %eax,%edx
    1872:	8b 45 08             	mov    0x8(%ebp),%eax
    1875:	01 d0                	add    %edx,%eax
    1877:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    187a:	ff 75 20             	pushl  0x20(%ebp)
    187d:	ff 75 f0             	pushl  -0x10(%ebp)
    1880:	e8 0b fe ff ff       	call   1690 <drawPointAlpha>
    1885:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1888:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    188c:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    1890:	0f 8e 7b ff ff ff    	jle    1811 <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1896:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    189a:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    189e:	0f 8e 41 ff ff ff    	jle    17e5 <drawCharacter+0x36>
    18a4:	eb 01                	jmp    18a7 <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    18a6:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    18a7:	c9                   	leave  
    18a8:	c3                   	ret    

000018a9 <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    18a9:	55                   	push   %ebp
    18aa:	89 e5                	mov    %esp,%ebp
    18ac:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    18af:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    18b6:	eb 3d                	jmp    18f5 <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    18b8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    18bb:	0f b6 00             	movzbl (%eax),%eax
    18be:	0f be c0             	movsbl %al,%eax
    18c1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    18c4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    18c7:	01 ca                	add    %ecx,%edx
    18c9:	89 55 f4             	mov    %edx,-0xc(%ebp)
    18cc:	8b 55 10             	mov    0x10(%ebp),%edx
    18cf:	89 55 f8             	mov    %edx,-0x8(%ebp)
    18d2:	ff 75 20             	pushl  0x20(%ebp)
    18d5:	50                   	push   %eax
    18d6:	ff 75 18             	pushl  0x18(%ebp)
    18d9:	ff 75 14             	pushl  0x14(%ebp)
    18dc:	ff 75 f8             	pushl  -0x8(%ebp)
    18df:	ff 75 f4             	pushl  -0xc(%ebp)
    18e2:	ff 75 08             	pushl  0x8(%ebp)
    18e5:	e8 c5 fe ff ff       	call   17af <drawCharacter>
    18ea:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    18ed:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    18f1:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    18f5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    18f8:	0f b6 00             	movzbl (%eax),%eax
    18fb:	84 c0                	test   %al,%al
    18fd:	75 b9                	jne    18b8 <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    18ff:	90                   	nop
    1900:	c9                   	leave  
    1901:	c3                   	ret    

00001902 <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    1902:	55                   	push   %ebp
    1903:	89 e5                	mov    %esp,%ebp
    1905:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1908:	8b 45 20             	mov    0x20(%ebp),%eax
    190b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    190e:	8b 45 24             	mov    0x24(%ebp),%eax
    1911:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1914:	8b 55 14             	mov    0x14(%ebp),%edx
    1917:	8b 45 10             	mov    0x10(%ebp),%eax
    191a:	29 c2                	sub    %eax,%edx
    191c:	89 d0                	mov    %edx,%eax
    191e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1921:	7d 0d                	jge    1930 <drawRect+0x2e>
        draw_h = s.h - p.y;
    1923:	8b 55 14             	mov    0x14(%ebp),%edx
    1926:	8b 45 10             	mov    0x10(%ebp),%eax
    1929:	29 c2                	sub    %eax,%edx
    192b:	89 d0                	mov    %edx,%eax
    192d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1930:	8b 55 18             	mov    0x18(%ebp),%edx
    1933:	8b 45 0c             	mov    0xc(%ebp),%eax
    1936:	29 c2                	sub    %eax,%edx
    1938:	89 d0                	mov    %edx,%eax
    193a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    193d:	7d 0d                	jge    194c <drawRect+0x4a>
        draw_w = s.w - p.x;
    193f:	8b 55 18             	mov    0x18(%ebp),%edx
    1942:	8b 45 0c             	mov    0xc(%ebp),%eax
    1945:	29 c2                	sub    %eax,%edx
    1947:	89 d0                	mov    %edx,%eax
    1949:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    194c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1953:	eb 52                	jmp    19a7 <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    1955:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    195c:	eb 3d                	jmp    199b <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    195e:	8b 55 10             	mov    0x10(%ebp),%edx
    1961:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1964:	01 c2                	add    %eax,%edx
    1966:	8b 45 18             	mov    0x18(%ebp),%eax
    1969:	0f af c2             	imul   %edx,%eax
    196c:	89 c2                	mov    %eax,%edx
    196e:	8b 45 0c             	mov    0xc(%ebp),%eax
    1971:	01 c2                	add    %eax,%edx
    1973:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1976:	01 c2                	add    %eax,%edx
    1978:	89 d0                	mov    %edx,%eax
    197a:	01 c0                	add    %eax,%eax
    197c:	01 c2                	add    %eax,%edx
    197e:	8b 45 08             	mov    0x8(%ebp),%eax
    1981:	01 d0                	add    %edx,%eax
    1983:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    1986:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1989:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    198d:	66 89 10             	mov    %dx,(%eax)
    1990:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1994:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1997:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    199b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    199e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    19a1:	7c bb                	jl     195e <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    19a3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    19a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    19aa:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    19ad:	7c a6                	jl     1955 <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    19af:	90                   	nop
    19b0:	c9                   	leave  
    19b1:	c3                   	ret    

000019b2 <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    19b2:	55                   	push   %ebp
    19b3:	89 e5                	mov    %esp,%ebp
    19b5:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    19b8:	8b 45 28             	mov    0x28(%ebp),%eax
    19bb:	89 45 c8             	mov    %eax,-0x38(%ebp)
    19be:	8b 45 24             	mov    0x24(%ebp),%eax
    19c1:	89 45 cc             	mov    %eax,-0x34(%ebp)
    19c4:	ff 75 cc             	pushl  -0x34(%ebp)
    19c7:	ff 75 c8             	pushl  -0x38(%ebp)
    19ca:	83 ec 04             	sub    $0x4,%esp
    19cd:	89 e0                	mov    %esp,%eax
    19cf:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    19d3:	66 89 10             	mov    %dx,(%eax)
    19d6:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    19da:	88 50 02             	mov    %dl,0x2(%eax)
    19dd:	ff 75 18             	pushl  0x18(%ebp)
    19e0:	ff 75 14             	pushl  0x14(%ebp)
    19e3:	ff 75 10             	pushl  0x10(%ebp)
    19e6:	ff 75 0c             	pushl  0xc(%ebp)
    19e9:	ff 75 08             	pushl  0x8(%ebp)
    19ec:	e8 11 ff ff ff       	call   1902 <drawRect>
    19f1:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    19f4:	8b 45 28             	mov    0x28(%ebp),%eax
    19f7:	89 45 d0             	mov    %eax,-0x30(%ebp)
    19fa:	8b 45 24             	mov    0x24(%ebp),%eax
    19fd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1a00:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a03:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1a06:	8b 55 10             	mov    0x10(%ebp),%edx
    1a09:	8b 45 20             	mov    0x20(%ebp),%eax
    1a0c:	01 d0                	add    %edx,%eax
    1a0e:	2b 45 28             	sub    0x28(%ebp),%eax
    1a11:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1a14:	ff 75 d4             	pushl  -0x2c(%ebp)
    1a17:	ff 75 d0             	pushl  -0x30(%ebp)
    1a1a:	83 ec 04             	sub    $0x4,%esp
    1a1d:	89 e0                	mov    %esp,%eax
    1a1f:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1a23:	66 89 10             	mov    %dx,(%eax)
    1a26:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1a2a:	88 50 02             	mov    %dl,0x2(%eax)
    1a2d:	ff 75 18             	pushl  0x18(%ebp)
    1a30:	ff 75 14             	pushl  0x14(%ebp)
    1a33:	ff 75 dc             	pushl  -0x24(%ebp)
    1a36:	ff 75 d8             	pushl  -0x28(%ebp)
    1a39:	ff 75 08             	pushl  0x8(%ebp)
    1a3c:	e8 c1 fe ff ff       	call   1902 <drawRect>
    1a41:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1a44:	8b 45 20             	mov    0x20(%ebp),%eax
    1a47:	8b 55 28             	mov    0x28(%ebp),%edx
    1a4a:	01 d2                	add    %edx,%edx
    1a4c:	29 d0                	sub    %edx,%eax
    1a4e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1a51:	8b 45 28             	mov    0x28(%ebp),%eax
    1a54:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1a57:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a5a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1a5d:	8b 55 10             	mov    0x10(%ebp),%edx
    1a60:	8b 45 28             	mov    0x28(%ebp),%eax
    1a63:	01 d0                	add    %edx,%eax
    1a65:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1a68:	ff 75 e4             	pushl  -0x1c(%ebp)
    1a6b:	ff 75 e0             	pushl  -0x20(%ebp)
    1a6e:	83 ec 04             	sub    $0x4,%esp
    1a71:	89 e0                	mov    %esp,%eax
    1a73:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1a77:	66 89 10             	mov    %dx,(%eax)
    1a7a:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1a7e:	88 50 02             	mov    %dl,0x2(%eax)
    1a81:	ff 75 18             	pushl  0x18(%ebp)
    1a84:	ff 75 14             	pushl  0x14(%ebp)
    1a87:	ff 75 ec             	pushl  -0x14(%ebp)
    1a8a:	ff 75 e8             	pushl  -0x18(%ebp)
    1a8d:	ff 75 08             	pushl  0x8(%ebp)
    1a90:	e8 6d fe ff ff       	call   1902 <drawRect>
    1a95:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1a98:	8b 45 20             	mov    0x20(%ebp),%eax
    1a9b:	8b 55 28             	mov    0x28(%ebp),%edx
    1a9e:	01 d2                	add    %edx,%edx
    1aa0:	29 d0                	sub    %edx,%eax
    1aa2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1aa5:	8b 45 28             	mov    0x28(%ebp),%eax
    1aa8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1aab:	8b 55 0c             	mov    0xc(%ebp),%edx
    1aae:	8b 45 24             	mov    0x24(%ebp),%eax
    1ab1:	01 d0                	add    %edx,%eax
    1ab3:	2b 45 28             	sub    0x28(%ebp),%eax
    1ab6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    1ab9:	8b 55 10             	mov    0x10(%ebp),%edx
    1abc:	8b 45 28             	mov    0x28(%ebp),%eax
    1abf:	01 d0                	add    %edx,%eax
    1ac1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1ac4:	ff 75 f4             	pushl  -0xc(%ebp)
    1ac7:	ff 75 f0             	pushl  -0x10(%ebp)
    1aca:	83 ec 04             	sub    $0x4,%esp
    1acd:	89 e0                	mov    %esp,%eax
    1acf:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1ad3:	66 89 10             	mov    %dx,(%eax)
    1ad6:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1ada:	88 50 02             	mov    %dl,0x2(%eax)
    1add:	ff 75 18             	pushl  0x18(%ebp)
    1ae0:	ff 75 14             	pushl  0x14(%ebp)
    1ae3:	ff 75 fc             	pushl  -0x4(%ebp)
    1ae6:	ff 75 f8             	pushl  -0x8(%ebp)
    1ae9:	ff 75 08             	pushl  0x8(%ebp)
    1aec:	e8 11 fe ff ff       	call   1902 <drawRect>
    1af1:	83 c4 20             	add    $0x20,%esp
}
    1af4:	90                   	nop
    1af5:	c9                   	leave  
    1af6:	c3                   	ret    

00001af7 <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1af7:	55                   	push   %ebp
    1af8:	89 e5                	mov    %esp,%ebp
    1afa:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1afd:	8b 45 30             	mov    0x30(%ebp),%eax
    1b00:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    1b03:	8b 45 34             	mov    0x34(%ebp),%eax
    1b06:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    1b09:	8b 55 20             	mov    0x20(%ebp),%edx
    1b0c:	8b 45 14             	mov    0x14(%ebp),%eax
    1b0f:	29 c2                	sub    %eax,%edx
    1b11:	89 d0                	mov    %edx,%eax
    1b13:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1b16:	7d 0d                	jge    1b25 <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    1b18:	8b 55 20             	mov    0x20(%ebp),%edx
    1b1b:	8b 45 14             	mov    0x14(%ebp),%eax
    1b1e:	29 c2                	sub    %eax,%edx
    1b20:	89 d0                	mov    %edx,%eax
    1b22:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1b25:	8b 55 28             	mov    0x28(%ebp),%edx
    1b28:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1b2b:	29 c2                	sub    %eax,%edx
    1b2d:	89 d0                	mov    %edx,%eax
    1b2f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1b32:	7d 0d                	jge    1b41 <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1b34:	8b 55 28             	mov    0x28(%ebp),%edx
    1b37:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1b3a:	29 c2                	sub    %eax,%edx
    1b3c:	89 d0                	mov    %edx,%eax
    1b3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1b41:	8b 55 24             	mov    0x24(%ebp),%edx
    1b44:	8b 45 10             	mov    0x10(%ebp),%eax
    1b47:	29 c2                	sub    %eax,%edx
    1b49:	89 d0                	mov    %edx,%eax
    1b4b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1b4e:	7d 0d                	jge    1b5d <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    1b50:	8b 55 24             	mov    0x24(%ebp),%edx
    1b53:	8b 45 10             	mov    0x10(%ebp),%eax
    1b56:	29 c2                	sub    %eax,%edx
    1b58:	89 d0                	mov    %edx,%eax
    1b5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1b5d:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1b60:	8b 45 18             	mov    0x18(%ebp),%eax
    1b63:	29 c2                	sub    %eax,%edx
    1b65:	89 d0                	mov    %edx,%eax
    1b67:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1b6a:	7d 0d                	jge    1b79 <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    1b6c:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1b6f:	8b 45 18             	mov    0x18(%ebp),%eax
    1b72:	29 c2                	sub    %eax,%edx
    1b74:	89 d0                	mov    %edx,%eax
    1b76:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1b79:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    1b80:	e9 83 00 00 00       	jmp    1c08 <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    1b85:	8b 55 14             	mov    0x14(%ebp),%edx
    1b88:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b8b:	01 d0                	add    %edx,%eax
    1b8d:	85 c0                	test   %eax,%eax
    1b8f:	78 72                	js     1c03 <drawBitmap+0x10c>
    1b91:	8b 55 14             	mov    0x14(%ebp),%edx
    1b94:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b97:	01 c2                	add    %eax,%edx
    1b99:	8b 45 20             	mov    0x20(%ebp),%eax
    1b9c:	39 c2                	cmp    %eax,%edx
    1b9e:	7d 63                	jge    1c03 <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    1ba0:	8b 55 14             	mov    0x14(%ebp),%edx
    1ba3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ba6:	01 c2                	add    %eax,%edx
    1ba8:	8b 45 24             	mov    0x24(%ebp),%eax
    1bab:	0f af c2             	imul   %edx,%eax
    1bae:	89 c2                	mov    %eax,%edx
    1bb0:	8b 45 10             	mov    0x10(%ebp),%eax
    1bb3:	01 c2                	add    %eax,%edx
    1bb5:	89 d0                	mov    %edx,%eax
    1bb7:	01 c0                	add    %eax,%eax
    1bb9:	01 c2                	add    %eax,%edx
    1bbb:	8b 45 08             	mov    0x8(%ebp),%eax
    1bbe:	01 d0                	add    %edx,%eax
    1bc0:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    1bc3:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1bc6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1bc9:	01 c2                	add    %eax,%edx
    1bcb:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1bce:	0f af c2             	imul   %edx,%eax
    1bd1:	89 c2                	mov    %eax,%edx
    1bd3:	8b 45 18             	mov    0x18(%ebp),%eax
    1bd6:	01 c2                	add    %eax,%edx
    1bd8:	89 d0                	mov    %edx,%eax
    1bda:	01 c0                	add    %eax,%eax
    1bdc:	01 c2                	add    %eax,%edx
    1bde:	8b 45 0c             	mov    0xc(%ebp),%eax
    1be1:	01 d0                	add    %edx,%eax
    1be3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    1be6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1be9:	89 d0                	mov    %edx,%eax
    1beb:	01 c0                	add    %eax,%eax
    1bed:	01 d0                	add    %edx,%eax
    1bef:	83 ec 04             	sub    $0x4,%esp
    1bf2:	50                   	push   %eax
    1bf3:	ff 75 e4             	pushl  -0x1c(%ebp)
    1bf6:	ff 75 e8             	pushl  -0x18(%ebp)
    1bf9:	e8 23 e7 ff ff       	call   321 <memmove>
    1bfe:	83 c4 10             	add    $0x10,%esp
    1c01:	eb 01                	jmp    1c04 <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    1c03:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1c04:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    1c08:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c0b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1c0e:	0f 8c 71 ff ff ff    	jl     1b85 <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    1c14:	90                   	nop
    1c15:	c9                   	leave  
    1c16:	c3                   	ret    

00001c17 <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1c17:	55                   	push   %ebp
    1c18:	89 e5                	mov    %esp,%ebp
    1c1a:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1c1d:	8b 45 30             	mov    0x30(%ebp),%eax
    1c20:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    1c23:	8b 45 34             	mov    0x34(%ebp),%eax
    1c26:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    1c29:	8b 55 20             	mov    0x20(%ebp),%edx
    1c2c:	8b 45 14             	mov    0x14(%ebp),%eax
    1c2f:	29 c2                	sub    %eax,%edx
    1c31:	89 d0                	mov    %edx,%eax
    1c33:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1c36:	7d 0d                	jge    1c45 <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    1c38:	8b 55 20             	mov    0x20(%ebp),%edx
    1c3b:	8b 45 14             	mov    0x14(%ebp),%eax
    1c3e:	29 c2                	sub    %eax,%edx
    1c40:	89 d0                	mov    %edx,%eax
    1c42:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1c45:	8b 55 28             	mov    0x28(%ebp),%edx
    1c48:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1c4b:	29 c2                	sub    %eax,%edx
    1c4d:	89 d0                	mov    %edx,%eax
    1c4f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1c52:	7d 0d                	jge    1c61 <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1c54:	8b 55 28             	mov    0x28(%ebp),%edx
    1c57:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1c5a:	29 c2                	sub    %eax,%edx
    1c5c:	89 d0                	mov    %edx,%eax
    1c5e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1c61:	8b 55 24             	mov    0x24(%ebp),%edx
    1c64:	8b 45 10             	mov    0x10(%ebp),%eax
    1c67:	29 c2                	sub    %eax,%edx
    1c69:	89 d0                	mov    %edx,%eax
    1c6b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1c6e:	7d 0d                	jge    1c7d <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    1c70:	8b 55 24             	mov    0x24(%ebp),%edx
    1c73:	8b 45 10             	mov    0x10(%ebp),%eax
    1c76:	29 c2                	sub    %eax,%edx
    1c78:	89 d0                	mov    %edx,%eax
    1c7a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1c7d:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1c80:	8b 45 18             	mov    0x18(%ebp),%eax
    1c83:	29 c2                	sub    %eax,%edx
    1c85:	89 d0                	mov    %edx,%eax
    1c87:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1c8a:	7d 0d                	jge    1c99 <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    1c8c:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1c8f:	8b 45 18             	mov    0x18(%ebp),%eax
    1c92:	29 c2                	sub    %eax,%edx
    1c94:	89 d0                	mov    %edx,%eax
    1c96:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    1c99:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1ca0:	e9 b8 00 00 00       	jmp    1d5d <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    1ca5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1cac:	e9 9c 00 00 00       	jmp    1d4d <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    1cb1:	8b 55 14             	mov    0x14(%ebp),%edx
    1cb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1cb7:	01 c2                	add    %eax,%edx
    1cb9:	8b 45 24             	mov    0x24(%ebp),%eax
    1cbc:	0f af c2             	imul   %edx,%eax
    1cbf:	89 c2                	mov    %eax,%edx
    1cc1:	8b 45 10             	mov    0x10(%ebp),%eax
    1cc4:	01 c2                	add    %eax,%edx
    1cc6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1cc9:	01 c2                	add    %eax,%edx
    1ccb:	89 d0                	mov    %edx,%eax
    1ccd:	01 c0                	add    %eax,%eax
    1ccf:	01 c2                	add    %eax,%edx
    1cd1:	8b 45 08             	mov    0x8(%ebp),%eax
    1cd4:	01 d0                	add    %edx,%eax
    1cd6:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    1cd9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1cdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1cdf:	01 c2                	add    %eax,%edx
    1ce1:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1ce4:	0f af c2             	imul   %edx,%eax
    1ce7:	89 c2                	mov    %eax,%edx
    1ce9:	8b 45 18             	mov    0x18(%ebp),%eax
    1cec:	01 c2                	add    %eax,%edx
    1cee:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1cf1:	01 c2                	add    %eax,%edx
    1cf3:	89 d0                	mov    %edx,%eax
    1cf5:	01 c0                	add    %eax,%eax
    1cf7:	01 c2                	add    %eax,%edx
    1cf9:	8b 45 0c             	mov    0xc(%ebp),%eax
    1cfc:	01 d0                	add    %edx,%eax
    1cfe:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    1d01:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d04:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1d08:	3c ff                	cmp    $0xff,%al
    1d0a:	75 15                	jne    1d21 <drawTransparentBitmap+0x10a>
    1d0c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d0f:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1d13:	3c ff                	cmp    $0xff,%al
    1d15:	75 0a                	jne    1d21 <drawTransparentBitmap+0x10a>
    1d17:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d1a:	0f b6 00             	movzbl (%eax),%eax
    1d1d:	3c ff                	cmp    $0xff,%al
    1d1f:	74 27                	je     1d48 <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    1d21:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d24:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    1d28:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d2b:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    1d2e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d31:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    1d35:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d38:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    1d3b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d3e:	0f b6 10             	movzbl (%eax),%edx
    1d41:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d44:	88 10                	mov    %dl,(%eax)
    1d46:	eb 01                	jmp    1d49 <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    1d48:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    1d49:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1d4d:	8b 45 34             	mov    0x34(%ebp),%eax
    1d50:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1d53:	0f 8f 58 ff ff ff    	jg     1cb1 <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    1d59:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1d5d:	8b 45 30             	mov    0x30(%ebp),%eax
    1d60:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1d63:	0f 8f 3c ff ff ff    	jg     1ca5 <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    1d69:	90                   	nop
    1d6a:	c9                   	leave  
    1d6b:	c3                   	ret    

00001d6c <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    1d6c:	55                   	push   %ebp
    1d6d:	89 e5                	mov    %esp,%ebp
    1d6f:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    1d72:	ff 75 24             	pushl  0x24(%ebp)
    1d75:	ff 75 20             	pushl  0x20(%ebp)
    1d78:	ff 75 1c             	pushl  0x1c(%ebp)
    1d7b:	ff 75 18             	pushl  0x18(%ebp)
    1d7e:	ff 75 1c             	pushl  0x1c(%ebp)
    1d81:	ff 75 18             	pushl  0x18(%ebp)
    1d84:	ff 75 14             	pushl  0x14(%ebp)
    1d87:	ff 75 10             	pushl  0x10(%ebp)
    1d8a:	ff 75 14             	pushl  0x14(%ebp)
    1d8d:	ff 75 10             	pushl  0x10(%ebp)
    1d90:	ff 75 0c             	pushl  0xc(%ebp)
    1d93:	ff 75 08             	pushl  0x8(%ebp)
    1d96:	e8 5c fd ff ff       	call   1af7 <drawBitmap>
    1d9b:	83 c4 30             	add    $0x30,%esp
}
    1d9e:	90                   	nop
    1d9f:	c9                   	leave  
    1da0:	c3                   	ret    

00001da1 <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    1da1:	55                   	push   %ebp
    1da2:	89 e5                	mov    %esp,%ebp
    1da4:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1da7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1daa:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1dad:	8b 45 20             	mov    0x20(%ebp),%eax
    1db0:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1db3:	8b 55 14             	mov    0x14(%ebp),%edx
    1db6:	8b 45 10             	mov    0x10(%ebp),%eax
    1db9:	29 c2                	sub    %eax,%edx
    1dbb:	89 d0                	mov    %edx,%eax
    1dbd:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1dc0:	7d 0d                	jge    1dcf <colorShift+0x2e>
        draw_h = s.h - p.y;
    1dc2:	8b 55 14             	mov    0x14(%ebp),%edx
    1dc5:	8b 45 10             	mov    0x10(%ebp),%eax
    1dc8:	29 c2                	sub    %eax,%edx
    1dca:	89 d0                	mov    %edx,%eax
    1dcc:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1dcf:	8b 55 18             	mov    0x18(%ebp),%edx
    1dd2:	8b 45 0c             	mov    0xc(%ebp),%eax
    1dd5:	29 c2                	sub    %eax,%edx
    1dd7:	89 d0                	mov    %edx,%eax
    1dd9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1ddc:	7d 0d                	jge    1deb <colorShift+0x4a>
        draw_w = s.w - p.x;
    1dde:	8b 55 18             	mov    0x18(%ebp),%edx
    1de1:	8b 45 0c             	mov    0xc(%ebp),%eax
    1de4:	29 c2                	sub    %eax,%edx
    1de6:	89 d0                	mov    %edx,%eax
    1de8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1deb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1df2:	e9 fc 00 00 00       	jmp    1ef3 <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    1df7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1dfe:	e9 e0 00 00 00       	jmp    1ee3 <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    1e03:	8b 55 10             	mov    0x10(%ebp),%edx
    1e06:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e09:	01 c2                	add    %eax,%edx
    1e0b:	8b 45 18             	mov    0x18(%ebp),%eax
    1e0e:	0f af c2             	imul   %edx,%eax
    1e11:	89 c2                	mov    %eax,%edx
    1e13:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e16:	01 c2                	add    %eax,%edx
    1e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e1b:	01 c2                	add    %eax,%edx
    1e1d:	89 d0                	mov    %edx,%eax
    1e1f:	01 c0                	add    %eax,%eax
    1e21:	01 c2                	add    %eax,%edx
    1e23:	8b 45 08             	mov    0x8(%ebp),%eax
    1e26:	01 d0                	add    %edx,%eax
    1e28:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    1e2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e2e:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1e32:	3c c8                	cmp    $0xc8,%al
    1e34:	0f 86 a5 00 00 00    	jbe    1edf <colorShift+0x13e>
    1e3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e3d:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1e41:	3c c8                	cmp    $0xc8,%al
    1e43:	0f 86 96 00 00 00    	jbe    1edf <colorShift+0x13e>
    1e49:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e4c:	0f b6 00             	movzbl (%eax),%eax
    1e4f:	3c c8                	cmp    $0xc8,%al
    1e51:	0f 86 88 00 00 00    	jbe    1edf <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    1e57:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e5a:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1e5e:	0f b6 d0             	movzbl %al,%edx
    1e61:	8b 45 24             	mov    0x24(%ebp),%eax
    1e64:	01 d0                	add    %edx,%eax
    1e66:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1e6c:	89 d0                	mov    %edx,%eax
    1e6e:	c1 f8 1f             	sar    $0x1f,%eax
    1e71:	c1 e8 18             	shr    $0x18,%eax
    1e74:	01 c2                	add    %eax,%edx
    1e76:	0f b6 d2             	movzbl %dl,%edx
    1e79:	29 c2                	sub    %eax,%edx
    1e7b:	89 d0                	mov    %edx,%eax
    1e7d:	89 c2                	mov    %eax,%edx
    1e7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e82:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    1e85:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e88:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1e8c:	0f b6 d0             	movzbl %al,%edx
    1e8f:	8b 45 24             	mov    0x24(%ebp),%eax
    1e92:	01 d0                	add    %edx,%eax
    1e94:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1e9a:	89 d0                	mov    %edx,%eax
    1e9c:	c1 f8 1f             	sar    $0x1f,%eax
    1e9f:	c1 e8 18             	shr    $0x18,%eax
    1ea2:	01 c2                	add    %eax,%edx
    1ea4:	0f b6 d2             	movzbl %dl,%edx
    1ea7:	29 c2                	sub    %eax,%edx
    1ea9:	89 d0                	mov    %edx,%eax
    1eab:	89 c2                	mov    %eax,%edx
    1ead:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1eb0:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    1eb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1eb6:	0f b6 00             	movzbl (%eax),%eax
    1eb9:	0f b6 d0             	movzbl %al,%edx
    1ebc:	8b 45 24             	mov    0x24(%ebp),%eax
    1ebf:	01 d0                	add    %edx,%eax
    1ec1:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1ec7:	89 d0                	mov    %edx,%eax
    1ec9:	c1 f8 1f             	sar    $0x1f,%eax
    1ecc:	c1 e8 18             	shr    $0x18,%eax
    1ecf:	01 c2                	add    %eax,%edx
    1ed1:	0f b6 d2             	movzbl %dl,%edx
    1ed4:	29 c2                	sub    %eax,%edx
    1ed6:	89 d0                	mov    %edx,%eax
    1ed8:	89 c2                	mov    %eax,%edx
    1eda:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1edd:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1edf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1ee3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1ee6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1ee9:	0f 8c 14 ff ff ff    	jl     1e03 <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1eef:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1ef3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1ef6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1ef9:	0f 8c f8 fe ff ff    	jl     1df7 <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    1eff:	90                   	nop
    1f00:	c9                   	leave  
    1f01:	c3                   	ret    

00001f02 <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    1f02:	55                   	push   %ebp
    1f03:	89 e5                	mov    %esp,%ebp
    1f05:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1f08:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1f0f:	e9 fb 00 00 00       	jmp    200f <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    1f14:	8b 55 14             	mov    0x14(%ebp),%edx
    1f17:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1f1a:	01 c2                	add    %eax,%edx
    1f1c:	0f b7 05 02 e8 01 00 	movzwl 0x1e802,%eax
    1f23:	0f b7 c0             	movzwl %ax,%eax
    1f26:	39 c2                	cmp    %eax,%edx
    1f28:	0f 8f eb 00 00 00    	jg     2019 <drawMouse+0x117>
    1f2e:	8b 55 14             	mov    0x14(%ebp),%edx
    1f31:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1f34:	01 d0                	add    %edx,%eax
    1f36:	85 c0                	test   %eax,%eax
    1f38:	0f 88 db 00 00 00    	js     2019 <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1f3e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1f45:	e9 b7 00 00 00       	jmp    2001 <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    1f4a:	8b 55 10             	mov    0x10(%ebp),%edx
    1f4d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1f50:	01 c2                	add    %eax,%edx
    1f52:	0f b7 05 00 e8 01 00 	movzwl 0x1e800,%eax
    1f59:	0f b7 c0             	movzwl %ax,%eax
    1f5c:	39 c2                	cmp    %eax,%edx
    1f5e:	0f 8f a7 00 00 00    	jg     200b <drawMouse+0x109>
    1f64:	8b 55 10             	mov    0x10(%ebp),%edx
    1f67:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1f6a:	01 d0                	add    %edx,%eax
    1f6c:	85 c0                	test   %eax,%eax
    1f6e:	0f 88 97 00 00 00    	js     200b <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    1f74:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1f77:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1f7a:	89 d0                	mov    %edx,%eax
    1f7c:	c1 e0 04             	shl    $0x4,%eax
    1f7f:	29 d0                	sub    %edx,%eax
    1f81:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    1f87:	01 c2                	add    %eax,%edx
    1f89:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1f8c:	01 d0                	add    %edx,%eax
    1f8e:	05 00 5f 01 00       	add    $0x15f00,%eax
    1f93:	0f b6 00             	movzbl (%eax),%eax
    1f96:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    1f99:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    1f9d:	74 5e                	je     1ffd <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    1f9f:	8b 55 14             	mov    0x14(%ebp),%edx
    1fa2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1fa5:	01 c2                	add    %eax,%edx
    1fa7:	0f b7 05 00 e8 01 00 	movzwl 0x1e800,%eax
    1fae:	0f b7 c0             	movzwl %ax,%eax
    1fb1:	0f af c2             	imul   %edx,%eax
    1fb4:	89 c2                	mov    %eax,%edx
    1fb6:	8b 45 10             	mov    0x10(%ebp),%eax
    1fb9:	01 c2                	add    %eax,%edx
    1fbb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1fbe:	01 c2                	add    %eax,%edx
    1fc0:	89 d0                	mov    %edx,%eax
    1fc2:	01 c0                	add    %eax,%eax
    1fc4:	01 c2                	add    %eax,%edx
    1fc6:	8b 45 08             	mov    0x8(%ebp),%eax
    1fc9:	01 d0                	add    %edx,%eax
    1fcb:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    1fce:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    1fd2:	8d 50 ff             	lea    -0x1(%eax),%edx
    1fd5:	89 d0                	mov    %edx,%eax
    1fd7:	01 c0                	add    %eax,%eax
    1fd9:	01 d0                	add    %edx,%eax
    1fdb:	05 08 e8 01 00       	add    $0x1e808,%eax
    1fe0:	83 ec 04             	sub    $0x4,%esp
    1fe3:	89 e2                	mov    %esp,%edx
    1fe5:	0f b7 08             	movzwl (%eax),%ecx
    1fe8:	66 89 0a             	mov    %cx,(%edx)
    1feb:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1fef:	88 42 02             	mov    %al,0x2(%edx)
    1ff2:	ff 75 f0             	pushl  -0x10(%ebp)
    1ff5:	e8 73 f6 ff ff       	call   166d <drawPoint>
    1ffa:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1ffd:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2001:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    2005:	0f 8e 3f ff ff ff    	jle    1f4a <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    200b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    200f:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    2013:	0f 8e fb fe ff ff    	jle    1f14 <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    2019:	90                   	nop
    201a:	c9                   	leave  
    201b:	c3                   	ret    

0000201c <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    201c:	55                   	push   %ebp
    201d:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    201f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    2023:	78 1b                	js     2040 <getColor+0x24>
    2025:	8b 45 08             	mov    0x8(%ebp),%eax
    2028:	8b 40 04             	mov    0x4(%eax),%eax
    202b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    202e:	7c 10                	jl     2040 <getColor+0x24>
    2030:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    2034:	78 0a                	js     2040 <getColor+0x24>
    2036:	8b 45 08             	mov    0x8(%ebp),%eax
    2039:	8b 00                	mov    (%eax),%eax
    203b:	3b 45 10             	cmp    0x10(%ebp),%eax
    203e:	7d 10                	jge    2050 <getColor+0x34>
    {
        *isInPic = 1;
    2040:	8b 45 14             	mov    0x14(%ebp),%eax
    2043:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    2049:	b8 b1 e1 01 00       	mov    $0x1e1b1,%eax
    204e:	eb 44                	jmp    2094 <getColor+0x78>
    }

    if (y == pic->height)
    2050:	8b 45 08             	mov    0x8(%ebp),%eax
    2053:	8b 40 04             	mov    0x4(%eax),%eax
    2056:	3b 45 0c             	cmp    0xc(%ebp),%eax
    2059:	75 04                	jne    205f <getColor+0x43>
        y--;
    205b:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    205f:	8b 45 08             	mov    0x8(%ebp),%eax
    2062:	8b 00                	mov    (%eax),%eax
    2064:	3b 45 10             	cmp    0x10(%ebp),%eax
    2067:	75 04                	jne    206d <getColor+0x51>
        x--;
    2069:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    206d:	8b 45 14             	mov    0x14(%ebp),%eax
    2070:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    2076:	8b 45 08             	mov    0x8(%ebp),%eax
    2079:	8b 48 08             	mov    0x8(%eax),%ecx
    207c:	8b 45 08             	mov    0x8(%ebp),%eax
    207f:	8b 00                	mov    (%eax),%eax
    2081:	0f af 45 0c          	imul   0xc(%ebp),%eax
    2085:	89 c2                	mov    %eax,%edx
    2087:	8b 45 10             	mov    0x10(%ebp),%eax
    208a:	01 c2                	add    %eax,%edx
    208c:	89 d0                	mov    %edx,%eax
    208e:	01 c0                	add    %eax,%eax
    2090:	01 d0                	add    %edx,%eax
    2092:	01 c8                	add    %ecx,%eax
}
    2094:	5d                   	pop    %ebp
    2095:	c3                   	ret    

00002096 <setColor>:

int setColor(RGB *src, RGB *dst)
{
    2096:	55                   	push   %ebp
    2097:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    2099:	8b 45 08             	mov    0x8(%ebp),%eax
    209c:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    20a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    20a3:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    20a6:	8b 45 08             	mov    0x8(%ebp),%eax
    20a9:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    20ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    20b0:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    20b3:	8b 45 08             	mov    0x8(%ebp),%eax
    20b6:	0f b6 10             	movzbl (%eax),%edx
    20b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    20bc:	88 10                	mov    %dl,(%eax)

    return 1;
    20be:	b8 01 00 00 00       	mov    $0x1,%eax
}
    20c3:	5d                   	pop    %ebp
    20c4:	c3                   	ret    

000020c5 <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    20c5:	55                   	push   %ebp
    20c6:	89 e5                	mov    %esp,%ebp
    20c8:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    20cb:	d9 45 10             	flds   0x10(%ebp)
    20ce:	d9 7d be             	fnstcw -0x42(%ebp)
    20d1:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    20d5:	b4 0c                	mov    $0xc,%ah
    20d7:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    20db:	d9 6d bc             	fldcw  -0x44(%ebp)
    20de:	db 5d fc             	fistpl -0x4(%ebp)
    20e1:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    20e4:	d9 45 0c             	flds   0xc(%ebp)
    20e7:	d9 6d bc             	fldcw  -0x44(%ebp)
    20ea:	db 5d f8             	fistpl -0x8(%ebp)
    20ed:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    20f0:	db 45 fc             	fildl  -0x4(%ebp)
    20f3:	d9 45 10             	flds   0x10(%ebp)
    20f6:	d9 c9                	fxch   %st(1)
    20f8:	df e9                	fucomip %st(1),%st
    20fa:	dd d8                	fstp   %st(0)
    20fc:	76 04                	jbe    2102 <mixColor+0x3d>
        x--;
    20fe:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    2102:	db 45 f8             	fildl  -0x8(%ebp)
    2105:	d9 45 0c             	flds   0xc(%ebp)
    2108:	d9 c9                	fxch   %st(1)
    210a:	df e9                	fucomip %st(1),%st
    210c:	dd d8                	fstp   %st(0)
    210e:	76 04                	jbe    2114 <mixColor+0x4f>
        y--;
    2110:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2114:	8d 45 c0             	lea    -0x40(%ebp),%eax
    2117:	50                   	push   %eax
    2118:	ff 75 fc             	pushl  -0x4(%ebp)
    211b:	ff 75 f8             	pushl  -0x8(%ebp)
    211e:	ff 75 08             	pushl  0x8(%ebp)
    2121:	e8 f6 fe ff ff       	call   201c <getColor>
    2126:	83 c4 10             	add    $0x10,%esp
    2129:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    212c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    212f:	83 c0 01             	add    $0x1,%eax
    2132:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2135:	83 c2 04             	add    $0x4,%edx
    2138:	52                   	push   %edx
    2139:	ff 75 fc             	pushl  -0x4(%ebp)
    213c:	50                   	push   %eax
    213d:	ff 75 08             	pushl  0x8(%ebp)
    2140:	e8 d7 fe ff ff       	call   201c <getColor>
    2145:	83 c4 10             	add    $0x10,%esp
    2148:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    214b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    214e:	83 c0 01             	add    $0x1,%eax
    2151:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2154:	83 c2 08             	add    $0x8,%edx
    2157:	52                   	push   %edx
    2158:	50                   	push   %eax
    2159:	ff 75 f8             	pushl  -0x8(%ebp)
    215c:	ff 75 08             	pushl  0x8(%ebp)
    215f:	e8 b8 fe ff ff       	call   201c <getColor>
    2164:	83 c4 10             	add    $0x10,%esp
    2167:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    216a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    216d:	8d 50 01             	lea    0x1(%eax),%edx
    2170:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2173:	83 c0 01             	add    $0x1,%eax
    2176:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    2179:	83 c1 0c             	add    $0xc,%ecx
    217c:	51                   	push   %ecx
    217d:	52                   	push   %edx
    217e:	50                   	push   %eax
    217f:	ff 75 08             	pushl  0x8(%ebp)
    2182:	e8 95 fe ff ff       	call   201c <getColor>
    2187:	83 c4 10             	add    $0x10,%esp
    218a:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    218d:	db 45 fc             	fildl  -0x4(%ebp)
    2190:	d9 45 10             	flds   0x10(%ebp)
    2193:	de e1                	fsubp  %st,%st(1)
    2195:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    2198:	db 45 f8             	fildl  -0x8(%ebp)
    219b:	d9 45 0c             	flds   0xc(%ebp)
    219e:	de e1                	fsubp  %st,%st(1)
    21a0:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    21a3:	d9 45 e4             	flds   -0x1c(%ebp)
    21a6:	d8 4d e0             	fmuls  -0x20(%ebp)
    21a9:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    21ac:	d9 e8                	fld1   
    21ae:	d8 65 e0             	fsubs  -0x20(%ebp)
    21b1:	d8 4d e4             	fmuls  -0x1c(%ebp)
    21b4:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    21b7:	d9 e8                	fld1   
    21b9:	d8 65 e4             	fsubs  -0x1c(%ebp)
    21bc:	d8 4d e0             	fmuls  -0x20(%ebp)
    21bf:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    21c2:	d9 e8                	fld1   
    21c4:	d8 65 e4             	fsubs  -0x1c(%ebp)
    21c7:	d9 e8                	fld1   
    21c9:	d8 65 e0             	fsubs  -0x20(%ebp)
    21cc:	de c9                	fmulp  %st,%st(1)
    21ce:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    21d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    21d4:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    21d8:	0f b6 c0             	movzbl %al,%eax
    21db:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21de:	db 45 b4             	fildl  -0x4c(%ebp)
    21e1:	d8 4d d0             	fmuls  -0x30(%ebp)
    21e4:	8b 45 c0             	mov    -0x40(%ebp),%eax
    21e7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21ea:	db 45 b4             	fildl  -0x4c(%ebp)
    21ed:	de c9                	fmulp  %st,%st(1)
    21ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
    21f2:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    21f6:	0f b6 c0             	movzbl %al,%eax
    21f9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21fc:	db 45 b4             	fildl  -0x4c(%ebp)
    21ff:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2202:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2205:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2208:	db 45 b4             	fildl  -0x4c(%ebp)
    220b:	de c9                	fmulp  %st,%st(1)
    220d:	de c1                	faddp  %st,%st(1)
    220f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2212:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2216:	0f b6 c0             	movzbl %al,%eax
    2219:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    221c:	db 45 b4             	fildl  -0x4c(%ebp)
    221f:	d8 4d d8             	fmuls  -0x28(%ebp)
    2222:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2225:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2228:	db 45 b4             	fildl  -0x4c(%ebp)
    222b:	de c9                	fmulp  %st,%st(1)
    222d:	de c1                	faddp  %st,%st(1)
    222f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2232:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2236:	0f b6 c0             	movzbl %al,%eax
    2239:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    223c:	db 45 b4             	fildl  -0x4c(%ebp)
    223f:	d8 4d dc             	fmuls  -0x24(%ebp)
    2242:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2245:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2248:	db 45 b4             	fildl  -0x4c(%ebp)
    224b:	de c9                	fmulp  %st,%st(1)
    224d:	de c1                	faddp  %st,%st(1)
    224f:	d9 7d be             	fnstcw -0x42(%ebp)
    2252:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    2256:	b4 0c                	mov    $0xc,%ah
    2258:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    225c:	d9 6d bc             	fldcw  -0x44(%ebp)
    225f:	db 5d b8             	fistpl -0x48(%ebp)
    2262:	d9 6d be             	fldcw  -0x42(%ebp)
    2265:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2268:	89 c2                	mov    %eax,%edx
    226a:	8b 45 14             	mov    0x14(%ebp),%eax
    226d:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    2270:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2273:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2277:	0f b6 c0             	movzbl %al,%eax
    227a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    227d:	db 45 b4             	fildl  -0x4c(%ebp)
    2280:	d8 4d d0             	fmuls  -0x30(%ebp)
    2283:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2286:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2289:	db 45 b4             	fildl  -0x4c(%ebp)
    228c:	de c9                	fmulp  %st,%st(1)
    228e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2291:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2295:	0f b6 c0             	movzbl %al,%eax
    2298:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    229b:	db 45 b4             	fildl  -0x4c(%ebp)
    229e:	d8 4d d4             	fmuls  -0x2c(%ebp)
    22a1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    22a4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22a7:	db 45 b4             	fildl  -0x4c(%ebp)
    22aa:	de c9                	fmulp  %st,%st(1)
    22ac:	de c1                	faddp  %st,%st(1)
    22ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
    22b1:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    22b5:	0f b6 c0             	movzbl %al,%eax
    22b8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22bb:	db 45 b4             	fildl  -0x4c(%ebp)
    22be:	d8 4d d8             	fmuls  -0x28(%ebp)
    22c1:	8b 45 c8             	mov    -0x38(%ebp),%eax
    22c4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22c7:	db 45 b4             	fildl  -0x4c(%ebp)
    22ca:	de c9                	fmulp  %st,%st(1)
    22cc:	de c1                	faddp  %st,%st(1)
    22ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
    22d1:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    22d5:	0f b6 c0             	movzbl %al,%eax
    22d8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22db:	db 45 b4             	fildl  -0x4c(%ebp)
    22de:	d8 4d dc             	fmuls  -0x24(%ebp)
    22e1:	8b 45 cc             	mov    -0x34(%ebp),%eax
    22e4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22e7:	db 45 b4             	fildl  -0x4c(%ebp)
    22ea:	de c9                	fmulp  %st,%st(1)
    22ec:	de c1                	faddp  %st,%st(1)
    22ee:	d9 6d bc             	fldcw  -0x44(%ebp)
    22f1:	db 5d b8             	fistpl -0x48(%ebp)
    22f4:	d9 6d be             	fldcw  -0x42(%ebp)
    22f7:	8b 45 b8             	mov    -0x48(%ebp),%eax
    22fa:	89 c2                	mov    %eax,%edx
    22fc:	8b 45 14             	mov    0x14(%ebp),%eax
    22ff:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    2302:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2305:	0f b6 00             	movzbl (%eax),%eax
    2308:	0f b6 c0             	movzbl %al,%eax
    230b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    230e:	db 45 b4             	fildl  -0x4c(%ebp)
    2311:	d8 4d d0             	fmuls  -0x30(%ebp)
    2314:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2317:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    231a:	db 45 b4             	fildl  -0x4c(%ebp)
    231d:	de c9                	fmulp  %st,%st(1)
    231f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2322:	0f b6 00             	movzbl (%eax),%eax
    2325:	0f b6 c0             	movzbl %al,%eax
    2328:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    232b:	db 45 b4             	fildl  -0x4c(%ebp)
    232e:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2331:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2334:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2337:	db 45 b4             	fildl  -0x4c(%ebp)
    233a:	de c9                	fmulp  %st,%st(1)
    233c:	de c1                	faddp  %st,%st(1)
    233e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2341:	0f b6 00             	movzbl (%eax),%eax
    2344:	0f b6 c0             	movzbl %al,%eax
    2347:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    234a:	db 45 b4             	fildl  -0x4c(%ebp)
    234d:	d8 4d d8             	fmuls  -0x28(%ebp)
    2350:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2353:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2356:	db 45 b4             	fildl  -0x4c(%ebp)
    2359:	de c9                	fmulp  %st,%st(1)
    235b:	de c1                	faddp  %st,%st(1)
    235d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2360:	0f b6 00             	movzbl (%eax),%eax
    2363:	0f b6 c0             	movzbl %al,%eax
    2366:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2369:	db 45 b4             	fildl  -0x4c(%ebp)
    236c:	d8 4d dc             	fmuls  -0x24(%ebp)
    236f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2372:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2375:	db 45 b4             	fildl  -0x4c(%ebp)
    2378:	de c9                	fmulp  %st,%st(1)
    237a:	de c1                	faddp  %st,%st(1)
    237c:	d9 6d bc             	fldcw  -0x44(%ebp)
    237f:	db 5d b8             	fistpl -0x48(%ebp)
    2382:	d9 6d be             	fldcw  -0x42(%ebp)
    2385:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2388:	89 c2                	mov    %eax,%edx
    238a:	8b 45 14             	mov    0x14(%ebp),%eax
    238d:	88 10                	mov    %dl,(%eax)

    return 1;
    238f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2394:	c9                   	leave  
    2395:	c3                   	ret    

00002396 <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    2396:	55                   	push   %ebp
    2397:	89 e5                	mov    %esp,%ebp
    2399:	53                   	push   %ebx
    239a:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    239d:	8b 45 10             	mov    0x10(%ebp),%eax
    23a0:	c1 f8 10             	sar    $0x10,%eax
    23a3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    23a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    23a9:	c1 f8 10             	sar    $0x10,%eax
    23ac:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    23af:	8d 45 bc             	lea    -0x44(%ebp),%eax
    23b2:	50                   	push   %eax
    23b3:	ff 75 f8             	pushl  -0x8(%ebp)
    23b6:	ff 75 f4             	pushl  -0xc(%ebp)
    23b9:	ff 75 08             	pushl  0x8(%ebp)
    23bc:	e8 5b fc ff ff       	call   201c <getColor>
    23c1:	83 c4 10             	add    $0x10,%esp
    23c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    23c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    23ca:	83 c0 01             	add    $0x1,%eax
    23cd:	8d 55 bc             	lea    -0x44(%ebp),%edx
    23d0:	83 c2 04             	add    $0x4,%edx
    23d3:	52                   	push   %edx
    23d4:	ff 75 f8             	pushl  -0x8(%ebp)
    23d7:	50                   	push   %eax
    23d8:	ff 75 08             	pushl  0x8(%ebp)
    23db:	e8 3c fc ff ff       	call   201c <getColor>
    23e0:	83 c4 10             	add    $0x10,%esp
    23e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    23e6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    23e9:	83 c0 01             	add    $0x1,%eax
    23ec:	8d 55 bc             	lea    -0x44(%ebp),%edx
    23ef:	83 c2 08             	add    $0x8,%edx
    23f2:	52                   	push   %edx
    23f3:	50                   	push   %eax
    23f4:	ff 75 f4             	pushl  -0xc(%ebp)
    23f7:	ff 75 08             	pushl  0x8(%ebp)
    23fa:	e8 1d fc ff ff       	call   201c <getColor>
    23ff:	83 c4 10             	add    $0x10,%esp
    2402:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    2405:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2408:	8d 50 01             	lea    0x1(%eax),%edx
    240b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    240e:	83 c0 01             	add    $0x1,%eax
    2411:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    2414:	83 c1 0c             	add    $0xc,%ecx
    2417:	51                   	push   %ecx
    2418:	52                   	push   %edx
    2419:	50                   	push   %eax
    241a:	ff 75 08             	pushl  0x8(%ebp)
    241d:	e8 fa fb ff ff       	call   201c <getColor>
    2422:	83 c4 10             	add    $0x10,%esp
    2425:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    2428:	8b 45 10             	mov    0x10(%ebp),%eax
    242b:	0f b7 c0             	movzwl %ax,%eax
    242e:	c1 f8 08             	sar    $0x8,%eax
    2431:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    2434:	8b 45 0c             	mov    0xc(%ebp),%eax
    2437:	0f b7 c0             	movzwl %ax,%eax
    243a:	c1 f8 08             	sar    $0x8,%eax
    243d:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    2440:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2443:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    2447:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    244a:	b8 ff 00 00 00       	mov    $0xff,%eax
    244f:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2452:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    2456:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    2459:	b8 ff 00 00 00       	mov    $0xff,%eax
    245e:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2461:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    2465:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    2468:	b8 ff 00 00 00       	mov    $0xff,%eax
    246d:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2470:	89 c2                	mov    %eax,%edx
    2472:	b8 ff 00 00 00       	mov    $0xff,%eax
    2477:	2b 45 dc             	sub    -0x24(%ebp),%eax
    247a:	0f af c2             	imul   %edx,%eax
    247d:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    2480:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2483:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2487:	0f b6 c0             	movzbl %al,%eax
    248a:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    248e:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2491:	0f af d0             	imul   %eax,%edx
    2494:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2497:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    249b:	0f b6 c0             	movzbl %al,%eax
    249e:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    24a2:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    24a5:	0f af c1             	imul   %ecx,%eax
    24a8:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    24ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    24ae:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    24b2:	0f b6 c0             	movzbl %al,%eax
    24b5:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    24b9:	8b 55 c8             	mov    -0x38(%ebp),%edx
    24bc:	0f af d0             	imul   %eax,%edx
    24bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    24c2:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    24c6:	0f b6 c0             	movzbl %al,%eax
    24c9:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    24cd:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    24d0:	0f af c1             	imul   %ecx,%eax
    24d3:	01 d0                	add    %edx,%eax
    24d5:	01 d8                	add    %ebx,%eax
    24d7:	c1 e8 10             	shr    $0x10,%eax
    24da:	89 c2                	mov    %eax,%edx
    24dc:	8b 45 14             	mov    0x14(%ebp),%eax
    24df:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    24e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    24e5:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    24e9:	0f b6 c0             	movzbl %al,%eax
    24ec:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    24f0:	8b 55 bc             	mov    -0x44(%ebp),%edx
    24f3:	0f af d0             	imul   %eax,%edx
    24f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24f9:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    24fd:	0f b6 c0             	movzbl %al,%eax
    2500:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2504:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2507:	0f af c1             	imul   %ecx,%eax
    250a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    250d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2510:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2514:	0f b6 c0             	movzbl %al,%eax
    2517:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    251b:	8b 55 c8             	mov    -0x38(%ebp),%edx
    251e:	0f af d0             	imul   %eax,%edx
    2521:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2524:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2528:	0f b6 c0             	movzbl %al,%eax
    252b:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    252f:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2532:	0f af c1             	imul   %ecx,%eax
    2535:	01 d0                	add    %edx,%eax
    2537:	01 d8                	add    %ebx,%eax
    2539:	c1 e8 10             	shr    $0x10,%eax
    253c:	89 c2                	mov    %eax,%edx
    253e:	8b 45 14             	mov    0x14(%ebp),%eax
    2541:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    2544:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2547:	0f b6 00             	movzbl (%eax),%eax
    254a:	0f b6 c0             	movzbl %al,%eax
    254d:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2551:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2554:	0f af d0             	imul   %eax,%edx
    2557:	8b 45 ec             	mov    -0x14(%ebp),%eax
    255a:	0f b6 00             	movzbl (%eax),%eax
    255d:	0f b6 c0             	movzbl %al,%eax
    2560:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2564:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2567:	0f af c1             	imul   %ecx,%eax
    256a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    256d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2570:	0f b6 00             	movzbl (%eax),%eax
    2573:	0f b6 c0             	movzbl %al,%eax
    2576:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    257a:	8b 55 c8             	mov    -0x38(%ebp),%edx
    257d:	0f af d0             	imul   %eax,%edx
    2580:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2583:	0f b6 00             	movzbl (%eax),%eax
    2586:	0f b6 c0             	movzbl %al,%eax
    2589:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    258d:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2590:	0f af c1             	imul   %ecx,%eax
    2593:	01 d0                	add    %edx,%eax
    2595:	01 d8                	add    %ebx,%eax
    2597:	c1 e8 10             	shr    $0x10,%eax
    259a:	89 c2                	mov    %eax,%edx
    259c:	8b 45 14             	mov    0x14(%ebp),%eax
    259f:	88 10                	mov    %dl,(%eax)
}
    25a1:	90                   	nop
    25a2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    25a5:	c9                   	leave  
    25a6:	c3                   	ret    

000025a7 <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    25a7:	55                   	push   %ebp
    25a8:	89 e5                	mov    %esp,%ebp
    25aa:	53                   	push   %ebx
    25ab:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    25ae:	8b 45 08             	mov    0x8(%ebp),%eax
    25b1:	8b 00                	mov    (%eax),%eax
    25b3:	c1 e0 10             	shl    $0x10,%eax
    25b6:	89 c1                	mov    %eax,%ecx
    25b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    25bb:	8b 18                	mov    (%eax),%ebx
    25bd:	89 c8                	mov    %ecx,%eax
    25bf:	99                   	cltd   
    25c0:	f7 fb                	idiv   %ebx
    25c2:	83 c0 01             	add    $0x1,%eax
    25c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    25c8:	8b 45 08             	mov    0x8(%ebp),%eax
    25cb:	8b 40 04             	mov    0x4(%eax),%eax
    25ce:	c1 e0 10             	shl    $0x10,%eax
    25d1:	89 c1                	mov    %eax,%ecx
    25d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    25d6:	8b 58 04             	mov    0x4(%eax),%ebx
    25d9:	89 c8                	mov    %ecx,%eax
    25db:	99                   	cltd   
    25dc:	f7 fb                	idiv   %ebx
    25de:	83 c0 01             	add    $0x1,%eax
    25e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    25e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    25e7:	d1 f8                	sar    %eax
    25e9:	2d 00 80 00 00       	sub    $0x8000,%eax
    25ee:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    25f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    25f4:	d1 f8                	sar    %eax
    25f6:	2d 00 80 00 00       	sub    $0x8000,%eax
    25fb:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    25fe:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2601:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    2604:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    260b:	eb 5d                	jmp    266a <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    260d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2610:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    2613:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    261a:	eb 3a                	jmp    2656 <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    261c:	8b 45 0c             	mov    0xc(%ebp),%eax
    261f:	8b 48 08             	mov    0x8(%eax),%ecx
    2622:	8b 45 0c             	mov    0xc(%ebp),%eax
    2625:	8b 00                	mov    (%eax),%eax
    2627:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    262b:	89 c2                	mov    %eax,%edx
    262d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2630:	01 c2                	add    %eax,%edx
    2632:	89 d0                	mov    %edx,%eax
    2634:	01 c0                	add    %eax,%eax
    2636:	01 d0                	add    %edx,%eax
    2638:	01 c8                	add    %ecx,%eax
    263a:	50                   	push   %eax
    263b:	ff 75 f0             	pushl  -0x10(%ebp)
    263e:	ff 75 f8             	pushl  -0x8(%ebp)
    2641:	ff 75 08             	pushl  0x8(%ebp)
    2644:	e8 4d fd ff ff       	call   2396 <mixColorInt>
    2649:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    264c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    264f:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    2652:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    2656:	8b 45 0c             	mov    0xc(%ebp),%eax
    2659:	8b 00                	mov    (%eax),%eax
    265b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    265e:	7f bc                	jg     261c <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    2660:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2663:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    2666:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    266a:	8b 45 0c             	mov    0xc(%ebp),%eax
    266d:	8b 40 04             	mov    0x4(%eax),%eax
    2670:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2673:	7f 98                	jg     260d <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    2675:	b8 01 00 00 00       	mov    $0x1,%eax
}
    267a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    267d:	c9                   	leave  
    267e:	c3                   	ret    

0000267f <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    267f:	55                   	push   %ebp
    2680:	89 e5                	mov    %esp,%ebp
    2682:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    2685:	8b 45 08             	mov    0x8(%ebp),%eax
    2688:	8b 00                	mov    (%eax),%eax
    268a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    268d:	db 45 e4             	fildl  -0x1c(%ebp)
    2690:	8b 45 0c             	mov    0xc(%ebp),%eax
    2693:	8b 00                	mov    (%eax),%eax
    2695:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2698:	db 45 e4             	fildl  -0x1c(%ebp)
    269b:	de f9                	fdivrp %st,%st(1)
    269d:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    26a0:	8b 45 08             	mov    0x8(%ebp),%eax
    26a3:	8b 40 04             	mov    0x4(%eax),%eax
    26a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    26a9:	db 45 e4             	fildl  -0x1c(%ebp)
    26ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    26af:	8b 40 04             	mov    0x4(%eax),%eax
    26b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    26b5:	db 45 e4             	fildl  -0x1c(%ebp)
    26b8:	de f9                	fdivrp %st,%st(1)
    26ba:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    26bd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    26c4:	eb 5e                	jmp    2724 <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    26c6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    26cd:	eb 47                	jmp    2716 <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    26cf:	db 45 f8             	fildl  -0x8(%ebp)
    26d2:	d8 4d f4             	fmuls  -0xc(%ebp)
    26d5:	d9 7d ee             	fnstcw -0x12(%ebp)
    26d8:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    26dc:	b4 0c                	mov    $0xc,%ah
    26de:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    26e2:	d9 6d ec             	fldcw  -0x14(%ebp)
    26e5:	db 5d e8             	fistpl -0x18(%ebp)
    26e8:	d9 6d ee             	fldcw  -0x12(%ebp)
    26eb:	8b 55 e8             	mov    -0x18(%ebp),%edx
    26ee:	db 45 fc             	fildl  -0x4(%ebp)
    26f1:	d8 4d f0             	fmuls  -0x10(%ebp)
    26f4:	d9 6d ec             	fldcw  -0x14(%ebp)
    26f7:	db 5d e8             	fistpl -0x18(%ebp)
    26fa:	d9 6d ee             	fldcw  -0x12(%ebp)
    26fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2700:	6a 00                	push   $0x0
    2702:	52                   	push   %edx
    2703:	50                   	push   %eax
    2704:	ff 75 08             	pushl  0x8(%ebp)
    2707:	e8 10 f9 ff ff       	call   201c <getColor>
    270c:	83 c4 10             	add    $0x10,%esp
    270f:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    2712:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2716:	8b 45 0c             	mov    0xc(%ebp),%eax
    2719:	8b 00                	mov    (%eax),%eax
    271b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    271e:	7f af                	jg     26cf <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    2720:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2724:	8b 45 0c             	mov    0xc(%ebp),%eax
    2727:	8b 40 04             	mov    0x4(%eax),%eax
    272a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    272d:	7f 97                	jg     26c6 <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    272f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2734:	c9                   	leave  
    2735:	c3                   	ret    

00002736 <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    2736:	55                   	push   %ebp
    2737:	89 e5                	mov    %esp,%ebp
    2739:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    273c:	8b 45 08             	mov    0x8(%ebp),%eax
    273f:	8b 00                	mov    (%eax),%eax
    2741:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2744:	db 45 e0             	fildl  -0x20(%ebp)
    2747:	d9 5d e0             	fstps  -0x20(%ebp)
    274a:	83 ec 0c             	sub    $0xc,%esp
    274d:	ff 75 10             	pushl  0x10(%ebp)
    2750:	e8 6b e2 ff ff       	call   9c0 <cos>
    2755:	83 c4 10             	add    $0x10,%esp
    2758:	d9 5d dc             	fstps  -0x24(%ebp)
    275b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    275e:	83 ec 0c             	sub    $0xc,%esp
    2761:	50                   	push   %eax
    2762:	e8 90 e1 ff ff       	call   8f7 <abs>
    2767:	83 c4 10             	add    $0x10,%esp
    276a:	d8 4d e0             	fmuls  -0x20(%ebp)
    276d:	d9 5d e0             	fstps  -0x20(%ebp)
    2770:	8b 45 0c             	mov    0xc(%ebp),%eax
    2773:	8b 00                	mov    (%eax),%eax
    2775:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2778:	db 45 dc             	fildl  -0x24(%ebp)
    277b:	d9 5d dc             	fstps  -0x24(%ebp)
    277e:	83 ec 0c             	sub    $0xc,%esp
    2781:	ff 75 10             	pushl  0x10(%ebp)
    2784:	e8 da e3 ff ff       	call   b63 <sin>
    2789:	83 c4 10             	add    $0x10,%esp
    278c:	d9 5d d8             	fstps  -0x28(%ebp)
    278f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2792:	83 ec 0c             	sub    $0xc,%esp
    2795:	50                   	push   %eax
    2796:	e8 5c e1 ff ff       	call   8f7 <abs>
    279b:	83 c4 10             	add    $0x10,%esp
    279e:	d8 4d dc             	fmuls  -0x24(%ebp)
    27a1:	d8 45 e0             	fadds  -0x20(%ebp)
    27a4:	d9 7d e6             	fnstcw -0x1a(%ebp)
    27a7:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    27ab:	b4 0c                	mov    $0xc,%ah
    27ad:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    27b1:	d9 6d e4             	fldcw  -0x1c(%ebp)
    27b4:	db 5d f4             	fistpl -0xc(%ebp)
    27b7:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    27ba:	8b 45 08             	mov    0x8(%ebp),%eax
    27bd:	8b 00                	mov    (%eax),%eax
    27bf:	89 45 e0             	mov    %eax,-0x20(%ebp)
    27c2:	db 45 e0             	fildl  -0x20(%ebp)
    27c5:	d9 5d e0             	fstps  -0x20(%ebp)
    27c8:	83 ec 0c             	sub    $0xc,%esp
    27cb:	ff 75 10             	pushl  0x10(%ebp)
    27ce:	e8 90 e3 ff ff       	call   b63 <sin>
    27d3:	83 c4 10             	add    $0x10,%esp
    27d6:	d9 5d dc             	fstps  -0x24(%ebp)
    27d9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    27dc:	83 ec 0c             	sub    $0xc,%esp
    27df:	50                   	push   %eax
    27e0:	e8 12 e1 ff ff       	call   8f7 <abs>
    27e5:	83 c4 10             	add    $0x10,%esp
    27e8:	d8 4d e0             	fmuls  -0x20(%ebp)
    27eb:	d9 5d e0             	fstps  -0x20(%ebp)
    27ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    27f1:	8b 00                	mov    (%eax),%eax
    27f3:	89 45 dc             	mov    %eax,-0x24(%ebp)
    27f6:	db 45 dc             	fildl  -0x24(%ebp)
    27f9:	d9 5d dc             	fstps  -0x24(%ebp)
    27fc:	83 ec 0c             	sub    $0xc,%esp
    27ff:	ff 75 10             	pushl  0x10(%ebp)
    2802:	e8 b9 e1 ff ff       	call   9c0 <cos>
    2807:	83 c4 10             	add    $0x10,%esp
    280a:	d9 5d d8             	fstps  -0x28(%ebp)
    280d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2810:	83 ec 0c             	sub    $0xc,%esp
    2813:	50                   	push   %eax
    2814:	e8 de e0 ff ff       	call   8f7 <abs>
    2819:	83 c4 10             	add    $0x10,%esp
    281c:	d8 4d dc             	fmuls  -0x24(%ebp)
    281f:	d8 45 e0             	fadds  -0x20(%ebp)
    2822:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2825:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    2829:	b4 0c                	mov    $0xc,%ah
    282b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    282f:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2832:	db 5d f0             	fistpl -0x10(%ebp)
    2835:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    2838:	8b 45 0c             	mov    0xc(%ebp),%eax
    283b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    283e:	89 10                	mov    %edx,(%eax)
    *width = w;
    2840:	8b 45 08             	mov    0x8(%ebp),%eax
    2843:	8b 55 f4             	mov    -0xc(%ebp),%edx
    2846:	89 10                	mov    %edx,(%eax)
    return 1;
    2848:	b8 01 00 00 00       	mov    $0x1,%eax
}
    284d:	c9                   	leave  
    284e:	c3                   	ret    

0000284f <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    284f:	55                   	push   %ebp
    2850:	89 e5                	mov    %esp,%ebp
    2852:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    2855:	8b 45 08             	mov    0x8(%ebp),%eax
    2858:	8b 40 04             	mov    0x4(%eax),%eax
    285b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    285e:	db 45 c4             	fildl  -0x3c(%ebp)
    2861:	d9 05 44 9d 01 00    	flds   0x19d44
    2867:	de f9                	fdivrp %st,%st(1)
    2869:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    286c:	8b 45 08             	mov    0x8(%ebp),%eax
    286f:	8b 00                	mov    (%eax),%eax
    2871:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2874:	db 45 c4             	fildl  -0x3c(%ebp)
    2877:	d9 05 44 9d 01 00    	flds   0x19d44
    287d:	de f9                	fdivrp %st,%st(1)
    287f:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    2882:	8b 45 0c             	mov    0xc(%ebp),%eax
    2885:	8b 50 04             	mov    0x4(%eax),%edx
    2888:	8b 45 08             	mov    0x8(%ebp),%eax
    288b:	8b 40 04             	mov    0x4(%eax),%eax
    288e:	29 c2                	sub    %eax,%edx
    2890:	89 d0                	mov    %edx,%eax
    2892:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2895:	db 45 c4             	fildl  -0x3c(%ebp)
    2898:	d9 05 44 9d 01 00    	flds   0x19d44
    289e:	de f9                	fdivrp %st,%st(1)
    28a0:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    28a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    28a6:	8b 10                	mov    (%eax),%edx
    28a8:	8b 45 08             	mov    0x8(%ebp),%eax
    28ab:	8b 00                	mov    (%eax),%eax
    28ad:	29 c2                	sub    %eax,%edx
    28af:	89 d0                	mov    %edx,%eax
    28b1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    28b4:	db 45 c4             	fildl  -0x3c(%ebp)
    28b7:	d9 05 44 9d 01 00    	flds   0x19d44
    28bd:	de f9                	fdivrp %st,%st(1)
    28bf:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    28c2:	d9 45 10             	flds   0x10(%ebp)
    28c5:	d9 e0                	fchs   
    28c7:	83 ec 0c             	sub    $0xc,%esp
    28ca:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    28ce:	d9 1c 24             	fstps  (%esp)
    28d1:	e8 ea e0 ff ff       	call   9c0 <cos>
    28d6:	83 c4 10             	add    $0x10,%esp
    28d9:	d9 5d c4             	fstps  -0x3c(%ebp)
    28dc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    28df:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    28e2:	d9 45 10             	flds   0x10(%ebp)
    28e5:	d9 e0                	fchs   
    28e7:	83 ec 0c             	sub    $0xc,%esp
    28ea:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    28ee:	d9 1c 24             	fstps  (%esp)
    28f1:	e8 6d e2 ff ff       	call   b63 <sin>
    28f6:	83 c4 10             	add    $0x10,%esp
    28f9:	d9 5d c4             	fstps  -0x3c(%ebp)
    28fc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    28ff:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    2902:	d9 ee                	fldz   
    2904:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    2907:	d9 ee                	fldz   
    2909:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    290c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2913:	e9 28 01 00 00       	jmp    2a40 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    2918:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    291f:	e9 0a 01 00 00       	jmp    2a2e <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    2924:	db 45 f4             	fildl  -0xc(%ebp)
    2927:	d8 65 e4             	fsubs  -0x1c(%ebp)
    292a:	d8 65 ec             	fsubs  -0x14(%ebp)
    292d:	d8 4d dc             	fmuls  -0x24(%ebp)
    2930:	db 45 f0             	fildl  -0x10(%ebp)
    2933:	d8 65 e0             	fsubs  -0x20(%ebp)
    2936:	d8 65 e8             	fsubs  -0x18(%ebp)
    2939:	d8 4d d8             	fmuls  -0x28(%ebp)
    293c:	de c1                	faddp  %st,%st(1)
    293e:	d8 45 ec             	fadds  -0x14(%ebp)
    2941:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    2944:	db 45 f0             	fildl  -0x10(%ebp)
    2947:	d8 65 e0             	fsubs  -0x20(%ebp)
    294a:	d8 65 e8             	fsubs  -0x18(%ebp)
    294d:	d8 4d dc             	fmuls  -0x24(%ebp)
    2950:	db 45 f4             	fildl  -0xc(%ebp)
    2953:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2956:	d8 65 ec             	fsubs  -0x14(%ebp)
    2959:	d8 4d d8             	fmuls  -0x28(%ebp)
    295c:	de e9                	fsubrp %st,%st(1)
    295e:	d8 45 e8             	fadds  -0x18(%ebp)
    2961:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    2964:	d9 45 d4             	flds   -0x2c(%ebp)
    2967:	d9 ee                	fldz   
    2969:	d9 c9                	fxch   %st(1)
    296b:	df e9                	fucomip %st(1),%st
    296d:	dd d8                	fstp   %st(0)
    296f:	0f 93 c0             	setae  %al
    2972:	83 f0 01             	xor    $0x1,%eax
    2975:	84 c0                	test   %al,%al
    2977:	75 52                	jne    29cb <picTurn+0x17c>
    2979:	8b 45 08             	mov    0x8(%ebp),%eax
    297c:	8b 40 04             	mov    0x4(%eax),%eax
    297f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2982:	db 45 c4             	fildl  -0x3c(%ebp)
    2985:	d9 45 d4             	flds   -0x2c(%ebp)
    2988:	d9 c9                	fxch   %st(1)
    298a:	df e9                	fucomip %st(1),%st
    298c:	dd d8                	fstp   %st(0)
    298e:	0f 97 c0             	seta   %al
    2991:	83 f0 01             	xor    $0x1,%eax
    2994:	84 c0                	test   %al,%al
    2996:	75 33                	jne    29cb <picTurn+0x17c>
    2998:	d9 45 d0             	flds   -0x30(%ebp)
    299b:	d9 ee                	fldz   
    299d:	d9 c9                	fxch   %st(1)
    299f:	df e9                	fucomip %st(1),%st
    29a1:	dd d8                	fstp   %st(0)
    29a3:	0f 93 c0             	setae  %al
    29a6:	83 f0 01             	xor    $0x1,%eax
    29a9:	84 c0                	test   %al,%al
    29ab:	75 1e                	jne    29cb <picTurn+0x17c>
    29ad:	8b 45 08             	mov    0x8(%ebp),%eax
    29b0:	8b 00                	mov    (%eax),%eax
    29b2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    29b5:	db 45 c4             	fildl  -0x3c(%ebp)
    29b8:	d9 45 d0             	flds   -0x30(%ebp)
    29bb:	d9 c9                	fxch   %st(1)
    29bd:	df e9                	fucomip %st(1),%st
    29bf:	dd d8                	fstp   %st(0)
    29c1:	0f 97 c0             	seta   %al
    29c4:	83 f0 01             	xor    $0x1,%eax
    29c7:	84 c0                	test   %al,%al
    29c9:	74 2f                	je     29fa <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    29cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    29ce:	8b 48 08             	mov    0x8(%eax),%ecx
    29d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    29d4:	8b 00                	mov    (%eax),%eax
    29d6:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    29da:	89 c2                	mov    %eax,%edx
    29dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    29df:	01 c2                	add    %eax,%edx
    29e1:	89 d0                	mov    %edx,%eax
    29e3:	01 c0                	add    %eax,%eax
    29e5:	01 d0                	add    %edx,%eax
    29e7:	01 c8                	add    %ecx,%eax
    29e9:	83 ec 08             	sub    $0x8,%esp
    29ec:	50                   	push   %eax
    29ed:	68 b1 e1 01 00       	push   $0x1e1b1
    29f2:	e8 9f f6 ff ff       	call   2096 <setColor>
    29f7:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    29fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    29fd:	8b 48 08             	mov    0x8(%eax),%ecx
    2a00:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a03:	8b 00                	mov    (%eax),%eax
    2a05:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2a09:	89 c2                	mov    %eax,%edx
    2a0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2a0e:	01 c2                	add    %eax,%edx
    2a10:	89 d0                	mov    %edx,%eax
    2a12:	01 c0                	add    %eax,%eax
    2a14:	01 d0                	add    %edx,%eax
    2a16:	01 c8                	add    %ecx,%eax
    2a18:	50                   	push   %eax
    2a19:	ff 75 d0             	pushl  -0x30(%ebp)
    2a1c:	ff 75 d4             	pushl  -0x2c(%ebp)
    2a1f:	ff 75 08             	pushl  0x8(%ebp)
    2a22:	e8 9e f6 ff ff       	call   20c5 <mixColor>
    2a27:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    2a2a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2a2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a31:	8b 00                	mov    (%eax),%eax
    2a33:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2a36:	0f 8f e8 fe ff ff    	jg     2924 <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    2a3c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2a40:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a43:	8b 40 04             	mov    0x4(%eax),%eax
    2a46:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2a49:	0f 8f c9 fe ff ff    	jg     2918 <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    2a4f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2a54:	c9                   	leave  
    2a55:	c3                   	ret    

00002a56 <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    2a56:	55                   	push   %ebp
    2a57:	89 e5                	mov    %esp,%ebp
    2a59:	53                   	push   %ebx
    2a5a:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2a5d:	8b 45 08             	mov    0x8(%ebp),%eax
    2a60:	8b 10                	mov    (%eax),%edx
    2a62:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a65:	8b 00                	mov    (%eax),%eax
    2a67:	39 c2                	cmp    %eax,%edx
    2a69:	75 10                	jne    2a7b <picRollingOver+0x25>
    2a6b:	8b 45 08             	mov    0x8(%ebp),%eax
    2a6e:	8b 50 04             	mov    0x4(%eax),%edx
    2a71:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a74:	8b 40 04             	mov    0x4(%eax),%eax
    2a77:	39 c2                	cmp    %eax,%edx
    2a79:	74 0a                	je     2a85 <picRollingOver+0x2f>
        return 0;
    2a7b:	b8 00 00 00 00       	mov    $0x0,%eax
    2a80:	e9 88 00 00 00       	jmp    2b0d <picRollingOver+0xb7>

    int h = src->height;
    2a85:	8b 45 08             	mov    0x8(%ebp),%eax
    2a88:	8b 40 04             	mov    0x4(%eax),%eax
    2a8b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2a8e:	8b 45 08             	mov    0x8(%ebp),%eax
    2a91:	8b 00                	mov    (%eax),%eax
    2a93:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2a96:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2a9d:	eb 61                	jmp    2b00 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    2a9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2aa6:	eb 4c                	jmp    2af4 <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    2aa8:	8b 45 0c             	mov    0xc(%ebp),%eax
    2aab:	8b 48 08             	mov    0x8(%eax),%ecx
    2aae:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2ab1:	2b 45 f8             	sub    -0x8(%ebp),%eax
    2ab4:	83 e8 01             	sub    $0x1,%eax
    2ab7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2abb:	89 c2                	mov    %eax,%edx
    2abd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ac0:	01 c2                	add    %eax,%edx
    2ac2:	89 d0                	mov    %edx,%eax
    2ac4:	01 c0                	add    %eax,%eax
    2ac6:	01 d0                	add    %edx,%eax
    2ac8:	01 c1                	add    %eax,%ecx
    2aca:	8b 45 08             	mov    0x8(%ebp),%eax
    2acd:	8b 58 08             	mov    0x8(%eax),%ebx
    2ad0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2ad3:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2ad7:	89 c2                	mov    %eax,%edx
    2ad9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2adc:	01 c2                	add    %eax,%edx
    2ade:	89 d0                	mov    %edx,%eax
    2ae0:	01 c0                	add    %eax,%eax
    2ae2:	01 d0                	add    %edx,%eax
    2ae4:	01 d8                	add    %ebx,%eax
    2ae6:	51                   	push   %ecx
    2ae7:	50                   	push   %eax
    2ae8:	e8 a9 f5 ff ff       	call   2096 <setColor>
    2aed:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2af0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2af4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2af7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2afa:	7c ac                	jl     2aa8 <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2afc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2b00:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2b03:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2b06:	7c 97                	jl     2a9f <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    2b08:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2b0d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2b10:	c9                   	leave  
    2b11:	c3                   	ret    

00002b12 <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    2b12:	55                   	push   %ebp
    2b13:	89 e5                	mov    %esp,%ebp
    2b15:	53                   	push   %ebx
    2b16:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2b19:	8b 45 08             	mov    0x8(%ebp),%eax
    2b1c:	8b 10                	mov    (%eax),%edx
    2b1e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b21:	8b 00                	mov    (%eax),%eax
    2b23:	39 c2                	cmp    %eax,%edx
    2b25:	75 10                	jne    2b37 <picTurnAround+0x25>
    2b27:	8b 45 08             	mov    0x8(%ebp),%eax
    2b2a:	8b 50 04             	mov    0x4(%eax),%edx
    2b2d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b30:	8b 40 04             	mov    0x4(%eax),%eax
    2b33:	39 c2                	cmp    %eax,%edx
    2b35:	74 0a                	je     2b41 <picTurnAround+0x2f>
        return 0;
    2b37:	b8 00 00 00 00       	mov    $0x0,%eax
    2b3c:	e9 88 00 00 00       	jmp    2bc9 <picTurnAround+0xb7>

    int h = src->height;
    2b41:	8b 45 08             	mov    0x8(%ebp),%eax
    2b44:	8b 40 04             	mov    0x4(%eax),%eax
    2b47:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2b4a:	8b 45 08             	mov    0x8(%ebp),%eax
    2b4d:	8b 00                	mov    (%eax),%eax
    2b4f:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2b52:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2b59:	eb 61                	jmp    2bbc <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    2b5b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2b62:	eb 4c                	jmp    2bb0 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    2b64:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b67:	8b 48 08             	mov    0x8(%eax),%ecx
    2b6a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2b6d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2b71:	89 c2                	mov    %eax,%edx
    2b73:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2b76:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2b79:	01 c2                	add    %eax,%edx
    2b7b:	89 d0                	mov    %edx,%eax
    2b7d:	01 c0                	add    %eax,%eax
    2b7f:	01 d0                	add    %edx,%eax
    2b81:	83 e8 03             	sub    $0x3,%eax
    2b84:	01 c1                	add    %eax,%ecx
    2b86:	8b 45 08             	mov    0x8(%ebp),%eax
    2b89:	8b 58 08             	mov    0x8(%eax),%ebx
    2b8c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2b8f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2b93:	89 c2                	mov    %eax,%edx
    2b95:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b98:	01 c2                	add    %eax,%edx
    2b9a:	89 d0                	mov    %edx,%eax
    2b9c:	01 c0                	add    %eax,%eax
    2b9e:	01 d0                	add    %edx,%eax
    2ba0:	01 d8                	add    %ebx,%eax
    2ba2:	51                   	push   %ecx
    2ba3:	50                   	push   %eax
    2ba4:	e8 ed f4 ff ff       	call   2096 <setColor>
    2ba9:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2bac:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2bb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bb3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2bb6:	7c ac                	jl     2b64 <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2bb8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2bbc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2bbf:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2bc2:	7c 97                	jl     2b5b <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    2bc4:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2bc9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2bcc:	c9                   	leave  
    2bcd:	c3                   	ret    

00002bce <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    2bce:	55                   	push   %ebp
    2bcf:	89 e5                	mov    %esp,%ebp
    2bd1:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    2bd4:	83 ec 0c             	sub    $0xc,%esp
    2bd7:	ff 75 08             	pushl  0x8(%ebp)
    2bda:	e8 c5 d5 ff ff       	call   1a4 <strlen>
    2bdf:	83 c4 10             	add    $0x10,%esp
    2be2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    2be5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2be8:	8d 50 ff             	lea    -0x1(%eax),%edx
    2beb:	8b 45 08             	mov    0x8(%ebp),%eax
    2bee:	01 d0                	add    %edx,%eax
    2bf0:	0f b6 00             	movzbl (%eax),%eax
    2bf3:	3c 67                	cmp    $0x67,%al
    2bf5:	75 2b                	jne    2c22 <type+0x54>
    2bf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bfa:	8d 50 fe             	lea    -0x2(%eax),%edx
    2bfd:	8b 45 08             	mov    0x8(%ebp),%eax
    2c00:	01 d0                	add    %edx,%eax
    2c02:	0f b6 00             	movzbl (%eax),%eax
    2c05:	3c 70                	cmp    $0x70,%al
    2c07:	75 19                	jne    2c22 <type+0x54>
    2c09:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c0c:	8d 50 fd             	lea    -0x3(%eax),%edx
    2c0f:	8b 45 08             	mov    0x8(%ebp),%eax
    2c12:	01 d0                	add    %edx,%eax
    2c14:	0f b6 00             	movzbl (%eax),%eax
    2c17:	3c 6a                	cmp    $0x6a,%al
    2c19:	75 07                	jne    2c22 <type+0x54>
    2c1b:	b8 00 00 00 00       	mov    $0x0,%eax
    2c20:	eb 7f                	jmp    2ca1 <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    2c22:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c25:	8d 50 ff             	lea    -0x1(%eax),%edx
    2c28:	8b 45 08             	mov    0x8(%ebp),%eax
    2c2b:	01 d0                	add    %edx,%eax
    2c2d:	0f b6 00             	movzbl (%eax),%eax
    2c30:	3c 70                	cmp    $0x70,%al
    2c32:	75 2b                	jne    2c5f <type+0x91>
    2c34:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c37:	8d 50 fe             	lea    -0x2(%eax),%edx
    2c3a:	8b 45 08             	mov    0x8(%ebp),%eax
    2c3d:	01 d0                	add    %edx,%eax
    2c3f:	0f b6 00             	movzbl (%eax),%eax
    2c42:	3c 6d                	cmp    $0x6d,%al
    2c44:	75 19                	jne    2c5f <type+0x91>
    2c46:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c49:	8d 50 fd             	lea    -0x3(%eax),%edx
    2c4c:	8b 45 08             	mov    0x8(%ebp),%eax
    2c4f:	01 d0                	add    %edx,%eax
    2c51:	0f b6 00             	movzbl (%eax),%eax
    2c54:	3c 62                	cmp    $0x62,%al
    2c56:	75 07                	jne    2c5f <type+0x91>
    2c58:	b8 01 00 00 00       	mov    $0x1,%eax
    2c5d:	eb 42                	jmp    2ca1 <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    2c5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c62:	8d 50 ff             	lea    -0x1(%eax),%edx
    2c65:	8b 45 08             	mov    0x8(%ebp),%eax
    2c68:	01 d0                	add    %edx,%eax
    2c6a:	0f b6 00             	movzbl (%eax),%eax
    2c6d:	3c 67                	cmp    $0x67,%al
    2c6f:	75 2b                	jne    2c9c <type+0xce>
    2c71:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c74:	8d 50 fe             	lea    -0x2(%eax),%edx
    2c77:	8b 45 08             	mov    0x8(%ebp),%eax
    2c7a:	01 d0                	add    %edx,%eax
    2c7c:	0f b6 00             	movzbl (%eax),%eax
    2c7f:	3c 6e                	cmp    $0x6e,%al
    2c81:	75 19                	jne    2c9c <type+0xce>
    2c83:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c86:	8d 50 fd             	lea    -0x3(%eax),%edx
    2c89:	8b 45 08             	mov    0x8(%ebp),%eax
    2c8c:	01 d0                	add    %edx,%eax
    2c8e:	0f b6 00             	movzbl (%eax),%eax
    2c91:	3c 70                	cmp    $0x70,%al
    2c93:	75 07                	jne    2c9c <type+0xce>
    2c95:	b8 02 00 00 00       	mov    $0x2,%eax
    2c9a:	eb 05                	jmp    2ca1 <type+0xd3>
    else return NONE;
    2c9c:	b8 03 00 00 00       	mov    $0x3,%eax
}
    2ca1:	c9                   	leave  
    2ca2:	c3                   	ret    

00002ca3 <LoadBmp>:

PBitmap LoadBmp(char* filename){
    2ca3:	55                   	push   %ebp
    2ca4:	89 e5                	mov    %esp,%ebp
    2ca6:	56                   	push   %esi
    2ca7:	53                   	push   %ebx
    2ca8:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    2cab:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    2cb2:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    2cb9:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    2cc0:	83 ec 08             	sub    $0x8,%esp
    2cc3:	6a 00                	push   $0x0
    2cc5:	ff 75 0c             	pushl  0xc(%ebp)
    2cc8:	e8 d9 d6 ff ff       	call   3a6 <open>
    2ccd:	83 c4 10             	add    $0x10,%esp
    2cd0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2cd3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2cd7:	79 2c                	jns    2d05 <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    2cd9:	83 ec 08             	sub    $0x8,%esp
    2cdc:	ff 75 0c             	pushl  0xc(%ebp)
    2cdf:	68 48 9d 01 00       	push   $0x19d48
    2ce4:	e8 24 d8 ff ff       	call   50d <printf>
    2ce9:	83 c4 10             	add    $0x10,%esp
        return bmp;
    2cec:	8b 45 08             	mov    0x8(%ebp),%eax
    2cef:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2cf2:	89 10                	mov    %edx,(%eax)
    2cf4:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2cf7:	89 50 04             	mov    %edx,0x4(%eax)
    2cfa:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2cfd:	89 50 08             	mov    %edx,0x8(%eax)
    2d00:	e9 2d 02 00 00       	jmp    2f32 <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    2d05:	83 ec 04             	sub    $0x4,%esp
    2d08:	6a 0e                	push   $0xe
    2d0a:	8d 45 aa             	lea    -0x56(%ebp),%eax
    2d0d:	50                   	push   %eax
    2d0e:	ff 75 ec             	pushl  -0x14(%ebp)
    2d11:	e8 68 d6 ff ff       	call   37e <read>
    2d16:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    2d19:	83 ec 04             	sub    $0x4,%esp
    2d1c:	6a 28                	push   $0x28
    2d1e:	8d 45 82             	lea    -0x7e(%ebp),%eax
    2d21:	50                   	push   %eax
    2d22:	ff 75 ec             	pushl  -0x14(%ebp)
    2d25:	e8 54 d6 ff ff       	call   37e <read>
    2d2a:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2d2d:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2d31:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2d34:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2d38:	0f b7 d8             	movzwl %ax,%ebx
    2d3b:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    2d3e:	8b 55 ac             	mov    -0x54(%ebp),%edx
    2d41:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    2d45:	0f b7 c0             	movzwl %ax,%eax
    2d48:	83 ec 04             	sub    $0x4,%esp
    2d4b:	6a 36                	push   $0x36
    2d4d:	56                   	push   %esi
    2d4e:	53                   	push   %ebx
    2d4f:	51                   	push   %ecx
    2d50:	52                   	push   %edx
    2d51:	50                   	push   %eax
    2d52:	68 58 9d 01 00       	push   $0x19d58
    2d57:	e8 b1 d7 ff ff       	call   50d <printf>
    2d5c:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    2d5f:	8b 45 86             	mov    -0x7a(%ebp),%eax
    2d62:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    2d65:	8b 45 8a             	mov    -0x76(%ebp),%eax
    2d68:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    2d6b:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2d6e:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2d71:	0f af c2             	imul   %edx,%eax
    2d74:	89 c2                	mov    %eax,%edx
    2d76:	89 d0                	mov    %edx,%eax
    2d78:	01 c0                	add    %eax,%eax
    2d7a:	01 d0                	add    %edx,%eax
    2d7c:	83 ec 0c             	sub    $0xc,%esp
    2d7f:	50                   	push   %eax
    2d80:	e8 5b da ff ff       	call   7e0 <malloc>
    2d85:	83 c4 10             	add    $0x10,%esp
    2d88:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    2d8b:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2d8f:	0f b7 c0             	movzwl %ax,%eax
    2d92:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    2d95:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2d98:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    2d9c:	83 c0 1f             	add    $0x1f,%eax
    2d9f:	c1 f8 05             	sar    $0x5,%eax
    2da2:	c1 e0 02             	shl    $0x2,%eax
    2da5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    2da8:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2dab:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2daf:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    2db2:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2db5:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2db8:	83 ec 08             	sub    $0x8,%esp
    2dbb:	52                   	push   %edx
    2dbc:	50                   	push   %eax
    2dbd:	ff 75 e8             	pushl  -0x18(%ebp)
    2dc0:	ff 75 e0             	pushl  -0x20(%ebp)
    2dc3:	ff 75 e4             	pushl  -0x1c(%ebp)
    2dc6:	68 80 9d 01 00       	push   $0x19d80
    2dcb:	e8 3d d7 ff ff       	call   50d <printf>
    2dd0:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    2dd3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    2dd6:	83 e8 36             	sub    $0x36,%eax
    2dd9:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    2ddc:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2ddf:	83 ec 0c             	sub    $0xc,%esp
    2de2:	50                   	push   %eax
    2de3:	e8 f8 d9 ff ff       	call   7e0 <malloc>
    2de8:	83 c4 10             	add    $0x10,%esp
    2deb:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    2dee:	83 ec 04             	sub    $0x4,%esp
    2df1:	ff 75 dc             	pushl  -0x24(%ebp)
    2df4:	ff 75 d8             	pushl  -0x28(%ebp)
    2df7:	ff 75 ec             	pushl  -0x14(%ebp)
    2dfa:	e8 7f d5 ff ff       	call   37e <read>
    2dff:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    2e02:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2e05:	83 ec 0c             	sub    $0xc,%esp
    2e08:	50                   	push   %eax
    2e09:	e8 d2 d9 ff ff       	call   7e0 <malloc>
    2e0e:	83 c4 10             	add    $0x10,%esp
    2e11:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    2e14:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2e17:	83 ec 04             	sub    $0x4,%esp
    2e1a:	50                   	push   %eax
    2e1b:	ff 75 d4             	pushl  -0x2c(%ebp)
    2e1e:	ff 75 ec             	pushl  -0x14(%ebp)
    2e21:	e8 58 d5 ff ff       	call   37e <read>
    2e26:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    2e29:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2e2d:	66 c1 e8 03          	shr    $0x3,%ax
    2e31:	0f b7 c0             	movzwl %ax,%eax
    2e34:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    2e37:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2e3e:	e9 c1 00 00 00       	jmp    2f04 <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    2e43:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2e46:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2e49:	8d 50 ff             	lea    -0x1(%eax),%edx
    2e4c:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2e4f:	0f af c2             	imul   %edx,%eax
    2e52:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    2e55:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e58:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2e5c:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    2e5f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2e66:	e9 89 00 00 00       	jmp    2ef4 <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    2e6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e6e:	83 c0 01             	add    $0x1,%eax
    2e71:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2e75:	89 c2                	mov    %eax,%edx
    2e77:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2e7a:	01 d0                	add    %edx,%eax
    2e7c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    2e7f:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e82:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2e85:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e88:	01 c8                	add    %ecx,%eax
    2e8a:	89 c1                	mov    %eax,%ecx
    2e8c:	89 c8                	mov    %ecx,%eax
    2e8e:	01 c0                	add    %eax,%eax
    2e90:	01 c8                	add    %ecx,%eax
    2e92:	01 c2                	add    %eax,%edx
    2e94:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2e97:	8d 48 ff             	lea    -0x1(%eax),%ecx
    2e9a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e9d:	01 c8                	add    %ecx,%eax
    2e9f:	0f b6 00             	movzbl (%eax),%eax
    2ea2:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    2ea5:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2ea8:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2eab:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2eae:	01 c8                	add    %ecx,%eax
    2eb0:	89 c1                	mov    %eax,%ecx
    2eb2:	89 c8                	mov    %ecx,%eax
    2eb4:	01 c0                	add    %eax,%eax
    2eb6:	01 c8                	add    %ecx,%eax
    2eb8:	01 c2                	add    %eax,%edx
    2eba:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2ebd:	8d 48 fe             	lea    -0x2(%eax),%ecx
    2ec0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2ec3:	01 c8                	add    %ecx,%eax
    2ec5:	0f b6 00             	movzbl (%eax),%eax
    2ec8:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    2ecb:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2ece:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2ed1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2ed4:	01 c8                	add    %ecx,%eax
    2ed6:	89 c1                	mov    %eax,%ecx
    2ed8:	89 c8                	mov    %ecx,%eax
    2eda:	01 c0                	add    %eax,%eax
    2edc:	01 c8                	add    %ecx,%eax
    2ede:	01 c2                	add    %eax,%edx
    2ee0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2ee3:	8d 48 fd             	lea    -0x3(%eax),%ecx
    2ee6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2ee9:	01 c8                	add    %ecx,%eax
    2eeb:	0f b6 00             	movzbl (%eax),%eax
    2eee:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    2ef0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2ef4:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2ef7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2efa:	0f 8f 6b ff ff ff    	jg     2e6b <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    2f00:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2f04:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2f07:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2f0a:	0f 8f 33 ff ff ff    	jg     2e43 <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    2f10:	83 ec 0c             	sub    $0xc,%esp
    2f13:	ff 75 ec             	pushl  -0x14(%ebp)
    2f16:	e8 73 d4 ff ff       	call   38e <close>
    2f1b:	83 c4 10             	add    $0x10,%esp
    return bmp;
    2f1e:	8b 45 08             	mov    0x8(%ebp),%eax
    2f21:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2f24:	89 10                	mov    %edx,(%eax)
    2f26:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2f29:	89 50 04             	mov    %edx,0x4(%eax)
    2f2c:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2f2f:	89 50 08             	mov    %edx,0x8(%eax)
}
    2f32:	8b 45 08             	mov    0x8(%ebp),%eax
    2f35:	8d 65 f8             	lea    -0x8(%ebp),%esp
    2f38:	5b                   	pop    %ebx
    2f39:	5e                   	pop    %esi
    2f3a:	5d                   	pop    %ebp
    2f3b:	c2 04 00             	ret    $0x4

00002f3e <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    2f3e:	55                   	push   %ebp
    2f3f:	89 e5                	mov    %esp,%ebp
    2f41:	53                   	push   %ebx
    2f42:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    2f45:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    2f49:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    2f4d:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    2f51:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    2f55:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    2f59:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    2f5d:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    2f61:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    2f65:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    2f69:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    2f6d:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    2f71:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    2f75:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    2f79:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    2f7d:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    2f81:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    2f85:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    2f89:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    2f8d:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    2f91:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    2f95:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    2f99:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    2f9d:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    2fa1:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    2fa5:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    2fa9:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    2fad:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    2fb1:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    2fb5:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    2fb9:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    2fbd:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    2fc1:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    2fc5:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    2fc9:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    2fcd:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    2fd1:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    2fd5:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    2fd9:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    2fdd:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    2fe1:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    2fe5:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    2fe9:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    2fed:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    2ff1:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    2ff5:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    2ff9:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    2ffd:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    3001:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    3005:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    3009:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    300d:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    3011:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    3015:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    3019:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    301d:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    3021:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    3025:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    3029:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    302d:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    3031:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    3035:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    3039:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    303d:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    3041:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    3045:	83 ec 0c             	sub    $0xc,%esp
    3048:	68 c8 02 08 00       	push   $0x802c8
    304d:	e8 8e d7 ff ff       	call   7e0 <malloc>
    3052:	83 c4 10             	add    $0x10,%esp
    3055:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    3058:	83 ec 04             	sub    $0x4,%esp
    305b:	68 c8 02 08 00       	push   $0x802c8
    3060:	6a 00                	push   $0x0
    3062:	ff 75 f0             	pushl  -0x10(%ebp)
    3065:	e8 61 d1 ff ff       	call   1cb <memset>
    306a:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    306d:	83 ec 08             	sub    $0x8,%esp
    3070:	6a 00                	push   $0x0
    3072:	ff 75 0c             	pushl  0xc(%ebp)
    3075:	e8 2c d3 ff ff       	call   3a6 <open>
    307a:	83 c4 10             	add    $0x10,%esp
    307d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    3080:	83 ec 0c             	sub    $0xc,%esp
    3083:	68 40 42 0f 00       	push   $0xf4240
    3088:	e8 53 d7 ff ff       	call   7e0 <malloc>
    308d:	83 c4 10             	add    $0x10,%esp
    3090:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    3093:	83 ec 04             	sub    $0x4,%esp
    3096:	68 40 42 0f 00       	push   $0xf4240
    309b:	ff 75 e8             	pushl  -0x18(%ebp)
    309e:	ff 75 ec             	pushl  -0x14(%ebp)
    30a1:	e8 d8 d2 ff ff       	call   37e <read>
    30a6:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    30a9:	83 ec 0c             	sub    $0xc,%esp
    30ac:	ff 75 ec             	pushl  -0x14(%ebp)
    30af:	e8 da d2 ff ff       	call   38e <close>
    30b4:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    30b7:	68 40 42 0f 00       	push   $0xf4240
    30bc:	ff 75 e8             	pushl  -0x18(%ebp)
    30bf:	8d 45 9c             	lea    -0x64(%ebp),%eax
    30c2:	50                   	push   %eax
    30c3:	ff 75 f0             	pushl  -0x10(%ebp)
    30c6:	e8 5e 0c 01 00       	call   13d29 <_DecodeJPEG>
    30cb:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    30ce:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    30d5:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    30dc:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    30e3:	83 ec 0c             	sub    $0xc,%esp
    30e6:	ff 75 f0             	pushl  -0x10(%ebp)
    30e9:	e8 29 0b 01 00       	call   13c17 <GetImageSize>
    30ee:	83 c4 10             	add    $0x10,%esp
    30f1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    30f4:	83 ec 0c             	sub    $0xc,%esp
    30f7:	ff 75 f0             	pushl  -0x10(%ebp)
    30fa:	e8 e1 0a 01 00       	call   13be0 <GetImage>
    30ff:	83 c4 10             	add    $0x10,%esp
    3102:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    3105:	83 ec 0c             	sub    $0xc,%esp
    3108:	ff 75 f0             	pushl  -0x10(%ebp)
    310b:	e8 f1 0a 01 00       	call   13c01 <GetWidth>
    3110:	83 c4 10             	add    $0x10,%esp
    3113:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    3116:	83 ec 0c             	sub    $0xc,%esp
    3119:	ff 75 f0             	pushl  -0x10(%ebp)
    311c:	e8 eb 0a 01 00       	call   13c0c <GetHeight>
    3121:	83 c4 10             	add    $0x10,%esp
    3124:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    3127:	8b 55 90             	mov    -0x70(%ebp),%edx
    312a:	8b 45 94             	mov    -0x6c(%ebp),%eax
    312d:	0f af c2             	imul   %edx,%eax
    3130:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    3133:	8b 55 dc             	mov    -0x24(%ebp),%edx
    3136:	89 d0                	mov    %edx,%eax
    3138:	01 c0                	add    %eax,%eax
    313a:	01 d0                	add    %edx,%eax
    313c:	83 ec 0c             	sub    $0xc,%esp
    313f:	50                   	push   %eax
    3140:	e8 9b d6 ff ff       	call   7e0 <malloc>
    3145:	83 c4 10             	add    $0x10,%esp
    3148:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    314b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3152:	e9 9c 00 00 00       	jmp    31f3 <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    3157:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    315a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    315d:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3162:	89 c8                	mov    %ecx,%eax
    3164:	f7 ea                	imul   %edx
    3166:	89 c8                	mov    %ecx,%eax
    3168:	c1 f8 1f             	sar    $0x1f,%eax
    316b:	29 c2                	sub    %eax,%edx
    316d:	89 d0                	mov    %edx,%eax
    316f:	89 c2                	mov    %eax,%edx
    3171:	89 d0                	mov    %edx,%eax
    3173:	01 c0                	add    %eax,%eax
    3175:	01 d0                	add    %edx,%eax
    3177:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    317a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    317d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3180:	01 c8                	add    %ecx,%eax
    3182:	0f b6 00             	movzbl (%eax),%eax
    3185:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    3188:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    318b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    318e:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3193:	89 c8                	mov    %ecx,%eax
    3195:	f7 ea                	imul   %edx
    3197:	89 c8                	mov    %ecx,%eax
    3199:	c1 f8 1f             	sar    $0x1f,%eax
    319c:	29 c2                	sub    %eax,%edx
    319e:	89 d0                	mov    %edx,%eax
    31a0:	89 c2                	mov    %eax,%edx
    31a2:	89 d0                	mov    %edx,%eax
    31a4:	01 c0                	add    %eax,%eax
    31a6:	01 d0                	add    %edx,%eax
    31a8:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    31ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    31ae:	8d 48 01             	lea    0x1(%eax),%ecx
    31b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    31b4:	01 c8                	add    %ecx,%eax
    31b6:	0f b6 00             	movzbl (%eax),%eax
    31b9:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    31bc:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    31bf:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    31c2:	ba 56 55 55 55       	mov    $0x55555556,%edx
    31c7:	89 c8                	mov    %ecx,%eax
    31c9:	f7 ea                	imul   %edx
    31cb:	89 c8                	mov    %ecx,%eax
    31cd:	c1 f8 1f             	sar    $0x1f,%eax
    31d0:	29 c2                	sub    %eax,%edx
    31d2:	89 d0                	mov    %edx,%eax
    31d4:	89 c2                	mov    %eax,%edx
    31d6:	89 d0                	mov    %edx,%eax
    31d8:	01 c0                	add    %eax,%eax
    31da:	01 d0                	add    %edx,%eax
    31dc:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    31df:	8b 45 f4             	mov    -0xc(%ebp),%eax
    31e2:	8d 48 02             	lea    0x2(%eax),%ecx
    31e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    31e8:	01 c8                	add    %ecx,%eax
    31ea:	0f b6 00             	movzbl (%eax),%eax
    31ed:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    31ef:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    31f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    31f6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    31f9:	0f 8c 58 ff ff ff    	jl     3157 <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    31ff:	8b 45 08             	mov    0x8(%ebp),%eax
    3202:	8b 55 90             	mov    -0x70(%ebp),%edx
    3205:	89 10                	mov    %edx,(%eax)
    3207:	8b 55 94             	mov    -0x6c(%ebp),%edx
    320a:	89 50 04             	mov    %edx,0x4(%eax)
    320d:	8b 55 98             	mov    -0x68(%ebp),%edx
    3210:	89 50 08             	mov    %edx,0x8(%eax)
}
    3213:	8b 45 08             	mov    0x8(%ebp),%eax
    3216:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3219:	c9                   	leave  
    321a:	c2 04 00             	ret    $0x4

0000321d <LoadPng>:

PBitmap LoadPng(char* filename){
    321d:	55                   	push   %ebp
    321e:	89 e5                	mov    %esp,%ebp
    3220:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    3223:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    322a:	ff 75 0c             	pushl  0xc(%ebp)
    322d:	8d 45 e0             	lea    -0x20(%ebp),%eax
    3230:	50                   	push   %eax
    3231:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    3234:	50                   	push   %eax
    3235:	8d 45 e8             	lea    -0x18(%ebp),%eax
    3238:	50                   	push   %eax
    3239:	e8 d3 d3 00 00       	call   10611 <lodepng_decode24_file>
    323e:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    3241:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3244:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    3247:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    324a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    324d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    3254:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3257:	8b 45 d8             	mov    -0x28(%ebp),%eax
    325a:	0f af c2             	imul   %edx,%eax
    325d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    3260:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3263:	89 d0                	mov    %edx,%eax
    3265:	01 c0                	add    %eax,%eax
    3267:	01 d0                	add    %edx,%eax
    3269:	83 ec 0c             	sub    $0xc,%esp
    326c:	50                   	push   %eax
    326d:	e8 6e d5 ff ff       	call   7e0 <malloc>
    3272:	83 c4 10             	add    $0x10,%esp
    3275:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    3278:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    327f:	e9 87 00 00 00       	jmp    330b <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    3284:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3287:	8b 55 f4             	mov    -0xc(%ebp),%edx
    328a:	89 d0                	mov    %edx,%eax
    328c:	01 c0                	add    %eax,%eax
    328e:	01 d0                	add    %edx,%eax
    3290:	01 c8                	add    %ecx,%eax
    3292:	0f b6 00             	movzbl (%eax),%eax
    3295:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    3298:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    329b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    329e:	89 d0                	mov    %edx,%eax
    32a0:	01 c0                	add    %eax,%eax
    32a2:	01 d0                	add    %edx,%eax
    32a4:	83 c0 01             	add    $0x1,%eax
    32a7:	01 c8                	add    %ecx,%eax
    32a9:	0f b6 00             	movzbl (%eax),%eax
    32ac:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    32af:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    32b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    32b5:	89 d0                	mov    %edx,%eax
    32b7:	01 c0                	add    %eax,%eax
    32b9:	01 d0                	add    %edx,%eax
    32bb:	83 c0 02             	add    $0x2,%eax
    32be:	01 c8                	add    %ecx,%eax
    32c0:	0f b6 00             	movzbl (%eax),%eax
    32c3:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    32c6:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    32c9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    32cc:	89 d0                	mov    %edx,%eax
    32ce:	01 c0                	add    %eax,%eax
    32d0:	01 d0                	add    %edx,%eax
    32d2:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    32d5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    32d9:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    32dc:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    32df:	8b 55 f4             	mov    -0xc(%ebp),%edx
    32e2:	89 d0                	mov    %edx,%eax
    32e4:	01 c0                	add    %eax,%eax
    32e6:	01 d0                	add    %edx,%eax
    32e8:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    32eb:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    32ef:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    32f2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    32f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    32f8:	89 d0                	mov    %edx,%eax
    32fa:	01 c0                	add    %eax,%eax
    32fc:	01 d0                	add    %edx,%eax
    32fe:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3301:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    3305:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    3307:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    330b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    330e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3311:	0f 8c 6d ff ff ff    	jl     3284 <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    3317:	8b 45 e8             	mov    -0x18(%ebp),%eax
    331a:	83 ec 0c             	sub    $0xc,%esp
    331d:	50                   	push   %eax
    331e:	e8 7b d3 ff ff       	call   69e <free>
    3323:	83 c4 10             	add    $0x10,%esp
    return bmp;
    3326:	8b 45 08             	mov    0x8(%ebp),%eax
    3329:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    332c:	89 10                	mov    %edx,(%eax)
    332e:	8b 55 d8             	mov    -0x28(%ebp),%edx
    3331:	89 50 04             	mov    %edx,0x4(%eax)
    3334:	8b 55 dc             	mov    -0x24(%ebp),%edx
    3337:	89 50 08             	mov    %edx,0x8(%eax)

}
    333a:	8b 45 08             	mov    0x8(%ebp),%eax
    333d:	c9                   	leave  
    333e:	c2 04 00             	ret    $0x4

00003341 <LoadImg>:

PBitmap LoadImg(char* filename){
    3341:	55                   	push   %ebp
    3342:	89 e5                	mov    %esp,%ebp
    3344:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    3347:	83 ec 0c             	sub    $0xc,%esp
    334a:	ff 75 0c             	pushl  0xc(%ebp)
    334d:	e8 7c f8 ff ff       	call   2bce <type>
    3352:	83 c4 10             	add    $0x10,%esp
    3355:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    3358:	8b 45 f4             	mov    -0xc(%ebp),%eax
    335b:	83 f8 01             	cmp    $0x1,%eax
    335e:	74 1d                	je     337d <LoadImg+0x3c>
    3360:	83 f8 02             	cmp    $0x2,%eax
    3363:	74 2c                	je     3391 <LoadImg+0x50>
    3365:	85 c0                	test   %eax,%eax
    3367:	75 3c                	jne    33a5 <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    3369:	8b 45 08             	mov    0x8(%ebp),%eax
    336c:	83 ec 08             	sub    $0x8,%esp
    336f:	ff 75 0c             	pushl  0xc(%ebp)
    3372:	50                   	push   %eax
    3373:	e8 c6 fb ff ff       	call   2f3e <LoadJpeg>
    3378:	83 c4 0c             	add    $0xc,%esp
    337b:	eb 3c                	jmp    33b9 <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    337d:	8b 45 08             	mov    0x8(%ebp),%eax
    3380:	83 ec 08             	sub    $0x8,%esp
    3383:	ff 75 0c             	pushl  0xc(%ebp)
    3386:	50                   	push   %eax
    3387:	e8 17 f9 ff ff       	call   2ca3 <LoadBmp>
    338c:	83 c4 0c             	add    $0xc,%esp
    338f:	eb 28                	jmp    33b9 <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    3391:	8b 45 08             	mov    0x8(%ebp),%eax
    3394:	83 ec 08             	sub    $0x8,%esp
    3397:	ff 75 0c             	pushl  0xc(%ebp)
    339a:	50                   	push   %eax
    339b:	e8 7d fe ff ff       	call   321d <LoadPng>
    33a0:	83 c4 0c             	add    $0xc,%esp
    33a3:	eb 14                	jmp    33b9 <LoadImg+0x78>

        default: return bmp;
    33a5:	8b 45 08             	mov    0x8(%ebp),%eax
    33a8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    33ab:	89 10                	mov    %edx,(%eax)
    33ad:	8b 55 ec             	mov    -0x14(%ebp),%edx
    33b0:	89 50 04             	mov    %edx,0x4(%eax)
    33b3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    33b6:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    33b9:	8b 45 08             	mov    0x8(%ebp),%eax
    33bc:	c9                   	leave  
    33bd:	c2 04 00             	ret    $0x4

000033c0 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    33c0:	55                   	push   %ebp
    33c1:	89 e5                	mov    %esp,%ebp
    33c3:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    33c6:	8b 45 08             	mov    0x8(%ebp),%eax
    33c9:	83 ec 0c             	sub    $0xc,%esp
    33cc:	50                   	push   %eax
    33cd:	e8 0e d4 ff ff       	call   7e0 <malloc>
    33d2:	83 c4 10             	add    $0x10,%esp
}
    33d5:	c9                   	leave  
    33d6:	c3                   	ret    

000033d7 <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    33d7:	55                   	push   %ebp
    33d8:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    33da:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    33df:	5d                   	pop    %ebp
    33e0:	c3                   	ret    

000033e1 <lodepng_free>:

static void lodepng_free(void* ptr) {
    33e1:	55                   	push   %ebp
    33e2:	89 e5                	mov    %esp,%ebp
    33e4:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    33e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    33eb:	74 0e                	je     33fb <lodepng_free+0x1a>
    free(ptr);
    33ed:	83 ec 0c             	sub    $0xc,%esp
    33f0:	ff 75 08             	pushl  0x8(%ebp)
    33f3:	e8 a6 d2 ff ff       	call   69e <free>
    33f8:	83 c4 10             	add    $0x10,%esp
}
    33fb:	90                   	nop
    33fc:	c9                   	leave  
    33fd:	c3                   	ret    

000033fe <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    33fe:	55                   	push   %ebp
    33ff:	89 e5                	mov    %esp,%ebp
    3401:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    3404:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    340b:	eb 19                	jmp    3426 <lodepng_memcpy+0x28>
    340d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3410:	8b 45 08             	mov    0x8(%ebp),%eax
    3413:	01 c2                	add    %eax,%edx
    3415:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3418:	8b 45 0c             	mov    0xc(%ebp),%eax
    341b:	01 c8                	add    %ecx,%eax
    341d:	0f b6 00             	movzbl (%eax),%eax
    3420:	88 02                	mov    %al,(%edx)
    3422:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3426:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3429:	3b 45 10             	cmp    0x10(%ebp),%eax
    342c:	7c df                	jl     340d <lodepng_memcpy+0xf>
}
    342e:	90                   	nop
    342f:	c9                   	leave  
    3430:	c3                   	ret    

00003431 <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    3431:	55                   	push   %ebp
    3432:	89 e5                	mov    %esp,%ebp
    3434:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    3437:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    343e:	eb 11                	jmp    3451 <lodepng_memset+0x20>
    3440:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3443:	8b 45 08             	mov    0x8(%ebp),%eax
    3446:	01 d0                	add    %edx,%eax
    3448:	8b 55 0c             	mov    0xc(%ebp),%edx
    344b:	88 10                	mov    %dl,(%eax)
    344d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3451:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3454:	3b 45 10             	cmp    0x10(%ebp),%eax
    3457:	7c e7                	jl     3440 <lodepng_memset+0xf>
}
    3459:	90                   	nop
    345a:	c9                   	leave  
    345b:	c3                   	ret    

0000345c <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    345c:	55                   	push   %ebp
    345d:	89 e5                	mov    %esp,%ebp
    345f:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    3462:	8b 45 08             	mov    0x8(%ebp),%eax
    3465:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    3468:	eb 04                	jmp    346e <lodepng_strlen+0x12>
    346a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    346e:	8b 45 08             	mov    0x8(%ebp),%eax
    3471:	0f b6 00             	movzbl (%eax),%eax
    3474:	84 c0                	test   %al,%al
    3476:	75 f2                	jne    346a <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    3478:	8b 55 08             	mov    0x8(%ebp),%edx
    347b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    347e:	29 c2                	sub    %eax,%edx
    3480:	89 d0                	mov    %edx,%eax
}
    3482:	c9                   	leave  
    3483:	c3                   	ret    

00003484 <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    3484:	55                   	push   %ebp
    3485:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    3487:	8b 55 08             	mov    0x8(%ebp),%edx
    348a:	8b 45 0c             	mov    0xc(%ebp),%eax
    348d:	01 c2                	add    %eax,%edx
    348f:	8b 45 10             	mov    0x10(%ebp),%eax
    3492:	89 10                	mov    %edx,(%eax)
  return *result < a;
    3494:	8b 45 10             	mov    0x10(%ebp),%eax
    3497:	8b 00                	mov    (%eax),%eax
    3499:	3b 45 08             	cmp    0x8(%ebp),%eax
    349c:	0f 9c c0             	setl   %al
    349f:	0f b6 c0             	movzbl %al,%eax
}
    34a2:	5d                   	pop    %ebp
    34a3:	c3                   	ret    

000034a4 <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    34a4:	55                   	push   %ebp
    34a5:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    34a7:	8b 45 08             	mov    0x8(%ebp),%eax
    34aa:	0f af 45 0c          	imul   0xc(%ebp),%eax
    34ae:	89 c2                	mov    %eax,%edx
    34b0:	8b 45 10             	mov    0x10(%ebp),%eax
    34b3:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    34b5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    34b9:	74 15                	je     34d0 <lodepng_mulofl+0x2c>
    34bb:	8b 45 10             	mov    0x10(%ebp),%eax
    34be:	8b 00                	mov    (%eax),%eax
    34c0:	99                   	cltd   
    34c1:	f7 7d 08             	idivl  0x8(%ebp)
    34c4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    34c7:	74 07                	je     34d0 <lodepng_mulofl+0x2c>
    34c9:	b8 01 00 00 00       	mov    $0x1,%eax
    34ce:	eb 05                	jmp    34d5 <lodepng_mulofl+0x31>
    34d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    34d5:	5d                   	pop    %ebp
    34d6:	c3                   	ret    

000034d7 <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    34d7:	55                   	push   %ebp
    34d8:	89 e5                	mov    %esp,%ebp
    34da:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    34dd:	8d 45 fc             	lea    -0x4(%ebp),%eax
    34e0:	50                   	push   %eax
    34e1:	ff 75 0c             	pushl  0xc(%ebp)
    34e4:	ff 75 08             	pushl  0x8(%ebp)
    34e7:	e8 98 ff ff ff       	call   3484 <lodepng_addofl>
    34ec:	83 c4 0c             	add    $0xc,%esp
    34ef:	85 c0                	test   %eax,%eax
    34f1:	74 07                	je     34fa <lodepng_gtofl+0x23>
    34f3:	b8 01 00 00 00       	mov    $0x1,%eax
    34f8:	eb 0c                	jmp    3506 <lodepng_gtofl+0x2f>
  return d > c;
    34fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    34fd:	3b 45 10             	cmp    0x10(%ebp),%eax
    3500:	0f 9f c0             	setg   %al
    3503:	0f b6 c0             	movzbl %al,%eax
}
    3506:	c9                   	leave  
    3507:	c3                   	ret    

00003508 <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    3508:	55                   	push   %ebp
    3509:	89 e5                	mov    %esp,%ebp
    350b:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    350e:	8b 45 08             	mov    0x8(%ebp),%eax
    3511:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    3518:	8b 45 08             	mov    0x8(%ebp),%eax
    351b:	8b 50 08             	mov    0x8(%eax),%edx
    351e:	8b 45 08             	mov    0x8(%ebp),%eax
    3521:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    3524:	8b 45 08             	mov    0x8(%ebp),%eax
    3527:	8b 00                	mov    (%eax),%eax
    3529:	83 ec 0c             	sub    $0xc,%esp
    352c:	50                   	push   %eax
    352d:	e8 af fe ff ff       	call   33e1 <lodepng_free>
    3532:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    3535:	8b 45 08             	mov    0x8(%ebp),%eax
    3538:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    353e:	90                   	nop
    353f:	c9                   	leave  
    3540:	c3                   	ret    

00003541 <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    3541:	55                   	push   %ebp
    3542:	89 e5                	mov    %esp,%ebp
    3544:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    3547:	8b 45 0c             	mov    0xc(%ebp),%eax
    354a:	c1 e0 02             	shl    $0x2,%eax
    354d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    3550:	8b 45 08             	mov    0x8(%ebp),%eax
    3553:	8b 40 08             	mov    0x8(%eax),%eax
    3556:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    3559:	7d 46                	jge    35a1 <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    355b:	8b 45 08             	mov    0x8(%ebp),%eax
    355e:	8b 40 08             	mov    0x8(%eax),%eax
    3561:	d1 f8                	sar    %eax
    3563:	89 c2                	mov    %eax,%edx
    3565:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3568:	01 d0                	add    %edx,%eax
    356a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    356d:	8b 45 08             	mov    0x8(%ebp),%eax
    3570:	8b 00                	mov    (%eax),%eax
    3572:	ff 75 f8             	pushl  -0x8(%ebp)
    3575:	50                   	push   %eax
    3576:	e8 5c fe ff ff       	call   33d7 <lodepng_realloc>
    357b:	83 c4 08             	add    $0x8,%esp
    357e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    3581:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3585:	74 13                	je     359a <uivector_resize+0x59>
      p->allocsize = newsize;
    3587:	8b 45 08             	mov    0x8(%ebp),%eax
    358a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    358d:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    3590:	8b 45 08             	mov    0x8(%ebp),%eax
    3593:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3596:	89 10                	mov    %edx,(%eax)
    3598:	eb 07                	jmp    35a1 <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    359a:	b8 00 00 00 00       	mov    $0x0,%eax
    359f:	eb 0e                	jmp    35af <uivector_resize+0x6e>
  }
  p->size = size;
    35a1:	8b 45 08             	mov    0x8(%ebp),%eax
    35a4:	8b 55 0c             	mov    0xc(%ebp),%edx
    35a7:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    35aa:	b8 01 00 00 00       	mov    $0x1,%eax
}
    35af:	c9                   	leave  
    35b0:	c3                   	ret    

000035b1 <uivector_init>:

static void uivector_init(uivector* p) {
    35b1:	55                   	push   %ebp
    35b2:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    35b4:	8b 45 08             	mov    0x8(%ebp),%eax
    35b7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    35bd:	8b 45 08             	mov    0x8(%ebp),%eax
    35c0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    35c7:	8b 45 08             	mov    0x8(%ebp),%eax
    35ca:	8b 50 08             	mov    0x8(%eax),%edx
    35cd:	8b 45 08             	mov    0x8(%ebp),%eax
    35d0:	89 50 04             	mov    %edx,0x4(%eax)
}
    35d3:	90                   	nop
    35d4:	5d                   	pop    %ebp
    35d5:	c3                   	ret    

000035d6 <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    35d6:	55                   	push   %ebp
    35d7:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    35d9:	8b 45 08             	mov    0x8(%ebp),%eax
    35dc:	8b 40 04             	mov    0x4(%eax),%eax
    35df:	83 c0 01             	add    $0x1,%eax
    35e2:	50                   	push   %eax
    35e3:	ff 75 08             	pushl  0x8(%ebp)
    35e6:	e8 56 ff ff ff       	call   3541 <uivector_resize>
    35eb:	83 c4 08             	add    $0x8,%esp
    35ee:	85 c0                	test   %eax,%eax
    35f0:	75 07                	jne    35f9 <uivector_push_back+0x23>
    35f2:	b8 00 00 00 00       	mov    $0x0,%eax
    35f7:	eb 1f                	jmp    3618 <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    35f9:	8b 45 08             	mov    0x8(%ebp),%eax
    35fc:	8b 10                	mov    (%eax),%edx
    35fe:	8b 45 08             	mov    0x8(%ebp),%eax
    3601:	8b 40 04             	mov    0x4(%eax),%eax
    3604:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    3609:	c1 e0 02             	shl    $0x2,%eax
    360c:	01 c2                	add    %eax,%edx
    360e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3611:	89 02                	mov    %eax,(%edx)
  return 1;
    3613:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3618:	c9                   	leave  
    3619:	c3                   	ret    

0000361a <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    361a:	55                   	push   %ebp
    361b:	89 e5                	mov    %esp,%ebp
    361d:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    3620:	8b 45 08             	mov    0x8(%ebp),%eax
    3623:	8b 40 08             	mov    0x8(%eax),%eax
    3626:	3b 45 0c             	cmp    0xc(%ebp),%eax
    3629:	7d 46                	jge    3671 <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    362b:	8b 45 08             	mov    0x8(%ebp),%eax
    362e:	8b 40 08             	mov    0x8(%eax),%eax
    3631:	d1 f8                	sar    %eax
    3633:	89 c2                	mov    %eax,%edx
    3635:	8b 45 0c             	mov    0xc(%ebp),%eax
    3638:	01 d0                	add    %edx,%eax
    363a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    363d:	8b 45 08             	mov    0x8(%ebp),%eax
    3640:	8b 00                	mov    (%eax),%eax
    3642:	ff 75 fc             	pushl  -0x4(%ebp)
    3645:	50                   	push   %eax
    3646:	e8 8c fd ff ff       	call   33d7 <lodepng_realloc>
    364b:	83 c4 08             	add    $0x8,%esp
    364e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    3651:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    3655:	74 13                	je     366a <ucvector_resize+0x50>
      p->allocsize = newsize;
    3657:	8b 45 08             	mov    0x8(%ebp),%eax
    365a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    365d:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    3660:	8b 45 08             	mov    0x8(%ebp),%eax
    3663:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3666:	89 10                	mov    %edx,(%eax)
    3668:	eb 07                	jmp    3671 <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    366a:	b8 00 00 00 00       	mov    $0x0,%eax
    366f:	eb 0e                	jmp    367f <ucvector_resize+0x65>
  }
  p->size = size;
    3671:	8b 45 08             	mov    0x8(%ebp),%eax
    3674:	8b 55 0c             	mov    0xc(%ebp),%edx
    3677:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    367a:	b8 01 00 00 00       	mov    $0x1,%eax
}
    367f:	c9                   	leave  
    3680:	c3                   	ret    

00003681 <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    3681:	55                   	push   %ebp
    3682:	89 e5                	mov    %esp,%ebp
    3684:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    3687:	8b 45 0c             	mov    0xc(%ebp),%eax
    368a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    368d:	8b 45 10             	mov    0x10(%ebp),%eax
    3690:	89 45 f8             	mov    %eax,-0x8(%ebp)
    3693:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3696:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    3699:	8b 45 08             	mov    0x8(%ebp),%eax
    369c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    369f:	89 10                	mov    %edx,(%eax)
    36a1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    36a4:	89 50 04             	mov    %edx,0x4(%eax)
    36a7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    36aa:	89 50 08             	mov    %edx,0x8(%eax)
}
    36ad:	8b 45 08             	mov    0x8(%ebp),%eax
    36b0:	c9                   	leave  
    36b1:	c2 04 00             	ret    $0x4

000036b4 <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    36b4:	55                   	push   %ebp
    36b5:	89 e5                	mov    %esp,%ebp
    36b7:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    36ba:	8b 45 08             	mov    0x8(%ebp),%eax
    36bd:	8b 00                	mov    (%eax),%eax
    36bf:	83 ec 0c             	sub    $0xc,%esp
    36c2:	50                   	push   %eax
    36c3:	e8 19 fd ff ff       	call   33e1 <lodepng_free>
    36c8:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    36cb:	8b 45 08             	mov    0x8(%ebp),%eax
    36ce:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    36d4:	90                   	nop
    36d5:	c9                   	leave  
    36d6:	c3                   	ret    

000036d7 <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    36d7:	55                   	push   %ebp
    36d8:	89 e5                	mov    %esp,%ebp
    36da:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    36dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    36e0:	83 c0 01             	add    $0x1,%eax
    36e3:	83 ec 0c             	sub    $0xc,%esp
    36e6:	50                   	push   %eax
    36e7:	e8 d4 fc ff ff       	call   33c0 <lodepng_malloc>
    36ec:	83 c4 10             	add    $0x10,%esp
    36ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    36f2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    36f6:	74 1f                	je     3717 <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    36f8:	83 ec 04             	sub    $0x4,%esp
    36fb:	ff 75 0c             	pushl  0xc(%ebp)
    36fe:	ff 75 08             	pushl  0x8(%ebp)
    3701:	ff 75 f4             	pushl  -0xc(%ebp)
    3704:	e8 f5 fc ff ff       	call   33fe <lodepng_memcpy>
    3709:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    370c:	8b 55 0c             	mov    0xc(%ebp),%edx
    370f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3712:	01 d0                	add    %edx,%eax
    3714:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    3717:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    371a:	c9                   	leave  
    371b:	c3                   	ret    

0000371c <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    371c:	55                   	push   %ebp
    371d:	89 e5                	mov    %esp,%ebp
    371f:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    3722:	ff 75 08             	pushl  0x8(%ebp)
    3725:	e8 32 fd ff ff       	call   345c <lodepng_strlen>
    372a:	83 c4 04             	add    $0x4,%esp
    372d:	83 ec 08             	sub    $0x8,%esp
    3730:	50                   	push   %eax
    3731:	ff 75 08             	pushl  0x8(%ebp)
    3734:	e8 9e ff ff ff       	call   36d7 <alloc_string_sized>
    3739:	83 c4 10             	add    $0x10,%esp
}
    373c:	c9                   	leave  
    373d:	c3                   	ret    

0000373e <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    373e:	55                   	push   %ebp
    373f:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3741:	8b 45 08             	mov    0x8(%ebp),%eax
    3744:	0f b6 00             	movzbl (%eax),%eax
    3747:	0f b6 c0             	movzbl %al,%eax
    374a:	c1 e0 18             	shl    $0x18,%eax
    374d:	89 c2                	mov    %eax,%edx
    374f:	8b 45 08             	mov    0x8(%ebp),%eax
    3752:	83 c0 01             	add    $0x1,%eax
    3755:	0f b6 00             	movzbl (%eax),%eax
    3758:	0f b6 c0             	movzbl %al,%eax
    375b:	c1 e0 10             	shl    $0x10,%eax
    375e:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    3760:	8b 45 08             	mov    0x8(%ebp),%eax
    3763:	83 c0 02             	add    $0x2,%eax
    3766:	0f b6 00             	movzbl (%eax),%eax
    3769:	0f b6 c0             	movzbl %al,%eax
    376c:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    376f:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    3771:	8b 45 08             	mov    0x8(%ebp),%eax
    3774:	83 c0 03             	add    $0x3,%eax
    3777:	0f b6 00             	movzbl (%eax),%eax
    377a:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    377d:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    377f:	5d                   	pop    %ebp
    3780:	c3                   	ret    

00003781 <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    3781:	55                   	push   %ebp
    3782:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    3784:	8b 45 0c             	mov    0xc(%ebp),%eax
    3787:	c1 e8 18             	shr    $0x18,%eax
    378a:	89 c2                	mov    %eax,%edx
    378c:	8b 45 08             	mov    0x8(%ebp),%eax
    378f:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    3791:	8b 45 08             	mov    0x8(%ebp),%eax
    3794:	83 c0 01             	add    $0x1,%eax
    3797:	8b 55 0c             	mov    0xc(%ebp),%edx
    379a:	c1 ea 10             	shr    $0x10,%edx
    379d:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    379f:	8b 45 08             	mov    0x8(%ebp),%eax
    37a2:	83 c0 02             	add    $0x2,%eax
    37a5:	8b 55 0c             	mov    0xc(%ebp),%edx
    37a8:	c1 ea 08             	shr    $0x8,%edx
    37ab:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    37ad:	8b 45 08             	mov    0x8(%ebp),%eax
    37b0:	83 c0 03             	add    $0x3,%eax
    37b3:	8b 55 0c             	mov    0xc(%ebp),%edx
    37b6:	88 10                	mov    %dl,(%eax)
}
    37b8:	90                   	nop
    37b9:	5d                   	pop    %ebp
    37ba:	c3                   	ret    

000037bb <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    37bb:	55                   	push   %ebp
    37bc:	89 e5                	mov    %esp,%ebp
    37be:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    37c1:	83 ec 08             	sub    $0x8,%esp
    37c4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    37c7:	50                   	push   %eax
    37c8:	ff 75 08             	pushl  0x8(%ebp)
    37cb:	e8 b7 ca ff ff       	call   287 <stat>
    37d0:	83 c4 10             	add    $0x10,%esp
  return s.size;
    37d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    37d6:	c9                   	leave  
    37d7:	c3                   	ret    

000037d8 <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    37d8:	55                   	push   %ebp
    37d9:	89 e5                	mov    %esp,%ebp
    37db:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    37de:	83 ec 08             	sub    $0x8,%esp
    37e1:	6a 00                	push   $0x0
    37e3:	ff 75 10             	pushl  0x10(%ebp)
    37e6:	e8 bb cb ff ff       	call   3a6 <open>
    37eb:	83 c4 10             	add    $0x10,%esp
    37ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    37f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    37f5:	79 07                	jns    37fe <lodepng_buffer_file+0x26>
  {
      return -1;
    37f7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    37fc:	eb 19                	jmp    3817 <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    37fe:	83 ec 04             	sub    $0x4,%esp
    3801:	ff 75 0c             	pushl  0xc(%ebp)
    3804:	ff 75 08             	pushl  0x8(%ebp)
    3807:	ff 75 f4             	pushl  -0xc(%ebp)
    380a:	e8 6f cb ff ff       	call   37e <read>
    380f:	83 c4 10             	add    $0x10,%esp
  return 0;
    3812:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3817:	c9                   	leave  
    3818:	c3                   	ret    

00003819 <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    3819:	55                   	push   %ebp
    381a:	89 e5                	mov    %esp,%ebp
    381c:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    381f:	83 ec 0c             	sub    $0xc,%esp
    3822:	ff 75 10             	pushl  0x10(%ebp)
    3825:	e8 91 ff ff ff       	call   37bb <lodepng_filesize>
    382a:	83 c4 10             	add    $0x10,%esp
    382d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    3830:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3834:	79 07                	jns    383d <lodepng_load_file+0x24>
    3836:	b8 4e 00 00 00       	mov    $0x4e,%eax
    383b:	eb 4a                	jmp    3887 <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    383d:	8b 45 0c             	mov    0xc(%ebp),%eax
    3840:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3843:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    3845:	83 ec 0c             	sub    $0xc,%esp
    3848:	ff 75 f4             	pushl  -0xc(%ebp)
    384b:	e8 70 fb ff ff       	call   33c0 <lodepng_malloc>
    3850:	83 c4 10             	add    $0x10,%esp
    3853:	89 c2                	mov    %eax,%edx
    3855:	8b 45 08             	mov    0x8(%ebp),%eax
    3858:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    385a:	8b 45 08             	mov    0x8(%ebp),%eax
    385d:	8b 00                	mov    (%eax),%eax
    385f:	85 c0                	test   %eax,%eax
    3861:	75 0d                	jne    3870 <lodepng_load_file+0x57>
    3863:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3867:	7e 07                	jle    3870 <lodepng_load_file+0x57>
    3869:	b8 53 00 00 00       	mov    $0x53,%eax
    386e:	eb 17                	jmp    3887 <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    3870:	8b 45 08             	mov    0x8(%ebp),%eax
    3873:	8b 00                	mov    (%eax),%eax
    3875:	83 ec 04             	sub    $0x4,%esp
    3878:	ff 75 10             	pushl  0x10(%ebp)
    387b:	ff 75 f4             	pushl  -0xc(%ebp)
    387e:	50                   	push   %eax
    387f:	e8 54 ff ff ff       	call   37d8 <lodepng_buffer_file>
    3884:	83 c4 10             	add    $0x10,%esp
}
    3887:	c9                   	leave  
    3888:	c3                   	ret    

00003889 <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    3889:	55                   	push   %ebp
    388a:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    388c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3891:	5d                   	pop    %ebp
    3892:	c3                   	ret    

00003893 <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    3893:	55                   	push   %ebp
    3894:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    3896:	8b 45 08             	mov    0x8(%ebp),%eax
    3899:	8b 55 0c             	mov    0xc(%ebp),%edx
    389c:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    389e:	8b 45 08             	mov    0x8(%ebp),%eax
    38a1:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    38a5:	90                   	nop
    38a6:	5d                   	pop    %ebp
    38a7:	c3                   	ret    

000038a8 <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    38a8:	55                   	push   %ebp
    38a9:	89 e5                	mov    %esp,%ebp
    38ab:	56                   	push   %esi
    38ac:	53                   	push   %ebx
    38ad:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    38b0:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    38b4:	0f 85 aa 00 00 00    	jne    3964 <writeBits+0xbc>
    WRITEBIT(writer, value);
    38ba:	8b 45 08             	mov    0x8(%ebp),%eax
    38bd:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    38c1:	0f b6 c0             	movzbl %al,%eax
    38c4:	83 e0 07             	and    $0x7,%eax
    38c7:	85 c0                	test   %eax,%eax
    38c9:	75 39                	jne    3904 <writeBits+0x5c>
    38cb:	8b 45 08             	mov    0x8(%ebp),%eax
    38ce:	8b 00                	mov    (%eax),%eax
    38d0:	8b 40 04             	mov    0x4(%eax),%eax
    38d3:	8d 50 01             	lea    0x1(%eax),%edx
    38d6:	8b 45 08             	mov    0x8(%ebp),%eax
    38d9:	8b 00                	mov    (%eax),%eax
    38db:	52                   	push   %edx
    38dc:	50                   	push   %eax
    38dd:	e8 38 fd ff ff       	call   361a <ucvector_resize>
    38e2:	83 c4 08             	add    $0x8,%esp
    38e5:	85 c0                	test   %eax,%eax
    38e7:	0f 84 44 01 00 00    	je     3a31 <writeBits+0x189>
    38ed:	8b 45 08             	mov    0x8(%ebp),%eax
    38f0:	8b 00                	mov    (%eax),%eax
    38f2:	8b 10                	mov    (%eax),%edx
    38f4:	8b 45 08             	mov    0x8(%ebp),%eax
    38f7:	8b 00                	mov    (%eax),%eax
    38f9:	8b 40 04             	mov    0x4(%eax),%eax
    38fc:	83 e8 01             	sub    $0x1,%eax
    38ff:	01 d0                	add    %edx,%eax
    3901:	c6 00 00             	movb   $0x0,(%eax)
    3904:	8b 45 08             	mov    0x8(%ebp),%eax
    3907:	8b 00                	mov    (%eax),%eax
    3909:	8b 10                	mov    (%eax),%edx
    390b:	8b 45 08             	mov    0x8(%ebp),%eax
    390e:	8b 00                	mov    (%eax),%eax
    3910:	8b 40 04             	mov    0x4(%eax),%eax
    3913:	83 e8 01             	sub    $0x1,%eax
    3916:	01 c2                	add    %eax,%edx
    3918:	8b 45 08             	mov    0x8(%ebp),%eax
    391b:	8b 00                	mov    (%eax),%eax
    391d:	8b 08                	mov    (%eax),%ecx
    391f:	8b 45 08             	mov    0x8(%ebp),%eax
    3922:	8b 00                	mov    (%eax),%eax
    3924:	8b 40 04             	mov    0x4(%eax),%eax
    3927:	83 e8 01             	sub    $0x1,%eax
    392a:	01 c8                	add    %ecx,%eax
    392c:	0f b6 00             	movzbl (%eax),%eax
    392f:	88 45 e7             	mov    %al,-0x19(%ebp)
    3932:	8b 45 08             	mov    0x8(%ebp),%eax
    3935:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3939:	0f b6 c0             	movzbl %al,%eax
    393c:	83 e0 07             	and    $0x7,%eax
    393f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3942:	89 de                	mov    %ebx,%esi
    3944:	89 c1                	mov    %eax,%ecx
    3946:	d3 e6                	shl    %cl,%esi
    3948:	89 f0                	mov    %esi,%eax
    394a:	0a 45 e7             	or     -0x19(%ebp),%al
    394d:	88 02                	mov    %al,(%edx)
    394f:	8b 45 08             	mov    0x8(%ebp),%eax
    3952:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3956:	8d 50 01             	lea    0x1(%eax),%edx
    3959:	8b 45 08             	mov    0x8(%ebp),%eax
    395c:	88 50 04             	mov    %dl,0x4(%eax)
    395f:	e9 d1 00 00 00       	jmp    3a35 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3964:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    396b:	e9 b3 00 00 00       	jmp    3a23 <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3970:	8b 45 08             	mov    0x8(%ebp),%eax
    3973:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3977:	0f b6 c0             	movzbl %al,%eax
    397a:	83 e0 07             	and    $0x7,%eax
    397d:	85 c0                	test   %eax,%eax
    397f:	75 39                	jne    39ba <writeBits+0x112>
    3981:	8b 45 08             	mov    0x8(%ebp),%eax
    3984:	8b 00                	mov    (%eax),%eax
    3986:	8b 40 04             	mov    0x4(%eax),%eax
    3989:	8d 50 01             	lea    0x1(%eax),%edx
    398c:	8b 45 08             	mov    0x8(%ebp),%eax
    398f:	8b 00                	mov    (%eax),%eax
    3991:	52                   	push   %edx
    3992:	50                   	push   %eax
    3993:	e8 82 fc ff ff       	call   361a <ucvector_resize>
    3998:	83 c4 08             	add    $0x8,%esp
    399b:	85 c0                	test   %eax,%eax
    399d:	0f 84 91 00 00 00    	je     3a34 <writeBits+0x18c>
    39a3:	8b 45 08             	mov    0x8(%ebp),%eax
    39a6:	8b 00                	mov    (%eax),%eax
    39a8:	8b 10                	mov    (%eax),%edx
    39aa:	8b 45 08             	mov    0x8(%ebp),%eax
    39ad:	8b 00                	mov    (%eax),%eax
    39af:	8b 40 04             	mov    0x4(%eax),%eax
    39b2:	83 e8 01             	sub    $0x1,%eax
    39b5:	01 d0                	add    %edx,%eax
    39b7:	c6 00 00             	movb   $0x0,(%eax)
    39ba:	8b 45 08             	mov    0x8(%ebp),%eax
    39bd:	8b 00                	mov    (%eax),%eax
    39bf:	8b 10                	mov    (%eax),%edx
    39c1:	8b 45 08             	mov    0x8(%ebp),%eax
    39c4:	8b 00                	mov    (%eax),%eax
    39c6:	8b 40 04             	mov    0x4(%eax),%eax
    39c9:	83 e8 01             	sub    $0x1,%eax
    39cc:	01 c2                	add    %eax,%edx
    39ce:	8b 45 08             	mov    0x8(%ebp),%eax
    39d1:	8b 00                	mov    (%eax),%eax
    39d3:	8b 08                	mov    (%eax),%ecx
    39d5:	8b 45 08             	mov    0x8(%ebp),%eax
    39d8:	8b 00                	mov    (%eax),%eax
    39da:	8b 40 04             	mov    0x4(%eax),%eax
    39dd:	83 e8 01             	sub    $0x1,%eax
    39e0:	01 c8                	add    %ecx,%eax
    39e2:	0f b6 00             	movzbl (%eax),%eax
    39e5:	89 c6                	mov    %eax,%esi
    39e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    39ea:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    39ed:	89 c1                	mov    %eax,%ecx
    39ef:	d3 eb                	shr    %cl,%ebx
    39f1:	89 d8                	mov    %ebx,%eax
    39f3:	83 e0 01             	and    $0x1,%eax
    39f6:	89 c3                	mov    %eax,%ebx
    39f8:	8b 45 08             	mov    0x8(%ebp),%eax
    39fb:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    39ff:	0f b6 c0             	movzbl %al,%eax
    3a02:	83 e0 07             	and    $0x7,%eax
    3a05:	89 c1                	mov    %eax,%ecx
    3a07:	d3 e3                	shl    %cl,%ebx
    3a09:	89 d8                	mov    %ebx,%eax
    3a0b:	09 f0                	or     %esi,%eax
    3a0d:	88 02                	mov    %al,(%edx)
    3a0f:	8b 45 08             	mov    0x8(%ebp),%eax
    3a12:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a16:	8d 50 01             	lea    0x1(%eax),%edx
    3a19:	8b 45 08             	mov    0x8(%ebp),%eax
    3a1c:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3a1f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3a23:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a26:	3b 45 10             	cmp    0x10(%ebp),%eax
    3a29:	0f 85 41 ff ff ff    	jne    3970 <writeBits+0xc8>
    3a2f:	eb 04                	jmp    3a35 <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    3a31:	90                   	nop
    3a32:	eb 01                	jmp    3a35 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3a34:	90                   	nop
    }
  }
}
    3a35:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3a38:	5b                   	pop    %ebx
    3a39:	5e                   	pop    %esi
    3a3a:	5d                   	pop    %ebp
    3a3b:	c3                   	ret    

00003a3c <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3a3c:	55                   	push   %ebp
    3a3d:	89 e5                	mov    %esp,%ebp
    3a3f:	56                   	push   %esi
    3a40:	53                   	push   %ebx
    3a41:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3a44:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3a4b:	e9 bd 00 00 00       	jmp    3b0d <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3a50:	8b 45 08             	mov    0x8(%ebp),%eax
    3a53:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a57:	0f b6 c0             	movzbl %al,%eax
    3a5a:	83 e0 07             	and    $0x7,%eax
    3a5d:	85 c0                	test   %eax,%eax
    3a5f:	75 39                	jne    3a9a <writeBitsReversed+0x5e>
    3a61:	8b 45 08             	mov    0x8(%ebp),%eax
    3a64:	8b 00                	mov    (%eax),%eax
    3a66:	8b 40 04             	mov    0x4(%eax),%eax
    3a69:	8d 50 01             	lea    0x1(%eax),%edx
    3a6c:	8b 45 08             	mov    0x8(%ebp),%eax
    3a6f:	8b 00                	mov    (%eax),%eax
    3a71:	52                   	push   %edx
    3a72:	50                   	push   %eax
    3a73:	e8 a2 fb ff ff       	call   361a <ucvector_resize>
    3a78:	83 c4 08             	add    $0x8,%esp
    3a7b:	85 c0                	test   %eax,%eax
    3a7d:	0f 84 98 00 00 00    	je     3b1b <writeBitsReversed+0xdf>
    3a83:	8b 45 08             	mov    0x8(%ebp),%eax
    3a86:	8b 00                	mov    (%eax),%eax
    3a88:	8b 10                	mov    (%eax),%edx
    3a8a:	8b 45 08             	mov    0x8(%ebp),%eax
    3a8d:	8b 00                	mov    (%eax),%eax
    3a8f:	8b 40 04             	mov    0x4(%eax),%eax
    3a92:	83 e8 01             	sub    $0x1,%eax
    3a95:	01 d0                	add    %edx,%eax
    3a97:	c6 00 00             	movb   $0x0,(%eax)
    3a9a:	8b 45 08             	mov    0x8(%ebp),%eax
    3a9d:	8b 00                	mov    (%eax),%eax
    3a9f:	8b 10                	mov    (%eax),%edx
    3aa1:	8b 45 08             	mov    0x8(%ebp),%eax
    3aa4:	8b 00                	mov    (%eax),%eax
    3aa6:	8b 40 04             	mov    0x4(%eax),%eax
    3aa9:	83 e8 01             	sub    $0x1,%eax
    3aac:	01 c2                	add    %eax,%edx
    3aae:	8b 45 08             	mov    0x8(%ebp),%eax
    3ab1:	8b 00                	mov    (%eax),%eax
    3ab3:	8b 08                	mov    (%eax),%ecx
    3ab5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ab8:	8b 00                	mov    (%eax),%eax
    3aba:	8b 40 04             	mov    0x4(%eax),%eax
    3abd:	83 e8 01             	sub    $0x1,%eax
    3ac0:	01 c8                	add    %ecx,%eax
    3ac2:	0f b6 00             	movzbl (%eax),%eax
    3ac5:	89 c6                	mov    %eax,%esi
    3ac7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3acd:	29 c1                	sub    %eax,%ecx
    3acf:	89 c8                	mov    %ecx,%eax
    3ad1:	83 e8 01             	sub    $0x1,%eax
    3ad4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3ad7:	89 c1                	mov    %eax,%ecx
    3ad9:	d3 eb                	shr    %cl,%ebx
    3adb:	89 d8                	mov    %ebx,%eax
    3add:	83 e0 01             	and    $0x1,%eax
    3ae0:	89 c3                	mov    %eax,%ebx
    3ae2:	8b 45 08             	mov    0x8(%ebp),%eax
    3ae5:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3ae9:	0f b6 c0             	movzbl %al,%eax
    3aec:	83 e0 07             	and    $0x7,%eax
    3aef:	89 c1                	mov    %eax,%ecx
    3af1:	d3 e3                	shl    %cl,%ebx
    3af3:	89 d8                	mov    %ebx,%eax
    3af5:	09 f0                	or     %esi,%eax
    3af7:	88 02                	mov    %al,(%edx)
    3af9:	8b 45 08             	mov    0x8(%ebp),%eax
    3afc:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3b00:	8d 50 01             	lea    0x1(%eax),%edx
    3b03:	8b 45 08             	mov    0x8(%ebp),%eax
    3b06:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3b09:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3b0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3b10:	3b 45 10             	cmp    0x10(%ebp),%eax
    3b13:	0f 85 37 ff ff ff    	jne    3a50 <writeBitsReversed+0x14>
    3b19:	eb 01                	jmp    3b1c <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3b1b:	90                   	nop
  }
}
    3b1c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3b1f:	5b                   	pop    %ebx
    3b20:	5e                   	pop    %esi
    3b21:	5d                   	pop    %ebp
    3b22:	c3                   	ret    

00003b23 <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    3b23:	55                   	push   %ebp
    3b24:	89 e5                	mov    %esp,%ebp
    3b26:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    3b29:	8b 45 08             	mov    0x8(%ebp),%eax
    3b2c:	8b 55 0c             	mov    0xc(%ebp),%edx
    3b2f:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    3b31:	8b 45 08             	mov    0x8(%ebp),%eax
    3b34:	8b 55 10             	mov    0x10(%ebp),%edx
    3b37:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    3b3a:	8b 45 08             	mov    0x8(%ebp),%eax
    3b3d:	83 c0 08             	add    $0x8,%eax
    3b40:	50                   	push   %eax
    3b41:	6a 08                	push   $0x8
    3b43:	ff 75 10             	pushl  0x10(%ebp)
    3b46:	e8 59 f9 ff ff       	call   34a4 <lodepng_mulofl>
    3b4b:	83 c4 0c             	add    $0xc,%esp
    3b4e:	85 c0                	test   %eax,%eax
    3b50:	74 07                	je     3b59 <LodePNGBitReader_init+0x36>
    3b52:	b8 69 00 00 00       	mov    $0x69,%eax
    3b57:	eb 39                	jmp    3b92 <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    3b59:	8b 45 08             	mov    0x8(%ebp),%eax
    3b5c:	8b 40 08             	mov    0x8(%eax),%eax
    3b5f:	8d 55 fc             	lea    -0x4(%ebp),%edx
    3b62:	52                   	push   %edx
    3b63:	6a 40                	push   $0x40
    3b65:	50                   	push   %eax
    3b66:	e8 19 f9 ff ff       	call   3484 <lodepng_addofl>
    3b6b:	83 c4 0c             	add    $0xc,%esp
    3b6e:	85 c0                	test   %eax,%eax
    3b70:	74 07                	je     3b79 <LodePNGBitReader_init+0x56>
    3b72:	b8 69 00 00 00       	mov    $0x69,%eax
    3b77:	eb 19                	jmp    3b92 <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    3b79:	8b 45 08             	mov    0x8(%ebp),%eax
    3b7c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    3b83:	8b 45 08             	mov    0x8(%ebp),%eax
    3b86:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    3b8d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3b92:	c9                   	leave  
    3b93:	c3                   	ret    

00003b94 <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    3b94:	55                   	push   %ebp
    3b95:	89 e5                	mov    %esp,%ebp
    3b97:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3b9a:	8b 45 08             	mov    0x8(%ebp),%eax
    3b9d:	8b 40 0c             	mov    0xc(%eax),%eax
    3ba0:	c1 f8 03             	sar    $0x3,%eax
    3ba3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3ba6:	8b 45 08             	mov    0x8(%ebp),%eax
    3ba9:	8b 40 04             	mov    0x4(%eax),%eax
    3bac:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    3baf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3bb2:	8d 50 01             	lea    0x1(%eax),%edx
    3bb5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3bb8:	39 c2                	cmp    %eax,%edx
    3bba:	73 4e                	jae    3c0a <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    3bbc:	8b 45 08             	mov    0x8(%ebp),%eax
    3bbf:	8b 10                	mov    (%eax),%edx
    3bc1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3bc4:	01 d0                	add    %edx,%eax
    3bc6:	0f b6 00             	movzbl (%eax),%eax
    3bc9:	0f b6 d0             	movzbl %al,%edx
    3bcc:	8b 45 08             	mov    0x8(%ebp),%eax
    3bcf:	8b 00                	mov    (%eax),%eax
    3bd1:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3bd4:	83 c1 01             	add    $0x1,%ecx
    3bd7:	01 c8                	add    %ecx,%eax
    3bd9:	0f b6 00             	movzbl (%eax),%eax
    3bdc:	0f b6 c0             	movzbl %al,%eax
    3bdf:	c1 e0 08             	shl    $0x8,%eax
    3be2:	09 c2                	or     %eax,%edx
    3be4:	8b 45 08             	mov    0x8(%ebp),%eax
    3be7:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3bea:	8b 45 08             	mov    0x8(%ebp),%eax
    3bed:	8b 50 10             	mov    0x10(%eax),%edx
    3bf0:	8b 45 08             	mov    0x8(%ebp),%eax
    3bf3:	8b 40 0c             	mov    0xc(%eax),%eax
    3bf6:	83 e0 07             	and    $0x7,%eax
    3bf9:	89 c1                	mov    %eax,%ecx
    3bfb:	d3 ea                	shr    %cl,%edx
    3bfd:	8b 45 08             	mov    0x8(%ebp),%eax
    3c00:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3c03:	b8 01 00 00 00       	mov    $0x1,%eax
    3c08:	eb 64                	jmp    3c6e <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    3c0a:	8b 45 08             	mov    0x8(%ebp),%eax
    3c0d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3c14:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3c17:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c1a:	39 c2                	cmp    %eax,%edx
    3c1c:	73 1e                	jae    3c3c <ensureBits9+0xa8>
    3c1e:	8b 45 08             	mov    0x8(%ebp),%eax
    3c21:	8b 50 10             	mov    0x10(%eax),%edx
    3c24:	8b 45 08             	mov    0x8(%ebp),%eax
    3c27:	8b 08                	mov    (%eax),%ecx
    3c29:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c2c:	01 c8                	add    %ecx,%eax
    3c2e:	0f b6 00             	movzbl (%eax),%eax
    3c31:	0f b6 c0             	movzbl %al,%eax
    3c34:	09 c2                	or     %eax,%edx
    3c36:	8b 45 08             	mov    0x8(%ebp),%eax
    3c39:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3c3c:	8b 45 08             	mov    0x8(%ebp),%eax
    3c3f:	8b 50 10             	mov    0x10(%eax),%edx
    3c42:	8b 45 08             	mov    0x8(%ebp),%eax
    3c45:	8b 40 0c             	mov    0xc(%eax),%eax
    3c48:	83 e0 07             	and    $0x7,%eax
    3c4b:	89 c1                	mov    %eax,%ecx
    3c4d:	d3 ea                	shr    %cl,%edx
    3c4f:	8b 45 08             	mov    0x8(%ebp),%eax
    3c52:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3c55:	8b 45 08             	mov    0x8(%ebp),%eax
    3c58:	8b 50 0c             	mov    0xc(%eax),%edx
    3c5b:	8b 45 0c             	mov    0xc(%ebp),%eax
    3c5e:	01 c2                	add    %eax,%edx
    3c60:	8b 45 08             	mov    0x8(%ebp),%eax
    3c63:	8b 40 08             	mov    0x8(%eax),%eax
    3c66:	39 c2                	cmp    %eax,%edx
    3c68:	0f 9e c0             	setle  %al
    3c6b:	0f b6 c0             	movzbl %al,%eax
  }
}
    3c6e:	c9                   	leave  
    3c6f:	c3                   	ret    

00003c70 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    3c70:	55                   	push   %ebp
    3c71:	89 e5                	mov    %esp,%ebp
    3c73:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3c76:	8b 45 08             	mov    0x8(%ebp),%eax
    3c79:	8b 40 0c             	mov    0xc(%eax),%eax
    3c7c:	c1 f8 03             	sar    $0x3,%eax
    3c7f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3c82:	8b 45 08             	mov    0x8(%ebp),%eax
    3c85:	8b 40 04             	mov    0x4(%eax),%eax
    3c88:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    3c8b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c8e:	8d 50 02             	lea    0x2(%eax),%edx
    3c91:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c94:	39 c2                	cmp    %eax,%edx
    3c96:	73 6d                	jae    3d05 <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3c98:	8b 45 08             	mov    0x8(%ebp),%eax
    3c9b:	8b 10                	mov    (%eax),%edx
    3c9d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ca0:	01 d0                	add    %edx,%eax
    3ca2:	0f b6 00             	movzbl (%eax),%eax
    3ca5:	0f b6 d0             	movzbl %al,%edx
    3ca8:	8b 45 08             	mov    0x8(%ebp),%eax
    3cab:	8b 00                	mov    (%eax),%eax
    3cad:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3cb0:	83 c1 01             	add    $0x1,%ecx
    3cb3:	01 c8                	add    %ecx,%eax
    3cb5:	0f b6 00             	movzbl (%eax),%eax
    3cb8:	0f b6 c0             	movzbl %al,%eax
    3cbb:	c1 e0 08             	shl    $0x8,%eax
    3cbe:	89 d1                	mov    %edx,%ecx
    3cc0:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    3cc2:	8b 45 08             	mov    0x8(%ebp),%eax
    3cc5:	8b 00                	mov    (%eax),%eax
    3cc7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3cca:	83 c2 02             	add    $0x2,%edx
    3ccd:	01 d0                	add    %edx,%eax
    3ccf:	0f b6 00             	movzbl (%eax),%eax
    3cd2:	0f b6 c0             	movzbl %al,%eax
    3cd5:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3cd8:	09 c1                	or     %eax,%ecx
    3cda:	89 ca                	mov    %ecx,%edx
    3cdc:	8b 45 08             	mov    0x8(%ebp),%eax
    3cdf:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    3ce2:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce5:	8b 50 10             	mov    0x10(%eax),%edx
    3ce8:	8b 45 08             	mov    0x8(%ebp),%eax
    3ceb:	8b 40 0c             	mov    0xc(%eax),%eax
    3cee:	83 e0 07             	and    $0x7,%eax
    3cf1:	89 c1                	mov    %eax,%ecx
    3cf3:	d3 ea                	shr    %cl,%edx
    3cf5:	8b 45 08             	mov    0x8(%ebp),%eax
    3cf8:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3cfb:	b8 01 00 00 00       	mov    $0x1,%eax
    3d00:	e9 95 00 00 00       	jmp    3d9a <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    3d05:	8b 45 08             	mov    0x8(%ebp),%eax
    3d08:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3d0f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d12:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3d15:	39 c2                	cmp    %eax,%edx
    3d17:	73 1e                	jae    3d37 <ensureBits17+0xc7>
    3d19:	8b 45 08             	mov    0x8(%ebp),%eax
    3d1c:	8b 50 10             	mov    0x10(%eax),%edx
    3d1f:	8b 45 08             	mov    0x8(%ebp),%eax
    3d22:	8b 08                	mov    (%eax),%ecx
    3d24:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d27:	01 c8                	add    %ecx,%eax
    3d29:	0f b6 00             	movzbl (%eax),%eax
    3d2c:	0f b6 c0             	movzbl %al,%eax
    3d2f:	09 c2                	or     %eax,%edx
    3d31:	8b 45 08             	mov    0x8(%ebp),%eax
    3d34:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3d37:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d3a:	8d 50 01             	lea    0x1(%eax),%edx
    3d3d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3d40:	39 c2                	cmp    %eax,%edx
    3d42:	73 24                	jae    3d68 <ensureBits17+0xf8>
    3d44:	8b 45 08             	mov    0x8(%ebp),%eax
    3d47:	8b 50 10             	mov    0x10(%eax),%edx
    3d4a:	8b 45 08             	mov    0x8(%ebp),%eax
    3d4d:	8b 00                	mov    (%eax),%eax
    3d4f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3d52:	83 c1 01             	add    $0x1,%ecx
    3d55:	01 c8                	add    %ecx,%eax
    3d57:	0f b6 00             	movzbl (%eax),%eax
    3d5a:	0f b6 c0             	movzbl %al,%eax
    3d5d:	c1 e0 08             	shl    $0x8,%eax
    3d60:	09 c2                	or     %eax,%edx
    3d62:	8b 45 08             	mov    0x8(%ebp),%eax
    3d65:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3d68:	8b 45 08             	mov    0x8(%ebp),%eax
    3d6b:	8b 50 10             	mov    0x10(%eax),%edx
    3d6e:	8b 45 08             	mov    0x8(%ebp),%eax
    3d71:	8b 40 0c             	mov    0xc(%eax),%eax
    3d74:	83 e0 07             	and    $0x7,%eax
    3d77:	89 c1                	mov    %eax,%ecx
    3d79:	d3 ea                	shr    %cl,%edx
    3d7b:	8b 45 08             	mov    0x8(%ebp),%eax
    3d7e:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3d81:	8b 45 08             	mov    0x8(%ebp),%eax
    3d84:	8b 50 0c             	mov    0xc(%eax),%edx
    3d87:	8b 45 0c             	mov    0xc(%ebp),%eax
    3d8a:	01 c2                	add    %eax,%edx
    3d8c:	8b 45 08             	mov    0x8(%ebp),%eax
    3d8f:	8b 40 08             	mov    0x8(%eax),%eax
    3d92:	39 c2                	cmp    %eax,%edx
    3d94:	0f 9e c0             	setle  %al
    3d97:	0f b6 c0             	movzbl %al,%eax
  }
}
    3d9a:	c9                   	leave  
    3d9b:	c3                   	ret    

00003d9c <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    3d9c:	55                   	push   %ebp
    3d9d:	89 e5                	mov    %esp,%ebp
    3d9f:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3da2:	8b 45 08             	mov    0x8(%ebp),%eax
    3da5:	8b 40 0c             	mov    0xc(%eax),%eax
    3da8:	c1 f8 03             	sar    $0x3,%eax
    3dab:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3dae:	8b 45 08             	mov    0x8(%ebp),%eax
    3db1:	8b 40 04             	mov    0x4(%eax),%eax
    3db4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    3db7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3dba:	8d 50 03             	lea    0x3(%eax),%edx
    3dbd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3dc0:	39 c2                	cmp    %eax,%edx
    3dc2:	0f 83 85 00 00 00    	jae    3e4d <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3dc8:	8b 45 08             	mov    0x8(%ebp),%eax
    3dcb:	8b 10                	mov    (%eax),%edx
    3dcd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3dd0:	01 d0                	add    %edx,%eax
    3dd2:	0f b6 00             	movzbl (%eax),%eax
    3dd5:	0f b6 d0             	movzbl %al,%edx
    3dd8:	8b 45 08             	mov    0x8(%ebp),%eax
    3ddb:	8b 00                	mov    (%eax),%eax
    3ddd:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3de0:	83 c1 01             	add    $0x1,%ecx
    3de3:	01 c8                	add    %ecx,%eax
    3de5:	0f b6 00             	movzbl (%eax),%eax
    3de8:	0f b6 c0             	movzbl %al,%eax
    3deb:	c1 e0 08             	shl    $0x8,%eax
    3dee:	89 d1                	mov    %edx,%ecx
    3df0:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3df2:	8b 45 08             	mov    0x8(%ebp),%eax
    3df5:	8b 00                	mov    (%eax),%eax
    3df7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3dfa:	83 c2 02             	add    $0x2,%edx
    3dfd:	01 d0                	add    %edx,%eax
    3dff:	0f b6 00             	movzbl (%eax),%eax
    3e02:	0f b6 c0             	movzbl %al,%eax
    3e05:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3e08:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3e0a:	8b 45 08             	mov    0x8(%ebp),%eax
    3e0d:	8b 00                	mov    (%eax),%eax
    3e0f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3e12:	83 c2 03             	add    $0x3,%edx
    3e15:	01 d0                	add    %edx,%eax
    3e17:	0f b6 00             	movzbl (%eax),%eax
    3e1a:	0f b6 c0             	movzbl %al,%eax
    3e1d:	c1 e0 18             	shl    $0x18,%eax
    3e20:	09 c1                	or     %eax,%ecx
    3e22:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3e24:	8b 45 08             	mov    0x8(%ebp),%eax
    3e27:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3e2a:	8b 45 08             	mov    0x8(%ebp),%eax
    3e2d:	8b 50 10             	mov    0x10(%eax),%edx
    3e30:	8b 45 08             	mov    0x8(%ebp),%eax
    3e33:	8b 40 0c             	mov    0xc(%eax),%eax
    3e36:	83 e0 07             	and    $0x7,%eax
    3e39:	89 c1                	mov    %eax,%ecx
    3e3b:	d3 ea                	shr    %cl,%edx
    3e3d:	8b 45 08             	mov    0x8(%ebp),%eax
    3e40:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3e43:	b8 01 00 00 00       	mov    $0x1,%eax
    3e48:	e9 c6 00 00 00       	jmp    3f13 <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    3e4d:	8b 45 08             	mov    0x8(%ebp),%eax
    3e50:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3e57:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3e5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e5d:	39 c2                	cmp    %eax,%edx
    3e5f:	73 1e                	jae    3e7f <ensureBits25+0xe3>
    3e61:	8b 45 08             	mov    0x8(%ebp),%eax
    3e64:	8b 50 10             	mov    0x10(%eax),%edx
    3e67:	8b 45 08             	mov    0x8(%ebp),%eax
    3e6a:	8b 08                	mov    (%eax),%ecx
    3e6c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e6f:	01 c8                	add    %ecx,%eax
    3e71:	0f b6 00             	movzbl (%eax),%eax
    3e74:	0f b6 c0             	movzbl %al,%eax
    3e77:	09 c2                	or     %eax,%edx
    3e79:	8b 45 08             	mov    0x8(%ebp),%eax
    3e7c:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3e7f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e82:	8d 50 01             	lea    0x1(%eax),%edx
    3e85:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e88:	39 c2                	cmp    %eax,%edx
    3e8a:	73 24                	jae    3eb0 <ensureBits25+0x114>
    3e8c:	8b 45 08             	mov    0x8(%ebp),%eax
    3e8f:	8b 50 10             	mov    0x10(%eax),%edx
    3e92:	8b 45 08             	mov    0x8(%ebp),%eax
    3e95:	8b 00                	mov    (%eax),%eax
    3e97:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3e9a:	83 c1 01             	add    $0x1,%ecx
    3e9d:	01 c8                	add    %ecx,%eax
    3e9f:	0f b6 00             	movzbl (%eax),%eax
    3ea2:	0f b6 c0             	movzbl %al,%eax
    3ea5:	c1 e0 08             	shl    $0x8,%eax
    3ea8:	09 c2                	or     %eax,%edx
    3eaa:	8b 45 08             	mov    0x8(%ebp),%eax
    3ead:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3eb0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3eb3:	8d 50 02             	lea    0x2(%eax),%edx
    3eb6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3eb9:	39 c2                	cmp    %eax,%edx
    3ebb:	73 24                	jae    3ee1 <ensureBits25+0x145>
    3ebd:	8b 45 08             	mov    0x8(%ebp),%eax
    3ec0:	8b 50 10             	mov    0x10(%eax),%edx
    3ec3:	8b 45 08             	mov    0x8(%ebp),%eax
    3ec6:	8b 00                	mov    (%eax),%eax
    3ec8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3ecb:	83 c1 02             	add    $0x2,%ecx
    3ece:	01 c8                	add    %ecx,%eax
    3ed0:	0f b6 00             	movzbl (%eax),%eax
    3ed3:	0f b6 c0             	movzbl %al,%eax
    3ed6:	c1 e0 10             	shl    $0x10,%eax
    3ed9:	09 c2                	or     %eax,%edx
    3edb:	8b 45 08             	mov    0x8(%ebp),%eax
    3ede:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3ee1:	8b 45 08             	mov    0x8(%ebp),%eax
    3ee4:	8b 50 10             	mov    0x10(%eax),%edx
    3ee7:	8b 45 08             	mov    0x8(%ebp),%eax
    3eea:	8b 40 0c             	mov    0xc(%eax),%eax
    3eed:	83 e0 07             	and    $0x7,%eax
    3ef0:	89 c1                	mov    %eax,%ecx
    3ef2:	d3 ea                	shr    %cl,%edx
    3ef4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ef7:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3efa:	8b 45 08             	mov    0x8(%ebp),%eax
    3efd:	8b 50 0c             	mov    0xc(%eax),%edx
    3f00:	8b 45 0c             	mov    0xc(%ebp),%eax
    3f03:	01 c2                	add    %eax,%edx
    3f05:	8b 45 08             	mov    0x8(%ebp),%eax
    3f08:	8b 40 08             	mov    0x8(%eax),%eax
    3f0b:	39 c2                	cmp    %eax,%edx
    3f0d:	0f 9e c0             	setle  %al
    3f10:	0f b6 c0             	movzbl %al,%eax
  }
}
    3f13:	c9                   	leave  
    3f14:	c3                   	ret    

00003f15 <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    3f15:	55                   	push   %ebp
    3f16:	89 e5                	mov    %esp,%ebp
    3f18:	53                   	push   %ebx
    3f19:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3f1c:	8b 45 08             	mov    0x8(%ebp),%eax
    3f1f:	8b 40 0c             	mov    0xc(%eax),%eax
    3f22:	c1 f8 03             	sar    $0x3,%eax
    3f25:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    3f28:	8b 45 08             	mov    0x8(%ebp),%eax
    3f2b:	8b 40 04             	mov    0x4(%eax),%eax
    3f2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    3f31:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f34:	8d 50 04             	lea    0x4(%eax),%edx
    3f37:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3f3a:	39 c2                	cmp    %eax,%edx
    3f3c:	0f 83 c3 00 00 00    	jae    4005 <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3f42:	8b 45 08             	mov    0x8(%ebp),%eax
    3f45:	8b 10                	mov    (%eax),%edx
    3f47:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f4a:	01 d0                	add    %edx,%eax
    3f4c:	0f b6 00             	movzbl (%eax),%eax
    3f4f:	0f b6 d0             	movzbl %al,%edx
    3f52:	8b 45 08             	mov    0x8(%ebp),%eax
    3f55:	8b 00                	mov    (%eax),%eax
    3f57:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3f5a:	83 c1 01             	add    $0x1,%ecx
    3f5d:	01 c8                	add    %ecx,%eax
    3f5f:	0f b6 00             	movzbl (%eax),%eax
    3f62:	0f b6 c0             	movzbl %al,%eax
    3f65:	c1 e0 08             	shl    $0x8,%eax
    3f68:	89 d1                	mov    %edx,%ecx
    3f6a:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3f6c:	8b 45 08             	mov    0x8(%ebp),%eax
    3f6f:	8b 00                	mov    (%eax),%eax
    3f71:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3f74:	83 c2 02             	add    $0x2,%edx
    3f77:	01 d0                	add    %edx,%eax
    3f79:	0f b6 00             	movzbl (%eax),%eax
    3f7c:	0f b6 c0             	movzbl %al,%eax
    3f7f:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3f82:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3f84:	8b 45 08             	mov    0x8(%ebp),%eax
    3f87:	8b 00                	mov    (%eax),%eax
    3f89:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3f8c:	83 c2 03             	add    $0x3,%edx
    3f8f:	01 d0                	add    %edx,%eax
    3f91:	0f b6 00             	movzbl (%eax),%eax
    3f94:	0f b6 c0             	movzbl %al,%eax
    3f97:	c1 e0 18             	shl    $0x18,%eax
    3f9a:	09 c1                	or     %eax,%ecx
    3f9c:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3f9e:	8b 45 08             	mov    0x8(%ebp),%eax
    3fa1:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3fa4:	8b 45 08             	mov    0x8(%ebp),%eax
    3fa7:	8b 50 10             	mov    0x10(%eax),%edx
    3faa:	8b 45 08             	mov    0x8(%ebp),%eax
    3fad:	8b 40 0c             	mov    0xc(%eax),%eax
    3fb0:	83 e0 07             	and    $0x7,%eax
    3fb3:	89 c1                	mov    %eax,%ecx
    3fb5:	d3 ea                	shr    %cl,%edx
    3fb7:	8b 45 08             	mov    0x8(%ebp),%eax
    3fba:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    3fbd:	8b 45 08             	mov    0x8(%ebp),%eax
    3fc0:	8b 50 10             	mov    0x10(%eax),%edx
    3fc3:	8b 45 08             	mov    0x8(%ebp),%eax
    3fc6:	8b 00                	mov    (%eax),%eax
    3fc8:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3fcb:	83 c1 04             	add    $0x4,%ecx
    3fce:	01 c8                	add    %ecx,%eax
    3fd0:	0f b6 00             	movzbl (%eax),%eax
    3fd3:	0f b6 c0             	movzbl %al,%eax
    3fd6:	c1 e0 18             	shl    $0x18,%eax
    3fd9:	89 c3                	mov    %eax,%ebx
    3fdb:	8b 45 08             	mov    0x8(%ebp),%eax
    3fde:	8b 40 0c             	mov    0xc(%eax),%eax
    3fe1:	83 e0 07             	and    $0x7,%eax
    3fe4:	b9 08 00 00 00       	mov    $0x8,%ecx
    3fe9:	29 c1                	sub    %eax,%ecx
    3feb:	89 c8                	mov    %ecx,%eax
    3fed:	89 c1                	mov    %eax,%ecx
    3fef:	d3 e3                	shl    %cl,%ebx
    3ff1:	89 d8                	mov    %ebx,%eax
    3ff3:	09 c2                	or     %eax,%edx
    3ff5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ff8:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3ffb:	b8 01 00 00 00       	mov    $0x1,%eax
    4000:	e9 f7 00 00 00       	jmp    40fc <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    4005:	8b 45 08             	mov    0x8(%ebp),%eax
    4008:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    400f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4012:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4015:	39 c2                	cmp    %eax,%edx
    4017:	73 1e                	jae    4037 <ensureBits32+0x122>
    4019:	8b 45 08             	mov    0x8(%ebp),%eax
    401c:	8b 50 10             	mov    0x10(%eax),%edx
    401f:	8b 45 08             	mov    0x8(%ebp),%eax
    4022:	8b 08                	mov    (%eax),%ecx
    4024:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4027:	01 c8                	add    %ecx,%eax
    4029:	0f b6 00             	movzbl (%eax),%eax
    402c:	0f b6 c0             	movzbl %al,%eax
    402f:	09 c2                	or     %eax,%edx
    4031:	8b 45 08             	mov    0x8(%ebp),%eax
    4034:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    4037:	8b 45 f8             	mov    -0x8(%ebp),%eax
    403a:	8d 50 01             	lea    0x1(%eax),%edx
    403d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4040:	39 c2                	cmp    %eax,%edx
    4042:	73 24                	jae    4068 <ensureBits32+0x153>
    4044:	8b 45 08             	mov    0x8(%ebp),%eax
    4047:	8b 50 10             	mov    0x10(%eax),%edx
    404a:	8b 45 08             	mov    0x8(%ebp),%eax
    404d:	8b 00                	mov    (%eax),%eax
    404f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4052:	83 c1 01             	add    $0x1,%ecx
    4055:	01 c8                	add    %ecx,%eax
    4057:	0f b6 00             	movzbl (%eax),%eax
    405a:	0f b6 c0             	movzbl %al,%eax
    405d:	c1 e0 08             	shl    $0x8,%eax
    4060:	09 c2                	or     %eax,%edx
    4062:	8b 45 08             	mov    0x8(%ebp),%eax
    4065:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    4068:	8b 45 f8             	mov    -0x8(%ebp),%eax
    406b:	8d 50 02             	lea    0x2(%eax),%edx
    406e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4071:	39 c2                	cmp    %eax,%edx
    4073:	73 24                	jae    4099 <ensureBits32+0x184>
    4075:	8b 45 08             	mov    0x8(%ebp),%eax
    4078:	8b 50 10             	mov    0x10(%eax),%edx
    407b:	8b 45 08             	mov    0x8(%ebp),%eax
    407e:	8b 00                	mov    (%eax),%eax
    4080:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4083:	83 c1 02             	add    $0x2,%ecx
    4086:	01 c8                	add    %ecx,%eax
    4088:	0f b6 00             	movzbl (%eax),%eax
    408b:	0f b6 c0             	movzbl %al,%eax
    408e:	c1 e0 10             	shl    $0x10,%eax
    4091:	09 c2                	or     %eax,%edx
    4093:	8b 45 08             	mov    0x8(%ebp),%eax
    4096:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    4099:	8b 45 f8             	mov    -0x8(%ebp),%eax
    409c:	8d 50 03             	lea    0x3(%eax),%edx
    409f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    40a2:	39 c2                	cmp    %eax,%edx
    40a4:	73 24                	jae    40ca <ensureBits32+0x1b5>
    40a6:	8b 45 08             	mov    0x8(%ebp),%eax
    40a9:	8b 50 10             	mov    0x10(%eax),%edx
    40ac:	8b 45 08             	mov    0x8(%ebp),%eax
    40af:	8b 00                	mov    (%eax),%eax
    40b1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    40b4:	83 c1 03             	add    $0x3,%ecx
    40b7:	01 c8                	add    %ecx,%eax
    40b9:	0f b6 00             	movzbl (%eax),%eax
    40bc:	0f b6 c0             	movzbl %al,%eax
    40bf:	c1 e0 18             	shl    $0x18,%eax
    40c2:	09 c2                	or     %eax,%edx
    40c4:	8b 45 08             	mov    0x8(%ebp),%eax
    40c7:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    40ca:	8b 45 08             	mov    0x8(%ebp),%eax
    40cd:	8b 50 10             	mov    0x10(%eax),%edx
    40d0:	8b 45 08             	mov    0x8(%ebp),%eax
    40d3:	8b 40 0c             	mov    0xc(%eax),%eax
    40d6:	83 e0 07             	and    $0x7,%eax
    40d9:	89 c1                	mov    %eax,%ecx
    40db:	d3 ea                	shr    %cl,%edx
    40dd:	8b 45 08             	mov    0x8(%ebp),%eax
    40e0:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    40e3:	8b 45 08             	mov    0x8(%ebp),%eax
    40e6:	8b 50 0c             	mov    0xc(%eax),%edx
    40e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    40ec:	01 c2                	add    %eax,%edx
    40ee:	8b 45 08             	mov    0x8(%ebp),%eax
    40f1:	8b 40 08             	mov    0x8(%eax),%eax
    40f4:	39 c2                	cmp    %eax,%edx
    40f6:	0f 9e c0             	setle  %al
    40f9:	0f b6 c0             	movzbl %al,%eax
  }
}
    40fc:	83 c4 10             	add    $0x10,%esp
    40ff:	5b                   	pop    %ebx
    4100:	5d                   	pop    %ebp
    4101:	c3                   	ret    

00004102 <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    4102:	55                   	push   %ebp
    4103:	89 e5                	mov    %esp,%ebp
    4105:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    4106:	8b 45 08             	mov    0x8(%ebp),%eax
    4109:	8b 50 10             	mov    0x10(%eax),%edx
    410c:	8b 45 0c             	mov    0xc(%ebp),%eax
    410f:	bb 01 00 00 00       	mov    $0x1,%ebx
    4114:	89 c1                	mov    %eax,%ecx
    4116:	d3 e3                	shl    %cl,%ebx
    4118:	89 d8                	mov    %ebx,%eax
    411a:	83 e8 01             	sub    $0x1,%eax
    411d:	21 d0                	and    %edx,%eax
}
    411f:	5b                   	pop    %ebx
    4120:	5d                   	pop    %ebp
    4121:	c3                   	ret    

00004122 <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    4122:	55                   	push   %ebp
    4123:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    4125:	8b 45 08             	mov    0x8(%ebp),%eax
    4128:	8b 50 10             	mov    0x10(%eax),%edx
    412b:	8b 45 0c             	mov    0xc(%ebp),%eax
    412e:	89 c1                	mov    %eax,%ecx
    4130:	d3 ea                	shr    %cl,%edx
    4132:	8b 45 08             	mov    0x8(%ebp),%eax
    4135:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    4138:	8b 45 08             	mov    0x8(%ebp),%eax
    413b:	8b 50 0c             	mov    0xc(%eax),%edx
    413e:	8b 45 0c             	mov    0xc(%ebp),%eax
    4141:	01 c2                	add    %eax,%edx
    4143:	8b 45 08             	mov    0x8(%ebp),%eax
    4146:	89 50 0c             	mov    %edx,0xc(%eax)
}
    4149:	90                   	nop
    414a:	5d                   	pop    %ebp
    414b:	c3                   	ret    

0000414c <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    414c:	55                   	push   %ebp
    414d:	89 e5                	mov    %esp,%ebp
    414f:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    4152:	ff 75 0c             	pushl  0xc(%ebp)
    4155:	ff 75 08             	pushl  0x8(%ebp)
    4158:	e8 a5 ff ff ff       	call   4102 <peekBits>
    415d:	83 c4 08             	add    $0x8,%esp
    4160:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    4163:	ff 75 0c             	pushl  0xc(%ebp)
    4166:	ff 75 08             	pushl  0x8(%ebp)
    4169:	e8 b4 ff ff ff       	call   4122 <advanceBits>
    416e:	83 c4 08             	add    $0x8,%esp
  return result;
    4171:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    4174:	c9                   	leave  
    4175:	c3                   	ret    

00004176 <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    4176:	55                   	push   %ebp
    4177:	89 e5                	mov    %esp,%ebp
    4179:	53                   	push   %ebx
    417a:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    417d:	ff 75 0c             	pushl  0xc(%ebp)
    4180:	ff 75 08             	pushl  0x8(%ebp)
    4183:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4186:	50                   	push   %eax
    4187:	e8 97 f9 ff ff       	call   3b23 <LodePNGBitReader_init>
    418c:	83 c4 0c             	add    $0xc,%esp
    418f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    4192:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    4196:	74 0a                	je     41a2 <lode_png_test_bitreader+0x2c>
    4198:	b8 00 00 00 00       	mov    $0x0,%eax
    419d:	e9 c3 00 00 00       	jmp    4265 <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    41a2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    41a9:	e9 a6 00 00 00       	jmp    4254 <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    41ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    41b1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    41b8:	8b 45 14             	mov    0x14(%ebp),%eax
    41bb:	01 d0                	add    %edx,%eax
    41bd:	8b 00                	mov    (%eax),%eax
    41bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    41c2:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    41c6:	7e 14                	jle    41dc <lode_png_test_bitreader+0x66>
    41c8:	ff 75 ec             	pushl  -0x14(%ebp)
    41cb:	8d 45 d8             	lea    -0x28(%ebp),%eax
    41ce:	50                   	push   %eax
    41cf:	e8 41 fd ff ff       	call   3f15 <ensureBits32>
    41d4:	83 c4 08             	add    $0x8,%esp
    41d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    41da:	eb 46                	jmp    4222 <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    41dc:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    41e0:	7e 14                	jle    41f6 <lode_png_test_bitreader+0x80>
    41e2:	ff 75 ec             	pushl  -0x14(%ebp)
    41e5:	8d 45 d8             	lea    -0x28(%ebp),%eax
    41e8:	50                   	push   %eax
    41e9:	e8 ae fb ff ff       	call   3d9c <ensureBits25>
    41ee:	83 c4 08             	add    $0x8,%esp
    41f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    41f4:	eb 2c                	jmp    4222 <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    41f6:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    41fa:	7e 14                	jle    4210 <lode_png_test_bitreader+0x9a>
    41fc:	ff 75 ec             	pushl  -0x14(%ebp)
    41ff:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4202:	50                   	push   %eax
    4203:	e8 68 fa ff ff       	call   3c70 <ensureBits17>
    4208:	83 c4 08             	add    $0x8,%esp
    420b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    420e:	eb 12                	jmp    4222 <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    4210:	ff 75 ec             	pushl  -0x14(%ebp)
    4213:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4216:	50                   	push   %eax
    4217:	e8 78 f9 ff ff       	call   3b94 <ensureBits9>
    421c:	83 c4 08             	add    $0x8,%esp
    421f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    4222:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4226:	75 07                	jne    422f <lode_png_test_bitreader+0xb9>
    4228:	b8 00 00 00 00       	mov    $0x0,%eax
    422d:	eb 36                	jmp    4265 <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    422f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4232:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4239:	8b 45 18             	mov    0x18(%ebp),%eax
    423c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    423f:	ff 75 ec             	pushl  -0x14(%ebp)
    4242:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4245:	50                   	push   %eax
    4246:	e8 01 ff ff ff       	call   414c <readBits>
    424b:	83 c4 08             	add    $0x8,%esp
    424e:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    4250:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4254:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4257:	3b 45 10             	cmp    0x10(%ebp),%eax
    425a:	0f 8c 4e ff ff ff    	jl     41ae <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    4260:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4265:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4268:	c9                   	leave  
    4269:	c3                   	ret    

0000426a <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    426a:	55                   	push   %ebp
    426b:	89 e5                	mov    %esp,%ebp
    426d:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    4270:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    4277:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    427e:	eb 27                	jmp    42a7 <reverseBits+0x3d>
    4280:	8b 45 0c             	mov    0xc(%ebp),%eax
    4283:	2b 45 fc             	sub    -0x4(%ebp),%eax
    4286:	83 e8 01             	sub    $0x1,%eax
    4289:	8b 55 08             	mov    0x8(%ebp),%edx
    428c:	89 c1                	mov    %eax,%ecx
    428e:	d3 ea                	shr    %cl,%edx
    4290:	89 d0                	mov    %edx,%eax
    4292:	83 e0 01             	and    $0x1,%eax
    4295:	89 c2                	mov    %eax,%edx
    4297:	8b 45 fc             	mov    -0x4(%ebp),%eax
    429a:	89 c1                	mov    %eax,%ecx
    429c:	d3 e2                	shl    %cl,%edx
    429e:	89 d0                	mov    %edx,%eax
    42a0:	09 45 f8             	or     %eax,-0x8(%ebp)
    42a3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    42a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    42aa:	3b 45 0c             	cmp    0xc(%ebp),%eax
    42ad:	72 d1                	jb     4280 <reverseBits+0x16>
  return result;
    42af:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    42b2:	c9                   	leave  
    42b3:	c3                   	ret    

000042b4 <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    42b4:	55                   	push   %ebp
    42b5:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    42b7:	8b 45 08             	mov    0x8(%ebp),%eax
    42ba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    42c0:	8b 45 08             	mov    0x8(%ebp),%eax
    42c3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    42ca:	8b 45 08             	mov    0x8(%ebp),%eax
    42cd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    42d4:	8b 45 08             	mov    0x8(%ebp),%eax
    42d7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    42de:	90                   	nop
    42df:	5d                   	pop    %ebp
    42e0:	c3                   	ret    

000042e1 <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    42e1:	55                   	push   %ebp
    42e2:	89 e5                	mov    %esp,%ebp
    42e4:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    42e7:	8b 45 08             	mov    0x8(%ebp),%eax
    42ea:	8b 00                	mov    (%eax),%eax
    42ec:	83 ec 0c             	sub    $0xc,%esp
    42ef:	50                   	push   %eax
    42f0:	e8 ec f0 ff ff       	call   33e1 <lodepng_free>
    42f5:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    42f8:	8b 45 08             	mov    0x8(%ebp),%eax
    42fb:	8b 40 04             	mov    0x4(%eax),%eax
    42fe:	83 ec 0c             	sub    $0xc,%esp
    4301:	50                   	push   %eax
    4302:	e8 da f0 ff ff       	call   33e1 <lodepng_free>
    4307:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    430a:	8b 45 08             	mov    0x8(%ebp),%eax
    430d:	8b 40 10             	mov    0x10(%eax),%eax
    4310:	83 ec 0c             	sub    $0xc,%esp
    4313:	50                   	push   %eax
    4314:	e8 c8 f0 ff ff       	call   33e1 <lodepng_free>
    4319:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    431c:	8b 45 08             	mov    0x8(%ebp),%eax
    431f:	8b 40 14             	mov    0x14(%eax),%eax
    4322:	83 ec 0c             	sub    $0xc,%esp
    4325:	50                   	push   %eax
    4326:	e8 b6 f0 ff ff       	call   33e1 <lodepng_free>
    432b:	83 c4 10             	add    $0x10,%esp
}
    432e:	90                   	nop
    432f:	c9                   	leave  
    4330:	c3                   	ret    

00004331 <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    4331:	55                   	push   %ebp
    4332:	89 e5                	mov    %esp,%ebp
    4334:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    4337:	a1 68 b6 01 00       	mov    0x1b668,%eax
    433c:	c1 e0 02             	shl    $0x2,%eax
    433f:	83 ec 0c             	sub    $0xc,%esp
    4342:	50                   	push   %eax
    4343:	e8 78 f0 ff ff       	call   33c0 <lodepng_malloc>
    4348:	83 c4 10             	add    $0x10,%esp
    434b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    434e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    4352:	75 0a                	jne    435e <HuffmanTree_makeTable+0x2d>
    4354:	b8 53 00 00 00       	mov    $0x53,%eax
    4359:	e9 61 04 00 00       	jmp    47bf <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    435e:	a1 68 b6 01 00       	mov    0x1b668,%eax
    4363:	c1 e0 02             	shl    $0x2,%eax
    4366:	83 ec 04             	sub    $0x4,%esp
    4369:	50                   	push   %eax
    436a:	6a 00                	push   $0x0
    436c:	ff 75 dc             	pushl  -0x24(%ebp)
    436f:	e8 bd f0 ff ff       	call   3431 <lodepng_memset>
    4374:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    4377:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    437e:	eb 7d                	jmp    43fd <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    4380:	8b 45 08             	mov    0x8(%ebp),%eax
    4383:	8b 00                	mov    (%eax),%eax
    4385:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4388:	c1 e2 02             	shl    $0x2,%edx
    438b:	01 d0                	add    %edx,%eax
    438d:	8b 00                	mov    (%eax),%eax
    438f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    4392:	8b 45 08             	mov    0x8(%ebp),%eax
    4395:	8b 40 04             	mov    0x4(%eax),%eax
    4398:	8b 55 f4             	mov    -0xc(%ebp),%edx
    439b:	c1 e2 02             	shl    $0x2,%edx
    439e:	01 d0                	add    %edx,%eax
    43a0:	8b 00                	mov    (%eax),%eax
    43a2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    43a5:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    43a9:	76 4d                	jbe    43f8 <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    43ab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    43ae:	83 e8 09             	sub    $0x9,%eax
    43b1:	8b 55 d8             	mov    -0x28(%ebp),%edx
    43b4:	89 c1                	mov    %eax,%ecx
    43b6:	d3 ea                	shr    %cl,%edx
    43b8:	89 d0                	mov    %edx,%eax
    43ba:	83 ec 08             	sub    $0x8,%esp
    43bd:	6a 09                	push   $0x9
    43bf:	50                   	push   %eax
    43c0:	e8 a5 fe ff ff       	call   426a <reverseBits>
    43c5:	83 c4 10             	add    $0x10,%esp
    43c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    43cb:	8b 45 d0             	mov    -0x30(%ebp),%eax
    43ce:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    43d5:	8b 45 dc             	mov    -0x24(%ebp),%eax
    43d8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    43db:	8b 45 d0             	mov    -0x30(%ebp),%eax
    43de:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    43e5:	8b 45 dc             	mov    -0x24(%ebp),%eax
    43e8:	01 d0                	add    %edx,%eax
    43ea:	8b 10                	mov    (%eax),%edx
    43ec:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    43ef:	39 c2                	cmp    %eax,%edx
    43f1:	0f 43 c2             	cmovae %edx,%eax
    43f4:	89 01                	mov    %eax,(%ecx)
    43f6:	eb 01                	jmp    43f9 <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    43f8:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    43f9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    43fd:	8b 45 08             	mov    0x8(%ebp),%eax
    4400:	8b 50 0c             	mov    0xc(%eax),%edx
    4403:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4406:	39 c2                	cmp    %eax,%edx
    4408:	0f 87 72 ff ff ff    	ja     4380 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    440e:	a1 68 b6 01 00       	mov    0x1b668,%eax
    4413:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    4416:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    441d:	eb 35                	jmp    4454 <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    441f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4422:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4429:	8b 45 dc             	mov    -0x24(%ebp),%eax
    442c:	01 d0                	add    %edx,%eax
    442e:	8b 00                	mov    (%eax),%eax
    4430:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    4433:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    4437:	76 17                	jbe    4450 <HuffmanTree_makeTable+0x11f>
    4439:	8b 45 cc             	mov    -0x34(%ebp),%eax
    443c:	83 e8 09             	sub    $0x9,%eax
    443f:	ba 01 00 00 00       	mov    $0x1,%edx
    4444:	89 c1                	mov    %eax,%ecx
    4446:	d3 e2                	shl    %cl,%edx
    4448:	8b 45 e8             	mov    -0x18(%ebp),%eax
    444b:	01 d0                	add    %edx,%eax
    444d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    4450:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4454:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4457:	a1 68 b6 01 00       	mov    0x1b668,%eax
    445c:	39 c2                	cmp    %eax,%edx
    445e:	72 bf                	jb     441f <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    4460:	83 ec 0c             	sub    $0xc,%esp
    4463:	ff 75 e8             	pushl  -0x18(%ebp)
    4466:	e8 55 ef ff ff       	call   33c0 <lodepng_malloc>
    446b:	83 c4 10             	add    $0x10,%esp
    446e:	89 c2                	mov    %eax,%edx
    4470:	8b 45 08             	mov    0x8(%ebp),%eax
    4473:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    4476:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4479:	01 c0                	add    %eax,%eax
    447b:	83 ec 0c             	sub    $0xc,%esp
    447e:	50                   	push   %eax
    447f:	e8 3c ef ff ff       	call   33c0 <lodepng_malloc>
    4484:	83 c4 10             	add    $0x10,%esp
    4487:	89 c2                	mov    %eax,%edx
    4489:	8b 45 08             	mov    0x8(%ebp),%eax
    448c:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    448f:	8b 45 08             	mov    0x8(%ebp),%eax
    4492:	8b 40 10             	mov    0x10(%eax),%eax
    4495:	85 c0                	test   %eax,%eax
    4497:	74 0a                	je     44a3 <HuffmanTree_makeTable+0x172>
    4499:	8b 45 08             	mov    0x8(%ebp),%eax
    449c:	8b 40 14             	mov    0x14(%eax),%eax
    449f:	85 c0                	test   %eax,%eax
    44a1:	75 18                	jne    44bb <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    44a3:	83 ec 0c             	sub    $0xc,%esp
    44a6:	ff 75 dc             	pushl  -0x24(%ebp)
    44a9:	e8 33 ef ff ff       	call   33e1 <lodepng_free>
    44ae:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    44b1:	b8 53 00 00 00       	mov    $0x53,%eax
    44b6:	e9 04 03 00 00       	jmp    47bf <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    44bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    44c2:	eb 12                	jmp    44d6 <HuffmanTree_makeTable+0x1a5>
    44c4:	8b 45 08             	mov    0x8(%ebp),%eax
    44c7:	8b 50 10             	mov    0x10(%eax),%edx
    44ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    44cd:	01 d0                	add    %edx,%eax
    44cf:	c6 00 10             	movb   $0x10,(%eax)
    44d2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    44d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    44d9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    44dc:	7c e6                	jl     44c4 <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    44de:	a1 68 b6 01 00       	mov    0x1b668,%eax
    44e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    44e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    44ed:	eb 5b                	jmp    454a <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    44ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    44f2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    44f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    44fc:	01 d0                	add    %edx,%eax
    44fe:	8b 00                	mov    (%eax),%eax
    4500:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    4503:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    4507:	76 3c                	jbe    4545 <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    4509:	8b 45 08             	mov    0x8(%ebp),%eax
    450c:	8b 50 10             	mov    0x10(%eax),%edx
    450f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4512:	01 d0                	add    %edx,%eax
    4514:	8b 55 c8             	mov    -0x38(%ebp),%edx
    4517:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    4519:	8b 45 08             	mov    0x8(%ebp),%eax
    451c:	8b 40 14             	mov    0x14(%eax),%eax
    451f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4522:	01 d2                	add    %edx,%edx
    4524:	01 d0                	add    %edx,%eax
    4526:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4529:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    452c:	8b 45 c8             	mov    -0x38(%ebp),%eax
    452f:	83 e8 09             	sub    $0x9,%eax
    4532:	ba 01 00 00 00       	mov    $0x1,%edx
    4537:	89 c1                	mov    %eax,%ecx
    4539:	d3 e2                	shl    %cl,%edx
    453b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    453e:	01 d0                	add    %edx,%eax
    4540:	89 45 ec             	mov    %eax,-0x14(%ebp)
    4543:	eb 01                	jmp    4546 <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    4545:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    4546:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    454a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    454d:	a1 68 b6 01 00       	mov    0x1b668,%eax
    4552:	39 c2                	cmp    %eax,%edx
    4554:	72 99                	jb     44ef <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    4556:	83 ec 0c             	sub    $0xc,%esp
    4559:	ff 75 dc             	pushl  -0x24(%ebp)
    455c:	e8 80 ee ff ff       	call   33e1 <lodepng_free>
    4561:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    4564:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    456b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4572:	e9 9d 01 00 00       	jmp    4714 <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    4577:	8b 45 08             	mov    0x8(%ebp),%eax
    457a:	8b 40 04             	mov    0x4(%eax),%eax
    457d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4580:	c1 e2 02             	shl    $0x2,%edx
    4583:	01 d0                	add    %edx,%eax
    4585:	8b 00                	mov    (%eax),%eax
    4587:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    458a:	8b 45 08             	mov    0x8(%ebp),%eax
    458d:	8b 00                	mov    (%eax),%eax
    458f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4592:	c1 e2 02             	shl    $0x2,%edx
    4595:	01 d0                	add    %edx,%eax
    4597:	8b 00                	mov    (%eax),%eax
    4599:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    459c:	83 ec 08             	sub    $0x8,%esp
    459f:	ff 75 c4             	pushl  -0x3c(%ebp)
    45a2:	ff 75 c0             	pushl  -0x40(%ebp)
    45a5:	e8 c0 fc ff ff       	call   426a <reverseBits>
    45aa:	83 c4 10             	add    $0x10,%esp
    45ad:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    45b0:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    45b4:	0f 84 55 01 00 00    	je     470f <HuffmanTree_makeTable+0x3de>
    numpresent++;
    45ba:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    45be:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    45c2:	0f 87 81 00 00 00    	ja     4649 <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    45c8:	b8 09 00 00 00       	mov    $0x9,%eax
    45cd:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    45d0:	ba 01 00 00 00       	mov    $0x1,%edx
    45d5:	89 c1                	mov    %eax,%ecx
    45d7:	d3 e2                	shl    %cl,%edx
    45d9:	89 d0                	mov    %edx,%eax
    45db:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    45de:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    45e5:	eb 55                	jmp    463c <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    45e7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    45ea:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    45ed:	89 c1                	mov    %eax,%ecx
    45ef:	d3 e2                	shl    %cl,%edx
    45f1:	89 d0                	mov    %edx,%eax
    45f3:	0b 45 bc             	or     -0x44(%ebp),%eax
    45f6:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    45f9:	8b 45 08             	mov    0x8(%ebp),%eax
    45fc:	8b 50 10             	mov    0x10(%eax),%edx
    45ff:	8b 45 98             	mov    -0x68(%ebp),%eax
    4602:	01 d0                	add    %edx,%eax
    4604:	0f b6 00             	movzbl (%eax),%eax
    4607:	3c 10                	cmp    $0x10,%al
    4609:	74 0a                	je     4615 <HuffmanTree_makeTable+0x2e4>
    460b:	b8 37 00 00 00       	mov    $0x37,%eax
    4610:	e9 aa 01 00 00       	jmp    47bf <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    4615:	8b 45 08             	mov    0x8(%ebp),%eax
    4618:	8b 50 10             	mov    0x10(%eax),%edx
    461b:	8b 45 98             	mov    -0x68(%ebp),%eax
    461e:	01 d0                	add    %edx,%eax
    4620:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4623:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    4625:	8b 45 08             	mov    0x8(%ebp),%eax
    4628:	8b 40 14             	mov    0x14(%eax),%eax
    462b:	8b 55 98             	mov    -0x68(%ebp),%edx
    462e:	01 d2                	add    %edx,%edx
    4630:	01 d0                	add    %edx,%eax
    4632:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4635:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    4638:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    463c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    463f:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    4642:	72 a3                	jb     45e7 <HuffmanTree_makeTable+0x2b6>
    4644:	e9 c7 00 00 00       	jmp    4710 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    4649:	a1 6c b6 01 00       	mov    0x1b66c,%eax
    464e:	23 45 bc             	and    -0x44(%ebp),%eax
    4651:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    4654:	8b 45 08             	mov    0x8(%ebp),%eax
    4657:	8b 50 10             	mov    0x10(%eax),%edx
    465a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    465d:	01 d0                	add    %edx,%eax
    465f:	0f b6 00             	movzbl (%eax),%eax
    4662:	0f b6 c0             	movzbl %al,%eax
    4665:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    4668:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    466b:	83 e8 09             	sub    $0x9,%eax
    466e:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    4671:	8b 45 08             	mov    0x8(%ebp),%eax
    4674:	8b 40 14             	mov    0x14(%eax),%eax
    4677:	8b 55 b8             	mov    -0x48(%ebp),%edx
    467a:	01 d2                	add    %edx,%edx
    467c:	01 d0                	add    %edx,%eax
    467e:	0f b7 00             	movzwl (%eax),%eax
    4681:	0f b7 c0             	movzwl %ax,%eax
    4684:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    4687:	8b 45 b0             	mov    -0x50(%ebp),%eax
    468a:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    468d:	83 c0 09             	add    $0x9,%eax
    4690:	ba 01 00 00 00       	mov    $0x1,%edx
    4695:	89 c1                	mov    %eax,%ecx
    4697:	d3 e2                	shl    %cl,%edx
    4699:	89 d0                	mov    %edx,%eax
    469b:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    469e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    46a1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    46a4:	73 0a                	jae    46b0 <HuffmanTree_makeTable+0x37f>
    46a6:	b8 37 00 00 00       	mov    $0x37,%eax
    46ab:	e9 0f 01 00 00       	jmp    47bf <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    46b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    46b7:	eb 4c                	jmp    4705 <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    46b9:	8b 45 bc             	mov    -0x44(%ebp),%eax
    46bc:	c1 e8 09             	shr    $0x9,%eax
    46bf:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    46c2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    46c5:	83 e8 09             	sub    $0x9,%eax
    46c8:	8b 55 e0             	mov    -0x20(%ebp),%edx
    46cb:	89 c1                	mov    %eax,%ecx
    46cd:	d3 e2                	shl    %cl,%edx
    46cf:	89 d0                	mov    %edx,%eax
    46d1:	0b 45 a4             	or     -0x5c(%ebp),%eax
    46d4:	89 c2                	mov    %eax,%edx
    46d6:	8b 45 ac             	mov    -0x54(%ebp),%eax
    46d9:	01 d0                	add    %edx,%eax
    46db:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    46de:	8b 45 08             	mov    0x8(%ebp),%eax
    46e1:	8b 50 10             	mov    0x10(%eax),%edx
    46e4:	8b 45 a0             	mov    -0x60(%ebp),%eax
    46e7:	01 d0                	add    %edx,%eax
    46e9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    46ec:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    46ee:	8b 45 08             	mov    0x8(%ebp),%eax
    46f1:	8b 40 14             	mov    0x14(%eax),%eax
    46f4:	8b 55 a0             	mov    -0x60(%ebp),%edx
    46f7:	01 d2                	add    %edx,%edx
    46f9:	01 d0                	add    %edx,%eax
    46fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    46fe:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    4701:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4705:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4708:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    470b:	72 ac                	jb     46b9 <HuffmanTree_makeTable+0x388>
    470d:	eb 01                	jmp    4710 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    470f:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    4710:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4714:	8b 45 08             	mov    0x8(%ebp),%eax
    4717:	8b 50 0c             	mov    0xc(%eax),%edx
    471a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    471d:	39 c2                	cmp    %eax,%edx
    471f:	0f 87 52 fe ff ff    	ja     4577 <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    4725:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    4729:	7f 61                	jg     478c <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    472b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4732:	eb 4e                	jmp    4782 <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    4734:	8b 45 08             	mov    0x8(%ebp),%eax
    4737:	8b 50 10             	mov    0x10(%eax),%edx
    473a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    473d:	01 d0                	add    %edx,%eax
    473f:	0f b6 00             	movzbl (%eax),%eax
    4742:	3c 10                	cmp    $0x10,%al
    4744:	75 38                	jne    477e <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    4746:	8b 45 08             	mov    0x8(%ebp),%eax
    4749:	8b 50 10             	mov    0x10(%eax),%edx
    474c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    474f:	01 d0                	add    %edx,%eax
    4751:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    4754:	8b 15 68 b6 01 00    	mov    0x1b668,%edx
    475a:	39 d1                	cmp    %edx,%ecx
    475c:	73 07                	jae    4765 <HuffmanTree_makeTable+0x434>
    475e:	ba 01 00 00 00       	mov    $0x1,%edx
    4763:	eb 05                	jmp    476a <HuffmanTree_makeTable+0x439>
    4765:	ba 0a 00 00 00       	mov    $0xa,%edx
    476a:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    476c:	8b 45 08             	mov    0x8(%ebp),%eax
    476f:	8b 40 14             	mov    0x14(%eax),%eax
    4772:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4775:	01 d2                	add    %edx,%edx
    4777:	01 d0                	add    %edx,%eax
    4779:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    477e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4782:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4785:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4788:	7c aa                	jl     4734 <HuffmanTree_makeTable+0x403>
    478a:	eb 2e                	jmp    47ba <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    478c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4793:	eb 1d                	jmp    47b2 <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    4795:	8b 45 08             	mov    0x8(%ebp),%eax
    4798:	8b 50 10             	mov    0x10(%eax),%edx
    479b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    479e:	01 d0                	add    %edx,%eax
    47a0:	0f b6 00             	movzbl (%eax),%eax
    47a3:	3c 10                	cmp    $0x10,%al
    47a5:	75 07                	jne    47ae <HuffmanTree_makeTable+0x47d>
    47a7:	b8 37 00 00 00       	mov    $0x37,%eax
    47ac:	eb 11                	jmp    47bf <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    47ae:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    47b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    47b5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    47b8:	7c db                	jl     4795 <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    47ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
    47bf:	c9                   	leave  
    47c0:	c3                   	ret    

000047c1 <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    47c1:	55                   	push   %ebp
    47c2:	89 e5                	mov    %esp,%ebp
    47c4:	56                   	push   %esi
    47c5:	53                   	push   %ebx
    47c6:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    47c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    47d0:	8b 45 08             	mov    0x8(%ebp),%eax
    47d3:	8b 40 0c             	mov    0xc(%eax),%eax
    47d6:	c1 e0 02             	shl    $0x2,%eax
    47d9:	83 ec 0c             	sub    $0xc,%esp
    47dc:	50                   	push   %eax
    47dd:	e8 de eb ff ff       	call   33c0 <lodepng_malloc>
    47e2:	83 c4 10             	add    $0x10,%esp
    47e5:	89 c2                	mov    %eax,%edx
    47e7:	8b 45 08             	mov    0x8(%ebp),%eax
    47ea:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    47ec:	8b 45 08             	mov    0x8(%ebp),%eax
    47ef:	8b 40 08             	mov    0x8(%eax),%eax
    47f2:	83 c0 01             	add    $0x1,%eax
    47f5:	c1 e0 02             	shl    $0x2,%eax
    47f8:	83 ec 0c             	sub    $0xc,%esp
    47fb:	50                   	push   %eax
    47fc:	e8 bf eb ff ff       	call   33c0 <lodepng_malloc>
    4801:	83 c4 10             	add    $0x10,%esp
    4804:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4807:	8b 45 08             	mov    0x8(%ebp),%eax
    480a:	8b 40 08             	mov    0x8(%eax),%eax
    480d:	83 c0 01             	add    $0x1,%eax
    4810:	c1 e0 02             	shl    $0x2,%eax
    4813:	83 ec 0c             	sub    $0xc,%esp
    4816:	50                   	push   %eax
    4817:	e8 a4 eb ff ff       	call   33c0 <lodepng_malloc>
    481c:	83 c4 10             	add    $0x10,%esp
    481f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    4822:	8b 45 08             	mov    0x8(%ebp),%eax
    4825:	8b 00                	mov    (%eax),%eax
    4827:	85 c0                	test   %eax,%eax
    4829:	74 0c                	je     4837 <HuffmanTree_makeFromLengths2+0x76>
    482b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    482f:	74 06                	je     4837 <HuffmanTree_makeFromLengths2+0x76>
    4831:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4835:	75 07                	jne    483e <HuffmanTree_makeFromLengths2+0x7d>
    4837:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    483e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4842:	0f 85 7d 01 00 00    	jne    49c5 <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    4848:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    484f:	eb 2c                	jmp    487d <HuffmanTree_makeFromLengths2+0xbc>
    4851:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4854:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    485b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    485e:	01 c2                	add    %eax,%edx
    4860:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4863:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    486a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    486d:	01 c8                	add    %ecx,%eax
    486f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    4875:	8b 00                	mov    (%eax),%eax
    4877:	89 02                	mov    %eax,(%edx)
    4879:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    487d:	8b 45 08             	mov    0x8(%ebp),%eax
    4880:	8b 40 08             	mov    0x8(%eax),%eax
    4883:	83 c0 01             	add    $0x1,%eax
    4886:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4889:	75 c6                	jne    4851 <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    488b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4892:	eb 27                	jmp    48bb <HuffmanTree_makeFromLengths2+0xfa>
    4894:	8b 45 08             	mov    0x8(%ebp),%eax
    4897:	8b 40 04             	mov    0x4(%eax),%eax
    489a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    489d:	c1 e2 02             	shl    $0x2,%edx
    48a0:	01 d0                	add    %edx,%eax
    48a2:	8b 00                	mov    (%eax),%eax
    48a4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    48ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    48ae:	01 d0                	add    %edx,%eax
    48b0:	8b 10                	mov    (%eax),%edx
    48b2:	83 c2 01             	add    $0x1,%edx
    48b5:	89 10                	mov    %edx,(%eax)
    48b7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    48bb:	8b 45 08             	mov    0x8(%ebp),%eax
    48be:	8b 40 0c             	mov    0xc(%eax),%eax
    48c1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    48c4:	75 ce                	jne    4894 <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    48c6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    48cd:	eb 47                	jmp    4916 <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    48cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    48d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    48d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    48dc:	01 d0                	add    %edx,%eax
    48de:	8b 55 f0             	mov    -0x10(%ebp),%edx
    48e1:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    48e7:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    48ee:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    48f1:	01 ca                	add    %ecx,%edx
    48f3:	8b 0a                	mov    (%edx),%ecx
    48f5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    48f8:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    48fe:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    4905:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4908:	01 da                	add    %ebx,%edx
    490a:	8b 12                	mov    (%edx),%edx
    490c:	01 ca                	add    %ecx,%edx
    490e:	01 d2                	add    %edx,%edx
    4910:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4912:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4916:	8b 45 08             	mov    0x8(%ebp),%eax
    4919:	8b 40 08             	mov    0x8(%eax),%eax
    491c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    491f:	73 ae                	jae    48cf <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4921:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4928:	e9 89 00 00 00       	jmp    49b6 <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    492d:	8b 45 08             	mov    0x8(%ebp),%eax
    4930:	8b 40 04             	mov    0x4(%eax),%eax
    4933:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4936:	c1 e2 02             	shl    $0x2,%edx
    4939:	01 d0                	add    %edx,%eax
    493b:	8b 00                	mov    (%eax),%eax
    493d:	85 c0                	test   %eax,%eax
    493f:	74 71                	je     49b2 <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    4941:	8b 45 08             	mov    0x8(%ebp),%eax
    4944:	8b 00                	mov    (%eax),%eax
    4946:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4949:	c1 e2 02             	shl    $0x2,%edx
    494c:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    494f:	8b 45 08             	mov    0x8(%ebp),%eax
    4952:	8b 40 04             	mov    0x4(%eax),%eax
    4955:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4958:	c1 e2 02             	shl    $0x2,%edx
    495b:	01 d0                	add    %edx,%eax
    495d:	8b 00                	mov    (%eax),%eax
    495f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4966:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4969:	01 c2                	add    %eax,%edx
    496b:	8b 02                	mov    (%edx),%eax
    496d:	8d 48 01             	lea    0x1(%eax),%ecx
    4970:	89 0a                	mov    %ecx,(%edx)
    4972:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    4974:	8b 45 08             	mov    0x8(%ebp),%eax
    4977:	8b 00                	mov    (%eax),%eax
    4979:	8b 55 ec             	mov    -0x14(%ebp),%edx
    497c:	c1 e2 02             	shl    $0x2,%edx
    497f:	01 c2                	add    %eax,%edx
    4981:	8b 45 08             	mov    0x8(%ebp),%eax
    4984:	8b 00                	mov    (%eax),%eax
    4986:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4989:	c1 e1 02             	shl    $0x2,%ecx
    498c:	01 c8                	add    %ecx,%eax
    498e:	8b 18                	mov    (%eax),%ebx
    4990:	8b 45 08             	mov    0x8(%ebp),%eax
    4993:	8b 40 04             	mov    0x4(%eax),%eax
    4996:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4999:	c1 e1 02             	shl    $0x2,%ecx
    499c:	01 c8                	add    %ecx,%eax
    499e:	8b 00                	mov    (%eax),%eax
    49a0:	be 01 00 00 00       	mov    $0x1,%esi
    49a5:	89 c1                	mov    %eax,%ecx
    49a7:	d3 e6                	shl    %cl,%esi
    49a9:	89 f0                	mov    %esi,%eax
    49ab:	83 e8 01             	sub    $0x1,%eax
    49ae:	21 d8                	and    %ebx,%eax
    49b0:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    49b2:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    49b6:	8b 45 08             	mov    0x8(%ebp),%eax
    49b9:	8b 40 0c             	mov    0xc(%eax),%eax
    49bc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    49bf:	0f 85 68 ff ff ff    	jne    492d <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    49c5:	83 ec 0c             	sub    $0xc,%esp
    49c8:	ff 75 e8             	pushl  -0x18(%ebp)
    49cb:	e8 11 ea ff ff       	call   33e1 <lodepng_free>
    49d0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    49d3:	83 ec 0c             	sub    $0xc,%esp
    49d6:	ff 75 e4             	pushl  -0x1c(%ebp)
    49d9:	e8 03 ea ff ff       	call   33e1 <lodepng_free>
    49de:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    49e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    49e5:	75 11                	jne    49f8 <HuffmanTree_makeFromLengths2+0x237>
    49e7:	83 ec 0c             	sub    $0xc,%esp
    49ea:	ff 75 08             	pushl  0x8(%ebp)
    49ed:	e8 3f f9 ff ff       	call   4331 <HuffmanTree_makeTable>
    49f2:	83 c4 10             	add    $0x10,%esp
    49f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    49f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    49fb:	8d 65 f8             	lea    -0x8(%ebp),%esp
    49fe:	5b                   	pop    %ebx
    49ff:	5e                   	pop    %esi
    4a00:	5d                   	pop    %ebp
    4a01:	c3                   	ret    

00004a02 <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    4a02:	55                   	push   %ebp
    4a03:	89 e5                	mov    %esp,%ebp
    4a05:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    4a08:	8b 45 10             	mov    0x10(%ebp),%eax
    4a0b:	c1 e0 02             	shl    $0x2,%eax
    4a0e:	83 ec 0c             	sub    $0xc,%esp
    4a11:	50                   	push   %eax
    4a12:	e8 a9 e9 ff ff       	call   33c0 <lodepng_malloc>
    4a17:	83 c4 10             	add    $0x10,%esp
    4a1a:	89 c2                	mov    %eax,%edx
    4a1c:	8b 45 08             	mov    0x8(%ebp),%eax
    4a1f:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    4a22:	8b 45 08             	mov    0x8(%ebp),%eax
    4a25:	8b 40 04             	mov    0x4(%eax),%eax
    4a28:	85 c0                	test   %eax,%eax
    4a2a:	75 07                	jne    4a33 <HuffmanTree_makeFromLengths+0x31>
    4a2c:	b8 53 00 00 00       	mov    $0x53,%eax
    4a31:	eb 56                	jmp    4a89 <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    4a33:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4a3a:	eb 25                	jmp    4a61 <HuffmanTree_makeFromLengths+0x5f>
    4a3c:	8b 45 08             	mov    0x8(%ebp),%eax
    4a3f:	8b 40 04             	mov    0x4(%eax),%eax
    4a42:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4a45:	c1 e2 02             	shl    $0x2,%edx
    4a48:	01 c2                	add    %eax,%edx
    4a4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a4d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4a54:	8b 45 0c             	mov    0xc(%ebp),%eax
    4a57:	01 c8                	add    %ecx,%eax
    4a59:	8b 00                	mov    (%eax),%eax
    4a5b:	89 02                	mov    %eax,(%edx)
    4a5d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4a61:	8b 45 10             	mov    0x10(%ebp),%eax
    4a64:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4a67:	75 d3                	jne    4a3c <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    4a69:	8b 55 10             	mov    0x10(%ebp),%edx
    4a6c:	8b 45 08             	mov    0x8(%ebp),%eax
    4a6f:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    4a72:	8b 45 08             	mov    0x8(%ebp),%eax
    4a75:	8b 55 14             	mov    0x14(%ebp),%edx
    4a78:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    4a7b:	83 ec 0c             	sub    $0xc,%esp
    4a7e:	ff 75 08             	pushl  0x8(%ebp)
    4a81:	e8 3b fd ff ff       	call   47c1 <HuffmanTree_makeFromLengths2>
    4a86:	83 c4 10             	add    $0x10,%esp
}
    4a89:	c9                   	leave  
    4a8a:	c3                   	ret    

00004a8b <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    4a8b:	55                   	push   %ebp
    4a8c:	89 e5                	mov    %esp,%ebp
    4a8e:	53                   	push   %ebx
    4a8f:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    4a92:	8b 45 08             	mov    0x8(%ebp),%eax
    4a95:	8b 50 0c             	mov    0xc(%eax),%edx
    4a98:	8b 45 08             	mov    0x8(%ebp),%eax
    4a9b:	8b 40 08             	mov    0x8(%eax),%eax
    4a9e:	39 c2                	cmp    %eax,%edx
    4aa0:	0f 82 0b 01 00 00    	jb     4bb1 <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    4aa6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4aad:	eb 19                	jmp    4ac8 <bpmnode_create+0x3d>
    4aaf:	8b 45 08             	mov    0x8(%ebp),%eax
    4ab2:	8b 40 04             	mov    0x4(%eax),%eax
    4ab5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4ab8:	c1 e2 04             	shl    $0x4,%edx
    4abb:	01 d0                	add    %edx,%eax
    4abd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    4ac4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4ac8:	8b 45 08             	mov    0x8(%ebp),%eax
    4acb:	8b 00                	mov    (%eax),%eax
    4acd:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4ad0:	75 dd                	jne    4aaf <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    4ad2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4ad9:	eb 60                	jmp    4b3b <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    4adb:	8b 45 08             	mov    0x8(%ebp),%eax
    4ade:	8b 40 18             	mov    0x18(%eax),%eax
    4ae1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4ae4:	c1 e2 02             	shl    $0x2,%edx
    4ae7:	01 d0                	add    %edx,%eax
    4ae9:	8b 00                	mov    (%eax),%eax
    4aeb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4aee:	eb 13                	jmp    4b03 <bpmnode_create+0x78>
    4af0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4af3:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4afa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4afd:	8b 40 08             	mov    0x8(%eax),%eax
    4b00:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4b03:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4b07:	75 e7                	jne    4af0 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    4b09:	8b 45 08             	mov    0x8(%ebp),%eax
    4b0c:	8b 40 1c             	mov    0x1c(%eax),%eax
    4b0f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4b12:	c1 e2 02             	shl    $0x2,%edx
    4b15:	01 d0                	add    %edx,%eax
    4b17:	8b 00                	mov    (%eax),%eax
    4b19:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4b1c:	eb 13                	jmp    4b31 <bpmnode_create+0xa6>
    4b1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b21:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4b28:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b2b:	8b 40 08             	mov    0x8(%eax),%eax
    4b2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4b31:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4b35:	75 e7                	jne    4b1e <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    4b37:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4b3b:	8b 45 08             	mov    0x8(%ebp),%eax
    4b3e:	8b 40 14             	mov    0x14(%eax),%eax
    4b41:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4b44:	75 95                	jne    4adb <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    4b46:	8b 45 08             	mov    0x8(%ebp),%eax
    4b49:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    4b50:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4b57:	eb 44                	jmp    4b9d <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    4b59:	8b 45 08             	mov    0x8(%ebp),%eax
    4b5c:	8b 40 04             	mov    0x4(%eax),%eax
    4b5f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4b62:	c1 e2 04             	shl    $0x4,%edx
    4b65:	01 d0                	add    %edx,%eax
    4b67:	8b 40 0c             	mov    0xc(%eax),%eax
    4b6a:	85 c0                	test   %eax,%eax
    4b6c:	75 2b                	jne    4b99 <bpmnode_create+0x10e>
    4b6e:	8b 45 08             	mov    0x8(%ebp),%eax
    4b71:	8b 58 10             	mov    0x10(%eax),%ebx
    4b74:	8b 45 08             	mov    0x8(%ebp),%eax
    4b77:	8b 40 08             	mov    0x8(%eax),%eax
    4b7a:	8d 48 01             	lea    0x1(%eax),%ecx
    4b7d:	8b 55 08             	mov    0x8(%ebp),%edx
    4b80:	89 4a 08             	mov    %ecx,0x8(%edx)
    4b83:	c1 e0 02             	shl    $0x2,%eax
    4b86:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4b89:	8b 45 08             	mov    0x8(%ebp),%eax
    4b8c:	8b 40 04             	mov    0x4(%eax),%eax
    4b8f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4b92:	c1 e1 04             	shl    $0x4,%ecx
    4b95:	01 c8                	add    %ecx,%eax
    4b97:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    4b99:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4b9d:	8b 45 08             	mov    0x8(%ebp),%eax
    4ba0:	8b 00                	mov    (%eax),%eax
    4ba2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4ba5:	75 b2                	jne    4b59 <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    4ba7:	8b 45 08             	mov    0x8(%ebp),%eax
    4baa:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    4bb1:	8b 45 08             	mov    0x8(%ebp),%eax
    4bb4:	8b 58 10             	mov    0x10(%eax),%ebx
    4bb7:	8b 45 08             	mov    0x8(%ebp),%eax
    4bba:	8b 40 0c             	mov    0xc(%eax),%eax
    4bbd:	8d 48 01             	lea    0x1(%eax),%ecx
    4bc0:	8b 55 08             	mov    0x8(%ebp),%edx
    4bc3:	89 4a 0c             	mov    %ecx,0xc(%edx)
    4bc6:	c1 e0 02             	shl    $0x2,%eax
    4bc9:	01 d8                	add    %ebx,%eax
    4bcb:	8b 00                	mov    (%eax),%eax
    4bcd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    4bd0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4bd3:	8b 55 0c             	mov    0xc(%ebp),%edx
    4bd6:	89 10                	mov    %edx,(%eax)
  result->index = index;
    4bd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4bdb:	8b 55 10             	mov    0x10(%ebp),%edx
    4bde:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    4be1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4be4:	8b 55 14             	mov    0x14(%ebp),%edx
    4be7:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    4bea:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    4bed:	83 c4 10             	add    $0x10,%esp
    4bf0:	5b                   	pop    %ebx
    4bf1:	5d                   	pop    %ebp
    4bf2:	c3                   	ret    

00004bf3 <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    4bf3:	55                   	push   %ebp
    4bf4:	89 e5                	mov    %esp,%ebp
    4bf6:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    4bf9:	8b 45 0c             	mov    0xc(%ebp),%eax
    4bfc:	c1 e0 04             	shl    $0x4,%eax
    4bff:	83 ec 0c             	sub    $0xc,%esp
    4c02:	50                   	push   %eax
    4c03:	e8 b8 e7 ff ff       	call   33c0 <lodepng_malloc>
    4c08:	83 c4 10             	add    $0x10,%esp
    4c0b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    4c0e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    4c15:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    4c1c:	e9 41 01 00 00       	jmp    4d62 <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    4c21:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c24:	83 e0 01             	and    $0x1,%eax
    4c27:	85 c0                	test   %eax,%eax
    4c29:	74 05                	je     4c30 <bpmnode_sort+0x3d>
    4c2b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4c2e:	eb 03                	jmp    4c33 <bpmnode_sort+0x40>
    4c30:	8b 45 08             	mov    0x8(%ebp),%eax
    4c33:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    4c36:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c39:	83 e0 01             	and    $0x1,%eax
    4c3c:	85 c0                	test   %eax,%eax
    4c3e:	74 05                	je     4c45 <bpmnode_sort+0x52>
    4c40:	8b 45 08             	mov    0x8(%ebp),%eax
    4c43:	eb 03                	jmp    4c48 <bpmnode_sort+0x55>
    4c45:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4c48:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4c4b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4c52:	e9 f8 00 00 00       	jmp    4d4f <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    4c57:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4c5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c5d:	01 c2                	add    %eax,%edx
    4c5f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4c62:	39 c2                	cmp    %eax,%edx
    4c64:	0f 4e c2             	cmovle %edx,%eax
    4c67:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    4c6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c6d:	8d 14 00             	lea    (%eax,%eax,1),%edx
    4c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4c73:	01 c2                	add    %eax,%edx
    4c75:	8b 45 0c             	mov    0xc(%ebp),%eax
    4c78:	39 c2                	cmp    %eax,%edx
    4c7a:	0f 4e c2             	cmovle %edx,%eax
    4c7d:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    4c80:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4c83:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4c86:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4c89:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    4c8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4c8f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4c92:	e9 a4 00 00 00       	jmp    4d3b <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    4c97:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4c9a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    4c9d:	7d 62                	jge    4d01 <bpmnode_sort+0x10e>
    4c9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4ca2:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4ca5:	7d 22                	jge    4cc9 <bpmnode_sort+0xd6>
    4ca7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4caa:	c1 e0 04             	shl    $0x4,%eax
    4cad:	89 c2                	mov    %eax,%edx
    4caf:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4cb2:	01 d0                	add    %edx,%eax
    4cb4:	8b 10                	mov    (%eax),%edx
    4cb6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4cb9:	c1 e0 04             	shl    $0x4,%eax
    4cbc:	89 c1                	mov    %eax,%ecx
    4cbe:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4cc1:	01 c8                	add    %ecx,%eax
    4cc3:	8b 00                	mov    (%eax),%eax
    4cc5:	39 c2                	cmp    %eax,%edx
    4cc7:	7f 38                	jg     4d01 <bpmnode_sort+0x10e>
    4cc9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4ccc:	c1 e0 04             	shl    $0x4,%eax
    4ccf:	89 c2                	mov    %eax,%edx
    4cd1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4cd4:	01 d0                	add    %edx,%eax
    4cd6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4cd9:	8d 4a 01             	lea    0x1(%edx),%ecx
    4cdc:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    4cdf:	89 d1                	mov    %edx,%ecx
    4ce1:	c1 e1 04             	shl    $0x4,%ecx
    4ce4:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4ce7:	01 ca                	add    %ecx,%edx
    4ce9:	8b 0a                	mov    (%edx),%ecx
    4ceb:	89 08                	mov    %ecx,(%eax)
    4ced:	8b 4a 04             	mov    0x4(%edx),%ecx
    4cf0:	89 48 04             	mov    %ecx,0x4(%eax)
    4cf3:	8b 4a 08             	mov    0x8(%edx),%ecx
    4cf6:	89 48 08             	mov    %ecx,0x8(%eax)
    4cf9:	8b 52 0c             	mov    0xc(%edx),%edx
    4cfc:	89 50 0c             	mov    %edx,0xc(%eax)
    4cff:	eb 36                	jmp    4d37 <bpmnode_sort+0x144>
        else b[k] = a[j++];
    4d01:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4d04:	c1 e0 04             	shl    $0x4,%eax
    4d07:	89 c2                	mov    %eax,%edx
    4d09:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4d0c:	01 d0                	add    %edx,%eax
    4d0e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4d11:	8d 4a 01             	lea    0x1(%edx),%ecx
    4d14:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    4d17:	89 d1                	mov    %edx,%ecx
    4d19:	c1 e1 04             	shl    $0x4,%ecx
    4d1c:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4d1f:	01 ca                	add    %ecx,%edx
    4d21:	8b 0a                	mov    (%edx),%ecx
    4d23:	89 08                	mov    %ecx,(%eax)
    4d25:	8b 4a 04             	mov    0x4(%edx),%ecx
    4d28:	89 48 04             	mov    %ecx,0x4(%eax)
    4d2b:	8b 4a 08             	mov    0x8(%edx),%ecx
    4d2e:	89 48 08             	mov    %ecx,0x8(%eax)
    4d31:	8b 52 0c             	mov    0xc(%edx),%edx
    4d34:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    4d37:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4d3b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4d3e:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4d41:	0f 8c 50 ff ff ff    	jl     4c97 <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4d47:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d4a:	01 c0                	add    %eax,%eax
    4d4c:	01 45 ec             	add    %eax,-0x14(%ebp)
    4d4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4d52:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4d55:	0f 8c fc fe ff ff    	jl     4c57 <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    4d5b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    4d5f:	d1 65 f4             	shll   -0xc(%ebp)
    4d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d65:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4d68:	0f 8c b3 fe ff ff    	jl     4c21 <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    4d6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4d71:	83 e0 01             	and    $0x1,%eax
    4d74:	85 c0                	test   %eax,%eax
    4d76:	74 18                	je     4d90 <bpmnode_sort+0x19d>
    4d78:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d7b:	c1 e0 04             	shl    $0x4,%eax
    4d7e:	83 ec 04             	sub    $0x4,%esp
    4d81:	50                   	push   %eax
    4d82:	ff 75 dc             	pushl  -0x24(%ebp)
    4d85:	ff 75 08             	pushl  0x8(%ebp)
    4d88:	e8 71 e6 ff ff       	call   33fe <lodepng_memcpy>
    4d8d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    4d90:	83 ec 0c             	sub    $0xc,%esp
    4d93:	ff 75 dc             	pushl  -0x24(%ebp)
    4d96:	e8 46 e6 ff ff       	call   33e1 <lodepng_free>
    4d9b:	83 c4 10             	add    $0x10,%esp
}
    4d9e:	90                   	nop
    4d9f:	c9                   	leave  
    4da0:	c3                   	ret    

00004da1 <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    4da1:	55                   	push   %ebp
    4da2:	89 e5                	mov    %esp,%ebp
    4da4:	56                   	push   %esi
    4da5:	53                   	push   %ebx
    4da6:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    4da9:	8b 45 08             	mov    0x8(%ebp),%eax
    4dac:	8b 40 1c             	mov    0x1c(%eax),%eax
    4daf:	8b 55 14             	mov    0x14(%ebp),%edx
    4db2:	c1 e2 02             	shl    $0x2,%edx
    4db5:	01 d0                	add    %edx,%eax
    4db7:	8b 00                	mov    (%eax),%eax
    4db9:	8b 40 04             	mov    0x4(%eax),%eax
    4dbc:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    4dbf:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    4dc3:	75 66                	jne    4e2b <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    4dc5:	8b 45 10             	mov    0x10(%ebp),%eax
    4dc8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4dcb:	0f 83 a0 01 00 00    	jae    4f71 <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    4dd1:	8b 45 08             	mov    0x8(%ebp),%eax
    4dd4:	8b 40 18             	mov    0x18(%eax),%eax
    4dd7:	8b 55 14             	mov    0x14(%ebp),%edx
    4dda:	c1 e2 02             	shl    $0x2,%edx
    4ddd:	01 c2                	add    %eax,%edx
    4ddf:	8b 45 08             	mov    0x8(%ebp),%eax
    4de2:	8b 40 1c             	mov    0x1c(%eax),%eax
    4de5:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4de8:	c1 e1 02             	shl    $0x2,%ecx
    4deb:	01 c8                	add    %ecx,%eax
    4ded:	8b 00                	mov    (%eax),%eax
    4def:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    4df1:	8b 45 08             	mov    0x8(%ebp),%eax
    4df4:	8b 40 1c             	mov    0x1c(%eax),%eax
    4df7:	8b 55 14             	mov    0x14(%ebp),%edx
    4dfa:	c1 e2 02             	shl    $0x2,%edx
    4dfd:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4e00:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e03:	8d 50 01             	lea    0x1(%eax),%edx
    4e06:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e09:	c1 e0 04             	shl    $0x4,%eax
    4e0c:	89 c1                	mov    %eax,%ecx
    4e0e:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e11:	01 c8                	add    %ecx,%eax
    4e13:	8b 00                	mov    (%eax),%eax
    4e15:	6a 00                	push   $0x0
    4e17:	52                   	push   %edx
    4e18:	50                   	push   %eax
    4e19:	ff 75 08             	pushl  0x8(%ebp)
    4e1c:	e8 6a fc ff ff       	call   4a8b <bpmnode_create>
    4e21:	83 c4 10             	add    $0x10,%esp
    4e24:	89 03                	mov    %eax,(%ebx)
    4e26:	e9 47 01 00 00       	jmp    4f72 <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    4e2b:	8b 45 08             	mov    0x8(%ebp),%eax
    4e2e:	8b 40 18             	mov    0x18(%eax),%eax
    4e31:	8b 55 14             	mov    0x14(%ebp),%edx
    4e34:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4e3a:	c1 e2 02             	shl    $0x2,%edx
    4e3d:	01 d0                	add    %edx,%eax
    4e3f:	8b 00                	mov    (%eax),%eax
    4e41:	8b 10                	mov    (%eax),%edx
    4e43:	8b 45 08             	mov    0x8(%ebp),%eax
    4e46:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e49:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4e4c:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    4e52:	c1 e1 02             	shl    $0x2,%ecx
    4e55:	01 c8                	add    %ecx,%eax
    4e57:	8b 00                	mov    (%eax),%eax
    4e59:	8b 00                	mov    (%eax),%eax
    4e5b:	01 d0                	add    %edx,%eax
    4e5d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    4e60:	8b 45 08             	mov    0x8(%ebp),%eax
    4e63:	8b 40 18             	mov    0x18(%eax),%eax
    4e66:	8b 55 14             	mov    0x14(%ebp),%edx
    4e69:	c1 e2 02             	shl    $0x2,%edx
    4e6c:	01 c2                	add    %eax,%edx
    4e6e:	8b 45 08             	mov    0x8(%ebp),%eax
    4e71:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e74:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4e77:	c1 e1 02             	shl    $0x2,%ecx
    4e7a:	01 c8                	add    %ecx,%eax
    4e7c:	8b 00                	mov    (%eax),%eax
    4e7e:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    4e80:	8b 45 10             	mov    0x10(%ebp),%eax
    4e83:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4e86:	73 60                	jae    4ee8 <boundaryPM+0x147>
    4e88:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e8b:	c1 e0 04             	shl    $0x4,%eax
    4e8e:	89 c2                	mov    %eax,%edx
    4e90:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e93:	01 d0                	add    %edx,%eax
    4e95:	8b 00                	mov    (%eax),%eax
    4e97:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4e9a:	7d 4c                	jge    4ee8 <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    4e9c:	8b 45 08             	mov    0x8(%ebp),%eax
    4e9f:	8b 40 1c             	mov    0x1c(%eax),%eax
    4ea2:	8b 55 14             	mov    0x14(%ebp),%edx
    4ea5:	c1 e2 02             	shl    $0x2,%edx
    4ea8:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4eab:	8b 45 08             	mov    0x8(%ebp),%eax
    4eae:	8b 40 1c             	mov    0x1c(%eax),%eax
    4eb1:	8b 55 14             	mov    0x14(%ebp),%edx
    4eb4:	c1 e2 02             	shl    $0x2,%edx
    4eb7:	01 d0                	add    %edx,%eax
    4eb9:	8b 00                	mov    (%eax),%eax
    4ebb:	8b 50 08             	mov    0x8(%eax),%edx
    4ebe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4ec1:	8d 48 01             	lea    0x1(%eax),%ecx
    4ec4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4ec7:	c1 e0 04             	shl    $0x4,%eax
    4eca:	89 c6                	mov    %eax,%esi
    4ecc:	8b 45 0c             	mov    0xc(%ebp),%eax
    4ecf:	01 f0                	add    %esi,%eax
    4ed1:	8b 00                	mov    (%eax),%eax
    4ed3:	52                   	push   %edx
    4ed4:	51                   	push   %ecx
    4ed5:	50                   	push   %eax
    4ed6:	ff 75 08             	pushl  0x8(%ebp)
    4ed9:	e8 ad fb ff ff       	call   4a8b <bpmnode_create>
    4ede:	83 c4 10             	add    $0x10,%esp
    4ee1:	89 03                	mov    %eax,(%ebx)
      return;
    4ee3:	e9 8a 00 00 00       	jmp    4f72 <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    4ee8:	8b 45 08             	mov    0x8(%ebp),%eax
    4eeb:	8b 40 1c             	mov    0x1c(%eax),%eax
    4eee:	8b 55 14             	mov    0x14(%ebp),%edx
    4ef1:	c1 e2 02             	shl    $0x2,%edx
    4ef4:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4ef7:	8b 45 08             	mov    0x8(%ebp),%eax
    4efa:	8b 40 1c             	mov    0x1c(%eax),%eax
    4efd:	8b 55 14             	mov    0x14(%ebp),%edx
    4f00:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4f06:	c1 e2 02             	shl    $0x2,%edx
    4f09:	01 d0                	add    %edx,%eax
    4f0b:	8b 00                	mov    (%eax),%eax
    4f0d:	50                   	push   %eax
    4f0e:	ff 75 f4             	pushl  -0xc(%ebp)
    4f11:	ff 75 f0             	pushl  -0x10(%ebp)
    4f14:	ff 75 08             	pushl  0x8(%ebp)
    4f17:	e8 6f fb ff ff       	call   4a8b <bpmnode_create>
    4f1c:	83 c4 10             	add    $0x10,%esp
    4f1f:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    4f21:	8b 45 18             	mov    0x18(%ebp),%eax
    4f24:	8d 50 01             	lea    0x1(%eax),%edx
    4f27:	8b 45 10             	mov    0x10(%ebp),%eax
    4f2a:	83 e8 01             	sub    $0x1,%eax
    4f2d:	01 c0                	add    %eax,%eax
    4f2f:	39 c2                	cmp    %eax,%edx
    4f31:	7d 3f                	jge    4f72 <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4f33:	8b 45 14             	mov    0x14(%ebp),%eax
    4f36:	83 e8 01             	sub    $0x1,%eax
    4f39:	83 ec 0c             	sub    $0xc,%esp
    4f3c:	ff 75 18             	pushl  0x18(%ebp)
    4f3f:	50                   	push   %eax
    4f40:	ff 75 10             	pushl  0x10(%ebp)
    4f43:	ff 75 0c             	pushl  0xc(%ebp)
    4f46:	ff 75 08             	pushl  0x8(%ebp)
    4f49:	e8 53 fe ff ff       	call   4da1 <boundaryPM>
    4f4e:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4f51:	8b 45 14             	mov    0x14(%ebp),%eax
    4f54:	83 e8 01             	sub    $0x1,%eax
    4f57:	83 ec 0c             	sub    $0xc,%esp
    4f5a:	ff 75 18             	pushl  0x18(%ebp)
    4f5d:	50                   	push   %eax
    4f5e:	ff 75 10             	pushl  0x10(%ebp)
    4f61:	ff 75 0c             	pushl  0xc(%ebp)
    4f64:	ff 75 08             	pushl  0x8(%ebp)
    4f67:	e8 35 fe ff ff       	call   4da1 <boundaryPM>
    4f6c:	83 c4 20             	add    $0x20,%esp
    4f6f:	eb 01                	jmp    4f72 <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    4f71:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    4f72:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4f75:	5b                   	pop    %ebx
    4f76:	5e                   	pop    %esi
    4f77:	5d                   	pop    %ebp
    4f78:	c3                   	ret    

00004f79 <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    4f79:	55                   	push   %ebp
    4f7a:	89 e5                	mov    %esp,%ebp
    4f7c:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    4f7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    4f86:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    4f8d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    4f91:	75 0a                	jne    4f9d <lodepng_huffman_code_lengths+0x24>
    4f93:	b8 50 00 00 00       	mov    $0x50,%eax
    4f98:	e9 4d 03 00 00       	jmp    52ea <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    4f9d:	8b 45 14             	mov    0x14(%ebp),%eax
    4fa0:	ba 01 00 00 00       	mov    $0x1,%edx
    4fa5:	89 c1                	mov    %eax,%ecx
    4fa7:	d3 e2                	shl    %cl,%edx
    4fa9:	8b 45 10             	mov    0x10(%ebp),%eax
    4fac:	39 c2                	cmp    %eax,%edx
    4fae:	73 0a                	jae    4fba <lodepng_huffman_code_lengths+0x41>
    4fb0:	b8 50 00 00 00       	mov    $0x50,%eax
    4fb5:	e9 30 03 00 00       	jmp    52ea <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    4fba:	8b 45 10             	mov    0x10(%ebp),%eax
    4fbd:	c1 e0 04             	shl    $0x4,%eax
    4fc0:	83 ec 0c             	sub    $0xc,%esp
    4fc3:	50                   	push   %eax
    4fc4:	e8 f7 e3 ff ff       	call   33c0 <lodepng_malloc>
    4fc9:	83 c4 10             	add    $0x10,%esp
    4fcc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    4fcf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4fd3:	75 0a                	jne    4fdf <lodepng_huffman_code_lengths+0x66>
    4fd5:	b8 53 00 00 00       	mov    $0x53,%eax
    4fda:	e9 0b 03 00 00       	jmp    52ea <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    4fdf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4fe6:	eb 50                	jmp    5038 <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    4fe8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4feb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4ff2:	8b 45 0c             	mov    0xc(%ebp),%eax
    4ff5:	01 d0                	add    %edx,%eax
    4ff7:	8b 00                	mov    (%eax),%eax
    4ff9:	85 c0                	test   %eax,%eax
    4ffb:	74 37                	je     5034 <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    4ffd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5000:	c1 e0 04             	shl    $0x4,%eax
    5003:	89 c2                	mov    %eax,%edx
    5005:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5008:	01 d0                	add    %edx,%eax
    500a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    500d:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    5014:	8b 55 0c             	mov    0xc(%ebp),%edx
    5017:	01 ca                	add    %ecx,%edx
    5019:	8b 12                	mov    (%edx),%edx
    501b:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    501d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5020:	c1 e0 04             	shl    $0x4,%eax
    5023:	89 c2                	mov    %eax,%edx
    5025:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5028:	01 c2                	add    %eax,%edx
    502a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    502d:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    5030:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    5034:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5038:	8b 45 10             	mov    0x10(%ebp),%eax
    503b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    503e:	75 a8                	jne    4fe8 <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    5040:	8b 45 10             	mov    0x10(%ebp),%eax
    5043:	c1 e0 02             	shl    $0x2,%eax
    5046:	83 ec 04             	sub    $0x4,%esp
    5049:	50                   	push   %eax
    504a:	6a 00                	push   $0x0
    504c:	ff 75 08             	pushl  0x8(%ebp)
    504f:	e8 dd e3 ff ff       	call   3431 <lodepng_memset>
    5054:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    5057:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    505b:	75 18                	jne    5075 <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    505d:	8b 45 08             	mov    0x8(%ebp),%eax
    5060:	83 c0 04             	add    $0x4,%eax
    5063:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    5069:	8b 10                	mov    (%eax),%edx
    506b:	8b 45 08             	mov    0x8(%ebp),%eax
    506e:	89 10                	mov    %edx,(%eax)
    5070:	e9 64 02 00 00       	jmp    52d9 <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    5075:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    5079:	75 3e                	jne    50b9 <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    507b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    507e:	8b 40 04             	mov    0x4(%eax),%eax
    5081:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5088:	8b 45 08             	mov    0x8(%ebp),%eax
    508b:	01 d0                	add    %edx,%eax
    508d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    5093:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5096:	8b 40 04             	mov    0x4(%eax),%eax
    5099:	85 c0                	test   %eax,%eax
    509b:	75 07                	jne    50a4 <lodepng_huffman_code_lengths+0x12b>
    509d:	ba 04 00 00 00       	mov    $0x4,%edx
    50a2:	eb 05                	jmp    50a9 <lodepng_huffman_code_lengths+0x130>
    50a4:	ba 00 00 00 00       	mov    $0x0,%edx
    50a9:	8b 45 08             	mov    0x8(%ebp),%eax
    50ac:	01 d0                	add    %edx,%eax
    50ae:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    50b4:	e9 20 02 00 00       	jmp    52d9 <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    50b9:	83 ec 08             	sub    $0x8,%esp
    50bc:	ff 75 ec             	pushl  -0x14(%ebp)
    50bf:	ff 75 e4             	pushl  -0x1c(%ebp)
    50c2:	e8 2c fb ff ff       	call   4bf3 <bpmnode_sort>
    50c7:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    50ca:	8b 45 14             	mov    0x14(%ebp),%eax
    50cd:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    50d0:	8b 45 14             	mov    0x14(%ebp),%eax
    50d3:	83 c0 01             	add    $0x1,%eax
    50d6:	0f af 45 14          	imul   0x14(%ebp),%eax
    50da:	01 c0                	add    %eax,%eax
    50dc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    50df:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    50e6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    50e9:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    50ec:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    50ef:	c1 e0 04             	shl    $0x4,%eax
    50f2:	83 ec 0c             	sub    $0xc,%esp
    50f5:	50                   	push   %eax
    50f6:	e8 c5 e2 ff ff       	call   33c0 <lodepng_malloc>
    50fb:	83 c4 10             	add    $0x10,%esp
    50fe:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    5101:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5104:	c1 e0 02             	shl    $0x2,%eax
    5107:	83 ec 0c             	sub    $0xc,%esp
    510a:	50                   	push   %eax
    510b:	e8 b0 e2 ff ff       	call   33c0 <lodepng_malloc>
    5110:	83 c4 10             	add    $0x10,%esp
    5113:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5116:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5119:	c1 e0 02             	shl    $0x2,%eax
    511c:	83 ec 0c             	sub    $0xc,%esp
    511f:	50                   	push   %eax
    5120:	e8 9b e2 ff ff       	call   33c0 <lodepng_malloc>
    5125:	83 c4 10             	add    $0x10,%esp
    5128:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    512b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    512e:	c1 e0 02             	shl    $0x2,%eax
    5131:	83 ec 0c             	sub    $0xc,%esp
    5134:	50                   	push   %eax
    5135:	e8 86 e2 ff ff       	call   33c0 <lodepng_malloc>
    513a:	83 c4 10             	add    $0x10,%esp
    513d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    5140:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5143:	85 c0                	test   %eax,%eax
    5145:	74 15                	je     515c <lodepng_huffman_code_lengths+0x1e3>
    5147:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    514a:	85 c0                	test   %eax,%eax
    514c:	74 0e                	je     515c <lodepng_huffman_code_lengths+0x1e3>
    514e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5151:	85 c0                	test   %eax,%eax
    5153:	74 07                	je     515c <lodepng_huffman_code_lengths+0x1e3>
    5155:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5158:	85 c0                	test   %eax,%eax
    515a:	75 07                	jne    5163 <lodepng_huffman_code_lengths+0x1ea>
    515c:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    5163:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5167:	0f 85 30 01 00 00    	jne    529d <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    516d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5174:	eb 1c                	jmp    5192 <lodepng_huffman_code_lengths+0x219>
    5176:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5179:	8b 55 f0             	mov    -0x10(%ebp),%edx
    517c:	c1 e2 02             	shl    $0x2,%edx
    517f:	01 d0                	add    %edx,%eax
    5181:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5184:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5187:	c1 e1 04             	shl    $0x4,%ecx
    518a:	01 ca                	add    %ecx,%edx
    518c:	89 10                	mov    %edx,(%eax)
    518e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5192:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5195:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5198:	75 dc                	jne    5176 <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    519a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    519d:	8b 00                	mov    (%eax),%eax
    519f:	6a 00                	push   $0x0
    51a1:	6a 01                	push   $0x1
    51a3:	50                   	push   %eax
    51a4:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    51a7:	50                   	push   %eax
    51a8:	e8 de f8 ff ff       	call   4a8b <bpmnode_create>
    51ad:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    51b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    51b3:	83 c0 10             	add    $0x10,%eax
    51b6:	8b 00                	mov    (%eax),%eax
    51b8:	6a 00                	push   $0x0
    51ba:	6a 02                	push   $0x2
    51bc:	50                   	push   %eax
    51bd:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    51c0:	50                   	push   %eax
    51c1:	e8 c5 f8 ff ff       	call   4a8b <bpmnode_create>
    51c6:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    51c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    51d0:	eb 27                	jmp    51f9 <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    51d2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    51d5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    51d8:	c1 e2 02             	shl    $0x2,%edx
    51db:	01 c2                	add    %eax,%edx
    51dd:	8b 45 c8             	mov    -0x38(%ebp),%eax
    51e0:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    51e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    51e5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    51e8:	c1 e2 02             	shl    $0x2,%edx
    51eb:	01 d0                	add    %edx,%eax
    51ed:	8b 55 c8             	mov    -0x38(%ebp),%edx
    51f0:	83 c2 10             	add    $0x10,%edx
    51f3:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    51f5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    51f9:	8b 45 d8             	mov    -0x28(%ebp),%eax
    51fc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    51ff:	75 d1                	jne    51d2 <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    5201:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    5208:	eb 24                	jmp    522e <lodepng_huffman_code_lengths+0x2b5>
    520a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    520d:	8b 55 14             	mov    0x14(%ebp),%edx
    5210:	83 ea 01             	sub    $0x1,%edx
    5213:	83 ec 0c             	sub    $0xc,%esp
    5216:	50                   	push   %eax
    5217:	52                   	push   %edx
    5218:	ff 75 ec             	pushl  -0x14(%ebp)
    521b:	ff 75 e4             	pushl  -0x1c(%ebp)
    521e:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5221:	50                   	push   %eax
    5222:	e8 7a fb ff ff       	call   4da1 <boundaryPM>
    5227:	83 c4 20             	add    $0x20,%esp
    522a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    522e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5231:	83 e8 01             	sub    $0x1,%eax
    5234:	01 c0                	add    %eax,%eax
    5236:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5239:	75 cf                	jne    520a <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    523b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    523e:	8b 55 14             	mov    0x14(%ebp),%edx
    5241:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5247:	c1 e2 02             	shl    $0x2,%edx
    524a:	01 d0                	add    %edx,%eax
    524c:	8b 00                	mov    (%eax),%eax
    524e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5251:	eb 44                	jmp    5297 <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    5253:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    525a:	eb 27                	jmp    5283 <lodepng_huffman_code_lengths+0x30a>
    525c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    525f:	c1 e0 04             	shl    $0x4,%eax
    5262:	89 c2                	mov    %eax,%edx
    5264:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5267:	01 d0                	add    %edx,%eax
    5269:	8b 40 04             	mov    0x4(%eax),%eax
    526c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5273:	8b 45 08             	mov    0x8(%ebp),%eax
    5276:	01 d0                	add    %edx,%eax
    5278:	8b 10                	mov    (%eax),%edx
    527a:	83 c2 01             	add    $0x1,%edx
    527d:	89 10                	mov    %edx,(%eax)
    527f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5283:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5286:	8b 40 04             	mov    0x4(%eax),%eax
    5289:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    528c:	75 ce                	jne    525c <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    528e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5291:	8b 40 08             	mov    0x8(%eax),%eax
    5294:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5297:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    529b:	75 b6                	jne    5253 <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    529d:	8b 45 c8             	mov    -0x38(%ebp),%eax
    52a0:	83 ec 0c             	sub    $0xc,%esp
    52a3:	50                   	push   %eax
    52a4:	e8 38 e1 ff ff       	call   33e1 <lodepng_free>
    52a9:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    52ac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    52af:	83 ec 0c             	sub    $0xc,%esp
    52b2:	50                   	push   %eax
    52b3:	e8 29 e1 ff ff       	call   33e1 <lodepng_free>
    52b8:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    52bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
    52be:	83 ec 0c             	sub    $0xc,%esp
    52c1:	50                   	push   %eax
    52c2:	e8 1a e1 ff ff       	call   33e1 <lodepng_free>
    52c7:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    52ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
    52cd:	83 ec 0c             	sub    $0xc,%esp
    52d0:	50                   	push   %eax
    52d1:	e8 0b e1 ff ff       	call   33e1 <lodepng_free>
    52d6:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    52d9:	83 ec 0c             	sub    $0xc,%esp
    52dc:	ff 75 e4             	pushl  -0x1c(%ebp)
    52df:	e8 fd e0 ff ff       	call   33e1 <lodepng_free>
    52e4:	83 c4 10             	add    $0x10,%esp
  return error;
    52e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    52ea:	c9                   	leave  
    52eb:	c3                   	ret    

000052ec <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    52ec:	55                   	push   %ebp
    52ed:	89 e5                	mov    %esp,%ebp
    52ef:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    52f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    52f9:	eb 04                	jmp    52ff <HuffmanTree_makeFromFrequencies+0x13>
    52fb:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    52ff:	8b 45 14             	mov    0x14(%ebp),%eax
    5302:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5307:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    530e:	8b 45 0c             	mov    0xc(%ebp),%eax
    5311:	01 d0                	add    %edx,%eax
    5313:	8b 00                	mov    (%eax),%eax
    5315:	85 c0                	test   %eax,%eax
    5317:	75 08                	jne    5321 <HuffmanTree_makeFromFrequencies+0x35>
    5319:	8b 45 14             	mov    0x14(%ebp),%eax
    531c:	3b 45 10             	cmp    0x10(%ebp),%eax
    531f:	7f da                	jg     52fb <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    5321:	8b 45 14             	mov    0x14(%ebp),%eax
    5324:	c1 e0 02             	shl    $0x2,%eax
    5327:	83 ec 0c             	sub    $0xc,%esp
    532a:	50                   	push   %eax
    532b:	e8 90 e0 ff ff       	call   33c0 <lodepng_malloc>
    5330:	83 c4 10             	add    $0x10,%esp
    5333:	89 c2                	mov    %eax,%edx
    5335:	8b 45 08             	mov    0x8(%ebp),%eax
    5338:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    533b:	8b 45 08             	mov    0x8(%ebp),%eax
    533e:	8b 40 04             	mov    0x4(%eax),%eax
    5341:	85 c0                	test   %eax,%eax
    5343:	75 07                	jne    534c <HuffmanTree_makeFromFrequencies+0x60>
    5345:	b8 53 00 00 00       	mov    $0x53,%eax
    534a:	eb 47                	jmp    5393 <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    534c:	8b 45 08             	mov    0x8(%ebp),%eax
    534f:	8b 55 18             	mov    0x18(%ebp),%edx
    5352:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    5355:	8b 55 14             	mov    0x14(%ebp),%edx
    5358:	8b 45 08             	mov    0x8(%ebp),%eax
    535b:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    535e:	8b 45 08             	mov    0x8(%ebp),%eax
    5361:	8b 40 04             	mov    0x4(%eax),%eax
    5364:	ff 75 18             	pushl  0x18(%ebp)
    5367:	ff 75 14             	pushl  0x14(%ebp)
    536a:	ff 75 0c             	pushl  0xc(%ebp)
    536d:	50                   	push   %eax
    536e:	e8 06 fc ff ff       	call   4f79 <lodepng_huffman_code_lengths>
    5373:	83 c4 10             	add    $0x10,%esp
    5376:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    5379:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    537d:	75 11                	jne    5390 <HuffmanTree_makeFromFrequencies+0xa4>
    537f:	83 ec 0c             	sub    $0xc,%esp
    5382:	ff 75 08             	pushl  0x8(%ebp)
    5385:	e8 37 f4 ff ff       	call   47c1 <HuffmanTree_makeFromLengths2>
    538a:	83 c4 10             	add    $0x10,%esp
    538d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    5390:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5393:	c9                   	leave  
    5394:	c3                   	ret    

00005395 <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    5395:	55                   	push   %ebp
    5396:	89 e5                	mov    %esp,%ebp
    5398:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    539b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    53a2:	83 ec 0c             	sub    $0xc,%esp
    53a5:	68 80 04 00 00       	push   $0x480
    53aa:	e8 11 e0 ff ff       	call   33c0 <lodepng_malloc>
    53af:	83 c4 10             	add    $0x10,%esp
    53b2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    53b5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    53b9:	75 0a                	jne    53c5 <generateFixedLitLenTree+0x30>
    53bb:	b8 53 00 00 00       	mov    $0x53,%eax
    53c0:	e9 d5 00 00 00       	jmp    549a <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    53c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    53cc:	eb 19                	jmp    53e7 <generateFixedLitLenTree+0x52>
    53ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53d1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    53d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    53db:	01 d0                	add    %edx,%eax
    53dd:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    53e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    53e7:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    53ee:	76 de                	jbe    53ce <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    53f0:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    53f7:	eb 19                	jmp    5412 <generateFixedLitLenTree+0x7d>
    53f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53fc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5403:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5406:	01 d0                	add    %edx,%eax
    5408:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    540e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5412:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    5419:	76 de                	jbe    53f9 <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    541b:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    5422:	eb 19                	jmp    543d <generateFixedLitLenTree+0xa8>
    5424:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5427:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    542e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5431:	01 d0                	add    %edx,%eax
    5433:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    5439:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    543d:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    5444:	76 de                	jbe    5424 <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    5446:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    544d:	eb 19                	jmp    5468 <generateFixedLitLenTree+0xd3>
    544f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5452:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5459:	8b 45 ec             	mov    -0x14(%ebp),%eax
    545c:	01 d0                	add    %edx,%eax
    545e:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5464:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5468:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    546f:	76 de                	jbe    544f <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5471:	6a 0f                	push   $0xf
    5473:	68 20 01 00 00       	push   $0x120
    5478:	ff 75 ec             	pushl  -0x14(%ebp)
    547b:	ff 75 08             	pushl  0x8(%ebp)
    547e:	e8 7f f5 ff ff       	call   4a02 <HuffmanTree_makeFromLengths>
    5483:	83 c4 10             	add    $0x10,%esp
    5486:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    5489:	83 ec 0c             	sub    $0xc,%esp
    548c:	ff 75 ec             	pushl  -0x14(%ebp)
    548f:	e8 4d df ff ff       	call   33e1 <lodepng_free>
    5494:	83 c4 10             	add    $0x10,%esp
  return error;
    5497:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    549a:	c9                   	leave  
    549b:	c3                   	ret    

0000549c <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    549c:	55                   	push   %ebp
    549d:	89 e5                	mov    %esp,%ebp
    549f:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    54a2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    54a9:	83 ec 0c             	sub    $0xc,%esp
    54ac:	68 80 00 00 00       	push   $0x80
    54b1:	e8 0a df ff ff       	call   33c0 <lodepng_malloc>
    54b6:	83 c4 10             	add    $0x10,%esp
    54b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    54bc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    54c0:	75 07                	jne    54c9 <generateFixedDistanceTree+0x2d>
    54c2:	b8 53 00 00 00       	mov    $0x53,%eax
    54c7:	eb 4e                	jmp    5517 <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    54c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    54d0:	eb 19                	jmp    54eb <generateFixedDistanceTree+0x4f>
    54d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    54d5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    54dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    54df:	01 d0                	add    %edx,%eax
    54e1:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    54e7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    54eb:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    54ef:	75 e1                	jne    54d2 <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    54f1:	6a 0f                	push   $0xf
    54f3:	6a 20                	push   $0x20
    54f5:	ff 75 ec             	pushl  -0x14(%ebp)
    54f8:	ff 75 08             	pushl  0x8(%ebp)
    54fb:	e8 02 f5 ff ff       	call   4a02 <HuffmanTree_makeFromLengths>
    5500:	83 c4 10             	add    $0x10,%esp
    5503:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    5506:	83 ec 0c             	sub    $0xc,%esp
    5509:	ff 75 ec             	pushl  -0x14(%ebp)
    550c:	e8 d0 de ff ff       	call   33e1 <lodepng_free>
    5511:	83 c4 10             	add    $0x10,%esp
  return error;
    5514:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    5517:	c9                   	leave  
    5518:	c3                   	ret    

00005519 <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    5519:	55                   	push   %ebp
    551a:	89 e5                	mov    %esp,%ebp
    551c:	53                   	push   %ebx
    551d:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    5520:	6a 09                	push   $0x9
    5522:	ff 75 08             	pushl  0x8(%ebp)
    5525:	e8 d8 eb ff ff       	call   4102 <peekBits>
    552a:	83 c4 08             	add    $0x8,%esp
    552d:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    5531:	8b 45 0c             	mov    0xc(%ebp),%eax
    5534:	8b 50 10             	mov    0x10(%eax),%edx
    5537:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    553b:	01 d0                	add    %edx,%eax
    553d:	0f b6 00             	movzbl (%eax),%eax
    5540:	0f b6 c0             	movzbl %al,%eax
    5543:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    5547:	8b 45 0c             	mov    0xc(%ebp),%eax
    554a:	8b 40 14             	mov    0x14(%eax),%eax
    554d:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    5551:	01 d2                	add    %edx,%edx
    5553:	01 d0                	add    %edx,%eax
    5555:	0f b7 00             	movzwl (%eax),%eax
    5558:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    555c:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    5561:	77 16                	ja     5579 <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    5563:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    5567:	50                   	push   %eax
    5568:	ff 75 08             	pushl  0x8(%ebp)
    556b:	e8 b2 eb ff ff       	call   4122 <advanceBits>
    5570:	83 c4 08             	add    $0x8,%esp
    return value;
    5573:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    5577:	eb 5c                	jmp    55d5 <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    5579:	6a 09                	push   $0x9
    557b:	ff 75 08             	pushl  0x8(%ebp)
    557e:	e8 9f eb ff ff       	call   4122 <advanceBits>
    5583:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    5586:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    558a:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    558e:	83 e8 09             	sub    $0x9,%eax
    5591:	50                   	push   %eax
    5592:	ff 75 08             	pushl  0x8(%ebp)
    5595:	e8 68 eb ff ff       	call   4102 <peekBits>
    559a:	83 c4 08             	add    $0x8,%esp
    559d:	01 d8                	add    %ebx,%eax
    559f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    55a2:	8b 45 0c             	mov    0xc(%ebp),%eax
    55a5:	8b 50 10             	mov    0x10(%eax),%edx
    55a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    55ab:	01 d0                	add    %edx,%eax
    55ad:	0f b6 00             	movzbl (%eax),%eax
    55b0:	0f b6 c0             	movzbl %al,%eax
    55b3:	83 e8 09             	sub    $0x9,%eax
    55b6:	50                   	push   %eax
    55b7:	ff 75 08             	pushl  0x8(%ebp)
    55ba:	e8 63 eb ff ff       	call   4122 <advanceBits>
    55bf:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    55c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    55c5:	8b 40 14             	mov    0x14(%eax),%eax
    55c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    55cb:	01 d2                	add    %edx,%edx
    55cd:	01 d0                	add    %edx,%eax
    55cf:	0f b7 00             	movzwl (%eax),%eax
    55d2:	0f b7 c0             	movzwl %ax,%eax
  }
}
    55d5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    55d8:	c9                   	leave  
    55d9:	c3                   	ret    

000055da <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    55da:	55                   	push   %ebp
    55db:	89 e5                	mov    %esp,%ebp
    55dd:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    55e0:	83 ec 0c             	sub    $0xc,%esp
    55e3:	ff 75 08             	pushl  0x8(%ebp)
    55e6:	e8 aa fd ff ff       	call   5395 <generateFixedLitLenTree>
    55eb:	83 c4 10             	add    $0x10,%esp
    55ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    55f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    55f5:	74 05                	je     55fc <getTreeInflateFixed+0x22>
    55f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    55fa:	eb 0e                	jmp    560a <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    55fc:	83 ec 0c             	sub    $0xc,%esp
    55ff:	ff 75 0c             	pushl  0xc(%ebp)
    5602:	e8 95 fe ff ff       	call   549c <generateFixedDistanceTree>
    5607:	83 c4 10             	add    $0x10,%esp
}
    560a:	c9                   	leave  
    560b:	c3                   	ret    

0000560c <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    560c:	55                   	push   %ebp
    560d:	89 e5                	mov    %esp,%ebp
    560f:	53                   	push   %ebx
    5610:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    5613:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    561a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    5621:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    5628:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    562f:	6a 0e                	push   $0xe
    5631:	ff 75 10             	pushl  0x10(%ebp)
    5634:	e8 37 e6 ff ff       	call   3c70 <ensureBits17>
    5639:	83 c4 08             	add    $0x8,%esp
    563c:	85 c0                	test   %eax,%eax
    563e:	75 0a                	jne    564a <getTreeInflateDynamic+0x3e>
    5640:	b8 31 00 00 00       	mov    $0x31,%eax
    5645:	e9 ec 04 00 00       	jmp    5b36 <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    564a:	6a 05                	push   $0x5
    564c:	ff 75 10             	pushl  0x10(%ebp)
    564f:	e8 f8 ea ff ff       	call   414c <readBits>
    5654:	83 c4 08             	add    $0x8,%esp
    5657:	05 01 01 00 00       	add    $0x101,%eax
    565c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    565f:	6a 05                	push   $0x5
    5661:	ff 75 10             	pushl  0x10(%ebp)
    5664:	e8 e3 ea ff ff       	call   414c <readBits>
    5669:	83 c4 08             	add    $0x8,%esp
    566c:	83 c0 01             	add    $0x1,%eax
    566f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    5672:	6a 04                	push   $0x4
    5674:	ff 75 10             	pushl  0x10(%ebp)
    5677:	e8 d0 ea ff ff       	call   414c <readBits>
    567c:	83 c4 08             	add    $0x8,%esp
    567f:	83 c0 04             	add    $0x4,%eax
    5682:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    5685:	83 ec 0c             	sub    $0xc,%esp
    5688:	6a 4c                	push   $0x4c
    568a:	e8 31 dd ff ff       	call   33c0 <lodepng_malloc>
    568f:	83 c4 10             	add    $0x10,%esp
    5692:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    5695:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    5699:	75 0a                	jne    56a5 <getTreeInflateDynamic+0x99>
    569b:	b8 53 00 00 00       	mov    $0x53,%eax
    56a0:	e9 91 04 00 00       	jmp    5b36 <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    56a5:	83 ec 0c             	sub    $0xc,%esp
    56a8:	8d 45 a8             	lea    -0x58(%ebp),%eax
    56ab:	50                   	push   %eax
    56ac:	e8 03 ec ff ff       	call   42b4 <HuffmanTree_init>
    56b1:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    56b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    56b8:	0f 85 3c 04 00 00    	jne    5afa <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    56be:	8b 45 10             	mov    0x10(%ebp),%eax
    56c1:	8b 48 08             	mov    0x8(%eax),%ecx
    56c4:	8b 55 d0             	mov    -0x30(%ebp),%edx
    56c7:	89 d0                	mov    %edx,%eax
    56c9:	01 c0                	add    %eax,%eax
    56cb:	01 d0                	add    %edx,%eax
    56cd:	89 c2                	mov    %eax,%edx
    56cf:	8b 45 10             	mov    0x10(%ebp),%eax
    56d2:	8b 40 0c             	mov    0xc(%eax),%eax
    56d5:	83 ec 04             	sub    $0x4,%esp
    56d8:	51                   	push   %ecx
    56d9:	52                   	push   %edx
    56da:	50                   	push   %eax
    56db:	e8 f7 dd ff ff       	call   34d7 <lodepng_gtofl>
    56e0:	83 c4 10             	add    $0x10,%esp
    56e3:	85 c0                	test   %eax,%eax
    56e5:	74 0c                	je     56f3 <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    56e7:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    56ee:	e9 07 04 00 00       	jmp    5afa <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    56f3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    56fa:	eb 3d                	jmp    5739 <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    56fc:	83 ec 08             	sub    $0x8,%esp
    56ff:	6a 03                	push   $0x3
    5701:	ff 75 10             	pushl  0x10(%ebp)
    5704:	e8 8b e4 ff ff       	call   3b94 <ensureBits9>
    5709:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    570c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    570f:	8b 04 85 e0 9f 01 00 	mov    0x19fe0(,%eax,4),%eax
    5716:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    571d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5720:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    5723:	83 ec 08             	sub    $0x8,%esp
    5726:	6a 03                	push   $0x3
    5728:	ff 75 10             	pushl  0x10(%ebp)
    572b:	e8 1c ea ff ff       	call   414c <readBits>
    5730:	83 c4 10             	add    $0x10,%esp
    5733:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    5735:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5739:	8b 45 ec             	mov    -0x14(%ebp),%eax
    573c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    573f:	75 bb                	jne    56fc <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5741:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5744:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5747:	eb 20                	jmp    5769 <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    5749:	8b 45 ec             	mov    -0x14(%ebp),%eax
    574c:	8b 04 85 e0 9f 01 00 	mov    0x19fe0(,%eax,4),%eax
    5753:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    575a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    575d:	01 d0                	add    %edx,%eax
    575f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5765:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5769:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    576d:	75 da                	jne    5749 <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    576f:	6a 07                	push   $0x7
    5771:	6a 13                	push   $0x13
    5773:	ff 75 dc             	pushl  -0x24(%ebp)
    5776:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5779:	50                   	push   %eax
    577a:	e8 83 f2 ff ff       	call   4a02 <HuffmanTree_makeFromLengths>
    577f:	83 c4 10             	add    $0x10,%esp
    5782:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5785:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5789:	0f 85 64 03 00 00    	jne    5af3 <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    578f:	83 ec 0c             	sub    $0xc,%esp
    5792:	68 80 04 00 00       	push   $0x480
    5797:	e8 24 dc ff ff       	call   33c0 <lodepng_malloc>
    579c:	83 c4 10             	add    $0x10,%esp
    579f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    57a2:	83 ec 0c             	sub    $0xc,%esp
    57a5:	68 80 00 00 00       	push   $0x80
    57aa:	e8 11 dc ff ff       	call   33c0 <lodepng_malloc>
    57af:	83 c4 10             	add    $0x10,%esp
    57b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    57b5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    57b9:	74 06                	je     57c1 <getTreeInflateDynamic+0x1b5>
    57bb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    57bf:	75 0c                	jne    57cd <getTreeInflateDynamic+0x1c1>
    57c1:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    57c8:	e9 2d 03 00 00       	jmp    5afa <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    57cd:	83 ec 04             	sub    $0x4,%esp
    57d0:	68 80 04 00 00       	push   $0x480
    57d5:	6a 00                	push   $0x0
    57d7:	ff 75 e8             	pushl  -0x18(%ebp)
    57da:	e8 52 dc ff ff       	call   3431 <lodepng_memset>
    57df:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    57e2:	83 ec 04             	sub    $0x4,%esp
    57e5:	68 80 00 00 00       	push   $0x80
    57ea:	6a 00                	push   $0x0
    57ec:	ff 75 e4             	pushl  -0x1c(%ebp)
    57ef:	e8 3d dc ff ff       	call   3431 <lodepng_memset>
    57f4:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    57f7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    57fe:	e9 8d 02 00 00       	jmp    5a90 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    5803:	83 ec 08             	sub    $0x8,%esp
    5806:	6a 16                	push   $0x16
    5808:	ff 75 10             	pushl  0x10(%ebp)
    580b:	e8 8c e5 ff ff       	call   3d9c <ensureBits25>
    5810:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    5813:	83 ec 08             	sub    $0x8,%esp
    5816:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5819:	50                   	push   %eax
    581a:	ff 75 10             	pushl  0x10(%ebp)
    581d:	e8 f7 fc ff ff       	call   5519 <huffmanDecodeSymbol>
    5822:	83 c4 10             	add    $0x10,%esp
    5825:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    5828:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    582c:	77 3e                	ja     586c <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    582e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5831:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5834:	73 16                	jae    584c <getTreeInflateDynamic+0x240>
    5836:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5839:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5840:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5843:	01 c2                	add    %eax,%edx
    5845:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5848:	89 02                	mov    %eax,(%edx)
    584a:	eb 17                	jmp    5863 <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    584c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    584f:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5852:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5859:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    585c:	01 c2                	add    %eax,%edx
    585e:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5861:	89 02                	mov    %eax,(%edx)
        ++i;
    5863:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5867:	e9 0b 02 00 00       	jmp    5a77 <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    586c:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    5870:	0f 85 da 00 00 00    	jne    5950 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    5876:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    587d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5881:	75 0c                	jne    588f <getTreeInflateDynamic+0x283>
    5883:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    588a:	e9 12 02 00 00       	jmp    5aa1 <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    588f:	83 ec 08             	sub    $0x8,%esp
    5892:	6a 02                	push   $0x2
    5894:	ff 75 10             	pushl  0x10(%ebp)
    5897:	e8 b0 e8 ff ff       	call   414c <readBits>
    589c:	83 c4 10             	add    $0x10,%esp
    589f:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    58a2:	8b 45 d8             	mov    -0x28(%ebp),%eax
    58a5:	83 c0 01             	add    $0x1,%eax
    58a8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    58ab:	76 1b                	jbe    58c8 <getTreeInflateDynamic+0x2bc>
    58ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58b0:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    58b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    58bf:	01 d0                	add    %edx,%eax
    58c1:	8b 00                	mov    (%eax),%eax
    58c3:	89 45 e0             	mov    %eax,-0x20(%ebp)
    58c6:	eb 1c                	jmp    58e4 <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    58c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58cb:	2b 45 d8             	sub    -0x28(%ebp),%eax
    58ce:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    58d3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    58dd:	01 d0                	add    %edx,%eax
    58df:	8b 00                	mov    (%eax),%eax
    58e1:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    58e4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    58eb:	eb 56                	jmp    5943 <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    58ed:	8b 55 d8             	mov    -0x28(%ebp),%edx
    58f0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    58f3:	01 d0                	add    %edx,%eax
    58f5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    58f8:	77 0c                	ja     5906 <getTreeInflateDynamic+0x2fa>
    58fa:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    5901:	e9 71 01 00 00       	jmp    5a77 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    5906:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5909:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    590c:	73 16                	jae    5924 <getTreeInflateDynamic+0x318>
    590e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5911:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5918:	8b 45 e8             	mov    -0x18(%ebp),%eax
    591b:	01 c2                	add    %eax,%edx
    591d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5920:	89 02                	mov    %eax,(%edx)
    5922:	eb 17                	jmp    593b <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    5924:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5927:	2b 45 d8             	sub    -0x28(%ebp),%eax
    592a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5931:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5934:	01 c2                	add    %eax,%edx
    5936:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5939:	89 02                	mov    %eax,(%edx)
          ++i;
    593b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    593f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5943:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5946:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    5949:	72 a2                	jb     58ed <getTreeInflateDynamic+0x2e1>
    594b:	e9 27 01 00 00       	jmp    5a77 <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    5950:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    5954:	0f 85 88 00 00 00    	jne    59e2 <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    595a:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    5961:	83 ec 08             	sub    $0x8,%esp
    5964:	6a 03                	push   $0x3
    5966:	ff 75 10             	pushl  0x10(%ebp)
    5969:	e8 de e7 ff ff       	call   414c <readBits>
    596e:	83 c4 10             	add    $0x10,%esp
    5971:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5974:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    597b:	eb 58                	jmp    59d5 <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    597d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5980:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5983:	01 d0                	add    %edx,%eax
    5985:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5988:	77 0c                	ja     5996 <getTreeInflateDynamic+0x38a>
    598a:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    5991:	e9 e1 00 00 00       	jmp    5a77 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5996:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5999:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    599c:	73 17                	jae    59b5 <getTreeInflateDynamic+0x3a9>
    599e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    59a8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    59ab:	01 d0                	add    %edx,%eax
    59ad:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    59b3:	eb 18                	jmp    59cd <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    59b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59b8:	2b 45 d8             	sub    -0x28(%ebp),%eax
    59bb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    59c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    59c5:	01 d0                	add    %edx,%eax
    59c7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    59cd:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    59d1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    59d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    59d8:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    59db:	72 a0                	jb     597d <getTreeInflateDynamic+0x371>
    59dd:	e9 95 00 00 00       	jmp    5a77 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    59e2:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    59e6:	0f 85 82 00 00 00    	jne    5a6e <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    59ec:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    59f3:	83 ec 08             	sub    $0x8,%esp
    59f6:	6a 07                	push   $0x7
    59f8:	ff 75 10             	pushl  0x10(%ebp)
    59fb:	e8 4c e7 ff ff       	call   414c <readBits>
    5a00:	83 c4 10             	add    $0x10,%esp
    5a03:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5a06:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5a0d:	eb 55                	jmp    5a64 <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    5a0f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5a12:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5a15:	01 d0                	add    %edx,%eax
    5a17:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5a1a:	77 09                	ja     5a25 <getTreeInflateDynamic+0x419>
    5a1c:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    5a23:	eb 52                	jmp    5a77 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5a25:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a28:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5a2b:	73 17                	jae    5a44 <getTreeInflateDynamic+0x438>
    5a2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a30:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a37:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5a3a:	01 d0                	add    %edx,%eax
    5a3c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5a42:	eb 18                	jmp    5a5c <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    5a44:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a47:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5a4a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5a54:	01 d0                	add    %edx,%eax
    5a56:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5a5c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5a60:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5a64:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5a67:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    5a6a:	72 a3                	jb     5a0f <getTreeInflateDynamic+0x403>
    5a6c:	eb 09                	jmp    5a77 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5a6e:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5a75:	eb 2a                	jmp    5aa1 <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    5a77:	8b 45 10             	mov    0x10(%ebp),%eax
    5a7a:	8b 50 0c             	mov    0xc(%eax),%edx
    5a7d:	8b 45 10             	mov    0x10(%ebp),%eax
    5a80:	8b 40 08             	mov    0x8(%eax),%eax
    5a83:	39 c2                	cmp    %eax,%edx
    5a85:	7e 09                	jle    5a90 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    5a87:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5a8e:	eb 11                	jmp    5aa1 <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    5a90:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5a93:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5a96:	01 d0                	add    %edx,%eax
    5a98:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5a9b:	0f 87 62 fd ff ff    	ja     5803 <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5aa1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5aa5:	75 4f                	jne    5af6 <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    5aa7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5aaa:	05 00 04 00 00       	add    $0x400,%eax
    5aaf:	8b 00                	mov    (%eax),%eax
    5ab1:	85 c0                	test   %eax,%eax
    5ab3:	75 09                	jne    5abe <getTreeInflateDynamic+0x4b2>
    5ab5:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    5abc:	eb 3c                	jmp    5afa <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5abe:	6a 0f                	push   $0xf
    5ac0:	68 20 01 00 00       	push   $0x120
    5ac5:	ff 75 e8             	pushl  -0x18(%ebp)
    5ac8:	ff 75 08             	pushl  0x8(%ebp)
    5acb:	e8 32 ef ff ff       	call   4a02 <HuffmanTree_makeFromLengths>
    5ad0:	83 c4 10             	add    $0x10,%esp
    5ad3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5ad6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5ada:	75 1d                	jne    5af9 <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    5adc:	6a 0f                	push   $0xf
    5ade:	6a 20                	push   $0x20
    5ae0:	ff 75 e4             	pushl  -0x1c(%ebp)
    5ae3:	ff 75 0c             	pushl  0xc(%ebp)
    5ae6:	e8 17 ef ff ff       	call   4a02 <HuffmanTree_makeFromLengths>
    5aeb:	83 c4 10             	add    $0x10,%esp
    5aee:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    5af1:	eb 07                	jmp    5afa <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    5af3:	90                   	nop
    5af4:	eb 04                	jmp    5afa <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5af6:	90                   	nop
    5af7:	eb 01                	jmp    5afa <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    5af9:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    5afa:	83 ec 0c             	sub    $0xc,%esp
    5afd:	ff 75 dc             	pushl  -0x24(%ebp)
    5b00:	e8 dc d8 ff ff       	call   33e1 <lodepng_free>
    5b05:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    5b08:	83 ec 0c             	sub    $0xc,%esp
    5b0b:	ff 75 e8             	pushl  -0x18(%ebp)
    5b0e:	e8 ce d8 ff ff       	call   33e1 <lodepng_free>
    5b13:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    5b16:	83 ec 0c             	sub    $0xc,%esp
    5b19:	ff 75 e4             	pushl  -0x1c(%ebp)
    5b1c:	e8 c0 d8 ff ff       	call   33e1 <lodepng_free>
    5b21:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    5b24:	83 ec 0c             	sub    $0xc,%esp
    5b27:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5b2a:	50                   	push   %eax
    5b2b:	e8 b1 e7 ff ff       	call   42e1 <HuffmanTree_cleanup>
    5b30:	83 c4 10             	add    $0x10,%esp

  return error;
    5b33:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5b36:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5b39:	c9                   	leave  
    5b3a:	c3                   	ret    

00005b3b <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    5b3b:	55                   	push   %ebp
    5b3c:	89 e5                	mov    %esp,%ebp
    5b3e:	53                   	push   %ebx
    5b3f:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    5b42:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    5b49:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5b4c:	50                   	push   %eax
    5b4d:	e8 62 e7 ff ff       	call   42b4 <HuffmanTree_init>
    5b52:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    5b55:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5b58:	50                   	push   %eax
    5b59:	e8 56 e7 ff ff       	call   42b4 <HuffmanTree_init>
    5b5e:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    5b61:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    5b65:	75 1b                	jne    5b82 <inflateHuffmanBlock+0x47>
    5b67:	83 ec 08             	sub    $0x8,%esp
    5b6a:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5b6d:	50                   	push   %eax
    5b6e:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5b71:	50                   	push   %eax
    5b72:	e8 63 fa ff ff       	call   55da <getTreeInflateFixed>
    5b77:	83 c4 10             	add    $0x10,%esp
    5b7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5b7d:	e9 9a 02 00 00       	jmp    5e1c <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    5b82:	83 ec 04             	sub    $0x4,%esp
    5b85:	ff 75 0c             	pushl  0xc(%ebp)
    5b88:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5b8b:	50                   	push   %eax
    5b8c:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5b8f:	50                   	push   %eax
    5b90:	e8 77 fa ff ff       	call   560c <getTreeInflateDynamic>
    5b95:	83 c4 10             	add    $0x10,%esp
    5b98:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5b9b:	e9 7c 02 00 00       	jmp    5e1c <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    5ba0:	83 ec 08             	sub    $0x8,%esp
    5ba3:	6a 14                	push   $0x14
    5ba5:	ff 75 0c             	pushl  0xc(%ebp)
    5ba8:	e8 ef e1 ff ff       	call   3d9c <ensureBits25>
    5bad:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    5bb0:	83 ec 08             	sub    $0x8,%esp
    5bb3:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5bb6:	50                   	push   %eax
    5bb7:	ff 75 0c             	pushl  0xc(%ebp)
    5bba:	e8 5a f9 ff ff       	call   5519 <huffmanDecodeSymbol>
    5bbf:	83 c4 10             	add    $0x10,%esp
    5bc2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    5bc5:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    5bcc:	77 42                	ja     5c10 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    5bce:	8b 45 08             	mov    0x8(%ebp),%eax
    5bd1:	8b 40 04             	mov    0x4(%eax),%eax
    5bd4:	83 c0 01             	add    $0x1,%eax
    5bd7:	83 ec 08             	sub    $0x8,%esp
    5bda:	50                   	push   %eax
    5bdb:	ff 75 08             	pushl  0x8(%ebp)
    5bde:	e8 37 da ff ff       	call   361a <ucvector_resize>
    5be3:	83 c4 10             	add    $0x10,%esp
    5be6:	85 c0                	test   %eax,%eax
    5be8:	75 0c                	jne    5bf6 <inflateHuffmanBlock+0xbb>
    5bea:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5bf1:	e9 33 02 00 00       	jmp    5e29 <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    5bf6:	8b 45 08             	mov    0x8(%ebp),%eax
    5bf9:	8b 10                	mov    (%eax),%edx
    5bfb:	8b 45 08             	mov    0x8(%ebp),%eax
    5bfe:	8b 40 04             	mov    0x4(%eax),%eax
    5c01:	83 e8 01             	sub    $0x1,%eax
    5c04:	01 d0                	add    %edx,%eax
    5c06:	8b 55 dc             	mov    -0x24(%ebp),%edx
    5c09:	88 10                	mov    %dl,(%eax)
    5c0b:	e9 d9 01 00 00       	jmp    5de9 <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5c10:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5c17:	0f 86 ba 01 00 00    	jbe    5dd7 <inflateHuffmanBlock+0x29c>
    5c1d:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    5c24:	0f 87 ad 01 00 00    	ja     5dd7 <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    5c2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5c2d:	2d 01 01 00 00       	sub    $0x101,%eax
    5c32:	8b 04 85 e0 9d 01 00 	mov    0x19de0(,%eax,4),%eax
    5c39:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    5c3c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5c3f:	2d 01 01 00 00       	sub    $0x101,%eax
    5c44:	8b 04 85 60 9e 01 00 	mov    0x19e60(,%eax,4),%eax
    5c4b:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    5c4e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    5c52:	74 1c                	je     5c70 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    5c54:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5c57:	83 ec 08             	sub    $0x8,%esp
    5c5a:	50                   	push   %eax
    5c5b:	ff 75 0c             	pushl  0xc(%ebp)
    5c5e:	e8 e9 e4 ff ff       	call   414c <readBits>
    5c63:	83 c4 10             	add    $0x10,%esp
    5c66:	89 c2                	mov    %eax,%edx
    5c68:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c6b:	01 d0                	add    %edx,%eax
    5c6d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    5c70:	83 ec 08             	sub    $0x8,%esp
    5c73:	6a 1c                	push   $0x1c
    5c75:	ff 75 0c             	pushl  0xc(%ebp)
    5c78:	e8 98 e2 ff ff       	call   3f15 <ensureBits32>
    5c7d:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    5c80:	83 ec 08             	sub    $0x8,%esp
    5c83:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5c86:	50                   	push   %eax
    5c87:	ff 75 0c             	pushl  0xc(%ebp)
    5c8a:	e8 8a f8 ff ff       	call   5519 <huffmanDecodeSymbol>
    5c8f:	83 c4 10             	add    $0x10,%esp
    5c92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    5c95:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    5c99:	76 1e                	jbe    5cb9 <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    5c9b:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    5c9f:	77 0c                	ja     5cad <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    5ca1:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    5ca8:	e9 7c 01 00 00       	jmp    5e29 <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5cad:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5cb4:	e9 70 01 00 00       	jmp    5e29 <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    5cb9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5cbc:	8b 04 85 e0 9e 01 00 	mov    0x19ee0(,%eax,4),%eax
    5cc3:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    5cc6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5cc9:	8b 04 85 60 9f 01 00 	mov    0x19f60(,%eax,4),%eax
    5cd0:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    5cd3:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    5cd7:	74 15                	je     5cee <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    5cd9:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5cdc:	83 ec 08             	sub    $0x8,%esp
    5cdf:	50                   	push   %eax
    5ce0:	ff 75 0c             	pushl  0xc(%ebp)
    5ce3:	e8 64 e4 ff ff       	call   414c <readBits>
    5ce8:	83 c4 10             	add    $0x10,%esp
    5ceb:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    5cee:	8b 45 08             	mov    0x8(%ebp),%eax
    5cf1:	8b 40 04             	mov    0x4(%eax),%eax
    5cf4:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    5cf7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5cfa:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5cfd:	76 0c                	jbe    5d0b <inflateHuffmanBlock+0x1d0>
    5cff:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    5d06:	e9 1e 01 00 00       	jmp    5e29 <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    5d0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d0e:	2b 45 f0             	sub    -0x10(%ebp),%eax
    5d11:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    5d14:	8b 45 08             	mov    0x8(%ebp),%eax
    5d17:	8b 50 04             	mov    0x4(%eax),%edx
    5d1a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5d1d:	01 d0                	add    %edx,%eax
    5d1f:	83 ec 08             	sub    $0x8,%esp
    5d22:	50                   	push   %eax
    5d23:	ff 75 08             	pushl  0x8(%ebp)
    5d26:	e8 ef d8 ff ff       	call   361a <ucvector_resize>
    5d2b:	83 c4 10             	add    $0x10,%esp
    5d2e:	85 c0                	test   %eax,%eax
    5d30:	75 0c                	jne    5d3e <inflateHuffmanBlock+0x203>
    5d32:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5d39:	e9 eb 00 00 00       	jmp    5e29 <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    5d3e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5d41:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5d44:	73 6b                	jae    5db1 <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    5d46:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5d49:	8b 55 08             	mov    0x8(%ebp),%edx
    5d4c:	8b 0a                	mov    (%edx),%ecx
    5d4e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5d51:	01 d1                	add    %edx,%ecx
    5d53:	8b 55 08             	mov    0x8(%ebp),%edx
    5d56:	8b 1a                	mov    (%edx),%ebx
    5d58:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5d5b:	01 da                	add    %ebx,%edx
    5d5d:	83 ec 04             	sub    $0x4,%esp
    5d60:	50                   	push   %eax
    5d61:	51                   	push   %ecx
    5d62:	52                   	push   %edx
    5d63:	e8 96 d6 ff ff       	call   33fe <lodepng_memcpy>
    5d68:	83 c4 10             	add    $0x10,%esp
        start += distance;
    5d6b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5d6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5d71:	01 d0                	add    %edx,%eax
    5d73:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    5d76:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5d79:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5d7c:	eb 29                	jmp    5da7 <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    5d7e:	8b 45 08             	mov    0x8(%ebp),%eax
    5d81:	8b 08                	mov    (%eax),%ecx
    5d83:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d86:	8d 50 01             	lea    0x1(%eax),%edx
    5d89:	89 55 ec             	mov    %edx,-0x14(%ebp)
    5d8c:	01 c1                	add    %eax,%ecx
    5d8e:	8b 45 08             	mov    0x8(%ebp),%eax
    5d91:	8b 18                	mov    (%eax),%ebx
    5d93:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5d96:	8d 50 01             	lea    0x1(%eax),%edx
    5d99:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5d9c:	01 d8                	add    %ebx,%eax
    5d9e:	0f b6 00             	movzbl (%eax),%eax
    5da1:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    5da3:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5da7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5daa:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    5dad:	7c cf                	jl     5d7e <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5daf:	eb 38                	jmp    5de9 <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    5db1:	8b 45 08             	mov    0x8(%ebp),%eax
    5db4:	8b 10                	mov    (%eax),%edx
    5db6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5db9:	01 c2                	add    %eax,%edx
    5dbb:	8b 45 08             	mov    0x8(%ebp),%eax
    5dbe:	8b 08                	mov    (%eax),%ecx
    5dc0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5dc3:	01 c8                	add    %ecx,%eax
    5dc5:	83 ec 04             	sub    $0x4,%esp
    5dc8:	ff 75 e4             	pushl  -0x1c(%ebp)
    5dcb:	52                   	push   %edx
    5dcc:	50                   	push   %eax
    5dcd:	e8 2c d6 ff ff       	call   33fe <lodepng_memcpy>
    5dd2:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5dd5:	eb 12                	jmp    5de9 <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    5dd7:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5dde:	74 48                	je     5e28 <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5de0:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5de7:	eb 40                	jmp    5e29 <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    5de9:	8b 45 0c             	mov    0xc(%ebp),%eax
    5dec:	8b 50 0c             	mov    0xc(%eax),%edx
    5def:	8b 45 0c             	mov    0xc(%ebp),%eax
    5df2:	8b 40 08             	mov    0x8(%eax),%eax
    5df5:	39 c2                	cmp    %eax,%edx
    5df7:	7e 09                	jle    5e02 <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    5df9:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    5e00:	eb 27                	jmp    5e29 <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    5e02:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    5e06:	74 14                	je     5e1c <inflateHuffmanBlock+0x2e1>
    5e08:	8b 45 08             	mov    0x8(%ebp),%eax
    5e0b:	8b 40 04             	mov    0x4(%eax),%eax
    5e0e:	3b 45 14             	cmp    0x14(%ebp),%eax
    5e11:	7e 09                	jle    5e1c <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    5e13:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    5e1a:	eb 0d                	jmp    5e29 <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5e1c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5e20:	0f 84 7a fd ff ff    	je     5ba0 <inflateHuffmanBlock+0x65>
    5e26:	eb 01                	jmp    5e29 <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    5e28:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    5e29:	83 ec 0c             	sub    $0xc,%esp
    5e2c:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5e2f:	50                   	push   %eax
    5e30:	e8 ac e4 ff ff       	call   42e1 <HuffmanTree_cleanup>
    5e35:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    5e38:	83 ec 0c             	sub    $0xc,%esp
    5e3b:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5e3e:	50                   	push   %eax
    5e3f:	e8 9d e4 ff ff       	call   42e1 <HuffmanTree_cleanup>
    5e44:	83 c4 10             	add    $0x10,%esp

  return error;
    5e47:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5e4a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5e4d:	c9                   	leave  
    5e4e:	c3                   	ret    

00005e4f <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    5e4f:	55                   	push   %ebp
    5e50:	89 e5                	mov    %esp,%ebp
    5e52:	53                   	push   %ebx
    5e53:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    5e56:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e59:	8b 40 04             	mov    0x4(%eax),%eax
    5e5c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    5e5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    5e66:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e69:	8b 40 0c             	mov    0xc(%eax),%eax
    5e6c:	83 c0 07             	add    $0x7,%eax
    5e6f:	c1 e8 03             	shr    $0x3,%eax
    5e72:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    5e75:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e78:	83 c0 04             	add    $0x4,%eax
    5e7b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5e7e:	7c 0a                	jl     5e8a <inflateNoCompression+0x3b>
    5e80:	b8 34 00 00 00       	mov    $0x34,%eax
    5e85:	e9 01 01 00 00       	jmp    5f8b <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5e8a:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e8d:	8b 10                	mov    (%eax),%edx
    5e8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e92:	01 d0                	add    %edx,%eax
    5e94:	0f b6 00             	movzbl (%eax),%eax
    5e97:	0f b6 d0             	movzbl %al,%edx
    5e9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e9d:	8b 00                	mov    (%eax),%eax
    5e9f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5ea2:	83 c1 01             	add    $0x1,%ecx
    5ea5:	01 c8                	add    %ecx,%eax
    5ea7:	0f b6 00             	movzbl (%eax),%eax
    5eaa:	0f b6 c0             	movzbl %al,%eax
    5ead:	c1 e0 08             	shl    $0x8,%eax
    5eb0:	01 d0                	add    %edx,%eax
    5eb2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5eb5:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5eb9:	8b 45 0c             	mov    0xc(%ebp),%eax
    5ebc:	8b 10                	mov    (%eax),%edx
    5ebe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5ec1:	01 d0                	add    %edx,%eax
    5ec3:	0f b6 00             	movzbl (%eax),%eax
    5ec6:	0f b6 d0             	movzbl %al,%edx
    5ec9:	8b 45 0c             	mov    0xc(%ebp),%eax
    5ecc:	8b 00                	mov    (%eax),%eax
    5ece:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5ed1:	83 c1 01             	add    $0x1,%ecx
    5ed4:	01 c8                	add    %ecx,%eax
    5ed6:	0f b6 00             	movzbl (%eax),%eax
    5ed9:	0f b6 c0             	movzbl %al,%eax
    5edc:	c1 e0 08             	shl    $0x8,%eax
    5edf:	01 d0                	add    %edx,%eax
    5ee1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5ee4:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    5ee8:	8b 45 10             	mov    0x10(%ebp),%eax
    5eeb:	8b 40 04             	mov    0x4(%eax),%eax
    5eee:	85 c0                	test   %eax,%eax
    5ef0:	75 19                	jne    5f0b <inflateNoCompression+0xbc>
    5ef2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5ef5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5ef8:	01 d0                	add    %edx,%eax
    5efa:	3d ff ff 00 00       	cmp    $0xffff,%eax
    5eff:	74 0a                	je     5f0b <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    5f01:	b8 15 00 00 00       	mov    $0x15,%eax
    5f06:	e9 80 00 00 00       	jmp    5f8b <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    5f0b:	8b 45 08             	mov    0x8(%ebp),%eax
    5f0e:	8b 40 04             	mov    0x4(%eax),%eax
    5f11:	89 c2                	mov    %eax,%edx
    5f13:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f16:	01 d0                	add    %edx,%eax
    5f18:	50                   	push   %eax
    5f19:	ff 75 08             	pushl  0x8(%ebp)
    5f1c:	e8 f9 d6 ff ff       	call   361a <ucvector_resize>
    5f21:	83 c4 08             	add    $0x8,%esp
    5f24:	85 c0                	test   %eax,%eax
    5f26:	75 07                	jne    5f2f <inflateNoCompression+0xe0>
    5f28:	b8 53 00 00 00       	mov    $0x53,%eax
    5f2d:	eb 5c                	jmp    5f8b <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    5f2f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5f32:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f35:	01 c2                	add    %eax,%edx
    5f37:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5f3a:	39 c2                	cmp    %eax,%edx
    5f3c:	76 07                	jbe    5f45 <inflateNoCompression+0xf6>
    5f3e:	b8 17 00 00 00       	mov    $0x17,%eax
    5f43:	eb 46                	jmp    5f8b <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    5f45:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f48:	8b 55 0c             	mov    0xc(%ebp),%edx
    5f4b:	8b 0a                	mov    (%edx),%ecx
    5f4d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5f50:	01 d1                	add    %edx,%ecx
    5f52:	8b 55 08             	mov    0x8(%ebp),%edx
    5f55:	8b 1a                	mov    (%edx),%ebx
    5f57:	8b 55 08             	mov    0x8(%ebp),%edx
    5f5a:	8b 52 04             	mov    0x4(%edx),%edx
    5f5d:	2b 55 ec             	sub    -0x14(%ebp),%edx
    5f60:	01 da                	add    %ebx,%edx
    5f62:	50                   	push   %eax
    5f63:	51                   	push   %ecx
    5f64:	52                   	push   %edx
    5f65:	e8 94 d4 ff ff       	call   33fe <lodepng_memcpy>
    5f6a:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    5f6d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5f70:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f73:	01 d0                	add    %edx,%eax
    5f75:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    5f78:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f7b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    5f82:	8b 45 0c             	mov    0xc(%ebp),%eax
    5f85:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    5f88:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5f8b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5f8e:	c9                   	leave  
    5f8f:	c3                   	ret    

00005f90 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    5f90:	55                   	push   %ebp
    5f91:	89 e5                	mov    %esp,%ebp
    5f93:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    5f96:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    5f9d:	ff 75 10             	pushl  0x10(%ebp)
    5fa0:	ff 75 0c             	pushl  0xc(%ebp)
    5fa3:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5fa6:	50                   	push   %eax
    5fa7:	e8 77 db ff ff       	call   3b23 <LodePNGBitReader_init>
    5fac:	83 c4 0c             	add    $0xc,%esp
    5faf:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    5fb2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5fb6:	0f 84 b9 00 00 00    	je     6075 <lodepng_inflatev+0xe5>
    5fbc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5fbf:	e9 c1 00 00 00       	jmp    6085 <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    5fc4:	6a 03                	push   $0x3
    5fc6:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5fc9:	50                   	push   %eax
    5fca:	e8 c5 db ff ff       	call   3b94 <ensureBits9>
    5fcf:	83 c4 08             	add    $0x8,%esp
    5fd2:	85 c0                	test   %eax,%eax
    5fd4:	75 0a                	jne    5fe0 <lodepng_inflatev+0x50>
    5fd6:	b8 34 00 00 00       	mov    $0x34,%eax
    5fdb:	e9 a5 00 00 00       	jmp    6085 <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    5fe0:	6a 01                	push   $0x1
    5fe2:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5fe5:	50                   	push   %eax
    5fe6:	e8 61 e1 ff ff       	call   414c <readBits>
    5feb:	83 c4 08             	add    $0x8,%esp
    5fee:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    5ff1:	6a 02                	push   $0x2
    5ff3:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5ff6:	50                   	push   %eax
    5ff7:	e8 50 e1 ff ff       	call   414c <readBits>
    5ffc:	83 c4 08             	add    $0x8,%esp
    5fff:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    6002:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    6006:	75 07                	jne    600f <lodepng_inflatev+0x7f>
    6008:	b8 14 00 00 00       	mov    $0x14,%eax
    600d:	eb 76                	jmp    6085 <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    600f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    6013:	75 17                	jne    602c <lodepng_inflatev+0x9c>
    6015:	ff 75 14             	pushl  0x14(%ebp)
    6018:	8d 45 d8             	lea    -0x28(%ebp),%eax
    601b:	50                   	push   %eax
    601c:	ff 75 08             	pushl  0x8(%ebp)
    601f:	e8 2b fe ff ff       	call   5e4f <inflateNoCompression>
    6024:	83 c4 0c             	add    $0xc,%esp
    6027:	89 45 f0             	mov    %eax,-0x10(%ebp)
    602a:	eb 1c                	jmp    6048 <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    602c:	8b 45 14             	mov    0x14(%ebp),%eax
    602f:	8b 40 08             	mov    0x8(%eax),%eax
    6032:	50                   	push   %eax
    6033:	ff 75 ec             	pushl  -0x14(%ebp)
    6036:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6039:	50                   	push   %eax
    603a:	ff 75 08             	pushl  0x8(%ebp)
    603d:	e8 f9 fa ff ff       	call   5b3b <inflateHuffmanBlock>
    6042:	83 c4 10             	add    $0x10,%esp
    6045:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6048:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    604c:	75 21                	jne    606f <lodepng_inflatev+0xdf>
    604e:	8b 45 14             	mov    0x14(%ebp),%eax
    6051:	8b 40 08             	mov    0x8(%eax),%eax
    6054:	85 c0                	test   %eax,%eax
    6056:	74 17                	je     606f <lodepng_inflatev+0xdf>
    6058:	8b 45 08             	mov    0x8(%ebp),%eax
    605b:	8b 50 04             	mov    0x4(%eax),%edx
    605e:	8b 45 14             	mov    0x14(%ebp),%eax
    6061:	8b 40 08             	mov    0x8(%eax),%eax
    6064:	39 c2                	cmp    %eax,%edx
    6066:	7e 07                	jle    606f <lodepng_inflatev+0xdf>
    6068:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    606f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6073:	75 0c                	jne    6081 <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    6075:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6079:	0f 84 45 ff ff ff    	je     5fc4 <lodepng_inflatev+0x34>
    607f:	eb 01                	jmp    6082 <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    6081:	90                   	nop
  }

  return error;
    6082:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    6085:	c9                   	leave  
    6086:	c3                   	ret    

00006087 <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    6087:	55                   	push   %ebp
    6088:	89 e5                	mov    %esp,%ebp
    608a:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    608d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6090:	8b 08                	mov    (%eax),%ecx
    6092:	8b 45 08             	mov    0x8(%ebp),%eax
    6095:	8b 10                	mov    (%eax),%edx
    6097:	8d 45 e8             	lea    -0x18(%ebp),%eax
    609a:	51                   	push   %ecx
    609b:	52                   	push   %edx
    609c:	50                   	push   %eax
    609d:	e8 df d5 ff ff       	call   3681 <ucvector_init>
    60a2:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    60a5:	ff 75 18             	pushl  0x18(%ebp)
    60a8:	ff 75 14             	pushl  0x14(%ebp)
    60ab:	ff 75 10             	pushl  0x10(%ebp)
    60ae:	8d 45 e8             	lea    -0x18(%ebp),%eax
    60b1:	50                   	push   %eax
    60b2:	e8 d9 fe ff ff       	call   5f90 <lodepng_inflatev>
    60b7:	83 c4 10             	add    $0x10,%esp
    60ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    60bd:	8b 55 e8             	mov    -0x18(%ebp),%edx
    60c0:	8b 45 08             	mov    0x8(%ebp),%eax
    60c3:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    60c5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    60c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    60cb:	89 10                	mov    %edx,(%eax)
  return error;
    60cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    60d0:	c9                   	leave  
    60d1:	c3                   	ret    

000060d2 <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    60d2:	55                   	push   %ebp
    60d3:	89 e5                	mov    %esp,%ebp
    60d5:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    60d8:	8b 45 14             	mov    0x14(%ebp),%eax
    60db:	8b 40 10             	mov    0x10(%eax),%eax
    60de:	85 c0                	test   %eax,%eax
    60e0:	74 64                	je     6146 <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    60e2:	8b 45 14             	mov    0x14(%ebp),%eax
    60e5:	8b 40 10             	mov    0x10(%eax),%eax
    60e8:	8b 55 08             	mov    0x8(%ebp),%edx
    60eb:	8d 4a 04             	lea    0x4(%edx),%ecx
    60ee:	8b 55 08             	mov    0x8(%ebp),%edx
    60f1:	83 ec 0c             	sub    $0xc,%esp
    60f4:	ff 75 14             	pushl  0x14(%ebp)
    60f7:	ff 75 10             	pushl  0x10(%ebp)
    60fa:	ff 75 0c             	pushl  0xc(%ebp)
    60fd:	51                   	push   %ecx
    60fe:	52                   	push   %edx
    60ff:	ff d0                	call   *%eax
    6101:	83 c4 20             	add    $0x20,%esp
    6104:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    6107:	8b 45 08             	mov    0x8(%ebp),%eax
    610a:	8b 50 04             	mov    0x4(%eax),%edx
    610d:	8b 45 08             	mov    0x8(%ebp),%eax
    6110:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    6113:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6117:	74 28                	je     6141 <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    6119:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6120:	8b 45 14             	mov    0x14(%ebp),%eax
    6123:	8b 40 08             	mov    0x8(%eax),%eax
    6126:	85 c0                	test   %eax,%eax
    6128:	74 17                	je     6141 <inflatev+0x6f>
    612a:	8b 45 08             	mov    0x8(%ebp),%eax
    612d:	8b 50 04             	mov    0x4(%eax),%edx
    6130:	8b 45 14             	mov    0x14(%ebp),%eax
    6133:	8b 40 08             	mov    0x8(%eax),%eax
    6136:	39 c2                	cmp    %eax,%edx
    6138:	7e 07                	jle    6141 <inflatev+0x6f>
    613a:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    6141:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6144:	eb 14                	jmp    615a <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    6146:	ff 75 14             	pushl  0x14(%ebp)
    6149:	ff 75 10             	pushl  0x10(%ebp)
    614c:	ff 75 0c             	pushl  0xc(%ebp)
    614f:	ff 75 08             	pushl  0x8(%ebp)
    6152:	e8 39 fe ff ff       	call   5f90 <lodepng_inflatev>
    6157:	83 c4 10             	add    $0x10,%esp
  }
}
    615a:	c9                   	leave  
    615b:	c3                   	ret    

0000615c <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    615c:	55                   	push   %ebp
    615d:	89 e5                	mov    %esp,%ebp
    615f:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    6162:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    6169:	8b 45 0c             	mov    0xc(%ebp),%eax
    616c:	83 e8 01             	sub    $0x1,%eax
    616f:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    6172:	eb 39                	jmp    61ad <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    6174:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6177:	8b 45 f8             	mov    -0x8(%ebp),%eax
    617a:	01 d0                	add    %edx,%eax
    617c:	d1 f8                	sar    %eax
    617e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    6181:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6184:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    618b:	8b 45 08             	mov    0x8(%ebp),%eax
    618e:	01 d0                	add    %edx,%eax
    6190:	8b 10                	mov    (%eax),%edx
    6192:	8b 45 10             	mov    0x10(%ebp),%eax
    6195:	39 c2                	cmp    %eax,%edx
    6197:	72 0b                	jb     61a4 <searchCodeIndex+0x48>
    6199:	8b 45 f4             	mov    -0xc(%ebp),%eax
    619c:	83 e8 01             	sub    $0x1,%eax
    619f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    61a2:	eb 09                	jmp    61ad <searchCodeIndex+0x51>
    else left = mid + 1;
    61a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    61a7:	83 c0 01             	add    $0x1,%eax
    61aa:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    61ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
    61b0:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    61b3:	7e bf                	jle    6174 <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    61b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    61b8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    61bb:	7d 18                	jge    61d5 <searchCodeIndex+0x79>
    61bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    61c0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    61c7:	8b 45 08             	mov    0x8(%ebp),%eax
    61ca:	01 d0                	add    %edx,%eax
    61cc:	8b 10                	mov    (%eax),%edx
    61ce:	8b 45 10             	mov    0x10(%ebp),%eax
    61d1:	39 c2                	cmp    %eax,%edx
    61d3:	76 04                	jbe    61d9 <searchCodeIndex+0x7d>
    61d5:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    61d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    61dc:	c9                   	leave  
    61dd:	c3                   	ret    

000061de <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    61de:	55                   	push   %ebp
    61df:	89 e5                	mov    %esp,%ebp
    61e1:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    61e4:	ff 75 0c             	pushl  0xc(%ebp)
    61e7:	6a 1d                	push   $0x1d
    61e9:	68 e0 9d 01 00       	push   $0x19de0
    61ee:	e8 69 ff ff ff       	call   615c <searchCodeIndex>
    61f3:	83 c4 0c             	add    $0xc,%esp
    61f6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    61f9:	8b 55 0c             	mov    0xc(%ebp),%edx
    61fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    61ff:	8b 04 85 e0 9d 01 00 	mov    0x19de0(,%eax,4),%eax
    6206:	29 c2                	sub    %eax,%edx
    6208:	89 d0                	mov    %edx,%eax
    620a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    620d:	ff 75 10             	pushl  0x10(%ebp)
    6210:	6a 1e                	push   $0x1e
    6212:	68 e0 9e 01 00       	push   $0x19ee0
    6217:	e8 40 ff ff ff       	call   615c <searchCodeIndex>
    621c:	83 c4 0c             	add    $0xc,%esp
    621f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    6222:	8b 55 10             	mov    0x10(%ebp),%edx
    6225:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6228:	8b 04 85 e0 9e 01 00 	mov    0x19ee0(,%eax,4),%eax
    622f:	29 c2                	sub    %eax,%edx
    6231:	89 d0                	mov    %edx,%eax
    6233:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    6236:	8b 45 08             	mov    0x8(%ebp),%eax
    6239:	8b 40 04             	mov    0x4(%eax),%eax
    623c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    623f:	8b 45 08             	mov    0x8(%ebp),%eax
    6242:	8b 40 04             	mov    0x4(%eax),%eax
    6245:	83 c0 04             	add    $0x4,%eax
    6248:	50                   	push   %eax
    6249:	ff 75 08             	pushl  0x8(%ebp)
    624c:	e8 f0 d2 ff ff       	call   3541 <uivector_resize>
    6251:	83 c4 08             	add    $0x8,%esp
    6254:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    6257:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    625b:	74 57                	je     62b4 <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    625d:	8b 45 08             	mov    0x8(%ebp),%eax
    6260:	8b 00                	mov    (%eax),%eax
    6262:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6265:	c1 e2 02             	shl    $0x2,%edx
    6268:	01 d0                	add    %edx,%eax
    626a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    626d:	81 c2 01 01 00 00    	add    $0x101,%edx
    6273:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    6275:	8b 45 08             	mov    0x8(%ebp),%eax
    6278:	8b 00                	mov    (%eax),%eax
    627a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    627d:	83 c2 01             	add    $0x1,%edx
    6280:	c1 e2 02             	shl    $0x2,%edx
    6283:	01 c2                	add    %eax,%edx
    6285:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6288:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    628a:	8b 45 08             	mov    0x8(%ebp),%eax
    628d:	8b 00                	mov    (%eax),%eax
    628f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6292:	83 c2 02             	add    $0x2,%edx
    6295:	c1 e2 02             	shl    $0x2,%edx
    6298:	01 c2                	add    %eax,%edx
    629a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    629d:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    629f:	8b 45 08             	mov    0x8(%ebp),%eax
    62a2:	8b 00                	mov    (%eax),%eax
    62a4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    62a7:	83 c2 03             	add    $0x3,%edx
    62aa:	c1 e2 02             	shl    $0x2,%edx
    62ad:	01 c2                	add    %eax,%edx
    62af:	8b 45 f0             	mov    -0x10(%ebp),%eax
    62b2:	89 02                	mov    %eax,(%edx)
  }
}
    62b4:	90                   	nop
    62b5:	c9                   	leave  
    62b6:	c3                   	ret    

000062b7 <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    62b7:	55                   	push   %ebp
    62b8:	89 e5                	mov    %esp,%ebp
    62ba:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    62bd:	b8 00 00 01 00       	mov    $0x10000,%eax
    62c2:	c1 e0 02             	shl    $0x2,%eax
    62c5:	83 ec 0c             	sub    $0xc,%esp
    62c8:	50                   	push   %eax
    62c9:	e8 f2 d0 ff ff       	call   33c0 <lodepng_malloc>
    62ce:	83 c4 10             	add    $0x10,%esp
    62d1:	89 c2                	mov    %eax,%edx
    62d3:	8b 45 08             	mov    0x8(%ebp),%eax
    62d6:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    62d8:	8b 45 0c             	mov    0xc(%ebp),%eax
    62db:	c1 e0 02             	shl    $0x2,%eax
    62de:	83 ec 0c             	sub    $0xc,%esp
    62e1:	50                   	push   %eax
    62e2:	e8 d9 d0 ff ff       	call   33c0 <lodepng_malloc>
    62e7:	83 c4 10             	add    $0x10,%esp
    62ea:	89 c2                	mov    %eax,%edx
    62ec:	8b 45 08             	mov    0x8(%ebp),%eax
    62ef:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    62f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    62f5:	01 c0                	add    %eax,%eax
    62f7:	83 ec 0c             	sub    $0xc,%esp
    62fa:	50                   	push   %eax
    62fb:	e8 c0 d0 ff ff       	call   33c0 <lodepng_malloc>
    6300:	83 c4 10             	add    $0x10,%esp
    6303:	89 c2                	mov    %eax,%edx
    6305:	8b 45 08             	mov    0x8(%ebp),%eax
    6308:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    630b:	8b 45 0c             	mov    0xc(%ebp),%eax
    630e:	01 c0                	add    %eax,%eax
    6310:	83 ec 0c             	sub    $0xc,%esp
    6313:	50                   	push   %eax
    6314:	e8 a7 d0 ff ff       	call   33c0 <lodepng_malloc>
    6319:	83 c4 10             	add    $0x10,%esp
    631c:	89 c2                	mov    %eax,%edx
    631e:	8b 45 08             	mov    0x8(%ebp),%eax
    6321:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    6324:	b8 02 01 00 00       	mov    $0x102,%eax
    6329:	83 c0 01             	add    $0x1,%eax
    632c:	c1 e0 02             	shl    $0x2,%eax
    632f:	83 ec 0c             	sub    $0xc,%esp
    6332:	50                   	push   %eax
    6333:	e8 88 d0 ff ff       	call   33c0 <lodepng_malloc>
    6338:	83 c4 10             	add    $0x10,%esp
    633b:	89 c2                	mov    %eax,%edx
    633d:	8b 45 08             	mov    0x8(%ebp),%eax
    6340:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6343:	8b 45 0c             	mov    0xc(%ebp),%eax
    6346:	01 c0                	add    %eax,%eax
    6348:	83 ec 0c             	sub    $0xc,%esp
    634b:	50                   	push   %eax
    634c:	e8 6f d0 ff ff       	call   33c0 <lodepng_malloc>
    6351:	83 c4 10             	add    $0x10,%esp
    6354:	89 c2                	mov    %eax,%edx
    6356:	8b 45 08             	mov    0x8(%ebp),%eax
    6359:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    635c:	8b 45 08             	mov    0x8(%ebp),%eax
    635f:	8b 00                	mov    (%eax),%eax
    6361:	85 c0                	test   %eax,%eax
    6363:	74 32                	je     6397 <hash_init+0xe0>
    6365:	8b 45 08             	mov    0x8(%ebp),%eax
    6368:	8b 40 04             	mov    0x4(%eax),%eax
    636b:	85 c0                	test   %eax,%eax
    636d:	74 28                	je     6397 <hash_init+0xe0>
    636f:	8b 45 08             	mov    0x8(%ebp),%eax
    6372:	8b 40 08             	mov    0x8(%eax),%eax
    6375:	85 c0                	test   %eax,%eax
    6377:	74 1e                	je     6397 <hash_init+0xe0>
    6379:	8b 45 08             	mov    0x8(%ebp),%eax
    637c:	8b 40 0c             	mov    0xc(%eax),%eax
    637f:	85 c0                	test   %eax,%eax
    6381:	74 14                	je     6397 <hash_init+0xe0>
    6383:	8b 45 08             	mov    0x8(%ebp),%eax
    6386:	8b 40 10             	mov    0x10(%eax),%eax
    6389:	85 c0                	test   %eax,%eax
    638b:	74 0a                	je     6397 <hash_init+0xe0>
    638d:	8b 45 08             	mov    0x8(%ebp),%eax
    6390:	8b 40 14             	mov    0x14(%eax),%eax
    6393:	85 c0                	test   %eax,%eax
    6395:	75 0a                	jne    63a1 <hash_init+0xea>
    return 83; /*alloc fail*/
    6397:	b8 53 00 00 00       	mov    $0x53,%eax
    639c:	e9 d3 00 00 00       	jmp    6474 <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    63a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    63a8:	eb 17                	jmp    63c1 <hash_init+0x10a>
    63aa:	8b 45 08             	mov    0x8(%ebp),%eax
    63ad:	8b 00                	mov    (%eax),%eax
    63af:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63b2:	c1 e2 02             	shl    $0x2,%edx
    63b5:	01 d0                	add    %edx,%eax
    63b7:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    63bd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    63c1:	b8 00 00 01 00       	mov    $0x10000,%eax
    63c6:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    63c9:	75 df                	jne    63aa <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    63cb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    63d2:	eb 18                	jmp    63ec <hash_init+0x135>
    63d4:	8b 45 08             	mov    0x8(%ebp),%eax
    63d7:	8b 40 08             	mov    0x8(%eax),%eax
    63da:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63dd:	c1 e2 02             	shl    $0x2,%edx
    63e0:	01 d0                	add    %edx,%eax
    63e2:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    63e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    63ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63ef:	3b 45 0c             	cmp    0xc(%ebp),%eax
    63f2:	75 e0                	jne    63d4 <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    63f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    63fb:	eb 17                	jmp    6414 <hash_init+0x15d>
    63fd:	8b 45 08             	mov    0x8(%ebp),%eax
    6400:	8b 40 04             	mov    0x4(%eax),%eax
    6403:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6406:	01 d2                	add    %edx,%edx
    6408:	01 d0                	add    %edx,%eax
    640a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    640d:	66 89 10             	mov    %dx,(%eax)
    6410:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6414:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6417:	3b 45 0c             	cmp    0xc(%ebp),%eax
    641a:	75 e1                	jne    63fd <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    641c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6423:	eb 18                	jmp    643d <hash_init+0x186>
    6425:	8b 45 08             	mov    0x8(%ebp),%eax
    6428:	8b 40 0c             	mov    0xc(%eax),%eax
    642b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    642e:	c1 e2 02             	shl    $0x2,%edx
    6431:	01 d0                	add    %edx,%eax
    6433:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6439:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    643d:	b8 02 01 00 00       	mov    $0x102,%eax
    6442:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    6445:	76 de                	jbe    6425 <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    6447:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    644e:	eb 17                	jmp    6467 <hash_init+0x1b0>
    6450:	8b 45 08             	mov    0x8(%ebp),%eax
    6453:	8b 40 10             	mov    0x10(%eax),%eax
    6456:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6459:	01 d2                	add    %edx,%edx
    645b:	01 d0                	add    %edx,%eax
    645d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6460:	66 89 10             	mov    %dx,(%eax)
    6463:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6467:	8b 45 f4             	mov    -0xc(%ebp),%eax
    646a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    646d:	75 e1                	jne    6450 <hash_init+0x199>

  return 0;
    646f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6474:	c9                   	leave  
    6475:	c3                   	ret    

00006476 <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    6476:	55                   	push   %ebp
    6477:	89 e5                	mov    %esp,%ebp
    6479:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    647c:	8b 45 08             	mov    0x8(%ebp),%eax
    647f:	8b 00                	mov    (%eax),%eax
    6481:	83 ec 0c             	sub    $0xc,%esp
    6484:	50                   	push   %eax
    6485:	e8 57 cf ff ff       	call   33e1 <lodepng_free>
    648a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    648d:	8b 45 08             	mov    0x8(%ebp),%eax
    6490:	8b 40 08             	mov    0x8(%eax),%eax
    6493:	83 ec 0c             	sub    $0xc,%esp
    6496:	50                   	push   %eax
    6497:	e8 45 cf ff ff       	call   33e1 <lodepng_free>
    649c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    649f:	8b 45 08             	mov    0x8(%ebp),%eax
    64a2:	8b 40 04             	mov    0x4(%eax),%eax
    64a5:	83 ec 0c             	sub    $0xc,%esp
    64a8:	50                   	push   %eax
    64a9:	e8 33 cf ff ff       	call   33e1 <lodepng_free>
    64ae:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    64b1:	8b 45 08             	mov    0x8(%ebp),%eax
    64b4:	8b 40 14             	mov    0x14(%eax),%eax
    64b7:	83 ec 0c             	sub    $0xc,%esp
    64ba:	50                   	push   %eax
    64bb:	e8 21 cf ff ff       	call   33e1 <lodepng_free>
    64c0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    64c3:	8b 45 08             	mov    0x8(%ebp),%eax
    64c6:	8b 40 0c             	mov    0xc(%eax),%eax
    64c9:	83 ec 0c             	sub    $0xc,%esp
    64cc:	50                   	push   %eax
    64cd:	e8 0f cf ff ff       	call   33e1 <lodepng_free>
    64d2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    64d5:	8b 45 08             	mov    0x8(%ebp),%eax
    64d8:	8b 40 10             	mov    0x10(%eax),%eax
    64db:	83 ec 0c             	sub    $0xc,%esp
    64de:	50                   	push   %eax
    64df:	e8 fd ce ff ff       	call   33e1 <lodepng_free>
    64e4:	83 c4 10             	add    $0x10,%esp
}
    64e7:	90                   	nop
    64e8:	c9                   	leave  
    64e9:	c3                   	ret    

000064ea <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    64ea:	55                   	push   %ebp
    64eb:	89 e5                	mov    %esp,%ebp
    64ed:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    64f0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    64f7:	8b 45 10             	mov    0x10(%ebp),%eax
    64fa:	83 c0 02             	add    $0x2,%eax
    64fd:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6500:	7d 41                	jge    6543 <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    6502:	8b 55 10             	mov    0x10(%ebp),%edx
    6505:	8b 45 08             	mov    0x8(%ebp),%eax
    6508:	01 d0                	add    %edx,%eax
    650a:	0f b6 00             	movzbl (%eax),%eax
    650d:	0f b6 c0             	movzbl %al,%eax
    6510:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    6513:	8b 45 10             	mov    0x10(%ebp),%eax
    6516:	8d 50 01             	lea    0x1(%eax),%edx
    6519:	8b 45 08             	mov    0x8(%ebp),%eax
    651c:	01 d0                	add    %edx,%eax
    651e:	0f b6 00             	movzbl (%eax),%eax
    6521:	0f b6 c0             	movzbl %al,%eax
    6524:	c1 e0 04             	shl    $0x4,%eax
    6527:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    652a:	8b 45 10             	mov    0x10(%ebp),%eax
    652d:	8d 50 02             	lea    0x2(%eax),%edx
    6530:	8b 45 08             	mov    0x8(%ebp),%eax
    6533:	01 d0                	add    %edx,%eax
    6535:	0f b6 00             	movzbl (%eax),%eax
    6538:	0f b6 c0             	movzbl %al,%eax
    653b:	c1 e0 08             	shl    $0x8,%eax
    653e:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6541:	eb 51                	jmp    6594 <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    6543:	8b 45 10             	mov    0x10(%ebp),%eax
    6546:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6549:	7c 07                	jl     6552 <getHash+0x68>
    654b:	b8 00 00 00 00       	mov    $0x0,%eax
    6550:	eb 4a                	jmp    659c <getHash+0xb2>
    amount = size - pos;
    6552:	8b 45 0c             	mov    0xc(%ebp),%eax
    6555:	2b 45 10             	sub    0x10(%ebp),%eax
    6558:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    655b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6562:	eb 28                	jmp    658c <getHash+0xa2>
    6564:	8b 55 10             	mov    0x10(%ebp),%edx
    6567:	8b 45 f8             	mov    -0x8(%ebp),%eax
    656a:	01 d0                	add    %edx,%eax
    656c:	89 c2                	mov    %eax,%edx
    656e:	8b 45 08             	mov    0x8(%ebp),%eax
    6571:	01 d0                	add    %edx,%eax
    6573:	0f b6 00             	movzbl (%eax),%eax
    6576:	0f b6 d0             	movzbl %al,%edx
    6579:	8b 45 f8             	mov    -0x8(%ebp),%eax
    657c:	c1 e0 03             	shl    $0x3,%eax
    657f:	89 c1                	mov    %eax,%ecx
    6581:	d3 e2                	shl    %cl,%edx
    6583:	89 d0                	mov    %edx,%eax
    6585:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6588:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    658c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    658f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    6592:	75 d0                	jne    6564 <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    6594:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6599:	23 45 fc             	and    -0x4(%ebp),%eax
}
    659c:	c9                   	leave  
    659d:	c3                   	ret    

0000659e <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    659e:	55                   	push   %ebp
    659f:	89 e5                	mov    %esp,%ebp
    65a1:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    65a4:	8b 55 10             	mov    0x10(%ebp),%edx
    65a7:	8b 45 08             	mov    0x8(%ebp),%eax
    65aa:	01 d0                	add    %edx,%eax
    65ac:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    65af:	b8 02 01 00 00       	mov    $0x102,%eax
    65b4:	89 c2                	mov    %eax,%edx
    65b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    65b9:	01 d0                	add    %edx,%eax
    65bb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    65be:	8b 55 0c             	mov    0xc(%ebp),%edx
    65c1:	8b 45 08             	mov    0x8(%ebp),%eax
    65c4:	01 d0                	add    %edx,%eax
    65c6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    65c9:	73 0b                	jae    65d6 <countZeros+0x38>
    65cb:	8b 55 0c             	mov    0xc(%ebp),%edx
    65ce:	8b 45 08             	mov    0x8(%ebp),%eax
    65d1:	01 d0                	add    %edx,%eax
    65d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    65d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    65d9:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    65dc:	eb 04                	jmp    65e2 <countZeros+0x44>
    65de:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    65e2:	8b 45 08             	mov    0x8(%ebp),%eax
    65e5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    65e8:	74 0a                	je     65f4 <countZeros+0x56>
    65ea:	8b 45 08             	mov    0x8(%ebp),%eax
    65ed:	0f b6 00             	movzbl (%eax),%eax
    65f0:	84 c0                	test   %al,%al
    65f2:	74 ea                	je     65de <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    65f4:	8b 55 08             	mov    0x8(%ebp),%edx
    65f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    65fa:	29 c2                	sub    %eax,%edx
    65fc:	89 d0                	mov    %edx,%eax
}
    65fe:	c9                   	leave  
    65ff:	c3                   	ret    

00006600 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    6600:	55                   	push   %ebp
    6601:	89 e5                	mov    %esp,%ebp
    6603:	83 ec 04             	sub    $0x4,%esp
    6606:	8b 45 14             	mov    0x14(%ebp),%eax
    6609:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    660d:	8b 45 08             	mov    0x8(%ebp),%eax
    6610:	8b 40 08             	mov    0x8(%eax),%eax
    6613:	8b 55 0c             	mov    0xc(%ebp),%edx
    6616:	c1 e2 02             	shl    $0x2,%edx
    6619:	01 c2                	add    %eax,%edx
    661b:	8b 45 10             	mov    0x10(%ebp),%eax
    661e:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    6620:	8b 45 08             	mov    0x8(%ebp),%eax
    6623:	8b 00                	mov    (%eax),%eax
    6625:	8b 55 10             	mov    0x10(%ebp),%edx
    6628:	c1 e2 02             	shl    $0x2,%edx
    662b:	01 d0                	add    %edx,%eax
    662d:	8b 00                	mov    (%eax),%eax
    662f:	83 f8 ff             	cmp    $0xffffffff,%eax
    6632:	74 1f                	je     6653 <updateHashChain+0x53>
    6634:	8b 45 08             	mov    0x8(%ebp),%eax
    6637:	8b 40 04             	mov    0x4(%eax),%eax
    663a:	8b 55 0c             	mov    0xc(%ebp),%edx
    663d:	01 d2                	add    %edx,%edx
    663f:	01 c2                	add    %eax,%edx
    6641:	8b 45 08             	mov    0x8(%ebp),%eax
    6644:	8b 00                	mov    (%eax),%eax
    6646:	8b 4d 10             	mov    0x10(%ebp),%ecx
    6649:	c1 e1 02             	shl    $0x2,%ecx
    664c:	01 c8                	add    %ecx,%eax
    664e:	8b 00                	mov    (%eax),%eax
    6650:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    6653:	8b 45 08             	mov    0x8(%ebp),%eax
    6656:	8b 00                	mov    (%eax),%eax
    6658:	8b 55 10             	mov    0x10(%ebp),%edx
    665b:	c1 e2 02             	shl    $0x2,%edx
    665e:	01 c2                	add    %eax,%edx
    6660:	8b 45 0c             	mov    0xc(%ebp),%eax
    6663:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    6665:	8b 45 08             	mov    0x8(%ebp),%eax
    6668:	8b 40 14             	mov    0x14(%eax),%eax
    666b:	8b 55 0c             	mov    0xc(%ebp),%edx
    666e:	01 d2                	add    %edx,%edx
    6670:	01 c2                	add    %eax,%edx
    6672:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    6676:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    6679:	8b 45 08             	mov    0x8(%ebp),%eax
    667c:	8b 40 0c             	mov    0xc(%eax),%eax
    667f:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    6683:	c1 e2 02             	shl    $0x2,%edx
    6686:	01 d0                	add    %edx,%eax
    6688:	8b 00                	mov    (%eax),%eax
    668a:	83 f8 ff             	cmp    $0xffffffff,%eax
    668d:	74 21                	je     66b0 <updateHashChain+0xb0>
    668f:	8b 45 08             	mov    0x8(%ebp),%eax
    6692:	8b 40 10             	mov    0x10(%eax),%eax
    6695:	8b 55 0c             	mov    0xc(%ebp),%edx
    6698:	01 d2                	add    %edx,%edx
    669a:	01 c2                	add    %eax,%edx
    669c:	8b 45 08             	mov    0x8(%ebp),%eax
    669f:	8b 40 0c             	mov    0xc(%eax),%eax
    66a2:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    66a6:	c1 e1 02             	shl    $0x2,%ecx
    66a9:	01 c8                	add    %ecx,%eax
    66ab:	8b 00                	mov    (%eax),%eax
    66ad:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    66b0:	8b 45 08             	mov    0x8(%ebp),%eax
    66b3:	8b 40 0c             	mov    0xc(%eax),%eax
    66b6:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    66ba:	c1 e2 02             	shl    $0x2,%edx
    66bd:	01 c2                	add    %eax,%edx
    66bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    66c2:	89 02                	mov    %eax,(%edx)
}
    66c4:	90                   	nop
    66c5:	c9                   	leave  
    66c6:	c3                   	ret    

000066c7 <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    66c7:	55                   	push   %ebp
    66c8:	89 e5                	mov    %esp,%ebp
    66ca:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    66cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    66d4:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    66db:	77 08                	ja     66e5 <encodeLZ77+0x1e>
    66dd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    66e0:	c1 e8 03             	shr    $0x3,%eax
    66e3:	eb 03                	jmp    66e8 <encodeLZ77+0x21>
    66e5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    66e8:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    66eb:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    66f2:	76 07                	jbe    66fb <encodeLZ77+0x34>
    66f4:	b8 02 01 00 00       	mov    $0x102,%eax
    66f9:	eb 05                	jmp    6700 <encodeLZ77+0x39>
    66fb:	b8 40 00 00 00       	mov    $0x40,%eax
    6700:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    6703:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    670a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    6711:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    6718:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    671f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    6726:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    672a:	74 09                	je     6735 <encodeLZ77+0x6e>
    672c:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    6733:	76 0a                	jbe    673f <encodeLZ77+0x78>
    6735:	b8 3c 00 00 00       	mov    $0x3c,%eax
    673a:	e9 e3 04 00 00       	jmp    6c22 <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    673f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6742:	83 e8 01             	sub    $0x1,%eax
    6745:	23 45 1c             	and    0x1c(%ebp),%eax
    6748:	85 c0                	test   %eax,%eax
    674a:	74 0a                	je     6756 <encodeLZ77+0x8f>
    674c:	b8 5a 00 00 00       	mov    $0x5a,%eax
    6751:	e9 cc 04 00 00       	jmp    6c22 <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    6756:	b8 02 01 00 00       	mov    $0x102,%eax
    675b:	39 45 24             	cmp    %eax,0x24(%ebp)
    675e:	76 08                	jbe    6768 <encodeLZ77+0xa1>
    6760:	b8 02 01 00 00       	mov    $0x102,%eax
    6765:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    6768:	8b 45 14             	mov    0x14(%ebp),%eax
    676b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    676e:	e9 a0 04 00 00       	jmp    6c13 <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    6773:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6776:	8d 50 ff             	lea    -0x1(%eax),%edx
    6779:	8b 45 fc             	mov    -0x4(%ebp),%eax
    677c:	21 d0                	and    %edx,%eax
    677e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    6781:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    6788:	ff 75 fc             	pushl  -0x4(%ebp)
    678b:	ff 75 18             	pushl  0x18(%ebp)
    678e:	ff 75 10             	pushl  0x10(%ebp)
    6791:	e8 54 fd ff ff       	call   64ea <getHash>
    6796:	83 c4 0c             	add    $0xc,%esp
    6799:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    679c:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    67a0:	74 4e                	je     67f0 <encodeLZ77+0x129>
    67a2:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    67a6:	75 48                	jne    67f0 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    67a8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    67ac:	75 16                	jne    67c4 <encodeLZ77+0xfd>
    67ae:	ff 75 fc             	pushl  -0x4(%ebp)
    67b1:	ff 75 18             	pushl  0x18(%ebp)
    67b4:	ff 75 10             	pushl  0x10(%ebp)
    67b7:	e8 e2 fd ff ff       	call   659e <countZeros>
    67bc:	83 c4 0c             	add    $0xc,%esp
    67bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    67c2:	eb 35                	jmp    67f9 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    67c4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    67c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    67ca:	01 c2                	add    %eax,%edx
    67cc:	8b 45 18             	mov    0x18(%ebp),%eax
    67cf:	39 c2                	cmp    %eax,%edx
    67d1:	77 17                	ja     67ea <encodeLZ77+0x123>
    67d3:	8b 55 fc             	mov    -0x4(%ebp),%edx
    67d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    67d9:	01 d0                	add    %edx,%eax
    67db:	8d 50 ff             	lea    -0x1(%eax),%edx
    67de:	8b 45 10             	mov    0x10(%ebp),%eax
    67e1:	01 d0                	add    %edx,%eax
    67e3:	0f b6 00             	movzbl (%eax),%eax
    67e6:	84 c0                	test   %al,%al
    67e8:	74 0f                	je     67f9 <encodeLZ77+0x132>
    67ea:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    67ee:	eb 09                	jmp    67f9 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    67f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    67f7:	eb 01                	jmp    67fa <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    67f9:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    67fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
    67fd:	0f b7 c0             	movzwl %ax,%eax
    6800:	50                   	push   %eax
    6801:	ff 75 b0             	pushl  -0x50(%ebp)
    6804:	ff 75 b4             	pushl  -0x4c(%ebp)
    6807:	ff 75 0c             	pushl  0xc(%ebp)
    680a:	e8 f1 fd ff ff       	call   6600 <updateHashChain>
    680f:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    6812:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    6819:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    6820:	8b 45 0c             	mov    0xc(%ebp),%eax
    6823:	8b 40 04             	mov    0x4(%eax),%eax
    6826:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    6829:	01 d2                	add    %edx,%edx
    682b:	01 d0                	add    %edx,%eax
    682d:	0f b7 00             	movzwl (%eax),%eax
    6830:	0f b7 c0             	movzwl %ax,%eax
    6833:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    6836:	ba 02 01 00 00       	mov    $0x102,%edx
    683b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    683e:	01 c2                	add    %eax,%edx
    6840:	8b 45 18             	mov    0x18(%ebp),%eax
    6843:	39 c2                	cmp    %eax,%edx
    6845:	0f 4e c2             	cmovle %edx,%eax
    6848:	89 c2                	mov    %eax,%edx
    684a:	8b 45 10             	mov    0x10(%ebp),%eax
    684d:	01 d0                	add    %edx,%eax
    684f:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    6852:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6859:	8b 45 c8             	mov    -0x38(%ebp),%eax
    685c:	8d 50 01             	lea    0x1(%eax),%edx
    685f:	89 55 c8             	mov    %edx,-0x38(%ebp)
    6862:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    6865:	0f 83 67 01 00 00    	jae    69d2 <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    686b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    686e:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    6871:	77 08                	ja     687b <encodeLZ77+0x1b4>
    6873:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6876:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6879:	eb 0d                	jmp    6888 <encodeLZ77+0x1c1>
    687b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    687e:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6881:	89 c2                	mov    %eax,%edx
    6883:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6886:	01 d0                	add    %edx,%eax
    6888:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    688b:	8b 45 a8             	mov    -0x58(%ebp),%eax
    688e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6891:	0f 82 3e 01 00 00    	jb     69d5 <encodeLZ77+0x30e>
      prev_offset = current_offset;
    6897:	8b 45 a8             	mov    -0x58(%ebp),%eax
    689a:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    689d:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    68a1:	0f 84 a3 00 00 00    	je     694a <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    68a7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    68aa:	8b 45 10             	mov    0x10(%ebp),%eax
    68ad:	01 d0                	add    %edx,%eax
    68af:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    68b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    68b5:	2b 45 a8             	sub    -0x58(%ebp),%eax
    68b8:	89 c2                	mov    %eax,%edx
    68ba:	8b 45 10             	mov    0x10(%ebp),%eax
    68bd:	01 d0                	add    %edx,%eax
    68bf:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    68c2:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    68c6:	76 3a                	jbe    6902 <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    68c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    68cb:	8b 40 14             	mov    0x14(%eax),%eax
    68ce:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68d1:	01 d2                	add    %edx,%edx
    68d3:	01 d0                	add    %edx,%eax
    68d5:	0f b7 00             	movzwl (%eax),%eax
    68d8:	0f b7 c0             	movzwl %ax,%eax
    68db:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    68de:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    68e1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    68e4:	76 06                	jbe    68ec <encodeLZ77+0x225>
    68e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    68e9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    68ec:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    68ef:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    68f2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    68f5:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    68f8:	eb 08                	jmp    6902 <encodeLZ77+0x23b>
          ++backptr;
    68fa:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    68fe:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6902:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6905:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    6908:	74 10                	je     691a <encodeLZ77+0x253>
    690a:	8b 45 d0             	mov    -0x30(%ebp),%eax
    690d:	0f b6 10             	movzbl (%eax),%edx
    6910:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6913:	0f b6 00             	movzbl (%eax),%eax
    6916:	38 c2                	cmp    %al,%dl
    6918:	74 e0                	je     68fa <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    691a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    691d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    6920:	8b 55 10             	mov    0x10(%ebp),%edx
    6923:	01 ca                	add    %ecx,%edx
    6925:	29 d0                	sub    %edx,%eax
    6927:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    692a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    692d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6930:	76 18                	jbe    694a <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    6932:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6935:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    6938:	8b 45 a8             	mov    -0x58(%ebp),%eax
    693b:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    693e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6941:	3b 45 24             	cmp    0x24(%ebp),%eax
    6944:	0f 83 8e 00 00 00    	jae    69d8 <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    694a:	8b 45 0c             	mov    0xc(%ebp),%eax
    694d:	8b 40 04             	mov    0x4(%eax),%eax
    6950:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6953:	01 d2                	add    %edx,%edx
    6955:	01 d0                	add    %edx,%eax
    6957:	0f b7 00             	movzwl (%eax),%eax
    695a:	0f b7 c0             	movzwl %ax,%eax
    695d:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    6960:	74 79                	je     69db <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    6962:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6966:	76 38                	jbe    69a0 <encodeLZ77+0x2d9>
    6968:	8b 45 e8             	mov    -0x18(%ebp),%eax
    696b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    696e:	76 30                	jbe    69a0 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    6970:	8b 45 0c             	mov    0xc(%ebp),%eax
    6973:	8b 40 10             	mov    0x10(%eax),%eax
    6976:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6979:	01 d2                	add    %edx,%edx
    697b:	01 d0                	add    %edx,%eax
    697d:	0f b7 00             	movzwl (%eax),%eax
    6980:	0f b7 c0             	movzwl %ax,%eax
    6983:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    6986:	8b 45 0c             	mov    0xc(%ebp),%eax
    6989:	8b 40 14             	mov    0x14(%eax),%eax
    698c:	8b 55 cc             	mov    -0x34(%ebp),%edx
    698f:	01 d2                	add    %edx,%edx
    6991:	01 d0                	add    %edx,%eax
    6993:	0f b7 00             	movzwl (%eax),%eax
    6996:	0f b7 c0             	movzwl %ax,%eax
    6999:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    699c:	74 2f                	je     69cd <encodeLZ77+0x306>
    699e:	eb 3f                	jmp    69df <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    69a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    69a3:	8b 40 04             	mov    0x4(%eax),%eax
    69a6:	8b 55 cc             	mov    -0x34(%ebp),%edx
    69a9:	01 d2                	add    %edx,%edx
    69ab:	01 d0                	add    %edx,%eax
    69ad:	0f b7 00             	movzwl (%eax),%eax
    69b0:	0f b7 c0             	movzwl %ax,%eax
    69b3:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    69b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    69b9:	8b 40 08             	mov    0x8(%eax),%eax
    69bc:	8b 55 cc             	mov    -0x34(%ebp),%edx
    69bf:	c1 e2 02             	shl    $0x2,%edx
    69c2:	01 d0                	add    %edx,%eax
    69c4:	8b 10                	mov    (%eax),%edx
    69c6:	8b 45 b0             	mov    -0x50(%ebp),%eax
    69c9:	39 c2                	cmp    %eax,%edx
    69cb:	75 11                	jne    69de <encodeLZ77+0x317>
      }
    }
    69cd:	e9 87 fe ff ff       	jmp    6859 <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    69d2:	90                   	nop
    69d3:	eb 0a                	jmp    69df <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    69d5:	90                   	nop
    69d6:	eb 07                	jmp    69df <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    69d8:	90                   	nop
    69d9:	eb 04                	jmp    69df <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    69db:	90                   	nop
    69dc:	eb 01                	jmp    69df <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    69de:	90                   	nop
      }
    }

    if(lazymatching) {
    69df:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    69e3:	0f 84 c8 00 00 00    	je     6ab1 <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    69e9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    69ed:	75 30                	jne    6a1f <encodeLZ77+0x358>
    69ef:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    69f3:	76 2a                	jbe    6a1f <encodeLZ77+0x358>
    69f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    69f8:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    69fb:	77 22                	ja     6a1f <encodeLZ77+0x358>
    69fd:	b8 02 01 00 00       	mov    $0x102,%eax
    6a02:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6a05:	73 18                	jae    6a1f <encodeLZ77+0x358>
        lazy = 1;
    6a07:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    6a0e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6a11:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    6a14:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a17:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    6a1a:	e9 f0 01 00 00       	jmp    6c0f <encodeLZ77+0x548>
      }
      if(lazy) {
    6a1f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6a23:	0f 84 88 00 00 00    	je     6ab1 <encodeLZ77+0x3ea>
        lazy = 0;
    6a29:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    6a30:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    6a34:	75 0c                	jne    6a42 <encodeLZ77+0x37b>
    6a36:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    6a3d:	e9 dd 01 00 00       	jmp    6c1f <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    6a42:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6a45:	83 c0 01             	add    $0x1,%eax
    6a48:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6a4b:	73 2d                	jae    6a7a <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    6a4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6a50:	8d 50 ff             	lea    -0x1(%eax),%edx
    6a53:	8b 45 10             	mov    0x10(%ebp),%eax
    6a56:	01 d0                	add    %edx,%eax
    6a58:	0f b6 00             	movzbl (%eax),%eax
    6a5b:	0f b6 c0             	movzbl %al,%eax
    6a5e:	50                   	push   %eax
    6a5f:	ff 75 08             	pushl  0x8(%ebp)
    6a62:	e8 6f cb ff ff       	call   35d6 <uivector_push_back>
    6a67:	83 c4 08             	add    $0x8,%esp
    6a6a:	85 c0                	test   %eax,%eax
    6a6c:	75 43                	jne    6ab1 <encodeLZ77+0x3ea>
    6a6e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6a75:	e9 a5 01 00 00       	jmp    6c1f <encodeLZ77+0x558>
        } else {
          length = lazylength;
    6a7a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6a7d:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    6a80:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6a83:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    6a86:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a89:	8b 00                	mov    (%eax),%eax
    6a8b:	8b 55 b0             	mov    -0x50(%ebp),%edx
    6a8e:	c1 e2 02             	shl    $0x2,%edx
    6a91:	01 d0                	add    %edx,%eax
    6a93:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    6a99:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a9c:	8b 40 0c             	mov    0xc(%eax),%eax
    6a9f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6aa2:	c1 e2 02             	shl    $0x2,%edx
    6aa5:	01 d0                	add    %edx,%eax
    6aa7:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    6aad:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    6ab1:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6ab5:	76 14                	jbe    6acb <encodeLZ77+0x404>
    6ab7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6aba:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    6abd:	76 0c                	jbe    6acb <encodeLZ77+0x404>
    6abf:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    6ac6:	e9 54 01 00 00       	jmp    6c1f <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    6acb:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6acf:	77 2e                	ja     6aff <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6ad1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6ad4:	8b 45 10             	mov    0x10(%ebp),%eax
    6ad7:	01 d0                	add    %edx,%eax
    6ad9:	0f b6 00             	movzbl (%eax),%eax
    6adc:	0f b6 c0             	movzbl %al,%eax
    6adf:	50                   	push   %eax
    6ae0:	ff 75 08             	pushl  0x8(%ebp)
    6ae3:	e8 ee ca ff ff       	call   35d6 <uivector_push_back>
    6ae8:	83 c4 08             	add    $0x8,%esp
    6aeb:	85 c0                	test   %eax,%eax
    6aed:	0f 85 1c 01 00 00    	jne    6c0f <encodeLZ77+0x548>
    6af3:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6afa:	e9 20 01 00 00       	jmp    6c1f <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    6aff:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6b02:	3b 45 20             	cmp    0x20(%ebp),%eax
    6b05:	72 0f                	jb     6b16 <encodeLZ77+0x44f>
    6b07:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    6b0b:	75 37                	jne    6b44 <encodeLZ77+0x47d>
    6b0d:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    6b14:	76 2e                	jbe    6b44 <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6b16:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6b19:	8b 45 10             	mov    0x10(%ebp),%eax
    6b1c:	01 d0                	add    %edx,%eax
    6b1e:	0f b6 00             	movzbl (%eax),%eax
    6b21:	0f b6 c0             	movzbl %al,%eax
    6b24:	50                   	push   %eax
    6b25:	ff 75 08             	pushl  0x8(%ebp)
    6b28:	e8 a9 ca ff ff       	call   35d6 <uivector_push_back>
    6b2d:	83 c4 08             	add    $0x8,%esp
    6b30:	85 c0                	test   %eax,%eax
    6b32:	0f 85 d7 00 00 00    	jne    6c0f <encodeLZ77+0x548>
    6b38:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6b3f:	e9 db 00 00 00       	jmp    6c1f <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    6b44:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6b47:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6b4a:	52                   	push   %edx
    6b4b:	50                   	push   %eax
    6b4c:	ff 75 08             	pushl  0x8(%ebp)
    6b4f:	e8 8a f6 ff ff       	call   61de <addLengthDistance>
    6b54:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    6b57:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    6b5e:	e9 a0 00 00 00       	jmp    6c03 <encodeLZ77+0x53c>
        ++pos;
    6b63:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    6b67:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6b6a:	8d 50 ff             	lea    -0x1(%eax),%edx
    6b6d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6b70:	21 d0                	and    %edx,%eax
    6b72:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    6b75:	ff 75 fc             	pushl  -0x4(%ebp)
    6b78:	ff 75 18             	pushl  0x18(%ebp)
    6b7b:	ff 75 10             	pushl  0x10(%ebp)
    6b7e:	e8 67 f9 ff ff       	call   64ea <getHash>
    6b83:	83 c4 0c             	add    $0xc,%esp
    6b86:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    6b89:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6b8d:	74 4e                	je     6bdd <encodeLZ77+0x516>
    6b8f:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6b93:	75 48                	jne    6bdd <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b95:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6b99:	75 16                	jne    6bb1 <encodeLZ77+0x4ea>
    6b9b:	ff 75 fc             	pushl  -0x4(%ebp)
    6b9e:	ff 75 18             	pushl  0x18(%ebp)
    6ba1:	ff 75 10             	pushl  0x10(%ebp)
    6ba4:	e8 f5 f9 ff ff       	call   659e <countZeros>
    6ba9:	83 c4 0c             	add    $0xc,%esp
    6bac:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6baf:	eb 35                	jmp    6be6 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6bb1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6bb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6bb7:	01 c2                	add    %eax,%edx
    6bb9:	8b 45 18             	mov    0x18(%ebp),%eax
    6bbc:	39 c2                	cmp    %eax,%edx
    6bbe:	77 17                	ja     6bd7 <encodeLZ77+0x510>
    6bc0:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6bc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6bc6:	01 d0                	add    %edx,%eax
    6bc8:	8d 50 ff             	lea    -0x1(%eax),%edx
    6bcb:	8b 45 10             	mov    0x10(%ebp),%eax
    6bce:	01 d0                	add    %edx,%eax
    6bd0:	0f b6 00             	movzbl (%eax),%eax
    6bd3:	84 c0                	test   %al,%al
    6bd5:	74 0f                	je     6be6 <encodeLZ77+0x51f>
    6bd7:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6bdb:	eb 09                	jmp    6be6 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    6bdd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6be4:	eb 01                	jmp    6be7 <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6be6:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    6be7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6bea:	0f b7 c0             	movzwl %ax,%eax
    6bed:	50                   	push   %eax
    6bee:	ff 75 b0             	pushl  -0x50(%ebp)
    6bf1:	ff 75 b4             	pushl  -0x4c(%ebp)
    6bf4:	ff 75 0c             	pushl  0xc(%ebp)
    6bf7:	e8 04 fa ff ff       	call   6600 <updateHashChain>
    6bfc:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    6bff:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6c03:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6c06:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6c09:	0f 82 54 ff ff ff    	jb     6b63 <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    6c0f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6c13:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6c16:	3b 45 18             	cmp    0x18(%ebp),%eax
    6c19:	0f 8c 54 fb ff ff    	jl     6773 <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    6c1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6c22:	c9                   	leave  
    6c23:	c3                   	ret    

00006c24 <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    6c24:	55                   	push   %ebp
    6c25:	89 e5                	mov    %esp,%ebp
    6c27:	53                   	push   %ebx
    6c28:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    6c2b:	8b 45 10             	mov    0x10(%ebp),%eax
    6c2e:	05 fe ff 00 00       	add    $0xfffe,%eax
    6c33:	ba 01 80 00 80       	mov    $0x80008001,%edx
    6c38:	f7 e2                	mul    %edx
    6c3a:	89 d0                	mov    %edx,%eax
    6c3c:	c1 e8 0f             	shr    $0xf,%eax
    6c3f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    6c42:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    6c49:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6c50:	e9 1b 01 00 00       	jmp    6d70 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    6c55:	8b 45 08             	mov    0x8(%ebp),%eax
    6c58:	8b 40 04             	mov    0x4(%eax),%eax
    6c5b:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    6c5e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6c61:	83 e8 01             	sub    $0x1,%eax
    6c64:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6c67:	0f 94 c0             	sete   %al
    6c6a:	0f b6 c0             	movzbl %al,%eax
    6c6d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    6c70:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    6c77:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    6c7e:	8b 45 10             	mov    0x10(%ebp),%eax
    6c81:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6c84:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    6c89:	77 09                	ja     6c94 <deflateNoCompression+0x70>
    6c8b:	8b 45 10             	mov    0x10(%ebp),%eax
    6c8e:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6c91:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    6c94:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6c99:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6c9c:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    6c9f:	8b 45 08             	mov    0x8(%ebp),%eax
    6ca2:	8b 40 04             	mov    0x4(%eax),%eax
    6ca5:	89 c2                	mov    %eax,%edx
    6ca7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6caa:	01 d0                	add    %edx,%eax
    6cac:	83 c0 05             	add    $0x5,%eax
    6caf:	50                   	push   %eax
    6cb0:	ff 75 08             	pushl  0x8(%ebp)
    6cb3:	e8 62 c9 ff ff       	call   361a <ucvector_resize>
    6cb8:	83 c4 08             	add    $0x8,%esp
    6cbb:	85 c0                	test   %eax,%eax
    6cbd:	75 0a                	jne    6cc9 <deflateNoCompression+0xa5>
    6cbf:	b8 53 00 00 00       	mov    $0x53,%eax
    6cc4:	e9 b8 00 00 00       	jmp    6d81 <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    6cc9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6ccc:	89 c2                	mov    %eax,%edx
    6cce:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6cd1:	83 e0 01             	and    $0x1,%eax
    6cd4:	01 c0                	add    %eax,%eax
    6cd6:	01 c2                	add    %eax,%edx
    6cd8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6cdb:	83 e0 02             	and    $0x2,%eax
    6cde:	01 c0                	add    %eax,%eax
    6ce0:	01 d0                	add    %edx,%eax
    6ce2:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    6ce5:	8b 45 08             	mov    0x8(%ebp),%eax
    6ce8:	8b 10                	mov    (%eax),%edx
    6cea:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6ced:	01 c2                	add    %eax,%edx
    6cef:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    6cf3:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    6cf5:	8b 45 08             	mov    0x8(%ebp),%eax
    6cf8:	8b 00                	mov    (%eax),%eax
    6cfa:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6cfd:	83 c2 01             	add    $0x1,%edx
    6d00:	01 d0                	add    %edx,%eax
    6d02:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6d05:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    6d07:	8b 45 08             	mov    0x8(%ebp),%eax
    6d0a:	8b 00                	mov    (%eax),%eax
    6d0c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6d0f:	83 c2 02             	add    $0x2,%edx
    6d12:	01 d0                	add    %edx,%eax
    6d14:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6d17:	c1 ea 08             	shr    $0x8,%edx
    6d1a:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    6d1c:	8b 45 08             	mov    0x8(%ebp),%eax
    6d1f:	8b 00                	mov    (%eax),%eax
    6d21:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6d24:	83 c2 03             	add    $0x3,%edx
    6d27:	01 d0                	add    %edx,%eax
    6d29:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6d2c:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    6d2e:	8b 45 08             	mov    0x8(%ebp),%eax
    6d31:	8b 00                	mov    (%eax),%eax
    6d33:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6d36:	83 c2 04             	add    $0x4,%edx
    6d39:	01 d0                	add    %edx,%eax
    6d3b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6d3e:	c1 ea 08             	shr    $0x8,%edx
    6d41:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    6d43:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6d46:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    6d49:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6d4c:	01 d1                	add    %edx,%ecx
    6d4e:	8b 55 08             	mov    0x8(%ebp),%edx
    6d51:	8b 12                	mov    (%edx),%edx
    6d53:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6d56:	83 c3 05             	add    $0x5,%ebx
    6d59:	01 da                	add    %ebx,%edx
    6d5b:	50                   	push   %eax
    6d5c:	51                   	push   %ecx
    6d5d:	52                   	push   %edx
    6d5e:	e8 9b c6 ff ff       	call   33fe <lodepng_memcpy>
    6d63:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    6d66:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6d69:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    6d6c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6d70:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6d73:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6d76:	0f 85 d9 fe ff ff    	jne    6c55 <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    6d7c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6d81:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6d84:	c9                   	leave  
    6d85:	c3                   	ret    

00006d86 <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    6d86:	55                   	push   %ebp
    6d87:	89 e5                	mov    %esp,%ebp
    6d89:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    6d8c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    6d93:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6d9a:	e9 10 01 00 00       	jmp    6eaf <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    6d9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    6da2:	8b 00                	mov    (%eax),%eax
    6da4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6da7:	c1 e2 02             	shl    $0x2,%edx
    6daa:	01 d0                	add    %edx,%eax
    6dac:	8b 00                	mov    (%eax),%eax
    6dae:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    6db1:	8b 45 10             	mov    0x10(%ebp),%eax
    6db4:	8b 40 04             	mov    0x4(%eax),%eax
    6db7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6dba:	c1 e2 02             	shl    $0x2,%edx
    6dbd:	01 d0                	add    %edx,%eax
    6dbf:	8b 00                	mov    (%eax),%eax
    6dc1:	89 c1                	mov    %eax,%ecx
    6dc3:	8b 45 10             	mov    0x10(%ebp),%eax
    6dc6:	8b 00                	mov    (%eax),%eax
    6dc8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6dcb:	c1 e2 02             	shl    $0x2,%edx
    6dce:	01 d0                	add    %edx,%eax
    6dd0:	8b 00                	mov    (%eax),%eax
    6dd2:	51                   	push   %ecx
    6dd3:	50                   	push   %eax
    6dd4:	ff 75 08             	pushl  0x8(%ebp)
    6dd7:	e8 60 cc ff ff       	call   3a3c <writeBitsReversed>
    6ddc:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    6ddf:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    6de6:	0f 86 bf 00 00 00    	jbe    6eab <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    6dec:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6def:	2d 01 01 00 00       	sub    $0x101,%eax
    6df4:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    6df7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6dfa:	8b 04 85 60 9e 01 00 	mov    0x19e60(,%eax,4),%eax
    6e01:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    6e04:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e07:	8b 00                	mov    (%eax),%eax
    6e09:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e0d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6e10:	c1 e2 02             	shl    $0x2,%edx
    6e13:	01 d0                	add    %edx,%eax
    6e15:	8b 00                	mov    (%eax),%eax
    6e17:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    6e1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e1d:	8b 00                	mov    (%eax),%eax
    6e1f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e23:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6e26:	c1 e2 02             	shl    $0x2,%edx
    6e29:	01 d0                	add    %edx,%eax
    6e2b:	8b 00                	mov    (%eax),%eax
    6e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    6e30:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6e33:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    6e36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6e39:	8b 04 85 60 9f 01 00 	mov    0x19f60(,%eax,4),%eax
    6e40:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    6e43:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e46:	8b 00                	mov    (%eax),%eax
    6e48:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e4c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6e4f:	c1 e2 02             	shl    $0x2,%edx
    6e52:	01 d0                	add    %edx,%eax
    6e54:	8b 00                	mov    (%eax),%eax
    6e56:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    6e59:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6e5c:	50                   	push   %eax
    6e5d:	ff 75 ec             	pushl  -0x14(%ebp)
    6e60:	ff 75 08             	pushl  0x8(%ebp)
    6e63:	e8 40 ca ff ff       	call   38a8 <writeBits>
    6e68:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    6e6b:	8b 45 14             	mov    0x14(%ebp),%eax
    6e6e:	8b 40 04             	mov    0x4(%eax),%eax
    6e71:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6e74:	c1 e2 02             	shl    $0x2,%edx
    6e77:	01 d0                	add    %edx,%eax
    6e79:	8b 00                	mov    (%eax),%eax
    6e7b:	89 c1                	mov    %eax,%ecx
    6e7d:	8b 45 14             	mov    0x14(%ebp),%eax
    6e80:	8b 00                	mov    (%eax),%eax
    6e82:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6e85:	c1 e2 02             	shl    $0x2,%edx
    6e88:	01 d0                	add    %edx,%eax
    6e8a:	8b 00                	mov    (%eax),%eax
    6e8c:	51                   	push   %ecx
    6e8d:	50                   	push   %eax
    6e8e:	ff 75 08             	pushl  0x8(%ebp)
    6e91:	e8 a6 cb ff ff       	call   3a3c <writeBitsReversed>
    6e96:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    6e99:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6e9c:	50                   	push   %eax
    6e9d:	ff 75 dc             	pushl  -0x24(%ebp)
    6ea0:	ff 75 08             	pushl  0x8(%ebp)
    6ea3:	e8 00 ca ff ff       	call   38a8 <writeBits>
    6ea8:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    6eab:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6eaf:	8b 45 0c             	mov    0xc(%ebp),%eax
    6eb2:	8b 40 04             	mov    0x4(%eax),%eax
    6eb5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6eb8:	0f 85 e1 fe ff ff    	jne    6d9f <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    6ebe:	90                   	nop
    6ebf:	c9                   	leave  
    6ec0:	c3                   	ret    

00006ec1 <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    6ec1:	55                   	push   %ebp
    6ec2:	89 e5                	mov    %esp,%ebp
    6ec4:	53                   	push   %ebx
    6ec5:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    6ecb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    6ed2:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    6ed9:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    6ee0:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    6ee7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    6eee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    6ef5:	8b 45 18             	mov    0x18(%ebp),%eax
    6ef8:	2b 45 14             	sub    0x14(%ebp),%eax
    6efb:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    6efe:	8b 45 20             	mov    0x20(%ebp),%eax
    6f01:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    6f04:	8d 45 90             	lea    -0x70(%ebp),%eax
    6f07:	50                   	push   %eax
    6f08:	e8 a4 c6 ff ff       	call   35b1 <uivector_init>
    6f0d:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    6f10:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    6f16:	50                   	push   %eax
    6f17:	e8 98 d3 ff ff       	call   42b4 <HuffmanTree_init>
    6f1c:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    6f1f:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    6f25:	50                   	push   %eax
    6f26:	e8 89 d3 ff ff       	call   42b4 <HuffmanTree_init>
    6f2b:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    6f2e:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    6f34:	50                   	push   %eax
    6f35:	e8 7a d3 ff ff       	call   42b4 <HuffmanTree_init>
    6f3a:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    6f3d:	83 ec 0c             	sub    $0xc,%esp
    6f40:	68 78 04 00 00       	push   $0x478
    6f45:	e8 76 c4 ff ff       	call   33c0 <lodepng_malloc>
    6f4a:	83 c4 10             	add    $0x10,%esp
    6f4d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    6f50:	83 ec 0c             	sub    $0xc,%esp
    6f53:	6a 78                	push   $0x78
    6f55:	e8 66 c4 ff ff       	call   33c0 <lodepng_malloc>
    6f5a:	83 c4 10             	add    $0x10,%esp
    6f5d:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6f60:	83 ec 0c             	sub    $0xc,%esp
    6f63:	6a 4c                	push   $0x4c
    6f65:	e8 56 c4 ff ff       	call   33c0 <lodepng_malloc>
    6f6a:	83 c4 10             	add    $0x10,%esp
    6f6d:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    6f70:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    6f74:	74 0c                	je     6f82 <deflateDynamic+0xc1>
    6f76:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    6f7a:	74 06                	je     6f82 <deflateDynamic+0xc1>
    6f7c:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    6f80:	75 07                	jne    6f89 <deflateDynamic+0xc8>
    6f82:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    6f89:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6f8d:	0f 85 f6 07 00 00    	jne    7789 <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    6f93:	83 ec 04             	sub    $0x4,%esp
    6f96:	68 78 04 00 00       	push   $0x478
    6f9b:	6a 00                	push   $0x0
    6f9d:	ff 75 d4             	pushl  -0x2c(%ebp)
    6fa0:	e8 8c c4 ff ff       	call   3431 <lodepng_memset>
    6fa5:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    6fa8:	83 ec 04             	sub    $0x4,%esp
    6fab:	6a 78                	push   $0x78
    6fad:	6a 00                	push   $0x0
    6faf:	ff 75 d0             	pushl  -0x30(%ebp)
    6fb2:	e8 7a c4 ff ff       	call   3431 <lodepng_memset>
    6fb7:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6fba:	83 ec 04             	sub    $0x4,%esp
    6fbd:	6a 4c                	push   $0x4c
    6fbf:	6a 00                	push   $0x0
    6fc1:	ff 75 cc             	pushl  -0x34(%ebp)
    6fc4:	e8 68 c4 ff ff       	call   3431 <lodepng_memset>
    6fc9:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    6fcc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6fcf:	8b 40 04             	mov    0x4(%eax),%eax
    6fd2:	85 c0                	test   %eax,%eax
    6fd4:	74 45                	je     701b <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    6fd6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6fd9:	8b 58 14             	mov    0x14(%eax),%ebx
    6fdc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6fdf:	8b 48 10             	mov    0x10(%eax),%ecx
    6fe2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6fe5:	8b 50 0c             	mov    0xc(%eax),%edx
    6fe8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6feb:	8b 40 08             	mov    0x8(%eax),%eax
    6fee:	83 ec 0c             	sub    $0xc,%esp
    6ff1:	53                   	push   %ebx
    6ff2:	51                   	push   %ecx
    6ff3:	52                   	push   %edx
    6ff4:	50                   	push   %eax
    6ff5:	ff 75 18             	pushl  0x18(%ebp)
    6ff8:	ff 75 14             	pushl  0x14(%ebp)
    6ffb:	ff 75 10             	pushl  0x10(%ebp)
    6ffe:	ff 75 0c             	pushl  0xc(%ebp)
    7001:	8d 45 90             	lea    -0x70(%ebp),%eax
    7004:	50                   	push   %eax
    7005:	e8 bd f6 ff ff       	call   66c7 <encodeLZ77>
    700a:	83 c4 30             	add    $0x30,%esp
    700d:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    7010:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7014:	74 59                	je     706f <deflateDynamic+0x1ae>
    7016:	e9 6e 07 00 00       	jmp    7789 <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    701b:	83 ec 08             	sub    $0x8,%esp
    701e:	ff 75 c8             	pushl  -0x38(%ebp)
    7021:	8d 45 90             	lea    -0x70(%ebp),%eax
    7024:	50                   	push   %eax
    7025:	e8 17 c5 ff ff       	call   3541 <uivector_resize>
    702a:	83 c4 10             	add    $0x10,%esp
    702d:	85 c0                	test   %eax,%eax
    702f:	75 0c                	jne    703d <deflateDynamic+0x17c>
    7031:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7038:	e9 4c 07 00 00       	jmp    7789 <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    703d:	8b 45 14             	mov    0x14(%ebp),%eax
    7040:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7043:	eb 22                	jmp    7067 <deflateDynamic+0x1a6>
    7045:	8b 55 90             	mov    -0x70(%ebp),%edx
    7048:	8b 45 e8             	mov    -0x18(%ebp),%eax
    704b:	2b 45 14             	sub    0x14(%ebp),%eax
    704e:	c1 e0 02             	shl    $0x2,%eax
    7051:	01 c2                	add    %eax,%edx
    7053:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7056:	8b 45 10             	mov    0x10(%ebp),%eax
    7059:	01 c8                	add    %ecx,%eax
    705b:	0f b6 00             	movzbl (%eax),%eax
    705e:	0f b6 c0             	movzbl %al,%eax
    7061:	89 02                	mov    %eax,(%edx)
    7063:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7067:	8b 45 e8             	mov    -0x18(%ebp),%eax
    706a:	3b 45 18             	cmp    0x18(%ebp),%eax
    706d:	7c d6                	jl     7045 <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    706f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7076:	eb 60                	jmp    70d8 <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    7078:	8b 45 90             	mov    -0x70(%ebp),%eax
    707b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    707e:	c1 e2 02             	shl    $0x2,%edx
    7081:	01 d0                	add    %edx,%eax
    7083:	8b 00                	mov    (%eax),%eax
    7085:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    7088:	8b 45 c0             	mov    -0x40(%ebp),%eax
    708b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7092:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7095:	01 d0                	add    %edx,%eax
    7097:	8b 10                	mov    (%eax),%edx
    7099:	83 c2 01             	add    $0x1,%edx
    709c:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    709e:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    70a5:	76 2d                	jbe    70d4 <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    70a7:	8b 45 90             	mov    -0x70(%ebp),%eax
    70aa:	8b 55 e8             	mov    -0x18(%ebp),%edx
    70ad:	83 c2 02             	add    $0x2,%edx
    70b0:	c1 e2 02             	shl    $0x2,%edx
    70b3:	01 d0                	add    %edx,%eax
    70b5:	8b 00                	mov    (%eax),%eax
    70b7:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    70ba:	8b 45 bc             	mov    -0x44(%ebp),%eax
    70bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    70c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
    70c7:	01 d0                	add    %edx,%eax
    70c9:	8b 10                	mov    (%eax),%edx
    70cb:	83 c2 01             	add    $0x1,%edx
    70ce:	89 10                	mov    %edx,(%eax)
        i += 3;
    70d0:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    70d4:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    70d8:	8b 45 94             	mov    -0x6c(%ebp),%eax
    70db:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    70de:	75 98                	jne    7078 <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    70e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    70e3:	05 00 04 00 00       	add    $0x400,%eax
    70e8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    70ee:	83 ec 0c             	sub    $0xc,%esp
    70f1:	6a 0f                	push   $0xf
    70f3:	68 1e 01 00 00       	push   $0x11e
    70f8:	68 01 01 00 00       	push   $0x101
    70fd:	ff 75 d4             	pushl  -0x2c(%ebp)
    7100:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7106:	50                   	push   %eax
    7107:	e8 e0 e1 ff ff       	call   52ec <HuffmanTree_makeFromFrequencies>
    710c:	83 c4 20             	add    $0x20,%esp
    710f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7112:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7116:	0f 85 66 06 00 00    	jne    7782 <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    711c:	83 ec 0c             	sub    $0xc,%esp
    711f:	6a 0f                	push   $0xf
    7121:	6a 1e                	push   $0x1e
    7123:	6a 02                	push   $0x2
    7125:	ff 75 d0             	pushl  -0x30(%ebp)
    7128:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    712e:	50                   	push   %eax
    712f:	e8 b8 e1 ff ff       	call   52ec <HuffmanTree_makeFromFrequencies>
    7134:	83 c4 20             	add    $0x20,%esp
    7137:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    713a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    713e:	0f 85 41 06 00 00    	jne    7785 <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    7144:	8b 45 84             	mov    -0x7c(%ebp),%eax
    7147:	ba 1e 01 00 00       	mov    $0x11e,%edx
    714c:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    7151:	0f 47 c2             	cmova  %edx,%eax
    7154:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    7157:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    715d:	ba 1e 00 00 00       	mov    $0x1e,%edx
    7162:	83 f8 1e             	cmp    $0x1e,%eax
    7165:	0f 47 c2             	cmova  %edx,%eax
    7168:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    716b:	8b 55 b8             	mov    -0x48(%ebp),%edx
    716e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7171:	01 d0                	add    %edx,%eax
    7173:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    7176:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7179:	c1 e0 02             	shl    $0x2,%eax
    717c:	83 ec 0c             	sub    $0xc,%esp
    717f:	50                   	push   %eax
    7180:	e8 3b c2 ff ff       	call   33c0 <lodepng_malloc>
    7185:	83 c4 10             	add    $0x10,%esp
    7188:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    718b:	8b 45 b0             	mov    -0x50(%ebp),%eax
    718e:	c1 e0 02             	shl    $0x2,%eax
    7191:	83 ec 0c             	sub    $0xc,%esp
    7194:	50                   	push   %eax
    7195:	e8 26 c2 ff ff       	call   33c0 <lodepng_malloc>
    719a:	83 c4 10             	add    $0x10,%esp
    719d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    71a0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    71a4:	74 06                	je     71ac <deflateDynamic+0x2eb>
    71a6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    71aa:	75 0c                	jne    71b8 <deflateDynamic+0x2f7>
    71ac:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    71b3:	e9 d1 05 00 00       	jmp    7789 <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    71b8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    71bf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    71c6:	eb 25                	jmp    71ed <deflateDynamic+0x32c>
    71c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71cb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71d5:	01 c2                	add    %eax,%edx
    71d7:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    71dd:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    71e0:	c1 e1 02             	shl    $0x2,%ecx
    71e3:	01 c8                	add    %ecx,%eax
    71e5:	8b 00                	mov    (%eax),%eax
    71e7:	89 02                	mov    %eax,(%edx)
    71e9:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    71ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71f0:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    71f3:	75 d3                	jne    71c8 <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    71f5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    71fc:	eb 2a                	jmp    7228 <deflateDynamic+0x367>
    71fe:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7201:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7204:	01 d0                	add    %edx,%eax
    7206:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    720d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7210:	01 c2                	add    %eax,%edx
    7212:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    7218:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    721b:	c1 e1 02             	shl    $0x2,%ecx
    721e:	01 c8                	add    %ecx,%eax
    7220:	8b 00                	mov    (%eax),%eax
    7222:	89 02                	mov    %eax,(%edx)
    7224:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7228:	8b 45 e8             	mov    -0x18(%ebp),%eax
    722b:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    722e:	75 ce                	jne    71fe <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7230:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7237:	e9 3b 02 00 00       	jmp    7477 <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    723c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    7243:	eb 04                	jmp    7249 <deflateDynamic+0x388>
    7245:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    7249:	8b 55 e8             	mov    -0x18(%ebp),%edx
    724c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    724f:	01 d0                	add    %edx,%eax
    7251:	8d 50 01             	lea    0x1(%eax),%edx
    7254:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7257:	39 c2                	cmp    %eax,%edx
    7259:	73 2e                	jae    7289 <deflateDynamic+0x3c8>
    725b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    725e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7261:	01 d0                	add    %edx,%eax
    7263:	83 c0 01             	add    $0x1,%eax
    7266:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    726d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7270:	01 d0                	add    %edx,%eax
    7272:	8b 10                	mov    (%eax),%edx
    7274:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7277:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    727e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7281:	01 c8                	add    %ecx,%eax
    7283:	8b 00                	mov    (%eax),%eax
    7285:	39 c2                	cmp    %eax,%edx
    7287:	74 bc                	je     7245 <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    7289:	8b 45 e8             	mov    -0x18(%ebp),%eax
    728c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7293:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7296:	01 d0                	add    %edx,%eax
    7298:	8b 00                	mov    (%eax),%eax
    729a:	85 c0                	test   %eax,%eax
    729c:	0f 85 a9 00 00 00    	jne    734b <deflateDynamic+0x48a>
    72a2:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    72a6:	0f 86 9f 00 00 00    	jbe    734b <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    72ac:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    72b0:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    72b4:	77 3a                	ja     72f0 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    72b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72b9:	8d 50 01             	lea    0x1(%eax),%edx
    72bc:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    72bf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    72c9:	01 d0                	add    %edx,%eax
    72cb:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    72d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72d4:	8d 50 01             	lea    0x1(%eax),%edx
    72d7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    72da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    72e4:	01 d0                	add    %edx,%eax
    72e6:	8b 55 dc             	mov    -0x24(%ebp),%edx
    72e9:	83 ea 03             	sub    $0x3,%edx
    72ec:	89 10                	mov    %edx,(%eax)
    72ee:	eb 48                	jmp    7338 <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    72f0:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    72f7:	76 07                	jbe    7300 <deflateDynamic+0x43f>
    72f9:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    7300:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7303:	8d 50 01             	lea    0x1(%eax),%edx
    7306:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7309:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7310:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7313:	01 d0                	add    %edx,%eax
    7315:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    731b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    731e:	8d 50 01             	lea    0x1(%eax),%edx
    7321:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7324:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    732b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    732e:	01 d0                	add    %edx,%eax
    7330:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7333:	83 ea 0b             	sub    $0xb,%edx
    7336:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    7338:	8b 55 e8             	mov    -0x18(%ebp),%edx
    733b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    733e:	01 d0                	add    %edx,%eax
    7340:	83 e8 01             	sub    $0x1,%eax
    7343:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7346:	e9 28 01 00 00       	jmp    7473 <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    734b:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    734f:	0f 86 f6 00 00 00    	jbe    744b <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    7355:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7358:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    735d:	f7 e2                	mul    %edx
    735f:	89 d0                	mov    %edx,%eax
    7361:	c1 e8 02             	shr    $0x2,%eax
    7364:	89 45 ac             	mov    %eax,-0x54(%ebp)
    7367:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    736a:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    736f:	89 c8                	mov    %ecx,%eax
    7371:	f7 e2                	mul    %edx
    7373:	c1 ea 02             	shr    $0x2,%edx
    7376:	89 d0                	mov    %edx,%eax
    7378:	01 c0                	add    %eax,%eax
    737a:	01 d0                	add    %edx,%eax
    737c:	01 c0                	add    %eax,%eax
    737e:	29 c1                	sub    %eax,%ecx
    7380:	89 c8                	mov    %ecx,%eax
    7382:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    7385:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7388:	8d 50 01             	lea    0x1(%eax),%edx
    738b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    738e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7395:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7398:	01 c2                	add    %eax,%edx
    739a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    739d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    73a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    73a7:	01 c8                	add    %ecx,%eax
    73a9:	8b 00                	mov    (%eax),%eax
    73ab:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    73ad:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    73b4:	eb 3a                	jmp    73f0 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    73b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73b9:	8d 50 01             	lea    0x1(%eax),%edx
    73bc:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    73bf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73c9:	01 d0                	add    %edx,%eax
    73cb:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    73d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73d4:	8d 50 01             	lea    0x1(%eax),%edx
    73d7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    73da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73e4:	01 d0                	add    %edx,%eax
    73e6:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    73ec:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    73f0:	8b 45 d8             	mov    -0x28(%ebp),%eax
    73f3:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    73f6:	72 be                	jb     73b6 <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    73f8:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    73fc:	76 3a                	jbe    7438 <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    73fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7401:	8d 50 01             	lea    0x1(%eax),%edx
    7404:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7407:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    740e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7411:	01 d0                	add    %edx,%eax
    7413:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    7419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    741c:	8d 50 01             	lea    0x1(%eax),%edx
    741f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7422:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7429:	8b 45 ec             	mov    -0x14(%ebp),%eax
    742c:	01 d0                	add    %edx,%eax
    742e:	8b 55 a8             	mov    -0x58(%ebp),%edx
    7431:	83 ea 03             	sub    $0x3,%edx
    7434:	89 10                	mov    %edx,(%eax)
    7436:	eb 06                	jmp    743e <deflateDynamic+0x57d>
        }
        else j -= rest;
    7438:	8b 45 a8             	mov    -0x58(%ebp),%eax
    743b:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    743e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7441:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7444:	01 d0                	add    %edx,%eax
    7446:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7449:	eb 28                	jmp    7473 <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    744b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    744e:	8d 50 01             	lea    0x1(%eax),%edx
    7451:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7454:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    745b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    745e:	01 c2                	add    %eax,%edx
    7460:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7463:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    746a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    746d:	01 c8                	add    %ecx,%eax
    746f:	8b 00                	mov    (%eax),%eax
    7471:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7473:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7477:	8b 45 e8             	mov    -0x18(%ebp),%eax
    747a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    747d:	0f 85 b9 fd ff ff    	jne    723c <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7483:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    748a:	eb 42                	jmp    74ce <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    748c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    748f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7496:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7499:	01 d0                	add    %edx,%eax
    749b:	8b 00                	mov    (%eax),%eax
    749d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
    74a7:	01 d0                	add    %edx,%eax
    74a9:	8b 10                	mov    (%eax),%edx
    74ab:	83 c2 01             	add    $0x1,%edx
    74ae:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    74b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    74bd:	01 d0                	add    %edx,%eax
    74bf:	8b 00                	mov    (%eax),%eax
    74c1:	83 f8 0f             	cmp    $0xf,%eax
    74c4:	76 04                	jbe    74ca <deflateDynamic+0x609>
    74c6:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    74ca:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    74ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74d1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    74d4:	75 b6                	jne    748c <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    74d6:	83 ec 0c             	sub    $0xc,%esp
    74d9:	6a 07                	push   $0x7
    74db:	6a 13                	push   $0x13
    74dd:	6a 13                	push   $0x13
    74df:	ff 75 cc             	pushl  -0x34(%ebp)
    74e2:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    74e8:	50                   	push   %eax
    74e9:	e8 fe dd ff ff       	call   52ec <HuffmanTree_makeFromFrequencies>
    74ee:	83 c4 20             	add    $0x20,%esp
    74f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    74f4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    74f8:	0f 85 8a 02 00 00    	jne    7788 <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    74fe:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7505:	eb 04                	jmp    750b <deflateDynamic+0x64a>
      numcodes_cl--;
    7507:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    750b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    750e:	83 f8 04             	cmp    $0x4,%eax
    7511:	76 1e                	jbe    7531 <deflateDynamic+0x670>
    7513:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7519:	8b 55 e0             	mov    -0x20(%ebp),%edx
    751c:	83 ea 01             	sub    $0x1,%edx
    751f:	8b 14 95 e0 9f 01 00 	mov    0x19fe0(,%edx,4),%edx
    7526:	c1 e2 02             	shl    $0x2,%edx
    7529:	01 d0                	add    %edx,%eax
    752b:	8b 00                	mov    (%eax),%eax
    752d:	85 c0                	test   %eax,%eax
    752f:	74 d6                	je     7507 <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    7531:	83 ec 04             	sub    $0x4,%esp
    7534:	6a 01                	push   $0x1
    7536:	ff 75 c4             	pushl  -0x3c(%ebp)
    7539:	ff 75 08             	pushl  0x8(%ebp)
    753c:	e8 67 c3 ff ff       	call   38a8 <writeBits>
    7541:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    7544:	83 ec 04             	sub    $0x4,%esp
    7547:	6a 01                	push   $0x1
    7549:	6a 00                	push   $0x0
    754b:	ff 75 08             	pushl  0x8(%ebp)
    754e:	e8 55 c3 ff ff       	call   38a8 <writeBits>
    7553:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    7556:	83 ec 04             	sub    $0x4,%esp
    7559:	6a 01                	push   $0x1
    755b:	6a 01                	push   $0x1
    755d:	ff 75 08             	pushl  0x8(%ebp)
    7560:	e8 43 c3 ff ff       	call   38a8 <writeBits>
    7565:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    7568:	8b 45 b8             	mov    -0x48(%ebp),%eax
    756b:	2d 01 01 00 00       	sub    $0x101,%eax
    7570:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    7573:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7576:	83 e8 01             	sub    $0x1,%eax
    7579:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    757c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    757f:	83 e8 04             	sub    $0x4,%eax
    7582:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    7585:	83 ec 04             	sub    $0x4,%esp
    7588:	6a 05                	push   $0x5
    758a:	ff 75 a4             	pushl  -0x5c(%ebp)
    758d:	ff 75 08             	pushl  0x8(%ebp)
    7590:	e8 13 c3 ff ff       	call   38a8 <writeBits>
    7595:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    7598:	83 ec 04             	sub    $0x4,%esp
    759b:	6a 05                	push   $0x5
    759d:	ff 75 a0             	pushl  -0x60(%ebp)
    75a0:	ff 75 08             	pushl  0x8(%ebp)
    75a3:	e8 00 c3 ff ff       	call   38a8 <writeBits>
    75a8:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    75ab:	83 ec 04             	sub    $0x4,%esp
    75ae:	6a 04                	push   $0x4
    75b0:	ff 75 9c             	pushl  -0x64(%ebp)
    75b3:	ff 75 08             	pushl  0x8(%ebp)
    75b6:	e8 ed c2 ff ff       	call   38a8 <writeBits>
    75bb:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    75be:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    75c5:	eb 2c                	jmp    75f3 <deflateDynamic+0x732>
    75c7:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    75cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75d0:	8b 04 85 e0 9f 01 00 	mov    0x19fe0(,%eax,4),%eax
    75d7:	c1 e0 02             	shl    $0x2,%eax
    75da:	01 d0                	add    %edx,%eax
    75dc:	8b 00                	mov    (%eax),%eax
    75de:	83 ec 04             	sub    $0x4,%esp
    75e1:	6a 03                	push   $0x3
    75e3:	50                   	push   %eax
    75e4:	ff 75 08             	pushl  0x8(%ebp)
    75e7:	e8 bc c2 ff ff       	call   38a8 <writeBits>
    75ec:	83 c4 10             	add    $0x10,%esp
    75ef:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    75f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75f6:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    75f9:	75 cc                	jne    75c7 <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    75fb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7602:	e9 0a 01 00 00       	jmp    7711 <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    7607:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    760d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7610:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    7617:	8b 55 ec             	mov    -0x14(%ebp),%edx
    761a:	01 ca                	add    %ecx,%edx
    761c:	8b 12                	mov    (%edx),%edx
    761e:	c1 e2 02             	shl    $0x2,%edx
    7621:	01 d0                	add    %edx,%eax
    7623:	8b 00                	mov    (%eax),%eax
    7625:	89 c3                	mov    %eax,%ebx
    7627:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    762d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7630:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    7637:	8b 55 ec             	mov    -0x14(%ebp),%edx
    763a:	01 ca                	add    %ecx,%edx
    763c:	8b 12                	mov    (%edx),%edx
    763e:	c1 e2 02             	shl    $0x2,%edx
    7641:	01 d0                	add    %edx,%eax
    7643:	8b 00                	mov    (%eax),%eax
    7645:	83 ec 04             	sub    $0x4,%esp
    7648:	53                   	push   %ebx
    7649:	50                   	push   %eax
    764a:	ff 75 08             	pushl  0x8(%ebp)
    764d:	e8 ea c3 ff ff       	call   3a3c <writeBitsReversed>
    7652:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    7655:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7658:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    765f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7662:	01 d0                	add    %edx,%eax
    7664:	8b 00                	mov    (%eax),%eax
    7666:	83 f8 10             	cmp    $0x10,%eax
    7669:	75 28                	jne    7693 <deflateDynamic+0x7d2>
    766b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    766f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7672:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7679:	8b 45 ec             	mov    -0x14(%ebp),%eax
    767c:	01 d0                	add    %edx,%eax
    767e:	8b 00                	mov    (%eax),%eax
    7680:	83 ec 04             	sub    $0x4,%esp
    7683:	6a 02                	push   $0x2
    7685:	50                   	push   %eax
    7686:	ff 75 08             	pushl  0x8(%ebp)
    7689:	e8 1a c2 ff ff       	call   38a8 <writeBits>
    768e:	83 c4 10             	add    $0x10,%esp
    7691:	eb 7a                	jmp    770d <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    7693:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7696:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    769d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76a0:	01 d0                	add    %edx,%eax
    76a2:	8b 00                	mov    (%eax),%eax
    76a4:	83 f8 11             	cmp    $0x11,%eax
    76a7:	75 28                	jne    76d1 <deflateDynamic+0x810>
    76a9:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    76ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76b0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76ba:	01 d0                	add    %edx,%eax
    76bc:	8b 00                	mov    (%eax),%eax
    76be:	83 ec 04             	sub    $0x4,%esp
    76c1:	6a 03                	push   $0x3
    76c3:	50                   	push   %eax
    76c4:	ff 75 08             	pushl  0x8(%ebp)
    76c7:	e8 dc c1 ff ff       	call   38a8 <writeBits>
    76cc:	83 c4 10             	add    $0x10,%esp
    76cf:	eb 3c                	jmp    770d <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    76d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76d4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76db:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76de:	01 d0                	add    %edx,%eax
    76e0:	8b 00                	mov    (%eax),%eax
    76e2:	83 f8 12             	cmp    $0x12,%eax
    76e5:	75 26                	jne    770d <deflateDynamic+0x84c>
    76e7:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    76eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76ee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76f8:	01 d0                	add    %edx,%eax
    76fa:	8b 00                	mov    (%eax),%eax
    76fc:	83 ec 04             	sub    $0x4,%esp
    76ff:	6a 07                	push   $0x7
    7701:	50                   	push   %eax
    7702:	ff 75 08             	pushl  0x8(%ebp)
    7705:	e8 9e c1 ff ff       	call   38a8 <writeBits>
    770a:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    770d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7711:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7714:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7717:	0f 85 ea fe ff ff    	jne    7607 <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    771d:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7723:	50                   	push   %eax
    7724:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    772a:	50                   	push   %eax
    772b:	8d 45 90             	lea    -0x70(%ebp),%eax
    772e:	50                   	push   %eax
    772f:	ff 75 08             	pushl  0x8(%ebp)
    7732:	e8 4f f6 ff ff       	call   6d86 <writeLZ77data>
    7737:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    773a:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7740:	05 00 04 00 00       	add    $0x400,%eax
    7745:	8b 00                	mov    (%eax),%eax
    7747:	85 c0                	test   %eax,%eax
    7749:	75 09                	jne    7754 <deflateDynamic+0x893>
    774b:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    7752:	eb 35                	jmp    7789 <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    7754:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    775a:	05 00 04 00 00       	add    $0x400,%eax
    775f:	8b 00                	mov    (%eax),%eax
    7761:	89 c2                	mov    %eax,%edx
    7763:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    7769:	05 00 04 00 00       	add    $0x400,%eax
    776e:	8b 00                	mov    (%eax),%eax
    7770:	83 ec 04             	sub    $0x4,%esp
    7773:	52                   	push   %edx
    7774:	50                   	push   %eax
    7775:	ff 75 08             	pushl  0x8(%ebp)
    7778:	e8 bf c2 ff ff       	call   3a3c <writeBitsReversed>
    777d:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    7780:	eb 07                	jmp    7789 <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    7782:	90                   	nop
    7783:	eb 04                	jmp    7789 <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    7785:	90                   	nop
    7786:	eb 01                	jmp    7789 <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    7788:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    7789:	83 ec 0c             	sub    $0xc,%esp
    778c:	8d 45 90             	lea    -0x70(%ebp),%eax
    778f:	50                   	push   %eax
    7790:	e8 73 bd ff ff       	call   3508 <uivector_cleanup>
    7795:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    7798:	83 ec 0c             	sub    $0xc,%esp
    779b:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    77a1:	50                   	push   %eax
    77a2:	e8 3a cb ff ff       	call   42e1 <HuffmanTree_cleanup>
    77a7:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    77aa:	83 ec 0c             	sub    $0xc,%esp
    77ad:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    77b3:	50                   	push   %eax
    77b4:	e8 28 cb ff ff       	call   42e1 <HuffmanTree_cleanup>
    77b9:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    77bc:	83 ec 0c             	sub    $0xc,%esp
    77bf:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    77c5:	50                   	push   %eax
    77c6:	e8 16 cb ff ff       	call   42e1 <HuffmanTree_cleanup>
    77cb:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    77ce:	83 ec 0c             	sub    $0xc,%esp
    77d1:	ff 75 d4             	pushl  -0x2c(%ebp)
    77d4:	e8 08 bc ff ff       	call   33e1 <lodepng_free>
    77d9:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    77dc:	83 ec 0c             	sub    $0xc,%esp
    77df:	ff 75 d0             	pushl  -0x30(%ebp)
    77e2:	e8 fa bb ff ff       	call   33e1 <lodepng_free>
    77e7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    77ea:	83 ec 0c             	sub    $0xc,%esp
    77ed:	ff 75 cc             	pushl  -0x34(%ebp)
    77f0:	e8 ec bb ff ff       	call   33e1 <lodepng_free>
    77f5:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    77f8:	83 ec 0c             	sub    $0xc,%esp
    77fb:	ff 75 f0             	pushl  -0x10(%ebp)
    77fe:	e8 de bb ff ff       	call   33e1 <lodepng_free>
    7803:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    7806:	83 ec 0c             	sub    $0xc,%esp
    7809:	ff 75 ec             	pushl  -0x14(%ebp)
    780c:	e8 d0 bb ff ff       	call   33e1 <lodepng_free>
    7811:	83 c4 10             	add    $0x10,%esp

  return error;
    7814:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7817:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    781a:	c9                   	leave  
    781b:	c3                   	ret    

0000781c <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    781c:	55                   	push   %ebp
    781d:	89 e5                	mov    %esp,%ebp
    781f:	53                   	push   %ebx
    7820:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    7823:	8b 45 20             	mov    0x20(%ebp),%eax
    7826:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    7829:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    7830:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7833:	50                   	push   %eax
    7834:	e8 7b ca ff ff       	call   42b4 <HuffmanTree_init>
    7839:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    783c:	8d 45 bc             	lea    -0x44(%ebp),%eax
    783f:	50                   	push   %eax
    7840:	e8 6f ca ff ff       	call   42b4 <HuffmanTree_init>
    7845:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    7848:	83 ec 0c             	sub    $0xc,%esp
    784b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    784e:	50                   	push   %eax
    784f:	e8 41 db ff ff       	call   5395 <generateFixedLitLenTree>
    7854:	83 c4 10             	add    $0x10,%esp
    7857:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    785a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    785e:	75 12                	jne    7872 <deflateFixed+0x56>
    7860:	83 ec 0c             	sub    $0xc,%esp
    7863:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7866:	50                   	push   %eax
    7867:	e8 30 dc ff ff       	call   549c <generateFixedDistanceTree>
    786c:	83 c4 10             	add    $0x10,%esp
    786f:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7872:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7876:	0f 85 3a 01 00 00    	jne    79b6 <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    787c:	83 ec 04             	sub    $0x4,%esp
    787f:	6a 01                	push   $0x1
    7881:	ff 75 ec             	pushl  -0x14(%ebp)
    7884:	ff 75 08             	pushl  0x8(%ebp)
    7887:	e8 1c c0 ff ff       	call   38a8 <writeBits>
    788c:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    788f:	83 ec 04             	sub    $0x4,%esp
    7892:	6a 01                	push   $0x1
    7894:	6a 01                	push   $0x1
    7896:	ff 75 08             	pushl  0x8(%ebp)
    7899:	e8 0a c0 ff ff       	call   38a8 <writeBits>
    789e:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    78a1:	83 ec 04             	sub    $0x4,%esp
    78a4:	6a 01                	push   $0x1
    78a6:	6a 00                	push   $0x0
    78a8:	ff 75 08             	pushl  0x8(%ebp)
    78ab:	e8 f8 bf ff ff       	call   38a8 <writeBits>
    78b0:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    78b3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    78b6:	8b 40 04             	mov    0x4(%eax),%eax
    78b9:	85 c0                	test   %eax,%eax
    78bb:	74 77                	je     7934 <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    78bd:	83 ec 0c             	sub    $0xc,%esp
    78c0:	8d 45 b0             	lea    -0x50(%ebp),%eax
    78c3:	50                   	push   %eax
    78c4:	e8 e8 bc ff ff       	call   35b1 <uivector_init>
    78c9:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    78cc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    78cf:	8b 58 14             	mov    0x14(%eax),%ebx
    78d2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    78d5:	8b 48 10             	mov    0x10(%eax),%ecx
    78d8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    78db:	8b 50 0c             	mov    0xc(%eax),%edx
    78de:	8b 45 1c             	mov    0x1c(%ebp),%eax
    78e1:	8b 40 08             	mov    0x8(%eax),%eax
    78e4:	83 ec 0c             	sub    $0xc,%esp
    78e7:	53                   	push   %ebx
    78e8:	51                   	push   %ecx
    78e9:	52                   	push   %edx
    78ea:	50                   	push   %eax
    78eb:	ff 75 18             	pushl  0x18(%ebp)
    78ee:	ff 75 14             	pushl  0x14(%ebp)
    78f1:	ff 75 10             	pushl  0x10(%ebp)
    78f4:	ff 75 0c             	pushl  0xc(%ebp)
    78f7:	8d 45 b0             	lea    -0x50(%ebp),%eax
    78fa:	50                   	push   %eax
    78fb:	e8 c7 ed ff ff       	call   66c7 <encodeLZ77>
    7900:	83 c4 30             	add    $0x30,%esp
    7903:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7906:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    790a:	75 17                	jne    7923 <deflateFixed+0x107>
    790c:	8d 45 bc             	lea    -0x44(%ebp),%eax
    790f:	50                   	push   %eax
    7910:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7913:	50                   	push   %eax
    7914:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7917:	50                   	push   %eax
    7918:	ff 75 08             	pushl  0x8(%ebp)
    791b:	e8 66 f4 ff ff       	call   6d86 <writeLZ77data>
    7920:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    7923:	83 ec 0c             	sub    $0xc,%esp
    7926:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7929:	50                   	push   %eax
    792a:	e8 d9 bb ff ff       	call   3508 <uivector_cleanup>
    792f:	83 c4 10             	add    $0x10,%esp
    7932:	eb 56                	jmp    798a <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7934:	8b 45 14             	mov    0x14(%ebp),%eax
    7937:	89 45 f0             	mov    %eax,-0x10(%ebp)
    793a:	eb 46                	jmp    7982 <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    793c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    793f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7942:	8b 55 10             	mov    0x10(%ebp),%edx
    7945:	01 ca                	add    %ecx,%edx
    7947:	0f b6 12             	movzbl (%edx),%edx
    794a:	0f b6 d2             	movzbl %dl,%edx
    794d:	c1 e2 02             	shl    $0x2,%edx
    7950:	01 d0                	add    %edx,%eax
    7952:	8b 00                	mov    (%eax),%eax
    7954:	89 c3                	mov    %eax,%ebx
    7956:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7959:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    795c:	8b 55 10             	mov    0x10(%ebp),%edx
    795f:	01 ca                	add    %ecx,%edx
    7961:	0f b6 12             	movzbl (%edx),%edx
    7964:	0f b6 d2             	movzbl %dl,%edx
    7967:	c1 e2 02             	shl    $0x2,%edx
    796a:	01 d0                	add    %edx,%eax
    796c:	8b 00                	mov    (%eax),%eax
    796e:	83 ec 04             	sub    $0x4,%esp
    7971:	53                   	push   %ebx
    7972:	50                   	push   %eax
    7973:	ff 75 08             	pushl  0x8(%ebp)
    7976:	e8 c1 c0 ff ff       	call   3a3c <writeBitsReversed>
    797b:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    797e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7982:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7985:	3b 45 18             	cmp    0x18(%ebp),%eax
    7988:	7c b2                	jl     793c <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    798a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    798e:	75 26                	jne    79b6 <deflateFixed+0x19a>
    7990:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7993:	05 00 04 00 00       	add    $0x400,%eax
    7998:	8b 00                	mov    (%eax),%eax
    799a:	89 c2                	mov    %eax,%edx
    799c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    799f:	05 00 04 00 00       	add    $0x400,%eax
    79a4:	8b 00                	mov    (%eax),%eax
    79a6:	83 ec 04             	sub    $0x4,%esp
    79a9:	52                   	push   %edx
    79aa:	50                   	push   %eax
    79ab:	ff 75 08             	pushl  0x8(%ebp)
    79ae:	e8 89 c0 ff ff       	call   3a3c <writeBitsReversed>
    79b3:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    79b6:	83 ec 0c             	sub    $0xc,%esp
    79b9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    79bc:	50                   	push   %eax
    79bd:	e8 1f c9 ff ff       	call   42e1 <HuffmanTree_cleanup>
    79c2:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    79c5:	83 ec 0c             	sub    $0xc,%esp
    79c8:	8d 45 bc             	lea    -0x44(%ebp),%eax
    79cb:	50                   	push   %eax
    79cc:	e8 10 c9 ff ff       	call   42e1 <HuffmanTree_cleanup>
    79d1:	83 c4 10             	add    $0x10,%esp

  return error;
    79d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    79d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    79da:	c9                   	leave  
    79db:	c3                   	ret    

000079dc <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    79dc:	55                   	push   %ebp
    79dd:	89 e5                	mov    %esp,%ebp
    79df:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    79e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    79e9:	ff 75 08             	pushl  0x8(%ebp)
    79ec:	8d 45 bc             	lea    -0x44(%ebp),%eax
    79ef:	50                   	push   %eax
    79f0:	e8 9e be ff ff       	call   3893 <LodePNGBitWriter_init>
    79f5:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    79f8:	8b 45 14             	mov    0x14(%ebp),%eax
    79fb:	8b 00                	mov    (%eax),%eax
    79fd:	83 f8 02             	cmp    $0x2,%eax
    7a00:	76 0a                	jbe    7a0c <lodepng_deflatev+0x30>
    7a02:	b8 3d 00 00 00       	mov    $0x3d,%eax
    7a07:	e9 68 01 00 00       	jmp    7b74 <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    7a0c:	8b 45 14             	mov    0x14(%ebp),%eax
    7a0f:	8b 00                	mov    (%eax),%eax
    7a11:	85 c0                	test   %eax,%eax
    7a13:	75 16                	jne    7a2b <lodepng_deflatev+0x4f>
    7a15:	ff 75 10             	pushl  0x10(%ebp)
    7a18:	ff 75 0c             	pushl  0xc(%ebp)
    7a1b:	ff 75 08             	pushl  0x8(%ebp)
    7a1e:	e8 01 f2 ff ff       	call   6c24 <deflateNoCompression>
    7a23:	83 c4 0c             	add    $0xc,%esp
    7a26:	e9 49 01 00 00       	jmp    7b74 <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    7a2b:	8b 45 14             	mov    0x14(%ebp),%eax
    7a2e:	8b 00                	mov    (%eax),%eax
    7a30:	83 f8 01             	cmp    $0x1,%eax
    7a33:	75 08                	jne    7a3d <lodepng_deflatev+0x61>
    7a35:	8b 45 10             	mov    0x10(%ebp),%eax
    7a38:	89 45 ec             	mov    %eax,-0x14(%ebp)
    7a3b:	eb 2c                	jmp    7a69 <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    7a3d:	8b 45 10             	mov    0x10(%ebp),%eax
    7a40:	c1 e8 03             	shr    $0x3,%eax
    7a43:	83 c0 08             	add    $0x8,%eax
    7a46:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    7a49:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    7a50:	7f 07                	jg     7a59 <lodepng_deflatev+0x7d>
    7a52:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    7a59:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    7a60:	7e 07                	jle    7a69 <lodepng_deflatev+0x8d>
    7a62:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    7a69:	8b 55 10             	mov    0x10(%ebp),%edx
    7a6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7a6f:	01 d0                	add    %edx,%eax
    7a71:	83 e8 01             	sub    $0x1,%eax
    7a74:	99                   	cltd   
    7a75:	f7 7d ec             	idivl  -0x14(%ebp)
    7a78:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    7a7b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7a7f:	75 07                	jne    7a88 <lodepng_deflatev+0xac>
    7a81:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    7a88:	8b 45 14             	mov    0x14(%ebp),%eax
    7a8b:	8b 40 08             	mov    0x8(%eax),%eax
    7a8e:	83 ec 08             	sub    $0x8,%esp
    7a91:	50                   	push   %eax
    7a92:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7a95:	50                   	push   %eax
    7a96:	e8 1c e8 ff ff       	call   62b7 <hash_init>
    7a9b:	83 c4 10             	add    $0x10,%esp
    7a9e:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7aa1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7aa5:	0f 85 b7 00 00 00    	jne    7b62 <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7aab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7ab2:	e9 99 00 00 00       	jmp    7b50 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    7ab7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7aba:	83 e8 01             	sub    $0x1,%eax
    7abd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7ac0:	0f 94 c0             	sete   %al
    7ac3:	0f b6 c0             	movzbl %al,%eax
    7ac6:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    7ac9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7acc:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    7ad0:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    7ad3:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7ad6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7ad9:	01 d0                	add    %edx,%eax
    7adb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    7ade:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7ae1:	3b 45 10             	cmp    0x10(%ebp),%eax
    7ae4:	7e 06                	jle    7aec <lodepng_deflatev+0x110>
    7ae6:	8b 45 10             	mov    0x10(%ebp),%eax
    7ae9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    7aec:	8b 45 14             	mov    0x14(%ebp),%eax
    7aef:	8b 00                	mov    (%eax),%eax
    7af1:	83 f8 01             	cmp    $0x1,%eax
    7af4:	75 27                	jne    7b1d <lodepng_deflatev+0x141>
    7af6:	83 ec 04             	sub    $0x4,%esp
    7af9:	ff 75 e0             	pushl  -0x20(%ebp)
    7afc:	ff 75 14             	pushl  0x14(%ebp)
    7aff:	ff 75 e4             	pushl  -0x1c(%ebp)
    7b02:	ff 75 dc             	pushl  -0x24(%ebp)
    7b05:	ff 75 0c             	pushl  0xc(%ebp)
    7b08:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7b0b:	50                   	push   %eax
    7b0c:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7b0f:	50                   	push   %eax
    7b10:	e8 07 fd ff ff       	call   781c <deflateFixed>
    7b15:	83 c4 20             	add    $0x20,%esp
    7b18:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7b1b:	eb 2f                	jmp    7b4c <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    7b1d:	8b 45 14             	mov    0x14(%ebp),%eax
    7b20:	8b 00                	mov    (%eax),%eax
    7b22:	83 f8 02             	cmp    $0x2,%eax
    7b25:	75 25                	jne    7b4c <lodepng_deflatev+0x170>
    7b27:	83 ec 04             	sub    $0x4,%esp
    7b2a:	ff 75 e0             	pushl  -0x20(%ebp)
    7b2d:	ff 75 14             	pushl  0x14(%ebp)
    7b30:	ff 75 e4             	pushl  -0x1c(%ebp)
    7b33:	ff 75 dc             	pushl  -0x24(%ebp)
    7b36:	ff 75 0c             	pushl  0xc(%ebp)
    7b39:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7b3c:	50                   	push   %eax
    7b3d:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7b40:	50                   	push   %eax
    7b41:	e8 7b f3 ff ff       	call   6ec1 <deflateDynamic>
    7b46:	83 c4 20             	add    $0x20,%esp
    7b49:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7b4c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7b50:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7b53:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7b56:	74 0a                	je     7b62 <lodepng_deflatev+0x186>
    7b58:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b5c:	0f 84 55 ff ff ff    	je     7ab7 <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    7b62:	83 ec 0c             	sub    $0xc,%esp
    7b65:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7b68:	50                   	push   %eax
    7b69:	e8 08 e9 ff ff       	call   6476 <hash_cleanup>
    7b6e:	83 c4 10             	add    $0x10,%esp

  return error;
    7b71:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7b74:	c9                   	leave  
    7b75:	c3                   	ret    

00007b76 <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    7b76:	55                   	push   %ebp
    7b77:	89 e5                	mov    %esp,%ebp
    7b79:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7b7c:	8b 45 0c             	mov    0xc(%ebp),%eax
    7b7f:	8b 08                	mov    (%eax),%ecx
    7b81:	8b 45 08             	mov    0x8(%ebp),%eax
    7b84:	8b 10                	mov    (%eax),%edx
    7b86:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7b89:	51                   	push   %ecx
    7b8a:	52                   	push   %edx
    7b8b:	50                   	push   %eax
    7b8c:	e8 f0 ba ff ff       	call   3681 <ucvector_init>
    7b91:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    7b94:	ff 75 18             	pushl  0x18(%ebp)
    7b97:	ff 75 14             	pushl  0x14(%ebp)
    7b9a:	ff 75 10             	pushl  0x10(%ebp)
    7b9d:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7ba0:	50                   	push   %eax
    7ba1:	e8 36 fe ff ff       	call   79dc <lodepng_deflatev>
    7ba6:	83 c4 10             	add    $0x10,%esp
    7ba9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7bac:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7baf:	8b 45 08             	mov    0x8(%ebp),%eax
    7bb2:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7bb4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7bb7:	8b 45 0c             	mov    0xc(%ebp),%eax
    7bba:	89 10                	mov    %edx,(%eax)
  return error;
    7bbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7bbf:	c9                   	leave  
    7bc0:	c3                   	ret    

00007bc1 <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    7bc1:	55                   	push   %ebp
    7bc2:	89 e5                	mov    %esp,%ebp
    7bc4:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    7bc7:	8b 45 18             	mov    0x18(%ebp),%eax
    7bca:	8b 40 1c             	mov    0x1c(%eax),%eax
    7bcd:	85 c0                	test   %eax,%eax
    7bcf:	74 34                	je     7c05 <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    7bd1:	8b 45 18             	mov    0x18(%ebp),%eax
    7bd4:	8b 40 1c             	mov    0x1c(%eax),%eax
    7bd7:	83 ec 0c             	sub    $0xc,%esp
    7bda:	ff 75 18             	pushl  0x18(%ebp)
    7bdd:	ff 75 14             	pushl  0x14(%ebp)
    7be0:	ff 75 10             	pushl  0x10(%ebp)
    7be3:	ff 75 0c             	pushl  0xc(%ebp)
    7be6:	ff 75 08             	pushl  0x8(%ebp)
    7be9:	ff d0                	call   *%eax
    7beb:	83 c4 20             	add    $0x20,%esp
    7bee:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    7bf1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7bf5:	74 07                	je     7bfe <deflate+0x3d>
    7bf7:	b8 6f 00 00 00       	mov    $0x6f,%eax
    7bfc:	eb 21                	jmp    7c1f <deflate+0x5e>
    7bfe:	b8 00 00 00 00       	mov    $0x0,%eax
    7c03:	eb 1a                	jmp    7c1f <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    7c05:	83 ec 0c             	sub    $0xc,%esp
    7c08:	ff 75 18             	pushl  0x18(%ebp)
    7c0b:	ff 75 14             	pushl  0x14(%ebp)
    7c0e:	ff 75 10             	pushl  0x10(%ebp)
    7c11:	ff 75 0c             	pushl  0xc(%ebp)
    7c14:	ff 75 08             	pushl  0x8(%ebp)
    7c17:	e8 5a ff ff ff       	call   7b76 <lodepng_deflate>
    7c1c:	83 c4 20             	add    $0x20,%esp
  }
}
    7c1f:	c9                   	leave  
    7c20:	c3                   	ret    

00007c21 <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    7c21:	55                   	push   %ebp
    7c22:	89 e5                	mov    %esp,%ebp
    7c24:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    7c27:	8b 45 08             	mov    0x8(%ebp),%eax
    7c2a:	0f b7 c0             	movzwl %ax,%eax
    7c2d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    7c30:	8b 45 08             	mov    0x8(%ebp),%eax
    7c33:	c1 e8 10             	shr    $0x10,%eax
    7c36:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    7c39:	e9 82 00 00 00       	jmp    7cc0 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    7c3e:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    7c43:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    7c4a:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    7c4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    7c51:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7c54:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    7c57:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7c5e:	eb 1c                	jmp    7c7c <update_adler32+0x5b>
      s1 += (*data++);
    7c60:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c63:	8d 50 01             	lea    0x1(%eax),%edx
    7c66:	89 55 0c             	mov    %edx,0xc(%ebp)
    7c69:	0f b6 00             	movzbl (%eax),%eax
    7c6c:	0f b6 c0             	movzbl %al,%eax
    7c6f:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    7c72:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7c75:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    7c78:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7c7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7c7f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7c82:	75 dc                	jne    7c60 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    7c84:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7c87:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7c8c:	89 c8                	mov    %ecx,%eax
    7c8e:	f7 e2                	mul    %edx
    7c90:	89 d0                	mov    %edx,%eax
    7c92:	c1 e8 0f             	shr    $0xf,%eax
    7c95:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7c9b:	29 c1                	sub    %eax,%ecx
    7c9d:	89 c8                	mov    %ecx,%eax
    7c9f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    7ca2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7ca5:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7caa:	89 c8                	mov    %ecx,%eax
    7cac:	f7 e2                	mul    %edx
    7cae:	89 d0                	mov    %edx,%eax
    7cb0:	c1 e8 0f             	shr    $0xf,%eax
    7cb3:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7cb9:	29 c1                	sub    %eax,%ecx
    7cbb:	89 c8                	mov    %ecx,%eax
    7cbd:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    7cc0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7cc4:	0f 85 74 ff ff ff    	jne    7c3e <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    7cca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7ccd:	c1 e0 10             	shl    $0x10,%eax
    7cd0:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    7cd3:	c9                   	leave  
    7cd4:	c3                   	ret    

00007cd5 <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    7cd5:	55                   	push   %ebp
    7cd6:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    7cd8:	ff 75 0c             	pushl  0xc(%ebp)
    7cdb:	ff 75 08             	pushl  0x8(%ebp)
    7cde:	6a 01                	push   $0x1
    7ce0:	e8 3c ff ff ff       	call   7c21 <update_adler32>
    7ce5:	83 c4 0c             	add    $0xc,%esp
}
    7ce8:	c9                   	leave  
    7ce9:	c3                   	ret    

00007cea <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    7cea:	55                   	push   %ebp
    7ceb:	89 e5                	mov    %esp,%ebp
    7ced:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    7cf0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    7cf7:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    7cfb:	7f 0a                	jg     7d07 <lodepng_zlib_decompressv+0x1d>
    7cfd:	b8 35 00 00 00       	mov    $0x35,%eax
    7d02:	e9 27 01 00 00       	jmp    7e2e <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    7d07:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d0a:	0f b6 00             	movzbl (%eax),%eax
    7d0d:	0f b6 c0             	movzbl %al,%eax
    7d10:	c1 e0 08             	shl    $0x8,%eax
    7d13:	89 c2                	mov    %eax,%edx
    7d15:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d18:	83 c0 01             	add    $0x1,%eax
    7d1b:	0f b6 00             	movzbl (%eax),%eax
    7d1e:	0f b6 c0             	movzbl %al,%eax
    7d21:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    7d24:	ba 43 08 21 84       	mov    $0x84210843,%edx
    7d29:	89 c8                	mov    %ecx,%eax
    7d2b:	f7 ea                	imul   %edx
    7d2d:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    7d30:	c1 f8 04             	sar    $0x4,%eax
    7d33:	89 c2                	mov    %eax,%edx
    7d35:	89 c8                	mov    %ecx,%eax
    7d37:	c1 f8 1f             	sar    $0x1f,%eax
    7d3a:	29 c2                	sub    %eax,%edx
    7d3c:	89 d0                	mov    %edx,%eax
    7d3e:	89 c2                	mov    %eax,%edx
    7d40:	c1 e2 05             	shl    $0x5,%edx
    7d43:	29 c2                	sub    %eax,%edx
    7d45:	89 c8                	mov    %ecx,%eax
    7d47:	29 d0                	sub    %edx,%eax
    7d49:	85 c0                	test   %eax,%eax
    7d4b:	74 0a                	je     7d57 <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    7d4d:	b8 18 00 00 00       	mov    $0x18,%eax
    7d52:	e9 d7 00 00 00       	jmp    7e2e <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    7d57:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d5a:	0f b6 00             	movzbl (%eax),%eax
    7d5d:	0f b6 c0             	movzbl %al,%eax
    7d60:	83 e0 0f             	and    $0xf,%eax
    7d63:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    7d66:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d69:	0f b6 00             	movzbl (%eax),%eax
    7d6c:	c0 e8 04             	shr    $0x4,%al
    7d6f:	0f b6 c0             	movzbl %al,%eax
    7d72:	83 e0 0f             	and    $0xf,%eax
    7d75:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    7d78:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d7b:	83 c0 01             	add    $0x1,%eax
    7d7e:	0f b6 00             	movzbl (%eax),%eax
    7d81:	c0 e8 05             	shr    $0x5,%al
    7d84:	0f b6 c0             	movzbl %al,%eax
    7d87:	83 e0 01             	and    $0x1,%eax
    7d8a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    7d8d:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    7d91:	75 06                	jne    7d99 <lodepng_zlib_decompressv+0xaf>
    7d93:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    7d97:	76 0a                	jbe    7da3 <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    7d99:	b8 19 00 00 00       	mov    $0x19,%eax
    7d9e:	e9 8b 00 00 00       	jmp    7e2e <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    7da3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7da7:	74 07                	je     7db0 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    7da9:	b8 1a 00 00 00       	mov    $0x1a,%eax
    7dae:	eb 7e                	jmp    7e2e <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    7db0:	8b 45 10             	mov    0x10(%ebp),%eax
    7db3:	8d 50 fe             	lea    -0x2(%eax),%edx
    7db6:	8b 45 0c             	mov    0xc(%ebp),%eax
    7db9:	83 c0 02             	add    $0x2,%eax
    7dbc:	ff 75 14             	pushl  0x14(%ebp)
    7dbf:	52                   	push   %edx
    7dc0:	50                   	push   %eax
    7dc1:	ff 75 08             	pushl  0x8(%ebp)
    7dc4:	e8 09 e3 ff ff       	call   60d2 <inflatev>
    7dc9:	83 c4 10             	add    $0x10,%esp
    7dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    7dcf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7dd3:	74 05                	je     7dda <lodepng_zlib_decompressv+0xf0>
    7dd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7dd8:	eb 54                	jmp    7e2e <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    7dda:	8b 45 14             	mov    0x14(%ebp),%eax
    7ddd:	8b 00                	mov    (%eax),%eax
    7ddf:	85 c0                	test   %eax,%eax
    7de1:	75 46                	jne    7e29 <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    7de3:	8b 45 10             	mov    0x10(%ebp),%eax
    7de6:	8d 50 fc             	lea    -0x4(%eax),%edx
    7de9:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dec:	01 d0                	add    %edx,%eax
    7dee:	83 ec 0c             	sub    $0xc,%esp
    7df1:	50                   	push   %eax
    7df2:	e8 47 b9 ff ff       	call   373e <lodepng_read32bitInt>
    7df7:	83 c4 10             	add    $0x10,%esp
    7dfa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    7dfd:	8b 45 08             	mov    0x8(%ebp),%eax
    7e00:	8b 40 04             	mov    0x4(%eax),%eax
    7e03:	89 c2                	mov    %eax,%edx
    7e05:	8b 45 08             	mov    0x8(%ebp),%eax
    7e08:	8b 00                	mov    (%eax),%eax
    7e0a:	83 ec 08             	sub    $0x8,%esp
    7e0d:	52                   	push   %edx
    7e0e:	50                   	push   %eax
    7e0f:	e8 c1 fe ff ff       	call   7cd5 <adler32>
    7e14:	83 c4 10             	add    $0x10,%esp
    7e17:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    7e1a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7e1d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7e20:	74 07                	je     7e29 <lodepng_zlib_decompressv+0x13f>
    7e22:	b8 3a 00 00 00       	mov    $0x3a,%eax
    7e27:	eb 05                	jmp    7e2e <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    7e29:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7e2e:	c9                   	leave  
    7e2f:	c3                   	ret    

00007e30 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    7e30:	55                   	push   %ebp
    7e31:	89 e5                	mov    %esp,%ebp
    7e33:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7e36:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e39:	8b 08                	mov    (%eax),%ecx
    7e3b:	8b 45 08             	mov    0x8(%ebp),%eax
    7e3e:	8b 10                	mov    (%eax),%edx
    7e40:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e43:	51                   	push   %ecx
    7e44:	52                   	push   %edx
    7e45:	50                   	push   %eax
    7e46:	e8 36 b8 ff ff       	call   3681 <ucvector_init>
    7e4b:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7e4e:	ff 75 18             	pushl  0x18(%ebp)
    7e51:	ff 75 14             	pushl  0x14(%ebp)
    7e54:	ff 75 10             	pushl  0x10(%ebp)
    7e57:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e5a:	50                   	push   %eax
    7e5b:	e8 8a fe ff ff       	call   7cea <lodepng_zlib_decompressv>
    7e60:	83 c4 10             	add    $0x10,%esp
    7e63:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7e66:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7e69:	8b 45 08             	mov    0x8(%ebp),%eax
    7e6c:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7e6e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7e71:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e74:	89 10                	mov    %edx,(%eax)
  return error;
    7e76:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7e79:	c9                   	leave  
    7e7a:	c3                   	ret    

00007e7b <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    7e7b:	55                   	push   %ebp
    7e7c:	89 e5                	mov    %esp,%ebp
    7e7e:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    7e81:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e84:	8b 40 0c             	mov    0xc(%eax),%eax
    7e87:	85 c0                	test   %eax,%eax
    7e89:	74 57                	je     7ee2 <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    7e8b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e8e:	8b 40 0c             	mov    0xc(%eax),%eax
    7e91:	83 ec 0c             	sub    $0xc,%esp
    7e94:	ff 75 1c             	pushl  0x1c(%ebp)
    7e97:	ff 75 18             	pushl  0x18(%ebp)
    7e9a:	ff 75 14             	pushl  0x14(%ebp)
    7e9d:	ff 75 0c             	pushl  0xc(%ebp)
    7ea0:	ff 75 08             	pushl  0x8(%ebp)
    7ea3:	ff d0                	call   *%eax
    7ea5:	83 c4 20             	add    $0x20,%esp
    7ea8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    7eab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7eaf:	0f 84 98 00 00 00    	je     7f4d <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    7eb5:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    7ebc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7ebf:	8b 40 08             	mov    0x8(%eax),%eax
    7ec2:	85 c0                	test   %eax,%eax
    7ec4:	0f 84 83 00 00 00    	je     7f4d <zlib_decompress+0xd2>
    7eca:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ecd:	8b 10                	mov    (%eax),%edx
    7ecf:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7ed2:	8b 40 08             	mov    0x8(%eax),%eax
    7ed5:	39 c2                	cmp    %eax,%edx
    7ed7:	7e 74                	jle    7f4d <zlib_decompress+0xd2>
    7ed9:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    7ee0:	eb 6b                	jmp    7f4d <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    7ee2:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ee5:	8b 08                	mov    (%eax),%ecx
    7ee7:	8b 45 08             	mov    0x8(%ebp),%eax
    7eea:	8b 10                	mov    (%eax),%edx
    7eec:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7eef:	83 ec 04             	sub    $0x4,%esp
    7ef2:	51                   	push   %ecx
    7ef3:	52                   	push   %edx
    7ef4:	50                   	push   %eax
    7ef5:	e8 87 b7 ff ff       	call   3681 <ucvector_init>
    7efa:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    7efd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7f01:	74 22                	je     7f25 <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    7f03:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f06:	8b 10                	mov    (%eax),%edx
    7f08:	8b 45 10             	mov    0x10(%ebp),%eax
    7f0b:	01 d0                	add    %edx,%eax
    7f0d:	83 ec 08             	sub    $0x8,%esp
    7f10:	50                   	push   %eax
    7f11:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7f14:	50                   	push   %eax
    7f15:	e8 00 b7 ff ff       	call   361a <ucvector_resize>
    7f1a:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    7f1d:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f20:	8b 00                	mov    (%eax),%eax
    7f22:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7f25:	ff 75 1c             	pushl  0x1c(%ebp)
    7f28:	ff 75 18             	pushl  0x18(%ebp)
    7f2b:	ff 75 14             	pushl  0x14(%ebp)
    7f2e:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7f31:	50                   	push   %eax
    7f32:	e8 b3 fd ff ff       	call   7cea <lodepng_zlib_decompressv>
    7f37:	83 c4 10             	add    $0x10,%esp
    7f3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    7f3d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7f40:	8b 45 08             	mov    0x8(%ebp),%eax
    7f43:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    7f45:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7f48:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f4b:	89 10                	mov    %edx,(%eax)
  }
  return error;
    7f4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7f50:	c9                   	leave  
    7f51:	c3                   	ret    

00007f52 <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    7f52:	55                   	push   %ebp
    7f53:	89 e5                	mov    %esp,%ebp
    7f55:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    7f58:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    7f5f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    7f66:	83 ec 0c             	sub    $0xc,%esp
    7f69:	ff 75 18             	pushl  0x18(%ebp)
    7f6c:	ff 75 14             	pushl  0x14(%ebp)
    7f6f:	ff 75 10             	pushl  0x10(%ebp)
    7f72:	8d 45 d0             	lea    -0x30(%ebp),%eax
    7f75:	50                   	push   %eax
    7f76:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7f79:	50                   	push   %eax
    7f7a:	e8 42 fc ff ff       	call   7bc1 <deflate>
    7f7f:	83 c4 20             	add    $0x20,%esp
    7f82:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    7f85:	8b 45 08             	mov    0x8(%ebp),%eax
    7f88:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    7f8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f91:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    7f97:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7f9b:	75 33                	jne    7fd0 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    7f9d:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7fa0:	8d 50 06             	lea    0x6(%eax),%edx
    7fa3:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fa6:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    7fa8:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fab:	8b 00                	mov    (%eax),%eax
    7fad:	83 ec 0c             	sub    $0xc,%esp
    7fb0:	50                   	push   %eax
    7fb1:	e8 0a b4 ff ff       	call   33c0 <lodepng_malloc>
    7fb6:	83 c4 10             	add    $0x10,%esp
    7fb9:	89 c2                	mov    %eax,%edx
    7fbb:	8b 45 08             	mov    0x8(%ebp),%eax
    7fbe:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    7fc0:	8b 45 08             	mov    0x8(%ebp),%eax
    7fc3:	8b 00                	mov    (%eax),%eax
    7fc5:	85 c0                	test   %eax,%eax
    7fc7:	75 07                	jne    7fd0 <lodepng_zlib_compress+0x7e>
    7fc9:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    7fd0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7fd4:	0f 85 e2 00 00 00    	jne    80bc <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    7fda:	8b 45 14             	mov    0x14(%ebp),%eax
    7fdd:	83 ec 08             	sub    $0x8,%esp
    7fe0:	50                   	push   %eax
    7fe1:	ff 75 10             	pushl  0x10(%ebp)
    7fe4:	e8 ec fc ff ff       	call   7cd5 <adler32>
    7fe9:	83 c4 10             	add    $0x10,%esp
    7fec:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    7fef:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    7ff6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    7ffd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    8004:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8007:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    800e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8011:	01 d0                	add    %edx,%eax
    8013:	8d 14 00             	lea    (%eax,%eax,1),%edx
    8016:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8019:	01 d0                	add    %edx,%eax
    801b:	c1 e0 05             	shl    $0x5,%eax
    801e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    8021:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    8024:	ba 85 10 42 08       	mov    $0x8421085,%edx
    8029:	89 c8                	mov    %ecx,%eax
    802b:	f7 e2                	mul    %edx
    802d:	89 c8                	mov    %ecx,%eax
    802f:	29 d0                	sub    %edx,%eax
    8031:	d1 e8                	shr    %eax
    8033:	01 d0                	add    %edx,%eax
    8035:	c1 e8 04             	shr    $0x4,%eax
    8038:	89 c2                	mov    %eax,%edx
    803a:	c1 e2 05             	shl    $0x5,%edx
    803d:	29 c2                	sub    %eax,%edx
    803f:	89 c8                	mov    %ecx,%eax
    8041:	29 d0                	sub    %edx,%eax
    8043:	ba 1f 00 00 00       	mov    $0x1f,%edx
    8048:	29 c2                	sub    %eax,%edx
    804a:	89 d0                	mov    %edx,%eax
    804c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    804f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8052:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    8055:	8b 45 08             	mov    0x8(%ebp),%eax
    8058:	8b 00                	mov    (%eax),%eax
    805a:	8b 55 dc             	mov    -0x24(%ebp),%edx
    805d:	c1 ea 08             	shr    $0x8,%edx
    8060:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    8062:	8b 45 08             	mov    0x8(%ebp),%eax
    8065:	8b 00                	mov    (%eax),%eax
    8067:	83 c0 01             	add    $0x1,%eax
    806a:	8b 55 dc             	mov    -0x24(%ebp),%edx
    806d:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    806f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8076:	eb 1e                	jmp    8096 <lodepng_zlib_compress+0x144>
    8078:	8b 45 08             	mov    0x8(%ebp),%eax
    807b:	8b 00                	mov    (%eax),%eax
    807d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8080:	83 c2 02             	add    $0x2,%edx
    8083:	01 c2                	add    %eax,%edx
    8085:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    8088:	8b 45 f4             	mov    -0xc(%ebp),%eax
    808b:	01 c8                	add    %ecx,%eax
    808d:	0f b6 00             	movzbl (%eax),%eax
    8090:	88 02                	mov    %al,(%edx)
    8092:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8096:	8b 45 d0             	mov    -0x30(%ebp),%eax
    8099:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    809c:	75 da                	jne    8078 <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    809e:	8b 45 08             	mov    0x8(%ebp),%eax
    80a1:	8b 10                	mov    (%eax),%edx
    80a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    80a6:	8b 00                	mov    (%eax),%eax
    80a8:	83 e8 04             	sub    $0x4,%eax
    80ab:	01 d0                	add    %edx,%eax
    80ad:	83 ec 08             	sub    $0x8,%esp
    80b0:	ff 75 ec             	pushl  -0x14(%ebp)
    80b3:	50                   	push   %eax
    80b4:	e8 c8 b6 ff ff       	call   3781 <lodepng_set32bitInt>
    80b9:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    80bc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    80bf:	83 ec 0c             	sub    $0xc,%esp
    80c2:	50                   	push   %eax
    80c3:	e8 19 b3 ff ff       	call   33e1 <lodepng_free>
    80c8:	83 c4 10             	add    $0x10,%esp
  return error;
    80cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    80ce:	c9                   	leave  
    80cf:	c3                   	ret    

000080d0 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    80d0:	55                   	push   %ebp
    80d1:	89 e5                	mov    %esp,%ebp
    80d3:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    80d6:	8b 45 18             	mov    0x18(%ebp),%eax
    80d9:	8b 40 18             	mov    0x18(%eax),%eax
    80dc:	85 c0                	test   %eax,%eax
    80de:	74 34                	je     8114 <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    80e0:	8b 45 18             	mov    0x18(%ebp),%eax
    80e3:	8b 40 18             	mov    0x18(%eax),%eax
    80e6:	83 ec 0c             	sub    $0xc,%esp
    80e9:	ff 75 18             	pushl  0x18(%ebp)
    80ec:	ff 75 14             	pushl  0x14(%ebp)
    80ef:	ff 75 10             	pushl  0x10(%ebp)
    80f2:	ff 75 0c             	pushl  0xc(%ebp)
    80f5:	ff 75 08             	pushl  0x8(%ebp)
    80f8:	ff d0                	call   *%eax
    80fa:	83 c4 20             	add    $0x20,%esp
    80fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    8100:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8104:	74 07                	je     810d <zlib_compress+0x3d>
    8106:	b8 6f 00 00 00       	mov    $0x6f,%eax
    810b:	eb 21                	jmp    812e <zlib_compress+0x5e>
    810d:	b8 00 00 00 00       	mov    $0x0,%eax
    8112:	eb 1a                	jmp    812e <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    8114:	83 ec 0c             	sub    $0xc,%esp
    8117:	ff 75 18             	pushl  0x18(%ebp)
    811a:	ff 75 14             	pushl  0x14(%ebp)
    811d:	ff 75 10             	pushl  0x10(%ebp)
    8120:	ff 75 0c             	pushl  0xc(%ebp)
    8123:	ff 75 08             	pushl  0x8(%ebp)
    8126:	e8 27 fe ff ff       	call   7f52 <lodepng_zlib_compress>
    812b:	83 c4 20             	add    $0x20,%esp
  }
}
    812e:	c9                   	leave  
    812f:	c3                   	ret    

00008130 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    8130:	55                   	push   %ebp
    8131:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    8133:	8b 45 08             	mov    0x8(%ebp),%eax
    8136:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    813c:	8b 45 08             	mov    0x8(%ebp),%eax
    813f:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    8146:	8b 45 08             	mov    0x8(%ebp),%eax
    8149:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    8150:	8b 45 08             	mov    0x8(%ebp),%eax
    8153:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    815a:	8b 45 08             	mov    0x8(%ebp),%eax
    815d:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    8164:	8b 45 08             	mov    0x8(%ebp),%eax
    8167:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    816e:	8b 45 08             	mov    0x8(%ebp),%eax
    8171:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    8178:	8b 45 08             	mov    0x8(%ebp),%eax
    817b:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    8182:	8b 45 08             	mov    0x8(%ebp),%eax
    8185:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    818c:	90                   	nop
    818d:	5d                   	pop    %ebp
    818e:	c3                   	ret    

0000818f <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    818f:	55                   	push   %ebp
    8190:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    8192:	8b 45 08             	mov    0x8(%ebp),%eax
    8195:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    819b:	8b 45 08             	mov    0x8(%ebp),%eax
    819e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    81a5:	8b 45 08             	mov    0x8(%ebp),%eax
    81a8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    81af:	8b 45 08             	mov    0x8(%ebp),%eax
    81b2:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    81b9:	8b 45 08             	mov    0x8(%ebp),%eax
    81bc:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    81c3:	8b 45 08             	mov    0x8(%ebp),%eax
    81c6:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    81cd:	90                   	nop
    81ce:	5d                   	pop    %ebp
    81cf:	c3                   	ret    

000081d0 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    81d0:	55                   	push   %ebp
    81d1:	89 e5                	mov    %esp,%ebp
    81d3:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    81d6:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    81dd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    81e4:	eb 2a                	jmp    8210 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    81e6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    81e9:	8b 45 08             	mov    0x8(%ebp),%eax
    81ec:	01 d0                	add    %edx,%eax
    81ee:	0f b6 00             	movzbl (%eax),%eax
    81f1:	0f b6 c0             	movzbl %al,%eax
    81f4:	33 45 fc             	xor    -0x4(%ebp),%eax
    81f7:	0f b6 c0             	movzbl %al,%eax
    81fa:	8b 04 85 e0 e1 01 00 	mov    0x1e1e0(,%eax,4),%eax
    8201:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8204:	c1 ea 08             	shr    $0x8,%edx
    8207:	31 d0                	xor    %edx,%eax
    8209:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    820c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8210:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8213:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8216:	7c ce                	jl     81e6 <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    8218:	8b 45 fc             	mov    -0x4(%ebp),%eax
    821b:	f7 d0                	not    %eax
}
    821d:	c9                   	leave  
    821e:	c3                   	ret    

0000821f <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    821f:	55                   	push   %ebp
    8220:	89 e5                	mov    %esp,%ebp
    8222:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    8225:	8b 45 08             	mov    0x8(%ebp),%eax
    8228:	8b 00                	mov    (%eax),%eax
    822a:	c1 f8 03             	sar    $0x3,%eax
    822d:	89 c2                	mov    %eax,%edx
    822f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8232:	01 d0                	add    %edx,%eax
    8234:	0f b6 00             	movzbl (%eax),%eax
    8237:	0f b6 d0             	movzbl %al,%edx
    823a:	8b 45 08             	mov    0x8(%ebp),%eax
    823d:	8b 00                	mov    (%eax),%eax
    823f:	f7 d0                	not    %eax
    8241:	83 e0 07             	and    $0x7,%eax
    8244:	89 c1                	mov    %eax,%ecx
    8246:	d3 fa                	sar    %cl,%edx
    8248:	89 d0                	mov    %edx,%eax
    824a:	83 e0 01             	and    $0x1,%eax
    824d:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    8250:	8b 45 08             	mov    0x8(%ebp),%eax
    8253:	8b 00                	mov    (%eax),%eax
    8255:	8d 50 01             	lea    0x1(%eax),%edx
    8258:	8b 45 08             	mov    0x8(%ebp),%eax
    825b:	89 10                	mov    %edx,(%eax)
  return result;
    825d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    8261:	c9                   	leave  
    8262:	c3                   	ret    

00008263 <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    8263:	55                   	push   %ebp
    8264:	89 e5                	mov    %esp,%ebp
    8266:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    8269:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    8270:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8277:	eb 1b                	jmp    8294 <readBitsFromReversedStream+0x31>
    result <<= 1u;
    8279:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    827c:	ff 75 0c             	pushl  0xc(%ebp)
    827f:	ff 75 08             	pushl  0x8(%ebp)
    8282:	e8 98 ff ff ff       	call   821f <readBitFromReversedStream>
    8287:	83 c4 08             	add    $0x8,%esp
    828a:	0f b6 c0             	movzbl %al,%eax
    828d:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    8290:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8294:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8297:	3b 45 10             	cmp    0x10(%ebp),%eax
    829a:	7c dd                	jl     8279 <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    829c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    829f:	c9                   	leave  
    82a0:	c3                   	ret    

000082a1 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    82a1:	55                   	push   %ebp
    82a2:	89 e5                	mov    %esp,%ebp
    82a4:	56                   	push   %esi
    82a5:	53                   	push   %ebx
    82a6:	83 ec 04             	sub    $0x4,%esp
    82a9:	8b 45 10             	mov    0x10(%ebp),%eax
    82ac:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    82af:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    82b3:	75 3e                	jne    82f3 <setBitOfReversedStream+0x52>
    82b5:	8b 45 08             	mov    0x8(%ebp),%eax
    82b8:	8b 00                	mov    (%eax),%eax
    82ba:	c1 f8 03             	sar    $0x3,%eax
    82bd:	89 c2                	mov    %eax,%edx
    82bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    82c2:	01 c2                	add    %eax,%edx
    82c4:	8b 45 08             	mov    0x8(%ebp),%eax
    82c7:	8b 00                	mov    (%eax),%eax
    82c9:	c1 f8 03             	sar    $0x3,%eax
    82cc:	89 c1                	mov    %eax,%ecx
    82ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    82d1:	01 c8                	add    %ecx,%eax
    82d3:	0f b6 18             	movzbl (%eax),%ebx
    82d6:	8b 45 08             	mov    0x8(%ebp),%eax
    82d9:	8b 00                	mov    (%eax),%eax
    82db:	f7 d0                	not    %eax
    82dd:	83 e0 07             	and    $0x7,%eax
    82e0:	be 01 00 00 00       	mov    $0x1,%esi
    82e5:	89 c1                	mov    %eax,%ecx
    82e7:	d3 e6                	shl    %cl,%esi
    82e9:	89 f0                	mov    %esi,%eax
    82eb:	f7 d0                	not    %eax
    82ed:	21 d8                	and    %ebx,%eax
    82ef:	88 02                	mov    %al,(%edx)
    82f1:	eb 3a                	jmp    832d <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    82f3:	8b 45 08             	mov    0x8(%ebp),%eax
    82f6:	8b 00                	mov    (%eax),%eax
    82f8:	c1 f8 03             	sar    $0x3,%eax
    82fb:	89 c2                	mov    %eax,%edx
    82fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    8300:	01 c2                	add    %eax,%edx
    8302:	8b 45 08             	mov    0x8(%ebp),%eax
    8305:	8b 00                	mov    (%eax),%eax
    8307:	c1 f8 03             	sar    $0x3,%eax
    830a:	89 c1                	mov    %eax,%ecx
    830c:	8b 45 0c             	mov    0xc(%ebp),%eax
    830f:	01 c8                	add    %ecx,%eax
    8311:	0f b6 18             	movzbl (%eax),%ebx
    8314:	8b 45 08             	mov    0x8(%ebp),%eax
    8317:	8b 00                	mov    (%eax),%eax
    8319:	f7 d0                	not    %eax
    831b:	83 e0 07             	and    $0x7,%eax
    831e:	be 01 00 00 00       	mov    $0x1,%esi
    8323:	89 c1                	mov    %eax,%ecx
    8325:	d3 e6                	shl    %cl,%esi
    8327:	89 f0                	mov    %esi,%eax
    8329:	09 d8                	or     %ebx,%eax
    832b:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    832d:	8b 45 08             	mov    0x8(%ebp),%eax
    8330:	8b 00                	mov    (%eax),%eax
    8332:	8d 50 01             	lea    0x1(%eax),%edx
    8335:	8b 45 08             	mov    0x8(%ebp),%eax
    8338:	89 10                	mov    %edx,(%eax)
}
    833a:	90                   	nop
    833b:	83 c4 04             	add    $0x4,%esp
    833e:	5b                   	pop    %ebx
    833f:	5e                   	pop    %esi
    8340:	5d                   	pop    %ebp
    8341:	c3                   	ret    

00008342 <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    8342:	55                   	push   %ebp
    8343:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    8345:	ff 75 08             	pushl  0x8(%ebp)
    8348:	e8 f1 b3 ff ff       	call   373e <lodepng_read32bitInt>
    834d:	83 c4 04             	add    $0x4,%esp
}
    8350:	c9                   	leave  
    8351:	c3                   	ret    

00008352 <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    8352:	55                   	push   %ebp
    8353:	89 e5                	mov    %esp,%ebp
    8355:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    8358:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    835f:	eb 1c                	jmp    837d <lodepng_chunk_type+0x2b>
    8361:	8b 55 08             	mov    0x8(%ebp),%edx
    8364:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8367:	01 d0                	add    %edx,%eax
    8369:	8b 55 fc             	mov    -0x4(%ebp),%edx
    836c:	8d 4a 04             	lea    0x4(%edx),%ecx
    836f:	8b 55 0c             	mov    0xc(%ebp),%edx
    8372:	01 ca                	add    %ecx,%edx
    8374:	0f b6 12             	movzbl (%edx),%edx
    8377:	88 10                	mov    %dl,(%eax)
    8379:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    837d:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    8381:	75 de                	jne    8361 <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    8383:	8b 45 08             	mov    0x8(%ebp),%eax
    8386:	83 c0 04             	add    $0x4,%eax
    8389:	c6 00 00             	movb   $0x0,(%eax)
}
    838c:	90                   	nop
    838d:	c9                   	leave  
    838e:	c3                   	ret    

0000838f <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    838f:	55                   	push   %ebp
    8390:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    8392:	ff 75 0c             	pushl  0xc(%ebp)
    8395:	e8 c2 b0 ff ff       	call   345c <lodepng_strlen>
    839a:	83 c4 04             	add    $0x4,%esp
    839d:	83 f8 04             	cmp    $0x4,%eax
    83a0:	74 07                	je     83a9 <lodepng_chunk_type_equals+0x1a>
    83a2:	b8 00 00 00 00       	mov    $0x0,%eax
    83a7:	eb 79                	jmp    8422 <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    83a9:	8b 45 08             	mov    0x8(%ebp),%eax
    83ac:	83 c0 04             	add    $0x4,%eax
    83af:	0f b6 00             	movzbl (%eax),%eax
    83b2:	0f b6 d0             	movzbl %al,%edx
    83b5:	8b 45 0c             	mov    0xc(%ebp),%eax
    83b8:	0f b6 00             	movzbl (%eax),%eax
    83bb:	0f be c0             	movsbl %al,%eax
    83be:	39 c2                	cmp    %eax,%edx
    83c0:	75 5b                	jne    841d <lodepng_chunk_type_equals+0x8e>
    83c2:	8b 45 08             	mov    0x8(%ebp),%eax
    83c5:	83 c0 05             	add    $0x5,%eax
    83c8:	0f b6 00             	movzbl (%eax),%eax
    83cb:	0f b6 d0             	movzbl %al,%edx
    83ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    83d1:	83 c0 01             	add    $0x1,%eax
    83d4:	0f b6 00             	movzbl (%eax),%eax
    83d7:	0f be c0             	movsbl %al,%eax
    83da:	39 c2                	cmp    %eax,%edx
    83dc:	75 3f                	jne    841d <lodepng_chunk_type_equals+0x8e>
    83de:	8b 45 08             	mov    0x8(%ebp),%eax
    83e1:	83 c0 06             	add    $0x6,%eax
    83e4:	0f b6 00             	movzbl (%eax),%eax
    83e7:	0f b6 d0             	movzbl %al,%edx
    83ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    83ed:	83 c0 02             	add    $0x2,%eax
    83f0:	0f b6 00             	movzbl (%eax),%eax
    83f3:	0f be c0             	movsbl %al,%eax
    83f6:	39 c2                	cmp    %eax,%edx
    83f8:	75 23                	jne    841d <lodepng_chunk_type_equals+0x8e>
    83fa:	8b 45 08             	mov    0x8(%ebp),%eax
    83fd:	83 c0 07             	add    $0x7,%eax
    8400:	0f b6 00             	movzbl (%eax),%eax
    8403:	0f b6 d0             	movzbl %al,%edx
    8406:	8b 45 0c             	mov    0xc(%ebp),%eax
    8409:	83 c0 03             	add    $0x3,%eax
    840c:	0f b6 00             	movzbl (%eax),%eax
    840f:	0f be c0             	movsbl %al,%eax
    8412:	39 c2                	cmp    %eax,%edx
    8414:	75 07                	jne    841d <lodepng_chunk_type_equals+0x8e>
    8416:	b8 01 00 00 00       	mov    $0x1,%eax
    841b:	eb 05                	jmp    8422 <lodepng_chunk_type_equals+0x93>
    841d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8422:	c9                   	leave  
    8423:	c3                   	ret    

00008424 <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    8424:	55                   	push   %ebp
    8425:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    8427:	8b 45 08             	mov    0x8(%ebp),%eax
    842a:	83 c0 04             	add    $0x4,%eax
    842d:	0f b6 00             	movzbl (%eax),%eax
    8430:	0f b6 c0             	movzbl %al,%eax
    8433:	83 e0 20             	and    $0x20,%eax
    8436:	85 c0                	test   %eax,%eax
    8438:	0f 95 c0             	setne  %al
}
    843b:	5d                   	pop    %ebp
    843c:	c3                   	ret    

0000843d <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    843d:	55                   	push   %ebp
    843e:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    8440:	8b 45 08             	mov    0x8(%ebp),%eax
    8443:	83 c0 06             	add    $0x6,%eax
    8446:	0f b6 00             	movzbl (%eax),%eax
    8449:	0f b6 c0             	movzbl %al,%eax
    844c:	83 e0 20             	and    $0x20,%eax
    844f:	85 c0                	test   %eax,%eax
    8451:	0f 95 c0             	setne  %al
}
    8454:	5d                   	pop    %ebp
    8455:	c3                   	ret    

00008456 <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    8456:	55                   	push   %ebp
    8457:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    8459:	8b 45 08             	mov    0x8(%ebp),%eax
    845c:	83 c0 07             	add    $0x7,%eax
    845f:	0f b6 00             	movzbl (%eax),%eax
    8462:	0f b6 c0             	movzbl %al,%eax
    8465:	83 e0 20             	and    $0x20,%eax
    8468:	85 c0                	test   %eax,%eax
    846a:	0f 95 c0             	setne  %al
}
    846d:	5d                   	pop    %ebp
    846e:	c3                   	ret    

0000846f <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    846f:	55                   	push   %ebp
    8470:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    8472:	8b 45 08             	mov    0x8(%ebp),%eax
    8475:	83 c0 08             	add    $0x8,%eax
}
    8478:	5d                   	pop    %ebp
    8479:	c3                   	ret    

0000847a <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    847a:	55                   	push   %ebp
    847b:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    847d:	8b 45 08             	mov    0x8(%ebp),%eax
    8480:	83 c0 08             	add    $0x8,%eax
}
    8483:	5d                   	pop    %ebp
    8484:	c3                   	ret    

00008485 <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    8485:	55                   	push   %ebp
    8486:	89 e5                	mov    %esp,%ebp
    8488:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    848b:	ff 75 08             	pushl  0x8(%ebp)
    848e:	e8 af fe ff ff       	call   8342 <lodepng_chunk_length>
    8493:	83 c4 04             	add    $0x4,%esp
    8496:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    8499:	8b 45 fc             	mov    -0x4(%ebp),%eax
    849c:	8d 50 08             	lea    0x8(%eax),%edx
    849f:	8b 45 08             	mov    0x8(%ebp),%eax
    84a2:	01 d0                	add    %edx,%eax
    84a4:	50                   	push   %eax
    84a5:	e8 94 b2 ff ff       	call   373e <lodepng_read32bitInt>
    84aa:	83 c4 04             	add    $0x4,%esp
    84ad:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    84b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    84b3:	83 c0 04             	add    $0x4,%eax
    84b6:	89 c2                	mov    %eax,%edx
    84b8:	8b 45 08             	mov    0x8(%ebp),%eax
    84bb:	83 c0 04             	add    $0x4,%eax
    84be:	52                   	push   %edx
    84bf:	50                   	push   %eax
    84c0:	e8 0b fd ff ff       	call   81d0 <lodepng_crc32>
    84c5:	83 c4 08             	add    $0x8,%esp
    84c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    84cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    84ce:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    84d1:	74 07                	je     84da <lodepng_chunk_check_crc+0x55>
    84d3:	b8 01 00 00 00       	mov    $0x1,%eax
    84d8:	eb 05                	jmp    84df <lodepng_chunk_check_crc+0x5a>
  else return 0;
    84da:	b8 00 00 00 00       	mov    $0x0,%eax
}
    84df:	c9                   	leave  
    84e0:	c3                   	ret    

000084e1 <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    84e1:	55                   	push   %ebp
    84e2:	89 e5                	mov    %esp,%ebp
    84e4:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    84e7:	ff 75 08             	pushl  0x8(%ebp)
    84ea:	e8 53 fe ff ff       	call   8342 <lodepng_chunk_length>
    84ef:	83 c4 04             	add    $0x4,%esp
    84f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    84f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    84f8:	83 c0 04             	add    $0x4,%eax
    84fb:	89 c2                	mov    %eax,%edx
    84fd:	8b 45 08             	mov    0x8(%ebp),%eax
    8500:	83 c0 04             	add    $0x4,%eax
    8503:	52                   	push   %edx
    8504:	50                   	push   %eax
    8505:	e8 c6 fc ff ff       	call   81d0 <lodepng_crc32>
    850a:	83 c4 08             	add    $0x8,%esp
    850d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    8510:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8513:	8d 50 08             	lea    0x8(%eax),%edx
    8516:	8b 45 08             	mov    0x8(%ebp),%eax
    8519:	01 d0                	add    %edx,%eax
    851b:	ff 75 f8             	pushl  -0x8(%ebp)
    851e:	50                   	push   %eax
    851f:	e8 5d b2 ff ff       	call   3781 <lodepng_set32bitInt>
    8524:	83 c4 08             	add    $0x8,%esp
}
    8527:	90                   	nop
    8528:	c9                   	leave  
    8529:	c3                   	ret    

0000852a <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    852a:	55                   	push   %ebp
    852b:	89 e5                	mov    %esp,%ebp
    852d:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8530:	8b 45 08             	mov    0x8(%ebp),%eax
    8533:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8536:	73 0f                	jae    8547 <lodepng_chunk_next+0x1d>
    8538:	8b 55 0c             	mov    0xc(%ebp),%edx
    853b:	8b 45 08             	mov    0x8(%ebp),%eax
    853e:	29 c2                	sub    %eax,%edx
    8540:	89 d0                	mov    %edx,%eax
    8542:	83 f8 0b             	cmp    $0xb,%eax
    8545:	7f 08                	jg     854f <lodepng_chunk_next+0x25>
    8547:	8b 45 0c             	mov    0xc(%ebp),%eax
    854a:	e9 af 00 00 00       	jmp    85fe <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    854f:	8b 45 08             	mov    0x8(%ebp),%eax
    8552:	0f b6 00             	movzbl (%eax),%eax
    8555:	3c 89                	cmp    $0x89,%al
    8557:	75 63                	jne    85bc <lodepng_chunk_next+0x92>
    8559:	8b 45 08             	mov    0x8(%ebp),%eax
    855c:	83 c0 01             	add    $0x1,%eax
    855f:	0f b6 00             	movzbl (%eax),%eax
    8562:	3c 50                	cmp    $0x50,%al
    8564:	75 56                	jne    85bc <lodepng_chunk_next+0x92>
    8566:	8b 45 08             	mov    0x8(%ebp),%eax
    8569:	83 c0 02             	add    $0x2,%eax
    856c:	0f b6 00             	movzbl (%eax),%eax
    856f:	3c 4e                	cmp    $0x4e,%al
    8571:	75 49                	jne    85bc <lodepng_chunk_next+0x92>
    8573:	8b 45 08             	mov    0x8(%ebp),%eax
    8576:	83 c0 03             	add    $0x3,%eax
    8579:	0f b6 00             	movzbl (%eax),%eax
    857c:	3c 47                	cmp    $0x47,%al
    857e:	75 3c                	jne    85bc <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    8580:	8b 45 08             	mov    0x8(%ebp),%eax
    8583:	83 c0 04             	add    $0x4,%eax
    8586:	0f b6 00             	movzbl (%eax),%eax
    8589:	3c 0d                	cmp    $0xd,%al
    858b:	75 2f                	jne    85bc <lodepng_chunk_next+0x92>
    858d:	8b 45 08             	mov    0x8(%ebp),%eax
    8590:	83 c0 05             	add    $0x5,%eax
    8593:	0f b6 00             	movzbl (%eax),%eax
    8596:	3c 0a                	cmp    $0xa,%al
    8598:	75 22                	jne    85bc <lodepng_chunk_next+0x92>
    859a:	8b 45 08             	mov    0x8(%ebp),%eax
    859d:	83 c0 06             	add    $0x6,%eax
    85a0:	0f b6 00             	movzbl (%eax),%eax
    85a3:	3c 1a                	cmp    $0x1a,%al
    85a5:	75 15                	jne    85bc <lodepng_chunk_next+0x92>
    85a7:	8b 45 08             	mov    0x8(%ebp),%eax
    85aa:	83 c0 07             	add    $0x7,%eax
    85ad:	0f b6 00             	movzbl (%eax),%eax
    85b0:	3c 0a                	cmp    $0xa,%al
    85b2:	75 08                	jne    85bc <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    85b4:	8b 45 08             	mov    0x8(%ebp),%eax
    85b7:	83 c0 08             	add    $0x8,%eax
    85ba:	eb 42                	jmp    85fe <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    85bc:	ff 75 08             	pushl  0x8(%ebp)
    85bf:	e8 7e fd ff ff       	call   8342 <lodepng_chunk_length>
    85c4:	83 c4 04             	add    $0x4,%esp
    85c7:	89 c2                	mov    %eax,%edx
    85c9:	8d 45 f8             	lea    -0x8(%ebp),%eax
    85cc:	50                   	push   %eax
    85cd:	6a 0c                	push   $0xc
    85cf:	52                   	push   %edx
    85d0:	e8 af ae ff ff       	call   3484 <lodepng_addofl>
    85d5:	83 c4 0c             	add    $0xc,%esp
    85d8:	85 c0                	test   %eax,%eax
    85da:	74 05                	je     85e1 <lodepng_chunk_next+0xb7>
    85dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    85df:	eb 1d                	jmp    85fe <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    85e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    85e4:	89 c2                	mov    %eax,%edx
    85e6:	8b 45 08             	mov    0x8(%ebp),%eax
    85e9:	01 d0                	add    %edx,%eax
    85eb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    85ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
    85f1:	3b 45 08             	cmp    0x8(%ebp),%eax
    85f4:	73 05                	jae    85fb <lodepng_chunk_next+0xd1>
    85f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    85f9:	eb 03                	jmp    85fe <lodepng_chunk_next+0xd4>
    return result;
    85fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    85fe:	c9                   	leave  
    85ff:	c3                   	ret    

00008600 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    8600:	55                   	push   %ebp
    8601:	89 e5                	mov    %esp,%ebp
    8603:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8606:	8b 45 08             	mov    0x8(%ebp),%eax
    8609:	3b 45 0c             	cmp    0xc(%ebp),%eax
    860c:	73 0f                	jae    861d <lodepng_chunk_next_const+0x1d>
    860e:	8b 55 0c             	mov    0xc(%ebp),%edx
    8611:	8b 45 08             	mov    0x8(%ebp),%eax
    8614:	29 c2                	sub    %eax,%edx
    8616:	89 d0                	mov    %edx,%eax
    8618:	83 f8 0b             	cmp    $0xb,%eax
    861b:	7f 08                	jg     8625 <lodepng_chunk_next_const+0x25>
    861d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8620:	e9 af 00 00 00       	jmp    86d4 <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8625:	8b 45 08             	mov    0x8(%ebp),%eax
    8628:	0f b6 00             	movzbl (%eax),%eax
    862b:	3c 89                	cmp    $0x89,%al
    862d:	75 63                	jne    8692 <lodepng_chunk_next_const+0x92>
    862f:	8b 45 08             	mov    0x8(%ebp),%eax
    8632:	83 c0 01             	add    $0x1,%eax
    8635:	0f b6 00             	movzbl (%eax),%eax
    8638:	3c 50                	cmp    $0x50,%al
    863a:	75 56                	jne    8692 <lodepng_chunk_next_const+0x92>
    863c:	8b 45 08             	mov    0x8(%ebp),%eax
    863f:	83 c0 02             	add    $0x2,%eax
    8642:	0f b6 00             	movzbl (%eax),%eax
    8645:	3c 4e                	cmp    $0x4e,%al
    8647:	75 49                	jne    8692 <lodepng_chunk_next_const+0x92>
    8649:	8b 45 08             	mov    0x8(%ebp),%eax
    864c:	83 c0 03             	add    $0x3,%eax
    864f:	0f b6 00             	movzbl (%eax),%eax
    8652:	3c 47                	cmp    $0x47,%al
    8654:	75 3c                	jne    8692 <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    8656:	8b 45 08             	mov    0x8(%ebp),%eax
    8659:	83 c0 04             	add    $0x4,%eax
    865c:	0f b6 00             	movzbl (%eax),%eax
    865f:	3c 0d                	cmp    $0xd,%al
    8661:	75 2f                	jne    8692 <lodepng_chunk_next_const+0x92>
    8663:	8b 45 08             	mov    0x8(%ebp),%eax
    8666:	83 c0 05             	add    $0x5,%eax
    8669:	0f b6 00             	movzbl (%eax),%eax
    866c:	3c 0a                	cmp    $0xa,%al
    866e:	75 22                	jne    8692 <lodepng_chunk_next_const+0x92>
    8670:	8b 45 08             	mov    0x8(%ebp),%eax
    8673:	83 c0 06             	add    $0x6,%eax
    8676:	0f b6 00             	movzbl (%eax),%eax
    8679:	3c 1a                	cmp    $0x1a,%al
    867b:	75 15                	jne    8692 <lodepng_chunk_next_const+0x92>
    867d:	8b 45 08             	mov    0x8(%ebp),%eax
    8680:	83 c0 07             	add    $0x7,%eax
    8683:	0f b6 00             	movzbl (%eax),%eax
    8686:	3c 0a                	cmp    $0xa,%al
    8688:	75 08                	jne    8692 <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    868a:	8b 45 08             	mov    0x8(%ebp),%eax
    868d:	83 c0 08             	add    $0x8,%eax
    8690:	eb 42                	jmp    86d4 <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    8692:	ff 75 08             	pushl  0x8(%ebp)
    8695:	e8 a8 fc ff ff       	call   8342 <lodepng_chunk_length>
    869a:	83 c4 04             	add    $0x4,%esp
    869d:	89 c2                	mov    %eax,%edx
    869f:	8d 45 f8             	lea    -0x8(%ebp),%eax
    86a2:	50                   	push   %eax
    86a3:	6a 0c                	push   $0xc
    86a5:	52                   	push   %edx
    86a6:	e8 d9 ad ff ff       	call   3484 <lodepng_addofl>
    86ab:	83 c4 0c             	add    $0xc,%esp
    86ae:	85 c0                	test   %eax,%eax
    86b0:	74 05                	je     86b7 <lodepng_chunk_next_const+0xb7>
    86b2:	8b 45 0c             	mov    0xc(%ebp),%eax
    86b5:	eb 1d                	jmp    86d4 <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    86b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    86ba:	89 c2                	mov    %eax,%edx
    86bc:	8b 45 08             	mov    0x8(%ebp),%eax
    86bf:	01 d0                	add    %edx,%eax
    86c1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    86c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    86c7:	3b 45 08             	cmp    0x8(%ebp),%eax
    86ca:	73 05                	jae    86d1 <lodepng_chunk_next_const+0xd1>
    86cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    86cf:	eb 03                	jmp    86d4 <lodepng_chunk_next_const+0xd4>
    return result;
    86d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    86d4:	c9                   	leave  
    86d5:	c3                   	ret    

000086d6 <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    86d6:	55                   	push   %ebp
    86d7:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    86d9:	8b 45 08             	mov    0x8(%ebp),%eax
    86dc:	3b 45 0c             	cmp    0xc(%ebp),%eax
    86df:	73 0f                	jae    86f0 <lodepng_chunk_find+0x1a>
    86e1:	8b 55 0c             	mov    0xc(%ebp),%edx
    86e4:	8b 45 08             	mov    0x8(%ebp),%eax
    86e7:	29 c2                	sub    %eax,%edx
    86e9:	89 d0                	mov    %edx,%eax
    86eb:	83 f8 0b             	cmp    $0xb,%eax
    86ee:	7f 07                	jg     86f7 <lodepng_chunk_find+0x21>
    86f0:	b8 00 00 00 00       	mov    $0x0,%eax
    86f5:	eb 2a                	jmp    8721 <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    86f7:	ff 75 10             	pushl  0x10(%ebp)
    86fa:	ff 75 08             	pushl  0x8(%ebp)
    86fd:	e8 8d fc ff ff       	call   838f <lodepng_chunk_type_equals>
    8702:	83 c4 08             	add    $0x8,%esp
    8705:	84 c0                	test   %al,%al
    8707:	74 05                	je     870e <lodepng_chunk_find+0x38>
    8709:	8b 45 08             	mov    0x8(%ebp),%eax
    870c:	eb 13                	jmp    8721 <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    870e:	ff 75 0c             	pushl  0xc(%ebp)
    8711:	ff 75 08             	pushl  0x8(%ebp)
    8714:	e8 11 fe ff ff       	call   852a <lodepng_chunk_next>
    8719:	83 c4 08             	add    $0x8,%esp
    871c:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    871f:	eb b8                	jmp    86d9 <lodepng_chunk_find+0x3>
}
    8721:	c9                   	leave  
    8722:	c3                   	ret    

00008723 <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    8723:	55                   	push   %ebp
    8724:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    8726:	8b 45 08             	mov    0x8(%ebp),%eax
    8729:	3b 45 0c             	cmp    0xc(%ebp),%eax
    872c:	73 0f                	jae    873d <lodepng_chunk_find_const+0x1a>
    872e:	8b 55 0c             	mov    0xc(%ebp),%edx
    8731:	8b 45 08             	mov    0x8(%ebp),%eax
    8734:	29 c2                	sub    %eax,%edx
    8736:	89 d0                	mov    %edx,%eax
    8738:	83 f8 0b             	cmp    $0xb,%eax
    873b:	7f 07                	jg     8744 <lodepng_chunk_find_const+0x21>
    873d:	b8 00 00 00 00       	mov    $0x0,%eax
    8742:	eb 2a                	jmp    876e <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    8744:	ff 75 10             	pushl  0x10(%ebp)
    8747:	ff 75 08             	pushl  0x8(%ebp)
    874a:	e8 40 fc ff ff       	call   838f <lodepng_chunk_type_equals>
    874f:	83 c4 08             	add    $0x8,%esp
    8752:	84 c0                	test   %al,%al
    8754:	74 05                	je     875b <lodepng_chunk_find_const+0x38>
    8756:	8b 45 08             	mov    0x8(%ebp),%eax
    8759:	eb 13                	jmp    876e <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    875b:	ff 75 0c             	pushl  0xc(%ebp)
    875e:	ff 75 08             	pushl  0x8(%ebp)
    8761:	e8 9a fe ff ff       	call   8600 <lodepng_chunk_next_const>
    8766:	83 c4 08             	add    $0x8,%esp
    8769:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    876c:	eb b8                	jmp    8726 <lodepng_chunk_find_const+0x3>
}
    876e:	c9                   	leave  
    876f:	c3                   	ret    

00008770 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    8770:	55                   	push   %ebp
    8771:	89 e5                	mov    %esp,%ebp
    8773:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    8776:	ff 75 10             	pushl  0x10(%ebp)
    8779:	e8 c4 fb ff ff       	call   8342 <lodepng_chunk_length>
    877e:	83 c4 04             	add    $0x4,%esp
    8781:	89 c2                	mov    %eax,%edx
    8783:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8786:	50                   	push   %eax
    8787:	6a 0c                	push   $0xc
    8789:	52                   	push   %edx
    878a:	e8 f5 ac ff ff       	call   3484 <lodepng_addofl>
    878f:	83 c4 0c             	add    $0xc,%esp
    8792:	85 c0                	test   %eax,%eax
    8794:	74 0a                	je     87a0 <lodepng_chunk_append+0x30>
    8796:	b8 4d 00 00 00       	mov    $0x4d,%eax
    879b:	e9 96 00 00 00       	jmp    8836 <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    87a0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    87a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    87a6:	8b 00                	mov    (%eax),%eax
    87a8:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    87ab:	51                   	push   %ecx
    87ac:	52                   	push   %edx
    87ad:	50                   	push   %eax
    87ae:	e8 d1 ac ff ff       	call   3484 <lodepng_addofl>
    87b3:	83 c4 0c             	add    $0xc,%esp
    87b6:	85 c0                	test   %eax,%eax
    87b8:	74 07                	je     87c1 <lodepng_chunk_append+0x51>
    87ba:	b8 4d 00 00 00       	mov    $0x4d,%eax
    87bf:	eb 75                	jmp    8836 <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    87c1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    87c4:	8b 45 08             	mov    0x8(%ebp),%eax
    87c7:	8b 00                	mov    (%eax),%eax
    87c9:	52                   	push   %edx
    87ca:	50                   	push   %eax
    87cb:	e8 07 ac ff ff       	call   33d7 <lodepng_realloc>
    87d0:	83 c4 08             	add    $0x8,%esp
    87d3:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    87d6:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    87da:	75 07                	jne    87e3 <lodepng_chunk_append+0x73>
    87dc:	b8 53 00 00 00       	mov    $0x53,%eax
    87e1:	eb 53                	jmp    8836 <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    87e3:	8b 45 08             	mov    0x8(%ebp),%eax
    87e6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    87e9:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    87eb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    87ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    87f1:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    87f3:	8b 45 08             	mov    0x8(%ebp),%eax
    87f6:	8b 00                	mov    (%eax),%eax
    87f8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    87fb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    87fe:	29 d1                	sub    %edx,%ecx
    8800:	89 ca                	mov    %ecx,%edx
    8802:	01 d0                	add    %edx,%eax
    8804:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    8807:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    880e:	eb 19                	jmp    8829 <lodepng_chunk_append+0xb9>
    8810:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8813:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8816:	01 c2                	add    %eax,%edx
    8818:	8b 4d 10             	mov    0x10(%ebp),%ecx
    881b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    881e:	01 c8                	add    %ecx,%eax
    8820:	0f b6 00             	movzbl (%eax),%eax
    8823:	88 02                	mov    %al,(%edx)
    8825:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8829:	8b 45 f0             	mov    -0x10(%ebp),%eax
    882c:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    882f:	75 df                	jne    8810 <lodepng_chunk_append+0xa0>

  return 0;
    8831:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8836:	c9                   	leave  
    8837:	c3                   	ret    

00008838 <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    8838:	55                   	push   %ebp
    8839:	89 e5                	mov    %esp,%ebp
    883b:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    883e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8841:	8b 40 04             	mov    0x4(%eax),%eax
    8844:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    8847:	8b 55 10             	mov    0x10(%ebp),%edx
    884a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    884d:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    8850:	51                   	push   %ecx
    8851:	52                   	push   %edx
    8852:	50                   	push   %eax
    8853:	e8 2c ac ff ff       	call   3484 <lodepng_addofl>
    8858:	83 c4 0c             	add    $0xc,%esp
    885b:	85 c0                	test   %eax,%eax
    885d:	74 07                	je     8866 <lodepng_chunk_init+0x2e>
    885f:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8864:	eb 78                	jmp    88de <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    8866:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8869:	8d 55 fc             	lea    -0x4(%ebp),%edx
    886c:	52                   	push   %edx
    886d:	6a 0c                	push   $0xc
    886f:	50                   	push   %eax
    8870:	e8 0f ac ff ff       	call   3484 <lodepng_addofl>
    8875:	83 c4 0c             	add    $0xc,%esp
    8878:	85 c0                	test   %eax,%eax
    887a:	74 07                	je     8883 <lodepng_chunk_init+0x4b>
    887c:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8881:	eb 5b                	jmp    88de <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    8883:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8886:	50                   	push   %eax
    8887:	ff 75 0c             	pushl  0xc(%ebp)
    888a:	e8 8b ad ff ff       	call   361a <ucvector_resize>
    888f:	83 c4 08             	add    $0x8,%esp
    8892:	85 c0                	test   %eax,%eax
    8894:	75 07                	jne    889d <lodepng_chunk_init+0x65>
    8896:	b8 53 00 00 00       	mov    $0x53,%eax
    889b:	eb 41                	jmp    88de <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    889d:	8b 45 0c             	mov    0xc(%ebp),%eax
    88a0:	8b 00                	mov    (%eax),%eax
    88a2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    88a5:	2b 55 10             	sub    0x10(%ebp),%edx
    88a8:	83 ea 0c             	sub    $0xc,%edx
    88ab:	01 c2                	add    %eax,%edx
    88ad:	8b 45 08             	mov    0x8(%ebp),%eax
    88b0:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    88b2:	8b 45 08             	mov    0x8(%ebp),%eax
    88b5:	8b 00                	mov    (%eax),%eax
    88b7:	ff 75 10             	pushl  0x10(%ebp)
    88ba:	50                   	push   %eax
    88bb:	e8 c1 ae ff ff       	call   3781 <lodepng_set32bitInt>
    88c0:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    88c3:	8b 45 08             	mov    0x8(%ebp),%eax
    88c6:	8b 00                	mov    (%eax),%eax
    88c8:	83 c0 04             	add    $0x4,%eax
    88cb:	6a 04                	push   $0x4
    88cd:	ff 75 14             	pushl  0x14(%ebp)
    88d0:	50                   	push   %eax
    88d1:	e8 28 ab ff ff       	call   33fe <lodepng_memcpy>
    88d6:	83 c4 0c             	add    $0xc,%esp

  return 0;
    88d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    88de:	c9                   	leave  
    88df:	c3                   	ret    

000088e0 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    88e0:	55                   	push   %ebp
    88e1:	89 e5                	mov    %esp,%ebp
    88e3:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    88e6:	ff 75 10             	pushl  0x10(%ebp)
    88e9:	ff 75 0c             	pushl  0xc(%ebp)
    88ec:	ff 75 08             	pushl  0x8(%ebp)
    88ef:	8d 45 f8             	lea    -0x8(%ebp),%eax
    88f2:	50                   	push   %eax
    88f3:	e8 40 ff ff ff       	call   8838 <lodepng_chunk_init>
    88f8:	83 c4 10             	add    $0x10,%esp
    88fb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    88fe:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    8902:	74 05                	je     8909 <lodepng_chunk_createv+0x29>
    8904:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8907:	eb 27                	jmp    8930 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    8909:	8b 45 0c             	mov    0xc(%ebp),%eax
    890c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    890f:	83 c2 08             	add    $0x8,%edx
    8912:	50                   	push   %eax
    8913:	ff 75 14             	pushl  0x14(%ebp)
    8916:	52                   	push   %edx
    8917:	e8 e2 aa ff ff       	call   33fe <lodepng_memcpy>
    891c:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    891f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8922:	50                   	push   %eax
    8923:	e8 b9 fb ff ff       	call   84e1 <lodepng_chunk_generate_crc>
    8928:	83 c4 04             	add    $0x4,%esp

  return 0;
    892b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8930:	c9                   	leave  
    8931:	c3                   	ret    

00008932 <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    8932:	55                   	push   %ebp
    8933:	89 e5                	mov    %esp,%ebp
    8935:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    8938:	8b 45 0c             	mov    0xc(%ebp),%eax
    893b:	8b 08                	mov    (%eax),%ecx
    893d:	8b 45 08             	mov    0x8(%ebp),%eax
    8940:	8b 10                	mov    (%eax),%edx
    8942:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8945:	51                   	push   %ecx
    8946:	52                   	push   %edx
    8947:	50                   	push   %eax
    8948:	e8 34 ad ff ff       	call   3681 <ucvector_init>
    894d:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    8950:	ff 75 18             	pushl  0x18(%ebp)
    8953:	ff 75 14             	pushl  0x14(%ebp)
    8956:	ff 75 10             	pushl  0x10(%ebp)
    8959:	8d 45 f0             	lea    -0x10(%ebp),%eax
    895c:	50                   	push   %eax
    895d:	e8 7e ff ff ff       	call   88e0 <lodepng_chunk_createv>
    8962:	83 c4 10             	add    $0x10,%esp
    8965:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    8968:	8b 55 f0             	mov    -0x10(%ebp),%edx
    896b:	8b 45 08             	mov    0x8(%ebp),%eax
    896e:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8970:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8973:	8b 45 0c             	mov    0xc(%ebp),%eax
    8976:	89 10                	mov    %edx,(%eax)
  return error;
    8978:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    897b:	c9                   	leave  
    897c:	c3                   	ret    

0000897d <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    897d:	55                   	push   %ebp
    897e:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8980:	8b 45 08             	mov    0x8(%ebp),%eax
    8983:	83 f8 03             	cmp    $0x3,%eax
    8986:	74 6d                	je     89f5 <checkColorValidity+0x78>
    8988:	83 f8 03             	cmp    $0x3,%eax
    898b:	77 0e                	ja     899b <checkColorValidity+0x1e>
    898d:	85 c0                	test   %eax,%eax
    898f:	74 28                	je     89b9 <checkColorValidity+0x3c>
    8991:	83 f8 02             	cmp    $0x2,%eax
    8994:	74 4c                	je     89e2 <checkColorValidity+0x65>
    8996:	e9 a6 00 00 00       	jmp    8a41 <checkColorValidity+0xc4>
    899b:	83 f8 06             	cmp    $0x6,%eax
    899e:	0f 84 83 00 00 00    	je     8a27 <checkColorValidity+0xaa>
    89a4:	3d ff 00 00 00       	cmp    $0xff,%eax
    89a9:	0f 84 8b 00 00 00    	je     8a3a <checkColorValidity+0xbd>
    89af:	83 f8 04             	cmp    $0x4,%eax
    89b2:	74 60                	je     8a14 <checkColorValidity+0x97>
    89b4:	e9 88 00 00 00       	jmp    8a41 <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    89b9:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    89bd:	0f 84 85 00 00 00    	je     8a48 <checkColorValidity+0xcb>
    89c3:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    89c7:	74 7f                	je     8a48 <checkColorValidity+0xcb>
    89c9:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    89cd:	74 79                	je     8a48 <checkColorValidity+0xcb>
    89cf:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    89d3:	74 73                	je     8a48 <checkColorValidity+0xcb>
    89d5:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    89d9:	74 6d                	je     8a48 <checkColorValidity+0xcb>
    89db:	b8 25 00 00 00       	mov    $0x25,%eax
    89e0:	eb 78                	jmp    8a5a <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89e2:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    89e6:	74 63                	je     8a4b <checkColorValidity+0xce>
    89e8:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    89ec:	74 5d                	je     8a4b <checkColorValidity+0xce>
    89ee:	b8 25 00 00 00       	mov    $0x25,%eax
    89f3:	eb 65                	jmp    8a5a <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    89f5:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    89f9:	74 53                	je     8a4e <checkColorValidity+0xd1>
    89fb:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    89ff:	74 4d                	je     8a4e <checkColorValidity+0xd1>
    8a01:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8a05:	74 47                	je     8a4e <checkColorValidity+0xd1>
    8a07:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8a0b:	74 41                	je     8a4e <checkColorValidity+0xd1>
    8a0d:	b8 25 00 00 00       	mov    $0x25,%eax
    8a12:	eb 46                	jmp    8a5a <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a14:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8a18:	74 37                	je     8a51 <checkColorValidity+0xd4>
    8a1a:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8a1e:	74 31                	je     8a51 <checkColorValidity+0xd4>
    8a20:	b8 25 00 00 00       	mov    $0x25,%eax
    8a25:	eb 33                	jmp    8a5a <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a27:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8a2b:	74 27                	je     8a54 <checkColorValidity+0xd7>
    8a2d:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8a31:	74 21                	je     8a54 <checkColorValidity+0xd7>
    8a33:	b8 25 00 00 00       	mov    $0x25,%eax
    8a38:	eb 20                	jmp    8a5a <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    8a3a:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8a3f:	eb 19                	jmp    8a5a <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    8a41:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8a46:	eb 12                	jmp    8a5a <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8a48:	90                   	nop
    8a49:	eb 0a                	jmp    8a55 <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a4b:	90                   	nop
    8a4c:	eb 07                	jmp    8a55 <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8a4e:	90                   	nop
    8a4f:	eb 04                	jmp    8a55 <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a51:	90                   	nop
    8a52:	eb 01                	jmp    8a55 <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a54:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    8a55:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8a5a:	5d                   	pop    %ebp
    8a5b:	c3                   	ret    

00008a5c <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    8a5c:	55                   	push   %ebp
    8a5d:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8a5f:	8b 45 08             	mov    0x8(%ebp),%eax
    8a62:	83 f8 03             	cmp    $0x3,%eax
    8a65:	74 31                	je     8a98 <getNumColorChannels+0x3c>
    8a67:	83 f8 03             	cmp    $0x3,%eax
    8a6a:	77 0b                	ja     8a77 <getNumColorChannels+0x1b>
    8a6c:	85 c0                	test   %eax,%eax
    8a6e:	74 1a                	je     8a8a <getNumColorChannels+0x2e>
    8a70:	83 f8 02             	cmp    $0x2,%eax
    8a73:	74 1c                	je     8a91 <getNumColorChannels+0x35>
    8a75:	eb 3d                	jmp    8ab4 <getNumColorChannels+0x58>
    8a77:	83 f8 06             	cmp    $0x6,%eax
    8a7a:	74 2a                	je     8aa6 <getNumColorChannels+0x4a>
    8a7c:	3d ff 00 00 00       	cmp    $0xff,%eax
    8a81:	74 2a                	je     8aad <getNumColorChannels+0x51>
    8a83:	83 f8 04             	cmp    $0x4,%eax
    8a86:	74 17                	je     8a9f <getNumColorChannels+0x43>
    8a88:	eb 2a                	jmp    8ab4 <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    8a8a:	b8 01 00 00 00       	mov    $0x1,%eax
    8a8f:	eb 28                	jmp    8ab9 <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    8a91:	b8 03 00 00 00       	mov    $0x3,%eax
    8a96:	eb 21                	jmp    8ab9 <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    8a98:	b8 01 00 00 00       	mov    $0x1,%eax
    8a9d:	eb 1a                	jmp    8ab9 <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    8a9f:	b8 02 00 00 00       	mov    $0x2,%eax
    8aa4:	eb 13                	jmp    8ab9 <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    8aa6:	b8 04 00 00 00       	mov    $0x4,%eax
    8aab:	eb 0c                	jmp    8ab9 <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    8aad:	b8 00 00 00 00       	mov    $0x0,%eax
    8ab2:	eb 05                	jmp    8ab9 <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    8ab4:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    8ab9:	5d                   	pop    %ebp
    8aba:	c3                   	ret    

00008abb <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    8abb:	55                   	push   %ebp
    8abc:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    8abe:	ff 75 08             	pushl  0x8(%ebp)
    8ac1:	e8 96 ff ff ff       	call   8a5c <getNumColorChannels>
    8ac6:	83 c4 04             	add    $0x4,%esp
    8ac9:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    8acd:	c9                   	leave  
    8ace:	c3                   	ret    

00008acf <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    8acf:	55                   	push   %ebp
    8ad0:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    8ad2:	8b 45 08             	mov    0x8(%ebp),%eax
    8ad5:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    8adc:	8b 45 08             	mov    0x8(%ebp),%eax
    8adf:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    8ae6:	8b 45 08             	mov    0x8(%ebp),%eax
    8ae9:	8b 50 1c             	mov    0x1c(%eax),%edx
    8aec:	8b 45 08             	mov    0x8(%ebp),%eax
    8aef:	89 50 18             	mov    %edx,0x18(%eax)
    8af2:	8b 45 08             	mov    0x8(%ebp),%eax
    8af5:	8b 50 18             	mov    0x18(%eax),%edx
    8af8:	8b 45 08             	mov    0x8(%ebp),%eax
    8afb:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    8afe:	8b 45 08             	mov    0x8(%ebp),%eax
    8b01:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    8b07:	8b 45 08             	mov    0x8(%ebp),%eax
    8b0a:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    8b11:	8b 45 08             	mov    0x8(%ebp),%eax
    8b14:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8b1b:	8b 45 08             	mov    0x8(%ebp),%eax
    8b1e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8b25:	90                   	nop
    8b26:	5d                   	pop    %ebp
    8b27:	c3                   	ret    

00008b28 <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    8b28:	55                   	push   %ebp
    8b29:	89 e5                	mov    %esp,%ebp
    8b2b:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    8b2e:	8b 45 08             	mov    0x8(%ebp),%eax
    8b31:	8b 40 08             	mov    0x8(%eax),%eax
    8b34:	85 c0                	test   %eax,%eax
    8b36:	75 18                	jne    8b50 <lodepng_color_mode_alloc_palette+0x28>
    8b38:	83 ec 0c             	sub    $0xc,%esp
    8b3b:	68 00 04 00 00       	push   $0x400
    8b40:	e8 7b a8 ff ff       	call   33c0 <lodepng_malloc>
    8b45:	83 c4 10             	add    $0x10,%esp
    8b48:	89 c2                	mov    %eax,%edx
    8b4a:	8b 45 08             	mov    0x8(%ebp),%eax
    8b4d:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    8b50:	8b 45 08             	mov    0x8(%ebp),%eax
    8b53:	8b 40 08             	mov    0x8(%eax),%eax
    8b56:	85 c0                	test   %eax,%eax
    8b58:	74 65                	je     8bbf <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    8b5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8b61:	eb 51                	jmp    8bb4 <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    8b63:	8b 45 08             	mov    0x8(%ebp),%eax
    8b66:	8b 40 08             	mov    0x8(%eax),%eax
    8b69:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b6c:	c1 e2 02             	shl    $0x2,%edx
    8b6f:	01 d0                	add    %edx,%eax
    8b71:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    8b74:	8b 45 08             	mov    0x8(%ebp),%eax
    8b77:	8b 40 08             	mov    0x8(%eax),%eax
    8b7a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b7d:	c1 e2 02             	shl    $0x2,%edx
    8b80:	83 c2 01             	add    $0x1,%edx
    8b83:	01 d0                	add    %edx,%eax
    8b85:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    8b88:	8b 45 08             	mov    0x8(%ebp),%eax
    8b8b:	8b 40 08             	mov    0x8(%eax),%eax
    8b8e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b91:	c1 e2 02             	shl    $0x2,%edx
    8b94:	83 c2 02             	add    $0x2,%edx
    8b97:	01 d0                	add    %edx,%eax
    8b99:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    8b9c:	8b 45 08             	mov    0x8(%ebp),%eax
    8b9f:	8b 40 08             	mov    0x8(%eax),%eax
    8ba2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ba5:	c1 e2 02             	shl    $0x2,%edx
    8ba8:	83 c2 03             	add    $0x3,%edx
    8bab:	01 d0                	add    %edx,%eax
    8bad:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    8bb0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8bb4:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    8bbb:	75 a6                	jne    8b63 <lodepng_color_mode_alloc_palette+0x3b>
    8bbd:	eb 01                	jmp    8bc0 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    8bbf:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    8bc0:	c9                   	leave  
    8bc1:	c3                   	ret    

00008bc2 <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    8bc2:	55                   	push   %ebp
    8bc3:	89 e5                	mov    %esp,%ebp
    8bc5:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    8bc8:	83 ec 0c             	sub    $0xc,%esp
    8bcb:	ff 75 08             	pushl  0x8(%ebp)
    8bce:	e8 f3 01 00 00       	call   8dc6 <lodepng_palette_clear>
    8bd3:	83 c4 10             	add    $0x10,%esp
}
    8bd6:	90                   	nop
    8bd7:	c9                   	leave  
    8bd8:	c3                   	ret    

00008bd9 <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    8bd9:	55                   	push   %ebp
    8bda:	89 e5                	mov    %esp,%ebp
    8bdc:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    8bdf:	83 ec 0c             	sub    $0xc,%esp
    8be2:	ff 75 08             	pushl  0x8(%ebp)
    8be5:	e8 d8 ff ff ff       	call   8bc2 <lodepng_color_mode_cleanup>
    8bea:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    8bed:	83 ec 04             	sub    $0x4,%esp
    8bf0:	6a 20                	push   $0x20
    8bf2:	ff 75 0c             	pushl  0xc(%ebp)
    8bf5:	ff 75 08             	pushl  0x8(%ebp)
    8bf8:	e8 01 a8 ff ff       	call   33fe <lodepng_memcpy>
    8bfd:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    8c00:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c03:	8b 40 08             	mov    0x8(%eax),%eax
    8c06:	85 c0                	test   %eax,%eax
    8c08:	74 5a                	je     8c64 <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    8c0a:	83 ec 0c             	sub    $0xc,%esp
    8c0d:	68 00 04 00 00       	push   $0x400
    8c12:	e8 a9 a7 ff ff       	call   33c0 <lodepng_malloc>
    8c17:	83 c4 10             	add    $0x10,%esp
    8c1a:	89 c2                	mov    %eax,%edx
    8c1c:	8b 45 08             	mov    0x8(%ebp),%eax
    8c1f:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    8c22:	8b 45 08             	mov    0x8(%ebp),%eax
    8c25:	8b 40 08             	mov    0x8(%eax),%eax
    8c28:	85 c0                	test   %eax,%eax
    8c2a:	75 11                	jne    8c3d <lodepng_color_mode_copy+0x64>
    8c2c:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c2f:	8b 40 0c             	mov    0xc(%eax),%eax
    8c32:	85 c0                	test   %eax,%eax
    8c34:	74 07                	je     8c3d <lodepng_color_mode_copy+0x64>
    8c36:	b8 53 00 00 00       	mov    $0x53,%eax
    8c3b:	eb 2c                	jmp    8c69 <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    8c3d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c40:	8b 40 0c             	mov    0xc(%eax),%eax
    8c43:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    8c4a:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c4d:	8b 50 08             	mov    0x8(%eax),%edx
    8c50:	8b 45 08             	mov    0x8(%ebp),%eax
    8c53:	8b 40 08             	mov    0x8(%eax),%eax
    8c56:	83 ec 04             	sub    $0x4,%esp
    8c59:	51                   	push   %ecx
    8c5a:	52                   	push   %edx
    8c5b:	50                   	push   %eax
    8c5c:	e8 9d a7 ff ff       	call   33fe <lodepng_memcpy>
    8c61:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    8c64:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8c69:	c9                   	leave  
    8c6a:	c3                   	ret    

00008c6b <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    8c6b:	55                   	push   %ebp
    8c6c:	89 e5                	mov    %esp,%ebp
    8c6e:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    8c71:	8d 45 e0             	lea    -0x20(%ebp),%eax
    8c74:	50                   	push   %eax
    8c75:	e8 55 fe ff ff       	call   8acf <lodepng_color_mode_init>
    8c7a:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    8c7d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c80:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    8c83:	8b 45 10             	mov    0x10(%ebp),%eax
    8c86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    8c89:	8b 45 08             	mov    0x8(%ebp),%eax
    8c8c:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8c8f:	89 10                	mov    %edx,(%eax)
    8c91:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8c94:	89 50 04             	mov    %edx,0x4(%eax)
    8c97:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8c9a:	89 50 08             	mov    %edx,0x8(%eax)
    8c9d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8ca0:	89 50 0c             	mov    %edx,0xc(%eax)
    8ca3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8ca6:	89 50 10             	mov    %edx,0x10(%eax)
    8ca9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8cac:	89 50 14             	mov    %edx,0x14(%eax)
    8caf:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8cb2:	89 50 18             	mov    %edx,0x18(%eax)
    8cb5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8cb8:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    8cbb:	8b 45 08             	mov    0x8(%ebp),%eax
    8cbe:	c9                   	leave  
    8cbf:	c2 04 00             	ret    $0x4

00008cc2 <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    8cc2:	55                   	push   %ebp
    8cc3:	89 e5                	mov    %esp,%ebp
    8cc5:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    8cc8:	8b 45 08             	mov    0x8(%ebp),%eax
    8ccb:	8b 10                	mov    (%eax),%edx
    8ccd:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cd0:	8b 00                	mov    (%eax),%eax
    8cd2:	39 c2                	cmp    %eax,%edx
    8cd4:	74 0a                	je     8ce0 <lodepng_color_mode_equal+0x1e>
    8cd6:	b8 00 00 00 00       	mov    $0x0,%eax
    8cdb:	e9 e4 00 00 00       	jmp    8dc4 <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    8ce0:	8b 45 08             	mov    0x8(%ebp),%eax
    8ce3:	8b 50 04             	mov    0x4(%eax),%edx
    8ce6:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ce9:	8b 40 04             	mov    0x4(%eax),%eax
    8cec:	39 c2                	cmp    %eax,%edx
    8cee:	74 0a                	je     8cfa <lodepng_color_mode_equal+0x38>
    8cf0:	b8 00 00 00 00       	mov    $0x0,%eax
    8cf5:	e9 ca 00 00 00       	jmp    8dc4 <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    8cfa:	8b 45 08             	mov    0x8(%ebp),%eax
    8cfd:	8b 50 10             	mov    0x10(%eax),%edx
    8d00:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d03:	8b 40 10             	mov    0x10(%eax),%eax
    8d06:	39 c2                	cmp    %eax,%edx
    8d08:	74 0a                	je     8d14 <lodepng_color_mode_equal+0x52>
    8d0a:	b8 00 00 00 00       	mov    $0x0,%eax
    8d0f:	e9 b0 00 00 00       	jmp    8dc4 <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    8d14:	8b 45 08             	mov    0x8(%ebp),%eax
    8d17:	8b 40 10             	mov    0x10(%eax),%eax
    8d1a:	85 c0                	test   %eax,%eax
    8d1c:	74 48                	je     8d66 <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    8d1e:	8b 45 08             	mov    0x8(%ebp),%eax
    8d21:	8b 50 14             	mov    0x14(%eax),%edx
    8d24:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d27:	8b 40 14             	mov    0x14(%eax),%eax
    8d2a:	39 c2                	cmp    %eax,%edx
    8d2c:	74 0a                	je     8d38 <lodepng_color_mode_equal+0x76>
    8d2e:	b8 00 00 00 00       	mov    $0x0,%eax
    8d33:	e9 8c 00 00 00       	jmp    8dc4 <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    8d38:	8b 45 08             	mov    0x8(%ebp),%eax
    8d3b:	8b 50 18             	mov    0x18(%eax),%edx
    8d3e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d41:	8b 40 18             	mov    0x18(%eax),%eax
    8d44:	39 c2                	cmp    %eax,%edx
    8d46:	74 07                	je     8d4f <lodepng_color_mode_equal+0x8d>
    8d48:	b8 00 00 00 00       	mov    $0x0,%eax
    8d4d:	eb 75                	jmp    8dc4 <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    8d4f:	8b 45 08             	mov    0x8(%ebp),%eax
    8d52:	8b 50 1c             	mov    0x1c(%eax),%edx
    8d55:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d58:	8b 40 1c             	mov    0x1c(%eax),%eax
    8d5b:	39 c2                	cmp    %eax,%edx
    8d5d:	74 07                	je     8d66 <lodepng_color_mode_equal+0xa4>
    8d5f:	b8 00 00 00 00       	mov    $0x0,%eax
    8d64:	eb 5e                	jmp    8dc4 <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    8d66:	8b 45 08             	mov    0x8(%ebp),%eax
    8d69:	8b 50 0c             	mov    0xc(%eax),%edx
    8d6c:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d6f:	8b 40 0c             	mov    0xc(%eax),%eax
    8d72:	39 c2                	cmp    %eax,%edx
    8d74:	74 07                	je     8d7d <lodepng_color_mode_equal+0xbb>
    8d76:	b8 00 00 00 00       	mov    $0x0,%eax
    8d7b:	eb 47                	jmp    8dc4 <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    8d7d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8d84:	eb 2b                	jmp    8db1 <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    8d86:	8b 45 08             	mov    0x8(%ebp),%eax
    8d89:	8b 50 08             	mov    0x8(%eax),%edx
    8d8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d8f:	01 d0                	add    %edx,%eax
    8d91:	0f b6 10             	movzbl (%eax),%edx
    8d94:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d97:	8b 48 08             	mov    0x8(%eax),%ecx
    8d9a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d9d:	01 c8                	add    %ecx,%eax
    8d9f:	0f b6 00             	movzbl (%eax),%eax
    8da2:	38 c2                	cmp    %al,%dl
    8da4:	74 07                	je     8dad <lodepng_color_mode_equal+0xeb>
    8da6:	b8 00 00 00 00       	mov    $0x0,%eax
    8dab:	eb 17                	jmp    8dc4 <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    8dad:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8db1:	8b 45 08             	mov    0x8(%ebp),%eax
    8db4:	8b 40 0c             	mov    0xc(%eax),%eax
    8db7:	c1 e0 02             	shl    $0x2,%eax
    8dba:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8dbd:	75 c7                	jne    8d86 <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    8dbf:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8dc4:	c9                   	leave  
    8dc5:	c3                   	ret    

00008dc6 <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    8dc6:	55                   	push   %ebp
    8dc7:	89 e5                	mov    %esp,%ebp
    8dc9:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    8dcc:	8b 45 08             	mov    0x8(%ebp),%eax
    8dcf:	8b 40 08             	mov    0x8(%eax),%eax
    8dd2:	85 c0                	test   %eax,%eax
    8dd4:	74 12                	je     8de8 <lodepng_palette_clear+0x22>
    8dd6:	8b 45 08             	mov    0x8(%ebp),%eax
    8dd9:	8b 40 08             	mov    0x8(%eax),%eax
    8ddc:	83 ec 0c             	sub    $0xc,%esp
    8ddf:	50                   	push   %eax
    8de0:	e8 fc a5 ff ff       	call   33e1 <lodepng_free>
    8de5:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    8de8:	8b 45 08             	mov    0x8(%ebp),%eax
    8deb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8df2:	8b 45 08             	mov    0x8(%ebp),%eax
    8df5:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8dfc:	90                   	nop
    8dfd:	c9                   	leave  
    8dfe:	c3                   	ret    

00008dff <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    8dff:	55                   	push   %ebp
    8e00:	89 e5                	mov    %esp,%ebp
    8e02:	53                   	push   %ebx
    8e03:	83 ec 14             	sub    $0x14,%esp
    8e06:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    8e09:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8e0c:	8b 55 14             	mov    0x14(%ebp),%edx
    8e0f:	8b 45 18             	mov    0x18(%ebp),%eax
    8e12:	88 5d f4             	mov    %bl,-0xc(%ebp)
    8e15:	88 4d f0             	mov    %cl,-0x10(%ebp)
    8e18:	88 55 ec             	mov    %dl,-0x14(%ebp)
    8e1b:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    8e1e:	8b 45 08             	mov    0x8(%ebp),%eax
    8e21:	8b 40 08             	mov    0x8(%eax),%eax
    8e24:	85 c0                	test   %eax,%eax
    8e26:	75 22                	jne    8e4a <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    8e28:	83 ec 0c             	sub    $0xc,%esp
    8e2b:	ff 75 08             	pushl  0x8(%ebp)
    8e2e:	e8 f5 fc ff ff       	call   8b28 <lodepng_color_mode_alloc_palette>
    8e33:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    8e36:	8b 45 08             	mov    0x8(%ebp),%eax
    8e39:	8b 40 08             	mov    0x8(%eax),%eax
    8e3c:	85 c0                	test   %eax,%eax
    8e3e:	75 0a                	jne    8e4a <lodepng_palette_add+0x4b>
    8e40:	b8 53 00 00 00       	mov    $0x53,%eax
    8e45:	e9 8d 00 00 00       	jmp    8ed7 <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    8e4a:	8b 45 08             	mov    0x8(%ebp),%eax
    8e4d:	8b 40 0c             	mov    0xc(%eax),%eax
    8e50:	3d ff 00 00 00       	cmp    $0xff,%eax
    8e55:	7e 07                	jle    8e5e <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    8e57:	b8 6c 00 00 00       	mov    $0x6c,%eax
    8e5c:	eb 79                	jmp    8ed7 <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    8e5e:	8b 45 08             	mov    0x8(%ebp),%eax
    8e61:	8b 50 08             	mov    0x8(%eax),%edx
    8e64:	8b 45 08             	mov    0x8(%ebp),%eax
    8e67:	8b 40 0c             	mov    0xc(%eax),%eax
    8e6a:	c1 e0 02             	shl    $0x2,%eax
    8e6d:	01 c2                	add    %eax,%edx
    8e6f:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    8e73:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    8e75:	8b 45 08             	mov    0x8(%ebp),%eax
    8e78:	8b 50 08             	mov    0x8(%eax),%edx
    8e7b:	8b 45 08             	mov    0x8(%ebp),%eax
    8e7e:	8b 40 0c             	mov    0xc(%eax),%eax
    8e81:	c1 e0 02             	shl    $0x2,%eax
    8e84:	83 c0 01             	add    $0x1,%eax
    8e87:	01 c2                	add    %eax,%edx
    8e89:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    8e8d:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    8e8f:	8b 45 08             	mov    0x8(%ebp),%eax
    8e92:	8b 50 08             	mov    0x8(%eax),%edx
    8e95:	8b 45 08             	mov    0x8(%ebp),%eax
    8e98:	8b 40 0c             	mov    0xc(%eax),%eax
    8e9b:	c1 e0 02             	shl    $0x2,%eax
    8e9e:	83 c0 02             	add    $0x2,%eax
    8ea1:	01 c2                	add    %eax,%edx
    8ea3:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    8ea7:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    8ea9:	8b 45 08             	mov    0x8(%ebp),%eax
    8eac:	8b 50 08             	mov    0x8(%eax),%edx
    8eaf:	8b 45 08             	mov    0x8(%ebp),%eax
    8eb2:	8b 40 0c             	mov    0xc(%eax),%eax
    8eb5:	c1 e0 02             	shl    $0x2,%eax
    8eb8:	83 c0 03             	add    $0x3,%eax
    8ebb:	01 c2                	add    %eax,%edx
    8ebd:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    8ec1:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    8ec3:	8b 45 08             	mov    0x8(%ebp),%eax
    8ec6:	8b 40 0c             	mov    0xc(%eax),%eax
    8ec9:	8d 50 01             	lea    0x1(%eax),%edx
    8ecc:	8b 45 08             	mov    0x8(%ebp),%eax
    8ecf:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    8ed2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8ed7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8eda:	c9                   	leave  
    8edb:	c3                   	ret    

00008edc <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    8edc:	55                   	push   %ebp
    8edd:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    8edf:	8b 45 08             	mov    0x8(%ebp),%eax
    8ee2:	8b 50 04             	mov    0x4(%eax),%edx
    8ee5:	8b 45 08             	mov    0x8(%ebp),%eax
    8ee8:	8b 00                	mov    (%eax),%eax
    8eea:	52                   	push   %edx
    8eeb:	50                   	push   %eax
    8eec:	e8 ca fb ff ff       	call   8abb <lodepng_get_bpp_lct>
    8ef1:	83 c4 08             	add    $0x8,%esp
}
    8ef4:	c9                   	leave  
    8ef5:	c3                   	ret    

00008ef6 <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    8ef6:	55                   	push   %ebp
    8ef7:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    8ef9:	8b 45 08             	mov    0x8(%ebp),%eax
    8efc:	8b 00                	mov    (%eax),%eax
    8efe:	50                   	push   %eax
    8eff:	e8 58 fb ff ff       	call   8a5c <getNumColorChannels>
    8f04:	83 c4 04             	add    $0x4,%esp
}
    8f07:	c9                   	leave  
    8f08:	c3                   	ret    

00008f09 <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    8f09:	55                   	push   %ebp
    8f0a:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    8f0c:	8b 45 08             	mov    0x8(%ebp),%eax
    8f0f:	8b 00                	mov    (%eax),%eax
    8f11:	85 c0                	test   %eax,%eax
    8f13:	74 0a                	je     8f1f <lodepng_is_greyscale_type+0x16>
    8f15:	8b 45 08             	mov    0x8(%ebp),%eax
    8f18:	8b 00                	mov    (%eax),%eax
    8f1a:	83 f8 04             	cmp    $0x4,%eax
    8f1d:	75 07                	jne    8f26 <lodepng_is_greyscale_type+0x1d>
    8f1f:	b8 01 00 00 00       	mov    $0x1,%eax
    8f24:	eb 05                	jmp    8f2b <lodepng_is_greyscale_type+0x22>
    8f26:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f2b:	5d                   	pop    %ebp
    8f2c:	c3                   	ret    

00008f2d <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    8f2d:	55                   	push   %ebp
    8f2e:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    8f30:	8b 45 08             	mov    0x8(%ebp),%eax
    8f33:	8b 00                	mov    (%eax),%eax
    8f35:	83 e0 04             	and    $0x4,%eax
    8f38:	85 c0                	test   %eax,%eax
    8f3a:	0f 95 c0             	setne  %al
    8f3d:	0f b6 c0             	movzbl %al,%eax
}
    8f40:	5d                   	pop    %ebp
    8f41:	c3                   	ret    

00008f42 <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    8f42:	55                   	push   %ebp
    8f43:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    8f45:	8b 45 08             	mov    0x8(%ebp),%eax
    8f48:	8b 00                	mov    (%eax),%eax
    8f4a:	83 f8 03             	cmp    $0x3,%eax
    8f4d:	0f 94 c0             	sete   %al
    8f50:	0f b6 c0             	movzbl %al,%eax
}
    8f53:	5d                   	pop    %ebp
    8f54:	c3                   	ret    

00008f55 <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    8f55:	55                   	push   %ebp
    8f56:	89 e5                	mov    %esp,%ebp
    8f58:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8f5b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8f62:	eb 23                	jmp    8f87 <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    8f64:	8b 45 08             	mov    0x8(%ebp),%eax
    8f67:	8b 40 08             	mov    0x8(%eax),%eax
    8f6a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8f6d:	c1 e2 02             	shl    $0x2,%edx
    8f70:	83 c2 03             	add    $0x3,%edx
    8f73:	01 d0                	add    %edx,%eax
    8f75:	0f b6 00             	movzbl (%eax),%eax
    8f78:	3c ff                	cmp    $0xff,%al
    8f7a:	74 07                	je     8f83 <lodepng_has_palette_alpha+0x2e>
    8f7c:	b8 01 00 00 00       	mov    $0x1,%eax
    8f81:	eb 14                	jmp    8f97 <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8f83:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8f87:	8b 45 08             	mov    0x8(%ebp),%eax
    8f8a:	8b 40 0c             	mov    0xc(%eax),%eax
    8f8d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8f90:	75 d2                	jne    8f64 <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    8f92:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f97:	c9                   	leave  
    8f98:	c3                   	ret    

00008f99 <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    8f99:	55                   	push   %ebp
    8f9a:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    8f9c:	8b 45 08             	mov    0x8(%ebp),%eax
    8f9f:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    8fa2:	85 c0                	test   %eax,%eax
    8fa4:	75 1e                	jne    8fc4 <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    8fa6:	ff 75 08             	pushl  0x8(%ebp)
    8fa9:	e8 7f ff ff ff       	call   8f2d <lodepng_is_alpha_type>
    8fae:	83 c4 04             	add    $0x4,%esp
    8fb1:	85 c0                	test   %eax,%eax
    8fb3:	75 0f                	jne    8fc4 <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    8fb5:	ff 75 08             	pushl  0x8(%ebp)
    8fb8:	e8 98 ff ff ff       	call   8f55 <lodepng_has_palette_alpha>
    8fbd:	83 c4 04             	add    $0x4,%esp
    8fc0:	85 c0                	test   %eax,%eax
    8fc2:	74 07                	je     8fcb <lodepng_can_have_alpha+0x32>
    8fc4:	b8 01 00 00 00       	mov    $0x1,%eax
    8fc9:	eb 05                	jmp    8fd0 <lodepng_can_have_alpha+0x37>
    8fcb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8fd0:	c9                   	leave  
    8fd1:	c3                   	ret    

00008fd2 <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    8fd2:	55                   	push   %ebp
    8fd3:	89 e5                	mov    %esp,%ebp
    8fd5:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    8fd8:	ff 75 14             	pushl  0x14(%ebp)
    8fdb:	ff 75 10             	pushl  0x10(%ebp)
    8fde:	e8 d8 fa ff ff       	call   8abb <lodepng_get_bpp_lct>
    8fe3:	83 c4 08             	add    $0x8,%esp
    8fe6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    8fe9:	8b 55 08             	mov    0x8(%ebp),%edx
    8fec:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fef:	0f af c2             	imul   %edx,%eax
    8ff2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    8ff5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8ff8:	c1 e8 03             	shr    $0x3,%eax
    8ffb:	89 c2                	mov    %eax,%edx
    8ffd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9000:	0f af c2             	imul   %edx,%eax
    9003:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9006:	89 d1                	mov    %edx,%ecx
    9008:	83 e1 07             	and    $0x7,%ecx
    900b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    900e:	0f af d1             	imul   %ecx,%edx
    9011:	83 c2 07             	add    $0x7,%edx
    9014:	c1 ea 03             	shr    $0x3,%edx
    9017:	01 d0                	add    %edx,%eax
}
    9019:	c9                   	leave  
    901a:	c3                   	ret    

0000901b <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    901b:	55                   	push   %ebp
    901c:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    901e:	8b 45 10             	mov    0x10(%ebp),%eax
    9021:	8b 50 04             	mov    0x4(%eax),%edx
    9024:	8b 45 10             	mov    0x10(%ebp),%eax
    9027:	8b 00                	mov    (%eax),%eax
    9029:	52                   	push   %edx
    902a:	50                   	push   %eax
    902b:	ff 75 0c             	pushl  0xc(%ebp)
    902e:	ff 75 08             	pushl  0x8(%ebp)
    9031:	e8 9c ff ff ff       	call   8fd2 <lodepng_get_raw_size_lct>
    9036:	83 c4 10             	add    $0x10,%esp
}
    9039:	c9                   	leave  
    903a:	c3                   	ret    

0000903b <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    903b:	55                   	push   %ebp
    903c:	89 e5                	mov    %esp,%ebp
    903e:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    9041:	8b 45 08             	mov    0x8(%ebp),%eax
    9044:	c1 e8 03             	shr    $0x3,%eax
    9047:	0f af 45 10          	imul   0x10(%ebp),%eax
    904b:	8b 55 08             	mov    0x8(%ebp),%edx
    904e:	83 e2 07             	and    $0x7,%edx
    9051:	0f af 55 10          	imul   0x10(%ebp),%edx
    9055:	83 c2 07             	add    $0x7,%edx
    9058:	c1 ea 03             	shr    $0x3,%edx
    905b:	01 d0                	add    %edx,%eax
    905d:	83 c0 01             	add    $0x1,%eax
    9060:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    9063:	8b 45 0c             	mov    0xc(%ebp),%eax
    9066:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    906a:	c9                   	leave  
    906b:	c3                   	ret    

0000906c <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    906c:	55                   	push   %ebp
    906d:	89 e5                	mov    %esp,%ebp
    906f:	53                   	push   %ebx
    9070:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    9073:	ff 75 10             	pushl  0x10(%ebp)
    9076:	e8 61 fe ff ff       	call   8edc <lodepng_get_bpp>
    907b:	83 c4 04             	add    $0x4,%esp
    907e:	89 c3                	mov    %eax,%ebx
    9080:	ff 75 14             	pushl  0x14(%ebp)
    9083:	e8 54 fe ff ff       	call   8edc <lodepng_get_bpp>
    9088:	83 c4 04             	add    $0x4,%esp
    908b:	39 c3                	cmp    %eax,%ebx
    908d:	76 0d                	jbe    909c <lodepng_pixel_overflow+0x30>
    908f:	ff 75 10             	pushl  0x10(%ebp)
    9092:	e8 45 fe ff ff       	call   8edc <lodepng_get_bpp>
    9097:	83 c4 04             	add    $0x4,%esp
    909a:	eb 0b                	jmp    90a7 <lodepng_pixel_overflow+0x3b>
    909c:	ff 75 14             	pushl  0x14(%ebp)
    909f:	e8 38 fe ff ff       	call   8edc <lodepng_get_bpp>
    90a4:	83 c4 04             	add    $0x4,%esp
    90a7:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    90aa:	8b 55 0c             	mov    0xc(%ebp),%edx
    90ad:	8b 45 08             	mov    0x8(%ebp),%eax
    90b0:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    90b3:	51                   	push   %ecx
    90b4:	52                   	push   %edx
    90b5:	50                   	push   %eax
    90b6:	e8 e9 a3 ff ff       	call   34a4 <lodepng_mulofl>
    90bb:	83 c4 0c             	add    $0xc,%esp
    90be:	85 c0                	test   %eax,%eax
    90c0:	74 0a                	je     90cc <lodepng_pixel_overflow+0x60>
    90c2:	b8 01 00 00 00       	mov    $0x1,%eax
    90c7:	e9 b6 00 00 00       	jmp    9182 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    90cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    90cf:	8d 55 f0             	lea    -0x10(%ebp),%edx
    90d2:	52                   	push   %edx
    90d3:	6a 08                	push   $0x8
    90d5:	50                   	push   %eax
    90d6:	e8 c9 a3 ff ff       	call   34a4 <lodepng_mulofl>
    90db:	83 c4 0c             	add    $0xc,%esp
    90de:	85 c0                	test   %eax,%eax
    90e0:	74 0a                	je     90ec <lodepng_pixel_overflow+0x80>
    90e2:	b8 01 00 00 00       	mov    $0x1,%eax
    90e7:	e9 96 00 00 00       	jmp    9182 <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    90ec:	8b 45 08             	mov    0x8(%ebp),%eax
    90ef:	c1 e8 03             	shr    $0x3,%eax
    90f2:	89 c2                	mov    %eax,%edx
    90f4:	8d 45 ec             	lea    -0x14(%ebp),%eax
    90f7:	50                   	push   %eax
    90f8:	ff 75 f8             	pushl  -0x8(%ebp)
    90fb:	52                   	push   %edx
    90fc:	e8 a3 a3 ff ff       	call   34a4 <lodepng_mulofl>
    9101:	83 c4 0c             	add    $0xc,%esp
    9104:	85 c0                	test   %eax,%eax
    9106:	74 07                	je     910f <lodepng_pixel_overflow+0xa3>
    9108:	b8 01 00 00 00       	mov    $0x1,%eax
    910d:	eb 73                	jmp    9182 <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    910f:	8b 45 08             	mov    0x8(%ebp),%eax
    9112:	83 e0 07             	and    $0x7,%eax
    9115:	89 c2                	mov    %eax,%edx
    9117:	8b 45 f8             	mov    -0x8(%ebp),%eax
    911a:	0f af c2             	imul   %edx,%eax
    911d:	83 c0 07             	add    $0x7,%eax
    9120:	c1 e8 03             	shr    $0x3,%eax
    9123:	89 c1                	mov    %eax,%ecx
    9125:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9128:	8d 55 ec             	lea    -0x14(%ebp),%edx
    912b:	52                   	push   %edx
    912c:	51                   	push   %ecx
    912d:	50                   	push   %eax
    912e:	e8 51 a3 ff ff       	call   3484 <lodepng_addofl>
    9133:	83 c4 0c             	add    $0xc,%esp
    9136:	85 c0                	test   %eax,%eax
    9138:	74 07                	je     9141 <lodepng_pixel_overflow+0xd5>
    913a:	b8 01 00 00 00       	mov    $0x1,%eax
    913f:	eb 41                	jmp    9182 <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    9141:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9144:	8d 55 ec             	lea    -0x14(%ebp),%edx
    9147:	52                   	push   %edx
    9148:	6a 05                	push   $0x5
    914a:	50                   	push   %eax
    914b:	e8 34 a3 ff ff       	call   3484 <lodepng_addofl>
    9150:	83 c4 0c             	add    $0xc,%esp
    9153:	85 c0                	test   %eax,%eax
    9155:	74 07                	je     915e <lodepng_pixel_overflow+0xf2>
    9157:	b8 01 00 00 00       	mov    $0x1,%eax
    915c:	eb 24                	jmp    9182 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    915e:	8b 55 0c             	mov    0xc(%ebp),%edx
    9161:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9164:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    9167:	51                   	push   %ecx
    9168:	52                   	push   %edx
    9169:	50                   	push   %eax
    916a:	e8 35 a3 ff ff       	call   34a4 <lodepng_mulofl>
    916f:	83 c4 0c             	add    $0xc,%esp
    9172:	85 c0                	test   %eax,%eax
    9174:	74 07                	je     917d <lodepng_pixel_overflow+0x111>
    9176:	b8 01 00 00 00       	mov    $0x1,%eax
    917b:	eb 05                	jmp    9182 <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    917d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9182:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9185:	c9                   	leave  
    9186:	c3                   	ret    

00009187 <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    9187:	55                   	push   %ebp
    9188:	89 e5                	mov    %esp,%ebp
    918a:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    918d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9194:	eb 15                	jmp    91ab <LodePNGUnknownChunks_init+0x24>
    9196:	8b 45 08             	mov    0x8(%ebp),%eax
    9199:	8b 55 fc             	mov    -0x4(%ebp),%edx
    919c:	83 c2 30             	add    $0x30,%edx
    919f:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    91a6:	00 
    91a7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    91ab:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    91af:	75 e5                	jne    9196 <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    91b1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    91b8:	eb 15                	jmp    91cf <LodePNGUnknownChunks_init+0x48>
    91ba:	8b 45 08             	mov    0x8(%ebp),%eax
    91bd:	8b 55 fc             	mov    -0x4(%ebp),%edx
    91c0:	83 c2 34             	add    $0x34,%edx
    91c3:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    91ca:	00 
    91cb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    91cf:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    91d3:	75 e5                	jne    91ba <LodePNGUnknownChunks_init+0x33>
}
    91d5:	90                   	nop
    91d6:	c9                   	leave  
    91d7:	c3                   	ret    

000091d8 <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    91d8:	55                   	push   %ebp
    91d9:	89 e5                	mov    %esp,%ebp
    91db:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    91de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    91e5:	eb 1d                	jmp    9204 <LodePNGUnknownChunks_cleanup+0x2c>
    91e7:	8b 45 08             	mov    0x8(%ebp),%eax
    91ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91ed:	83 c2 30             	add    $0x30,%edx
    91f0:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    91f4:	83 ec 0c             	sub    $0xc,%esp
    91f7:	50                   	push   %eax
    91f8:	e8 e4 a1 ff ff       	call   33e1 <lodepng_free>
    91fd:	83 c4 10             	add    $0x10,%esp
    9200:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9204:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    9208:	75 dd                	jne    91e7 <LodePNGUnknownChunks_cleanup+0xf>
}
    920a:	90                   	nop
    920b:	c9                   	leave  
    920c:	c3                   	ret    

0000920d <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    920d:	55                   	push   %ebp
    920e:	89 e5                	mov    %esp,%ebp
    9210:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    9213:	83 ec 0c             	sub    $0xc,%esp
    9216:	ff 75 08             	pushl  0x8(%ebp)
    9219:	e8 ba ff ff ff       	call   91d8 <LodePNGUnknownChunks_cleanup>
    921e:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    9221:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9228:	e9 b7 00 00 00       	jmp    92e4 <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    922d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9230:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9233:	83 c2 34             	add    $0x34,%edx
    9236:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    923a:	8b 45 08             	mov    0x8(%ebp),%eax
    923d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9240:	83 c1 34             	add    $0x34,%ecx
    9243:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    9247:	8b 45 0c             	mov    0xc(%ebp),%eax
    924a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    924d:	83 c2 34             	add    $0x34,%edx
    9250:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9254:	83 ec 0c             	sub    $0xc,%esp
    9257:	50                   	push   %eax
    9258:	e8 63 a1 ff ff       	call   33c0 <lodepng_malloc>
    925d:	83 c4 10             	add    $0x10,%esp
    9260:	89 c1                	mov    %eax,%ecx
    9262:	8b 45 08             	mov    0x8(%ebp),%eax
    9265:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9268:	83 c2 30             	add    $0x30,%edx
    926b:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    926f:	8b 45 08             	mov    0x8(%ebp),%eax
    9272:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9275:	83 c2 30             	add    $0x30,%edx
    9278:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    927c:	85 c0                	test   %eax,%eax
    927e:	75 18                	jne    9298 <LodePNGUnknownChunks_copy+0x8b>
    9280:	8b 45 08             	mov    0x8(%ebp),%eax
    9283:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9286:	83 c2 34             	add    $0x34,%edx
    9289:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    928d:	85 c0                	test   %eax,%eax
    928f:	74 07                	je     9298 <LodePNGUnknownChunks_copy+0x8b>
    9291:	b8 53 00 00 00       	mov    $0x53,%eax
    9296:	eb 5b                	jmp    92f3 <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    9298:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    929f:	eb 2d                	jmp    92ce <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    92a1:	8b 45 08             	mov    0x8(%ebp),%eax
    92a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92a7:	83 c2 30             	add    $0x30,%edx
    92aa:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    92ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
    92b1:	01 c2                	add    %eax,%edx
    92b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    92b6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    92b9:	83 c1 30             	add    $0x30,%ecx
    92bc:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    92c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    92c3:	01 c8                	add    %ecx,%eax
    92c5:	0f b6 00             	movzbl (%eax),%eax
    92c8:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    92ca:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    92ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    92d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92d4:	83 c2 34             	add    $0x34,%edx
    92d7:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    92db:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    92de:	7f c1                	jg     92a1 <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    92e0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    92e4:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    92e8:	0f 85 3f ff ff ff    	jne    922d <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    92ee:	b8 00 00 00 00       	mov    $0x0,%eax
}
    92f3:	c9                   	leave  
    92f4:	c3                   	ret    

000092f5 <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    92f5:	55                   	push   %ebp
    92f6:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    92f8:	8b 45 08             	mov    0x8(%ebp),%eax
    92fb:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    9302:	8b 45 08             	mov    0x8(%ebp),%eax
    9305:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    930c:	8b 45 08             	mov    0x8(%ebp),%eax
    930f:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    9316:	90                   	nop
    9317:	5d                   	pop    %ebp
    9318:	c3                   	ret    

00009319 <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    9319:	55                   	push   %ebp
    931a:	89 e5                	mov    %esp,%ebp
    931c:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    931f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9326:	eb 38                	jmp    9360 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    9328:	8b 45 08             	mov    0x8(%ebp),%eax
    932b:	8b 40 40             	mov    0x40(%eax),%eax
    932e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9331:	c1 e2 02             	shl    $0x2,%edx
    9334:	01 d0                	add    %edx,%eax
    9336:	83 ec 0c             	sub    $0xc,%esp
    9339:	50                   	push   %eax
    933a:	e8 75 a3 ff ff       	call   36b4 <string_cleanup>
    933f:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    9342:	8b 45 08             	mov    0x8(%ebp),%eax
    9345:	8b 40 44             	mov    0x44(%eax),%eax
    9348:	8b 55 f4             	mov    -0xc(%ebp),%edx
    934b:	c1 e2 02             	shl    $0x2,%edx
    934e:	01 d0                	add    %edx,%eax
    9350:	83 ec 0c             	sub    $0xc,%esp
    9353:	50                   	push   %eax
    9354:	e8 5b a3 ff ff       	call   36b4 <string_cleanup>
    9359:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    935c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9360:	8b 45 08             	mov    0x8(%ebp),%eax
    9363:	8b 40 3c             	mov    0x3c(%eax),%eax
    9366:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9369:	75 bd                	jne    9328 <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    936b:	8b 45 08             	mov    0x8(%ebp),%eax
    936e:	8b 40 40             	mov    0x40(%eax),%eax
    9371:	83 ec 0c             	sub    $0xc,%esp
    9374:	50                   	push   %eax
    9375:	e8 67 a0 ff ff       	call   33e1 <lodepng_free>
    937a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    937d:	8b 45 08             	mov    0x8(%ebp),%eax
    9380:	8b 40 44             	mov    0x44(%eax),%eax
    9383:	83 ec 0c             	sub    $0xc,%esp
    9386:	50                   	push   %eax
    9387:	e8 55 a0 ff ff       	call   33e1 <lodepng_free>
    938c:	83 c4 10             	add    $0x10,%esp
}
    938f:	90                   	nop
    9390:	c9                   	leave  
    9391:	c3                   	ret    

00009392 <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9392:	55                   	push   %ebp
    9393:	89 e5                	mov    %esp,%ebp
    9395:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    9398:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    939f:	8b 45 08             	mov    0x8(%ebp),%eax
    93a2:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    93a9:	8b 45 08             	mov    0x8(%ebp),%eax
    93ac:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    93b3:	8b 45 08             	mov    0x8(%ebp),%eax
    93b6:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    93bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    93c4:	eb 42                	jmp    9408 <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    93c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    93c9:	8b 40 44             	mov    0x44(%eax),%eax
    93cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    93cf:	c1 e2 02             	shl    $0x2,%edx
    93d2:	01 d0                	add    %edx,%eax
    93d4:	8b 10                	mov    (%eax),%edx
    93d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    93d9:	8b 40 40             	mov    0x40(%eax),%eax
    93dc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    93df:	c1 e1 02             	shl    $0x2,%ecx
    93e2:	01 c8                	add    %ecx,%eax
    93e4:	8b 00                	mov    (%eax),%eax
    93e6:	83 ec 04             	sub    $0x4,%esp
    93e9:	52                   	push   %edx
    93ea:	50                   	push   %eax
    93eb:	ff 75 08             	pushl  0x8(%ebp)
    93ee:	e8 4d 01 00 00       	call   9540 <lodepng_add_text>
    93f3:	83 c4 10             	add    $0x10,%esp
    93f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    93f9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    93fd:	74 05                	je     9404 <LodePNGText_copy+0x72>
    93ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9402:	eb 14                	jmp    9418 <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    9404:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9408:	8b 45 0c             	mov    0xc(%ebp),%eax
    940b:	8b 40 3c             	mov    0x3c(%eax),%eax
    940e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9411:	75 b3                	jne    93c6 <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    9413:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9418:	c9                   	leave  
    9419:	c3                   	ret    

0000941a <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    941a:	55                   	push   %ebp
    941b:	89 e5                	mov    %esp,%ebp
    941d:	53                   	push   %ebx
    941e:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    9421:	8b 45 08             	mov    0x8(%ebp),%eax
    9424:	8b 40 3c             	mov    0x3c(%eax),%eax
    9427:	83 c0 01             	add    $0x1,%eax
    942a:	c1 e0 02             	shl    $0x2,%eax
    942d:	89 c2                	mov    %eax,%edx
    942f:	8b 45 08             	mov    0x8(%ebp),%eax
    9432:	8b 40 40             	mov    0x40(%eax),%eax
    9435:	52                   	push   %edx
    9436:	50                   	push   %eax
    9437:	e8 9b 9f ff ff       	call   33d7 <lodepng_realloc>
    943c:	83 c4 08             	add    $0x8,%esp
    943f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    9442:	8b 45 08             	mov    0x8(%ebp),%eax
    9445:	8b 40 3c             	mov    0x3c(%eax),%eax
    9448:	83 c0 01             	add    $0x1,%eax
    944b:	c1 e0 02             	shl    $0x2,%eax
    944e:	89 c2                	mov    %eax,%edx
    9450:	8b 45 08             	mov    0x8(%ebp),%eax
    9453:	8b 40 44             	mov    0x44(%eax),%eax
    9456:	52                   	push   %edx
    9457:	50                   	push   %eax
    9458:	e8 7a 9f ff ff       	call   33d7 <lodepng_realloc>
    945d:	83 c4 08             	add    $0x8,%esp
    9460:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    9463:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9467:	74 09                	je     9472 <lodepng_add_text_sized+0x58>
    9469:	8b 45 08             	mov    0x8(%ebp),%eax
    946c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    946f:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    9472:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9476:	74 09                	je     9481 <lodepng_add_text_sized+0x67>
    9478:	8b 45 08             	mov    0x8(%ebp),%eax
    947b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    947e:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    9481:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9485:	74 06                	je     948d <lodepng_add_text_sized+0x73>
    9487:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    948b:	75 0a                	jne    9497 <lodepng_add_text_sized+0x7d>
    948d:	b8 53 00 00 00       	mov    $0x53,%eax
    9492:	e9 a4 00 00 00       	jmp    953b <lodepng_add_text_sized+0x121>

  ++info->text_num;
    9497:	8b 45 08             	mov    0x8(%ebp),%eax
    949a:	8b 40 3c             	mov    0x3c(%eax),%eax
    949d:	8d 50 01             	lea    0x1(%eax),%edx
    94a0:	8b 45 08             	mov    0x8(%ebp),%eax
    94a3:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    94a6:	8b 45 08             	mov    0x8(%ebp),%eax
    94a9:	8b 50 40             	mov    0x40(%eax),%edx
    94ac:	8b 45 08             	mov    0x8(%ebp),%eax
    94af:	8b 40 3c             	mov    0x3c(%eax),%eax
    94b2:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    94b7:	c1 e0 02             	shl    $0x2,%eax
    94ba:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    94bd:	83 ec 0c             	sub    $0xc,%esp
    94c0:	ff 75 0c             	pushl  0xc(%ebp)
    94c3:	e8 54 a2 ff ff       	call   371c <alloc_string>
    94c8:	83 c4 10             	add    $0x10,%esp
    94cb:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    94cd:	8b 45 08             	mov    0x8(%ebp),%eax
    94d0:	8b 50 44             	mov    0x44(%eax),%edx
    94d3:	8b 45 08             	mov    0x8(%ebp),%eax
    94d6:	8b 40 3c             	mov    0x3c(%eax),%eax
    94d9:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    94de:	c1 e0 02             	shl    $0x2,%eax
    94e1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    94e4:	83 ec 08             	sub    $0x8,%esp
    94e7:	ff 75 14             	pushl  0x14(%ebp)
    94ea:	ff 75 10             	pushl  0x10(%ebp)
    94ed:	e8 e5 a1 ff ff       	call   36d7 <alloc_string_sized>
    94f2:	83 c4 10             	add    $0x10,%esp
    94f5:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    94f7:	8b 45 08             	mov    0x8(%ebp),%eax
    94fa:	8b 50 40             	mov    0x40(%eax),%edx
    94fd:	8b 45 08             	mov    0x8(%ebp),%eax
    9500:	8b 40 3c             	mov    0x3c(%eax),%eax
    9503:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9508:	c1 e0 02             	shl    $0x2,%eax
    950b:	01 d0                	add    %edx,%eax
    950d:	8b 00                	mov    (%eax),%eax
    950f:	85 c0                	test   %eax,%eax
    9511:	74 1c                	je     952f <lodepng_add_text_sized+0x115>
    9513:	8b 45 08             	mov    0x8(%ebp),%eax
    9516:	8b 50 44             	mov    0x44(%eax),%edx
    9519:	8b 45 08             	mov    0x8(%ebp),%eax
    951c:	8b 40 3c             	mov    0x3c(%eax),%eax
    951f:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9524:	c1 e0 02             	shl    $0x2,%eax
    9527:	01 d0                	add    %edx,%eax
    9529:	8b 00                	mov    (%eax),%eax
    952b:	85 c0                	test   %eax,%eax
    952d:	75 07                	jne    9536 <lodepng_add_text_sized+0x11c>
    952f:	b8 53 00 00 00       	mov    $0x53,%eax
    9534:	eb 05                	jmp    953b <lodepng_add_text_sized+0x121>

  return 0;
    9536:	b8 00 00 00 00       	mov    $0x0,%eax
}
    953b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    953e:	c9                   	leave  
    953f:	c3                   	ret    

00009540 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    9540:	55                   	push   %ebp
    9541:	89 e5                	mov    %esp,%ebp
    9543:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    9546:	ff 75 10             	pushl  0x10(%ebp)
    9549:	e8 0e 9f ff ff       	call   345c <lodepng_strlen>
    954e:	83 c4 04             	add    $0x4,%esp
    9551:	50                   	push   %eax
    9552:	ff 75 10             	pushl  0x10(%ebp)
    9555:	ff 75 0c             	pushl  0xc(%ebp)
    9558:	ff 75 08             	pushl  0x8(%ebp)
    955b:	e8 ba fe ff ff       	call   941a <lodepng_add_text_sized>
    9560:	83 c4 10             	add    $0x10,%esp
}
    9563:	c9                   	leave  
    9564:	c3                   	ret    

00009565 <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    9565:	55                   	push   %ebp
    9566:	89 e5                	mov    %esp,%ebp
    9568:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    956b:	83 ec 0c             	sub    $0xc,%esp
    956e:	ff 75 08             	pushl  0x8(%ebp)
    9571:	e8 a3 fd ff ff       	call   9319 <LodePNGText_cleanup>
    9576:	83 c4 10             	add    $0x10,%esp
}
    9579:	90                   	nop
    957a:	c9                   	leave  
    957b:	c3                   	ret    

0000957c <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    957c:	55                   	push   %ebp
    957d:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    957f:	8b 45 08             	mov    0x8(%ebp),%eax
    9582:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    9589:	8b 45 08             	mov    0x8(%ebp),%eax
    958c:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    9593:	8b 45 08             	mov    0x8(%ebp),%eax
    9596:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    959d:	8b 45 08             	mov    0x8(%ebp),%eax
    95a0:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    95a7:	8b 45 08             	mov    0x8(%ebp),%eax
    95aa:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    95b1:	90                   	nop
    95b2:	5d                   	pop    %ebp
    95b3:	c3                   	ret    

000095b4 <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    95b4:	55                   	push   %ebp
    95b5:	89 e5                	mov    %esp,%ebp
    95b7:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    95ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    95c1:	eb 6c                	jmp    962f <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    95c3:	8b 45 08             	mov    0x8(%ebp),%eax
    95c6:	8b 40 4c             	mov    0x4c(%eax),%eax
    95c9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    95cc:	c1 e2 02             	shl    $0x2,%edx
    95cf:	01 d0                	add    %edx,%eax
    95d1:	83 ec 0c             	sub    $0xc,%esp
    95d4:	50                   	push   %eax
    95d5:	e8 da a0 ff ff       	call   36b4 <string_cleanup>
    95da:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    95dd:	8b 45 08             	mov    0x8(%ebp),%eax
    95e0:	8b 40 50             	mov    0x50(%eax),%eax
    95e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    95e6:	c1 e2 02             	shl    $0x2,%edx
    95e9:	01 d0                	add    %edx,%eax
    95eb:	83 ec 0c             	sub    $0xc,%esp
    95ee:	50                   	push   %eax
    95ef:	e8 c0 a0 ff ff       	call   36b4 <string_cleanup>
    95f4:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    95f7:	8b 45 08             	mov    0x8(%ebp),%eax
    95fa:	8b 40 54             	mov    0x54(%eax),%eax
    95fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9600:	c1 e2 02             	shl    $0x2,%edx
    9603:	01 d0                	add    %edx,%eax
    9605:	83 ec 0c             	sub    $0xc,%esp
    9608:	50                   	push   %eax
    9609:	e8 a6 a0 ff ff       	call   36b4 <string_cleanup>
    960e:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    9611:	8b 45 08             	mov    0x8(%ebp),%eax
    9614:	8b 40 58             	mov    0x58(%eax),%eax
    9617:	8b 55 f4             	mov    -0xc(%ebp),%edx
    961a:	c1 e2 02             	shl    $0x2,%edx
    961d:	01 d0                	add    %edx,%eax
    961f:	83 ec 0c             	sub    $0xc,%esp
    9622:	50                   	push   %eax
    9623:	e8 8c a0 ff ff       	call   36b4 <string_cleanup>
    9628:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    962b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    962f:	8b 45 08             	mov    0x8(%ebp),%eax
    9632:	8b 40 48             	mov    0x48(%eax),%eax
    9635:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9638:	75 89                	jne    95c3 <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    963a:	8b 45 08             	mov    0x8(%ebp),%eax
    963d:	8b 40 4c             	mov    0x4c(%eax),%eax
    9640:	83 ec 0c             	sub    $0xc,%esp
    9643:	50                   	push   %eax
    9644:	e8 98 9d ff ff       	call   33e1 <lodepng_free>
    9649:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    964c:	8b 45 08             	mov    0x8(%ebp),%eax
    964f:	8b 40 50             	mov    0x50(%eax),%eax
    9652:	83 ec 0c             	sub    $0xc,%esp
    9655:	50                   	push   %eax
    9656:	e8 86 9d ff ff       	call   33e1 <lodepng_free>
    965b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    965e:	8b 45 08             	mov    0x8(%ebp),%eax
    9661:	8b 40 54             	mov    0x54(%eax),%eax
    9664:	83 ec 0c             	sub    $0xc,%esp
    9667:	50                   	push   %eax
    9668:	e8 74 9d ff ff       	call   33e1 <lodepng_free>
    966d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    9670:	8b 45 08             	mov    0x8(%ebp),%eax
    9673:	8b 40 58             	mov    0x58(%eax),%eax
    9676:	83 ec 0c             	sub    $0xc,%esp
    9679:	50                   	push   %eax
    967a:	e8 62 9d ff ff       	call   33e1 <lodepng_free>
    967f:	83 c4 10             	add    $0x10,%esp
}
    9682:	90                   	nop
    9683:	c9                   	leave  
    9684:	c3                   	ret    

00009685 <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9685:	55                   	push   %ebp
    9686:	89 e5                	mov    %esp,%ebp
    9688:	56                   	push   %esi
    9689:	53                   	push   %ebx
    968a:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    968d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    9694:	8b 45 08             	mov    0x8(%ebp),%eax
    9697:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    969e:	8b 45 08             	mov    0x8(%ebp),%eax
    96a1:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    96a8:	8b 45 08             	mov    0x8(%ebp),%eax
    96ab:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    96b2:	8b 45 08             	mov    0x8(%ebp),%eax
    96b5:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    96bc:	8b 45 08             	mov    0x8(%ebp),%eax
    96bf:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    96c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    96cd:	eb 64                	jmp    9733 <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    96cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    96d2:	8b 40 58             	mov    0x58(%eax),%eax
    96d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    96d8:	c1 e2 02             	shl    $0x2,%edx
    96db:	01 d0                	add    %edx,%eax
    96dd:	8b 18                	mov    (%eax),%ebx
    96df:	8b 45 0c             	mov    0xc(%ebp),%eax
    96e2:	8b 40 54             	mov    0x54(%eax),%eax
    96e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    96e8:	c1 e2 02             	shl    $0x2,%edx
    96eb:	01 d0                	add    %edx,%eax
    96ed:	8b 08                	mov    (%eax),%ecx
    96ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    96f2:	8b 40 50             	mov    0x50(%eax),%eax
    96f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    96f8:	c1 e2 02             	shl    $0x2,%edx
    96fb:	01 d0                	add    %edx,%eax
    96fd:	8b 10                	mov    (%eax),%edx
    96ff:	8b 45 0c             	mov    0xc(%ebp),%eax
    9702:	8b 40 4c             	mov    0x4c(%eax),%eax
    9705:	8b 75 f4             	mov    -0xc(%ebp),%esi
    9708:	c1 e6 02             	shl    $0x2,%esi
    970b:	01 f0                	add    %esi,%eax
    970d:	8b 00                	mov    (%eax),%eax
    970f:	83 ec 0c             	sub    $0xc,%esp
    9712:	53                   	push   %ebx
    9713:	51                   	push   %ecx
    9714:	52                   	push   %edx
    9715:	50                   	push   %eax
    9716:	ff 75 08             	pushl  0x8(%ebp)
    9719:	e8 e4 01 00 00       	call   9902 <lodepng_add_itext>
    971e:	83 c4 20             	add    $0x20,%esp
    9721:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9724:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9728:	74 05                	je     972f <LodePNGIText_copy+0xaa>
    972a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    972d:	eb 14                	jmp    9743 <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    972f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9733:	8b 45 0c             	mov    0xc(%ebp),%eax
    9736:	8b 40 48             	mov    0x48(%eax),%eax
    9739:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    973c:	75 91                	jne    96cf <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    973e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9743:	8d 65 f8             	lea    -0x8(%ebp),%esp
    9746:	5b                   	pop    %ebx
    9747:	5e                   	pop    %esi
    9748:	5d                   	pop    %ebp
    9749:	c3                   	ret    

0000974a <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    974a:	55                   	push   %ebp
    974b:	89 e5                	mov    %esp,%ebp
    974d:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    9750:	83 ec 0c             	sub    $0xc,%esp
    9753:	ff 75 08             	pushl  0x8(%ebp)
    9756:	e8 59 fe ff ff       	call   95b4 <LodePNGIText_cleanup>
    975b:	83 c4 10             	add    $0x10,%esp
}
    975e:	90                   	nop
    975f:	c9                   	leave  
    9760:	c3                   	ret    

00009761 <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    9761:	55                   	push   %ebp
    9762:	89 e5                	mov    %esp,%ebp
    9764:	53                   	push   %ebx
    9765:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    9768:	8b 45 08             	mov    0x8(%ebp),%eax
    976b:	8b 40 48             	mov    0x48(%eax),%eax
    976e:	83 c0 01             	add    $0x1,%eax
    9771:	c1 e0 02             	shl    $0x2,%eax
    9774:	89 c2                	mov    %eax,%edx
    9776:	8b 45 08             	mov    0x8(%ebp),%eax
    9779:	8b 40 4c             	mov    0x4c(%eax),%eax
    977c:	52                   	push   %edx
    977d:	50                   	push   %eax
    977e:	e8 54 9c ff ff       	call   33d7 <lodepng_realloc>
    9783:	83 c4 08             	add    $0x8,%esp
    9786:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    9789:	8b 45 08             	mov    0x8(%ebp),%eax
    978c:	8b 40 48             	mov    0x48(%eax),%eax
    978f:	83 c0 01             	add    $0x1,%eax
    9792:	c1 e0 02             	shl    $0x2,%eax
    9795:	89 c2                	mov    %eax,%edx
    9797:	8b 45 08             	mov    0x8(%ebp),%eax
    979a:	8b 40 50             	mov    0x50(%eax),%eax
    979d:	52                   	push   %edx
    979e:	50                   	push   %eax
    979f:	e8 33 9c ff ff       	call   33d7 <lodepng_realloc>
    97a4:	83 c4 08             	add    $0x8,%esp
    97a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    97aa:	8b 45 08             	mov    0x8(%ebp),%eax
    97ad:	8b 40 48             	mov    0x48(%eax),%eax
    97b0:	83 c0 01             	add    $0x1,%eax
    97b3:	c1 e0 02             	shl    $0x2,%eax
    97b6:	89 c2                	mov    %eax,%edx
    97b8:	8b 45 08             	mov    0x8(%ebp),%eax
    97bb:	8b 40 54             	mov    0x54(%eax),%eax
    97be:	52                   	push   %edx
    97bf:	50                   	push   %eax
    97c0:	e8 12 9c ff ff       	call   33d7 <lodepng_realloc>
    97c5:	83 c4 08             	add    $0x8,%esp
    97c8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    97cb:	8b 45 08             	mov    0x8(%ebp),%eax
    97ce:	8b 40 48             	mov    0x48(%eax),%eax
    97d1:	83 c0 01             	add    $0x1,%eax
    97d4:	c1 e0 02             	shl    $0x2,%eax
    97d7:	89 c2                	mov    %eax,%edx
    97d9:	8b 45 08             	mov    0x8(%ebp),%eax
    97dc:	8b 40 58             	mov    0x58(%eax),%eax
    97df:	52                   	push   %edx
    97e0:	50                   	push   %eax
    97e1:	e8 f1 9b ff ff       	call   33d7 <lodepng_realloc>
    97e6:	83 c4 08             	add    $0x8,%esp
    97e9:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    97ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    97f0:	74 09                	je     97fb <lodepng_add_itext_sized+0x9a>
    97f2:	8b 45 08             	mov    0x8(%ebp),%eax
    97f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    97f8:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    97fb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    97ff:	74 09                	je     980a <lodepng_add_itext_sized+0xa9>
    9801:	8b 45 08             	mov    0x8(%ebp),%eax
    9804:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9807:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    980a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    980e:	74 09                	je     9819 <lodepng_add_itext_sized+0xb8>
    9810:	8b 45 08             	mov    0x8(%ebp),%eax
    9813:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9816:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    9819:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    981d:	74 09                	je     9828 <lodepng_add_itext_sized+0xc7>
    981f:	8b 45 08             	mov    0x8(%ebp),%eax
    9822:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9825:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    9828:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    982c:	74 12                	je     9840 <lodepng_add_itext_sized+0xdf>
    982e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9832:	74 0c                	je     9840 <lodepng_add_itext_sized+0xdf>
    9834:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9838:	74 06                	je     9840 <lodepng_add_itext_sized+0xdf>
    983a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    983e:	75 0a                	jne    984a <lodepng_add_itext_sized+0xe9>
    9840:	b8 53 00 00 00       	mov    $0x53,%eax
    9845:	e9 b3 00 00 00       	jmp    98fd <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    984a:	8b 45 08             	mov    0x8(%ebp),%eax
    984d:	8b 40 48             	mov    0x48(%eax),%eax
    9850:	8d 50 01             	lea    0x1(%eax),%edx
    9853:	8b 45 08             	mov    0x8(%ebp),%eax
    9856:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    9859:	8b 45 08             	mov    0x8(%ebp),%eax
    985c:	8b 50 4c             	mov    0x4c(%eax),%edx
    985f:	8b 45 08             	mov    0x8(%ebp),%eax
    9862:	8b 40 48             	mov    0x48(%eax),%eax
    9865:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    986a:	c1 e0 02             	shl    $0x2,%eax
    986d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9870:	83 ec 0c             	sub    $0xc,%esp
    9873:	ff 75 0c             	pushl  0xc(%ebp)
    9876:	e8 a1 9e ff ff       	call   371c <alloc_string>
    987b:	83 c4 10             	add    $0x10,%esp
    987e:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    9880:	8b 45 08             	mov    0x8(%ebp),%eax
    9883:	8b 50 50             	mov    0x50(%eax),%edx
    9886:	8b 45 08             	mov    0x8(%ebp),%eax
    9889:	8b 40 48             	mov    0x48(%eax),%eax
    988c:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9891:	c1 e0 02             	shl    $0x2,%eax
    9894:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9897:	83 ec 0c             	sub    $0xc,%esp
    989a:	ff 75 10             	pushl  0x10(%ebp)
    989d:	e8 7a 9e ff ff       	call   371c <alloc_string>
    98a2:	83 c4 10             	add    $0x10,%esp
    98a5:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    98a7:	8b 45 08             	mov    0x8(%ebp),%eax
    98aa:	8b 50 54             	mov    0x54(%eax),%edx
    98ad:	8b 45 08             	mov    0x8(%ebp),%eax
    98b0:	8b 40 48             	mov    0x48(%eax),%eax
    98b3:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    98b8:	c1 e0 02             	shl    $0x2,%eax
    98bb:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    98be:	83 ec 0c             	sub    $0xc,%esp
    98c1:	ff 75 14             	pushl  0x14(%ebp)
    98c4:	e8 53 9e ff ff       	call   371c <alloc_string>
    98c9:	83 c4 10             	add    $0x10,%esp
    98cc:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    98ce:	8b 45 08             	mov    0x8(%ebp),%eax
    98d1:	8b 50 58             	mov    0x58(%eax),%edx
    98d4:	8b 45 08             	mov    0x8(%ebp),%eax
    98d7:	8b 40 48             	mov    0x48(%eax),%eax
    98da:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    98df:	c1 e0 02             	shl    $0x2,%eax
    98e2:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    98e5:	83 ec 08             	sub    $0x8,%esp
    98e8:	ff 75 1c             	pushl  0x1c(%ebp)
    98eb:	ff 75 18             	pushl  0x18(%ebp)
    98ee:	e8 e4 9d ff ff       	call   36d7 <alloc_string_sized>
    98f3:	83 c4 10             	add    $0x10,%esp
    98f6:	89 03                	mov    %eax,(%ebx)

  return 0;
    98f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    98fd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9900:	c9                   	leave  
    9901:	c3                   	ret    

00009902 <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    9902:	55                   	push   %ebp
    9903:	89 e5                	mov    %esp,%ebp
    9905:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    9908:	ff 75 18             	pushl  0x18(%ebp)
    990b:	e8 4c 9b ff ff       	call   345c <lodepng_strlen>
    9910:	83 c4 04             	add    $0x4,%esp
    9913:	83 ec 08             	sub    $0x8,%esp
    9916:	50                   	push   %eax
    9917:	ff 75 18             	pushl  0x18(%ebp)
    991a:	ff 75 14             	pushl  0x14(%ebp)
    991d:	ff 75 10             	pushl  0x10(%ebp)
    9920:	ff 75 0c             	pushl  0xc(%ebp)
    9923:	ff 75 08             	pushl  0x8(%ebp)
    9926:	e8 36 fe ff ff       	call   9761 <lodepng_add_itext_sized>
    992b:	83 c4 20             	add    $0x20,%esp
}
    992e:	c9                   	leave  
    992f:	c3                   	ret    

00009930 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9930:	55                   	push   %ebp
    9931:	89 e5                	mov    %esp,%ebp
    9933:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    9936:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    993a:	75 0a                	jne    9946 <lodepng_assign_icc+0x16>
    993c:	b8 64 00 00 00       	mov    $0x64,%eax
    9941:	e9 81 00 00 00       	jmp    99c7 <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    9946:	83 ec 0c             	sub    $0xc,%esp
    9949:	ff 75 0c             	pushl  0xc(%ebp)
    994c:	e8 cb 9d ff ff       	call   371c <alloc_string>
    9951:	83 c4 10             	add    $0x10,%esp
    9954:	89 c2                	mov    %eax,%edx
    9956:	8b 45 08             	mov    0x8(%ebp),%eax
    9959:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    995f:	8b 45 14             	mov    0x14(%ebp),%eax
    9962:	83 ec 0c             	sub    $0xc,%esp
    9965:	50                   	push   %eax
    9966:	e8 55 9a ff ff       	call   33c0 <lodepng_malloc>
    996b:	83 c4 10             	add    $0x10,%esp
    996e:	89 c2                	mov    %eax,%edx
    9970:	8b 45 08             	mov    0x8(%ebp),%eax
    9973:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    9979:	8b 45 08             	mov    0x8(%ebp),%eax
    997c:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9982:	85 c0                	test   %eax,%eax
    9984:	74 0d                	je     9993 <lodepng_assign_icc+0x63>
    9986:	8b 45 08             	mov    0x8(%ebp),%eax
    9989:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    998f:	85 c0                	test   %eax,%eax
    9991:	75 07                	jne    999a <lodepng_assign_icc+0x6a>
    9993:	b8 53 00 00 00       	mov    $0x53,%eax
    9998:	eb 2d                	jmp    99c7 <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    999a:	8b 55 14             	mov    0x14(%ebp),%edx
    999d:	8b 45 08             	mov    0x8(%ebp),%eax
    99a0:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    99a6:	83 ec 04             	sub    $0x4,%esp
    99a9:	52                   	push   %edx
    99aa:	ff 75 10             	pushl  0x10(%ebp)
    99ad:	50                   	push   %eax
    99ae:	e8 4b 9a ff ff       	call   33fe <lodepng_memcpy>
    99b3:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    99b6:	8b 45 08             	mov    0x8(%ebp),%eax
    99b9:	8b 55 14             	mov    0x14(%ebp),%edx
    99bc:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    99c2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    99c7:	c9                   	leave  
    99c8:	c3                   	ret    

000099c9 <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    99c9:	55                   	push   %ebp
    99ca:	89 e5                	mov    %esp,%ebp
    99cc:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    99cf:	8b 45 08             	mov    0x8(%ebp),%eax
    99d2:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    99d8:	85 c0                	test   %eax,%eax
    99da:	74 0e                	je     99ea <lodepng_set_icc+0x21>
    99dc:	83 ec 0c             	sub    $0xc,%esp
    99df:	ff 75 08             	pushl  0x8(%ebp)
    99e2:	e8 26 00 00 00       	call   9a0d <lodepng_clear_icc>
    99e7:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    99ea:	8b 45 08             	mov    0x8(%ebp),%eax
    99ed:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    99f4:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    99f7:	ff 75 14             	pushl  0x14(%ebp)
    99fa:	ff 75 10             	pushl  0x10(%ebp)
    99fd:	ff 75 0c             	pushl  0xc(%ebp)
    9a00:	ff 75 08             	pushl  0x8(%ebp)
    9a03:	e8 28 ff ff ff       	call   9930 <lodepng_assign_icc>
    9a08:	83 c4 10             	add    $0x10,%esp
}
    9a0b:	c9                   	leave  
    9a0c:	c3                   	ret    

00009a0d <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    9a0d:	55                   	push   %ebp
    9a0e:	89 e5                	mov    %esp,%ebp
    9a10:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    9a13:	8b 45 08             	mov    0x8(%ebp),%eax
    9a16:	05 c0 00 00 00       	add    $0xc0,%eax
    9a1b:	83 ec 0c             	sub    $0xc,%esp
    9a1e:	50                   	push   %eax
    9a1f:	e8 90 9c ff ff       	call   36b4 <string_cleanup>
    9a24:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    9a27:	8b 45 08             	mov    0x8(%ebp),%eax
    9a2a:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9a30:	83 ec 0c             	sub    $0xc,%esp
    9a33:	50                   	push   %eax
    9a34:	e8 a8 99 ff ff       	call   33e1 <lodepng_free>
    9a39:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    9a3c:	8b 45 08             	mov    0x8(%ebp),%eax
    9a3f:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9a46:	00 00 00 
  info->iccp_profile_size = 0;
    9a49:	8b 45 08             	mov    0x8(%ebp),%eax
    9a4c:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    9a53:	00 00 00 
  info->iccp_defined = 0;
    9a56:	8b 45 08             	mov    0x8(%ebp),%eax
    9a59:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9a60:	00 00 00 
}
    9a63:	90                   	nop
    9a64:	c9                   	leave  
    9a65:	c3                   	ret    

00009a66 <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    9a66:	55                   	push   %ebp
    9a67:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    9a69:	8b 45 08             	mov    0x8(%ebp),%eax
    9a6c:	83 c0 0c             	add    $0xc,%eax
    9a6f:	50                   	push   %eax
    9a70:	e8 5a f0 ff ff       	call   8acf <lodepng_color_mode_init>
    9a75:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    9a78:	8b 45 08             	mov    0x8(%ebp),%eax
    9a7b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    9a82:	8b 45 08             	mov    0x8(%ebp),%eax
    9a85:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    9a8b:	8b 45 08             	mov    0x8(%ebp),%eax
    9a8e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    9a95:	8b 45 08             	mov    0x8(%ebp),%eax
    9a98:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    9a9f:	8b 45 08             	mov    0x8(%ebp),%eax
    9aa2:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    9aa9:	8b 45 08             	mov    0x8(%ebp),%eax
    9aac:	8b 50 38             	mov    0x38(%eax),%edx
    9aaf:	8b 45 08             	mov    0x8(%ebp),%eax
    9ab2:	89 50 34             	mov    %edx,0x34(%eax)
    9ab5:	8b 45 08             	mov    0x8(%ebp),%eax
    9ab8:	8b 50 34             	mov    0x34(%eax),%edx
    9abb:	8b 45 08             	mov    0x8(%ebp),%eax
    9abe:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    9ac1:	ff 75 08             	pushl  0x8(%ebp)
    9ac4:	e8 2c f8 ff ff       	call   92f5 <LodePNGText_init>
    9ac9:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    9acc:	ff 75 08             	pushl  0x8(%ebp)
    9acf:	e8 a8 fa ff ff       	call   957c <LodePNGIText_init>
    9ad4:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    9ad7:	8b 45 08             	mov    0x8(%ebp),%eax
    9ada:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    9ae1:	8b 45 08             	mov    0x8(%ebp),%eax
    9ae4:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    9aeb:	8b 45 08             	mov    0x8(%ebp),%eax
    9aee:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    9af5:	00 00 00 
  info->chrm_defined = 0;
    9af8:	8b 45 08             	mov    0x8(%ebp),%eax
    9afb:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    9b02:	00 00 00 
  info->srgb_defined = 0;
    9b05:	8b 45 08             	mov    0x8(%ebp),%eax
    9b08:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    9b0f:	00 00 00 
  info->iccp_defined = 0;
    9b12:	8b 45 08             	mov    0x8(%ebp),%eax
    9b15:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9b1c:	00 00 00 
  info->iccp_name = NULL;
    9b1f:	8b 45 08             	mov    0x8(%ebp),%eax
    9b22:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    9b29:	00 00 00 
  info->iccp_profile = NULL;
    9b2c:	8b 45 08             	mov    0x8(%ebp),%eax
    9b2f:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9b36:	00 00 00 

  LodePNGUnknownChunks_init(info);
    9b39:	ff 75 08             	pushl  0x8(%ebp)
    9b3c:	e8 46 f6 ff ff       	call   9187 <LodePNGUnknownChunks_init>
    9b41:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9b44:	90                   	nop
    9b45:	c9                   	leave  
    9b46:	c3                   	ret    

00009b47 <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    9b47:	55                   	push   %ebp
    9b48:	89 e5                	mov    %esp,%ebp
    9b4a:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    9b4d:	8b 45 08             	mov    0x8(%ebp),%eax
    9b50:	83 c0 0c             	add    $0xc,%eax
    9b53:	83 ec 0c             	sub    $0xc,%esp
    9b56:	50                   	push   %eax
    9b57:	e8 66 f0 ff ff       	call   8bc2 <lodepng_color_mode_cleanup>
    9b5c:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    9b5f:	83 ec 0c             	sub    $0xc,%esp
    9b62:	ff 75 08             	pushl  0x8(%ebp)
    9b65:	e8 af f7 ff ff       	call   9319 <LodePNGText_cleanup>
    9b6a:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    9b6d:	83 ec 0c             	sub    $0xc,%esp
    9b70:	ff 75 08             	pushl  0x8(%ebp)
    9b73:	e8 3c fa ff ff       	call   95b4 <LodePNGIText_cleanup>
    9b78:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    9b7b:	83 ec 0c             	sub    $0xc,%esp
    9b7e:	ff 75 08             	pushl  0x8(%ebp)
    9b81:	e8 87 fe ff ff       	call   9a0d <lodepng_clear_icc>
    9b86:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    9b89:	83 ec 0c             	sub    $0xc,%esp
    9b8c:	ff 75 08             	pushl  0x8(%ebp)
    9b8f:	e8 44 f6 ff ff       	call   91d8 <LodePNGUnknownChunks_cleanup>
    9b94:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9b97:	90                   	nop
    9b98:	c9                   	leave  
    9b99:	c3                   	ret    

00009b9a <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9b9a:	55                   	push   %ebp
    9b9b:	89 e5                	mov    %esp,%ebp
    9b9d:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    9ba0:	83 ec 0c             	sub    $0xc,%esp
    9ba3:	ff 75 08             	pushl  0x8(%ebp)
    9ba6:	e8 9c ff ff ff       	call   9b47 <lodepng_info_cleanup>
    9bab:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    9bae:	83 ec 04             	sub    $0x4,%esp
    9bb1:	68 e4 00 00 00       	push   $0xe4
    9bb6:	ff 75 0c             	pushl  0xc(%ebp)
    9bb9:	ff 75 08             	pushl  0x8(%ebp)
    9bbc:	e8 3d 98 ff ff       	call   33fe <lodepng_memcpy>
    9bc1:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    9bc4:	8b 45 08             	mov    0x8(%ebp),%eax
    9bc7:	83 c0 0c             	add    $0xc,%eax
    9bca:	83 ec 0c             	sub    $0xc,%esp
    9bcd:	50                   	push   %eax
    9bce:	e8 fc ee ff ff       	call   8acf <lodepng_color_mode_init>
    9bd3:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    9bd6:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bd9:	8d 50 0c             	lea    0xc(%eax),%edx
    9bdc:	8b 45 08             	mov    0x8(%ebp),%eax
    9bdf:	83 c0 0c             	add    $0xc,%eax
    9be2:	83 ec 08             	sub    $0x8,%esp
    9be5:	52                   	push   %edx
    9be6:	50                   	push   %eax
    9be7:	e8 ed ef ff ff       	call   8bd9 <lodepng_color_mode_copy>
    9bec:	83 c4 10             	add    $0x10,%esp
    9bef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    9bf2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9bf6:	74 08                	je     9c00 <lodepng_info_copy+0x66>
    9bf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9bfb:	e9 b7 00 00 00       	jmp    9cb7 <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    9c00:	83 ec 08             	sub    $0x8,%esp
    9c03:	ff 75 0c             	pushl  0xc(%ebp)
    9c06:	ff 75 08             	pushl  0x8(%ebp)
    9c09:	e8 84 f7 ff ff       	call   9392 <LodePNGText_copy>
    9c0e:	83 c4 10             	add    $0x10,%esp
    9c11:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9c14:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9c18:	74 08                	je     9c22 <lodepng_info_copy+0x88>
    9c1a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9c1d:	e9 95 00 00 00       	jmp    9cb7 <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    9c22:	83 ec 08             	sub    $0x8,%esp
    9c25:	ff 75 0c             	pushl  0xc(%ebp)
    9c28:	ff 75 08             	pushl  0x8(%ebp)
    9c2b:	e8 55 fa ff ff       	call   9685 <LodePNGIText_copy>
    9c30:	83 c4 10             	add    $0x10,%esp
    9c33:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9c36:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9c3a:	74 05                	je     9c41 <lodepng_info_copy+0xa7>
    9c3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9c3f:	eb 76                	jmp    9cb7 <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    9c41:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c44:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    9c4a:	85 c0                	test   %eax,%eax
    9c4c:	74 37                	je     9c85 <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    9c4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c51:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    9c57:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c5a:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    9c60:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c63:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9c69:	51                   	push   %ecx
    9c6a:	52                   	push   %edx
    9c6b:	50                   	push   %eax
    9c6c:	ff 75 08             	pushl  0x8(%ebp)
    9c6f:	e8 bc fc ff ff       	call   9930 <lodepng_assign_icc>
    9c74:	83 c4 10             	add    $0x10,%esp
    9c77:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9c7a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9c7e:	74 05                	je     9c85 <lodepng_info_copy+0xeb>
    9c80:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9c83:	eb 32                	jmp    9cb7 <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    9c85:	83 ec 0c             	sub    $0xc,%esp
    9c88:	ff 75 08             	pushl  0x8(%ebp)
    9c8b:	e8 f7 f4 ff ff       	call   9187 <LodePNGUnknownChunks_init>
    9c90:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    9c93:	83 ec 08             	sub    $0x8,%esp
    9c96:	ff 75 0c             	pushl  0xc(%ebp)
    9c99:	ff 75 08             	pushl  0x8(%ebp)
    9c9c:	e8 6c f5 ff ff       	call   920d <LodePNGUnknownChunks_copy>
    9ca1:	83 c4 10             	add    $0x10,%esp
    9ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9ca7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    9cab:	74 05                	je     9cb2 <lodepng_info_copy+0x118>
    9cad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9cb0:	eb 05                	jmp    9cb7 <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    9cb2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9cb7:	c9                   	leave  
    9cb8:	c3                   	ret    

00009cb9 <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    9cb9:	55                   	push   %ebp
    9cba:	89 e5                	mov    %esp,%ebp
    9cbc:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    9cbf:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    9cc3:	74 14                	je     9cd9 <addColorBits+0x20>
    9cc5:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    9cc9:	75 07                	jne    9cd2 <addColorBits+0x19>
    9ccb:	b8 03 00 00 00       	mov    $0x3,%eax
    9cd0:	eb 0c                	jmp    9cde <addColorBits+0x25>
    9cd2:	b8 01 00 00 00       	mov    $0x1,%eax
    9cd7:	eb 05                	jmp    9cde <addColorBits+0x25>
    9cd9:	b8 07 00 00 00       	mov    $0x7,%eax
    9cde:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    9ce1:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ce4:	23 45 fc             	and    -0x4(%ebp),%eax
    9ce7:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    9cea:	8b 45 10             	mov    0x10(%ebp),%eax
    9ced:	ba 01 00 00 00       	mov    $0x1,%edx
    9cf2:	89 c1                	mov    %eax,%ecx
    9cf4:	d3 e2                	shl    %cl,%edx
    9cf6:	89 d0                	mov    %edx,%eax
    9cf8:	83 e8 01             	sub    $0x1,%eax
    9cfb:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    9cfe:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9d01:	2b 45 f8             	sub    -0x8(%ebp),%eax
    9d04:	0f af 45 10          	imul   0x10(%ebp),%eax
    9d08:	89 c1                	mov    %eax,%ecx
    9d0a:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    9d0d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    9d11:	75 18                	jne    9d2b <addColorBits+0x72>
    9d13:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d16:	0f af 45 10          	imul   0x10(%ebp),%eax
    9d1a:	c1 e8 03             	shr    $0x3,%eax
    9d1d:	89 c2                	mov    %eax,%edx
    9d1f:	8b 45 08             	mov    0x8(%ebp),%eax
    9d22:	01 d0                	add    %edx,%eax
    9d24:	8b 55 14             	mov    0x14(%ebp),%edx
    9d27:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    9d29:	eb 1e                	jmp    9d49 <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    9d2b:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d2e:	0f af 45 10          	imul   0x10(%ebp),%eax
    9d32:	c1 e8 03             	shr    $0x3,%eax
    9d35:	8b 55 08             	mov    0x8(%ebp),%edx
    9d38:	01 c2                	add    %eax,%edx
    9d3a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9d3d:	01 c8                	add    %ecx,%eax
    9d3f:	0f b6 08             	movzbl (%eax),%ecx
    9d42:	8b 45 14             	mov    0x14(%ebp),%eax
    9d45:	09 c8                	or     %ecx,%eax
    9d47:	88 02                	mov    %al,(%edx)
}
    9d49:	90                   	nop
    9d4a:	c9                   	leave  
    9d4b:	c3                   	ret    

00009d4c <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    9d4c:	55                   	push   %ebp
    9d4d:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    9d4f:	8b 45 08             	mov    0x8(%ebp),%eax
    9d52:	6a 40                	push   $0x40
    9d54:	6a 00                	push   $0x0
    9d56:	50                   	push   %eax
    9d57:	e8 d5 96 ff ff       	call   3431 <lodepng_memset>
    9d5c:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    9d5f:	8b 45 08             	mov    0x8(%ebp),%eax
    9d62:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    9d69:	90                   	nop
    9d6a:	c9                   	leave  
    9d6b:	c3                   	ret    

00009d6c <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    9d6c:	55                   	push   %ebp
    9d6d:	89 e5                	mov    %esp,%ebp
    9d6f:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    9d72:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9d79:	eb 3b                	jmp    9db6 <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    9d7b:	8b 45 08             	mov    0x8(%ebp),%eax
    9d7e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d81:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9d84:	85 c0                	test   %eax,%eax
    9d86:	74 2a                	je     9db2 <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    9d88:	8b 45 08             	mov    0x8(%ebp),%eax
    9d8b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d8e:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9d91:	83 ec 0c             	sub    $0xc,%esp
    9d94:	50                   	push   %eax
    9d95:	e8 d2 ff ff ff       	call   9d6c <color_tree_cleanup>
    9d9a:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    9d9d:	8b 45 08             	mov    0x8(%ebp),%eax
    9da0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9da3:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9da6:	83 ec 0c             	sub    $0xc,%esp
    9da9:	50                   	push   %eax
    9daa:	e8 32 96 ff ff       	call   33e1 <lodepng_free>
    9daf:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    9db2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9db6:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    9dba:	75 bf                	jne    9d7b <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    9dbc:	90                   	nop
    9dbd:	c9                   	leave  
    9dbe:	c3                   	ret    

00009dbf <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9dbf:	55                   	push   %ebp
    9dc0:	89 e5                	mov    %esp,%ebp
    9dc2:	53                   	push   %ebx
    9dc3:	83 ec 20             	sub    $0x20,%esp
    9dc6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9dc9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9dcc:	8b 55 14             	mov    0x14(%ebp),%edx
    9dcf:	8b 45 18             	mov    0x18(%ebp),%eax
    9dd2:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9dd5:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9dd8:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9ddb:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    9dde:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    9de5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    9dec:	eb 76                	jmp    9e64 <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9dee:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    9df2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9df5:	89 c1                	mov    %eax,%ecx
    9df7:	d3 fa                	sar    %cl,%edx
    9df9:	89 d0                	mov    %edx,%eax
    9dfb:	83 e0 01             	and    $0x1,%eax
    9dfe:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e01:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9e05:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9e08:	89 c1                	mov    %eax,%ecx
    9e0a:	d3 fa                	sar    %cl,%edx
    9e0c:	89 d0                	mov    %edx,%eax
    9e0e:	83 e0 01             	and    $0x1,%eax
    9e11:	01 d8                	add    %ebx,%eax
    9e13:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e16:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9e1a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9e1d:	89 c1                	mov    %eax,%ecx
    9e1f:	d3 fa                	sar    %cl,%edx
    9e21:	89 d0                	mov    %edx,%eax
    9e23:	83 e0 01             	and    $0x1,%eax
    9e26:	01 d8                	add    %ebx,%eax
    9e28:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e2b:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9e2f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9e32:	89 c1                	mov    %eax,%ecx
    9e34:	d3 fa                	sar    %cl,%edx
    9e36:	89 d0                	mov    %edx,%eax
    9e38:	83 e0 01             	and    $0x1,%eax
    9e3b:	01 d8                	add    %ebx,%eax
    9e3d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    9e40:	8b 45 08             	mov    0x8(%ebp),%eax
    9e43:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e46:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9e49:	85 c0                	test   %eax,%eax
    9e4b:	75 07                	jne    9e54 <color_tree_get+0x95>
    9e4d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9e52:	eb 2a                	jmp    9e7e <color_tree_get+0xbf>
    else tree = tree->children[i];
    9e54:	8b 45 08             	mov    0x8(%ebp),%eax
    9e57:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e5a:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9e5d:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    9e60:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    9e64:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    9e68:	7e 84                	jle    9dee <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    9e6a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    9e6e:	74 08                	je     9e78 <color_tree_get+0xb9>
    9e70:	8b 45 08             	mov    0x8(%ebp),%eax
    9e73:	8b 40 40             	mov    0x40(%eax),%eax
    9e76:	eb 05                	jmp    9e7d <color_tree_get+0xbe>
    9e78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9e7d:	90                   	nop
}
    9e7e:	83 c4 20             	add    $0x20,%esp
    9e81:	5b                   	pop    %ebx
    9e82:	5d                   	pop    %ebp
    9e83:	c3                   	ret    

00009e84 <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9e84:	55                   	push   %ebp
    9e85:	89 e5                	mov    %esp,%ebp
    9e87:	53                   	push   %ebx
    9e88:	83 ec 10             	sub    $0x10,%esp
    9e8b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9e8e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9e91:	8b 55 14             	mov    0x14(%ebp),%edx
    9e94:	8b 45 18             	mov    0x18(%ebp),%eax
    9e97:	88 5d f8             	mov    %bl,-0x8(%ebp)
    9e9a:	88 4d f4             	mov    %cl,-0xc(%ebp)
    9e9d:	88 55 f0             	mov    %dl,-0x10(%ebp)
    9ea0:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    9ea3:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    9ea7:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    9eab:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    9eaf:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    9eb3:	53                   	push   %ebx
    9eb4:	51                   	push   %ecx
    9eb5:	52                   	push   %edx
    9eb6:	50                   	push   %eax
    9eb7:	ff 75 08             	pushl  0x8(%ebp)
    9eba:	e8 00 ff ff ff       	call   9dbf <color_tree_get>
    9ebf:	83 c4 14             	add    $0x14,%esp
    9ec2:	f7 d0                	not    %eax
    9ec4:	c1 e8 1f             	shr    $0x1f,%eax
    9ec7:	0f b6 c0             	movzbl %al,%eax
}
    9eca:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9ecd:	c9                   	leave  
    9ece:	c3                   	ret    

00009ecf <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    9ecf:	55                   	push   %ebp
    9ed0:	89 e5                	mov    %esp,%ebp
    9ed2:	53                   	push   %ebx
    9ed3:	83 ec 24             	sub    $0x24,%esp
    9ed6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9ed9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9edc:	8b 55 14             	mov    0x14(%ebp),%edx
    9edf:	8b 45 18             	mov    0x18(%ebp),%eax
    9ee2:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    9ee5:	88 4d e0             	mov    %cl,-0x20(%ebp)
    9ee8:	88 55 dc             	mov    %dl,-0x24(%ebp)
    9eeb:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9eee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9ef5:	e9 b0 00 00 00       	jmp    9faa <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9efa:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9efe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f01:	89 c1                	mov    %eax,%ecx
    9f03:	d3 fa                	sar    %cl,%edx
    9f05:	89 d0                	mov    %edx,%eax
    9f07:	83 e0 01             	and    $0x1,%eax
    9f0a:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9f0d:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9f11:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f14:	89 c1                	mov    %eax,%ecx
    9f16:	d3 fa                	sar    %cl,%edx
    9f18:	89 d0                	mov    %edx,%eax
    9f1a:	83 e0 01             	and    $0x1,%eax
    9f1d:	01 d8                	add    %ebx,%eax
    9f1f:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9f22:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9f26:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f29:	89 c1                	mov    %eax,%ecx
    9f2b:	d3 fa                	sar    %cl,%edx
    9f2d:	89 d0                	mov    %edx,%eax
    9f2f:	83 e0 01             	and    $0x1,%eax
    9f32:	01 d8                	add    %ebx,%eax
    9f34:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9f37:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    9f3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f3e:	89 c1                	mov    %eax,%ecx
    9f40:	d3 fa                	sar    %cl,%edx
    9f42:	89 d0                	mov    %edx,%eax
    9f44:	83 e0 01             	and    $0x1,%eax
    9f47:	01 d8                	add    %ebx,%eax
    9f49:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    9f4c:	8b 45 08             	mov    0x8(%ebp),%eax
    9f4f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f52:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9f55:	85 c0                	test   %eax,%eax
    9f57:	75 41                	jne    9f9a <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    9f59:	83 ec 0c             	sub    $0xc,%esp
    9f5c:	6a 44                	push   $0x44
    9f5e:	e8 5d 94 ff ff       	call   33c0 <lodepng_malloc>
    9f63:	83 c4 10             	add    $0x10,%esp
    9f66:	89 c1                	mov    %eax,%ecx
    9f68:	8b 45 08             	mov    0x8(%ebp),%eax
    9f6b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f6e:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    9f71:	8b 45 08             	mov    0x8(%ebp),%eax
    9f74:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f77:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9f7a:	85 c0                	test   %eax,%eax
    9f7c:	75 07                	jne    9f85 <color_tree_add+0xb6>
    9f7e:	b8 53 00 00 00       	mov    $0x53,%eax
    9f83:	eb 3d                	jmp    9fc2 <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    9f85:	8b 45 08             	mov    0x8(%ebp),%eax
    9f88:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f8b:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9f8e:	83 ec 0c             	sub    $0xc,%esp
    9f91:	50                   	push   %eax
    9f92:	e8 b5 fd ff ff       	call   9d4c <color_tree_init>
    9f97:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    9f9a:	8b 45 08             	mov    0x8(%ebp),%eax
    9f9d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9fa0:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9fa3:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9fa6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9faa:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    9fae:	0f 8e 46 ff ff ff    	jle    9efa <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    9fb4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    9fb7:	8b 45 08             	mov    0x8(%ebp),%eax
    9fba:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    9fbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9fc2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9fc5:	c9                   	leave  
    9fc6:	c3                   	ret    

00009fc7 <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9fc7:	55                   	push   %ebp
    9fc8:	89 e5                	mov    %esp,%ebp
    9fca:	53                   	push   %ebx
    9fcb:	83 ec 20             	sub    $0x20,%esp
    9fce:	8b 5d 18             	mov    0x18(%ebp),%ebx
    9fd1:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    9fd4:	8b 55 20             	mov    0x20(%ebp),%edx
    9fd7:	8b 45 24             	mov    0x24(%ebp),%eax
    9fda:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9fdd:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9fe0:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9fe3:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    9fe6:	8b 45 10             	mov    0x10(%ebp),%eax
    9fe9:	8b 00                	mov    (%eax),%eax
    9feb:	85 c0                	test   %eax,%eax
    9fed:	0f 85 ad 00 00 00    	jne    a0a0 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    9ff3:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    9ff7:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    9ffa:	8b 45 10             	mov    0x10(%ebp),%eax
    9ffd:	8b 40 04             	mov    0x4(%eax),%eax
    a000:	83 f8 08             	cmp    $0x8,%eax
    a003:	75 13                	jne    a018 <rgba8ToPixel+0x51>
    a005:	8b 55 0c             	mov    0xc(%ebp),%edx
    a008:	8b 45 08             	mov    0x8(%ebp),%eax
    a00b:	01 c2                	add    %eax,%edx
    a00d:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    a011:	88 02                	mov    %al,(%edx)
    a013:	e9 b4 03 00 00       	jmp    a3cc <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    a018:	8b 45 10             	mov    0x10(%ebp),%eax
    a01b:	8b 40 04             	mov    0x4(%eax),%eax
    a01e:	83 f8 10             	cmp    $0x10,%eax
    a021:	75 2a                	jne    a04d <rgba8ToPixel+0x86>
    a023:	8b 45 0c             	mov    0xc(%ebp),%eax
    a026:	01 c0                	add    %eax,%eax
    a028:	89 c2                	mov    %eax,%edx
    a02a:	8b 45 08             	mov    0x8(%ebp),%eax
    a02d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a030:	8b 45 0c             	mov    0xc(%ebp),%eax
    a033:	01 c0                	add    %eax,%eax
    a035:	8d 50 01             	lea    0x1(%eax),%edx
    a038:	8b 45 08             	mov    0x8(%ebp),%eax
    a03b:	01 d0                	add    %edx,%eax
    a03d:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a041:	88 10                	mov    %dl,(%eax)
    a043:	0f b6 00             	movzbl (%eax),%eax
    a046:	88 01                	mov    %al,(%ecx)
    a048:	e9 7f 03 00 00       	jmp    a3cc <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    a04d:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a051:	8b 45 10             	mov    0x10(%ebp),%eax
    a054:	8b 40 04             	mov    0x4(%eax),%eax
    a057:	b9 08 00 00 00       	mov    $0x8,%ecx
    a05c:	29 c1                	sub    %eax,%ecx
    a05e:	89 c8                	mov    %ecx,%eax
    a060:	89 c1                	mov    %eax,%ecx
    a062:	d3 ea                	shr    %cl,%edx
    a064:	89 d0                	mov    %edx,%eax
    a066:	89 c2                	mov    %eax,%edx
    a068:	8b 45 10             	mov    0x10(%ebp),%eax
    a06b:	8b 40 04             	mov    0x4(%eax),%eax
    a06e:	bb 01 00 00 00       	mov    $0x1,%ebx
    a073:	89 c1                	mov    %eax,%ecx
    a075:	d3 e3                	shl    %cl,%ebx
    a077:	89 d8                	mov    %ebx,%eax
    a079:	83 e8 01             	sub    $0x1,%eax
    a07c:	21 d0                	and    %edx,%eax
    a07e:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    a081:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a085:	8b 45 10             	mov    0x10(%ebp),%eax
    a088:	8b 40 04             	mov    0x4(%eax),%eax
    a08b:	52                   	push   %edx
    a08c:	50                   	push   %eax
    a08d:	ff 75 0c             	pushl  0xc(%ebp)
    a090:	ff 75 08             	pushl  0x8(%ebp)
    a093:	e8 21 fc ff ff       	call   9cb9 <addColorBits>
    a098:	83 c4 10             	add    $0x10,%esp
    a09b:	e9 2c 03 00 00       	jmp    a3cc <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    a0a0:	8b 45 10             	mov    0x10(%ebp),%eax
    a0a3:	8b 00                	mov    (%eax),%eax
    a0a5:	83 f8 02             	cmp    $0x2,%eax
    a0a8:	0f 85 ee 00 00 00    	jne    a19c <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    a0ae:	8b 45 10             	mov    0x10(%ebp),%eax
    a0b1:	8b 40 04             	mov    0x4(%eax),%eax
    a0b4:	83 f8 08             	cmp    $0x8,%eax
    a0b7:	75 49                	jne    a102 <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    a0b9:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0bc:	89 d0                	mov    %edx,%eax
    a0be:	01 c0                	add    %eax,%eax
    a0c0:	01 d0                	add    %edx,%eax
    a0c2:	89 c2                	mov    %eax,%edx
    a0c4:	8b 45 08             	mov    0x8(%ebp),%eax
    a0c7:	01 c2                	add    %eax,%edx
    a0c9:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a0cd:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    a0cf:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0d2:	89 d0                	mov    %edx,%eax
    a0d4:	01 c0                	add    %eax,%eax
    a0d6:	01 d0                	add    %edx,%eax
    a0d8:	8d 50 01             	lea    0x1(%eax),%edx
    a0db:	8b 45 08             	mov    0x8(%ebp),%eax
    a0de:	01 c2                	add    %eax,%edx
    a0e0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a0e4:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a0e6:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0e9:	89 d0                	mov    %edx,%eax
    a0eb:	01 c0                	add    %eax,%eax
    a0ed:	01 d0                	add    %edx,%eax
    a0ef:	8d 50 02             	lea    0x2(%eax),%edx
    a0f2:	8b 45 08             	mov    0x8(%ebp),%eax
    a0f5:	01 c2                	add    %eax,%edx
    a0f7:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a0fb:	88 02                	mov    %al,(%edx)
    a0fd:	e9 ca 02 00 00       	jmp    a3cc <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a102:	8b 55 0c             	mov    0xc(%ebp),%edx
    a105:	89 d0                	mov    %edx,%eax
    a107:	01 c0                	add    %eax,%eax
    a109:	01 d0                	add    %edx,%eax
    a10b:	01 c0                	add    %eax,%eax
    a10d:	89 c2                	mov    %eax,%edx
    a10f:	8b 45 08             	mov    0x8(%ebp),%eax
    a112:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a115:	8b 55 0c             	mov    0xc(%ebp),%edx
    a118:	89 d0                	mov    %edx,%eax
    a11a:	01 c0                	add    %eax,%eax
    a11c:	01 d0                	add    %edx,%eax
    a11e:	01 c0                	add    %eax,%eax
    a120:	8d 50 01             	lea    0x1(%eax),%edx
    a123:	8b 45 08             	mov    0x8(%ebp),%eax
    a126:	01 d0                	add    %edx,%eax
    a128:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a12c:	88 10                	mov    %dl,(%eax)
    a12e:	0f b6 00             	movzbl (%eax),%eax
    a131:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a133:	8b 55 0c             	mov    0xc(%ebp),%edx
    a136:	89 d0                	mov    %edx,%eax
    a138:	01 c0                	add    %eax,%eax
    a13a:	01 d0                	add    %edx,%eax
    a13c:	01 c0                	add    %eax,%eax
    a13e:	8d 50 02             	lea    0x2(%eax),%edx
    a141:	8b 45 08             	mov    0x8(%ebp),%eax
    a144:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a147:	8b 55 0c             	mov    0xc(%ebp),%edx
    a14a:	89 d0                	mov    %edx,%eax
    a14c:	01 c0                	add    %eax,%eax
    a14e:	01 d0                	add    %edx,%eax
    a150:	01 c0                	add    %eax,%eax
    a152:	8d 50 03             	lea    0x3(%eax),%edx
    a155:	8b 45 08             	mov    0x8(%ebp),%eax
    a158:	01 d0                	add    %edx,%eax
    a15a:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a15e:	88 10                	mov    %dl,(%eax)
    a160:	0f b6 00             	movzbl (%eax),%eax
    a163:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a165:	8b 55 0c             	mov    0xc(%ebp),%edx
    a168:	89 d0                	mov    %edx,%eax
    a16a:	01 c0                	add    %eax,%eax
    a16c:	01 d0                	add    %edx,%eax
    a16e:	01 c0                	add    %eax,%eax
    a170:	8d 50 04             	lea    0x4(%eax),%edx
    a173:	8b 45 08             	mov    0x8(%ebp),%eax
    a176:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a179:	8b 55 0c             	mov    0xc(%ebp),%edx
    a17c:	89 d0                	mov    %edx,%eax
    a17e:	01 c0                	add    %eax,%eax
    a180:	01 d0                	add    %edx,%eax
    a182:	01 c0                	add    %eax,%eax
    a184:	8d 50 05             	lea    0x5(%eax),%edx
    a187:	8b 45 08             	mov    0x8(%ebp),%eax
    a18a:	01 d0                	add    %edx,%eax
    a18c:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a190:	88 10                	mov    %dl,(%eax)
    a192:	0f b6 00             	movzbl (%eax),%eax
    a195:	88 01                	mov    %al,(%ecx)
    a197:	e9 30 02 00 00       	jmp    a3cc <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a19c:	8b 45 10             	mov    0x10(%ebp),%eax
    a19f:	8b 00                	mov    (%eax),%eax
    a1a1:	83 f8 03             	cmp    $0x3,%eax
    a1a4:	75 6d                	jne    a213 <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a1a6:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a1aa:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a1ae:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a1b2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a1b6:	53                   	push   %ebx
    a1b7:	51                   	push   %ecx
    a1b8:	52                   	push   %edx
    a1b9:	50                   	push   %eax
    a1ba:	ff 75 14             	pushl  0x14(%ebp)
    a1bd:	e8 fd fb ff ff       	call   9dbf <color_tree_get>
    a1c2:	83 c4 14             	add    $0x14,%esp
    a1c5:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a1c8:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a1cc:	79 0a                	jns    a1d8 <rgba8ToPixel+0x211>
    a1ce:	b8 52 00 00 00       	mov    $0x52,%eax
    a1d3:	e9 f9 01 00 00       	jmp    a3d1 <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a1d8:	8b 45 10             	mov    0x10(%ebp),%eax
    a1db:	8b 40 04             	mov    0x4(%eax),%eax
    a1de:	83 f8 08             	cmp    $0x8,%eax
    a1e1:	75 12                	jne    a1f5 <rgba8ToPixel+0x22e>
    a1e3:	8b 55 0c             	mov    0xc(%ebp),%edx
    a1e6:	8b 45 08             	mov    0x8(%ebp),%eax
    a1e9:	01 d0                	add    %edx,%eax
    a1eb:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a1ee:	88 10                	mov    %dl,(%eax)
    a1f0:	e9 d7 01 00 00       	jmp    a3cc <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a1f5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a1f8:	8b 45 10             	mov    0x10(%ebp),%eax
    a1fb:	8b 40 04             	mov    0x4(%eax),%eax
    a1fe:	52                   	push   %edx
    a1ff:	50                   	push   %eax
    a200:	ff 75 0c             	pushl  0xc(%ebp)
    a203:	ff 75 08             	pushl  0x8(%ebp)
    a206:	e8 ae fa ff ff       	call   9cb9 <addColorBits>
    a20b:	83 c4 10             	add    $0x10,%esp
    a20e:	e9 b9 01 00 00       	jmp    a3cc <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a213:	8b 45 10             	mov    0x10(%ebp),%eax
    a216:	8b 00                	mov    (%eax),%eax
    a218:	83 f8 04             	cmp    $0x4,%eax
    a21b:	0f 85 9f 00 00 00    	jne    a2c0 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a221:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a225:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a228:	8b 45 10             	mov    0x10(%ebp),%eax
    a22b:	8b 40 04             	mov    0x4(%eax),%eax
    a22e:	83 f8 08             	cmp    $0x8,%eax
    a231:	75 2a                	jne    a25d <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a233:	8b 45 0c             	mov    0xc(%ebp),%eax
    a236:	01 c0                	add    %eax,%eax
    a238:	89 c2                	mov    %eax,%edx
    a23a:	8b 45 08             	mov    0x8(%ebp),%eax
    a23d:	01 c2                	add    %eax,%edx
    a23f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a243:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a245:	8b 45 0c             	mov    0xc(%ebp),%eax
    a248:	01 c0                	add    %eax,%eax
    a24a:	8d 50 01             	lea    0x1(%eax),%edx
    a24d:	8b 45 08             	mov    0x8(%ebp),%eax
    a250:	01 c2                	add    %eax,%edx
    a252:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a256:	88 02                	mov    %al,(%edx)
    a258:	e9 6f 01 00 00       	jmp    a3cc <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a25d:	8b 45 10             	mov    0x10(%ebp),%eax
    a260:	8b 40 04             	mov    0x4(%eax),%eax
    a263:	83 f8 10             	cmp    $0x10,%eax
    a266:	0f 85 60 01 00 00    	jne    a3cc <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a26c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a26f:	c1 e0 02             	shl    $0x2,%eax
    a272:	89 c2                	mov    %eax,%edx
    a274:	8b 45 08             	mov    0x8(%ebp),%eax
    a277:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a27a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a27d:	c1 e0 02             	shl    $0x2,%eax
    a280:	8d 50 01             	lea    0x1(%eax),%edx
    a283:	8b 45 08             	mov    0x8(%ebp),%eax
    a286:	01 d0                	add    %edx,%eax
    a288:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a28c:	88 10                	mov    %dl,(%eax)
    a28e:	0f b6 00             	movzbl (%eax),%eax
    a291:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a293:	8b 45 0c             	mov    0xc(%ebp),%eax
    a296:	c1 e0 02             	shl    $0x2,%eax
    a299:	8d 50 02             	lea    0x2(%eax),%edx
    a29c:	8b 45 08             	mov    0x8(%ebp),%eax
    a29f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2a2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2a5:	c1 e0 02             	shl    $0x2,%eax
    a2a8:	8d 50 03             	lea    0x3(%eax),%edx
    a2ab:	8b 45 08             	mov    0x8(%ebp),%eax
    a2ae:	01 d0                	add    %edx,%eax
    a2b0:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a2b4:	88 10                	mov    %dl,(%eax)
    a2b6:	0f b6 00             	movzbl (%eax),%eax
    a2b9:	88 01                	mov    %al,(%ecx)
    a2bb:	e9 0c 01 00 00       	jmp    a3cc <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a2c0:	8b 45 10             	mov    0x10(%ebp),%eax
    a2c3:	8b 00                	mov    (%eax),%eax
    a2c5:	83 f8 06             	cmp    $0x6,%eax
    a2c8:	0f 85 fe 00 00 00    	jne    a3cc <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a2ce:	8b 45 10             	mov    0x10(%ebp),%eax
    a2d1:	8b 40 04             	mov    0x4(%eax),%eax
    a2d4:	83 f8 08             	cmp    $0x8,%eax
    a2d7:	75 54                	jne    a32d <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a2d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2dc:	c1 e0 02             	shl    $0x2,%eax
    a2df:	89 c2                	mov    %eax,%edx
    a2e1:	8b 45 08             	mov    0x8(%ebp),%eax
    a2e4:	01 c2                	add    %eax,%edx
    a2e6:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a2ea:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a2ec:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2ef:	c1 e0 02             	shl    $0x2,%eax
    a2f2:	8d 50 01             	lea    0x1(%eax),%edx
    a2f5:	8b 45 08             	mov    0x8(%ebp),%eax
    a2f8:	01 c2                	add    %eax,%edx
    a2fa:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a2fe:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a300:	8b 45 0c             	mov    0xc(%ebp),%eax
    a303:	c1 e0 02             	shl    $0x2,%eax
    a306:	8d 50 02             	lea    0x2(%eax),%edx
    a309:	8b 45 08             	mov    0x8(%ebp),%eax
    a30c:	01 c2                	add    %eax,%edx
    a30e:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a312:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a314:	8b 45 0c             	mov    0xc(%ebp),%eax
    a317:	c1 e0 02             	shl    $0x2,%eax
    a31a:	8d 50 03             	lea    0x3(%eax),%edx
    a31d:	8b 45 08             	mov    0x8(%ebp),%eax
    a320:	01 c2                	add    %eax,%edx
    a322:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a326:	88 02                	mov    %al,(%edx)
    a328:	e9 9f 00 00 00       	jmp    a3cc <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a32d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a330:	c1 e0 03             	shl    $0x3,%eax
    a333:	89 c2                	mov    %eax,%edx
    a335:	8b 45 08             	mov    0x8(%ebp),%eax
    a338:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a33b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a33e:	c1 e0 03             	shl    $0x3,%eax
    a341:	8d 50 01             	lea    0x1(%eax),%edx
    a344:	8b 45 08             	mov    0x8(%ebp),%eax
    a347:	01 d0                	add    %edx,%eax
    a349:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a34d:	88 10                	mov    %dl,(%eax)
    a34f:	0f b6 00             	movzbl (%eax),%eax
    a352:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a354:	8b 45 0c             	mov    0xc(%ebp),%eax
    a357:	c1 e0 03             	shl    $0x3,%eax
    a35a:	8d 50 02             	lea    0x2(%eax),%edx
    a35d:	8b 45 08             	mov    0x8(%ebp),%eax
    a360:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a363:	8b 45 0c             	mov    0xc(%ebp),%eax
    a366:	c1 e0 03             	shl    $0x3,%eax
    a369:	8d 50 03             	lea    0x3(%eax),%edx
    a36c:	8b 45 08             	mov    0x8(%ebp),%eax
    a36f:	01 d0                	add    %edx,%eax
    a371:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a375:	88 10                	mov    %dl,(%eax)
    a377:	0f b6 00             	movzbl (%eax),%eax
    a37a:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a37c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a37f:	c1 e0 03             	shl    $0x3,%eax
    a382:	8d 50 04             	lea    0x4(%eax),%edx
    a385:	8b 45 08             	mov    0x8(%ebp),%eax
    a388:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a38b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a38e:	c1 e0 03             	shl    $0x3,%eax
    a391:	8d 50 05             	lea    0x5(%eax),%edx
    a394:	8b 45 08             	mov    0x8(%ebp),%eax
    a397:	01 d0                	add    %edx,%eax
    a399:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a39d:	88 10                	mov    %dl,(%eax)
    a39f:	0f b6 00             	movzbl (%eax),%eax
    a3a2:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    a3a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3a7:	c1 e0 03             	shl    $0x3,%eax
    a3aa:	8d 50 06             	lea    0x6(%eax),%edx
    a3ad:	8b 45 08             	mov    0x8(%ebp),%eax
    a3b0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a3b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3b6:	c1 e0 03             	shl    $0x3,%eax
    a3b9:	8d 50 07             	lea    0x7(%eax),%edx
    a3bc:	8b 45 08             	mov    0x8(%ebp),%eax
    a3bf:	01 d0                	add    %edx,%eax
    a3c1:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a3c5:	88 10                	mov    %dl,(%eax)
    a3c7:	0f b6 00             	movzbl (%eax),%eax
    a3ca:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    a3cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a3d1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a3d4:	c9                   	leave  
    a3d5:	c3                   	ret    

0000a3d6 <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    a3d6:	55                   	push   %ebp
    a3d7:	89 e5                	mov    %esp,%ebp
    a3d9:	53                   	push   %ebx
    a3da:	83 ec 20             	sub    $0x20,%esp
    a3dd:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a3e0:	8b 4d 18             	mov    0x18(%ebp),%ecx
    a3e3:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a3e6:	8b 45 20             	mov    0x20(%ebp),%eax
    a3e9:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    a3ed:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    a3f1:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    a3f5:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a3f9:	8b 45 10             	mov    0x10(%ebp),%eax
    a3fc:	8b 00                	mov    (%eax),%eax
    a3fe:	85 c0                	test   %eax,%eax
    a400:	75 36                	jne    a438 <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a402:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a406:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    a40a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a40d:	01 c0                	add    %eax,%eax
    a40f:	89 c2                	mov    %eax,%edx
    a411:	8b 45 08             	mov    0x8(%ebp),%eax
    a414:	01 d0                	add    %edx,%eax
    a416:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a41a:	66 c1 ea 08          	shr    $0x8,%dx
    a41e:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    a420:	8b 45 0c             	mov    0xc(%ebp),%eax
    a423:	01 c0                	add    %eax,%eax
    a425:	8d 50 01             	lea    0x1(%eax),%edx
    a428:	8b 45 08             	mov    0x8(%ebp),%eax
    a42b:	01 d0                	add    %edx,%eax
    a42d:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a431:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a433:	e9 df 01 00 00       	jmp    a617 <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    a438:	8b 45 10             	mov    0x10(%ebp),%eax
    a43b:	8b 00                	mov    (%eax),%eax
    a43d:	83 f8 02             	cmp    $0x2,%eax
    a440:	0f 85 a6 00 00 00    	jne    a4ec <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    a446:	8b 55 0c             	mov    0xc(%ebp),%edx
    a449:	89 d0                	mov    %edx,%eax
    a44b:	01 c0                	add    %eax,%eax
    a44d:	01 d0                	add    %edx,%eax
    a44f:	01 c0                	add    %eax,%eax
    a451:	89 c2                	mov    %eax,%edx
    a453:	8b 45 08             	mov    0x8(%ebp),%eax
    a456:	01 d0                	add    %edx,%eax
    a458:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a45c:	66 c1 ea 08          	shr    $0x8,%dx
    a460:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    a462:	8b 55 0c             	mov    0xc(%ebp),%edx
    a465:	89 d0                	mov    %edx,%eax
    a467:	01 c0                	add    %eax,%eax
    a469:	01 d0                	add    %edx,%eax
    a46b:	01 c0                	add    %eax,%eax
    a46d:	8d 50 01             	lea    0x1(%eax),%edx
    a470:	8b 45 08             	mov    0x8(%ebp),%eax
    a473:	01 d0                	add    %edx,%eax
    a475:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a479:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    a47b:	8b 55 0c             	mov    0xc(%ebp),%edx
    a47e:	89 d0                	mov    %edx,%eax
    a480:	01 c0                	add    %eax,%eax
    a482:	01 d0                	add    %edx,%eax
    a484:	01 c0                	add    %eax,%eax
    a486:	8d 50 02             	lea    0x2(%eax),%edx
    a489:	8b 45 08             	mov    0x8(%ebp),%eax
    a48c:	01 d0                	add    %edx,%eax
    a48e:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a492:	66 c1 ea 08          	shr    $0x8,%dx
    a496:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    a498:	8b 55 0c             	mov    0xc(%ebp),%edx
    a49b:	89 d0                	mov    %edx,%eax
    a49d:	01 c0                	add    %eax,%eax
    a49f:	01 d0                	add    %edx,%eax
    a4a1:	01 c0                	add    %eax,%eax
    a4a3:	8d 50 03             	lea    0x3(%eax),%edx
    a4a6:	8b 45 08             	mov    0x8(%ebp),%eax
    a4a9:	01 d0                	add    %edx,%eax
    a4ab:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a4af:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    a4b1:	8b 55 0c             	mov    0xc(%ebp),%edx
    a4b4:	89 d0                	mov    %edx,%eax
    a4b6:	01 c0                	add    %eax,%eax
    a4b8:	01 d0                	add    %edx,%eax
    a4ba:	01 c0                	add    %eax,%eax
    a4bc:	8d 50 04             	lea    0x4(%eax),%edx
    a4bf:	8b 45 08             	mov    0x8(%ebp),%eax
    a4c2:	01 d0                	add    %edx,%eax
    a4c4:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a4c8:	66 c1 ea 08          	shr    $0x8,%dx
    a4cc:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    a4ce:	8b 55 0c             	mov    0xc(%ebp),%edx
    a4d1:	89 d0                	mov    %edx,%eax
    a4d3:	01 c0                	add    %eax,%eax
    a4d5:	01 d0                	add    %edx,%eax
    a4d7:	01 c0                	add    %eax,%eax
    a4d9:	8d 50 05             	lea    0x5(%eax),%edx
    a4dc:	8b 45 08             	mov    0x8(%ebp),%eax
    a4df:	01 d0                	add    %edx,%eax
    a4e1:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a4e5:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a4e7:	e9 2b 01 00 00       	jmp    a617 <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a4ec:	8b 45 10             	mov    0x10(%ebp),%eax
    a4ef:	8b 00                	mov    (%eax),%eax
    a4f1:	83 f8 04             	cmp    $0x4,%eax
    a4f4:	75 64                	jne    a55a <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a4f6:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a4fa:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    a4fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    a501:	c1 e0 02             	shl    $0x2,%eax
    a504:	89 c2                	mov    %eax,%edx
    a506:	8b 45 08             	mov    0x8(%ebp),%eax
    a509:	01 d0                	add    %edx,%eax
    a50b:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a50f:	66 c1 ea 08          	shr    $0x8,%dx
    a513:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    a515:	8b 45 0c             	mov    0xc(%ebp),%eax
    a518:	c1 e0 02             	shl    $0x2,%eax
    a51b:	8d 50 01             	lea    0x1(%eax),%edx
    a51e:	8b 45 08             	mov    0x8(%ebp),%eax
    a521:	01 d0                	add    %edx,%eax
    a523:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a527:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    a529:	8b 45 0c             	mov    0xc(%ebp),%eax
    a52c:	c1 e0 02             	shl    $0x2,%eax
    a52f:	8d 50 02             	lea    0x2(%eax),%edx
    a532:	8b 45 08             	mov    0x8(%ebp),%eax
    a535:	01 d0                	add    %edx,%eax
    a537:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a53b:	66 c1 ea 08          	shr    $0x8,%dx
    a53f:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    a541:	8b 45 0c             	mov    0xc(%ebp),%eax
    a544:	c1 e0 02             	shl    $0x2,%eax
    a547:	8d 50 03             	lea    0x3(%eax),%edx
    a54a:	8b 45 08             	mov    0x8(%ebp),%eax
    a54d:	01 d0                	add    %edx,%eax
    a54f:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a553:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a555:	e9 bd 00 00 00       	jmp    a617 <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    a55a:	8b 45 10             	mov    0x10(%ebp),%eax
    a55d:	8b 00                	mov    (%eax),%eax
    a55f:	83 f8 06             	cmp    $0x6,%eax
    a562:	0f 85 af 00 00 00    	jne    a617 <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    a568:	8b 45 0c             	mov    0xc(%ebp),%eax
    a56b:	c1 e0 03             	shl    $0x3,%eax
    a56e:	89 c2                	mov    %eax,%edx
    a570:	8b 45 08             	mov    0x8(%ebp),%eax
    a573:	01 d0                	add    %edx,%eax
    a575:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a579:	66 c1 ea 08          	shr    $0x8,%dx
    a57d:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    a57f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a582:	c1 e0 03             	shl    $0x3,%eax
    a585:	8d 50 01             	lea    0x1(%eax),%edx
    a588:	8b 45 08             	mov    0x8(%ebp),%eax
    a58b:	01 d0                	add    %edx,%eax
    a58d:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a591:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    a593:	8b 45 0c             	mov    0xc(%ebp),%eax
    a596:	c1 e0 03             	shl    $0x3,%eax
    a599:	8d 50 02             	lea    0x2(%eax),%edx
    a59c:	8b 45 08             	mov    0x8(%ebp),%eax
    a59f:	01 d0                	add    %edx,%eax
    a5a1:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a5a5:	66 c1 ea 08          	shr    $0x8,%dx
    a5a9:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    a5ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5ae:	c1 e0 03             	shl    $0x3,%eax
    a5b1:	8d 50 03             	lea    0x3(%eax),%edx
    a5b4:	8b 45 08             	mov    0x8(%ebp),%eax
    a5b7:	01 d0                	add    %edx,%eax
    a5b9:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a5bd:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    a5bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5c2:	c1 e0 03             	shl    $0x3,%eax
    a5c5:	8d 50 04             	lea    0x4(%eax),%edx
    a5c8:	8b 45 08             	mov    0x8(%ebp),%eax
    a5cb:	01 d0                	add    %edx,%eax
    a5cd:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a5d1:	66 c1 ea 08          	shr    $0x8,%dx
    a5d5:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    a5d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5da:	c1 e0 03             	shl    $0x3,%eax
    a5dd:	8d 50 05             	lea    0x5(%eax),%edx
    a5e0:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e3:	01 d0                	add    %edx,%eax
    a5e5:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a5e9:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    a5eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5ee:	c1 e0 03             	shl    $0x3,%eax
    a5f1:	8d 50 06             	lea    0x6(%eax),%edx
    a5f4:	8b 45 08             	mov    0x8(%ebp),%eax
    a5f7:	01 d0                	add    %edx,%eax
    a5f9:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a5fd:	66 c1 ea 08          	shr    $0x8,%dx
    a601:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    a603:	8b 45 0c             	mov    0xc(%ebp),%eax
    a606:	c1 e0 03             	shl    $0x3,%eax
    a609:	8d 50 07             	lea    0x7(%eax),%edx
    a60c:	8b 45 08             	mov    0x8(%ebp),%eax
    a60f:	01 d0                	add    %edx,%eax
    a611:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a615:	88 10                	mov    %dl,(%eax)
  }
}
    a617:	90                   	nop
    a618:	83 c4 20             	add    $0x20,%esp
    a61b:	5b                   	pop    %ebx
    a61c:	5d                   	pop    %ebp
    a61d:	c3                   	ret    

0000a61e <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    a61e:	55                   	push   %ebp
    a61f:	89 e5                	mov    %esp,%ebp
    a621:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    a624:	8b 45 20             	mov    0x20(%ebp),%eax
    a627:	8b 00                	mov    (%eax),%eax
    a629:	85 c0                	test   %eax,%eax
    a62b:	0f 85 8c 01 00 00    	jne    a7bd <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    a631:	8b 45 20             	mov    0x20(%ebp),%eax
    a634:	8b 40 04             	mov    0x4(%eax),%eax
    a637:	83 f8 08             	cmp    $0x8,%eax
    a63a:	75 59                	jne    a695 <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    a63c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a63f:	8b 45 18             	mov    0x18(%ebp),%eax
    a642:	01 d0                	add    %edx,%eax
    a644:	0f b6 10             	movzbl (%eax),%edx
    a647:	8b 45 10             	mov    0x10(%ebp),%eax
    a64a:	88 10                	mov    %dl,(%eax)
    a64c:	8b 45 10             	mov    0x10(%ebp),%eax
    a64f:	0f b6 10             	movzbl (%eax),%edx
    a652:	8b 45 0c             	mov    0xc(%ebp),%eax
    a655:	88 10                	mov    %dl,(%eax)
    a657:	8b 45 0c             	mov    0xc(%ebp),%eax
    a65a:	0f b6 10             	movzbl (%eax),%edx
    a65d:	8b 45 08             	mov    0x8(%ebp),%eax
    a660:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    a662:	8b 45 20             	mov    0x20(%ebp),%eax
    a665:	8b 40 10             	mov    0x10(%eax),%eax
    a668:	85 c0                	test   %eax,%eax
    a66a:	74 1e                	je     a68a <getPixelColorRGBA8+0x6c>
    a66c:	8b 45 08             	mov    0x8(%ebp),%eax
    a66f:	0f b6 00             	movzbl (%eax),%eax
    a672:	0f b6 d0             	movzbl %al,%edx
    a675:	8b 45 20             	mov    0x20(%ebp),%eax
    a678:	8b 40 14             	mov    0x14(%eax),%eax
    a67b:	39 c2                	cmp    %eax,%edx
    a67d:	75 0b                	jne    a68a <getPixelColorRGBA8+0x6c>
    a67f:	8b 45 14             	mov    0x14(%ebp),%eax
    a682:	c6 00 00             	movb   $0x0,(%eax)
    a685:	e9 5e 05 00 00       	jmp    abe8 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a68a:	8b 45 14             	mov    0x14(%ebp),%eax
    a68d:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a690:	e9 53 05 00 00       	jmp    abe8 <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    a695:	8b 45 20             	mov    0x20(%ebp),%eax
    a698:	8b 40 04             	mov    0x4(%eax),%eax
    a69b:	83 f8 10             	cmp    $0x10,%eax
    a69e:	0f 85 80 00 00 00    	jne    a724 <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    a6a4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a6a7:	01 c0                	add    %eax,%eax
    a6a9:	89 c2                	mov    %eax,%edx
    a6ab:	8b 45 18             	mov    0x18(%ebp),%eax
    a6ae:	01 d0                	add    %edx,%eax
    a6b0:	0f b6 10             	movzbl (%eax),%edx
    a6b3:	8b 45 10             	mov    0x10(%ebp),%eax
    a6b6:	88 10                	mov    %dl,(%eax)
    a6b8:	8b 45 10             	mov    0x10(%ebp),%eax
    a6bb:	0f b6 10             	movzbl (%eax),%edx
    a6be:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6c1:	88 10                	mov    %dl,(%eax)
    a6c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6c6:	0f b6 10             	movzbl (%eax),%edx
    a6c9:	8b 45 08             	mov    0x8(%ebp),%eax
    a6cc:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    a6ce:	8b 45 20             	mov    0x20(%ebp),%eax
    a6d1:	8b 40 10             	mov    0x10(%eax),%eax
    a6d4:	85 c0                	test   %eax,%eax
    a6d6:	74 41                	je     a719 <getPixelColorRGBA8+0xfb>
    a6d8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a6db:	01 c0                	add    %eax,%eax
    a6dd:	89 c2                	mov    %eax,%edx
    a6df:	8b 45 18             	mov    0x18(%ebp),%eax
    a6e2:	01 d0                	add    %edx,%eax
    a6e4:	0f b6 00             	movzbl (%eax),%eax
    a6e7:	0f b6 c0             	movzbl %al,%eax
    a6ea:	c1 e0 08             	shl    $0x8,%eax
    a6ed:	89 c2                	mov    %eax,%edx
    a6ef:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a6f2:	01 c0                	add    %eax,%eax
    a6f4:	8d 48 01             	lea    0x1(%eax),%ecx
    a6f7:	8b 45 18             	mov    0x18(%ebp),%eax
    a6fa:	01 c8                	add    %ecx,%eax
    a6fc:	0f b6 00             	movzbl (%eax),%eax
    a6ff:	0f b6 c0             	movzbl %al,%eax
    a702:	01 c2                	add    %eax,%edx
    a704:	8b 45 20             	mov    0x20(%ebp),%eax
    a707:	8b 40 14             	mov    0x14(%eax),%eax
    a70a:	39 c2                	cmp    %eax,%edx
    a70c:	75 0b                	jne    a719 <getPixelColorRGBA8+0xfb>
    a70e:	8b 45 14             	mov    0x14(%ebp),%eax
    a711:	c6 00 00             	movb   $0x0,(%eax)
    a714:	e9 cf 04 00 00       	jmp    abe8 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a719:	8b 45 14             	mov    0x14(%ebp),%eax
    a71c:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a71f:	e9 c4 04 00 00       	jmp    abe8 <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    a724:	8b 45 20             	mov    0x20(%ebp),%eax
    a727:	8b 40 04             	mov    0x4(%eax),%eax
    a72a:	ba 01 00 00 00       	mov    $0x1,%edx
    a72f:	89 c1                	mov    %eax,%ecx
    a731:	d3 e2                	shl    %cl,%edx
    a733:	89 d0                	mov    %edx,%eax
    a735:	83 e8 01             	sub    $0x1,%eax
    a738:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    a73b:	8b 45 20             	mov    0x20(%ebp),%eax
    a73e:	8b 50 04             	mov    0x4(%eax),%edx
    a741:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a744:	0f af c2             	imul   %edx,%eax
    a747:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a74a:	8b 45 20             	mov    0x20(%ebp),%eax
    a74d:	8b 40 04             	mov    0x4(%eax),%eax
    a750:	50                   	push   %eax
    a751:	ff 75 18             	pushl  0x18(%ebp)
    a754:	8d 45 f0             	lea    -0x10(%ebp),%eax
    a757:	50                   	push   %eax
    a758:	e8 06 db ff ff       	call   8263 <readBitsFromReversedStream>
    a75d:	83 c4 0c             	add    $0xc,%esp
    a760:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    a763:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a766:	89 d0                	mov    %edx,%eax
    a768:	c1 e0 08             	shl    $0x8,%eax
    a76b:	29 d0                	sub    %edx,%eax
    a76d:	ba 00 00 00 00       	mov    $0x0,%edx
    a772:	f7 75 f8             	divl   -0x8(%ebp)
    a775:	89 c2                	mov    %eax,%edx
    a777:	8b 45 10             	mov    0x10(%ebp),%eax
    a77a:	88 10                	mov    %dl,(%eax)
    a77c:	8b 45 10             	mov    0x10(%ebp),%eax
    a77f:	0f b6 10             	movzbl (%eax),%edx
    a782:	8b 45 0c             	mov    0xc(%ebp),%eax
    a785:	88 10                	mov    %dl,(%eax)
    a787:	8b 45 0c             	mov    0xc(%ebp),%eax
    a78a:	0f b6 10             	movzbl (%eax),%edx
    a78d:	8b 45 08             	mov    0x8(%ebp),%eax
    a790:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    a792:	8b 45 20             	mov    0x20(%ebp),%eax
    a795:	8b 40 10             	mov    0x10(%eax),%eax
    a798:	85 c0                	test   %eax,%eax
    a79a:	74 16                	je     a7b2 <getPixelColorRGBA8+0x194>
    a79c:	8b 45 20             	mov    0x20(%ebp),%eax
    a79f:	8b 40 14             	mov    0x14(%eax),%eax
    a7a2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a7a5:	75 0b                	jne    a7b2 <getPixelColorRGBA8+0x194>
    a7a7:	8b 45 14             	mov    0x14(%ebp),%eax
    a7aa:	c6 00 00             	movb   $0x0,(%eax)
    a7ad:	e9 36 04 00 00       	jmp    abe8 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a7b2:	8b 45 14             	mov    0x14(%ebp),%eax
    a7b5:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a7b8:	e9 2b 04 00 00       	jmp    abe8 <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    a7bd:	8b 45 20             	mov    0x20(%ebp),%eax
    a7c0:	8b 00                	mov    (%eax),%eax
    a7c2:	83 f8 02             	cmp    $0x2,%eax
    a7c5:	0f 85 f5 01 00 00    	jne    a9c0 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    a7cb:	8b 45 20             	mov    0x20(%ebp),%eax
    a7ce:	8b 40 04             	mov    0x4(%eax),%eax
    a7d1:	83 f8 08             	cmp    $0x8,%eax
    a7d4:	0f 85 a3 00 00 00    	jne    a87d <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    a7da:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a7dd:	89 d0                	mov    %edx,%eax
    a7df:	01 c0                	add    %eax,%eax
    a7e1:	01 d0                	add    %edx,%eax
    a7e3:	89 c2                	mov    %eax,%edx
    a7e5:	8b 45 18             	mov    0x18(%ebp),%eax
    a7e8:	01 d0                	add    %edx,%eax
    a7ea:	0f b6 10             	movzbl (%eax),%edx
    a7ed:	8b 45 08             	mov    0x8(%ebp),%eax
    a7f0:	88 10                	mov    %dl,(%eax)
    a7f2:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a7f5:	89 d0                	mov    %edx,%eax
    a7f7:	01 c0                	add    %eax,%eax
    a7f9:	01 d0                	add    %edx,%eax
    a7fb:	8d 50 01             	lea    0x1(%eax),%edx
    a7fe:	8b 45 18             	mov    0x18(%ebp),%eax
    a801:	01 d0                	add    %edx,%eax
    a803:	0f b6 10             	movzbl (%eax),%edx
    a806:	8b 45 0c             	mov    0xc(%ebp),%eax
    a809:	88 10                	mov    %dl,(%eax)
    a80b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a80e:	89 d0                	mov    %edx,%eax
    a810:	01 c0                	add    %eax,%eax
    a812:	01 d0                	add    %edx,%eax
    a814:	8d 50 02             	lea    0x2(%eax),%edx
    a817:	8b 45 18             	mov    0x18(%ebp),%eax
    a81a:	01 d0                	add    %edx,%eax
    a81c:	0f b6 10             	movzbl (%eax),%edx
    a81f:	8b 45 10             	mov    0x10(%ebp),%eax
    a822:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    a824:	8b 45 20             	mov    0x20(%ebp),%eax
    a827:	8b 40 10             	mov    0x10(%eax),%eax
    a82a:	85 c0                	test   %eax,%eax
    a82c:	74 44                	je     a872 <getPixelColorRGBA8+0x254>
    a82e:	8b 45 08             	mov    0x8(%ebp),%eax
    a831:	0f b6 00             	movzbl (%eax),%eax
    a834:	0f b6 d0             	movzbl %al,%edx
    a837:	8b 45 20             	mov    0x20(%ebp),%eax
    a83a:	8b 40 14             	mov    0x14(%eax),%eax
    a83d:	39 c2                	cmp    %eax,%edx
    a83f:	75 31                	jne    a872 <getPixelColorRGBA8+0x254>
    a841:	8b 45 0c             	mov    0xc(%ebp),%eax
    a844:	0f b6 00             	movzbl (%eax),%eax
    a847:	0f b6 d0             	movzbl %al,%edx
    a84a:	8b 45 20             	mov    0x20(%ebp),%eax
    a84d:	8b 40 18             	mov    0x18(%eax),%eax
    a850:	39 c2                	cmp    %eax,%edx
    a852:	75 1e                	jne    a872 <getPixelColorRGBA8+0x254>
    a854:	8b 45 10             	mov    0x10(%ebp),%eax
    a857:	0f b6 00             	movzbl (%eax),%eax
    a85a:	0f b6 d0             	movzbl %al,%edx
    a85d:	8b 45 20             	mov    0x20(%ebp),%eax
    a860:	8b 40 1c             	mov    0x1c(%eax),%eax
    a863:	39 c2                	cmp    %eax,%edx
    a865:	75 0b                	jne    a872 <getPixelColorRGBA8+0x254>
    a867:	8b 45 14             	mov    0x14(%ebp),%eax
    a86a:	c6 00 00             	movb   $0x0,(%eax)
    a86d:	e9 76 03 00 00       	jmp    abe8 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a872:	8b 45 14             	mov    0x14(%ebp),%eax
    a875:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a878:	e9 6b 03 00 00       	jmp    abe8 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    a87d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a880:	89 d0                	mov    %edx,%eax
    a882:	01 c0                	add    %eax,%eax
    a884:	01 d0                	add    %edx,%eax
    a886:	01 c0                	add    %eax,%eax
    a888:	89 c2                	mov    %eax,%edx
    a88a:	8b 45 18             	mov    0x18(%ebp),%eax
    a88d:	01 d0                	add    %edx,%eax
    a88f:	0f b6 10             	movzbl (%eax),%edx
    a892:	8b 45 08             	mov    0x8(%ebp),%eax
    a895:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    a897:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a89a:	89 d0                	mov    %edx,%eax
    a89c:	01 c0                	add    %eax,%eax
    a89e:	01 d0                	add    %edx,%eax
    a8a0:	01 c0                	add    %eax,%eax
    a8a2:	8d 50 02             	lea    0x2(%eax),%edx
    a8a5:	8b 45 18             	mov    0x18(%ebp),%eax
    a8a8:	01 d0                	add    %edx,%eax
    a8aa:	0f b6 10             	movzbl (%eax),%edx
    a8ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8b0:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    a8b2:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8b5:	89 d0                	mov    %edx,%eax
    a8b7:	01 c0                	add    %eax,%eax
    a8b9:	01 d0                	add    %edx,%eax
    a8bb:	01 c0                	add    %eax,%eax
    a8bd:	8d 50 04             	lea    0x4(%eax),%edx
    a8c0:	8b 45 18             	mov    0x18(%ebp),%eax
    a8c3:	01 d0                	add    %edx,%eax
    a8c5:	0f b6 10             	movzbl (%eax),%edx
    a8c8:	8b 45 10             	mov    0x10(%ebp),%eax
    a8cb:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    a8cd:	8b 45 20             	mov    0x20(%ebp),%eax
    a8d0:	8b 40 10             	mov    0x10(%eax),%eax
    a8d3:	85 c0                	test   %eax,%eax
    a8d5:	0f 84 da 00 00 00    	je     a9b5 <getPixelColorRGBA8+0x397>
    a8db:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8de:	89 d0                	mov    %edx,%eax
    a8e0:	01 c0                	add    %eax,%eax
    a8e2:	01 d0                	add    %edx,%eax
    a8e4:	01 c0                	add    %eax,%eax
    a8e6:	89 c2                	mov    %eax,%edx
    a8e8:	8b 45 18             	mov    0x18(%ebp),%eax
    a8eb:	01 d0                	add    %edx,%eax
    a8ed:	0f b6 00             	movzbl (%eax),%eax
    a8f0:	0f b6 c0             	movzbl %al,%eax
    a8f3:	c1 e0 08             	shl    $0x8,%eax
    a8f6:	89 c1                	mov    %eax,%ecx
    a8f8:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8fb:	89 d0                	mov    %edx,%eax
    a8fd:	01 c0                	add    %eax,%eax
    a8ff:	01 d0                	add    %edx,%eax
    a901:	01 c0                	add    %eax,%eax
    a903:	8d 50 01             	lea    0x1(%eax),%edx
    a906:	8b 45 18             	mov    0x18(%ebp),%eax
    a909:	01 d0                	add    %edx,%eax
    a90b:	0f b6 00             	movzbl (%eax),%eax
    a90e:	0f b6 c0             	movzbl %al,%eax
    a911:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a914:	8b 45 20             	mov    0x20(%ebp),%eax
    a917:	8b 40 14             	mov    0x14(%eax),%eax
    a91a:	39 c2                	cmp    %eax,%edx
    a91c:	0f 85 93 00 00 00    	jne    a9b5 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    a922:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a925:	89 d0                	mov    %edx,%eax
    a927:	01 c0                	add    %eax,%eax
    a929:	01 d0                	add    %edx,%eax
    a92b:	01 c0                	add    %eax,%eax
    a92d:	8d 50 02             	lea    0x2(%eax),%edx
    a930:	8b 45 18             	mov    0x18(%ebp),%eax
    a933:	01 d0                	add    %edx,%eax
    a935:	0f b6 00             	movzbl (%eax),%eax
    a938:	0f b6 c0             	movzbl %al,%eax
    a93b:	c1 e0 08             	shl    $0x8,%eax
    a93e:	89 c1                	mov    %eax,%ecx
    a940:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a943:	89 d0                	mov    %edx,%eax
    a945:	01 c0                	add    %eax,%eax
    a947:	01 d0                	add    %edx,%eax
    a949:	01 c0                	add    %eax,%eax
    a94b:	8d 50 03             	lea    0x3(%eax),%edx
    a94e:	8b 45 18             	mov    0x18(%ebp),%eax
    a951:	01 d0                	add    %edx,%eax
    a953:	0f b6 00             	movzbl (%eax),%eax
    a956:	0f b6 c0             	movzbl %al,%eax
    a959:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a95c:	8b 45 20             	mov    0x20(%ebp),%eax
    a95f:	8b 40 18             	mov    0x18(%eax),%eax
    a962:	39 c2                	cmp    %eax,%edx
    a964:	75 4f                	jne    a9b5 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    a966:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a969:	89 d0                	mov    %edx,%eax
    a96b:	01 c0                	add    %eax,%eax
    a96d:	01 d0                	add    %edx,%eax
    a96f:	01 c0                	add    %eax,%eax
    a971:	8d 50 04             	lea    0x4(%eax),%edx
    a974:	8b 45 18             	mov    0x18(%ebp),%eax
    a977:	01 d0                	add    %edx,%eax
    a979:	0f b6 00             	movzbl (%eax),%eax
    a97c:	0f b6 c0             	movzbl %al,%eax
    a97f:	c1 e0 08             	shl    $0x8,%eax
    a982:	89 c1                	mov    %eax,%ecx
    a984:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a987:	89 d0                	mov    %edx,%eax
    a989:	01 c0                	add    %eax,%eax
    a98b:	01 d0                	add    %edx,%eax
    a98d:	01 c0                	add    %eax,%eax
    a98f:	8d 50 05             	lea    0x5(%eax),%edx
    a992:	8b 45 18             	mov    0x18(%ebp),%eax
    a995:	01 d0                	add    %edx,%eax
    a997:	0f b6 00             	movzbl (%eax),%eax
    a99a:	0f b6 c0             	movzbl %al,%eax
    a99d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a9a0:	8b 45 20             	mov    0x20(%ebp),%eax
    a9a3:	8b 40 1c             	mov    0x1c(%eax),%eax
    a9a6:	39 c2                	cmp    %eax,%edx
    a9a8:	75 0b                	jne    a9b5 <getPixelColorRGBA8+0x397>
    a9aa:	8b 45 14             	mov    0x14(%ebp),%eax
    a9ad:	c6 00 00             	movb   $0x0,(%eax)
    a9b0:	e9 33 02 00 00       	jmp    abe8 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a9b5:	8b 45 14             	mov    0x14(%ebp),%eax
    a9b8:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a9bb:	e9 28 02 00 00       	jmp    abe8 <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a9c0:	8b 45 20             	mov    0x20(%ebp),%eax
    a9c3:	8b 00                	mov    (%eax),%eax
    a9c5:	83 f8 03             	cmp    $0x3,%eax
    a9c8:	0f 85 ac 00 00 00    	jne    aa7a <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    a9ce:	8b 45 20             	mov    0x20(%ebp),%eax
    a9d1:	8b 40 04             	mov    0x4(%eax),%eax
    a9d4:	83 f8 08             	cmp    $0x8,%eax
    a9d7:	75 13                	jne    a9ec <getPixelColorRGBA8+0x3ce>
    a9d9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a9dc:	8b 45 18             	mov    0x18(%ebp),%eax
    a9df:	01 d0                	add    %edx,%eax
    a9e1:	0f b6 00             	movzbl (%eax),%eax
    a9e4:	0f b6 c0             	movzbl %al,%eax
    a9e7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    a9ea:	eb 28                	jmp    aa14 <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    a9ec:	8b 45 20             	mov    0x20(%ebp),%eax
    a9ef:	8b 50 04             	mov    0x4(%eax),%edx
    a9f2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a9f5:	0f af c2             	imul   %edx,%eax
    a9f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a9fb:	8b 45 20             	mov    0x20(%ebp),%eax
    a9fe:	8b 40 04             	mov    0x4(%eax),%eax
    aa01:	50                   	push   %eax
    aa02:	ff 75 18             	pushl  0x18(%ebp)
    aa05:	8d 45 ec             	lea    -0x14(%ebp),%eax
    aa08:	50                   	push   %eax
    aa09:	e8 55 d8 ff ff       	call   8263 <readBitsFromReversedStream>
    aa0e:	83 c4 0c             	add    $0xc,%esp
    aa11:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    aa14:	8b 45 20             	mov    0x20(%ebp),%eax
    aa17:	8b 40 08             	mov    0x8(%eax),%eax
    aa1a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aa1d:	c1 e2 02             	shl    $0x2,%edx
    aa20:	01 d0                	add    %edx,%eax
    aa22:	0f b6 10             	movzbl (%eax),%edx
    aa25:	8b 45 08             	mov    0x8(%ebp),%eax
    aa28:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    aa2a:	8b 45 20             	mov    0x20(%ebp),%eax
    aa2d:	8b 40 08             	mov    0x8(%eax),%eax
    aa30:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aa33:	c1 e2 02             	shl    $0x2,%edx
    aa36:	83 c2 01             	add    $0x1,%edx
    aa39:	01 d0                	add    %edx,%eax
    aa3b:	0f b6 10             	movzbl (%eax),%edx
    aa3e:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa41:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    aa43:	8b 45 20             	mov    0x20(%ebp),%eax
    aa46:	8b 40 08             	mov    0x8(%eax),%eax
    aa49:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aa4c:	c1 e2 02             	shl    $0x2,%edx
    aa4f:	83 c2 02             	add    $0x2,%edx
    aa52:	01 d0                	add    %edx,%eax
    aa54:	0f b6 10             	movzbl (%eax),%edx
    aa57:	8b 45 10             	mov    0x10(%ebp),%eax
    aa5a:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    aa5c:	8b 45 20             	mov    0x20(%ebp),%eax
    aa5f:	8b 40 08             	mov    0x8(%eax),%eax
    aa62:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aa65:	c1 e2 02             	shl    $0x2,%edx
    aa68:	83 c2 03             	add    $0x3,%edx
    aa6b:	01 d0                	add    %edx,%eax
    aa6d:	0f b6 10             	movzbl (%eax),%edx
    aa70:	8b 45 14             	mov    0x14(%ebp),%eax
    aa73:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa75:	e9 6e 01 00 00       	jmp    abe8 <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    aa7a:	8b 45 20             	mov    0x20(%ebp),%eax
    aa7d:	8b 00                	mov    (%eax),%eax
    aa7f:	83 f8 04             	cmp    $0x4,%eax
    aa82:	0f 85 95 00 00 00    	jne    ab1d <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    aa88:	8b 45 20             	mov    0x20(%ebp),%eax
    aa8b:	8b 40 04             	mov    0x4(%eax),%eax
    aa8e:	83 f8 08             	cmp    $0x8,%eax
    aa91:	75 44                	jne    aad7 <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    aa93:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa96:	01 c0                	add    %eax,%eax
    aa98:	89 c2                	mov    %eax,%edx
    aa9a:	8b 45 18             	mov    0x18(%ebp),%eax
    aa9d:	01 d0                	add    %edx,%eax
    aa9f:	0f b6 10             	movzbl (%eax),%edx
    aaa2:	8b 45 10             	mov    0x10(%ebp),%eax
    aaa5:	88 10                	mov    %dl,(%eax)
    aaa7:	8b 45 10             	mov    0x10(%ebp),%eax
    aaaa:	0f b6 10             	movzbl (%eax),%edx
    aaad:	8b 45 0c             	mov    0xc(%ebp),%eax
    aab0:	88 10                	mov    %dl,(%eax)
    aab2:	8b 45 0c             	mov    0xc(%ebp),%eax
    aab5:	0f b6 10             	movzbl (%eax),%edx
    aab8:	8b 45 08             	mov    0x8(%ebp),%eax
    aabb:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    aabd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aac0:	01 c0                	add    %eax,%eax
    aac2:	8d 50 01             	lea    0x1(%eax),%edx
    aac5:	8b 45 18             	mov    0x18(%ebp),%eax
    aac8:	01 d0                	add    %edx,%eax
    aaca:	0f b6 10             	movzbl (%eax),%edx
    aacd:	8b 45 14             	mov    0x14(%ebp),%eax
    aad0:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aad2:	e9 11 01 00 00       	jmp    abe8 <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    aad7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aada:	c1 e0 02             	shl    $0x2,%eax
    aadd:	89 c2                	mov    %eax,%edx
    aadf:	8b 45 18             	mov    0x18(%ebp),%eax
    aae2:	01 d0                	add    %edx,%eax
    aae4:	0f b6 10             	movzbl (%eax),%edx
    aae7:	8b 45 10             	mov    0x10(%ebp),%eax
    aaea:	88 10                	mov    %dl,(%eax)
    aaec:	8b 45 10             	mov    0x10(%ebp),%eax
    aaef:	0f b6 10             	movzbl (%eax),%edx
    aaf2:	8b 45 0c             	mov    0xc(%ebp),%eax
    aaf5:	88 10                	mov    %dl,(%eax)
    aaf7:	8b 45 0c             	mov    0xc(%ebp),%eax
    aafa:	0f b6 10             	movzbl (%eax),%edx
    aafd:	8b 45 08             	mov    0x8(%ebp),%eax
    ab00:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    ab02:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab05:	c1 e0 02             	shl    $0x2,%eax
    ab08:	8d 50 02             	lea    0x2(%eax),%edx
    ab0b:	8b 45 18             	mov    0x18(%ebp),%eax
    ab0e:	01 d0                	add    %edx,%eax
    ab10:	0f b6 10             	movzbl (%eax),%edx
    ab13:	8b 45 14             	mov    0x14(%ebp),%eax
    ab16:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ab18:	e9 cb 00 00 00       	jmp    abe8 <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    ab1d:	8b 45 20             	mov    0x20(%ebp),%eax
    ab20:	8b 00                	mov    (%eax),%eax
    ab22:	83 f8 06             	cmp    $0x6,%eax
    ab25:	0f 85 bd 00 00 00    	jne    abe8 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    ab2b:	8b 45 20             	mov    0x20(%ebp),%eax
    ab2e:	8b 40 04             	mov    0x4(%eax),%eax
    ab31:	83 f8 08             	cmp    $0x8,%eax
    ab34:	75 59                	jne    ab8f <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    ab36:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab39:	c1 e0 02             	shl    $0x2,%eax
    ab3c:	89 c2                	mov    %eax,%edx
    ab3e:	8b 45 18             	mov    0x18(%ebp),%eax
    ab41:	01 d0                	add    %edx,%eax
    ab43:	0f b6 10             	movzbl (%eax),%edx
    ab46:	8b 45 08             	mov    0x8(%ebp),%eax
    ab49:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    ab4b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab4e:	c1 e0 02             	shl    $0x2,%eax
    ab51:	8d 50 01             	lea    0x1(%eax),%edx
    ab54:	8b 45 18             	mov    0x18(%ebp),%eax
    ab57:	01 d0                	add    %edx,%eax
    ab59:	0f b6 10             	movzbl (%eax),%edx
    ab5c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab5f:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    ab61:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab64:	c1 e0 02             	shl    $0x2,%eax
    ab67:	8d 50 02             	lea    0x2(%eax),%edx
    ab6a:	8b 45 18             	mov    0x18(%ebp),%eax
    ab6d:	01 d0                	add    %edx,%eax
    ab6f:	0f b6 10             	movzbl (%eax),%edx
    ab72:	8b 45 10             	mov    0x10(%ebp),%eax
    ab75:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    ab77:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab7a:	c1 e0 02             	shl    $0x2,%eax
    ab7d:	8d 50 03             	lea    0x3(%eax),%edx
    ab80:	8b 45 18             	mov    0x18(%ebp),%eax
    ab83:	01 d0                	add    %edx,%eax
    ab85:	0f b6 10             	movzbl (%eax),%edx
    ab88:	8b 45 14             	mov    0x14(%ebp),%eax
    ab8b:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ab8d:	eb 59                	jmp    abe8 <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    ab8f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab92:	c1 e0 03             	shl    $0x3,%eax
    ab95:	89 c2                	mov    %eax,%edx
    ab97:	8b 45 18             	mov    0x18(%ebp),%eax
    ab9a:	01 d0                	add    %edx,%eax
    ab9c:	0f b6 10             	movzbl (%eax),%edx
    ab9f:	8b 45 08             	mov    0x8(%ebp),%eax
    aba2:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    aba4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aba7:	c1 e0 03             	shl    $0x3,%eax
    abaa:	8d 50 02             	lea    0x2(%eax),%edx
    abad:	8b 45 18             	mov    0x18(%ebp),%eax
    abb0:	01 d0                	add    %edx,%eax
    abb2:	0f b6 10             	movzbl (%eax),%edx
    abb5:	8b 45 0c             	mov    0xc(%ebp),%eax
    abb8:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    abba:	8b 45 1c             	mov    0x1c(%ebp),%eax
    abbd:	c1 e0 03             	shl    $0x3,%eax
    abc0:	8d 50 04             	lea    0x4(%eax),%edx
    abc3:	8b 45 18             	mov    0x18(%ebp),%eax
    abc6:	01 d0                	add    %edx,%eax
    abc8:	0f b6 10             	movzbl (%eax),%edx
    abcb:	8b 45 10             	mov    0x10(%ebp),%eax
    abce:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    abd0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    abd3:	c1 e0 03             	shl    $0x3,%eax
    abd6:	8d 50 06             	lea    0x6(%eax),%edx
    abd9:	8b 45 18             	mov    0x18(%ebp),%eax
    abdc:	01 d0                	add    %edx,%eax
    abde:	0f b6 10             	movzbl (%eax),%edx
    abe1:	8b 45 14             	mov    0x14(%ebp),%eax
    abe4:	88 10                	mov    %dl,(%eax)
    }
  }
}
    abe6:	eb 00                	jmp    abe8 <getPixelColorRGBA8+0x5ca>
    abe8:	90                   	nop
    abe9:	c9                   	leave  
    abea:	c3                   	ret    

0000abeb <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    abeb:	55                   	push   %ebp
    abec:	89 e5                	mov    %esp,%ebp
    abee:	53                   	push   %ebx
    abef:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    abf2:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    abf9:	8b 45 14             	mov    0x14(%ebp),%eax
    abfc:	8b 00                	mov    (%eax),%eax
    abfe:	85 c0                	test   %eax,%eax
    ac00:	0f 85 14 02 00 00    	jne    ae1a <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    ac06:	8b 45 14             	mov    0x14(%ebp),%eax
    ac09:	8b 40 04             	mov    0x4(%eax),%eax
    ac0c:	83 f8 08             	cmp    $0x8,%eax
    ac0f:	0f 85 a0 00 00 00    	jne    acb5 <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac15:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ac1c:	eb 39                	jmp    ac57 <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    ac1e:	8b 45 08             	mov    0x8(%ebp),%eax
    ac21:	83 c0 01             	add    $0x1,%eax
    ac24:	8b 55 08             	mov    0x8(%ebp),%edx
    ac27:	83 c2 02             	add    $0x2,%edx
    ac2a:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    ac2d:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ac30:	01 d9                	add    %ebx,%ecx
    ac32:	0f b6 09             	movzbl (%ecx),%ecx
    ac35:	88 0a                	mov    %cl,(%edx)
    ac37:	0f b6 12             	movzbl (%edx),%edx
    ac3a:	88 10                	mov    %dl,(%eax)
    ac3c:	0f b6 10             	movzbl (%eax),%edx
    ac3f:	8b 45 08             	mov    0x8(%ebp),%eax
    ac42:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    ac44:	8b 45 08             	mov    0x8(%ebp),%eax
    ac47:	83 c0 03             	add    $0x3,%eax
    ac4a:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac4d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ac51:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ac54:	01 45 08             	add    %eax,0x8(%ebp)
    ac57:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac5a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ac5d:	75 bf                	jne    ac1e <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    ac5f:	8b 45 14             	mov    0x14(%ebp),%eax
    ac62:	8b 40 10             	mov    0x10(%eax),%eax
    ac65:	85 c0                	test   %eax,%eax
    ac67:	0f 84 48 06 00 00    	je     b2b5 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    ac6d:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac70:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    ac74:	f7 d8                	neg    %eax
    ac76:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac79:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ac80:	eb 26                	jmp    aca8 <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    ac82:	8b 45 08             	mov    0x8(%ebp),%eax
    ac85:	0f b6 00             	movzbl (%eax),%eax
    ac88:	0f b6 d0             	movzbl %al,%edx
    ac8b:	8b 45 14             	mov    0x14(%ebp),%eax
    ac8e:	8b 40 14             	mov    0x14(%eax),%eax
    ac91:	39 c2                	cmp    %eax,%edx
    ac93:	75 09                	jne    ac9e <getPixelColorsRGBA8+0xb3>
    ac95:	8b 45 08             	mov    0x8(%ebp),%eax
    ac98:	83 c0 03             	add    $0x3,%eax
    ac9b:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac9e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    aca2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    aca5:	01 45 08             	add    %eax,0x8(%ebp)
    aca8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    acab:	3b 45 0c             	cmp    0xc(%ebp),%eax
    acae:	75 d2                	jne    ac82 <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    acb0:	e9 00 06 00 00       	jmp    b2b5 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    acb5:	8b 45 14             	mov    0x14(%ebp),%eax
    acb8:	8b 40 04             	mov    0x4(%eax),%eax
    acbb:	83 f8 10             	cmp    $0x10,%eax
    acbe:	0f 85 a5 00 00 00    	jne    ad69 <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    acc4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    accb:	e9 88 00 00 00       	jmp    ad58 <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    acd0:	8b 45 08             	mov    0x8(%ebp),%eax
    acd3:	83 c0 01             	add    $0x1,%eax
    acd6:	8b 55 08             	mov    0x8(%ebp),%edx
    acd9:	83 c2 02             	add    $0x2,%edx
    acdc:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    acdf:	01 c9                	add    %ecx,%ecx
    ace1:	89 cb                	mov    %ecx,%ebx
    ace3:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ace6:	01 d9                	add    %ebx,%ecx
    ace8:	0f b6 09             	movzbl (%ecx),%ecx
    aceb:	88 0a                	mov    %cl,(%edx)
    aced:	0f b6 12             	movzbl (%edx),%edx
    acf0:	88 10                	mov    %dl,(%eax)
    acf2:	0f b6 10             	movzbl (%eax),%edx
    acf5:	8b 45 08             	mov    0x8(%ebp),%eax
    acf8:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    acfa:	8b 45 08             	mov    0x8(%ebp),%eax
    acfd:	8d 50 03             	lea    0x3(%eax),%edx
    ad00:	8b 45 14             	mov    0x14(%ebp),%eax
    ad03:	8b 40 10             	mov    0x10(%eax),%eax
    ad06:	85 c0                	test   %eax,%eax
    ad08:	74 3d                	je     ad47 <getPixelColorsRGBA8+0x15c>
    ad0a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad0d:	01 c0                	add    %eax,%eax
    ad0f:	89 c1                	mov    %eax,%ecx
    ad11:	8b 45 10             	mov    0x10(%ebp),%eax
    ad14:	01 c8                	add    %ecx,%eax
    ad16:	0f b6 00             	movzbl (%eax),%eax
    ad19:	0f b6 c0             	movzbl %al,%eax
    ad1c:	c1 e0 08             	shl    $0x8,%eax
    ad1f:	89 c1                	mov    %eax,%ecx
    ad21:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad24:	01 c0                	add    %eax,%eax
    ad26:	8d 58 01             	lea    0x1(%eax),%ebx
    ad29:	8b 45 10             	mov    0x10(%ebp),%eax
    ad2c:	01 d8                	add    %ebx,%eax
    ad2e:	0f b6 00             	movzbl (%eax),%eax
    ad31:	0f b6 c0             	movzbl %al,%eax
    ad34:	01 c1                	add    %eax,%ecx
    ad36:	8b 45 14             	mov    0x14(%ebp),%eax
    ad39:	8b 40 14             	mov    0x14(%eax),%eax
    ad3c:	39 c1                	cmp    %eax,%ecx
    ad3e:	75 07                	jne    ad47 <getPixelColorsRGBA8+0x15c>
    ad40:	b8 00 00 00 00       	mov    $0x0,%eax
    ad45:	eb 05                	jmp    ad4c <getPixelColorsRGBA8+0x161>
    ad47:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    ad4c:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad4e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ad52:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ad55:	01 45 08             	add    %eax,0x8(%ebp)
    ad58:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad5b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ad5e:	0f 85 6c ff ff ff    	jne    acd0 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ad64:	e9 4c 05 00 00       	jmp    b2b5 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    ad69:	8b 45 14             	mov    0x14(%ebp),%eax
    ad6c:	8b 40 04             	mov    0x4(%eax),%eax
    ad6f:	ba 01 00 00 00       	mov    $0x1,%edx
    ad74:	89 c1                	mov    %eax,%ecx
    ad76:	d3 e2                	shl    %cl,%edx
    ad78:	89 d0                	mov    %edx,%eax
    ad7a:	83 e8 01             	sub    $0x1,%eax
    ad7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    ad80:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad87:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ad8e:	eb 79                	jmp    ae09 <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ad90:	8b 45 14             	mov    0x14(%ebp),%eax
    ad93:	8b 40 04             	mov    0x4(%eax),%eax
    ad96:	50                   	push   %eax
    ad97:	ff 75 10             	pushl  0x10(%ebp)
    ad9a:	8d 45 e0             	lea    -0x20(%ebp),%eax
    ad9d:	50                   	push   %eax
    ad9e:	e8 c0 d4 ff ff       	call   8263 <readBitsFromReversedStream>
    ada3:	83 c4 0c             	add    $0xc,%esp
    ada6:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    ada9:	8b 45 08             	mov    0x8(%ebp),%eax
    adac:	8d 48 01             	lea    0x1(%eax),%ecx
    adaf:	8b 45 08             	mov    0x8(%ebp),%eax
    adb2:	8d 58 02             	lea    0x2(%eax),%ebx
    adb5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    adb8:	89 d0                	mov    %edx,%eax
    adba:	c1 e0 08             	shl    $0x8,%eax
    adbd:	29 d0                	sub    %edx,%eax
    adbf:	ba 00 00 00 00       	mov    $0x0,%edx
    adc4:	f7 75 f0             	divl   -0x10(%ebp)
    adc7:	88 03                	mov    %al,(%ebx)
    adc9:	0f b6 03             	movzbl (%ebx),%eax
    adcc:	88 01                	mov    %al,(%ecx)
    adce:	0f b6 11             	movzbl (%ecx),%edx
    add1:	8b 45 08             	mov    0x8(%ebp),%eax
    add4:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    add6:	8b 45 08             	mov    0x8(%ebp),%eax
    add9:	8d 50 03             	lea    0x3(%eax),%edx
    addc:	8b 45 14             	mov    0x14(%ebp),%eax
    addf:	8b 40 10             	mov    0x10(%eax),%eax
    ade2:	85 c0                	test   %eax,%eax
    ade4:	74 12                	je     adf8 <getPixelColorsRGBA8+0x20d>
    ade6:	8b 45 14             	mov    0x14(%ebp),%eax
    ade9:	8b 40 14             	mov    0x14(%eax),%eax
    adec:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    adef:	75 07                	jne    adf8 <getPixelColorsRGBA8+0x20d>
    adf1:	b8 00 00 00 00       	mov    $0x0,%eax
    adf6:	eb 05                	jmp    adfd <getPixelColorsRGBA8+0x212>
    adf8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    adfd:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    adff:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ae03:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ae06:	01 45 08             	add    %eax,0x8(%ebp)
    ae09:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae0c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ae0f:	0f 85 7b ff ff ff    	jne    ad90 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ae15:	e9 9b 04 00 00       	jmp    b2b5 <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    ae1a:	8b 45 14             	mov    0x14(%ebp),%eax
    ae1d:	8b 00                	mov    (%eax),%eax
    ae1f:	83 f8 02             	cmp    $0x2,%eax
    ae22:	0f 85 41 02 00 00    	jne    b069 <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    ae28:	8b 45 14             	mov    0x14(%ebp),%eax
    ae2b:	8b 40 04             	mov    0x4(%eax),%eax
    ae2e:	83 f8 08             	cmp    $0x8,%eax
    ae31:	0f 85 c4 00 00 00    	jne    aefb <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae37:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae3e:	eb 31                	jmp    ae71 <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    ae40:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae43:	89 d0                	mov    %edx,%eax
    ae45:	01 c0                	add    %eax,%eax
    ae47:	01 d0                	add    %edx,%eax
    ae49:	89 c2                	mov    %eax,%edx
    ae4b:	8b 45 10             	mov    0x10(%ebp),%eax
    ae4e:	01 d0                	add    %edx,%eax
    ae50:	6a 03                	push   $0x3
    ae52:	50                   	push   %eax
    ae53:	ff 75 08             	pushl  0x8(%ebp)
    ae56:	e8 a3 85 ff ff       	call   33fe <lodepng_memcpy>
    ae5b:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    ae5e:	8b 45 08             	mov    0x8(%ebp),%eax
    ae61:	83 c0 03             	add    $0x3,%eax
    ae64:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae67:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ae6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ae6e:	01 45 08             	add    %eax,0x8(%ebp)
    ae71:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae74:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ae77:	75 c7                	jne    ae40 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    ae79:	8b 45 14             	mov    0x14(%ebp),%eax
    ae7c:	8b 40 10             	mov    0x10(%eax),%eax
    ae7f:	85 c0                	test   %eax,%eax
    ae81:	0f 84 2e 04 00 00    	je     b2b5 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    ae87:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae8a:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    ae8e:	f7 d8                	neg    %eax
    ae90:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae93:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae9a:	eb 52                	jmp    aeee <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    ae9c:	8b 45 08             	mov    0x8(%ebp),%eax
    ae9f:	0f b6 00             	movzbl (%eax),%eax
    aea2:	0f b6 d0             	movzbl %al,%edx
    aea5:	8b 45 14             	mov    0x14(%ebp),%eax
    aea8:	8b 40 14             	mov    0x14(%eax),%eax
    aeab:	39 c2                	cmp    %eax,%edx
    aead:	75 35                	jne    aee4 <getPixelColorsRGBA8+0x2f9>
    aeaf:	8b 45 08             	mov    0x8(%ebp),%eax
    aeb2:	83 c0 01             	add    $0x1,%eax
    aeb5:	0f b6 00             	movzbl (%eax),%eax
    aeb8:	0f b6 d0             	movzbl %al,%edx
    aebb:	8b 45 14             	mov    0x14(%ebp),%eax
    aebe:	8b 40 18             	mov    0x18(%eax),%eax
    aec1:	39 c2                	cmp    %eax,%edx
    aec3:	75 1f                	jne    aee4 <getPixelColorsRGBA8+0x2f9>
    aec5:	8b 45 08             	mov    0x8(%ebp),%eax
    aec8:	83 c0 02             	add    $0x2,%eax
    aecb:	0f b6 00             	movzbl (%eax),%eax
    aece:	0f b6 d0             	movzbl %al,%edx
    aed1:	8b 45 14             	mov    0x14(%ebp),%eax
    aed4:	8b 40 1c             	mov    0x1c(%eax),%eax
    aed7:	39 c2                	cmp    %eax,%edx
    aed9:	75 09                	jne    aee4 <getPixelColorsRGBA8+0x2f9>
    aedb:	8b 45 08             	mov    0x8(%ebp),%eax
    aede:	83 c0 03             	add    $0x3,%eax
    aee1:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aee4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    aee8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    aeeb:	01 45 08             	add    %eax,0x8(%ebp)
    aeee:	8b 45 f8             	mov    -0x8(%ebp),%eax
    aef1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    aef4:	75 a6                	jne    ae9c <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    aef6:	e9 ba 03 00 00       	jmp    b2b5 <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aefb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    af02:	e9 51 01 00 00       	jmp    b058 <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    af07:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af0a:	89 d0                	mov    %edx,%eax
    af0c:	01 c0                	add    %eax,%eax
    af0e:	01 d0                	add    %edx,%eax
    af10:	01 c0                	add    %eax,%eax
    af12:	89 c2                	mov    %eax,%edx
    af14:	8b 45 10             	mov    0x10(%ebp),%eax
    af17:	01 d0                	add    %edx,%eax
    af19:	0f b6 10             	movzbl (%eax),%edx
    af1c:	8b 45 08             	mov    0x8(%ebp),%eax
    af1f:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    af21:	8b 45 08             	mov    0x8(%ebp),%eax
    af24:	8d 48 01             	lea    0x1(%eax),%ecx
    af27:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af2a:	89 d0                	mov    %edx,%eax
    af2c:	01 c0                	add    %eax,%eax
    af2e:	01 d0                	add    %edx,%eax
    af30:	01 c0                	add    %eax,%eax
    af32:	8d 50 02             	lea    0x2(%eax),%edx
    af35:	8b 45 10             	mov    0x10(%ebp),%eax
    af38:	01 d0                	add    %edx,%eax
    af3a:	0f b6 00             	movzbl (%eax),%eax
    af3d:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    af3f:	8b 45 08             	mov    0x8(%ebp),%eax
    af42:	8d 48 02             	lea    0x2(%eax),%ecx
    af45:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af48:	89 d0                	mov    %edx,%eax
    af4a:	01 c0                	add    %eax,%eax
    af4c:	01 d0                	add    %edx,%eax
    af4e:	01 c0                	add    %eax,%eax
    af50:	8d 50 04             	lea    0x4(%eax),%edx
    af53:	8b 45 10             	mov    0x10(%ebp),%eax
    af56:	01 d0                	add    %edx,%eax
    af58:	0f b6 00             	movzbl (%eax),%eax
    af5b:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    af5d:	8b 45 08             	mov    0x8(%ebp),%eax
    af60:	8d 48 03             	lea    0x3(%eax),%ecx
    af63:	8b 45 14             	mov    0x14(%ebp),%eax
    af66:	8b 40 10             	mov    0x10(%eax),%eax
    af69:	85 c0                	test   %eax,%eax
    af6b:	0f 84 d6 00 00 00    	je     b047 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    af71:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af74:	89 d0                	mov    %edx,%eax
    af76:	01 c0                	add    %eax,%eax
    af78:	01 d0                	add    %edx,%eax
    af7a:	01 c0                	add    %eax,%eax
    af7c:	89 c2                	mov    %eax,%edx
    af7e:	8b 45 10             	mov    0x10(%ebp),%eax
    af81:	01 d0                	add    %edx,%eax
    af83:	0f b6 00             	movzbl (%eax),%eax
    af86:	0f b6 c0             	movzbl %al,%eax
    af89:	c1 e0 08             	shl    $0x8,%eax
    af8c:	89 c3                	mov    %eax,%ebx
    af8e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af91:	89 d0                	mov    %edx,%eax
    af93:	01 c0                	add    %eax,%eax
    af95:	01 d0                	add    %edx,%eax
    af97:	01 c0                	add    %eax,%eax
    af99:	8d 50 01             	lea    0x1(%eax),%edx
    af9c:	8b 45 10             	mov    0x10(%ebp),%eax
    af9f:	01 d0                	add    %edx,%eax
    afa1:	0f b6 00             	movzbl (%eax),%eax
    afa4:	0f b6 c0             	movzbl %al,%eax
    afa7:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    afaa:	8b 45 14             	mov    0x14(%ebp),%eax
    afad:	8b 40 14             	mov    0x14(%eax),%eax
    afb0:	39 c2                	cmp    %eax,%edx
    afb2:	0f 85 8f 00 00 00    	jne    b047 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    afb8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    afbb:	89 d0                	mov    %edx,%eax
    afbd:	01 c0                	add    %eax,%eax
    afbf:	01 d0                	add    %edx,%eax
    afc1:	01 c0                	add    %eax,%eax
    afc3:	8d 50 02             	lea    0x2(%eax),%edx
    afc6:	8b 45 10             	mov    0x10(%ebp),%eax
    afc9:	01 d0                	add    %edx,%eax
    afcb:	0f b6 00             	movzbl (%eax),%eax
    afce:	0f b6 c0             	movzbl %al,%eax
    afd1:	c1 e0 08             	shl    $0x8,%eax
    afd4:	89 c3                	mov    %eax,%ebx
    afd6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    afd9:	89 d0                	mov    %edx,%eax
    afdb:	01 c0                	add    %eax,%eax
    afdd:	01 d0                	add    %edx,%eax
    afdf:	01 c0                	add    %eax,%eax
    afe1:	8d 50 03             	lea    0x3(%eax),%edx
    afe4:	8b 45 10             	mov    0x10(%ebp),%eax
    afe7:	01 d0                	add    %edx,%eax
    afe9:	0f b6 00             	movzbl (%eax),%eax
    afec:	0f b6 c0             	movzbl %al,%eax
    afef:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    aff2:	8b 45 14             	mov    0x14(%ebp),%eax
    aff5:	8b 40 18             	mov    0x18(%eax),%eax
    aff8:	39 c2                	cmp    %eax,%edx
    affa:	75 4b                	jne    b047 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    affc:	8b 55 f8             	mov    -0x8(%ebp),%edx
    afff:	89 d0                	mov    %edx,%eax
    b001:	01 c0                	add    %eax,%eax
    b003:	01 d0                	add    %edx,%eax
    b005:	01 c0                	add    %eax,%eax
    b007:	8d 50 04             	lea    0x4(%eax),%edx
    b00a:	8b 45 10             	mov    0x10(%ebp),%eax
    b00d:	01 d0                	add    %edx,%eax
    b00f:	0f b6 00             	movzbl (%eax),%eax
    b012:	0f b6 c0             	movzbl %al,%eax
    b015:	c1 e0 08             	shl    $0x8,%eax
    b018:	89 c3                	mov    %eax,%ebx
    b01a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b01d:	89 d0                	mov    %edx,%eax
    b01f:	01 c0                	add    %eax,%eax
    b021:	01 d0                	add    %edx,%eax
    b023:	01 c0                	add    %eax,%eax
    b025:	8d 50 05             	lea    0x5(%eax),%edx
    b028:	8b 45 10             	mov    0x10(%ebp),%eax
    b02b:	01 d0                	add    %edx,%eax
    b02d:	0f b6 00             	movzbl (%eax),%eax
    b030:	0f b6 c0             	movzbl %al,%eax
    b033:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b036:	8b 45 14             	mov    0x14(%ebp),%eax
    b039:	8b 40 1c             	mov    0x1c(%eax),%eax
    b03c:	39 c2                	cmp    %eax,%edx
    b03e:	75 07                	jne    b047 <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    b040:	b8 00 00 00 00       	mov    $0x0,%eax
    b045:	eb 05                	jmp    b04c <getPixelColorsRGBA8+0x461>
    b047:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b04c:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b04e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b052:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b055:	01 45 08             	add    %eax,0x8(%ebp)
    b058:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b05b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b05e:	0f 85 a3 fe ff ff    	jne    af07 <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b064:	e9 4c 02 00 00       	jmp    b2b5 <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b069:	8b 45 14             	mov    0x14(%ebp),%eax
    b06c:	8b 00                	mov    (%eax),%eax
    b06e:	83 f8 03             	cmp    $0x3,%eax
    b071:	0f 85 b4 00 00 00    	jne    b12b <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    b077:	8b 45 14             	mov    0x14(%ebp),%eax
    b07a:	8b 40 04             	mov    0x4(%eax),%eax
    b07d:	83 f8 08             	cmp    $0x8,%eax
    b080:	75 4d                	jne    b0cf <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b082:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b089:	eb 37                	jmp    b0c2 <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    b08b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b08e:	8b 45 10             	mov    0x10(%ebp),%eax
    b091:	01 d0                	add    %edx,%eax
    b093:	0f b6 00             	movzbl (%eax),%eax
    b096:	0f b6 c0             	movzbl %al,%eax
    b099:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b09c:	8b 45 14             	mov    0x14(%ebp),%eax
    b09f:	8b 40 08             	mov    0x8(%eax),%eax
    b0a2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b0a5:	c1 e2 02             	shl    $0x2,%edx
    b0a8:	01 d0                	add    %edx,%eax
    b0aa:	6a 04                	push   $0x4
    b0ac:	50                   	push   %eax
    b0ad:	ff 75 08             	pushl  0x8(%ebp)
    b0b0:	e8 49 83 ff ff       	call   33fe <lodepng_memcpy>
    b0b5:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0b8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b0bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b0bf:	01 45 08             	add    %eax,0x8(%ebp)
    b0c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b0c5:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b0c8:	75 c1                	jne    b08b <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b0ca:	e9 e6 01 00 00       	jmp    b2b5 <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    b0cf:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0d6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b0dd:	eb 3f                	jmp    b11e <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b0df:	8b 45 14             	mov    0x14(%ebp),%eax
    b0e2:	8b 40 04             	mov    0x4(%eax),%eax
    b0e5:	50                   	push   %eax
    b0e6:	ff 75 10             	pushl  0x10(%ebp)
    b0e9:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b0ec:	50                   	push   %eax
    b0ed:	e8 71 d1 ff ff       	call   8263 <readBitsFromReversedStream>
    b0f2:	83 c4 0c             	add    $0xc,%esp
    b0f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b0f8:	8b 45 14             	mov    0x14(%ebp),%eax
    b0fb:	8b 40 08             	mov    0x8(%eax),%eax
    b0fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b101:	c1 e2 02             	shl    $0x2,%edx
    b104:	01 d0                	add    %edx,%eax
    b106:	6a 04                	push   $0x4
    b108:	50                   	push   %eax
    b109:	ff 75 08             	pushl  0x8(%ebp)
    b10c:	e8 ed 82 ff ff       	call   33fe <lodepng_memcpy>
    b111:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b114:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b118:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b11b:	01 45 08             	add    %eax,0x8(%ebp)
    b11e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b121:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b124:	75 b9                	jne    b0df <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b126:	e9 8a 01 00 00       	jmp    b2b5 <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b12b:	8b 45 14             	mov    0x14(%ebp),%eax
    b12e:	8b 00                	mov    (%eax),%eax
    b130:	83 f8 04             	cmp    $0x4,%eax
    b133:	0f 85 d1 00 00 00    	jne    b20a <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b139:	8b 45 14             	mov    0x14(%ebp),%eax
    b13c:	8b 40 04             	mov    0x4(%eax),%eax
    b13f:	83 f8 08             	cmp    $0x8,%eax
    b142:	75 62                	jne    b1a6 <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b144:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b14b:	eb 4c                	jmp    b199 <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b14d:	8b 45 08             	mov    0x8(%ebp),%eax
    b150:	83 c0 01             	add    $0x1,%eax
    b153:	8b 55 08             	mov    0x8(%ebp),%edx
    b156:	83 c2 02             	add    $0x2,%edx
    b159:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b15c:	01 c9                	add    %ecx,%ecx
    b15e:	89 cb                	mov    %ecx,%ebx
    b160:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b163:	01 d9                	add    %ebx,%ecx
    b165:	0f b6 09             	movzbl (%ecx),%ecx
    b168:	88 0a                	mov    %cl,(%edx)
    b16a:	0f b6 12             	movzbl (%edx),%edx
    b16d:	88 10                	mov    %dl,(%eax)
    b16f:	0f b6 10             	movzbl (%eax),%edx
    b172:	8b 45 08             	mov    0x8(%ebp),%eax
    b175:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b177:	8b 45 08             	mov    0x8(%ebp),%eax
    b17a:	8d 50 03             	lea    0x3(%eax),%edx
    b17d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b180:	01 c0                	add    %eax,%eax
    b182:	8d 48 01             	lea    0x1(%eax),%ecx
    b185:	8b 45 10             	mov    0x10(%ebp),%eax
    b188:	01 c8                	add    %ecx,%eax
    b18a:	0f b6 00             	movzbl (%eax),%eax
    b18d:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b18f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b193:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b196:	01 45 08             	add    %eax,0x8(%ebp)
    b199:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b19c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b19f:	75 ac                	jne    b14d <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b1a1:	e9 0f 01 00 00       	jmp    b2b5 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1a6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b1ad:	eb 4e                	jmp    b1fd <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b1af:	8b 45 08             	mov    0x8(%ebp),%eax
    b1b2:	83 c0 01             	add    $0x1,%eax
    b1b5:	8b 55 08             	mov    0x8(%ebp),%edx
    b1b8:	83 c2 02             	add    $0x2,%edx
    b1bb:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b1be:	c1 e1 02             	shl    $0x2,%ecx
    b1c1:	89 cb                	mov    %ecx,%ebx
    b1c3:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b1c6:	01 d9                	add    %ebx,%ecx
    b1c8:	0f b6 09             	movzbl (%ecx),%ecx
    b1cb:	88 0a                	mov    %cl,(%edx)
    b1cd:	0f b6 12             	movzbl (%edx),%edx
    b1d0:	88 10                	mov    %dl,(%eax)
    b1d2:	0f b6 10             	movzbl (%eax),%edx
    b1d5:	8b 45 08             	mov    0x8(%ebp),%eax
    b1d8:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b1da:	8b 45 08             	mov    0x8(%ebp),%eax
    b1dd:	8d 50 03             	lea    0x3(%eax),%edx
    b1e0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1e3:	c1 e0 02             	shl    $0x2,%eax
    b1e6:	8d 48 02             	lea    0x2(%eax),%ecx
    b1e9:	8b 45 10             	mov    0x10(%ebp),%eax
    b1ec:	01 c8                	add    %ecx,%eax
    b1ee:	0f b6 00             	movzbl (%eax),%eax
    b1f1:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1f3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b1f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b1fa:	01 45 08             	add    %eax,0x8(%ebp)
    b1fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b200:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b203:	75 aa                	jne    b1af <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b205:	e9 ab 00 00 00       	jmp    b2b5 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b20a:	8b 45 14             	mov    0x14(%ebp),%eax
    b20d:	8b 00                	mov    (%eax),%eax
    b20f:	83 f8 06             	cmp    $0x6,%eax
    b212:	0f 85 9d 00 00 00    	jne    b2b5 <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b218:	8b 45 14             	mov    0x14(%ebp),%eax
    b21b:	8b 40 04             	mov    0x4(%eax),%eax
    b21e:	83 f8 08             	cmp    $0x8,%eax
    b221:	75 17                	jne    b23a <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b223:	8b 45 0c             	mov    0xc(%ebp),%eax
    b226:	c1 e0 02             	shl    $0x2,%eax
    b229:	50                   	push   %eax
    b22a:	ff 75 10             	pushl  0x10(%ebp)
    b22d:	ff 75 08             	pushl  0x8(%ebp)
    b230:	e8 c9 81 ff ff       	call   33fe <lodepng_memcpy>
    b235:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b238:	eb 7b                	jmp    b2b5 <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b23a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b241:	eb 6a                	jmp    b2ad <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b243:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b246:	c1 e0 03             	shl    $0x3,%eax
    b249:	89 c2                	mov    %eax,%edx
    b24b:	8b 45 10             	mov    0x10(%ebp),%eax
    b24e:	01 d0                	add    %edx,%eax
    b250:	0f b6 10             	movzbl (%eax),%edx
    b253:	8b 45 08             	mov    0x8(%ebp),%eax
    b256:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b258:	8b 45 08             	mov    0x8(%ebp),%eax
    b25b:	8d 50 01             	lea    0x1(%eax),%edx
    b25e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b261:	c1 e0 03             	shl    $0x3,%eax
    b264:	8d 48 02             	lea    0x2(%eax),%ecx
    b267:	8b 45 10             	mov    0x10(%ebp),%eax
    b26a:	01 c8                	add    %ecx,%eax
    b26c:	0f b6 00             	movzbl (%eax),%eax
    b26f:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b271:	8b 45 08             	mov    0x8(%ebp),%eax
    b274:	8d 50 02             	lea    0x2(%eax),%edx
    b277:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b27a:	c1 e0 03             	shl    $0x3,%eax
    b27d:	8d 48 04             	lea    0x4(%eax),%ecx
    b280:	8b 45 10             	mov    0x10(%ebp),%eax
    b283:	01 c8                	add    %ecx,%eax
    b285:	0f b6 00             	movzbl (%eax),%eax
    b288:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b28a:	8b 45 08             	mov    0x8(%ebp),%eax
    b28d:	8d 50 03             	lea    0x3(%eax),%edx
    b290:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b293:	c1 e0 03             	shl    $0x3,%eax
    b296:	8d 48 06             	lea    0x6(%eax),%ecx
    b299:	8b 45 10             	mov    0x10(%ebp),%eax
    b29c:	01 c8                	add    %ecx,%eax
    b29e:	0f b6 00             	movzbl (%eax),%eax
    b2a1:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2a3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b2a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b2aa:	01 45 08             	add    %eax,0x8(%ebp)
    b2ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2b0:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b2b3:	75 8e                	jne    b243 <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b2b5:	90                   	nop
    b2b6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b2b9:	c9                   	leave  
    b2ba:	c3                   	ret    

0000b2bb <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b2bb:	55                   	push   %ebp
    b2bc:	89 e5                	mov    %esp,%ebp
    b2be:	53                   	push   %ebx
    b2bf:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b2c2:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b2c9:	8b 45 14             	mov    0x14(%ebp),%eax
    b2cc:	8b 00                	mov    (%eax),%eax
    b2ce:	85 c0                	test   %eax,%eax
    b2d0:	0f 85 2a 01 00 00    	jne    b400 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b2d6:	8b 45 14             	mov    0x14(%ebp),%eax
    b2d9:	8b 40 04             	mov    0x4(%eax),%eax
    b2dc:	83 f8 08             	cmp    $0x8,%eax
    b2df:	75 46                	jne    b327 <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2e1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b2e8:	eb 30                	jmp    b31a <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b2ea:	8b 45 08             	mov    0x8(%ebp),%eax
    b2ed:	83 c0 01             	add    $0x1,%eax
    b2f0:	8b 55 08             	mov    0x8(%ebp),%edx
    b2f3:	83 c2 02             	add    $0x2,%edx
    b2f6:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b2f9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b2fc:	01 d9                	add    %ebx,%ecx
    b2fe:	0f b6 09             	movzbl (%ecx),%ecx
    b301:	88 0a                	mov    %cl,(%edx)
    b303:	0f b6 12             	movzbl (%edx),%edx
    b306:	88 10                	mov    %dl,(%eax)
    b308:	0f b6 10             	movzbl (%eax),%edx
    b30b:	8b 45 08             	mov    0x8(%ebp),%eax
    b30e:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b310:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b314:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b317:	01 45 08             	add    %eax,0x8(%ebp)
    b31a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b31d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b320:	75 c8                	jne    b2ea <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b322:	e9 a8 03 00 00       	jmp    b6cf <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b327:	8b 45 14             	mov    0x14(%ebp),%eax
    b32a:	8b 40 04             	mov    0x4(%eax),%eax
    b32d:	83 f8 10             	cmp    $0x10,%eax
    b330:	75 4a                	jne    b37c <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b332:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b339:	eb 34                	jmp    b36f <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b33b:	8b 45 08             	mov    0x8(%ebp),%eax
    b33e:	83 c0 01             	add    $0x1,%eax
    b341:	8b 55 08             	mov    0x8(%ebp),%edx
    b344:	83 c2 02             	add    $0x2,%edx
    b347:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b34a:	01 c9                	add    %ecx,%ecx
    b34c:	89 cb                	mov    %ecx,%ebx
    b34e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b351:	01 d9                	add    %ebx,%ecx
    b353:	0f b6 09             	movzbl (%ecx),%ecx
    b356:	88 0a                	mov    %cl,(%edx)
    b358:	0f b6 12             	movzbl (%edx),%edx
    b35b:	88 10                	mov    %dl,(%eax)
    b35d:	0f b6 10             	movzbl (%eax),%edx
    b360:	8b 45 08             	mov    0x8(%ebp),%eax
    b363:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b365:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b369:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b36c:	01 45 08             	add    %eax,0x8(%ebp)
    b36f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b372:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b375:	75 c4                	jne    b33b <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b377:	e9 53 03 00 00       	jmp    b6cf <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b37c:	8b 45 14             	mov    0x14(%ebp),%eax
    b37f:	8b 40 04             	mov    0x4(%eax),%eax
    b382:	ba 01 00 00 00       	mov    $0x1,%edx
    b387:	89 c1                	mov    %eax,%ecx
    b389:	d3 e2                	shl    %cl,%edx
    b38b:	89 d0                	mov    %edx,%eax
    b38d:	83 e8 01             	sub    $0x1,%eax
    b390:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b393:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b39a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b3a1:	eb 50                	jmp    b3f3 <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b3a3:	8b 45 14             	mov    0x14(%ebp),%eax
    b3a6:	8b 40 04             	mov    0x4(%eax),%eax
    b3a9:	50                   	push   %eax
    b3aa:	ff 75 10             	pushl  0x10(%ebp)
    b3ad:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b3b0:	50                   	push   %eax
    b3b1:	e8 ad ce ff ff       	call   8263 <readBitsFromReversedStream>
    b3b6:	83 c4 0c             	add    $0xc,%esp
    b3b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b3bc:	8b 45 08             	mov    0x8(%ebp),%eax
    b3bf:	8d 48 01             	lea    0x1(%eax),%ecx
    b3c2:	8b 45 08             	mov    0x8(%ebp),%eax
    b3c5:	8d 58 02             	lea    0x2(%eax),%ebx
    b3c8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b3cb:	89 d0                	mov    %edx,%eax
    b3cd:	c1 e0 08             	shl    $0x8,%eax
    b3d0:	29 d0                	sub    %edx,%eax
    b3d2:	ba 00 00 00 00       	mov    $0x0,%edx
    b3d7:	f7 75 f0             	divl   -0x10(%ebp)
    b3da:	88 03                	mov    %al,(%ebx)
    b3dc:	0f b6 03             	movzbl (%ebx),%eax
    b3df:	88 01                	mov    %al,(%ecx)
    b3e1:	0f b6 11             	movzbl (%ecx),%edx
    b3e4:	8b 45 08             	mov    0x8(%ebp),%eax
    b3e7:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3e9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3f0:	01 45 08             	add    %eax,0x8(%ebp)
    b3f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3f6:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b3f9:	75 a8                	jne    b3a3 <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b3fb:	e9 cf 02 00 00       	jmp    b6cf <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b400:	8b 45 14             	mov    0x14(%ebp),%eax
    b403:	8b 00                	mov    (%eax),%eax
    b405:	83 f8 02             	cmp    $0x2,%eax
    b408:	0f 85 9e 00 00 00    	jne    b4ac <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    b40e:	8b 45 14             	mov    0x14(%ebp),%eax
    b411:	8b 40 04             	mov    0x4(%eax),%eax
    b414:	83 f8 08             	cmp    $0x8,%eax
    b417:	75 1d                	jne    b436 <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    b419:	8b 55 0c             	mov    0xc(%ebp),%edx
    b41c:	89 d0                	mov    %edx,%eax
    b41e:	01 c0                	add    %eax,%eax
    b420:	01 d0                	add    %edx,%eax
    b422:	50                   	push   %eax
    b423:	ff 75 10             	pushl  0x10(%ebp)
    b426:	ff 75 08             	pushl  0x8(%ebp)
    b429:	e8 d0 7f ff ff       	call   33fe <lodepng_memcpy>
    b42e:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b431:	e9 99 02 00 00       	jmp    b6cf <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b436:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b43d:	eb 60                	jmp    b49f <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    b43f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b442:	89 d0                	mov    %edx,%eax
    b444:	01 c0                	add    %eax,%eax
    b446:	01 d0                	add    %edx,%eax
    b448:	01 c0                	add    %eax,%eax
    b44a:	89 c2                	mov    %eax,%edx
    b44c:	8b 45 10             	mov    0x10(%ebp),%eax
    b44f:	01 d0                	add    %edx,%eax
    b451:	0f b6 10             	movzbl (%eax),%edx
    b454:	8b 45 08             	mov    0x8(%ebp),%eax
    b457:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b459:	8b 45 08             	mov    0x8(%ebp),%eax
    b45c:	8d 48 01             	lea    0x1(%eax),%ecx
    b45f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b462:	89 d0                	mov    %edx,%eax
    b464:	01 c0                	add    %eax,%eax
    b466:	01 d0                	add    %edx,%eax
    b468:	01 c0                	add    %eax,%eax
    b46a:	8d 50 02             	lea    0x2(%eax),%edx
    b46d:	8b 45 10             	mov    0x10(%ebp),%eax
    b470:	01 d0                	add    %edx,%eax
    b472:	0f b6 00             	movzbl (%eax),%eax
    b475:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b477:	8b 45 08             	mov    0x8(%ebp),%eax
    b47a:	8d 48 02             	lea    0x2(%eax),%ecx
    b47d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b480:	89 d0                	mov    %edx,%eax
    b482:	01 c0                	add    %eax,%eax
    b484:	01 d0                	add    %edx,%eax
    b486:	01 c0                	add    %eax,%eax
    b488:	8d 50 04             	lea    0x4(%eax),%edx
    b48b:	8b 45 10             	mov    0x10(%ebp),%eax
    b48e:	01 d0                	add    %edx,%eax
    b490:	0f b6 00             	movzbl (%eax),%eax
    b493:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b495:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b499:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b49c:	01 45 08             	add    %eax,0x8(%ebp)
    b49f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4a2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b4a5:	75 98                	jne    b43f <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b4a7:	e9 23 02 00 00       	jmp    b6cf <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b4ac:	8b 45 14             	mov    0x14(%ebp),%eax
    b4af:	8b 00                	mov    (%eax),%eax
    b4b1:	83 f8 03             	cmp    $0x3,%eax
    b4b4:	0f 85 b4 00 00 00    	jne    b56e <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    b4ba:	8b 45 14             	mov    0x14(%ebp),%eax
    b4bd:	8b 40 04             	mov    0x4(%eax),%eax
    b4c0:	83 f8 08             	cmp    $0x8,%eax
    b4c3:	75 4d                	jne    b512 <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4c5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b4cc:	eb 37                	jmp    b505 <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    b4ce:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b4d1:	8b 45 10             	mov    0x10(%ebp),%eax
    b4d4:	01 d0                	add    %edx,%eax
    b4d6:	0f b6 00             	movzbl (%eax),%eax
    b4d9:	0f b6 c0             	movzbl %al,%eax
    b4dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b4df:	8b 45 14             	mov    0x14(%ebp),%eax
    b4e2:	8b 40 08             	mov    0x8(%eax),%eax
    b4e5:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b4e8:	c1 e2 02             	shl    $0x2,%edx
    b4eb:	01 d0                	add    %edx,%eax
    b4ed:	6a 03                	push   $0x3
    b4ef:	50                   	push   %eax
    b4f0:	ff 75 08             	pushl  0x8(%ebp)
    b4f3:	e8 06 7f ff ff       	call   33fe <lodepng_memcpy>
    b4f8:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4fb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b4ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b502:	01 45 08             	add    %eax,0x8(%ebp)
    b505:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b508:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b50b:	75 c1                	jne    b4ce <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b50d:	e9 bd 01 00 00       	jmp    b6cf <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    b512:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b519:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b520:	eb 3f                	jmp    b561 <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b522:	8b 45 14             	mov    0x14(%ebp),%eax
    b525:	8b 40 04             	mov    0x4(%eax),%eax
    b528:	50                   	push   %eax
    b529:	ff 75 10             	pushl  0x10(%ebp)
    b52c:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b52f:	50                   	push   %eax
    b530:	e8 2e cd ff ff       	call   8263 <readBitsFromReversedStream>
    b535:	83 c4 0c             	add    $0xc,%esp
    b538:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b53b:	8b 45 14             	mov    0x14(%ebp),%eax
    b53e:	8b 40 08             	mov    0x8(%eax),%eax
    b541:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b544:	c1 e2 02             	shl    $0x2,%edx
    b547:	01 d0                	add    %edx,%eax
    b549:	6a 03                	push   $0x3
    b54b:	50                   	push   %eax
    b54c:	ff 75 08             	pushl  0x8(%ebp)
    b54f:	e8 aa 7e ff ff       	call   33fe <lodepng_memcpy>
    b554:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b557:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b55b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b55e:	01 45 08             	add    %eax,0x8(%ebp)
    b561:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b564:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b567:	75 b9                	jne    b522 <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b569:	e9 61 01 00 00       	jmp    b6cf <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b56e:	8b 45 14             	mov    0x14(%ebp),%eax
    b571:	8b 00                	mov    (%eax),%eax
    b573:	83 f8 04             	cmp    $0x4,%eax
    b576:	0f 85 a0 00 00 00    	jne    b61c <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    b57c:	8b 45 14             	mov    0x14(%ebp),%eax
    b57f:	8b 40 04             	mov    0x4(%eax),%eax
    b582:	83 f8 08             	cmp    $0x8,%eax
    b585:	75 4a                	jne    b5d1 <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b587:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b58e:	eb 34                	jmp    b5c4 <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b590:	8b 45 08             	mov    0x8(%ebp),%eax
    b593:	83 c0 01             	add    $0x1,%eax
    b596:	8b 55 08             	mov    0x8(%ebp),%edx
    b599:	83 c2 02             	add    $0x2,%edx
    b59c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b59f:	01 c9                	add    %ecx,%ecx
    b5a1:	89 cb                	mov    %ecx,%ebx
    b5a3:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b5a6:	01 d9                	add    %ebx,%ecx
    b5a8:	0f b6 09             	movzbl (%ecx),%ecx
    b5ab:	88 0a                	mov    %cl,(%edx)
    b5ad:	0f b6 12             	movzbl (%edx),%edx
    b5b0:	88 10                	mov    %dl,(%eax)
    b5b2:	0f b6 10             	movzbl (%eax),%edx
    b5b5:	8b 45 08             	mov    0x8(%ebp),%eax
    b5b8:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5ba:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b5be:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5c1:	01 45 08             	add    %eax,0x8(%ebp)
    b5c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5c7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b5ca:	75 c4                	jne    b590 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b5cc:	e9 fe 00 00 00       	jmp    b6cf <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5d1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b5d8:	eb 35                	jmp    b60f <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b5da:	8b 45 08             	mov    0x8(%ebp),%eax
    b5dd:	83 c0 01             	add    $0x1,%eax
    b5e0:	8b 55 08             	mov    0x8(%ebp),%edx
    b5e3:	83 c2 02             	add    $0x2,%edx
    b5e6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b5e9:	c1 e1 02             	shl    $0x2,%ecx
    b5ec:	89 cb                	mov    %ecx,%ebx
    b5ee:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b5f1:	01 d9                	add    %ebx,%ecx
    b5f3:	0f b6 09             	movzbl (%ecx),%ecx
    b5f6:	88 0a                	mov    %cl,(%edx)
    b5f8:	0f b6 12             	movzbl (%edx),%edx
    b5fb:	88 10                	mov    %dl,(%eax)
    b5fd:	0f b6 10             	movzbl (%eax),%edx
    b600:	8b 45 08             	mov    0x8(%ebp),%eax
    b603:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b605:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b609:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b60c:	01 45 08             	add    %eax,0x8(%ebp)
    b60f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b612:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b615:	75 c3                	jne    b5da <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b617:	e9 b3 00 00 00       	jmp    b6cf <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b61c:	8b 45 14             	mov    0x14(%ebp),%eax
    b61f:	8b 00                	mov    (%eax),%eax
    b621:	83 f8 06             	cmp    $0x6,%eax
    b624:	0f 85 a5 00 00 00    	jne    b6cf <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    b62a:	8b 45 14             	mov    0x14(%ebp),%eax
    b62d:	8b 40 04             	mov    0x4(%eax),%eax
    b630:	83 f8 08             	cmp    $0x8,%eax
    b633:	75 38                	jne    b66d <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b635:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b63c:	eb 25                	jmp    b663 <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    b63e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b641:	c1 e0 02             	shl    $0x2,%eax
    b644:	89 c2                	mov    %eax,%edx
    b646:	8b 45 10             	mov    0x10(%ebp),%eax
    b649:	01 d0                	add    %edx,%eax
    b64b:	6a 03                	push   $0x3
    b64d:	50                   	push   %eax
    b64e:	ff 75 08             	pushl  0x8(%ebp)
    b651:	e8 a8 7d ff ff       	call   33fe <lodepng_memcpy>
    b656:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b659:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b65d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b660:	01 45 08             	add    %eax,0x8(%ebp)
    b663:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b666:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b669:	75 d3                	jne    b63e <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b66b:	eb 62                	jmp    b6cf <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b66d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b674:	eb 51                	jmp    b6c7 <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    b676:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b679:	c1 e0 03             	shl    $0x3,%eax
    b67c:	89 c2                	mov    %eax,%edx
    b67e:	8b 45 10             	mov    0x10(%ebp),%eax
    b681:	01 d0                	add    %edx,%eax
    b683:	0f b6 10             	movzbl (%eax),%edx
    b686:	8b 45 08             	mov    0x8(%ebp),%eax
    b689:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b68b:	8b 45 08             	mov    0x8(%ebp),%eax
    b68e:	8d 50 01             	lea    0x1(%eax),%edx
    b691:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b694:	c1 e0 03             	shl    $0x3,%eax
    b697:	8d 48 02             	lea    0x2(%eax),%ecx
    b69a:	8b 45 10             	mov    0x10(%ebp),%eax
    b69d:	01 c8                	add    %ecx,%eax
    b69f:	0f b6 00             	movzbl (%eax),%eax
    b6a2:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b6a4:	8b 45 08             	mov    0x8(%ebp),%eax
    b6a7:	8d 50 02             	lea    0x2(%eax),%edx
    b6aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6ad:	c1 e0 03             	shl    $0x3,%eax
    b6b0:	8d 48 04             	lea    0x4(%eax),%ecx
    b6b3:	8b 45 10             	mov    0x10(%ebp),%eax
    b6b6:	01 c8                	add    %ecx,%eax
    b6b8:	0f b6 00             	movzbl (%eax),%eax
    b6bb:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b6bd:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b6c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b6c4:	01 45 08             	add    %eax,0x8(%ebp)
    b6c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6ca:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b6cd:	75 a7                	jne    b676 <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b6cf:	90                   	nop
    b6d0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b6d3:	c9                   	leave  
    b6d4:	c3                   	ret    

0000b6d5 <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    b6d5:	55                   	push   %ebp
    b6d6:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    b6d8:	8b 45 20             	mov    0x20(%ebp),%eax
    b6db:	8b 00                	mov    (%eax),%eax
    b6dd:	85 c0                	test   %eax,%eax
    b6df:	0f 85 a4 00 00 00    	jne    b789 <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    b6e5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b6e8:	01 c0                	add    %eax,%eax
    b6ea:	89 c2                	mov    %eax,%edx
    b6ec:	8b 45 18             	mov    0x18(%ebp),%eax
    b6ef:	01 d0                	add    %edx,%eax
    b6f1:	0f b6 00             	movzbl (%eax),%eax
    b6f4:	0f b6 c0             	movzbl %al,%eax
    b6f7:	c1 e0 08             	shl    $0x8,%eax
    b6fa:	89 c2                	mov    %eax,%edx
    b6fc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b6ff:	01 c0                	add    %eax,%eax
    b701:	8d 48 01             	lea    0x1(%eax),%ecx
    b704:	8b 45 18             	mov    0x18(%ebp),%eax
    b707:	01 c8                	add    %ecx,%eax
    b709:	0f b6 00             	movzbl (%eax),%eax
    b70c:	0f b6 c0             	movzbl %al,%eax
    b70f:	01 c2                	add    %eax,%edx
    b711:	8b 45 10             	mov    0x10(%ebp),%eax
    b714:	66 89 10             	mov    %dx,(%eax)
    b717:	8b 45 10             	mov    0x10(%ebp),%eax
    b71a:	0f b7 10             	movzwl (%eax),%edx
    b71d:	8b 45 0c             	mov    0xc(%ebp),%eax
    b720:	66 89 10             	mov    %dx,(%eax)
    b723:	8b 45 0c             	mov    0xc(%ebp),%eax
    b726:	0f b7 10             	movzwl (%eax),%edx
    b729:	8b 45 08             	mov    0x8(%ebp),%eax
    b72c:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    b72f:	8b 45 20             	mov    0x20(%ebp),%eax
    b732:	8b 40 10             	mov    0x10(%eax),%eax
    b735:	85 c0                	test   %eax,%eax
    b737:	74 43                	je     b77c <getPixelColorRGBA16+0xa7>
    b739:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b73c:	01 c0                	add    %eax,%eax
    b73e:	89 c2                	mov    %eax,%edx
    b740:	8b 45 18             	mov    0x18(%ebp),%eax
    b743:	01 d0                	add    %edx,%eax
    b745:	0f b6 00             	movzbl (%eax),%eax
    b748:	0f b6 c0             	movzbl %al,%eax
    b74b:	c1 e0 08             	shl    $0x8,%eax
    b74e:	89 c2                	mov    %eax,%edx
    b750:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b753:	01 c0                	add    %eax,%eax
    b755:	8d 48 01             	lea    0x1(%eax),%ecx
    b758:	8b 45 18             	mov    0x18(%ebp),%eax
    b75b:	01 c8                	add    %ecx,%eax
    b75d:	0f b6 00             	movzbl (%eax),%eax
    b760:	0f b6 c0             	movzbl %al,%eax
    b763:	01 c2                	add    %eax,%edx
    b765:	8b 45 20             	mov    0x20(%ebp),%eax
    b768:	8b 40 14             	mov    0x14(%eax),%eax
    b76b:	39 c2                	cmp    %eax,%edx
    b76d:	75 0d                	jne    b77c <getPixelColorRGBA16+0xa7>
    b76f:	8b 45 14             	mov    0x14(%ebp),%eax
    b772:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b777:	e9 48 03 00 00       	jmp    bac4 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b77c:	8b 45 14             	mov    0x14(%ebp),%eax
    b77f:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b784:	e9 3b 03 00 00       	jmp    bac4 <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    b789:	8b 45 20             	mov    0x20(%ebp),%eax
    b78c:	8b 00                	mov    (%eax),%eax
    b78e:	83 f8 02             	cmp    $0x2,%eax
    b791:	0f 85 b6 01 00 00    	jne    b94d <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    b797:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b79a:	89 d0                	mov    %edx,%eax
    b79c:	01 c0                	add    %eax,%eax
    b79e:	01 d0                	add    %edx,%eax
    b7a0:	01 c0                	add    %eax,%eax
    b7a2:	89 c2                	mov    %eax,%edx
    b7a4:	8b 45 18             	mov    0x18(%ebp),%eax
    b7a7:	01 d0                	add    %edx,%eax
    b7a9:	0f b6 00             	movzbl (%eax),%eax
    b7ac:	0f b6 c0             	movzbl %al,%eax
    b7af:	c1 e0 08             	shl    $0x8,%eax
    b7b2:	89 c1                	mov    %eax,%ecx
    b7b4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7b7:	89 d0                	mov    %edx,%eax
    b7b9:	01 c0                	add    %eax,%eax
    b7bb:	01 d0                	add    %edx,%eax
    b7bd:	01 c0                	add    %eax,%eax
    b7bf:	8d 50 01             	lea    0x1(%eax),%edx
    b7c2:	8b 45 18             	mov    0x18(%ebp),%eax
    b7c5:	01 d0                	add    %edx,%eax
    b7c7:	0f b6 00             	movzbl (%eax),%eax
    b7ca:	0f b6 c0             	movzbl %al,%eax
    b7cd:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b7d0:	8b 45 08             	mov    0x8(%ebp),%eax
    b7d3:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    b7d6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7d9:	89 d0                	mov    %edx,%eax
    b7db:	01 c0                	add    %eax,%eax
    b7dd:	01 d0                	add    %edx,%eax
    b7df:	01 c0                	add    %eax,%eax
    b7e1:	8d 50 02             	lea    0x2(%eax),%edx
    b7e4:	8b 45 18             	mov    0x18(%ebp),%eax
    b7e7:	01 d0                	add    %edx,%eax
    b7e9:	0f b6 00             	movzbl (%eax),%eax
    b7ec:	0f b6 c0             	movzbl %al,%eax
    b7ef:	c1 e0 08             	shl    $0x8,%eax
    b7f2:	89 c1                	mov    %eax,%ecx
    b7f4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7f7:	89 d0                	mov    %edx,%eax
    b7f9:	01 c0                	add    %eax,%eax
    b7fb:	01 d0                	add    %edx,%eax
    b7fd:	01 c0                	add    %eax,%eax
    b7ff:	8d 50 03             	lea    0x3(%eax),%edx
    b802:	8b 45 18             	mov    0x18(%ebp),%eax
    b805:	01 d0                	add    %edx,%eax
    b807:	0f b6 00             	movzbl (%eax),%eax
    b80a:	0f b6 c0             	movzbl %al,%eax
    b80d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b810:	8b 45 0c             	mov    0xc(%ebp),%eax
    b813:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    b816:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b819:	89 d0                	mov    %edx,%eax
    b81b:	01 c0                	add    %eax,%eax
    b81d:	01 d0                	add    %edx,%eax
    b81f:	01 c0                	add    %eax,%eax
    b821:	8d 50 04             	lea    0x4(%eax),%edx
    b824:	8b 45 18             	mov    0x18(%ebp),%eax
    b827:	01 d0                	add    %edx,%eax
    b829:	0f b6 00             	movzbl (%eax),%eax
    b82c:	0f b6 c0             	movzbl %al,%eax
    b82f:	c1 e0 08             	shl    $0x8,%eax
    b832:	89 c1                	mov    %eax,%ecx
    b834:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b837:	89 d0                	mov    %edx,%eax
    b839:	01 c0                	add    %eax,%eax
    b83b:	01 d0                	add    %edx,%eax
    b83d:	01 c0                	add    %eax,%eax
    b83f:	8d 50 05             	lea    0x5(%eax),%edx
    b842:	8b 45 18             	mov    0x18(%ebp),%eax
    b845:	01 d0                	add    %edx,%eax
    b847:	0f b6 00             	movzbl (%eax),%eax
    b84a:	0f b6 c0             	movzbl %al,%eax
    b84d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b850:	8b 45 10             	mov    0x10(%ebp),%eax
    b853:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    b856:	8b 45 20             	mov    0x20(%ebp),%eax
    b859:	8b 40 10             	mov    0x10(%eax),%eax
    b85c:	85 c0                	test   %eax,%eax
    b85e:	0f 84 dc 00 00 00    	je     b940 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b864:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b867:	89 d0                	mov    %edx,%eax
    b869:	01 c0                	add    %eax,%eax
    b86b:	01 d0                	add    %edx,%eax
    b86d:	01 c0                	add    %eax,%eax
    b86f:	89 c2                	mov    %eax,%edx
    b871:	8b 45 18             	mov    0x18(%ebp),%eax
    b874:	01 d0                	add    %edx,%eax
    b876:	0f b6 00             	movzbl (%eax),%eax
    b879:	0f b6 c0             	movzbl %al,%eax
    b87c:	c1 e0 08             	shl    $0x8,%eax
    b87f:	89 c1                	mov    %eax,%ecx
    b881:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b884:	89 d0                	mov    %edx,%eax
    b886:	01 c0                	add    %eax,%eax
    b888:	01 d0                	add    %edx,%eax
    b88a:	01 c0                	add    %eax,%eax
    b88c:	8d 50 01             	lea    0x1(%eax),%edx
    b88f:	8b 45 18             	mov    0x18(%ebp),%eax
    b892:	01 d0                	add    %edx,%eax
    b894:	0f b6 00             	movzbl (%eax),%eax
    b897:	0f b6 c0             	movzbl %al,%eax
    b89a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b89d:	8b 45 20             	mov    0x20(%ebp),%eax
    b8a0:	8b 40 14             	mov    0x14(%eax),%eax
    b8a3:	39 c2                	cmp    %eax,%edx
    b8a5:	0f 85 95 00 00 00    	jne    b940 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b8ab:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8ae:	89 d0                	mov    %edx,%eax
    b8b0:	01 c0                	add    %eax,%eax
    b8b2:	01 d0                	add    %edx,%eax
    b8b4:	01 c0                	add    %eax,%eax
    b8b6:	8d 50 02             	lea    0x2(%eax),%edx
    b8b9:	8b 45 18             	mov    0x18(%ebp),%eax
    b8bc:	01 d0                	add    %edx,%eax
    b8be:	0f b6 00             	movzbl (%eax),%eax
    b8c1:	0f b6 c0             	movzbl %al,%eax
    b8c4:	c1 e0 08             	shl    $0x8,%eax
    b8c7:	89 c1                	mov    %eax,%ecx
    b8c9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8cc:	89 d0                	mov    %edx,%eax
    b8ce:	01 c0                	add    %eax,%eax
    b8d0:	01 d0                	add    %edx,%eax
    b8d2:	01 c0                	add    %eax,%eax
    b8d4:	8d 50 03             	lea    0x3(%eax),%edx
    b8d7:	8b 45 18             	mov    0x18(%ebp),%eax
    b8da:	01 d0                	add    %edx,%eax
    b8dc:	0f b6 00             	movzbl (%eax),%eax
    b8df:	0f b6 c0             	movzbl %al,%eax
    b8e2:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b8e5:	8b 45 20             	mov    0x20(%ebp),%eax
    b8e8:	8b 40 18             	mov    0x18(%eax),%eax
    b8eb:	39 c2                	cmp    %eax,%edx
    b8ed:	75 51                	jne    b940 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    b8ef:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8f2:	89 d0                	mov    %edx,%eax
    b8f4:	01 c0                	add    %eax,%eax
    b8f6:	01 d0                	add    %edx,%eax
    b8f8:	01 c0                	add    %eax,%eax
    b8fa:	8d 50 04             	lea    0x4(%eax),%edx
    b8fd:	8b 45 18             	mov    0x18(%ebp),%eax
    b900:	01 d0                	add    %edx,%eax
    b902:	0f b6 00             	movzbl (%eax),%eax
    b905:	0f b6 c0             	movzbl %al,%eax
    b908:	c1 e0 08             	shl    $0x8,%eax
    b90b:	89 c1                	mov    %eax,%ecx
    b90d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b910:	89 d0                	mov    %edx,%eax
    b912:	01 c0                	add    %eax,%eax
    b914:	01 d0                	add    %edx,%eax
    b916:	01 c0                	add    %eax,%eax
    b918:	8d 50 05             	lea    0x5(%eax),%edx
    b91b:	8b 45 18             	mov    0x18(%ebp),%eax
    b91e:	01 d0                	add    %edx,%eax
    b920:	0f b6 00             	movzbl (%eax),%eax
    b923:	0f b6 c0             	movzbl %al,%eax
    b926:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b929:	8b 45 20             	mov    0x20(%ebp),%eax
    b92c:	8b 40 1c             	mov    0x1c(%eax),%eax
    b92f:	39 c2                	cmp    %eax,%edx
    b931:	75 0d                	jne    b940 <getPixelColorRGBA16+0x26b>
    b933:	8b 45 14             	mov    0x14(%ebp),%eax
    b936:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b93b:	e9 84 01 00 00       	jmp    bac4 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b940:	8b 45 14             	mov    0x14(%ebp),%eax
    b943:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b948:	e9 77 01 00 00       	jmp    bac4 <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b94d:	8b 45 20             	mov    0x20(%ebp),%eax
    b950:	8b 00                	mov    (%eax),%eax
    b952:	83 f8 04             	cmp    $0x4,%eax
    b955:	0f 85 86 00 00 00    	jne    b9e1 <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    b95b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b95e:	c1 e0 02             	shl    $0x2,%eax
    b961:	89 c2                	mov    %eax,%edx
    b963:	8b 45 18             	mov    0x18(%ebp),%eax
    b966:	01 d0                	add    %edx,%eax
    b968:	0f b6 00             	movzbl (%eax),%eax
    b96b:	0f b6 c0             	movzbl %al,%eax
    b96e:	c1 e0 08             	shl    $0x8,%eax
    b971:	89 c2                	mov    %eax,%edx
    b973:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b976:	c1 e0 02             	shl    $0x2,%eax
    b979:	8d 48 01             	lea    0x1(%eax),%ecx
    b97c:	8b 45 18             	mov    0x18(%ebp),%eax
    b97f:	01 c8                	add    %ecx,%eax
    b981:	0f b6 00             	movzbl (%eax),%eax
    b984:	0f b6 c0             	movzbl %al,%eax
    b987:	01 c2                	add    %eax,%edx
    b989:	8b 45 10             	mov    0x10(%ebp),%eax
    b98c:	66 89 10             	mov    %dx,(%eax)
    b98f:	8b 45 10             	mov    0x10(%ebp),%eax
    b992:	0f b7 10             	movzwl (%eax),%edx
    b995:	8b 45 0c             	mov    0xc(%ebp),%eax
    b998:	66 89 10             	mov    %dx,(%eax)
    b99b:	8b 45 0c             	mov    0xc(%ebp),%eax
    b99e:	0f b7 10             	movzwl (%eax),%edx
    b9a1:	8b 45 08             	mov    0x8(%ebp),%eax
    b9a4:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    b9a7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9aa:	c1 e0 02             	shl    $0x2,%eax
    b9ad:	8d 50 02             	lea    0x2(%eax),%edx
    b9b0:	8b 45 18             	mov    0x18(%ebp),%eax
    b9b3:	01 d0                	add    %edx,%eax
    b9b5:	0f b6 00             	movzbl (%eax),%eax
    b9b8:	0f b6 c0             	movzbl %al,%eax
    b9bb:	c1 e0 08             	shl    $0x8,%eax
    b9be:	89 c2                	mov    %eax,%edx
    b9c0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9c3:	c1 e0 02             	shl    $0x2,%eax
    b9c6:	8d 48 03             	lea    0x3(%eax),%ecx
    b9c9:	8b 45 18             	mov    0x18(%ebp),%eax
    b9cc:	01 c8                	add    %ecx,%eax
    b9ce:	0f b6 00             	movzbl (%eax),%eax
    b9d1:	0f b6 c0             	movzbl %al,%eax
    b9d4:	01 c2                	add    %eax,%edx
    b9d6:	8b 45 14             	mov    0x14(%ebp),%eax
    b9d9:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b9dc:	e9 e3 00 00 00       	jmp    bac4 <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    b9e1:	8b 45 20             	mov    0x20(%ebp),%eax
    b9e4:	8b 00                	mov    (%eax),%eax
    b9e6:	83 f8 06             	cmp    $0x6,%eax
    b9e9:	0f 85 d5 00 00 00    	jne    bac4 <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    b9ef:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9f2:	c1 e0 03             	shl    $0x3,%eax
    b9f5:	89 c2                	mov    %eax,%edx
    b9f7:	8b 45 18             	mov    0x18(%ebp),%eax
    b9fa:	01 d0                	add    %edx,%eax
    b9fc:	0f b6 00             	movzbl (%eax),%eax
    b9ff:	0f b6 c0             	movzbl %al,%eax
    ba02:	c1 e0 08             	shl    $0x8,%eax
    ba05:	89 c2                	mov    %eax,%edx
    ba07:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba0a:	c1 e0 03             	shl    $0x3,%eax
    ba0d:	8d 48 01             	lea    0x1(%eax),%ecx
    ba10:	8b 45 18             	mov    0x18(%ebp),%eax
    ba13:	01 c8                	add    %ecx,%eax
    ba15:	0f b6 00             	movzbl (%eax),%eax
    ba18:	0f b6 c0             	movzbl %al,%eax
    ba1b:	01 c2                	add    %eax,%edx
    ba1d:	8b 45 08             	mov    0x8(%ebp),%eax
    ba20:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    ba23:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba26:	c1 e0 03             	shl    $0x3,%eax
    ba29:	8d 50 02             	lea    0x2(%eax),%edx
    ba2c:	8b 45 18             	mov    0x18(%ebp),%eax
    ba2f:	01 d0                	add    %edx,%eax
    ba31:	0f b6 00             	movzbl (%eax),%eax
    ba34:	0f b6 c0             	movzbl %al,%eax
    ba37:	c1 e0 08             	shl    $0x8,%eax
    ba3a:	89 c2                	mov    %eax,%edx
    ba3c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba3f:	c1 e0 03             	shl    $0x3,%eax
    ba42:	8d 48 03             	lea    0x3(%eax),%ecx
    ba45:	8b 45 18             	mov    0x18(%ebp),%eax
    ba48:	01 c8                	add    %ecx,%eax
    ba4a:	0f b6 00             	movzbl (%eax),%eax
    ba4d:	0f b6 c0             	movzbl %al,%eax
    ba50:	01 c2                	add    %eax,%edx
    ba52:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba55:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    ba58:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba5b:	c1 e0 03             	shl    $0x3,%eax
    ba5e:	8d 50 04             	lea    0x4(%eax),%edx
    ba61:	8b 45 18             	mov    0x18(%ebp),%eax
    ba64:	01 d0                	add    %edx,%eax
    ba66:	0f b6 00             	movzbl (%eax),%eax
    ba69:	0f b6 c0             	movzbl %al,%eax
    ba6c:	c1 e0 08             	shl    $0x8,%eax
    ba6f:	89 c2                	mov    %eax,%edx
    ba71:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba74:	c1 e0 03             	shl    $0x3,%eax
    ba77:	8d 48 05             	lea    0x5(%eax),%ecx
    ba7a:	8b 45 18             	mov    0x18(%ebp),%eax
    ba7d:	01 c8                	add    %ecx,%eax
    ba7f:	0f b6 00             	movzbl (%eax),%eax
    ba82:	0f b6 c0             	movzbl %al,%eax
    ba85:	01 c2                	add    %eax,%edx
    ba87:	8b 45 10             	mov    0x10(%ebp),%eax
    ba8a:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    ba8d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba90:	c1 e0 03             	shl    $0x3,%eax
    ba93:	8d 50 06             	lea    0x6(%eax),%edx
    ba96:	8b 45 18             	mov    0x18(%ebp),%eax
    ba99:	01 d0                	add    %edx,%eax
    ba9b:	0f b6 00             	movzbl (%eax),%eax
    ba9e:	0f b6 c0             	movzbl %al,%eax
    baa1:	c1 e0 08             	shl    $0x8,%eax
    baa4:	89 c2                	mov    %eax,%edx
    baa6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    baa9:	c1 e0 03             	shl    $0x3,%eax
    baac:	8d 48 07             	lea    0x7(%eax),%ecx
    baaf:	8b 45 18             	mov    0x18(%ebp),%eax
    bab2:	01 c8                	add    %ecx,%eax
    bab4:	0f b6 00             	movzbl (%eax),%eax
    bab7:	0f b6 c0             	movzbl %al,%eax
    baba:	01 c2                	add    %eax,%edx
    babc:	8b 45 14             	mov    0x14(%ebp),%eax
    babf:	66 89 10             	mov    %dx,(%eax)
  }
}
    bac2:	eb 00                	jmp    bac4 <getPixelColorRGBA16+0x3ef>
    bac4:	90                   	nop
    bac5:	5d                   	pop    %ebp
    bac6:	c3                   	ret    

0000bac7 <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    bac7:	55                   	push   %ebp
    bac8:	89 e5                	mov    %esp,%ebp
    baca:	56                   	push   %esi
    bacb:	53                   	push   %ebx
    bacc:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    bacf:	8b 55 18             	mov    0x18(%ebp),%edx
    bad2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bad5:	0f af c2             	imul   %edx,%eax
    bad8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    badb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    bae2:	8b 45 14             	mov    0x14(%ebp),%eax
    bae5:	8b 00                	mov    (%eax),%eax
    bae7:	83 f8 03             	cmp    $0x3,%eax
    baea:	75 14                	jne    bb00 <lodepng_convert+0x39>
    baec:	8b 45 14             	mov    0x14(%ebp),%eax
    baef:	8b 40 08             	mov    0x8(%eax),%eax
    baf2:	85 c0                	test   %eax,%eax
    baf4:	75 0a                	jne    bb00 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    baf6:	b8 6b 00 00 00       	mov    $0x6b,%eax
    bafb:	e9 19 03 00 00       	jmp    be19 <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    bb00:	ff 75 14             	pushl  0x14(%ebp)
    bb03:	ff 75 10             	pushl  0x10(%ebp)
    bb06:	e8 b7 d1 ff ff       	call   8cc2 <lodepng_color_mode_equal>
    bb0b:	83 c4 08             	add    $0x8,%esp
    bb0e:	85 c0                	test   %eax,%eax
    bb10:	74 2f                	je     bb41 <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bb12:	ff 75 14             	pushl  0x14(%ebp)
    bb15:	ff 75 1c             	pushl  0x1c(%ebp)
    bb18:	ff 75 18             	pushl  0x18(%ebp)
    bb1b:	e8 fb d4 ff ff       	call   901b <lodepng_get_raw_size>
    bb20:	83 c4 0c             	add    $0xc,%esp
    bb23:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    bb26:	ff 75 dc             	pushl  -0x24(%ebp)
    bb29:	ff 75 0c             	pushl  0xc(%ebp)
    bb2c:	ff 75 08             	pushl  0x8(%ebp)
    bb2f:	e8 ca 78 ff ff       	call   33fe <lodepng_memcpy>
    bb34:	83 c4 0c             	add    $0xc,%esp
    return 0;
    bb37:	b8 00 00 00 00       	mov    $0x0,%eax
    bb3c:	e9 d8 02 00 00       	jmp    be19 <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bb41:	8b 45 10             	mov    0x10(%ebp),%eax
    bb44:	8b 00                	mov    (%eax),%eax
    bb46:	83 f8 03             	cmp    $0x3,%eax
    bb49:	0f 85 16 01 00 00    	jne    bc65 <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    bb4f:	8b 45 10             	mov    0x10(%ebp),%eax
    bb52:	8b 40 0c             	mov    0xc(%eax),%eax
    bb55:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    bb58:	8b 45 10             	mov    0x10(%ebp),%eax
    bb5b:	8b 40 08             	mov    0x8(%eax),%eax
    bb5e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    bb61:	8b 45 10             	mov    0x10(%ebp),%eax
    bb64:	8b 40 04             	mov    0x4(%eax),%eax
    bb67:	ba 01 00 00 00       	mov    $0x1,%edx
    bb6c:	89 c1                	mov    %eax,%ecx
    bb6e:	d3 e2                	shl    %cl,%edx
    bb70:	89 d0                	mov    %edx,%eax
    bb72:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    bb75:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    bb79:	75 5b                	jne    bbd6 <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    bb7b:	8b 45 14             	mov    0x14(%ebp),%eax
    bb7e:	8b 40 0c             	mov    0xc(%eax),%eax
    bb81:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    bb84:	8b 45 14             	mov    0x14(%ebp),%eax
    bb87:	8b 40 08             	mov    0x8(%eax),%eax
    bb8a:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    bb8d:	8b 45 14             	mov    0x14(%ebp),%eax
    bb90:	8b 00                	mov    (%eax),%eax
    bb92:	83 f8 03             	cmp    $0x3,%eax
    bb95:	75 3f                	jne    bbd6 <lodepng_convert+0x10f>
    bb97:	8b 45 14             	mov    0x14(%ebp),%eax
    bb9a:	8b 50 04             	mov    0x4(%eax),%edx
    bb9d:	8b 45 10             	mov    0x10(%ebp),%eax
    bba0:	8b 40 04             	mov    0x4(%eax),%eax
    bba3:	39 c2                	cmp    %eax,%edx
    bba5:	75 2f                	jne    bbd6 <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bba7:	ff 75 14             	pushl  0x14(%ebp)
    bbaa:	ff 75 1c             	pushl  0x1c(%ebp)
    bbad:	ff 75 18             	pushl  0x18(%ebp)
    bbb0:	e8 66 d4 ff ff       	call   901b <lodepng_get_raw_size>
    bbb5:	83 c4 0c             	add    $0xc,%esp
    bbb8:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    bbbb:	ff 75 d8             	pushl  -0x28(%ebp)
    bbbe:	ff 75 0c             	pushl  0xc(%ebp)
    bbc1:	ff 75 08             	pushl  0x8(%ebp)
    bbc4:	e8 35 78 ff ff       	call   33fe <lodepng_memcpy>
    bbc9:	83 c4 0c             	add    $0xc,%esp
        return 0;
    bbcc:	b8 00 00 00 00       	mov    $0x0,%eax
    bbd1:	e9 43 02 00 00       	jmp    be19 <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    bbd6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bbd9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bbdc:	7d 06                	jge    bbe4 <lodepng_convert+0x11d>
    bbde:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bbe1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    bbe4:	8d 45 90             	lea    -0x70(%ebp),%eax
    bbe7:	50                   	push   %eax
    bbe8:	e8 5f e1 ff ff       	call   9d4c <color_tree_init>
    bbed:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    bbf0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bbf7:	eb 61                	jmp    bc5a <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    bbf9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bbfc:	c1 e0 02             	shl    $0x2,%eax
    bbff:	89 c2                	mov    %eax,%edx
    bc01:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bc04:	01 d0                	add    %edx,%eax
    bc06:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    bc09:	8b 75 f4             	mov    -0xc(%ebp),%esi
    bc0c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bc0f:	83 c0 03             	add    $0x3,%eax
    bc12:	0f b6 00             	movzbl (%eax),%eax
    bc15:	0f b6 d8             	movzbl %al,%ebx
    bc18:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bc1b:	83 c0 02             	add    $0x2,%eax
    bc1e:	0f b6 00             	movzbl (%eax),%eax
    bc21:	0f b6 c8             	movzbl %al,%ecx
    bc24:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bc27:	83 c0 01             	add    $0x1,%eax
    bc2a:	0f b6 00             	movzbl (%eax),%eax
    bc2d:	0f b6 d0             	movzbl %al,%edx
    bc30:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bc33:	0f b6 00             	movzbl (%eax),%eax
    bc36:	0f b6 c0             	movzbl %al,%eax
    bc39:	83 ec 08             	sub    $0x8,%esp
    bc3c:	56                   	push   %esi
    bc3d:	53                   	push   %ebx
    bc3e:	51                   	push   %ecx
    bc3f:	52                   	push   %edx
    bc40:	50                   	push   %eax
    bc41:	8d 45 90             	lea    -0x70(%ebp),%eax
    bc44:	50                   	push   %eax
    bc45:	e8 85 e2 ff ff       	call   9ecf <color_tree_add>
    bc4a:	83 c4 20             	add    $0x20,%esp
    bc4d:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    bc50:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bc54:	75 0e                	jne    bc64 <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    bc56:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bc5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bc5d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bc60:	75 97                	jne    bbf9 <lodepng_convert+0x132>
    bc62:	eb 01                	jmp    bc65 <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    bc64:	90                   	nop
    }
  }

  if(!error) {
    bc65:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bc69:	0f 85 8e 01 00 00    	jne    bdfd <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bc6f:	8b 45 14             	mov    0x14(%ebp),%eax
    bc72:	8b 40 04             	mov    0x4(%eax),%eax
    bc75:	83 f8 10             	cmp    $0x10,%eax
    bc78:	0f 85 99 00 00 00    	jne    bd17 <lodepng_convert+0x250>
    bc7e:	8b 45 10             	mov    0x10(%ebp),%eax
    bc81:	8b 40 04             	mov    0x4(%eax),%eax
    bc84:	83 f8 10             	cmp    $0x10,%eax
    bc87:	0f 85 8a 00 00 00    	jne    bd17 <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    bc8d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bc94:	eb 74                	jmp    bd0a <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    bc96:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    bc9c:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    bca2:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    bca8:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    bcae:	83 ec 04             	sub    $0x4,%esp
    bcb1:	ff 75 14             	pushl  0x14(%ebp)
    bcb4:	ff 75 f4             	pushl  -0xc(%ebp)
    bcb7:	ff 75 0c             	pushl  0xc(%ebp)
    bcba:	8d 45 88             	lea    -0x78(%ebp),%eax
    bcbd:	50                   	push   %eax
    bcbe:	8d 45 8a             	lea    -0x76(%ebp),%eax
    bcc1:	50                   	push   %eax
    bcc2:	8d 45 8c             	lea    -0x74(%ebp),%eax
    bcc5:	50                   	push   %eax
    bcc6:	8d 45 8e             	lea    -0x72(%ebp),%eax
    bcc9:	50                   	push   %eax
    bcca:	e8 06 fa ff ff       	call   b6d5 <getPixelColorRGBA16>
    bccf:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    bcd2:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    bcd6:	0f b7 d8             	movzwl %ax,%ebx
    bcd9:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    bcdd:	0f b7 c8             	movzwl %ax,%ecx
    bce0:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    bce4:	0f b7 d0             	movzwl %ax,%edx
    bce7:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    bceb:	0f b7 c0             	movzwl %ax,%eax
    bcee:	83 ec 04             	sub    $0x4,%esp
    bcf1:	53                   	push   %ebx
    bcf2:	51                   	push   %ecx
    bcf3:	52                   	push   %edx
    bcf4:	50                   	push   %eax
    bcf5:	ff 75 10             	pushl  0x10(%ebp)
    bcf8:	ff 75 f4             	pushl  -0xc(%ebp)
    bcfb:	ff 75 08             	pushl  0x8(%ebp)
    bcfe:	e8 d3 e6 ff ff       	call   a3d6 <rgba16ToPixel>
    bd03:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    bd06:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bd0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bd0d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bd10:	75 84                	jne    bc96 <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bd12:	e9 e6 00 00 00       	jmp    bdfd <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    bd17:	8b 45 10             	mov    0x10(%ebp),%eax
    bd1a:	8b 40 04             	mov    0x4(%eax),%eax
    bd1d:	83 f8 08             	cmp    $0x8,%eax
    bd20:	75 23                	jne    bd45 <lodepng_convert+0x27e>
    bd22:	8b 45 10             	mov    0x10(%ebp),%eax
    bd25:	8b 00                	mov    (%eax),%eax
    bd27:	83 f8 06             	cmp    $0x6,%eax
    bd2a:	75 19                	jne    bd45 <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    bd2c:	ff 75 14             	pushl  0x14(%ebp)
    bd2f:	ff 75 0c             	pushl  0xc(%ebp)
    bd32:	ff 75 e0             	pushl  -0x20(%ebp)
    bd35:	ff 75 08             	pushl  0x8(%ebp)
    bd38:	e8 ae ee ff ff       	call   abeb <getPixelColorsRGBA8>
    bd3d:	83 c4 10             	add    $0x10,%esp
    bd40:	e9 b8 00 00 00       	jmp    bdfd <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    bd45:	8b 45 10             	mov    0x10(%ebp),%eax
    bd48:	8b 40 04             	mov    0x4(%eax),%eax
    bd4b:	83 f8 08             	cmp    $0x8,%eax
    bd4e:	75 23                	jne    bd73 <lodepng_convert+0x2ac>
    bd50:	8b 45 10             	mov    0x10(%ebp),%eax
    bd53:	8b 00                	mov    (%eax),%eax
    bd55:	83 f8 02             	cmp    $0x2,%eax
    bd58:	75 19                	jne    bd73 <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    bd5a:	ff 75 14             	pushl  0x14(%ebp)
    bd5d:	ff 75 0c             	pushl  0xc(%ebp)
    bd60:	ff 75 e0             	pushl  -0x20(%ebp)
    bd63:	ff 75 08             	pushl  0x8(%ebp)
    bd66:	e8 50 f5 ff ff       	call   b2bb <getPixelColorsRGB8>
    bd6b:	83 c4 10             	add    $0x10,%esp
    bd6e:	e9 8a 00 00 00       	jmp    bdfd <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    bd73:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    bd77:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    bd7b:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    bd7f:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    bd83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bd8a:	eb 66                	jmp    bdf2 <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    bd8c:	83 ec 04             	sub    $0x4,%esp
    bd8f:	ff 75 14             	pushl  0x14(%ebp)
    bd92:	ff 75 f4             	pushl  -0xc(%ebp)
    bd95:	ff 75 0c             	pushl  0xc(%ebp)
    bd98:	8d 45 84             	lea    -0x7c(%ebp),%eax
    bd9b:	50                   	push   %eax
    bd9c:	8d 45 85             	lea    -0x7b(%ebp),%eax
    bd9f:	50                   	push   %eax
    bda0:	8d 45 86             	lea    -0x7a(%ebp),%eax
    bda3:	50                   	push   %eax
    bda4:	8d 45 87             	lea    -0x79(%ebp),%eax
    bda7:	50                   	push   %eax
    bda8:	e8 71 e8 ff ff       	call   a61e <getPixelColorRGBA8>
    bdad:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    bdb0:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    bdb4:	0f b6 d8             	movzbl %al,%ebx
    bdb7:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    bdbb:	0f b6 c8             	movzbl %al,%ecx
    bdbe:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    bdc2:	0f b6 d0             	movzbl %al,%edx
    bdc5:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    bdc9:	0f b6 c0             	movzbl %al,%eax
    bdcc:	53                   	push   %ebx
    bdcd:	51                   	push   %ecx
    bdce:	52                   	push   %edx
    bdcf:	50                   	push   %eax
    bdd0:	8d 45 90             	lea    -0x70(%ebp),%eax
    bdd3:	50                   	push   %eax
    bdd4:	ff 75 10             	pushl  0x10(%ebp)
    bdd7:	ff 75 f4             	pushl  -0xc(%ebp)
    bdda:	ff 75 08             	pushl  0x8(%ebp)
    bddd:	e8 e5 e1 ff ff       	call   9fc7 <rgba8ToPixel>
    bde2:	83 c4 20             	add    $0x20,%esp
    bde5:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    bde8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bdec:	75 0e                	jne    bdfc <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    bdee:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bdf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bdf5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bdf8:	75 92                	jne    bd8c <lodepng_convert+0x2c5>
    bdfa:	eb 01                	jmp    bdfd <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    bdfc:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bdfd:	8b 45 10             	mov    0x10(%ebp),%eax
    be00:	8b 00                	mov    (%eax),%eax
    be02:	83 f8 03             	cmp    $0x3,%eax
    be05:	75 0f                	jne    be16 <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    be07:	83 ec 0c             	sub    $0xc,%esp
    be0a:	8d 45 90             	lea    -0x70(%ebp),%eax
    be0d:	50                   	push   %eax
    be0e:	e8 59 df ff ff       	call   9d6c <color_tree_cleanup>
    be13:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    be16:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    be19:	8d 65 f8             	lea    -0x8(%ebp),%esp
    be1c:	5b                   	pop    %ebx
    be1d:	5e                   	pop    %esi
    be1e:	5d                   	pop    %ebp
    be1f:	c3                   	ret    

0000be20 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    be20:	55                   	push   %ebp
    be21:	89 e5                	mov    %esp,%ebp
    be23:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    be26:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    be2d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    be34:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    be3b:	8b 45 24             	mov    0x24(%ebp),%eax
    be3e:	8b 40 04             	mov    0x4(%eax),%eax
    be41:	ba 01 00 00 00       	mov    $0x1,%edx
    be46:	89 c1                	mov    %eax,%ecx
    be48:	d3 e2                	shl    %cl,%edx
    be4a:	89 d0                	mov    %edx,%eax
    be4c:	8d 48 ff             	lea    -0x1(%eax),%ecx
    be4f:	b8 ff ff 00 00       	mov    $0xffff,%eax
    be54:	ba 00 00 00 00       	mov    $0x0,%edx
    be59:	f7 f1                	div    %ecx
    be5b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    be5e:	8b 45 20             	mov    0x20(%ebp),%eax
    be61:	8b 40 04             	mov    0x4(%eax),%eax
    be64:	ba 10 00 00 00       	mov    $0x10,%edx
    be69:	29 c2                	sub    %eax,%edx
    be6b:	89 d0                	mov    %edx,%eax
    be6d:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    be70:	8b 45 24             	mov    0x24(%ebp),%eax
    be73:	8b 00                	mov    (%eax),%eax
    be75:	85 c0                	test   %eax,%eax
    be77:	74 0a                	je     be83 <lodepng_convert_rgb+0x63>
    be79:	8b 45 24             	mov    0x24(%ebp),%eax
    be7c:	8b 00                	mov    (%eax),%eax
    be7e:	83 f8 04             	cmp    $0x4,%eax
    be81:	75 1b                	jne    be9e <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    be83:	8b 45 14             	mov    0x14(%ebp),%eax
    be86:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    be8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    be90:	89 45 f8             	mov    %eax,-0x8(%ebp)
    be93:	8b 45 f8             	mov    -0x8(%ebp),%eax
    be96:	89 45 fc             	mov    %eax,-0x4(%ebp)
    be99:	e9 c2 00 00 00       	jmp    bf60 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    be9e:	8b 45 24             	mov    0x24(%ebp),%eax
    bea1:	8b 00                	mov    (%eax),%eax
    bea3:	83 f8 02             	cmp    $0x2,%eax
    bea6:	74 0a                	je     beb2 <lodepng_convert_rgb+0x92>
    bea8:	8b 45 24             	mov    0x24(%ebp),%eax
    beab:	8b 00                	mov    (%eax),%eax
    bead:	83 f8 06             	cmp    $0x6,%eax
    beb0:	75 23                	jne    bed5 <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    beb2:	8b 45 14             	mov    0x14(%ebp),%eax
    beb5:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    beb9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    bebc:	8b 45 18             	mov    0x18(%ebp),%eax
    bebf:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bec3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    bec6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bec9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    becd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bed0:	e9 8b 00 00 00       	jmp    bf60 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    bed5:	8b 45 24             	mov    0x24(%ebp),%eax
    bed8:	8b 00                	mov    (%eax),%eax
    beda:	83 f8 03             	cmp    $0x3,%eax
    bedd:	75 77                	jne    bf56 <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    bedf:	8b 45 24             	mov    0x24(%ebp),%eax
    bee2:	8b 40 0c             	mov    0xc(%eax),%eax
    bee5:	3b 45 14             	cmp    0x14(%ebp),%eax
    bee8:	77 0a                	ja     bef4 <lodepng_convert_rgb+0xd4>
    beea:	b8 52 00 00 00       	mov    $0x52,%eax
    beef:	e9 cb 01 00 00       	jmp    c0bf <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    bef4:	8b 45 24             	mov    0x24(%ebp),%eax
    bef7:	8b 40 08             	mov    0x8(%eax),%eax
    befa:	8b 55 14             	mov    0x14(%ebp),%edx
    befd:	c1 e2 02             	shl    $0x2,%edx
    bf00:	01 d0                	add    %edx,%eax
    bf02:	0f b6 00             	movzbl (%eax),%eax
    bf05:	0f b6 d0             	movzbl %al,%edx
    bf08:	89 d0                	mov    %edx,%eax
    bf0a:	c1 e0 08             	shl    $0x8,%eax
    bf0d:	01 d0                	add    %edx,%eax
    bf0f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    bf12:	8b 45 24             	mov    0x24(%ebp),%eax
    bf15:	8b 40 08             	mov    0x8(%eax),%eax
    bf18:	8b 55 14             	mov    0x14(%ebp),%edx
    bf1b:	c1 e2 02             	shl    $0x2,%edx
    bf1e:	83 c2 01             	add    $0x1,%edx
    bf21:	01 d0                	add    %edx,%eax
    bf23:	0f b6 00             	movzbl (%eax),%eax
    bf26:	0f b6 d0             	movzbl %al,%edx
    bf29:	89 d0                	mov    %edx,%eax
    bf2b:	c1 e0 08             	shl    $0x8,%eax
    bf2e:	01 d0                	add    %edx,%eax
    bf30:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    bf33:	8b 45 24             	mov    0x24(%ebp),%eax
    bf36:	8b 40 08             	mov    0x8(%eax),%eax
    bf39:	8b 55 14             	mov    0x14(%ebp),%edx
    bf3c:	c1 e2 02             	shl    $0x2,%edx
    bf3f:	83 c2 02             	add    $0x2,%edx
    bf42:	01 d0                	add    %edx,%eax
    bf44:	0f b6 00             	movzbl (%eax),%eax
    bf47:	0f b6 d0             	movzbl %al,%edx
    bf4a:	89 d0                	mov    %edx,%eax
    bf4c:	c1 e0 08             	shl    $0x8,%eax
    bf4f:	01 d0                	add    %edx,%eax
    bf51:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bf54:	eb 0a                	jmp    bf60 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    bf56:	b8 1f 00 00 00       	mov    $0x1f,%eax
    bf5b:	e9 5f 01 00 00       	jmp    c0bf <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    bf60:	8b 45 20             	mov    0x20(%ebp),%eax
    bf63:	8b 00                	mov    (%eax),%eax
    bf65:	85 c0                	test   %eax,%eax
    bf67:	74 0a                	je     bf73 <lodepng_convert_rgb+0x153>
    bf69:	8b 45 20             	mov    0x20(%ebp),%eax
    bf6c:	8b 00                	mov    (%eax),%eax
    bf6e:	83 f8 04             	cmp    $0x4,%eax
    bf71:	75 14                	jne    bf87 <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    bf73:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf76:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bf79:	89 c1                	mov    %eax,%ecx
    bf7b:	d3 ea                	shr    %cl,%edx
    bf7d:	8b 45 08             	mov    0x8(%ebp),%eax
    bf80:	89 10                	mov    %edx,(%eax)
    bf82:	e9 33 01 00 00       	jmp    c0ba <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    bf87:	8b 45 20             	mov    0x20(%ebp),%eax
    bf8a:	8b 00                	mov    (%eax),%eax
    bf8c:	83 f8 02             	cmp    $0x2,%eax
    bf8f:	74 0a                	je     bf9b <lodepng_convert_rgb+0x17b>
    bf91:	8b 45 20             	mov    0x20(%ebp),%eax
    bf94:	8b 00                	mov    (%eax),%eax
    bf96:	83 f8 06             	cmp    $0x6,%eax
    bf99:	75 32                	jne    bfcd <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    bf9b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf9e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bfa1:	89 c1                	mov    %eax,%ecx
    bfa3:	d3 ea                	shr    %cl,%edx
    bfa5:	8b 45 08             	mov    0x8(%ebp),%eax
    bfa8:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    bfaa:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bfad:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bfb0:	89 c1                	mov    %eax,%ecx
    bfb2:	d3 ea                	shr    %cl,%edx
    bfb4:	8b 45 0c             	mov    0xc(%ebp),%eax
    bfb7:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    bfb9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bfbc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    bfbf:	89 c1                	mov    %eax,%ecx
    bfc1:	d3 ea                	shr    %cl,%edx
    bfc3:	8b 45 10             	mov    0x10(%ebp),%eax
    bfc6:	89 10                	mov    %edx,(%eax)
    bfc8:	e9 ed 00 00 00       	jmp    c0ba <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    bfcd:	8b 45 20             	mov    0x20(%ebp),%eax
    bfd0:	8b 00                	mov    (%eax),%eax
    bfd2:	83 f8 03             	cmp    $0x3,%eax
    bfd5:	0f 85 d8 00 00 00    	jne    c0b3 <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    bfdb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bfde:	c1 e8 08             	shr    $0x8,%eax
    bfe1:	89 c2                	mov    %eax,%edx
    bfe3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bfe6:	0f b6 c0             	movzbl %al,%eax
    bfe9:	39 c2                	cmp    %eax,%edx
    bfeb:	75 24                	jne    c011 <lodepng_convert_rgb+0x1f1>
    bfed:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bff0:	c1 e8 08             	shr    $0x8,%eax
    bff3:	89 c2                	mov    %eax,%edx
    bff5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bff8:	0f b6 c0             	movzbl %al,%eax
    bffb:	39 c2                	cmp    %eax,%edx
    bffd:	75 12                	jne    c011 <lodepng_convert_rgb+0x1f1>
    bfff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c002:	c1 e8 08             	shr    $0x8,%eax
    c005:	89 c2                	mov    %eax,%edx
    c007:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c00a:	0f b6 c0             	movzbl %al,%eax
    c00d:	39 c2                	cmp    %eax,%edx
    c00f:	74 0a                	je     c01b <lodepng_convert_rgb+0x1fb>
    c011:	b8 52 00 00 00       	mov    $0x52,%eax
    c016:	e9 a4 00 00 00       	jmp    c0bf <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    c01b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    c022:	eb 79                	jmp    c09d <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    c024:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c027:	c1 e0 02             	shl    $0x2,%eax
    c02a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c02d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c030:	c1 e8 08             	shr    $0x8,%eax
    c033:	89 c1                	mov    %eax,%ecx
    c035:	8b 45 20             	mov    0x20(%ebp),%eax
    c038:	8b 50 08             	mov    0x8(%eax),%edx
    c03b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c03e:	01 d0                	add    %edx,%eax
    c040:	0f b6 00             	movzbl (%eax),%eax
    c043:	0f b6 c0             	movzbl %al,%eax
    c046:	39 c1                	cmp    %eax,%ecx
    c048:	75 4f                	jne    c099 <lodepng_convert_rgb+0x279>
    c04a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c04d:	c1 e8 08             	shr    $0x8,%eax
    c050:	89 c1                	mov    %eax,%ecx
    c052:	8b 45 20             	mov    0x20(%ebp),%eax
    c055:	8b 40 08             	mov    0x8(%eax),%eax
    c058:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c05b:	83 c2 01             	add    $0x1,%edx
    c05e:	01 d0                	add    %edx,%eax
    c060:	0f b6 00             	movzbl (%eax),%eax
    c063:	0f b6 c0             	movzbl %al,%eax
    c066:	39 c1                	cmp    %eax,%ecx
    c068:	75 2f                	jne    c099 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    c06a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c06d:	c1 e8 08             	shr    $0x8,%eax
    c070:	89 c1                	mov    %eax,%ecx
    c072:	8b 45 20             	mov    0x20(%ebp),%eax
    c075:	8b 40 08             	mov    0x8(%eax),%eax
    c078:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c07b:	83 c2 02             	add    $0x2,%edx
    c07e:	01 d0                	add    %edx,%eax
    c080:	0f b6 00             	movzbl (%eax),%eax
    c083:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c086:	39 c1                	cmp    %eax,%ecx
    c088:	75 0f                	jne    c099 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    c08a:	8b 45 08             	mov    0x8(%ebp),%eax
    c08d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c090:	89 10                	mov    %edx,(%eax)
        return 0;
    c092:	b8 00 00 00 00       	mov    $0x0,%eax
    c097:	eb 26                	jmp    c0bf <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    c099:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c09d:	8b 45 20             	mov    0x20(%ebp),%eax
    c0a0:	8b 40 0c             	mov    0xc(%eax),%eax
    c0a3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    c0a6:	0f 87 78 ff ff ff    	ja     c024 <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    c0ac:	b8 52 00 00 00       	mov    $0x52,%eax
    c0b1:	eb 0c                	jmp    c0bf <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    c0b3:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c0b8:	eb 05                	jmp    c0bf <lodepng_convert_rgb+0x29f>
  }

  return 0;
    c0ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c0bf:	c9                   	leave  
    c0c0:	c3                   	ret    

0000c0c1 <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    c0c1:	55                   	push   %ebp
    c0c2:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    c0c4:	8b 45 08             	mov    0x8(%ebp),%eax
    c0c7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    c0cd:	8b 45 08             	mov    0x8(%ebp),%eax
    c0d0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    c0d7:	8b 45 08             	mov    0x8(%ebp),%eax
    c0da:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    c0e0:	8b 45 08             	mov    0x8(%ebp),%eax
    c0e3:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c0e7:	8b 45 08             	mov    0x8(%ebp),%eax
    c0ea:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c0ee:	8b 45 08             	mov    0x8(%ebp),%eax
    c0f1:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c0f5:	8b 45 08             	mov    0x8(%ebp),%eax
    c0f8:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c0fc:	8b 45 08             	mov    0x8(%ebp),%eax
    c0ff:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c106:	8b 45 08             	mov    0x8(%ebp),%eax
    c109:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c110:	8b 45 08             	mov    0x8(%ebp),%eax
    c113:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c11a:	00 00 00 
  stats->numpixels = 0;
    c11d:	8b 45 08             	mov    0x8(%ebp),%eax
    c120:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c127:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c12a:	8b 45 08             	mov    0x8(%ebp),%eax
    c12d:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c134:	00 00 00 
  stats->allow_greyscale = 1;
    c137:	8b 45 08             	mov    0x8(%ebp),%eax
    c13a:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c141:	00 00 00 
}
    c144:	90                   	nop
    c145:	5d                   	pop    %ebp
    c146:	c3                   	ret    

0000c147 <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c147:	55                   	push   %ebp
    c148:	89 e5                	mov    %esp,%ebp
    c14a:	53                   	push   %ebx
    c14b:	83 ec 04             	sub    $0x4,%esp
    c14e:	8b 45 08             	mov    0x8(%ebp),%eax
    c151:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c154:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c158:	74 06                	je     c160 <getValueRequiredBits+0x19>
    c15a:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c15e:	75 07                	jne    c167 <getValueRequiredBits+0x20>
    c160:	b8 01 00 00 00       	mov    $0x1,%eax
    c165:	eb 6b                	jmp    c1d2 <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c167:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c16b:	0f b6 d9             	movzbl %cl,%ebx
    c16e:	89 da                	mov    %ebx,%edx
    c170:	89 d0                	mov    %edx,%eax
    c172:	c1 e0 04             	shl    $0x4,%eax
    c175:	89 c2                	mov    %eax,%edx
    c177:	89 d0                	mov    %edx,%eax
    c179:	c1 e0 04             	shl    $0x4,%eax
    c17c:	29 d0                	sub    %edx,%eax
    c17e:	01 d8                	add    %ebx,%eax
    c180:	66 c1 e8 08          	shr    $0x8,%ax
    c184:	c0 e8 04             	shr    $0x4,%al
    c187:	89 c2                	mov    %eax,%edx
    c189:	c1 e2 04             	shl    $0x4,%edx
    c18c:	01 c2                	add    %eax,%edx
    c18e:	89 c8                	mov    %ecx,%eax
    c190:	29 d0                	sub    %edx,%eax
    c192:	84 c0                	test   %al,%al
    c194:	75 37                	jne    c1cd <getValueRequiredBits+0x86>
    c196:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c19a:	0f b6 d1             	movzbl %cl,%edx
    c19d:	89 d0                	mov    %edx,%eax
    c19f:	01 c0                	add    %eax,%eax
    c1a1:	01 d0                	add    %edx,%eax
    c1a3:	c1 e0 06             	shl    $0x6,%eax
    c1a6:	01 d0                	add    %edx,%eax
    c1a8:	66 c1 e8 08          	shr    $0x8,%ax
    c1ac:	c0 e8 06             	shr    $0x6,%al
    c1af:	ba 55 00 00 00       	mov    $0x55,%edx
    c1b4:	0f af c2             	imul   %edx,%eax
    c1b7:	29 c1                	sub    %eax,%ecx
    c1b9:	89 c8                	mov    %ecx,%eax
    c1bb:	84 c0                	test   %al,%al
    c1bd:	75 07                	jne    c1c6 <getValueRequiredBits+0x7f>
    c1bf:	b8 02 00 00 00       	mov    $0x2,%eax
    c1c4:	eb 0c                	jmp    c1d2 <getValueRequiredBits+0x8b>
    c1c6:	b8 04 00 00 00       	mov    $0x4,%eax
    c1cb:	eb 05                	jmp    c1d2 <getValueRequiredBits+0x8b>
  return 8;
    c1cd:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c1d2:	83 c4 04             	add    $0x4,%esp
    c1d5:	5b                   	pop    %ebx
    c1d6:	5d                   	pop    %ebp
    c1d7:	c3                   	ret    

0000c1d8 <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c1d8:	55                   	push   %ebp
    c1d9:	89 e5                	mov    %esp,%ebp
    c1db:	56                   	push   %esi
    c1dc:	53                   	push   %ebx
    c1dd:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c1e3:	8b 55 10             	mov    0x10(%ebp),%edx
    c1e6:	8b 45 14             	mov    0x14(%ebp),%eax
    c1e9:	0f af c2             	imul   %edx,%eax
    c1ec:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c1ef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c1f6:	ff 75 18             	pushl  0x18(%ebp)
    c1f9:	e8 0b cd ff ff       	call   8f09 <lodepng_is_greyscale_type>
    c1fe:	83 c4 04             	add    $0x4,%esp
    c201:	85 c0                	test   %eax,%eax
    c203:	0f 95 c0             	setne  %al
    c206:	0f b6 c0             	movzbl %al,%eax
    c209:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c20c:	ff 75 18             	pushl  0x18(%ebp)
    c20f:	e8 85 cd ff ff       	call   8f99 <lodepng_can_have_alpha>
    c214:	83 c4 04             	add    $0x4,%esp
    c217:	85 c0                	test   %eax,%eax
    c219:	0f 94 c0             	sete   %al
    c21c:	0f b6 c0             	movzbl %al,%eax
    c21f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c222:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c229:	ff 75 18             	pushl  0x18(%ebp)
    c22c:	e8 ab cc ff ff       	call   8edc <lodepng_get_bpp>
    c231:	83 c4 04             	add    $0x4,%esp
    c234:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c237:	8b 45 08             	mov    0x8(%ebp),%eax
    c23a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c240:	83 f8 01             	cmp    $0x1,%eax
    c243:	75 0d                	jne    c252 <lodepng_compute_color_stats+0x7a>
    c245:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c249:	75 07                	jne    c252 <lodepng_compute_color_stats+0x7a>
    c24b:	b8 01 00 00 00       	mov    $0x1,%eax
    c250:	eb 05                	jmp    c257 <lodepng_compute_color_stats+0x7f>
    c252:	b8 00 00 00 00       	mov    $0x0,%eax
    c257:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c25a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c261:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c268:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c26c:	77 26                	ja     c294 <lodepng_compute_color_stats+0xbc>
    c26e:	8b 45 08             	mov    0x8(%ebp),%eax
    c271:	8b 50 14             	mov    0x14(%eax),%edx
    c274:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c277:	bb 01 00 00 00       	mov    $0x1,%ebx
    c27c:	89 c1                	mov    %eax,%ecx
    c27e:	d3 e3                	shl    %cl,%ebx
    c280:	89 d8                	mov    %ebx,%eax
    c282:	01 d0                	add    %edx,%eax
    c284:	ba 01 01 00 00       	mov    $0x101,%edx
    c289:	3d 01 01 00 00       	cmp    $0x101,%eax
    c28e:	0f 47 c2             	cmova  %edx,%eax
    c291:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c294:	8b 45 08             	mov    0x8(%ebp),%eax
    c297:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c29d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c2a0:	01 c2                	add    %eax,%edx
    c2a2:	8b 45 08             	mov    0x8(%ebp),%eax
    c2a5:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c2ab:	8b 45 08             	mov    0x8(%ebp),%eax
    c2ae:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c2b4:	85 c0                	test   %eax,%eax
    c2b6:	75 07                	jne    c2bf <lodepng_compute_color_stats+0xe7>
    c2b8:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c2bf:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c2c5:	50                   	push   %eax
    c2c6:	e8 81 da ff ff       	call   9d4c <color_tree_init>
    c2cb:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c2ce:	8b 45 08             	mov    0x8(%ebp),%eax
    c2d1:	8b 40 10             	mov    0x10(%eax),%eax
    c2d4:	85 c0                	test   %eax,%eax
    c2d6:	74 07                	je     c2df <lodepng_compute_color_stats+0x107>
    c2d8:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c2df:	8b 45 08             	mov    0x8(%ebp),%eax
    c2e2:	8b 00                	mov    (%eax),%eax
    c2e4:	85 c0                	test   %eax,%eax
    c2e6:	74 07                	je     c2ef <lodepng_compute_color_stats+0x117>
    c2e8:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c2ef:	8b 45 08             	mov    0x8(%ebp),%eax
    c2f2:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c2f8:	83 f8 10             	cmp    $0x10,%eax
    c2fb:	75 07                	jne    c304 <lodepng_compute_color_stats+0x12c>
    c2fd:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c304:	8b 45 08             	mov    0x8(%ebp),%eax
    c307:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c30d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c310:	72 07                	jb     c319 <lodepng_compute_color_stats+0x141>
    c312:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c319:	8b 45 08             	mov    0x8(%ebp),%eax
    c31c:	8b 40 14             	mov    0x14(%eax),%eax
    c31f:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c322:	72 07                	jb     c32b <lodepng_compute_color_stats+0x153>
    c324:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c32b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c32f:	0f 85 82 00 00 00    	jne    c3b7 <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c335:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c33c:	eb 6c                	jmp    c3aa <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c33e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c341:	c1 e0 02             	shl    $0x2,%eax
    c344:	8d 50 10             	lea    0x10(%eax),%edx
    c347:	8b 45 08             	mov    0x8(%ebp),%eax
    c34a:	01 d0                	add    %edx,%eax
    c34c:	83 c0 08             	add    $0x8,%eax
    c34f:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c352:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c355:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c358:	83 c0 03             	add    $0x3,%eax
    c35b:	0f b6 00             	movzbl (%eax),%eax
    c35e:	0f b6 d8             	movzbl %al,%ebx
    c361:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c364:	83 c0 02             	add    $0x2,%eax
    c367:	0f b6 00             	movzbl (%eax),%eax
    c36a:	0f b6 c8             	movzbl %al,%ecx
    c36d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c370:	83 c0 01             	add    $0x1,%eax
    c373:	0f b6 00             	movzbl (%eax),%eax
    c376:	0f b6 d0             	movzbl %al,%edx
    c379:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c37c:	0f b6 00             	movzbl (%eax),%eax
    c37f:	0f b6 c0             	movzbl %al,%eax
    c382:	83 ec 08             	sub    $0x8,%esp
    c385:	56                   	push   %esi
    c386:	53                   	push   %ebx
    c387:	51                   	push   %ecx
    c388:	52                   	push   %edx
    c389:	50                   	push   %eax
    c38a:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c390:	50                   	push   %eax
    c391:	e8 39 db ff ff       	call   9ecf <color_tree_add>
    c396:	83 c4 20             	add    $0x20,%esp
    c399:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    c39c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c3a0:	0f 85 22 09 00 00    	jne    ccc8 <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    c3a6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c3aa:	8b 45 08             	mov    0x8(%ebp),%eax
    c3ad:	8b 50 14             	mov    0x14(%eax),%edx
    c3b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c3b3:	39 c2                	cmp    %eax,%edx
    c3b5:	77 87                	ja     c33e <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    c3b7:	8b 45 18             	mov    0x18(%ebp),%eax
    c3ba:	8b 40 04             	mov    0x4(%eax),%eax
    c3bd:	83 f8 10             	cmp    $0x10,%eax
    c3c0:	0f 85 1e 01 00 00    	jne    c4e4 <lodepng_compute_color_stats+0x30c>
    c3c6:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c3ca:	0f 85 14 01 00 00    	jne    c4e4 <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c3d0:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    c3d7:	00 00 
    c3d9:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    c3e0:	00 00 
    c3e2:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    c3e9:	00 00 
    c3eb:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    c3f2:	00 00 
    for(i = 0; i != numpixels; ++i) {
    c3f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c3fb:	e9 d8 00 00 00       	jmp    c4d8 <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c400:	83 ec 04             	sub    $0x4,%esp
    c403:	ff 75 18             	pushl  0x18(%ebp)
    c406:	ff 75 f4             	pushl  -0xc(%ebp)
    c409:	ff 75 0c             	pushl  0xc(%ebp)
    c40c:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    c412:	50                   	push   %eax
    c413:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    c419:	50                   	push   %eax
    c41a:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    c420:	50                   	push   %eax
    c421:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    c427:	50                   	push   %eax
    c428:	e8 a8 f2 ff ff       	call   b6d5 <getPixelColorRGBA16>
    c42d:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c430:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c437:	66 c1 e8 08          	shr    $0x8,%ax
    c43b:	89 c2                	mov    %eax,%edx
    c43d:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c444:	31 d0                	xor    %edx,%eax
    c446:	0f b7 c0             	movzwl %ax,%eax
    c449:	0f b6 c0             	movzbl %al,%eax
    c44c:	85 c0                	test   %eax,%eax
    c44e:	75 60                	jne    c4b0 <lodepng_compute_color_stats+0x2d8>
    c450:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c457:	66 c1 e8 08          	shr    $0x8,%ax
    c45b:	89 c2                	mov    %eax,%edx
    c45d:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c464:	31 d0                	xor    %edx,%eax
    c466:	0f b7 c0             	movzwl %ax,%eax
    c469:	0f b6 c0             	movzbl %al,%eax
    c46c:	85 c0                	test   %eax,%eax
    c46e:	75 40                	jne    c4b0 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c470:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c477:	66 c1 e8 08          	shr    $0x8,%ax
    c47b:	89 c2                	mov    %eax,%edx
    c47d:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c484:	31 d0                	xor    %edx,%eax
    c486:	0f b7 c0             	movzwl %ax,%eax
    c489:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c48c:	85 c0                	test   %eax,%eax
    c48e:	75 20                	jne    c4b0 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c490:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c497:	66 c1 e8 08          	shr    $0x8,%ax
    c49b:	89 c2                	mov    %eax,%edx
    c49d:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c4a4:	31 d0                	xor    %edx,%eax
    c4a6:	0f b7 c0             	movzwl %ax,%eax
    c4a9:	0f b6 c0             	movzbl %al,%eax
    c4ac:	85 c0                	test   %eax,%eax
    c4ae:	74 24                	je     c4d4 <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    c4b0:	8b 45 08             	mov    0x8(%ebp),%eax
    c4b3:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    c4ba:	00 00 00 
        sixteen = 1;
    c4bd:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    c4c4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    c4cb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    c4d2:	eb 10                	jmp    c4e4 <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    c4d4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c4d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c4db:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c4de:	0f 85 1c ff ff ff    	jne    c400 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    c4e4:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c4e8:	0f 84 bd 02 00 00    	je     c7ab <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c4ee:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    c4f5:	00 00 
    c4f7:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    c4fe:	00 00 
    c500:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    c507:	00 00 
    c509:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    c510:	00 00 

    for(i = 0; i != numpixels; ++i) {
    c512:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c519:	e9 b1 01 00 00       	jmp    c6cf <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c51e:	83 ec 04             	sub    $0x4,%esp
    c521:	ff 75 18             	pushl  0x18(%ebp)
    c524:	ff 75 f4             	pushl  -0xc(%ebp)
    c527:	ff 75 0c             	pushl  0xc(%ebp)
    c52a:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c530:	50                   	push   %eax
    c531:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c537:	50                   	push   %eax
    c538:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c53e:	50                   	push   %eax
    c53f:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c545:	50                   	push   %eax
    c546:	e8 8a f1 ff ff       	call   b6d5 <getPixelColorRGBA16>
    c54b:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    c54e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c552:	75 36                	jne    c58a <lodepng_compute_color_stats+0x3b2>
    c554:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c55b:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c562:	66 39 c2             	cmp    %ax,%dx
    c565:	75 13                	jne    c57a <lodepng_compute_color_stats+0x3a2>
    c567:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c56e:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c575:	66 39 c2             	cmp    %ax,%dx
    c578:	74 10                	je     c58a <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    c57a:	8b 45 08             	mov    0x8(%ebp),%eax
    c57d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c583:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    c58a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c58e:	0f 85 1f 01 00 00    	jne    c6b3 <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c594:	8b 45 08             	mov    0x8(%ebp),%eax
    c597:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c59b:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c5a2:	66 39 c2             	cmp    %ax,%dx
    c5a5:	75 2d                	jne    c5d4 <lodepng_compute_color_stats+0x3fc>
    c5a7:	8b 45 08             	mov    0x8(%ebp),%eax
    c5aa:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c5ae:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c5b5:	66 39 c2             	cmp    %ax,%dx
    c5b8:	75 1a                	jne    c5d4 <lodepng_compute_color_stats+0x3fc>
    c5ba:	8b 45 08             	mov    0x8(%ebp),%eax
    c5bd:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c5c1:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c5c8:	66 39 c2             	cmp    %ax,%dx
    c5cb:	75 07                	jne    c5d4 <lodepng_compute_color_stats+0x3fc>
    c5cd:	b8 01 00 00 00       	mov    $0x1,%eax
    c5d2:	eb 05                	jmp    c5d9 <lodepng_compute_color_stats+0x401>
    c5d4:	b8 00 00 00 00       	mov    $0x0,%eax
    c5d9:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    c5dc:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c5e3:	66 83 f8 ff          	cmp    $0xffff,%ax
    c5e7:	74 3c                	je     c625 <lodepng_compute_color_stats+0x44d>
    c5e9:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c5f0:	66 85 c0             	test   %ax,%ax
    c5f3:	75 10                	jne    c605 <lodepng_compute_color_stats+0x42d>
    c5f5:	8b 45 08             	mov    0x8(%ebp),%eax
    c5f8:	8b 40 04             	mov    0x4(%eax),%eax
    c5fb:	85 c0                	test   %eax,%eax
    c5fd:	74 26                	je     c625 <lodepng_compute_color_stats+0x44d>
    c5ff:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c603:	75 20                	jne    c625 <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    c605:	8b 45 08             	mov    0x8(%ebp),%eax
    c608:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c60f:	8b 45 08             	mov    0x8(%ebp),%eax
    c612:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c619:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    c620:	e9 8e 00 00 00       	jmp    c6b3 <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c625:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c62c:	66 85 c0             	test   %ax,%ax
    c62f:	75 4a                	jne    c67b <lodepng_compute_color_stats+0x4a3>
    c631:	8b 45 08             	mov    0x8(%ebp),%eax
    c634:	8b 40 10             	mov    0x10(%eax),%eax
    c637:	85 c0                	test   %eax,%eax
    c639:	75 40                	jne    c67b <lodepng_compute_color_stats+0x4a3>
    c63b:	8b 45 08             	mov    0x8(%ebp),%eax
    c63e:	8b 40 04             	mov    0x4(%eax),%eax
    c641:	85 c0                	test   %eax,%eax
    c643:	75 36                	jne    c67b <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    c645:	8b 45 08             	mov    0x8(%ebp),%eax
    c648:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c64f:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c656:	8b 45 08             	mov    0x8(%ebp),%eax
    c659:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c65d:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    c664:	8b 45 08             	mov    0x8(%ebp),%eax
    c667:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c66b:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    c672:	8b 45 08             	mov    0x8(%ebp),%eax
    c675:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c679:	eb 38                	jmp    c6b3 <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    c67b:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c682:	66 83 f8 ff          	cmp    $0xffff,%ax
    c686:	75 2b                	jne    c6b3 <lodepng_compute_color_stats+0x4db>
    c688:	8b 45 08             	mov    0x8(%ebp),%eax
    c68b:	8b 40 04             	mov    0x4(%eax),%eax
    c68e:	85 c0                	test   %eax,%eax
    c690:	74 21                	je     c6b3 <lodepng_compute_color_stats+0x4db>
    c692:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c696:	74 1b                	je     c6b3 <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c698:	8b 45 08             	mov    0x8(%ebp),%eax
    c69b:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c6a2:	8b 45 08             	mov    0x8(%ebp),%eax
    c6a5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c6ac:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c6b3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c6b7:	74 12                	je     c6cb <lodepng_compute_color_stats+0x4f3>
    c6b9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c6bd:	74 0c                	je     c6cb <lodepng_compute_color_stats+0x4f3>
    c6bf:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c6c3:	74 06                	je     c6cb <lodepng_compute_color_stats+0x4f3>
    c6c5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c6c9:	75 12                	jne    c6dd <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    c6cb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c6cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c6d2:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c6d5:	0f 85 43 fe ff ff    	jne    c51e <lodepng_compute_color_stats+0x346>
    c6db:	eb 01                	jmp    c6de <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c6dd:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    c6de:	8b 45 08             	mov    0x8(%ebp),%eax
    c6e1:	8b 40 04             	mov    0x4(%eax),%eax
    c6e4:	85 c0                	test   %eax,%eax
    c6e6:	0f 84 e0 05 00 00    	je     cccc <lodepng_compute_color_stats+0xaf4>
    c6ec:	8b 45 08             	mov    0x8(%ebp),%eax
    c6ef:	8b 40 10             	mov    0x10(%eax),%eax
    c6f2:	85 c0                	test   %eax,%eax
    c6f4:	0f 85 d2 05 00 00    	jne    cccc <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    c6fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c701:	e9 94 00 00 00       	jmp    c79a <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c706:	83 ec 04             	sub    $0x4,%esp
    c709:	ff 75 18             	pushl  0x18(%ebp)
    c70c:	ff 75 f4             	pushl  -0xc(%ebp)
    c70f:	ff 75 0c             	pushl  0xc(%ebp)
    c712:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c718:	50                   	push   %eax
    c719:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c71f:	50                   	push   %eax
    c720:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c726:	50                   	push   %eax
    c727:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c72d:	50                   	push   %eax
    c72e:	e8 a2 ef ff ff       	call   b6d5 <getPixelColorRGBA16>
    c733:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    c736:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c73d:	66 85 c0             	test   %ax,%ax
    c740:	74 54                	je     c796 <lodepng_compute_color_stats+0x5be>
    c742:	8b 45 08             	mov    0x8(%ebp),%eax
    c745:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c749:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c750:	66 39 c2             	cmp    %ax,%dx
    c753:	75 41                	jne    c796 <lodepng_compute_color_stats+0x5be>
    c755:	8b 45 08             	mov    0x8(%ebp),%eax
    c758:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c75c:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c763:	66 39 c2             	cmp    %ax,%dx
    c766:	75 2e                	jne    c796 <lodepng_compute_color_stats+0x5be>
    c768:	8b 45 08             	mov    0x8(%ebp),%eax
    c76b:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c76f:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c776:	66 39 c2             	cmp    %ax,%dx
    c779:	75 1b                	jne    c796 <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c77b:	8b 45 08             	mov    0x8(%ebp),%eax
    c77e:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c785:	8b 45 08             	mov    0x8(%ebp),%eax
    c788:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c78f:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    c796:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c79a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c79d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c7a0:	0f 85 60 ff ff ff    	jne    c706 <lodepng_compute_color_stats+0x52e>
    c7a6:	e9 21 05 00 00       	jmp    cccc <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    c7ab:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    c7b2:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    c7b9:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    c7c0:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    c7c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c7ce:	e9 ab 03 00 00       	jmp    cb7e <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c7d3:	83 ec 04             	sub    $0x4,%esp
    c7d6:	ff 75 18             	pushl  0x18(%ebp)
    c7d9:	ff 75 f4             	pushl  -0xc(%ebp)
    c7dc:	ff 75 0c             	pushl  0xc(%ebp)
    c7df:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    c7e5:	50                   	push   %eax
    c7e6:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    c7ec:	50                   	push   %eax
    c7ed:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    c7f3:	50                   	push   %eax
    c7f4:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    c7fa:	50                   	push   %eax
    c7fb:	e8 1e de ff ff       	call   a61e <getPixelColorRGBA8>
    c800:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    c803:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c807:	75 41                	jne    c84a <lodepng_compute_color_stats+0x672>
    c809:	8b 45 08             	mov    0x8(%ebp),%eax
    c80c:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c812:	83 f8 07             	cmp    $0x7,%eax
    c815:	77 33                	ja     c84a <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    c817:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c81e:	0f b6 c0             	movzbl %al,%eax
    c821:	83 ec 0c             	sub    $0xc,%esp
    c824:	50                   	push   %eax
    c825:	e8 1d f9 ff ff       	call   c147 <getValueRequiredBits>
    c82a:	83 c4 10             	add    $0x10,%esp
    c82d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    c830:	8b 45 08             	mov    0x8(%ebp),%eax
    c833:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c839:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    c83c:	73 0c                	jae    c84a <lodepng_compute_color_stats+0x672>
    c83e:	8b 45 08             	mov    0x8(%ebp),%eax
    c841:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    c844:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    c84a:	8b 45 08             	mov    0x8(%ebp),%eax
    c84d:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c853:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c856:	0f 93 c0             	setae  %al
    c859:	0f b6 c0             	movzbl %al,%eax
    c85c:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    c85f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c863:	75 4f                	jne    c8b4 <lodepng_compute_color_stats+0x6dc>
    c865:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c86c:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c873:	38 c2                	cmp    %al,%dl
    c875:	75 12                	jne    c889 <lodepng_compute_color_stats+0x6b1>
    c877:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c87e:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c885:	38 c2                	cmp    %al,%dl
    c887:	74 2b                	je     c8b4 <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    c889:	8b 45 08             	mov    0x8(%ebp),%eax
    c88c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c892:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    c899:	8b 45 08             	mov    0x8(%ebp),%eax
    c89c:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c8a2:	83 f8 07             	cmp    $0x7,%eax
    c8a5:	77 0d                	ja     c8b4 <lodepng_compute_color_stats+0x6dc>
    c8a7:	8b 45 08             	mov    0x8(%ebp),%eax
    c8aa:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c8b1:	00 00 00 
      }

      if(!alpha_done) {
    c8b4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c8b8:	0f 85 65 01 00 00    	jne    ca23 <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c8be:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c8c5:	0f b6 d0             	movzbl %al,%edx
    c8c8:	8b 45 08             	mov    0x8(%ebp),%eax
    c8cb:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c8cf:	66 39 c2             	cmp    %ax,%dx
    c8d2:	75 33                	jne    c907 <lodepng_compute_color_stats+0x72f>
    c8d4:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c8db:	0f b6 d0             	movzbl %al,%edx
    c8de:	8b 45 08             	mov    0x8(%ebp),%eax
    c8e1:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    c8e5:	66 39 c2             	cmp    %ax,%dx
    c8e8:	75 1d                	jne    c907 <lodepng_compute_color_stats+0x72f>
    c8ea:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c8f1:	0f b6 d0             	movzbl %al,%edx
    c8f4:	8b 45 08             	mov    0x8(%ebp),%eax
    c8f7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    c8fb:	66 39 c2             	cmp    %ax,%dx
    c8fe:	75 07                	jne    c907 <lodepng_compute_color_stats+0x72f>
    c900:	b8 01 00 00 00       	mov    $0x1,%eax
    c905:	eb 05                	jmp    c90c <lodepng_compute_color_stats+0x734>
    c907:	b8 00 00 00 00       	mov    $0x0,%eax
    c90c:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    c90f:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c916:	3c ff                	cmp    $0xff,%al
    c918:	74 5a                	je     c974 <lodepng_compute_color_stats+0x79c>
    c91a:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c921:	84 c0                	test   %al,%al
    c923:	75 10                	jne    c935 <lodepng_compute_color_stats+0x75d>
    c925:	8b 45 08             	mov    0x8(%ebp),%eax
    c928:	8b 40 04             	mov    0x4(%eax),%eax
    c92b:	85 c0                	test   %eax,%eax
    c92d:	74 45                	je     c974 <lodepng_compute_color_stats+0x79c>
    c92f:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c933:	75 3f                	jne    c974 <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    c935:	8b 45 08             	mov    0x8(%ebp),%eax
    c938:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c93f:	8b 45 08             	mov    0x8(%ebp),%eax
    c942:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c949:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c950:	8b 45 08             	mov    0x8(%ebp),%eax
    c953:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c959:	83 f8 07             	cmp    $0x7,%eax
    c95c:	0f 87 c1 00 00 00    	ja     ca23 <lodepng_compute_color_stats+0x84b>
    c962:	8b 45 08             	mov    0x8(%ebp),%eax
    c965:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c96c:	00 00 00 
    c96f:	e9 af 00 00 00       	jmp    ca23 <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c974:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c97b:	84 c0                	test   %al,%al
    c97d:	75 53                	jne    c9d2 <lodepng_compute_color_stats+0x7fa>
    c97f:	8b 45 08             	mov    0x8(%ebp),%eax
    c982:	8b 40 10             	mov    0x10(%eax),%eax
    c985:	85 c0                	test   %eax,%eax
    c987:	75 49                	jne    c9d2 <lodepng_compute_color_stats+0x7fa>
    c989:	8b 45 08             	mov    0x8(%ebp),%eax
    c98c:	8b 40 04             	mov    0x4(%eax),%eax
    c98f:	85 c0                	test   %eax,%eax
    c991:	75 3f                	jne    c9d2 <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    c993:	8b 45 08             	mov    0x8(%ebp),%eax
    c996:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c99d:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c9a4:	0f b6 d0             	movzbl %al,%edx
    c9a7:	8b 45 08             	mov    0x8(%ebp),%eax
    c9aa:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c9ae:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c9b5:	0f b6 d0             	movzbl %al,%edx
    c9b8:	8b 45 08             	mov    0x8(%ebp),%eax
    c9bb:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c9bf:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c9c6:	0f b6 d0             	movzbl %al,%edx
    c9c9:	8b 45 08             	mov    0x8(%ebp),%eax
    c9cc:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c9d0:	eb 51                	jmp    ca23 <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    c9d2:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c9d9:	3c ff                	cmp    $0xff,%al
    c9db:	75 46                	jne    ca23 <lodepng_compute_color_stats+0x84b>
    c9dd:	8b 45 08             	mov    0x8(%ebp),%eax
    c9e0:	8b 40 04             	mov    0x4(%eax),%eax
    c9e3:	85 c0                	test   %eax,%eax
    c9e5:	74 3c                	je     ca23 <lodepng_compute_color_stats+0x84b>
    c9e7:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c9eb:	74 36                	je     ca23 <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c9ed:	8b 45 08             	mov    0x8(%ebp),%eax
    c9f0:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c9f7:	8b 45 08             	mov    0x8(%ebp),%eax
    c9fa:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    ca01:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    ca08:	8b 45 08             	mov    0x8(%ebp),%eax
    ca0b:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ca11:	83 f8 07             	cmp    $0x7,%eax
    ca14:	77 0d                	ja     ca23 <lodepng_compute_color_stats+0x84b>
    ca16:	8b 45 08             	mov    0x8(%ebp),%eax
    ca19:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    ca20:	00 00 00 
        }
      }

      if(!numcolors_done) {
    ca23:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ca27:	0f 85 35 01 00 00    	jne    cb62 <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    ca2d:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ca34:	0f b6 d8             	movzbl %al,%ebx
    ca37:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ca3e:	0f b6 c8             	movzbl %al,%ecx
    ca41:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ca48:	0f b6 d0             	movzbl %al,%edx
    ca4b:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca52:	0f b6 c0             	movzbl %al,%eax
    ca55:	83 ec 0c             	sub    $0xc,%esp
    ca58:	53                   	push   %ebx
    ca59:	51                   	push   %ecx
    ca5a:	52                   	push   %edx
    ca5b:	50                   	push   %eax
    ca5c:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    ca62:	50                   	push   %eax
    ca63:	e8 1c d4 ff ff       	call   9e84 <color_tree_has>
    ca68:	83 c4 20             	add    $0x20,%esp
    ca6b:	85 c0                	test   %eax,%eax
    ca6d:	0f 85 ef 00 00 00    	jne    cb62 <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    ca73:	8b 45 08             	mov    0x8(%ebp),%eax
    ca76:	8b 70 14             	mov    0x14(%eax),%esi
    ca79:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ca80:	0f b6 d8             	movzbl %al,%ebx
    ca83:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ca8a:	0f b6 c8             	movzbl %al,%ecx
    ca8d:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ca94:	0f b6 d0             	movzbl %al,%edx
    ca97:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca9e:	0f b6 c0             	movzbl %al,%eax
    caa1:	83 ec 08             	sub    $0x8,%esp
    caa4:	56                   	push   %esi
    caa5:	53                   	push   %ebx
    caa6:	51                   	push   %ecx
    caa7:	52                   	push   %edx
    caa8:	50                   	push   %eax
    caa9:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    caaf:	50                   	push   %eax
    cab0:	e8 1a d4 ff ff       	call   9ecf <color_tree_add>
    cab5:	83 c4 20             	add    $0x20,%esp
    cab8:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    cabb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    cabf:	0f 85 06 02 00 00    	jne    cccb <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    cac5:	8b 45 08             	mov    0x8(%ebp),%eax
    cac8:	8b 40 14             	mov    0x14(%eax),%eax
    cacb:	3d ff 00 00 00       	cmp    $0xff,%eax
    cad0:	77 6f                	ja     cb41 <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    cad2:	8b 45 08             	mov    0x8(%ebp),%eax
    cad5:	83 c0 18             	add    $0x18,%eax
    cad8:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    cadb:	8b 45 08             	mov    0x8(%ebp),%eax
    cade:	8b 40 14             	mov    0x14(%eax),%eax
    cae1:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    cae4:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cae7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    caee:	8b 45 bc             	mov    -0x44(%ebp),%eax
    caf1:	01 c2                	add    %eax,%edx
    caf3:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cafa:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    cafc:	8b 45 b8             	mov    -0x48(%ebp),%eax
    caff:	c1 e0 02             	shl    $0x2,%eax
    cb02:	8d 50 01             	lea    0x1(%eax),%edx
    cb05:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cb08:	01 c2                	add    %eax,%edx
    cb0a:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cb11:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    cb13:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cb16:	c1 e0 02             	shl    $0x2,%eax
    cb19:	8d 50 02             	lea    0x2(%eax),%edx
    cb1c:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cb1f:	01 c2                	add    %eax,%edx
    cb21:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cb28:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    cb2a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cb2d:	c1 e0 02             	shl    $0x2,%eax
    cb30:	8d 50 03             	lea    0x3(%eax),%edx
    cb33:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cb36:	01 c2                	add    %eax,%edx
    cb38:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cb3f:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    cb41:	8b 45 08             	mov    0x8(%ebp),%eax
    cb44:	8b 40 14             	mov    0x14(%eax),%eax
    cb47:	8d 50 01             	lea    0x1(%eax),%edx
    cb4a:	8b 45 08             	mov    0x8(%ebp),%eax
    cb4d:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    cb50:	8b 45 08             	mov    0x8(%ebp),%eax
    cb53:	8b 40 14             	mov    0x14(%eax),%eax
    cb56:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cb59:	0f 93 c0             	setae  %al
    cb5c:	0f b6 c0             	movzbl %al,%eax
    cb5f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cb62:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cb66:	74 12                	je     cb7a <lodepng_compute_color_stats+0x9a2>
    cb68:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cb6c:	74 0c                	je     cb7a <lodepng_compute_color_stats+0x9a2>
    cb6e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cb72:	74 06                	je     cb7a <lodepng_compute_color_stats+0x9a2>
    cb74:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cb78:	75 12                	jne    cb8c <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    cb7a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cb7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cb81:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cb84:	0f 85 49 fc ff ff    	jne    c7d3 <lodepng_compute_color_stats+0x5fb>
    cb8a:	eb 01                	jmp    cb8d <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cb8c:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    cb8d:	8b 45 08             	mov    0x8(%ebp),%eax
    cb90:	8b 40 04             	mov    0x4(%eax),%eax
    cb93:	85 c0                	test   %eax,%eax
    cb95:	0f 84 dd 00 00 00    	je     cc78 <lodepng_compute_color_stats+0xaa0>
    cb9b:	8b 45 08             	mov    0x8(%ebp),%eax
    cb9e:	8b 40 10             	mov    0x10(%eax),%eax
    cba1:	85 c0                	test   %eax,%eax
    cba3:	0f 85 cf 00 00 00    	jne    cc78 <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    cba9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cbb0:	e9 b7 00 00 00       	jmp    cc6c <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    cbb5:	83 ec 04             	sub    $0x4,%esp
    cbb8:	ff 75 18             	pushl  0x18(%ebp)
    cbbb:	ff 75 f4             	pushl  -0xc(%ebp)
    cbbe:	ff 75 0c             	pushl  0xc(%ebp)
    cbc1:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    cbc7:	50                   	push   %eax
    cbc8:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    cbce:	50                   	push   %eax
    cbcf:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    cbd5:	50                   	push   %eax
    cbd6:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    cbdc:	50                   	push   %eax
    cbdd:	e8 3c da ff ff       	call   a61e <getPixelColorRGBA8>
    cbe2:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    cbe5:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cbec:	84 c0                	test   %al,%al
    cbee:	74 78                	je     cc68 <lodepng_compute_color_stats+0xa90>
    cbf0:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cbf7:	0f b6 d0             	movzbl %al,%edx
    cbfa:	8b 45 08             	mov    0x8(%ebp),%eax
    cbfd:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cc01:	66 39 c2             	cmp    %ax,%dx
    cc04:	75 62                	jne    cc68 <lodepng_compute_color_stats+0xa90>
    cc06:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cc0d:	0f b6 d0             	movzbl %al,%edx
    cc10:	8b 45 08             	mov    0x8(%ebp),%eax
    cc13:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cc17:	66 39 c2             	cmp    %ax,%dx
    cc1a:	75 4c                	jne    cc68 <lodepng_compute_color_stats+0xa90>
    cc1c:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cc23:	0f b6 d0             	movzbl %al,%edx
    cc26:	8b 45 08             	mov    0x8(%ebp),%eax
    cc29:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cc2d:	66 39 c2             	cmp    %ax,%dx
    cc30:	75 36                	jne    cc68 <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cc32:	8b 45 08             	mov    0x8(%ebp),%eax
    cc35:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cc3c:	8b 45 08             	mov    0x8(%ebp),%eax
    cc3f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cc46:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cc4d:	8b 45 08             	mov    0x8(%ebp),%eax
    cc50:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cc56:	83 f8 07             	cmp    $0x7,%eax
    cc59:	77 0d                	ja     cc68 <lodepng_compute_color_stats+0xa90>
    cc5b:	8b 45 08             	mov    0x8(%ebp),%eax
    cc5e:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cc65:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    cc68:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cc6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cc6f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cc72:	0f 85 3d ff ff ff    	jne    cbb5 <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    cc78:	8b 45 08             	mov    0x8(%ebp),%eax
    cc7b:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    cc7f:	8b 45 08             	mov    0x8(%ebp),%eax
    cc82:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cc86:	c1 e0 08             	shl    $0x8,%eax
    cc89:	01 c2                	add    %eax,%edx
    cc8b:	8b 45 08             	mov    0x8(%ebp),%eax
    cc8e:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    cc92:	8b 45 08             	mov    0x8(%ebp),%eax
    cc95:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cc99:	8b 45 08             	mov    0x8(%ebp),%eax
    cc9c:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cca0:	c1 e0 08             	shl    $0x8,%eax
    cca3:	01 c2                	add    %eax,%edx
    cca5:	8b 45 08             	mov    0x8(%ebp),%eax
    cca8:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    ccac:	8b 45 08             	mov    0x8(%ebp),%eax
    ccaf:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    ccb3:	8b 45 08             	mov    0x8(%ebp),%eax
    ccb6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    ccba:	c1 e0 08             	shl    $0x8,%eax
    ccbd:	01 c2                	add    %eax,%edx
    ccbf:	8b 45 08             	mov    0x8(%ebp),%eax
    ccc2:	66 89 50 0c          	mov    %dx,0xc(%eax)
    ccc6:	eb 04                	jmp    cccc <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    ccc8:	90                   	nop
    ccc9:	eb 01                	jmp    cccc <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    cccb:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    cccc:	83 ec 0c             	sub    $0xc,%esp
    cccf:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    ccd5:	50                   	push   %eax
    ccd6:	e8 91 d0 ff ff       	call   9d6c <color_tree_cleanup>
    ccdb:	83 c4 10             	add    $0x10,%esp
  return error;
    ccde:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    cce1:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cce4:	5b                   	pop    %ebx
    cce5:	5e                   	pop    %esi
    cce6:	5d                   	pop    %ebp
    cce7:	c3                   	ret    

0000cce8 <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    cce8:	55                   	push   %ebp
    cce9:	89 e5                	mov    %esp,%ebp
    cceb:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    ccee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    ccf5:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ccf8:	50                   	push   %eax
    ccf9:	e8 d1 bd ff ff       	call   8acf <lodepng_color_mode_init>
    ccfe:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    cd01:	8b 45 0c             	mov    0xc(%ebp),%eax
    cd04:	c1 e8 08             	shr    $0x8,%eax
    cd07:	88 45 ec             	mov    %al,-0x14(%ebp)
    cd0a:	8b 45 0c             	mov    0xc(%ebp),%eax
    cd0d:	88 45 ed             	mov    %al,-0x13(%ebp)
    cd10:	8b 45 10             	mov    0x10(%ebp),%eax
    cd13:	c1 e8 08             	shr    $0x8,%eax
    cd16:	88 45 ee             	mov    %al,-0x12(%ebp)
    cd19:	8b 45 10             	mov    0x10(%ebp),%eax
    cd1c:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    cd1f:	8b 45 14             	mov    0x14(%ebp),%eax
    cd22:	c1 e8 08             	shr    $0x8,%eax
    cd25:	88 45 f0             	mov    %al,-0x10(%ebp)
    cd28:	8b 45 14             	mov    0x14(%ebp),%eax
    cd2b:	88 45 f1             	mov    %al,-0xf(%ebp)
    cd2e:	8b 45 18             	mov    0x18(%ebp),%eax
    cd31:	c1 e8 08             	shr    $0x8,%eax
    cd34:	88 45 f2             	mov    %al,-0xe(%ebp)
    cd37:	8b 45 18             	mov    0x18(%ebp),%eax
    cd3a:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    cd3d:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    cd44:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    cd4b:	83 ec 0c             	sub    $0xc,%esp
    cd4e:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cd51:	50                   	push   %eax
    cd52:	6a 01                	push   $0x1
    cd54:	6a 01                	push   $0x1
    cd56:	8d 45 ec             	lea    -0x14(%ebp),%eax
    cd59:	50                   	push   %eax
    cd5a:	ff 75 08             	pushl  0x8(%ebp)
    cd5d:	e8 76 f4 ff ff       	call   c1d8 <lodepng_compute_color_stats>
    cd62:	83 c4 20             	add    $0x20,%esp
    cd65:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    cd68:	83 ec 0c             	sub    $0xc,%esp
    cd6b:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cd6e:	50                   	push   %eax
    cd6f:	e8 4e be ff ff       	call   8bc2 <lodepng_color_mode_cleanup>
    cd74:	83 c4 10             	add    $0x10,%esp
  return error;
    cd77:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    cd7a:	c9                   	leave  
    cd7b:	c3                   	ret    

0000cd7c <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    cd7c:	55                   	push   %ebp
    cd7d:	89 e5                	mov    %esp,%ebp
    cd7f:	56                   	push   %esi
    cd80:	53                   	push   %ebx
    cd81:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    cd84:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    cd8b:	8b 45 10             	mov    0x10(%ebp),%eax
    cd8e:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    cd94:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    cd97:	8b 45 10             	mov    0x10(%ebp),%eax
    cd9a:	8b 40 10             	mov    0x10(%eax),%eax
    cd9d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    cda0:	8b 45 10             	mov    0x10(%ebp),%eax
    cda3:	8b 40 04             	mov    0x4(%eax),%eax
    cda6:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    cda9:	8b 45 10             	mov    0x10(%ebp),%eax
    cdac:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cdb2:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    cdb5:	8b 45 08             	mov    0x8(%ebp),%eax
    cdb8:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    cdbf:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cdc3:	74 21                	je     cde6 <auto_choose_color+0x6a>
    cdc5:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    cdc9:	7f 1b                	jg     cde6 <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    cdcb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    cdd2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cdd9:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    cddd:	77 07                	ja     cde6 <auto_choose_color+0x6a>
    cddf:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    cde6:	8b 45 10             	mov    0x10(%ebp),%eax
    cde9:	8b 00                	mov    (%eax),%eax
    cdeb:	85 c0                	test   %eax,%eax
    cded:	0f 94 c0             	sete   %al
    cdf0:	0f b6 c0             	movzbl %al,%eax
    cdf3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    cdf6:	8b 45 10             	mov    0x10(%ebp),%eax
    cdf9:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    cdff:	85 c0                	test   %eax,%eax
    ce01:	75 07                	jne    ce0a <auto_choose_color+0x8e>
    ce03:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    ce0a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ce0e:	75 0d                	jne    ce1d <auto_choose_color+0xa1>
    ce10:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    ce14:	77 07                	ja     ce1d <auto_choose_color+0xa1>
    ce16:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    ce1d:	8b 45 10             	mov    0x10(%ebp),%eax
    ce20:	8b 40 14             	mov    0x14(%eax),%eax
    ce23:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    ce26:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    ce2a:	7e 21                	jle    ce4d <auto_choose_color+0xd1>
    ce2c:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    ce30:	7e 14                	jle    ce46 <auto_choose_color+0xca>
    ce32:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    ce36:	7f 07                	jg     ce3f <auto_choose_color+0xc3>
    ce38:	b8 04 00 00 00       	mov    $0x4,%eax
    ce3d:	eb 13                	jmp    ce52 <auto_choose_color+0xd6>
    ce3f:	b8 08 00 00 00       	mov    $0x8,%eax
    ce44:	eb 0c                	jmp    ce52 <auto_choose_color+0xd6>
    ce46:	b8 02 00 00 00       	mov    $0x2,%eax
    ce4b:	eb 05                	jmp    ce52 <auto_choose_color+0xd6>
    ce4d:	b8 01 00 00 00       	mov    $0x1,%eax
    ce52:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    ce55:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    ce5c:	7f 13                	jg     ce71 <auto_choose_color+0xf5>
    ce5e:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    ce62:	77 0d                	ja     ce71 <auto_choose_color+0xf5>
    ce64:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    ce68:	74 07                	je     ce71 <auto_choose_color+0xf5>
    ce6a:	b8 01 00 00 00       	mov    $0x1,%eax
    ce6f:	eb 05                	jmp    ce76 <auto_choose_color+0xfa>
    ce71:	b8 00 00 00 00       	mov    $0x0,%eax
    ce76:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    ce79:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ce7c:	01 c0                	add    %eax,%eax
    ce7e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ce81:	7e 07                	jle    ce8a <auto_choose_color+0x10e>
    ce83:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    ce8a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ce8e:	74 15                	je     cea5 <auto_choose_color+0x129>
    ce90:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ce94:	75 0f                	jne    cea5 <auto_choose_color+0x129>
    ce96:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ce99:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    ce9c:	77 07                	ja     cea5 <auto_choose_color+0x129>
    ce9e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    cea5:	8b 45 10             	mov    0x10(%ebp),%eax
    cea8:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    ceae:	85 c0                	test   %eax,%eax
    ceb0:	75 07                	jne    ceb9 <auto_choose_color+0x13d>
    ceb2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    ceb9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cebd:	0f 84 0a 01 00 00    	je     cfcd <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    cec3:	8b 45 10             	mov    0x10(%ebp),%eax
    cec6:	83 c0 18             	add    $0x18,%eax
    cec9:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    cecc:	83 ec 0c             	sub    $0xc,%esp
    cecf:	ff 75 08             	pushl  0x8(%ebp)
    ced2:	e8 ef be ff ff       	call   8dc6 <lodepng_palette_clear>
    ced7:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    ceda:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    cee1:	eb 6e                	jmp    cf51 <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    cee3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cee6:	c1 e0 02             	shl    $0x2,%eax
    cee9:	8d 50 03             	lea    0x3(%eax),%edx
    ceec:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ceef:	01 d0                	add    %edx,%eax
    cef1:	0f b6 00             	movzbl (%eax),%eax
    cef4:	0f b6 d8             	movzbl %al,%ebx
    cef7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cefa:	c1 e0 02             	shl    $0x2,%eax
    cefd:	8d 50 02             	lea    0x2(%eax),%edx
    cf00:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cf03:	01 d0                	add    %edx,%eax
    cf05:	0f b6 00             	movzbl (%eax),%eax
    cf08:	0f b6 c8             	movzbl %al,%ecx
    cf0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cf0e:	c1 e0 02             	shl    $0x2,%eax
    cf11:	8d 50 01             	lea    0x1(%eax),%edx
    cf14:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cf17:	01 d0                	add    %edx,%eax
    cf19:	0f b6 00             	movzbl (%eax),%eax
    cf1c:	0f b6 d0             	movzbl %al,%edx
    cf1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cf22:	c1 e0 02             	shl    $0x2,%eax
    cf25:	89 c6                	mov    %eax,%esi
    cf27:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cf2a:	01 f0                	add    %esi,%eax
    cf2c:	0f b6 00             	movzbl (%eax),%eax
    cf2f:	0f b6 c0             	movzbl %al,%eax
    cf32:	83 ec 0c             	sub    $0xc,%esp
    cf35:	53                   	push   %ebx
    cf36:	51                   	push   %ecx
    cf37:	52                   	push   %edx
    cf38:	50                   	push   %eax
    cf39:	ff 75 08             	pushl  0x8(%ebp)
    cf3c:	e8 be be ff ff       	call   8dff <lodepng_palette_add>
    cf41:	83 c4 20             	add    $0x20,%esp
    cf44:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    cf47:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    cf4b:	75 13                	jne    cf60 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    cf4d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    cf51:	8b 45 10             	mov    0x10(%ebp),%eax
    cf54:	8b 50 14             	mov    0x14(%eax),%edx
    cf57:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cf5a:	39 c2                	cmp    %eax,%edx
    cf5c:	75 85                	jne    cee3 <auto_choose_color+0x167>
    cf5e:	eb 01                	jmp    cf61 <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    cf60:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    cf61:	8b 45 08             	mov    0x8(%ebp),%eax
    cf64:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    cf6a:	8b 45 08             	mov    0x8(%ebp),%eax
    cf6d:	8b 55 d0             	mov    -0x30(%ebp),%edx
    cf70:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    cf73:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf76:	8b 00                	mov    (%eax),%eax
    cf78:	83 f8 03             	cmp    $0x3,%eax
    cf7b:	0f 85 ec 00 00 00    	jne    d06d <auto_choose_color+0x2f1>
    cf81:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf84:	8b 50 0c             	mov    0xc(%eax),%edx
    cf87:	8b 45 08             	mov    0x8(%ebp),%eax
    cf8a:	8b 40 0c             	mov    0xc(%eax),%eax
    cf8d:	39 c2                	cmp    %eax,%edx
    cf8f:	0f 8c d8 00 00 00    	jl     d06d <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    cf95:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf98:	8b 50 04             	mov    0x4(%eax),%edx
    cf9b:	8b 45 08             	mov    0x8(%ebp),%eax
    cf9e:	8b 40 04             	mov    0x4(%eax),%eax
    cfa1:	39 c2                	cmp    %eax,%edx
    cfa3:	0f 85 c4 00 00 00    	jne    d06d <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    cfa9:	83 ec 0c             	sub    $0xc,%esp
    cfac:	ff 75 08             	pushl  0x8(%ebp)
    cfaf:	e8 0e bc ff ff       	call   8bc2 <lodepng_color_mode_cleanup>
    cfb4:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    cfb7:	83 ec 08             	sub    $0x8,%esp
    cfba:	ff 75 0c             	pushl  0xc(%ebp)
    cfbd:	ff 75 08             	pushl  0x8(%ebp)
    cfc0:	e8 14 bc ff ff       	call   8bd9 <lodepng_color_mode_copy>
    cfc5:	83 c4 10             	add    $0x10,%esp
    cfc8:	e9 a0 00 00 00       	jmp    d06d <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    cfcd:	8b 45 08             	mov    0x8(%ebp),%eax
    cfd0:	8b 55 dc             	mov    -0x24(%ebp),%edx
    cfd3:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    cfd6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cfda:	74 14                	je     cff0 <auto_choose_color+0x274>
    cfdc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cfe0:	74 07                	je     cfe9 <auto_choose_color+0x26d>
    cfe2:	b8 04 00 00 00       	mov    $0x4,%eax
    cfe7:	eb 19                	jmp    d002 <auto_choose_color+0x286>
    cfe9:	b8 06 00 00 00       	mov    $0x6,%eax
    cfee:	eb 12                	jmp    d002 <auto_choose_color+0x286>
    cff0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cff4:	74 07                	je     cffd <auto_choose_color+0x281>
    cff6:	b8 00 00 00 00       	mov    $0x0,%eax
    cffb:	eb 05                	jmp    d002 <auto_choose_color+0x286>
    cffd:	b8 02 00 00 00       	mov    $0x2,%eax
    d002:	8b 55 08             	mov    0x8(%ebp),%edx
    d005:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    d007:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d00b:	74 60                	je     d06d <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    d00d:	8b 45 08             	mov    0x8(%ebp),%eax
    d010:	8b 40 04             	mov    0x4(%eax),%eax
    d013:	ba 01 00 00 00       	mov    $0x1,%edx
    d018:	89 c1                	mov    %eax,%ecx
    d01a:	d3 e2                	shl    %cl,%edx
    d01c:	89 d0                	mov    %edx,%eax
    d01e:	83 e8 01             	sub    $0x1,%eax
    d021:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    d024:	8b 45 10             	mov    0x10(%ebp),%eax
    d027:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d02b:	0f b7 c0             	movzwl %ax,%eax
    d02e:	23 45 c8             	and    -0x38(%ebp),%eax
    d031:	89 c2                	mov    %eax,%edx
    d033:	8b 45 08             	mov    0x8(%ebp),%eax
    d036:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    d039:	8b 45 10             	mov    0x10(%ebp),%eax
    d03c:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d040:	0f b7 c0             	movzwl %ax,%eax
    d043:	23 45 c8             	and    -0x38(%ebp),%eax
    d046:	89 c2                	mov    %eax,%edx
    d048:	8b 45 08             	mov    0x8(%ebp),%eax
    d04b:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    d04e:	8b 45 10             	mov    0x10(%ebp),%eax
    d051:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d055:	0f b7 c0             	movzwl %ax,%eax
    d058:	23 45 c8             	and    -0x38(%ebp),%eax
    d05b:	89 c2                	mov    %eax,%edx
    d05d:	8b 45 08             	mov    0x8(%ebp),%eax
    d060:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    d063:	8b 45 08             	mov    0x8(%ebp),%eax
    d066:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    d06d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d070:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d073:	5b                   	pop    %ebx
    d074:	5e                   	pop    %esi
    d075:	5d                   	pop    %ebp
    d076:	c3                   	ret    

0000d077 <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    d077:	55                   	push   %ebp
    d078:	89 e5                	mov    %esp,%ebp
    d07a:	83 ec 1c             	sub    $0x1c,%esp
    d07d:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d080:	8b 55 0c             	mov    0xc(%ebp),%edx
    d083:	8b 45 10             	mov    0x10(%ebp),%eax
    d086:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    d08a:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    d08e:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    d092:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    d096:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d09a:	29 c2                	sub    %eax,%edx
    d09c:	89 d0                	mov    %edx,%eax
    d09e:	99                   	cltd   
    d09f:	31 d0                	xor    %edx,%eax
    d0a1:	29 d0                	sub    %edx,%eax
    d0a3:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    d0a7:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d0ab:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d0af:	29 c2                	sub    %eax,%edx
    d0b1:	89 d0                	mov    %edx,%eax
    d0b3:	99                   	cltd   
    d0b4:	31 d0                	xor    %edx,%eax
    d0b6:	29 d0                	sub    %edx,%eax
    d0b8:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    d0bc:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d0c0:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    d0c4:	01 c2                	add    %eax,%edx
    d0c6:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d0ca:	29 c2                	sub    %eax,%edx
    d0cc:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d0d0:	29 c2                	sub    %eax,%edx
    d0d2:	89 d0                	mov    %edx,%eax
    d0d4:	99                   	cltd   
    d0d5:	31 d0                	xor    %edx,%eax
    d0d7:	29 d0                	sub    %edx,%eax
    d0d9:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    d0dd:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d0e1:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d0e5:	7d 10                	jge    d0f7 <paethPredictor+0x80>
    d0e7:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d0eb:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d0ef:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d0f3:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d0f7:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d0fb:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d0ff:	7d 06                	jge    d107 <paethPredictor+0x90>
    d101:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d105:	eb 04                	jmp    d10b <paethPredictor+0x94>
    d107:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d10b:	c9                   	leave  
    d10c:	c3                   	ret    

0000d10d <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d10d:	55                   	push   %ebp
    d10e:	89 e5                	mov    %esp,%ebp
    d110:	56                   	push   %esi
    d111:	53                   	push   %ebx
    d112:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d115:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d11c:	e9 e2 00 00 00       	jmp    d203 <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d121:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d124:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d12b:	8b 45 08             	mov    0x8(%ebp),%eax
    d12e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d131:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d134:	8b 14 85 b4 a0 01 00 	mov    0x1a0b4(,%eax,4),%edx
    d13b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d13e:	01 c2                	add    %eax,%edx
    d140:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d143:	8b 04 85 7c a0 01 00 	mov    0x1a07c(,%eax,4),%eax
    d14a:	29 c2                	sub    %eax,%edx
    d14c:	89 d0                	mov    %edx,%eax
    d14e:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d151:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d154:	8b 34 85 b4 a0 01 00 	mov    0x1a0b4(,%eax,4),%esi
    d15b:	89 d8                	mov    %ebx,%eax
    d15d:	ba 00 00 00 00       	mov    $0x0,%edx
    d162:	f7 f6                	div    %esi
    d164:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d166:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d169:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d170:	8b 45 0c             	mov    0xc(%ebp),%eax
    d173:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d176:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d179:	8b 14 85 d0 a0 01 00 	mov    0x1a0d0(,%eax,4),%edx
    d180:	8b 45 20             	mov    0x20(%ebp),%eax
    d183:	01 c2                	add    %eax,%edx
    d185:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d188:	8b 04 85 98 a0 01 00 	mov    0x1a098(,%eax,4),%eax
    d18f:	29 c2                	sub    %eax,%edx
    d191:	89 d0                	mov    %edx,%eax
    d193:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d196:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d199:	8b 34 85 d0 a0 01 00 	mov    0x1a0d0(,%eax,4),%esi
    d1a0:	89 d8                	mov    %ebx,%eax
    d1a2:	ba 00 00 00 00       	mov    $0x0,%edx
    d1a7:	f7 f6                	div    %esi
    d1a9:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d1ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1ae:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1b5:	8b 45 08             	mov    0x8(%ebp),%eax
    d1b8:	01 d0                	add    %edx,%eax
    d1ba:	8b 00                	mov    (%eax),%eax
    d1bc:	85 c0                	test   %eax,%eax
    d1be:	75 15                	jne    d1d5 <Adam7_getpassvalues+0xc8>
    d1c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1c3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1cd:	01 d0                	add    %edx,%eax
    d1cf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d1d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1d8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1df:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1e2:	01 d0                	add    %edx,%eax
    d1e4:	8b 00                	mov    (%eax),%eax
    d1e6:	85 c0                	test   %eax,%eax
    d1e8:	75 15                	jne    d1ff <Adam7_getpassvalues+0xf2>
    d1ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1ed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1f4:	8b 45 08             	mov    0x8(%ebp),%eax
    d1f7:	01 d0                	add    %edx,%eax
    d1f9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d1ff:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d203:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d207:	0f 85 14 ff ff ff    	jne    d121 <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d20d:	8b 45 18             	mov    0x18(%ebp),%eax
    d210:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d216:	8b 45 18             	mov    0x18(%ebp),%eax
    d219:	8b 10                	mov    (%eax),%edx
    d21b:	8b 45 14             	mov    0x14(%ebp),%eax
    d21e:	89 10                	mov    %edx,(%eax)
    d220:	8b 45 14             	mov    0x14(%ebp),%eax
    d223:	8b 10                	mov    (%eax),%edx
    d225:	8b 45 10             	mov    0x10(%ebp),%eax
    d228:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d22a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d231:	e9 40 01 00 00       	jmp    d376 <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d236:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d239:	83 c0 01             	add    $0x1,%eax
    d23c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d243:	8b 45 10             	mov    0x10(%ebp),%eax
    d246:	01 c2                	add    %eax,%edx
    d248:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d24b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d252:	8b 45 10             	mov    0x10(%ebp),%eax
    d255:	01 c8                	add    %ecx,%eax
    d257:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d259:	89 c6                	mov    %eax,%esi
    d25b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d25e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d265:	8b 45 08             	mov    0x8(%ebp),%eax
    d268:	01 c8                	add    %ecx,%eax
    d26a:	8b 00                	mov    (%eax),%eax
    d26c:	85 c0                	test   %eax,%eax
    d26e:	74 49                	je     d2b9 <Adam7_getpassvalues+0x1ac>
    d270:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d273:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d27a:	8b 45 0c             	mov    0xc(%ebp),%eax
    d27d:	01 c8                	add    %ecx,%eax
    d27f:	8b 00                	mov    (%eax),%eax
    d281:	85 c0                	test   %eax,%eax
    d283:	74 34                	je     d2b9 <Adam7_getpassvalues+0x1ac>
    d285:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d288:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d28f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d292:	01 c8                	add    %ecx,%eax
    d294:	8b 08                	mov    (%eax),%ecx
    d296:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d299:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d2a0:	8b 45 08             	mov    0x8(%ebp),%eax
    d2a3:	01 d8                	add    %ebx,%eax
    d2a5:	8b 00                	mov    (%eax),%eax
    d2a7:	0f af 45 24          	imul   0x24(%ebp),%eax
    d2ab:	83 c0 07             	add    $0x7,%eax
    d2ae:	c1 e8 03             	shr    $0x3,%eax
    d2b1:	83 c0 01             	add    $0x1,%eax
    d2b4:	0f af c1             	imul   %ecx,%eax
    d2b7:	eb 05                	jmp    d2be <Adam7_getpassvalues+0x1b1>
    d2b9:	b8 00 00 00 00       	mov    $0x0,%eax
    d2be:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d2c0:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d2c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2c5:	83 c0 01             	add    $0x1,%eax
    d2c8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d2cf:	8b 45 14             	mov    0x14(%ebp),%eax
    d2d2:	01 c2                	add    %eax,%edx
    d2d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2d7:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d2de:	8b 45 14             	mov    0x14(%ebp),%eax
    d2e1:	01 c8                	add    %ecx,%eax
    d2e3:	8b 00                	mov    (%eax),%eax
    d2e5:	89 c6                	mov    %eax,%esi
    d2e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2ea:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d2f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    d2f4:	01 c8                	add    %ecx,%eax
    d2f6:	8b 08                	mov    (%eax),%ecx
    d2f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2fb:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d302:	8b 45 08             	mov    0x8(%ebp),%eax
    d305:	01 d8                	add    %ebx,%eax
    d307:	8b 00                	mov    (%eax),%eax
    d309:	0f af 45 24          	imul   0x24(%ebp),%eax
    d30d:	83 c0 07             	add    $0x7,%eax
    d310:	c1 e8 03             	shr    $0x3,%eax
    d313:	0f af c1             	imul   %ecx,%eax
    d316:	01 f0                	add    %esi,%eax
    d318:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d31a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d31d:	83 c0 01             	add    $0x1,%eax
    d320:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d327:	8b 45 18             	mov    0x18(%ebp),%eax
    d32a:	01 c2                	add    %eax,%edx
    d32c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d32f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d336:	8b 45 18             	mov    0x18(%ebp),%eax
    d339:	01 c8                	add    %ecx,%eax
    d33b:	8b 00                	mov    (%eax),%eax
    d33d:	89 c6                	mov    %eax,%esi
    d33f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d342:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d349:	8b 45 0c             	mov    0xc(%ebp),%eax
    d34c:	01 c8                	add    %ecx,%eax
    d34e:	8b 08                	mov    (%eax),%ecx
    d350:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d353:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d35a:	8b 45 08             	mov    0x8(%ebp),%eax
    d35d:	01 d8                	add    %ebx,%eax
    d35f:	8b 00                	mov    (%eax),%eax
    d361:	0f af c1             	imul   %ecx,%eax
    d364:	0f af 45 24          	imul   0x24(%ebp),%eax
    d368:	83 c0 07             	add    $0x7,%eax
    d36b:	c1 e8 03             	shr    $0x3,%eax
    d36e:	01 f0                	add    %esi,%eax
    d370:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d372:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d376:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d37a:	0f 85 b6 fe ff ff    	jne    d236 <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d380:	90                   	nop
    d381:	83 c4 10             	add    $0x10,%esp
    d384:	5b                   	pop    %ebx
    d385:	5e                   	pop    %esi
    d386:	5d                   	pop    %ebp
    d387:	c3                   	ret    

0000d388 <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    d388:	55                   	push   %ebp
    d389:	89 e5                	mov    %esp,%ebp
    d38b:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    d38e:	8b 45 10             	mov    0x10(%ebp),%eax
    d391:	05 98 00 00 00       	add    $0x98,%eax
    d396:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    d399:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    d39d:	74 06                	je     d3a5 <lodepng_inspect+0x1d>
    d39f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d3a3:	75 17                	jne    d3bc <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    d3a5:	8b 45 10             	mov    0x10(%ebp),%eax
    d3a8:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    d3af:	00 00 00 
    d3b2:	b8 30 00 00 00       	mov    $0x30,%eax
    d3b7:	e9 ce 02 00 00       	jmp    d68a <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    d3bc:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    d3c0:	7f 17                	jg     d3d9 <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    d3c2:	8b 45 10             	mov    0x10(%ebp),%eax
    d3c5:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    d3cc:	00 00 00 
    d3cf:	b8 1b 00 00 00       	mov    $0x1b,%eax
    d3d4:	e9 b1 02 00 00       	jmp    d68a <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    d3d9:	83 ec 0c             	sub    $0xc,%esp
    d3dc:	ff 75 f4             	pushl  -0xc(%ebp)
    d3df:	e8 63 c7 ff ff       	call   9b47 <lodepng_info_cleanup>
    d3e4:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    d3e7:	83 ec 0c             	sub    $0xc,%esp
    d3ea:	ff 75 f4             	pushl  -0xc(%ebp)
    d3ed:	e8 74 c6 ff ff       	call   9a66 <lodepng_info_init>
    d3f2:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    d3f5:	8b 45 14             	mov    0x14(%ebp),%eax
    d3f8:	0f b6 00             	movzbl (%eax),%eax
    d3fb:	3c 89                	cmp    $0x89,%al
    d3fd:	75 5b                	jne    d45a <lodepng_inspect+0xd2>
    d3ff:	8b 45 14             	mov    0x14(%ebp),%eax
    d402:	83 c0 01             	add    $0x1,%eax
    d405:	0f b6 00             	movzbl (%eax),%eax
    d408:	3c 50                	cmp    $0x50,%al
    d40a:	75 4e                	jne    d45a <lodepng_inspect+0xd2>
    d40c:	8b 45 14             	mov    0x14(%ebp),%eax
    d40f:	83 c0 02             	add    $0x2,%eax
    d412:	0f b6 00             	movzbl (%eax),%eax
    d415:	3c 4e                	cmp    $0x4e,%al
    d417:	75 41                	jne    d45a <lodepng_inspect+0xd2>
    d419:	8b 45 14             	mov    0x14(%ebp),%eax
    d41c:	83 c0 03             	add    $0x3,%eax
    d41f:	0f b6 00             	movzbl (%eax),%eax
    d422:	3c 47                	cmp    $0x47,%al
    d424:	75 34                	jne    d45a <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    d426:	8b 45 14             	mov    0x14(%ebp),%eax
    d429:	83 c0 04             	add    $0x4,%eax
    d42c:	0f b6 00             	movzbl (%eax),%eax
    d42f:	3c 0d                	cmp    $0xd,%al
    d431:	75 27                	jne    d45a <lodepng_inspect+0xd2>
    d433:	8b 45 14             	mov    0x14(%ebp),%eax
    d436:	83 c0 05             	add    $0x5,%eax
    d439:	0f b6 00             	movzbl (%eax),%eax
    d43c:	3c 0a                	cmp    $0xa,%al
    d43e:	75 1a                	jne    d45a <lodepng_inspect+0xd2>
    d440:	8b 45 14             	mov    0x14(%ebp),%eax
    d443:	83 c0 06             	add    $0x6,%eax
    d446:	0f b6 00             	movzbl (%eax),%eax
    d449:	3c 1a                	cmp    $0x1a,%al
    d44b:	75 0d                	jne    d45a <lodepng_inspect+0xd2>
    d44d:	8b 45 14             	mov    0x14(%ebp),%eax
    d450:	83 c0 07             	add    $0x7,%eax
    d453:	0f b6 00             	movzbl (%eax),%eax
    d456:	3c 0a                	cmp    $0xa,%al
    d458:	74 17                	je     d471 <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    d45a:	8b 45 10             	mov    0x10(%ebp),%eax
    d45d:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    d464:	00 00 00 
    d467:	b8 1c 00 00 00       	mov    $0x1c,%eax
    d46c:	e9 19 02 00 00       	jmp    d68a <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    d471:	8b 45 14             	mov    0x14(%ebp),%eax
    d474:	83 c0 08             	add    $0x8,%eax
    d477:	83 ec 0c             	sub    $0xc,%esp
    d47a:	50                   	push   %eax
    d47b:	e8 c2 ae ff ff       	call   8342 <lodepng_chunk_length>
    d480:	83 c4 10             	add    $0x10,%esp
    d483:	83 f8 0d             	cmp    $0xd,%eax
    d486:	74 17                	je     d49f <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    d488:	8b 45 10             	mov    0x10(%ebp),%eax
    d48b:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    d492:	00 00 00 
    d495:	b8 5e 00 00 00       	mov    $0x5e,%eax
    d49a:	e9 eb 01 00 00       	jmp    d68a <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    d49f:	8b 45 14             	mov    0x14(%ebp),%eax
    d4a2:	83 c0 08             	add    $0x8,%eax
    d4a5:	83 ec 08             	sub    $0x8,%esp
    d4a8:	68 ec a0 01 00       	push   $0x1a0ec
    d4ad:	50                   	push   %eax
    d4ae:	e8 dc ae ff ff       	call   838f <lodepng_chunk_type_equals>
    d4b3:	83 c4 10             	add    $0x10,%esp
    d4b6:	84 c0                	test   %al,%al
    d4b8:	75 17                	jne    d4d1 <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    d4ba:	8b 45 10             	mov    0x10(%ebp),%eax
    d4bd:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    d4c4:	00 00 00 
    d4c7:	b8 1d 00 00 00       	mov    $0x1d,%eax
    d4cc:	e9 b9 01 00 00       	jmp    d68a <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    d4d1:	8b 45 14             	mov    0x14(%ebp),%eax
    d4d4:	83 c0 10             	add    $0x10,%eax
    d4d7:	83 ec 0c             	sub    $0xc,%esp
    d4da:	50                   	push   %eax
    d4db:	e8 5e 62 ff ff       	call   373e <lodepng_read32bitInt>
    d4e0:	83 c4 10             	add    $0x10,%esp
    d4e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    d4e6:	8b 45 14             	mov    0x14(%ebp),%eax
    d4e9:	83 c0 14             	add    $0x14,%eax
    d4ec:	83 ec 0c             	sub    $0xc,%esp
    d4ef:	50                   	push   %eax
    d4f0:	e8 49 62 ff ff       	call   373e <lodepng_read32bitInt>
    d4f5:	83 c4 10             	add    $0x10,%esp
    d4f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    d4fb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d4ff:	74 08                	je     d509 <lodepng_inspect+0x181>
    d501:	8b 45 08             	mov    0x8(%ebp),%eax
    d504:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d507:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    d509:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d50d:	74 08                	je     d517 <lodepng_inspect+0x18f>
    d50f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d512:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d515:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    d517:	8b 45 14             	mov    0x14(%ebp),%eax
    d51a:	83 c0 18             	add    $0x18,%eax
    d51d:	0f b6 00             	movzbl (%eax),%eax
    d520:	0f b6 d0             	movzbl %al,%edx
    d523:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d526:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    d529:	8b 45 14             	mov    0x14(%ebp),%eax
    d52c:	83 c0 19             	add    $0x19,%eax
    d52f:	0f b6 00             	movzbl (%eax),%eax
    d532:	0f b6 d0             	movzbl %al,%edx
    d535:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d538:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    d53b:	8b 45 14             	mov    0x14(%ebp),%eax
    d53e:	83 c0 1a             	add    $0x1a,%eax
    d541:	0f b6 00             	movzbl (%eax),%eax
    d544:	0f b6 d0             	movzbl %al,%edx
    d547:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d54a:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    d54c:	8b 45 14             	mov    0x14(%ebp),%eax
    d54f:	83 c0 1b             	add    $0x1b,%eax
    d552:	0f b6 00             	movzbl (%eax),%eax
    d555:	0f b6 d0             	movzbl %al,%edx
    d558:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d55b:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    d55e:	8b 45 14             	mov    0x14(%ebp),%eax
    d561:	83 c0 1c             	add    $0x1c,%eax
    d564:	0f b6 00             	movzbl (%eax),%eax
    d567:	0f b6 d0             	movzbl %al,%edx
    d56a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d56d:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    d570:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d574:	74 06                	je     d57c <lodepng_inspect+0x1f4>
    d576:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d57a:	75 17                	jne    d593 <lodepng_inspect+0x20b>
    d57c:	8b 45 10             	mov    0x10(%ebp),%eax
    d57f:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    d586:	00 00 00 
    d589:	b8 5d 00 00 00       	mov    $0x5d,%eax
    d58e:	e9 f7 00 00 00       	jmp    d68a <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    d593:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d596:	8b 50 10             	mov    0x10(%eax),%edx
    d599:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d59c:	8b 40 0c             	mov    0xc(%eax),%eax
    d59f:	83 ec 08             	sub    $0x8,%esp
    d5a2:	52                   	push   %edx
    d5a3:	50                   	push   %eax
    d5a4:	e8 d4 b3 ff ff       	call   897d <checkColorValidity>
    d5a9:	83 c4 10             	add    $0x10,%esp
    d5ac:	89 c2                	mov    %eax,%edx
    d5ae:	8b 45 10             	mov    0x10(%ebp),%eax
    d5b1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    d5b7:	8b 45 10             	mov    0x10(%ebp),%eax
    d5ba:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d5c0:	85 c0                	test   %eax,%eax
    d5c2:	74 0e                	je     d5d2 <lodepng_inspect+0x24a>
    d5c4:	8b 45 10             	mov    0x10(%ebp),%eax
    d5c7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d5cd:	e9 b8 00 00 00       	jmp    d68a <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    d5d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5d5:	8b 00                	mov    (%eax),%eax
    d5d7:	85 c0                	test   %eax,%eax
    d5d9:	74 17                	je     d5f2 <lodepng_inspect+0x26a>
    d5db:	8b 45 10             	mov    0x10(%ebp),%eax
    d5de:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    d5e5:	00 00 00 
    d5e8:	b8 20 00 00 00       	mov    $0x20,%eax
    d5ed:	e9 98 00 00 00       	jmp    d68a <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    d5f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5f5:	8b 40 04             	mov    0x4(%eax),%eax
    d5f8:	85 c0                	test   %eax,%eax
    d5fa:	74 14                	je     d610 <lodepng_inspect+0x288>
    d5fc:	8b 45 10             	mov    0x10(%ebp),%eax
    d5ff:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    d606:	00 00 00 
    d609:	b8 21 00 00 00       	mov    $0x21,%eax
    d60e:	eb 7a                	jmp    d68a <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    d610:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d613:	8b 40 08             	mov    0x8(%eax),%eax
    d616:	83 f8 01             	cmp    $0x1,%eax
    d619:	76 14                	jbe    d62f <lodepng_inspect+0x2a7>
    d61b:	8b 45 10             	mov    0x10(%ebp),%eax
    d61e:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    d625:	00 00 00 
    d628:	b8 22 00 00 00       	mov    $0x22,%eax
    d62d:	eb 5b                	jmp    d68a <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    d62f:	8b 45 10             	mov    0x10(%ebp),%eax
    d632:	8b 40 18             	mov    0x18(%eax),%eax
    d635:	85 c0                	test   %eax,%eax
    d637:	75 48                	jne    d681 <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    d639:	8b 45 14             	mov    0x14(%ebp),%eax
    d63c:	83 c0 1d             	add    $0x1d,%eax
    d63f:	83 ec 0c             	sub    $0xc,%esp
    d642:	50                   	push   %eax
    d643:	e8 f6 60 ff ff       	call   373e <lodepng_read32bitInt>
    d648:	83 c4 10             	add    $0x10,%esp
    d64b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    d64e:	8b 45 14             	mov    0x14(%ebp),%eax
    d651:	83 c0 0c             	add    $0xc,%eax
    d654:	83 ec 08             	sub    $0x8,%esp
    d657:	6a 11                	push   $0x11
    d659:	50                   	push   %eax
    d65a:	e8 71 ab ff ff       	call   81d0 <lodepng_crc32>
    d65f:	83 c4 10             	add    $0x10,%esp
    d662:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    d665:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d668:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d66b:	74 14                	je     d681 <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    d66d:	8b 45 10             	mov    0x10(%ebp),%eax
    d670:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    d677:	00 00 00 
    d67a:	b8 39 00 00 00       	mov    $0x39,%eax
    d67f:	eb 09                	jmp    d68a <lodepng_inspect+0x302>
    }
  }

  return state->error;
    d681:	8b 45 10             	mov    0x10(%ebp),%eax
    d684:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    d68a:	c9                   	leave  
    d68b:	c3                   	ret    

0000d68c <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    d68c:	55                   	push   %ebp
    d68d:	89 e5                	mov    %esp,%ebp
    d68f:	56                   	push   %esi
    d690:	53                   	push   %ebx
    d691:	83 ec 44             	sub    $0x44,%esp
    d694:	8b 45 18             	mov    0x18(%ebp),%eax
    d697:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    d69a:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    d69e:	83 f8 04             	cmp    $0x4,%eax
    d6a1:	0f 87 81 07 00 00    	ja     de28 <unfilterScanline+0x79c>
    d6a7:	8b 04 85 f4 a0 01 00 	mov    0x1a0f4(,%eax,4),%eax
    d6ae:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d6b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6b7:	eb 19                	jmp    d6d2 <unfilterScanline+0x46>
    d6b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6bc:	8b 45 08             	mov    0x8(%ebp),%eax
    d6bf:	01 c2                	add    %eax,%edx
    d6c1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d6c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    d6c7:	01 c8                	add    %ecx,%eax
    d6c9:	0f b6 00             	movzbl (%eax),%eax
    d6cc:	88 02                	mov    %al,(%edx)
    d6ce:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d6d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6d5:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d6d8:	75 df                	jne    d6b9 <unfilterScanline+0x2d>
      break;
    d6da:	e9 50 07 00 00       	jmp    de2f <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d6df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6e6:	eb 19                	jmp    d701 <unfilterScanline+0x75>
    d6e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6eb:	8b 45 08             	mov    0x8(%ebp),%eax
    d6ee:	01 c2                	add    %eax,%edx
    d6f0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d6f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    d6f6:	01 c8                	add    %ecx,%eax
    d6f8:	0f b6 00             	movzbl (%eax),%eax
    d6fb:	88 02                	mov    %al,(%edx)
    d6fd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d701:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d704:	3b 45 14             	cmp    0x14(%ebp),%eax
    d707:	75 df                	jne    d6e8 <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    d709:	8b 45 14             	mov    0x14(%ebp),%eax
    d70c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d70f:	eb 2b                	jmp    d73c <unfilterScanline+0xb0>
    d711:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d714:	8b 45 08             	mov    0x8(%ebp),%eax
    d717:	01 c2                	add    %eax,%edx
    d719:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d71c:	8b 45 0c             	mov    0xc(%ebp),%eax
    d71f:	01 c8                	add    %ecx,%eax
    d721:	0f b6 08             	movzbl (%eax),%ecx
    d724:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d727:	2b 45 14             	sub    0x14(%ebp),%eax
    d72a:	89 c3                	mov    %eax,%ebx
    d72c:	8b 45 08             	mov    0x8(%ebp),%eax
    d72f:	01 d8                	add    %ebx,%eax
    d731:	0f b6 00             	movzbl (%eax),%eax
    d734:	01 c8                	add    %ecx,%eax
    d736:	88 02                	mov    %al,(%edx)
    d738:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d73c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d73f:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d742:	7c cd                	jl     d711 <unfilterScanline+0x85>
      break;
    d744:	e9 e6 06 00 00       	jmp    de2f <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    d749:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d74d:	74 3c                	je     d78b <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    d74f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d756:	eb 26                	jmp    d77e <unfilterScanline+0xf2>
    d758:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d75b:	8b 45 08             	mov    0x8(%ebp),%eax
    d75e:	01 d0                	add    %edx,%eax
    d760:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d763:	8b 55 0c             	mov    0xc(%ebp),%edx
    d766:	01 ca                	add    %ecx,%edx
    d768:	0f b6 0a             	movzbl (%edx),%ecx
    d76b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d76e:	8b 55 10             	mov    0x10(%ebp),%edx
    d771:	01 da                	add    %ebx,%edx
    d773:	0f b6 12             	movzbl (%edx),%edx
    d776:	01 ca                	add    %ecx,%edx
    d778:	88 10                	mov    %dl,(%eax)
    d77a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d77e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d781:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d784:	75 d2                	jne    d758 <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    d786:	e9 a4 06 00 00       	jmp    de2f <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d78b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d792:	eb 19                	jmp    d7ad <unfilterScanline+0x121>
    d794:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d797:	8b 45 08             	mov    0x8(%ebp),%eax
    d79a:	01 c2                	add    %eax,%edx
    d79c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d79f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7a2:	01 c8                	add    %ecx,%eax
    d7a4:	0f b6 00             	movzbl (%eax),%eax
    d7a7:	88 02                	mov    %al,(%edx)
    d7a9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7b0:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d7b3:	75 df                	jne    d794 <unfilterScanline+0x108>
      }
      break;
    d7b5:	e9 75 06 00 00       	jmp    de2f <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    d7ba:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d7be:	0f 84 8e 00 00 00    	je     d852 <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    d7c4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d7cb:	eb 28                	jmp    d7f5 <unfilterScanline+0x169>
    d7cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7d0:	8b 45 08             	mov    0x8(%ebp),%eax
    d7d3:	01 d0                	add    %edx,%eax
    d7d5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7d8:	8b 55 0c             	mov    0xc(%ebp),%edx
    d7db:	01 ca                	add    %ecx,%edx
    d7dd:	0f b6 12             	movzbl (%edx),%edx
    d7e0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d7e3:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d7e6:	01 d9                	add    %ebx,%ecx
    d7e8:	0f b6 09             	movzbl (%ecx),%ecx
    d7eb:	d0 e9                	shr    %cl
    d7ed:	01 ca                	add    %ecx,%edx
    d7ef:	88 10                	mov    %dl,(%eax)
    d7f1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7f8:	3b 45 14             	cmp    0x14(%ebp),%eax
    d7fb:	75 d0                	jne    d7cd <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    d7fd:	8b 45 14             	mov    0x14(%ebp),%eax
    d800:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d803:	eb 40                	jmp    d845 <unfilterScanline+0x1b9>
    d805:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d808:	8b 45 08             	mov    0x8(%ebp),%eax
    d80b:	01 c2                	add    %eax,%edx
    d80d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d810:	8b 45 0c             	mov    0xc(%ebp),%eax
    d813:	01 c8                	add    %ecx,%eax
    d815:	0f b6 08             	movzbl (%eax),%ecx
    d818:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d81b:	2b 45 14             	sub    0x14(%ebp),%eax
    d81e:	89 c3                	mov    %eax,%ebx
    d820:	8b 45 08             	mov    0x8(%ebp),%eax
    d823:	01 d8                	add    %ebx,%eax
    d825:	0f b6 00             	movzbl (%eax),%eax
    d828:	0f b6 d8             	movzbl %al,%ebx
    d82b:	8b 75 f4             	mov    -0xc(%ebp),%esi
    d82e:	8b 45 10             	mov    0x10(%ebp),%eax
    d831:	01 f0                	add    %esi,%eax
    d833:	0f b6 00             	movzbl (%eax),%eax
    d836:	0f b6 c0             	movzbl %al,%eax
    d839:	01 d8                	add    %ebx,%eax
    d83b:	d1 f8                	sar    %eax
    d83d:	01 c8                	add    %ecx,%eax
    d83f:	88 02                	mov    %al,(%edx)
    d841:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d845:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d848:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d84b:	7c b8                	jl     d805 <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    d84d:	e9 dd 05 00 00       	jmp    de2f <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d852:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d859:	eb 19                	jmp    d874 <unfilterScanline+0x1e8>
    d85b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d85e:	8b 45 08             	mov    0x8(%ebp),%eax
    d861:	01 c2                	add    %eax,%edx
    d863:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d866:	8b 45 0c             	mov    0xc(%ebp),%eax
    d869:	01 c8                	add    %ecx,%eax
    d86b:	0f b6 00             	movzbl (%eax),%eax
    d86e:	88 02                	mov    %al,(%edx)
    d870:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d874:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d877:	3b 45 14             	cmp    0x14(%ebp),%eax
    d87a:	75 df                	jne    d85b <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    d87c:	8b 45 14             	mov    0x14(%ebp),%eax
    d87f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d882:	eb 2d                	jmp    d8b1 <unfilterScanline+0x225>
    d884:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d887:	8b 45 08             	mov    0x8(%ebp),%eax
    d88a:	01 c2                	add    %eax,%edx
    d88c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d88f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d892:	01 c8                	add    %ecx,%eax
    d894:	0f b6 08             	movzbl (%eax),%ecx
    d897:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d89a:	2b 45 14             	sub    0x14(%ebp),%eax
    d89d:	89 c3                	mov    %eax,%ebx
    d89f:	8b 45 08             	mov    0x8(%ebp),%eax
    d8a2:	01 d8                	add    %ebx,%eax
    d8a4:	0f b6 00             	movzbl (%eax),%eax
    d8a7:	d0 e8                	shr    %al
    d8a9:	01 c8                	add    %ecx,%eax
    d8ab:	88 02                	mov    %al,(%edx)
    d8ad:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d8b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8b4:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d8b7:	7c cb                	jl     d884 <unfilterScanline+0x1f8>
      }
      break;
    d8b9:	e9 71 05 00 00       	jmp    de2f <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    d8be:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d8c2:	0f 84 f9 04 00 00    	je     ddc1 <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    d8c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d8cf:	eb 26                	jmp    d8f7 <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    d8d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d8d4:	8b 45 08             	mov    0x8(%ebp),%eax
    d8d7:	01 d0                	add    %edx,%eax
    d8d9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d8dc:	8b 55 0c             	mov    0xc(%ebp),%edx
    d8df:	01 ca                	add    %ecx,%edx
    d8e1:	0f b6 0a             	movzbl (%edx),%ecx
    d8e4:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d8e7:	8b 55 10             	mov    0x10(%ebp),%edx
    d8ea:	01 da                	add    %ebx,%edx
    d8ec:	0f b6 12             	movzbl (%edx),%edx
    d8ef:	01 ca                	add    %ecx,%edx
    d8f1:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    d8f3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d8f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8fa:	3b 45 14             	cmp    0x14(%ebp),%eax
    d8fd:	75 d2                	jne    d8d1 <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    d8ff:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    d903:	0f 8e db 01 00 00    	jle    dae4 <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    d909:	e9 c2 01 00 00       	jmp    dad0 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    d90e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d911:	2b 45 14             	sub    0x14(%ebp),%eax
    d914:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    d917:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d91a:	8b 45 0c             	mov    0xc(%ebp),%eax
    d91d:	01 d0                	add    %edx,%eax
    d91f:	0f b6 00             	movzbl (%eax),%eax
    d922:	88 45 ef             	mov    %al,-0x11(%ebp)
    d925:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d928:	8d 50 01             	lea    0x1(%eax),%edx
    d92b:	8b 45 0c             	mov    0xc(%ebp),%eax
    d92e:	01 d0                	add    %edx,%eax
    d930:	0f b6 00             	movzbl (%eax),%eax
    d933:	88 45 ee             	mov    %al,-0x12(%ebp)
    d936:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d939:	8d 50 02             	lea    0x2(%eax),%edx
    d93c:	8b 45 0c             	mov    0xc(%ebp),%eax
    d93f:	01 d0                	add    %edx,%eax
    d941:	0f b6 00             	movzbl (%eax),%eax
    d944:	88 45 ed             	mov    %al,-0x13(%ebp)
    d947:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d94a:	8d 50 03             	lea    0x3(%eax),%edx
    d94d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d950:	01 d0                	add    %edx,%eax
    d952:	0f b6 00             	movzbl (%eax),%eax
    d955:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    d958:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d95b:	8b 45 08             	mov    0x8(%ebp),%eax
    d95e:	01 d0                	add    %edx,%eax
    d960:	0f b6 00             	movzbl (%eax),%eax
    d963:	88 45 eb             	mov    %al,-0x15(%ebp)
    d966:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d969:	8d 50 01             	lea    0x1(%eax),%edx
    d96c:	8b 45 08             	mov    0x8(%ebp),%eax
    d96f:	01 d0                	add    %edx,%eax
    d971:	0f b6 00             	movzbl (%eax),%eax
    d974:	88 45 ea             	mov    %al,-0x16(%ebp)
    d977:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d97a:	8d 50 02             	lea    0x2(%eax),%edx
    d97d:	8b 45 08             	mov    0x8(%ebp),%eax
    d980:	01 d0                	add    %edx,%eax
    d982:	0f b6 00             	movzbl (%eax),%eax
    d985:	88 45 e9             	mov    %al,-0x17(%ebp)
    d988:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d98b:	8d 50 03             	lea    0x3(%eax),%edx
    d98e:	8b 45 08             	mov    0x8(%ebp),%eax
    d991:	01 d0                	add    %edx,%eax
    d993:	0f b6 00             	movzbl (%eax),%eax
    d996:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    d999:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d99c:	8b 45 10             	mov    0x10(%ebp),%eax
    d99f:	01 d0                	add    %edx,%eax
    d9a1:	0f b6 00             	movzbl (%eax),%eax
    d9a4:	88 45 e7             	mov    %al,-0x19(%ebp)
    d9a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9aa:	8d 50 01             	lea    0x1(%eax),%edx
    d9ad:	8b 45 10             	mov    0x10(%ebp),%eax
    d9b0:	01 d0                	add    %edx,%eax
    d9b2:	0f b6 00             	movzbl (%eax),%eax
    d9b5:	88 45 e6             	mov    %al,-0x1a(%ebp)
    d9b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9bb:	8d 50 02             	lea    0x2(%eax),%edx
    d9be:	8b 45 10             	mov    0x10(%ebp),%eax
    d9c1:	01 d0                	add    %edx,%eax
    d9c3:	0f b6 00             	movzbl (%eax),%eax
    d9c6:	88 45 e5             	mov    %al,-0x1b(%ebp)
    d9c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9cc:	8d 50 03             	lea    0x3(%eax),%edx
    d9cf:	8b 45 10             	mov    0x10(%ebp),%eax
    d9d2:	01 d0                	add    %edx,%eax
    d9d4:	0f b6 00             	movzbl (%eax),%eax
    d9d7:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    d9da:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d9dd:	8b 45 10             	mov    0x10(%ebp),%eax
    d9e0:	01 d0                	add    %edx,%eax
    d9e2:	0f b6 00             	movzbl (%eax),%eax
    d9e5:	88 45 e3             	mov    %al,-0x1d(%ebp)
    d9e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d9eb:	8d 50 01             	lea    0x1(%eax),%edx
    d9ee:	8b 45 10             	mov    0x10(%ebp),%eax
    d9f1:	01 d0                	add    %edx,%eax
    d9f3:	0f b6 00             	movzbl (%eax),%eax
    d9f6:	88 45 e2             	mov    %al,-0x1e(%ebp)
    d9f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d9fc:	8d 50 02             	lea    0x2(%eax),%edx
    d9ff:	8b 45 10             	mov    0x10(%ebp),%eax
    da02:	01 d0                	add    %edx,%eax
    da04:	0f b6 00             	movzbl (%eax),%eax
    da07:	88 45 e1             	mov    %al,-0x1f(%ebp)
    da0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    da0d:	8d 50 03             	lea    0x3(%eax),%edx
    da10:	8b 45 10             	mov    0x10(%ebp),%eax
    da13:	01 d0                	add    %edx,%eax
    da15:	0f b6 00             	movzbl (%eax),%eax
    da18:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    da1b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da1e:	8b 45 08             	mov    0x8(%ebp),%eax
    da21:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    da24:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    da28:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    da2c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    da30:	51                   	push   %ecx
    da31:	52                   	push   %edx
    da32:	50                   	push   %eax
    da33:	e8 3f f6 ff ff       	call   d077 <paethPredictor>
    da38:	83 c4 0c             	add    $0xc,%esp
    da3b:	89 c2                	mov    %eax,%edx
    da3d:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    da41:	01 d0                	add    %edx,%eax
    da43:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    da45:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da48:	8d 50 01             	lea    0x1(%eax),%edx
    da4b:	8b 45 08             	mov    0x8(%ebp),%eax
    da4e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    da51:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    da55:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    da59:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    da5d:	51                   	push   %ecx
    da5e:	52                   	push   %edx
    da5f:	50                   	push   %eax
    da60:	e8 12 f6 ff ff       	call   d077 <paethPredictor>
    da65:	83 c4 0c             	add    $0xc,%esp
    da68:	89 c2                	mov    %eax,%edx
    da6a:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    da6e:	01 d0                	add    %edx,%eax
    da70:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    da72:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da75:	8d 50 02             	lea    0x2(%eax),%edx
    da78:	8b 45 08             	mov    0x8(%ebp),%eax
    da7b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    da7e:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    da82:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    da86:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    da8a:	51                   	push   %ecx
    da8b:	52                   	push   %edx
    da8c:	50                   	push   %eax
    da8d:	e8 e5 f5 ff ff       	call   d077 <paethPredictor>
    da92:	83 c4 0c             	add    $0xc,%esp
    da95:	89 c2                	mov    %eax,%edx
    da97:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    da9b:	01 d0                	add    %edx,%eax
    da9d:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    da9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    daa2:	8d 50 03             	lea    0x3(%eax),%edx
    daa5:	8b 45 08             	mov    0x8(%ebp),%eax
    daa8:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    daab:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    daaf:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    dab3:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    dab7:	51                   	push   %ecx
    dab8:	52                   	push   %edx
    dab9:	50                   	push   %eax
    daba:	e8 b8 f5 ff ff       	call   d077 <paethPredictor>
    dabf:	83 c4 0c             	add    $0xc,%esp
    dac2:	89 c2                	mov    %eax,%edx
    dac4:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    dac8:	01 d0                	add    %edx,%eax
    daca:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    dacc:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    dad0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dad3:	83 c0 03             	add    $0x3,%eax
    dad6:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dad9:	0f 8c 2f fe ff ff    	jl     d90e <unfilterScanline+0x282>
    dadf:	e9 d3 02 00 00       	jmp    ddb7 <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    dae4:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    dae8:	0f 8e 6a 01 00 00    	jle    dc58 <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    daee:	e9 51 01 00 00       	jmp    dc44 <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    daf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    daf6:	2b 45 14             	sub    0x14(%ebp),%eax
    daf9:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    dafc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    daff:	8b 45 0c             	mov    0xc(%ebp),%eax
    db02:	01 d0                	add    %edx,%eax
    db04:	0f b6 00             	movzbl (%eax),%eax
    db07:	88 45 db             	mov    %al,-0x25(%ebp)
    db0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db0d:	8d 50 01             	lea    0x1(%eax),%edx
    db10:	8b 45 0c             	mov    0xc(%ebp),%eax
    db13:	01 d0                	add    %edx,%eax
    db15:	0f b6 00             	movzbl (%eax),%eax
    db18:	88 45 da             	mov    %al,-0x26(%ebp)
    db1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db1e:	8d 50 02             	lea    0x2(%eax),%edx
    db21:	8b 45 0c             	mov    0xc(%ebp),%eax
    db24:	01 d0                	add    %edx,%eax
    db26:	0f b6 00             	movzbl (%eax),%eax
    db29:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    db2c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    db2f:	8b 45 08             	mov    0x8(%ebp),%eax
    db32:	01 d0                	add    %edx,%eax
    db34:	0f b6 00             	movzbl (%eax),%eax
    db37:	88 45 d8             	mov    %al,-0x28(%ebp)
    db3a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db3d:	8d 50 01             	lea    0x1(%eax),%edx
    db40:	8b 45 08             	mov    0x8(%ebp),%eax
    db43:	01 d0                	add    %edx,%eax
    db45:	0f b6 00             	movzbl (%eax),%eax
    db48:	88 45 d7             	mov    %al,-0x29(%ebp)
    db4b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db4e:	8d 50 02             	lea    0x2(%eax),%edx
    db51:	8b 45 08             	mov    0x8(%ebp),%eax
    db54:	01 d0                	add    %edx,%eax
    db56:	0f b6 00             	movzbl (%eax),%eax
    db59:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    db5c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db5f:	8b 45 10             	mov    0x10(%ebp),%eax
    db62:	01 d0                	add    %edx,%eax
    db64:	0f b6 00             	movzbl (%eax),%eax
    db67:	88 45 d5             	mov    %al,-0x2b(%ebp)
    db6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db6d:	8d 50 01             	lea    0x1(%eax),%edx
    db70:	8b 45 10             	mov    0x10(%ebp),%eax
    db73:	01 d0                	add    %edx,%eax
    db75:	0f b6 00             	movzbl (%eax),%eax
    db78:	88 45 d4             	mov    %al,-0x2c(%ebp)
    db7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db7e:	8d 50 02             	lea    0x2(%eax),%edx
    db81:	8b 45 10             	mov    0x10(%ebp),%eax
    db84:	01 d0                	add    %edx,%eax
    db86:	0f b6 00             	movzbl (%eax),%eax
    db89:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    db8c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    db8f:	8b 45 10             	mov    0x10(%ebp),%eax
    db92:	01 d0                	add    %edx,%eax
    db94:	0f b6 00             	movzbl (%eax),%eax
    db97:	88 45 d2             	mov    %al,-0x2e(%ebp)
    db9a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db9d:	8d 50 01             	lea    0x1(%eax),%edx
    dba0:	8b 45 10             	mov    0x10(%ebp),%eax
    dba3:	01 d0                	add    %edx,%eax
    dba5:	0f b6 00             	movzbl (%eax),%eax
    dba8:	88 45 d1             	mov    %al,-0x2f(%ebp)
    dbab:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dbae:	8d 50 02             	lea    0x2(%eax),%edx
    dbb1:	8b 45 10             	mov    0x10(%ebp),%eax
    dbb4:	01 d0                	add    %edx,%eax
    dbb6:	0f b6 00             	movzbl (%eax),%eax
    dbb9:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dbbc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dbbf:	8b 45 08             	mov    0x8(%ebp),%eax
    dbc2:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dbc5:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    dbc9:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    dbcd:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    dbd1:	51                   	push   %ecx
    dbd2:	52                   	push   %edx
    dbd3:	50                   	push   %eax
    dbd4:	e8 9e f4 ff ff       	call   d077 <paethPredictor>
    dbd9:	83 c4 0c             	add    $0xc,%esp
    dbdc:	89 c2                	mov    %eax,%edx
    dbde:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    dbe2:	01 d0                	add    %edx,%eax
    dbe4:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dbe6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbe9:	8d 50 01             	lea    0x1(%eax),%edx
    dbec:	8b 45 08             	mov    0x8(%ebp),%eax
    dbef:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dbf2:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    dbf6:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    dbfa:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    dbfe:	51                   	push   %ecx
    dbff:	52                   	push   %edx
    dc00:	50                   	push   %eax
    dc01:	e8 71 f4 ff ff       	call   d077 <paethPredictor>
    dc06:	83 c4 0c             	add    $0xc,%esp
    dc09:	89 c2                	mov    %eax,%edx
    dc0b:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    dc0f:	01 d0                	add    %edx,%eax
    dc11:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    dc13:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc16:	8d 50 02             	lea    0x2(%eax),%edx
    dc19:	8b 45 08             	mov    0x8(%ebp),%eax
    dc1c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc1f:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    dc23:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    dc27:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    dc2b:	51                   	push   %ecx
    dc2c:	52                   	push   %edx
    dc2d:	50                   	push   %eax
    dc2e:	e8 44 f4 ff ff       	call   d077 <paethPredictor>
    dc33:	83 c4 0c             	add    $0xc,%esp
    dc36:	89 c2                	mov    %eax,%edx
    dc38:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    dc3c:	01 d0                	add    %edx,%eax
    dc3e:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    dc40:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    dc44:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc47:	83 c0 02             	add    $0x2,%eax
    dc4a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dc4d:	0f 8c a0 fe ff ff    	jl     daf3 <unfilterScanline+0x467>
    dc53:	e9 5f 01 00 00       	jmp    ddb7 <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    dc58:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    dc5c:	0f 8e 55 01 00 00    	jle    ddb7 <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    dc62:	e9 e0 00 00 00       	jmp    dd47 <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    dc67:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc6a:	2b 45 14             	sub    0x14(%ebp),%eax
    dc6d:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    dc70:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc73:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc76:	01 d0                	add    %edx,%eax
    dc78:	0f b6 00             	movzbl (%eax),%eax
    dc7b:	88 45 cb             	mov    %al,-0x35(%ebp)
    dc7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc81:	8d 50 01             	lea    0x1(%eax),%edx
    dc84:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc87:	01 d0                	add    %edx,%eax
    dc89:	0f b6 00             	movzbl (%eax),%eax
    dc8c:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    dc8f:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dc92:	8b 45 08             	mov    0x8(%ebp),%eax
    dc95:	01 d0                	add    %edx,%eax
    dc97:	0f b6 00             	movzbl (%eax),%eax
    dc9a:	88 45 c9             	mov    %al,-0x37(%ebp)
    dc9d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dca0:	8d 50 01             	lea    0x1(%eax),%edx
    dca3:	8b 45 08             	mov    0x8(%ebp),%eax
    dca6:	01 d0                	add    %edx,%eax
    dca8:	0f b6 00             	movzbl (%eax),%eax
    dcab:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    dcae:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcb1:	8b 45 10             	mov    0x10(%ebp),%eax
    dcb4:	01 d0                	add    %edx,%eax
    dcb6:	0f b6 00             	movzbl (%eax),%eax
    dcb9:	88 45 c7             	mov    %al,-0x39(%ebp)
    dcbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcbf:	8d 50 01             	lea    0x1(%eax),%edx
    dcc2:	8b 45 10             	mov    0x10(%ebp),%eax
    dcc5:	01 d0                	add    %edx,%eax
    dcc7:	0f b6 00             	movzbl (%eax),%eax
    dcca:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    dccd:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dcd0:	8b 45 10             	mov    0x10(%ebp),%eax
    dcd3:	01 d0                	add    %edx,%eax
    dcd5:	0f b6 00             	movzbl (%eax),%eax
    dcd8:	88 45 c5             	mov    %al,-0x3b(%ebp)
    dcdb:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dcde:	8d 50 01             	lea    0x1(%eax),%edx
    dce1:	8b 45 10             	mov    0x10(%ebp),%eax
    dce4:	01 d0                	add    %edx,%eax
    dce6:	0f b6 00             	movzbl (%eax),%eax
    dce9:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dcec:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcef:	8b 45 08             	mov    0x8(%ebp),%eax
    dcf2:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dcf5:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    dcf9:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    dcfd:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    dd01:	51                   	push   %ecx
    dd02:	52                   	push   %edx
    dd03:	50                   	push   %eax
    dd04:	e8 6e f3 ff ff       	call   d077 <paethPredictor>
    dd09:	83 c4 0c             	add    $0xc,%esp
    dd0c:	89 c2                	mov    %eax,%edx
    dd0e:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    dd12:	01 d0                	add    %edx,%eax
    dd14:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dd16:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd19:	8d 50 01             	lea    0x1(%eax),%edx
    dd1c:	8b 45 08             	mov    0x8(%ebp),%eax
    dd1f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dd22:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    dd26:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    dd2a:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    dd2e:	51                   	push   %ecx
    dd2f:	52                   	push   %edx
    dd30:	50                   	push   %eax
    dd31:	e8 41 f3 ff ff       	call   d077 <paethPredictor>
    dd36:	83 c4 0c             	add    $0xc,%esp
    dd39:	89 c2                	mov    %eax,%edx
    dd3b:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    dd3f:	01 d0                	add    %edx,%eax
    dd41:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    dd43:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    dd47:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd4a:	83 c0 01             	add    $0x1,%eax
    dd4d:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd50:	0f 8c 11 ff ff ff    	jl     dc67 <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dd56:	eb 5f                	jmp    ddb7 <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    dd58:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd5b:	8b 45 08             	mov    0x8(%ebp),%eax
    dd5e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dd61:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd64:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd67:	01 d0                	add    %edx,%eax
    dd69:	0f b6 00             	movzbl (%eax),%eax
    dd6c:	88 45 b7             	mov    %al,-0x49(%ebp)
    dd6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd72:	2b 45 14             	sub    0x14(%ebp),%eax
    dd75:	89 c2                	mov    %eax,%edx
    dd77:	8b 45 10             	mov    0x10(%ebp),%eax
    dd7a:	01 d0                	add    %edx,%eax
    dd7c:	0f b6 00             	movzbl (%eax),%eax
    dd7f:	0f b6 c8             	movzbl %al,%ecx
    dd82:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd85:	8b 45 10             	mov    0x10(%ebp),%eax
    dd88:	01 d0                	add    %edx,%eax
    dd8a:	0f b6 00             	movzbl (%eax),%eax
    dd8d:	0f b6 d0             	movzbl %al,%edx
    dd90:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd93:	2b 45 14             	sub    0x14(%ebp),%eax
    dd96:	89 c6                	mov    %eax,%esi
    dd98:	8b 45 08             	mov    0x8(%ebp),%eax
    dd9b:	01 f0                	add    %esi,%eax
    dd9d:	0f b6 00             	movzbl (%eax),%eax
    dda0:	0f b6 c0             	movzbl %al,%eax
    dda3:	51                   	push   %ecx
    dda4:	52                   	push   %edx
    dda5:	50                   	push   %eax
    dda6:	e8 cc f2 ff ff       	call   d077 <paethPredictor>
    ddab:	83 c4 0c             	add    $0xc,%esp
    ddae:	02 45 b7             	add    -0x49(%ebp),%al
    ddb1:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    ddb3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ddb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddba:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ddbd:	75 99                	jne    dd58 <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    ddbf:	eb 6e                	jmp    de2f <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    ddc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ddc8:	eb 19                	jmp    dde3 <unfilterScanline+0x757>
          recon[i] = scanline[i];
    ddca:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ddcd:	8b 45 08             	mov    0x8(%ebp),%eax
    ddd0:	01 c2                	add    %eax,%edx
    ddd2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ddd5:	8b 45 0c             	mov    0xc(%ebp),%eax
    ddd8:	01 c8                	add    %ecx,%eax
    ddda:	0f b6 00             	movzbl (%eax),%eax
    dddd:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    dddf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dde3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dde6:	3b 45 14             	cmp    0x14(%ebp),%eax
    dde9:	75 df                	jne    ddca <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    ddeb:	8b 45 14             	mov    0x14(%ebp),%eax
    ddee:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ddf1:	eb 2b                	jmp    de1e <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    ddf3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ddf6:	8b 45 08             	mov    0x8(%ebp),%eax
    ddf9:	01 c2                	add    %eax,%edx
    ddfb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ddfe:	8b 45 0c             	mov    0xc(%ebp),%eax
    de01:	01 c8                	add    %ecx,%eax
    de03:	0f b6 08             	movzbl (%eax),%ecx
    de06:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de09:	2b 45 14             	sub    0x14(%ebp),%eax
    de0c:	89 c3                	mov    %eax,%ebx
    de0e:	8b 45 08             	mov    0x8(%ebp),%eax
    de11:	01 d8                	add    %ebx,%eax
    de13:	0f b6 00             	movzbl (%eax),%eax
    de16:	01 c8                	add    %ecx,%eax
    de18:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    de1a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    de1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de21:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    de24:	7c cd                	jl     ddf3 <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    de26:	eb 07                	jmp    de2f <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    de28:	b8 24 00 00 00       	mov    $0x24,%eax
    de2d:	eb 05                	jmp    de34 <unfilterScanline+0x7a8>
  }
  return 0;
    de2f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    de34:	8d 65 f8             	lea    -0x8(%ebp),%esp
    de37:	5b                   	pop    %ebx
    de38:	5e                   	pop    %esi
    de39:	5d                   	pop    %ebp
    de3a:	c3                   	ret    

0000de3b <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    de3b:	55                   	push   %ebp
    de3c:	89 e5                	mov    %esp,%ebp
    de3e:	53                   	push   %ebx
    de3f:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    de42:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    de49:	8b 45 18             	mov    0x18(%ebp),%eax
    de4c:	83 c0 07             	add    $0x7,%eax
    de4f:	c1 e8 03             	shr    $0x3,%eax
    de52:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    de55:	ff 75 18             	pushl  0x18(%ebp)
    de58:	6a 01                	push   $0x1
    de5a:	ff 75 10             	pushl  0x10(%ebp)
    de5d:	e8 d9 b1 ff ff       	call   903b <lodepng_get_raw_size_idat>
    de62:	83 c4 0c             	add    $0xc,%esp
    de65:	83 e8 01             	sub    $0x1,%eax
    de68:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    de6b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    de72:	eb 6d                	jmp    dee1 <unfilter+0xa6>
    size_t outindex = linebytes * y;
    de74:	8b 45 ec             	mov    -0x14(%ebp),%eax
    de77:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    de7b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    de7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    de81:	83 c0 01             	add    $0x1,%eax
    de84:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    de88:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    de8b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    de8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    de91:	01 d0                	add    %edx,%eax
    de93:	0f b6 00             	movzbl (%eax),%eax
    de96:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    de99:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    de9d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    dea0:	8d 4a 01             	lea    0x1(%edx),%ecx
    dea3:	8b 55 0c             	mov    0xc(%ebp),%edx
    dea6:	01 d1                	add    %edx,%ecx
    dea8:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    deab:	8b 55 08             	mov    0x8(%ebp),%edx
    deae:	01 da                	add    %ebx,%edx
    deb0:	ff 75 ec             	pushl  -0x14(%ebp)
    deb3:	50                   	push   %eax
    deb4:	ff 75 f0             	pushl  -0x10(%ebp)
    deb7:	ff 75 f4             	pushl  -0xc(%ebp)
    deba:	51                   	push   %ecx
    debb:	52                   	push   %edx
    debc:	e8 cb f7 ff ff       	call   d68c <unfilterScanline>
    dec1:	83 c4 18             	add    $0x18,%esp
    dec4:	89 45 dc             	mov    %eax,-0x24(%ebp)
    dec7:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    decb:	74 05                	je     ded2 <unfilter+0x97>
    decd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ded0:	eb 1c                	jmp    deee <unfilter+0xb3>

    prevline = &out[outindex];
    ded2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ded5:	8b 45 08             	mov    0x8(%ebp),%eax
    ded8:	01 d0                	add    %edx,%eax
    deda:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    dedd:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    dee1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    dee4:	3b 45 14             	cmp    0x14(%ebp),%eax
    dee7:	72 8b                	jb     de74 <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    dee9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    deee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    def1:	c9                   	leave  
    def2:	c3                   	ret    

0000def3 <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    def3:	55                   	push   %ebp
    def4:	89 e5                	mov    %esp,%ebp
    def6:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    defc:	ff 75 18             	pushl  0x18(%ebp)
    deff:	ff 75 14             	pushl  0x14(%ebp)
    df02:	ff 75 10             	pushl  0x10(%ebp)
    df05:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    df0b:	50                   	push   %eax
    df0c:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    df12:	50                   	push   %eax
    df13:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    df19:	50                   	push   %eax
    df1a:	8d 45 94             	lea    -0x6c(%ebp),%eax
    df1d:	50                   	push   %eax
    df1e:	8d 45 b0             	lea    -0x50(%ebp),%eax
    df21:	50                   	push   %eax
    df22:	e8 e6 f1 ff ff       	call   d10d <Adam7_getpassvalues>
    df27:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    df2a:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    df2e:	0f 86 0a 01 00 00    	jbe    e03e <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    df34:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    df3b:	e9 ef 00 00 00       	jmp    e02f <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    df40:	8b 45 18             	mov    0x18(%ebp),%eax
    df43:	c1 e8 03             	shr    $0x3,%eax
    df46:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    df49:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    df50:	e9 c6 00 00 00       	jmp    e01b <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    df55:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    df5c:	e9 a6 00 00 00       	jmp    e007 <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    df61:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df64:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    df6b:	89 c1                	mov    %eax,%ecx
    df6d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df70:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    df74:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    df78:	89 c2                	mov    %eax,%edx
    df7a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    df7d:	01 c2                	add    %eax,%edx
    df7f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    df82:	0f af c2             	imul   %edx,%eax
    df85:	01 c8                	add    %ecx,%eax
    df87:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    df8a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df8d:	8b 14 85 98 a0 01 00 	mov    0x1a098(,%eax,4),%edx
    df94:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df97:	8b 04 85 d0 a0 01 00 	mov    0x1a0d0(,%eax,4),%eax
    df9e:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    dfa2:	01 d0                	add    %edx,%eax
    dfa4:	0f af 45 10          	imul   0x10(%ebp),%eax
    dfa8:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    dfaa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfad:	8b 04 85 b4 a0 01 00 	mov    0x1a0b4(,%eax,4),%eax
    dfb4:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    dfb8:	01 c2                	add    %eax,%edx
    dfba:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfbd:	8b 04 85 7c a0 01 00 	mov    0x1a07c(,%eax,4),%eax
    dfc4:	01 c2                	add    %eax,%edx
    dfc6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    dfc9:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    dfcc:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    dfcf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    dfd6:	eb 23                	jmp    dffb <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    dfd8:	8b 55 d8             	mov    -0x28(%ebp),%edx
    dfdb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dfde:	01 c2                	add    %eax,%edx
    dfe0:	8b 45 08             	mov    0x8(%ebp),%eax
    dfe3:	01 c2                	add    %eax,%edx
    dfe5:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    dfe8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dfeb:	01 c1                	add    %eax,%ecx
    dfed:	8b 45 0c             	mov    0xc(%ebp),%eax
    dff0:	01 c8                	add    %ecx,%eax
    dff2:	0f b6 00             	movzbl (%eax),%eax
    dff5:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    dff7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    dffb:	8b 45 e0             	mov    -0x20(%ebp),%eax
    dffe:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e001:	72 d5                	jb     dfd8 <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e003:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e007:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e00a:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e00e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    e011:	0f 87 4a ff ff ff    	ja     df61 <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    e017:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e01b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e01e:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e022:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    e025:	0f 87 2a ff ff ff    	ja     df55 <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    e02b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e02f:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e033:	0f 85 07 ff ff ff    	jne    df40 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e039:	e9 22 01 00 00       	jmp    e160 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e03e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e045:	e9 0c 01 00 00       	jmp    e156 <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    e04a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e04d:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e051:	0f af 45 18          	imul   0x18(%ebp),%eax
    e055:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    e058:	8b 45 18             	mov    0x18(%ebp),%eax
    e05b:	0f af 45 10          	imul   0x10(%ebp),%eax
    e05f:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e062:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    e069:	e9 d4 00 00 00       	jmp    e142 <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    e06e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e075:	e9 b4 00 00 00       	jmp    e12e <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    e07a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e07d:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e084:	c1 e0 03             	shl    $0x3,%eax
    e087:	89 c1                	mov    %eax,%ecx
    e089:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e08c:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    e090:	89 c2                	mov    %eax,%edx
    e092:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e095:	0f af 45 18          	imul   0x18(%ebp),%eax
    e099:	01 d0                	add    %edx,%eax
    e09b:	01 c8                	add    %ecx,%eax
    e09d:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    e0a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0a6:	8b 14 85 98 a0 01 00 	mov    0x1a098(,%eax,4),%edx
    e0ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0b0:	8b 04 85 d0 a0 01 00 	mov    0x1a0d0(,%eax,4),%eax
    e0b7:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    e0bb:	01 d0                	add    %edx,%eax
    e0bd:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    e0c1:	89 c2                	mov    %eax,%edx
    e0c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0c6:	8b 0c 85 7c a0 01 00 	mov    0x1a07c(,%eax,4),%ecx
    e0cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0d0:	8b 04 85 b4 a0 01 00 	mov    0x1a0b4(,%eax,4),%eax
    e0d7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e0db:	01 c8                	add    %ecx,%eax
    e0dd:	0f af 45 18          	imul   0x18(%ebp),%eax
    e0e1:	01 d0                	add    %edx,%eax
    e0e3:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e0e9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e0f0:	eb 30                	jmp    e122 <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e0f2:	ff 75 0c             	pushl  0xc(%ebp)
    e0f5:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e0fb:	50                   	push   %eax
    e0fc:	e8 1e a1 ff ff       	call   821f <readBitFromReversedStream>
    e101:	83 c4 08             	add    $0x8,%esp
    e104:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e107:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e10b:	50                   	push   %eax
    e10c:	ff 75 08             	pushl  0x8(%ebp)
    e10f:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e115:	50                   	push   %eax
    e116:	e8 86 a1 ff ff       	call   82a1 <setBitOfReversedStream>
    e11b:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e11e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e122:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e125:	3b 45 18             	cmp    0x18(%ebp),%eax
    e128:	72 c8                	jb     e0f2 <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e12a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e12e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e131:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e135:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e138:	0f 87 3c ff ff ff    	ja     e07a <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e13e:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e142:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e145:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e149:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e14c:	0f 87 1c ff ff ff    	ja     e06e <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e152:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e156:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e15a:	0f 85 ea fe ff ff    	jne    e04a <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e160:	90                   	nop
    e161:	c9                   	leave  
    e162:	c3                   	ret    

0000e163 <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e163:	55                   	push   %ebp
    e164:	89 e5                	mov    %esp,%ebp
    e166:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e169:	8b 45 14             	mov    0x14(%ebp),%eax
    e16c:	2b 45 10             	sub    0x10(%ebp),%eax
    e16f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e172:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e179:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e180:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e187:	eb 4a                	jmp    e1d3 <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e189:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e190:	eb 2a                	jmp    e1bc <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e192:	ff 75 0c             	pushl  0xc(%ebp)
    e195:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e198:	50                   	push   %eax
    e199:	e8 81 a0 ff ff       	call   821f <readBitFromReversedStream>
    e19e:	83 c4 08             	add    $0x8,%esp
    e1a1:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e1a4:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e1a8:	50                   	push   %eax
    e1a9:	ff 75 08             	pushl  0x8(%ebp)
    e1ac:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e1af:	50                   	push   %eax
    e1b0:	e8 ec a0 ff ff       	call   82a1 <setBitOfReversedStream>
    e1b5:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e1b8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e1bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e1bf:	3b 45 10             	cmp    0x10(%ebp),%eax
    e1c2:	7c ce                	jl     e192 <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e1c4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e1c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1ca:	01 d0                	add    %edx,%eax
    e1cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e1cf:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e1d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e1d6:	3b 45 18             	cmp    0x18(%ebp),%eax
    e1d9:	72 ae                	jb     e189 <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e1db:	90                   	nop
    e1dc:	c9                   	leave  
    e1dd:	c3                   	ret    

0000e1de <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e1de:	55                   	push   %ebp
    e1df:	89 e5                	mov    %esp,%ebp
    e1e1:	57                   	push   %edi
    e1e2:	56                   	push   %esi
    e1e3:	53                   	push   %ebx
    e1e4:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e1ea:	8b 45 18             	mov    0x18(%ebp),%eax
    e1ed:	83 c0 0c             	add    $0xc,%eax
    e1f0:	50                   	push   %eax
    e1f1:	e8 e6 ac ff ff       	call   8edc <lodepng_get_bpp>
    e1f6:	83 c4 04             	add    $0x4,%esp
    e1f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e1fc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e200:	75 0a                	jne    e20c <postProcessScanlines+0x2e>
    e202:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e207:	e9 c3 01 00 00       	jmp    e3cf <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e20c:	8b 45 18             	mov    0x18(%ebp),%eax
    e20f:	8b 40 08             	mov    0x8(%eax),%eax
    e212:	85 c0                	test   %eax,%eax
    e214:	0f 85 a8 00 00 00    	jne    e2c2 <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e21a:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e21e:	77 76                	ja     e296 <postProcessScanlines+0xb8>
    e220:	8b 45 10             	mov    0x10(%ebp),%eax
    e223:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e227:	89 c2                	mov    %eax,%edx
    e229:	8b 45 10             	mov    0x10(%ebp),%eax
    e22c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e230:	83 c0 07             	add    $0x7,%eax
    e233:	c1 e8 03             	shr    $0x3,%eax
    e236:	c1 e0 03             	shl    $0x3,%eax
    e239:	39 c2                	cmp    %eax,%edx
    e23b:	74 59                	je     e296 <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e23d:	ff 75 ec             	pushl  -0x14(%ebp)
    e240:	ff 75 14             	pushl  0x14(%ebp)
    e243:	ff 75 10             	pushl  0x10(%ebp)
    e246:	ff 75 0c             	pushl  0xc(%ebp)
    e249:	ff 75 0c             	pushl  0xc(%ebp)
    e24c:	e8 ea fb ff ff       	call   de3b <unfilter>
    e251:	83 c4 14             	add    $0x14,%esp
    e254:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e257:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e25b:	74 08                	je     e265 <postProcessScanlines+0x87>
    e25d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e260:	e9 6a 01 00 00       	jmp    e3cf <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e265:	8b 45 10             	mov    0x10(%ebp),%eax
    e268:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e26c:	83 c0 07             	add    $0x7,%eax
    e26f:	c1 e8 03             	shr    $0x3,%eax
    e272:	c1 e0 03             	shl    $0x3,%eax
    e275:	89 c2                	mov    %eax,%edx
    e277:	8b 45 10             	mov    0x10(%ebp),%eax
    e27a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e27e:	ff 75 14             	pushl  0x14(%ebp)
    e281:	52                   	push   %edx
    e282:	50                   	push   %eax
    e283:	ff 75 0c             	pushl  0xc(%ebp)
    e286:	ff 75 08             	pushl  0x8(%ebp)
    e289:	e8 d5 fe ff ff       	call   e163 <removePaddingBits>
    e28e:	83 c4 14             	add    $0x14,%esp
    e291:	e9 34 01 00 00       	jmp    e3ca <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e296:	ff 75 ec             	pushl  -0x14(%ebp)
    e299:	ff 75 14             	pushl  0x14(%ebp)
    e29c:	ff 75 10             	pushl  0x10(%ebp)
    e29f:	ff 75 0c             	pushl  0xc(%ebp)
    e2a2:	ff 75 08             	pushl  0x8(%ebp)
    e2a5:	e8 91 fb ff ff       	call   de3b <unfilter>
    e2aa:	83 c4 14             	add    $0x14,%esp
    e2ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e2b0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e2b4:	0f 84 10 01 00 00    	je     e3ca <postProcessScanlines+0x1ec>
    e2ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e2bd:	e9 0d 01 00 00       	jmp    e3cf <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e2c2:	ff 75 ec             	pushl  -0x14(%ebp)
    e2c5:	ff 75 14             	pushl  0x14(%ebp)
    e2c8:	ff 75 10             	pushl  0x10(%ebp)
    e2cb:	8d 45 88             	lea    -0x78(%ebp),%eax
    e2ce:	50                   	push   %eax
    e2cf:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e2d5:	50                   	push   %eax
    e2d6:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e2dc:	50                   	push   %eax
    e2dd:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e2e0:	50                   	push   %eax
    e2e1:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e2e4:	50                   	push   %eax
    e2e5:	e8 23 ee ff ff       	call   d10d <Adam7_getpassvalues>
    e2ea:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e2ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e2f4:	e9 b0 00 00 00       	jmp    e3a9 <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e2f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e2fc:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e300:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e303:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e307:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e30a:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e311:	89 cb                	mov    %ecx,%ebx
    e313:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e316:	01 cb                	add    %ecx,%ebx
    e318:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e31b:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e322:	89 ce                	mov    %ecx,%esi
    e324:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e327:	01 f1                	add    %esi,%ecx
    e329:	ff 75 ec             	pushl  -0x14(%ebp)
    e32c:	52                   	push   %edx
    e32d:	50                   	push   %eax
    e32e:	53                   	push   %ebx
    e32f:	51                   	push   %ecx
    e330:	e8 06 fb ff ff       	call   de3b <unfilter>
    e335:	83 c4 14             	add    $0x14,%esp
    e338:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e33b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e33f:	74 08                	je     e349 <postProcessScanlines+0x16b>
    e341:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e344:	e9 86 00 00 00       	jmp    e3cf <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e349:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e34d:	77 56                	ja     e3a5 <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e34f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e352:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e356:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e359:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e35d:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e361:	83 c2 07             	add    $0x7,%edx
    e364:	c1 ea 03             	shr    $0x3,%edx
    e367:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e36a:	89 d6                	mov    %edx,%esi
    e36c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e36f:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e373:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e377:	89 d3                	mov    %edx,%ebx
    e379:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e37c:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    e383:	89 d1                	mov    %edx,%ecx
    e385:	8b 55 0c             	mov    0xc(%ebp),%edx
    e388:	01 d1                	add    %edx,%ecx
    e38a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e38d:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    e391:	89 d7                	mov    %edx,%edi
    e393:	8b 55 0c             	mov    0xc(%ebp),%edx
    e396:	01 fa                	add    %edi,%edx
    e398:	50                   	push   %eax
    e399:	56                   	push   %esi
    e39a:	53                   	push   %ebx
    e39b:	51                   	push   %ecx
    e39c:	52                   	push   %edx
    e39d:	e8 c1 fd ff ff       	call   e163 <removePaddingBits>
    e3a2:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    e3a5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e3a9:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    e3ad:	0f 85 46 ff ff ff    	jne    e2f9 <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    e3b3:	ff 75 ec             	pushl  -0x14(%ebp)
    e3b6:	ff 75 14             	pushl  0x14(%ebp)
    e3b9:	ff 75 10             	pushl  0x10(%ebp)
    e3bc:	ff 75 0c             	pushl  0xc(%ebp)
    e3bf:	ff 75 08             	pushl  0x8(%ebp)
    e3c2:	e8 2c fb ff ff       	call   def3 <Adam7_deinterlace>
    e3c7:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    e3ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e3cf:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e3d2:	5b                   	pop    %ebx
    e3d3:	5e                   	pop    %esi
    e3d4:	5f                   	pop    %edi
    e3d5:	5d                   	pop    %ebp
    e3d6:	c3                   	ret    

0000e3d7 <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e3d7:	55                   	push   %ebp
    e3d8:	89 e5                	mov    %esp,%ebp
    e3da:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    e3dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    e3e4:	8b 45 10             	mov    0x10(%ebp),%eax
    e3e7:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    e3ec:	f7 e2                	mul    %edx
    e3ee:	89 d0                	mov    %edx,%eax
    e3f0:	d1 e8                	shr    %eax
    e3f2:	89 c2                	mov    %eax,%edx
    e3f4:	8b 45 08             	mov    0x8(%ebp),%eax
    e3f7:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    e3fa:	8b 45 08             	mov    0x8(%ebp),%eax
    e3fd:	8b 40 0c             	mov    0xc(%eax),%eax
    e400:	85 c0                	test   %eax,%eax
    e402:	74 0d                	je     e411 <readChunk_PLTE+0x3a>
    e404:	8b 45 08             	mov    0x8(%ebp),%eax
    e407:	8b 40 0c             	mov    0xc(%eax),%eax
    e40a:	3d 00 01 00 00       	cmp    $0x100,%eax
    e40f:	7e 0a                	jle    e41b <readChunk_PLTE+0x44>
    e411:	b8 26 00 00 00       	mov    $0x26,%eax
    e416:	e9 da 00 00 00       	jmp    e4f5 <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    e41b:	83 ec 0c             	sub    $0xc,%esp
    e41e:	ff 75 08             	pushl  0x8(%ebp)
    e421:	e8 02 a7 ff ff       	call   8b28 <lodepng_color_mode_alloc_palette>
    e426:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    e429:	8b 45 08             	mov    0x8(%ebp),%eax
    e42c:	8b 40 08             	mov    0x8(%eax),%eax
    e42f:	85 c0                	test   %eax,%eax
    e431:	75 1e                	jne    e451 <readChunk_PLTE+0x7a>
    e433:	8b 45 08             	mov    0x8(%ebp),%eax
    e436:	8b 40 0c             	mov    0xc(%eax),%eax
    e439:	85 c0                	test   %eax,%eax
    e43b:	74 14                	je     e451 <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    e43d:	8b 45 08             	mov    0x8(%ebp),%eax
    e440:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    e447:	b8 53 00 00 00       	mov    $0x53,%eax
    e44c:	e9 a4 00 00 00       	jmp    e4f5 <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    e451:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e458:	e9 84 00 00 00       	jmp    e4e1 <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    e45d:	8b 45 08             	mov    0x8(%ebp),%eax
    e460:	8b 40 08             	mov    0x8(%eax),%eax
    e463:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e466:	c1 e2 02             	shl    $0x2,%edx
    e469:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e46c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e46f:	8d 50 01             	lea    0x1(%eax),%edx
    e472:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e475:	8b 55 0c             	mov    0xc(%ebp),%edx
    e478:	01 d0                	add    %edx,%eax
    e47a:	0f b6 00             	movzbl (%eax),%eax
    e47d:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    e47f:	8b 45 08             	mov    0x8(%ebp),%eax
    e482:	8b 40 08             	mov    0x8(%eax),%eax
    e485:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e488:	c1 e2 02             	shl    $0x2,%edx
    e48b:	83 c2 01             	add    $0x1,%edx
    e48e:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e491:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e494:	8d 50 01             	lea    0x1(%eax),%edx
    e497:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e49a:	8b 55 0c             	mov    0xc(%ebp),%edx
    e49d:	01 d0                	add    %edx,%eax
    e49f:	0f b6 00             	movzbl (%eax),%eax
    e4a2:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    e4a4:	8b 45 08             	mov    0x8(%ebp),%eax
    e4a7:	8b 40 08             	mov    0x8(%eax),%eax
    e4aa:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e4ad:	c1 e2 02             	shl    $0x2,%edx
    e4b0:	83 c2 02             	add    $0x2,%edx
    e4b3:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e4b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e4b9:	8d 50 01             	lea    0x1(%eax),%edx
    e4bc:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e4bf:	8b 55 0c             	mov    0xc(%ebp),%edx
    e4c2:	01 d0                	add    %edx,%eax
    e4c4:	0f b6 00             	movzbl (%eax),%eax
    e4c7:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    e4c9:	8b 45 08             	mov    0x8(%ebp),%eax
    e4cc:	8b 40 08             	mov    0x8(%eax),%eax
    e4cf:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e4d2:	c1 e2 02             	shl    $0x2,%edx
    e4d5:	83 c2 03             	add    $0x3,%edx
    e4d8:	01 d0                	add    %edx,%eax
    e4da:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    e4dd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e4e1:	8b 45 08             	mov    0x8(%ebp),%eax
    e4e4:	8b 40 0c             	mov    0xc(%eax),%eax
    e4e7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e4ea:	0f 85 6d ff ff ff    	jne    e45d <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    e4f0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e4f5:	c9                   	leave  
    e4f6:	c3                   	ret    

0000e4f7 <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e4f7:	55                   	push   %ebp
    e4f8:	89 e5                	mov    %esp,%ebp
    e4fa:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    e4fd:	8b 45 08             	mov    0x8(%ebp),%eax
    e500:	8b 00                	mov    (%eax),%eax
    e502:	83 f8 03             	cmp    $0x3,%eax
    e505:	75 4d                	jne    e554 <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    e507:	8b 45 08             	mov    0x8(%ebp),%eax
    e50a:	8b 40 0c             	mov    0xc(%eax),%eax
    e50d:	3b 45 10             	cmp    0x10(%ebp),%eax
    e510:	7d 0a                	jge    e51c <readChunk_tRNS+0x25>
    e512:	b8 27 00 00 00       	mov    $0x27,%eax
    e517:	e9 3c 01 00 00       	jmp    e658 <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    e51c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e523:	eb 22                	jmp    e547 <readChunk_tRNS+0x50>
    e525:	8b 45 08             	mov    0x8(%ebp),%eax
    e528:	8b 40 08             	mov    0x8(%eax),%eax
    e52b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e52e:	c1 e2 02             	shl    $0x2,%edx
    e531:	83 c2 03             	add    $0x3,%edx
    e534:	01 c2                	add    %eax,%edx
    e536:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e539:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e53c:	01 c8                	add    %ecx,%eax
    e53e:	0f b6 00             	movzbl (%eax),%eax
    e541:	88 02                	mov    %al,(%edx)
    e543:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e547:	8b 45 10             	mov    0x10(%ebp),%eax
    e54a:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    e54d:	75 d6                	jne    e525 <readChunk_tRNS+0x2e>
    e54f:	e9 ff 00 00 00       	jmp    e653 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    e554:	8b 45 08             	mov    0x8(%ebp),%eax
    e557:	8b 00                	mov    (%eax),%eax
    e559:	85 c0                	test   %eax,%eax
    e55b:	75 59                	jne    e5b6 <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    e55d:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e561:	74 0a                	je     e56d <readChunk_tRNS+0x76>
    e563:	b8 1e 00 00 00       	mov    $0x1e,%eax
    e568:	e9 eb 00 00 00       	jmp    e658 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e56d:	8b 45 08             	mov    0x8(%ebp),%eax
    e570:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    e577:	8b 45 0c             	mov    0xc(%ebp),%eax
    e57a:	0f b6 00             	movzbl (%eax),%eax
    e57d:	0f b6 c0             	movzbl %al,%eax
    e580:	c1 e0 08             	shl    $0x8,%eax
    e583:	89 c2                	mov    %eax,%edx
    e585:	8b 45 0c             	mov    0xc(%ebp),%eax
    e588:	83 c0 01             	add    $0x1,%eax
    e58b:	0f b6 00             	movzbl (%eax),%eax
    e58e:	0f b6 c0             	movzbl %al,%eax
    e591:	01 c2                	add    %eax,%edx
    e593:	8b 45 08             	mov    0x8(%ebp),%eax
    e596:	89 50 1c             	mov    %edx,0x1c(%eax)
    e599:	8b 45 08             	mov    0x8(%ebp),%eax
    e59c:	8b 50 1c             	mov    0x1c(%eax),%edx
    e59f:	8b 45 08             	mov    0x8(%ebp),%eax
    e5a2:	89 50 18             	mov    %edx,0x18(%eax)
    e5a5:	8b 45 08             	mov    0x8(%ebp),%eax
    e5a8:	8b 50 18             	mov    0x18(%eax),%edx
    e5ab:	8b 45 08             	mov    0x8(%ebp),%eax
    e5ae:	89 50 14             	mov    %edx,0x14(%eax)
    e5b1:	e9 9d 00 00 00       	jmp    e653 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    e5b6:	8b 45 08             	mov    0x8(%ebp),%eax
    e5b9:	8b 00                	mov    (%eax),%eax
    e5bb:	83 f8 02             	cmp    $0x2,%eax
    e5be:	0f 85 88 00 00 00    	jne    e64c <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    e5c4:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e5c8:	74 0a                	je     e5d4 <readChunk_tRNS+0xdd>
    e5ca:	b8 29 00 00 00       	mov    $0x29,%eax
    e5cf:	e9 84 00 00 00       	jmp    e658 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e5d4:	8b 45 08             	mov    0x8(%ebp),%eax
    e5d7:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    e5de:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5e1:	0f b6 00             	movzbl (%eax),%eax
    e5e4:	0f b6 c0             	movzbl %al,%eax
    e5e7:	c1 e0 08             	shl    $0x8,%eax
    e5ea:	89 c2                	mov    %eax,%edx
    e5ec:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5ef:	83 c0 01             	add    $0x1,%eax
    e5f2:	0f b6 00             	movzbl (%eax),%eax
    e5f5:	0f b6 c0             	movzbl %al,%eax
    e5f8:	01 c2                	add    %eax,%edx
    e5fa:	8b 45 08             	mov    0x8(%ebp),%eax
    e5fd:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    e600:	8b 45 0c             	mov    0xc(%ebp),%eax
    e603:	83 c0 02             	add    $0x2,%eax
    e606:	0f b6 00             	movzbl (%eax),%eax
    e609:	0f b6 c0             	movzbl %al,%eax
    e60c:	c1 e0 08             	shl    $0x8,%eax
    e60f:	89 c2                	mov    %eax,%edx
    e611:	8b 45 0c             	mov    0xc(%ebp),%eax
    e614:	83 c0 03             	add    $0x3,%eax
    e617:	0f b6 00             	movzbl (%eax),%eax
    e61a:	0f b6 c0             	movzbl %al,%eax
    e61d:	01 c2                	add    %eax,%edx
    e61f:	8b 45 08             	mov    0x8(%ebp),%eax
    e622:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    e625:	8b 45 0c             	mov    0xc(%ebp),%eax
    e628:	83 c0 04             	add    $0x4,%eax
    e62b:	0f b6 00             	movzbl (%eax),%eax
    e62e:	0f b6 c0             	movzbl %al,%eax
    e631:	c1 e0 08             	shl    $0x8,%eax
    e634:	89 c2                	mov    %eax,%edx
    e636:	8b 45 0c             	mov    0xc(%ebp),%eax
    e639:	83 c0 05             	add    $0x5,%eax
    e63c:	0f b6 00             	movzbl (%eax),%eax
    e63f:	0f b6 c0             	movzbl %al,%eax
    e642:	01 c2                	add    %eax,%edx
    e644:	8b 45 08             	mov    0x8(%ebp),%eax
    e647:	89 50 1c             	mov    %edx,0x1c(%eax)
    e64a:	eb 07                	jmp    e653 <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    e64c:	b8 2a 00 00 00       	mov    $0x2a,%eax
    e651:	eb 05                	jmp    e658 <readChunk_tRNS+0x161>

  return 0; /* OK */
    e653:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e658:	c9                   	leave  
    e659:	c3                   	ret    

0000e65a <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e65a:	55                   	push   %ebp
    e65b:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    e65d:	8b 45 08             	mov    0x8(%ebp),%eax
    e660:	8b 40 0c             	mov    0xc(%eax),%eax
    e663:	83 f8 03             	cmp    $0x3,%eax
    e666:	75 63                	jne    e6cb <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    e668:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    e66c:	74 0a                	je     e678 <readChunk_bKGD+0x1e>
    e66e:	b8 2b 00 00 00       	mov    $0x2b,%eax
    e673:	e9 63 01 00 00       	jmp    e7db <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    e678:	8b 45 0c             	mov    0xc(%ebp),%eax
    e67b:	0f b6 00             	movzbl (%eax),%eax
    e67e:	0f b6 d0             	movzbl %al,%edx
    e681:	8b 45 08             	mov    0x8(%ebp),%eax
    e684:	8b 40 18             	mov    0x18(%eax),%eax
    e687:	39 c2                	cmp    %eax,%edx
    e689:	7c 0a                	jl     e695 <readChunk_bKGD+0x3b>
    e68b:	b8 67 00 00 00       	mov    $0x67,%eax
    e690:	e9 46 01 00 00       	jmp    e7db <readChunk_bKGD+0x181>

    info->background_defined = 1;
    e695:	8b 45 08             	mov    0x8(%ebp),%eax
    e698:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    e69f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6a2:	0f b6 00             	movzbl (%eax),%eax
    e6a5:	0f b6 d0             	movzbl %al,%edx
    e6a8:	8b 45 08             	mov    0x8(%ebp),%eax
    e6ab:	89 50 38             	mov    %edx,0x38(%eax)
    e6ae:	8b 45 08             	mov    0x8(%ebp),%eax
    e6b1:	8b 50 38             	mov    0x38(%eax),%edx
    e6b4:	8b 45 08             	mov    0x8(%ebp),%eax
    e6b7:	89 50 34             	mov    %edx,0x34(%eax)
    e6ba:	8b 45 08             	mov    0x8(%ebp),%eax
    e6bd:	8b 50 34             	mov    0x34(%eax),%edx
    e6c0:	8b 45 08             	mov    0x8(%ebp),%eax
    e6c3:	89 50 30             	mov    %edx,0x30(%eax)
    e6c6:	e9 0b 01 00 00       	jmp    e7d6 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    e6cb:	8b 45 08             	mov    0x8(%ebp),%eax
    e6ce:	8b 40 0c             	mov    0xc(%eax),%eax
    e6d1:	85 c0                	test   %eax,%eax
    e6d3:	74 0b                	je     e6e0 <readChunk_bKGD+0x86>
    e6d5:	8b 45 08             	mov    0x8(%ebp),%eax
    e6d8:	8b 40 0c             	mov    0xc(%eax),%eax
    e6db:	83 f8 04             	cmp    $0x4,%eax
    e6de:	75 59                	jne    e739 <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    e6e0:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e6e4:	74 0a                	je     e6f0 <readChunk_bKGD+0x96>
    e6e6:	b8 2c 00 00 00       	mov    $0x2c,%eax
    e6eb:	e9 eb 00 00 00       	jmp    e7db <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e6f0:	8b 45 08             	mov    0x8(%ebp),%eax
    e6f3:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    e6fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6fd:	0f b6 00             	movzbl (%eax),%eax
    e700:	0f b6 c0             	movzbl %al,%eax
    e703:	c1 e0 08             	shl    $0x8,%eax
    e706:	89 c2                	mov    %eax,%edx
    e708:	8b 45 0c             	mov    0xc(%ebp),%eax
    e70b:	83 c0 01             	add    $0x1,%eax
    e70e:	0f b6 00             	movzbl (%eax),%eax
    e711:	0f b6 c0             	movzbl %al,%eax
    e714:	01 c2                	add    %eax,%edx
    e716:	8b 45 08             	mov    0x8(%ebp),%eax
    e719:	89 50 38             	mov    %edx,0x38(%eax)
    e71c:	8b 45 08             	mov    0x8(%ebp),%eax
    e71f:	8b 50 38             	mov    0x38(%eax),%edx
    e722:	8b 45 08             	mov    0x8(%ebp),%eax
    e725:	89 50 34             	mov    %edx,0x34(%eax)
    e728:	8b 45 08             	mov    0x8(%ebp),%eax
    e72b:	8b 50 34             	mov    0x34(%eax),%edx
    e72e:	8b 45 08             	mov    0x8(%ebp),%eax
    e731:	89 50 30             	mov    %edx,0x30(%eax)
    e734:	e9 9d 00 00 00       	jmp    e7d6 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    e739:	8b 45 08             	mov    0x8(%ebp),%eax
    e73c:	8b 40 0c             	mov    0xc(%eax),%eax
    e73f:	83 f8 02             	cmp    $0x2,%eax
    e742:	74 0f                	je     e753 <readChunk_bKGD+0xf9>
    e744:	8b 45 08             	mov    0x8(%ebp),%eax
    e747:	8b 40 0c             	mov    0xc(%eax),%eax
    e74a:	83 f8 06             	cmp    $0x6,%eax
    e74d:	0f 85 83 00 00 00    	jne    e7d6 <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    e753:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e757:	74 07                	je     e760 <readChunk_bKGD+0x106>
    e759:	b8 2d 00 00 00       	mov    $0x2d,%eax
    e75e:	eb 7b                	jmp    e7db <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e760:	8b 45 08             	mov    0x8(%ebp),%eax
    e763:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    e76a:	8b 45 0c             	mov    0xc(%ebp),%eax
    e76d:	0f b6 00             	movzbl (%eax),%eax
    e770:	0f b6 c0             	movzbl %al,%eax
    e773:	c1 e0 08             	shl    $0x8,%eax
    e776:	89 c2                	mov    %eax,%edx
    e778:	8b 45 0c             	mov    0xc(%ebp),%eax
    e77b:	83 c0 01             	add    $0x1,%eax
    e77e:	0f b6 00             	movzbl (%eax),%eax
    e781:	0f b6 c0             	movzbl %al,%eax
    e784:	01 c2                	add    %eax,%edx
    e786:	8b 45 08             	mov    0x8(%ebp),%eax
    e789:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    e78c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e78f:	83 c0 02             	add    $0x2,%eax
    e792:	0f b6 00             	movzbl (%eax),%eax
    e795:	0f b6 c0             	movzbl %al,%eax
    e798:	c1 e0 08             	shl    $0x8,%eax
    e79b:	89 c2                	mov    %eax,%edx
    e79d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7a0:	83 c0 03             	add    $0x3,%eax
    e7a3:	0f b6 00             	movzbl (%eax),%eax
    e7a6:	0f b6 c0             	movzbl %al,%eax
    e7a9:	01 c2                	add    %eax,%edx
    e7ab:	8b 45 08             	mov    0x8(%ebp),%eax
    e7ae:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    e7b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7b4:	83 c0 04             	add    $0x4,%eax
    e7b7:	0f b6 00             	movzbl (%eax),%eax
    e7ba:	0f b6 c0             	movzbl %al,%eax
    e7bd:	c1 e0 08             	shl    $0x8,%eax
    e7c0:	89 c2                	mov    %eax,%edx
    e7c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7c5:	83 c0 05             	add    $0x5,%eax
    e7c8:	0f b6 00             	movzbl (%eax),%eax
    e7cb:	0f b6 c0             	movzbl %al,%eax
    e7ce:	01 c2                	add    %eax,%edx
    e7d0:	8b 45 08             	mov    0x8(%ebp),%eax
    e7d3:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    e7d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e7db:	5d                   	pop    %ebp
    e7dc:	c3                   	ret    

0000e7dd <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e7dd:	55                   	push   %ebp
    e7de:	89 e5                	mov    %esp,%ebp
    e7e0:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    e7e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    e7ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e7f1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e7f8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e7fc:	0f 85 06 01 00 00    	jne    e908 <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    e802:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    e809:	eb 04                	jmp    e80f <readChunk_tEXt+0x32>
    e80b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e80f:	8b 45 10             	mov    0x10(%ebp),%eax
    e812:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e815:	73 0f                	jae    e826 <readChunk_tEXt+0x49>
    e817:	8b 55 0c             	mov    0xc(%ebp),%edx
    e81a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e81d:	01 d0                	add    %edx,%eax
    e81f:	0f b6 00             	movzbl (%eax),%eax
    e822:	84 c0                	test   %al,%al
    e824:	75 e5                	jne    e80b <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e826:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e82a:	74 06                	je     e832 <readChunk_tEXt+0x55>
    e82c:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    e830:	76 0c                	jbe    e83e <readChunk_tEXt+0x61>
    e832:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e839:	e9 ca 00 00 00       	jmp    e908 <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    e83e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e841:	83 c0 01             	add    $0x1,%eax
    e844:	83 ec 0c             	sub    $0xc,%esp
    e847:	50                   	push   %eax
    e848:	e8 73 4b ff ff       	call   33c0 <lodepng_malloc>
    e84d:	83 c4 10             	add    $0x10,%esp
    e850:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e853:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e857:	75 0c                	jne    e865 <readChunk_tEXt+0x88>
    e859:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e860:	e9 a3 00 00 00       	jmp    e908 <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    e865:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e868:	83 ec 04             	sub    $0x4,%esp
    e86b:	50                   	push   %eax
    e86c:	ff 75 0c             	pushl  0xc(%ebp)
    e86f:	ff 75 f0             	pushl  -0x10(%ebp)
    e872:	e8 87 4b ff ff       	call   33fe <lodepng_memcpy>
    e877:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e87a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e87d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e880:	01 d0                	add    %edx,%eax
    e882:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    e885:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e888:	83 c0 01             	add    $0x1,%eax
    e88b:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    e88e:	8b 45 10             	mov    0x10(%ebp),%eax
    e891:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    e894:	72 08                	jb     e89e <readChunk_tEXt+0xc1>
    e896:	8b 45 10             	mov    0x10(%ebp),%eax
    e899:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    e89c:	eb 05                	jmp    e8a3 <readChunk_tEXt+0xc6>
    e89e:	b8 00 00 00 00       	mov    $0x0,%eax
    e8a3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    e8a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e8a9:	83 c0 01             	add    $0x1,%eax
    e8ac:	83 ec 0c             	sub    $0xc,%esp
    e8af:	50                   	push   %eax
    e8b0:	e8 0b 4b ff ff       	call   33c0 <lodepng_malloc>
    e8b5:	83 c4 10             	add    $0x10,%esp
    e8b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    e8bb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e8bf:	75 09                	jne    e8ca <readChunk_tEXt+0xed>
    e8c1:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e8c8:	eb 3e                	jmp    e908 <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    e8ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e8cd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e8d0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e8d3:	01 ca                	add    %ecx,%edx
    e8d5:	83 ec 04             	sub    $0x4,%esp
    e8d8:	50                   	push   %eax
    e8d9:	52                   	push   %edx
    e8da:	ff 75 ec             	pushl  -0x14(%ebp)
    e8dd:	e8 1c 4b ff ff       	call   33fe <lodepng_memcpy>
    e8e2:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    e8e5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e8e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e8eb:	01 d0                	add    %edx,%eax
    e8ed:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    e8f0:	83 ec 04             	sub    $0x4,%esp
    e8f3:	ff 75 ec             	pushl  -0x14(%ebp)
    e8f6:	ff 75 f0             	pushl  -0x10(%ebp)
    e8f9:	ff 75 08             	pushl  0x8(%ebp)
    e8fc:	e8 3f ac ff ff       	call   9540 <lodepng_add_text>
    e901:	83 c4 10             	add    $0x10,%esp
    e904:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    e907:	90                   	nop
  }

  lodepng_free(key);
    e908:	83 ec 0c             	sub    $0xc,%esp
    e90b:	ff 75 f0             	pushl  -0x10(%ebp)
    e90e:	e8 ce 4a ff ff       	call   33e1 <lodepng_free>
    e913:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    e916:	83 ec 0c             	sub    $0xc,%esp
    e919:	ff 75 ec             	pushl  -0x14(%ebp)
    e91c:	e8 c0 4a ff ff       	call   33e1 <lodepng_free>
    e921:	83 c4 10             	add    $0x10,%esp

  return error;
    e924:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e927:	c9                   	leave  
    e928:	c3                   	ret    

0000e929 <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    e929:	55                   	push   %ebp
    e92a:	89 e5                	mov    %esp,%ebp
    e92c:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    e92f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    e936:	8b 45 0c             	mov    0xc(%ebp),%eax
    e939:	8b 10                	mov    (%eax),%edx
    e93b:	89 55 d0             	mov    %edx,-0x30(%ebp)
    e93e:	8b 50 04             	mov    0x4(%eax),%edx
    e941:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    e944:	8b 50 08             	mov    0x8(%eax),%edx
    e947:	89 55 d8             	mov    %edx,-0x28(%ebp)
    e94a:	8b 50 0c             	mov    0xc(%eax),%edx
    e94d:	89 55 dc             	mov    %edx,-0x24(%ebp)
    e950:	8b 50 10             	mov    0x10(%eax),%edx
    e953:	89 55 e0             	mov    %edx,-0x20(%ebp)
    e956:	8b 40 14             	mov    0x14(%eax),%eax
    e959:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    e95c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    e963:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    e96a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e971:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e975:	0f 85 48 01 00 00    	jne    eac3 <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    e97b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e982:	eb 04                	jmp    e988 <readChunk_zTXt+0x5f>
    e984:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e988:	8b 45 14             	mov    0x14(%ebp),%eax
    e98b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e98e:	73 0f                	jae    e99f <readChunk_zTXt+0x76>
    e990:	8b 55 10             	mov    0x10(%ebp),%edx
    e993:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e996:	01 d0                	add    %edx,%eax
    e998:	0f b6 00             	movzbl (%eax),%eax
    e99b:	84 c0                	test   %al,%al
    e99d:	75 e5                	jne    e984 <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    e99f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9a2:	8d 50 02             	lea    0x2(%eax),%edx
    e9a5:	8b 45 14             	mov    0x14(%ebp),%eax
    e9a8:	39 c2                	cmp    %eax,%edx
    e9aa:	72 0c                	jb     e9b8 <readChunk_zTXt+0x8f>
    e9ac:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    e9b3:	e9 0b 01 00 00       	jmp    eac3 <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e9b8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e9bc:	74 06                	je     e9c4 <readChunk_zTXt+0x9b>
    e9be:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    e9c2:	76 0c                	jbe    e9d0 <readChunk_zTXt+0xa7>
    e9c4:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e9cb:	e9 f3 00 00 00       	jmp    eac3 <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    e9d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9d3:	83 c0 01             	add    $0x1,%eax
    e9d6:	83 ec 0c             	sub    $0xc,%esp
    e9d9:	50                   	push   %eax
    e9da:	e8 e1 49 ff ff       	call   33c0 <lodepng_malloc>
    e9df:	83 c4 10             	add    $0x10,%esp
    e9e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e9e5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e9e9:	75 0c                	jne    e9f7 <readChunk_zTXt+0xce>
    e9eb:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e9f2:	e9 cc 00 00 00       	jmp    eac3 <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    e9f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9fa:	83 ec 04             	sub    $0x4,%esp
    e9fd:	50                   	push   %eax
    e9fe:	ff 75 10             	pushl  0x10(%ebp)
    ea01:	ff 75 ec             	pushl  -0x14(%ebp)
    ea04:	e8 f5 49 ff ff       	call   33fe <lodepng_memcpy>
    ea09:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    ea0c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ea0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea12:	01 d0                	add    %edx,%eax
    ea14:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    ea17:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea1a:	8d 50 01             	lea    0x1(%eax),%edx
    ea1d:	8b 45 10             	mov    0x10(%ebp),%eax
    ea20:	01 d0                	add    %edx,%eax
    ea22:	0f b6 00             	movzbl (%eax),%eax
    ea25:	84 c0                	test   %al,%al
    ea27:	74 0c                	je     ea35 <readChunk_zTXt+0x10c>
    ea29:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ea30:	e9 8e 00 00 00       	jmp    eac3 <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    ea35:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea38:	83 c0 02             	add    $0x2,%eax
    ea3b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    ea3e:	8b 45 14             	mov    0x14(%ebp),%eax
    ea41:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    ea44:	76 09                	jbe    ea4f <readChunk_zTXt+0x126>
    ea46:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ea4d:	eb 74                	jmp    eac3 <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    ea4f:	8b 45 14             	mov    0x14(%ebp),%eax
    ea52:	2b 45 e8             	sub    -0x18(%ebp),%eax
    ea55:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    ea58:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea5b:	8b 40 30             	mov    0x30(%eax),%eax
    ea5e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    ea61:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea64:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ea67:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ea6a:	01 d1                	add    %edx,%ecx
    ea6c:	83 ec 08             	sub    $0x8,%esp
    ea6f:	8d 55 d0             	lea    -0x30(%ebp),%edx
    ea72:	52                   	push   %edx
    ea73:	50                   	push   %eax
    ea74:	51                   	push   %ecx
    ea75:	6a 00                	push   $0x0
    ea77:	8d 45 c8             	lea    -0x38(%ebp),%eax
    ea7a:	50                   	push   %eax
    ea7b:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ea7e:	50                   	push   %eax
    ea7f:	e8 f7 93 ff ff       	call   7e7b <zlib_decompress>
    ea84:	83 c4 20             	add    $0x20,%esp
    ea87:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    ea8a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea8e:	74 11                	je     eaa1 <readChunk_zTXt+0x178>
    ea90:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ea93:	8b 45 c8             	mov    -0x38(%ebp),%eax
    ea96:	39 c2                	cmp    %eax,%edx
    ea98:	7d 07                	jge    eaa1 <readChunk_zTXt+0x178>
    ea9a:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    eaa1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eaa5:	75 1b                	jne    eac2 <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    eaa7:	8b 55 c8             	mov    -0x38(%ebp),%edx
    eaaa:	8b 45 cc             	mov    -0x34(%ebp),%eax
    eaad:	52                   	push   %edx
    eaae:	50                   	push   %eax
    eaaf:	ff 75 ec             	pushl  -0x14(%ebp)
    eab2:	ff 75 08             	pushl  0x8(%ebp)
    eab5:	e8 60 a9 ff ff       	call   941a <lodepng_add_text_sized>
    eaba:	83 c4 10             	add    $0x10,%esp
    eabd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    eac0:	eb 01                	jmp    eac3 <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    eac2:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    eac3:	83 ec 0c             	sub    $0xc,%esp
    eac6:	ff 75 ec             	pushl  -0x14(%ebp)
    eac9:	e8 13 49 ff ff       	call   33e1 <lodepng_free>
    eace:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    ead1:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ead4:	83 ec 0c             	sub    $0xc,%esp
    ead7:	50                   	push   %eax
    ead8:	e8 04 49 ff ff       	call   33e1 <lodepng_free>
    eadd:	83 c4 10             	add    $0x10,%esp

  return error;
    eae0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    eae3:	c9                   	leave  
    eae4:	c3                   	ret    

0000eae5 <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    eae5:	55                   	push   %ebp
    eae6:	89 e5                	mov    %esp,%ebp
    eae8:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    eaeb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    eaf2:	8b 45 0c             	mov    0xc(%ebp),%eax
    eaf5:	8b 10                	mov    (%eax),%edx
    eaf7:	89 55 c0             	mov    %edx,-0x40(%ebp)
    eafa:	8b 50 04             	mov    0x4(%eax),%edx
    eafd:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    eb00:	8b 50 08             	mov    0x8(%eax),%edx
    eb03:	89 55 c8             	mov    %edx,-0x38(%ebp)
    eb06:	8b 50 0c             	mov    0xc(%eax),%edx
    eb09:	89 55 cc             	mov    %edx,-0x34(%ebp)
    eb0c:	8b 50 10             	mov    0x10(%eax),%edx
    eb0f:	89 55 d0             	mov    %edx,-0x30(%ebp)
    eb12:	8b 40 14             	mov    0x14(%eax),%eax
    eb15:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    eb18:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    eb1f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    eb26:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    eb2d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eb31:	0f 85 d5 02 00 00    	jne    ee0c <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    eb37:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    eb3b:	7f 0c                	jg     eb49 <readChunk_iTXt+0x64>
    eb3d:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    eb44:	e9 c3 02 00 00       	jmp    ee0c <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    eb49:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    eb50:	eb 04                	jmp    eb56 <readChunk_iTXt+0x71>
    eb52:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    eb56:	8b 45 14             	mov    0x14(%ebp),%eax
    eb59:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    eb5c:	73 0f                	jae    eb6d <readChunk_iTXt+0x88>
    eb5e:	8b 55 10             	mov    0x10(%ebp),%edx
    eb61:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb64:	01 d0                	add    %edx,%eax
    eb66:	0f b6 00             	movzbl (%eax),%eax
    eb69:	84 c0                	test   %al,%al
    eb6b:	75 e5                	jne    eb52 <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    eb6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb70:	8d 50 03             	lea    0x3(%eax),%edx
    eb73:	8b 45 14             	mov    0x14(%ebp),%eax
    eb76:	39 c2                	cmp    %eax,%edx
    eb78:	72 0c                	jb     eb86 <readChunk_iTXt+0xa1>
    eb7a:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    eb81:	e9 86 02 00 00       	jmp    ee0c <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    eb86:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    eb8a:	74 06                	je     eb92 <readChunk_iTXt+0xad>
    eb8c:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    eb90:	76 0c                	jbe    eb9e <readChunk_iTXt+0xb9>
    eb92:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    eb99:	e9 6e 02 00 00       	jmp    ee0c <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    eb9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eba1:	83 c0 01             	add    $0x1,%eax
    eba4:	83 ec 0c             	sub    $0xc,%esp
    eba7:	50                   	push   %eax
    eba8:	e8 13 48 ff ff       	call   33c0 <lodepng_malloc>
    ebad:	83 c4 10             	add    $0x10,%esp
    ebb0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    ebb3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ebb7:	75 0c                	jne    ebc5 <readChunk_iTXt+0xe0>
    ebb9:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ebc0:	e9 47 02 00 00       	jmp    ee0c <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    ebc5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebc8:	83 ec 04             	sub    $0x4,%esp
    ebcb:	50                   	push   %eax
    ebcc:	ff 75 10             	pushl  0x10(%ebp)
    ebcf:	ff 75 e8             	pushl  -0x18(%ebp)
    ebd2:	e8 27 48 ff ff       	call   33fe <lodepng_memcpy>
    ebd7:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    ebda:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ebdd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebe0:	01 d0                	add    %edx,%eax
    ebe2:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    ebe5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebe8:	8d 50 01             	lea    0x1(%eax),%edx
    ebeb:	8b 45 10             	mov    0x10(%ebp),%eax
    ebee:	01 d0                	add    %edx,%eax
    ebf0:	0f b6 00             	movzbl (%eax),%eax
    ebf3:	0f b6 c0             	movzbl %al,%eax
    ebf6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    ebf9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebfc:	8d 50 02             	lea    0x2(%eax),%edx
    ebff:	8b 45 10             	mov    0x10(%ebp),%eax
    ec02:	01 d0                	add    %edx,%eax
    ec04:	0f b6 00             	movzbl (%eax),%eax
    ec07:	84 c0                	test   %al,%al
    ec09:	74 0c                	je     ec17 <readChunk_iTXt+0x132>
    ec0b:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ec12:	e9 f5 01 00 00       	jmp    ee0c <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    ec17:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec1a:	83 c0 03             	add    $0x3,%eax
    ec1d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ec20:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ec27:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec2a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ec2d:	eb 08                	jmp    ec37 <readChunk_iTXt+0x152>
    ec2f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ec33:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ec37:	8b 45 14             	mov    0x14(%ebp),%eax
    ec3a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ec3d:	73 0f                	jae    ec4e <readChunk_iTXt+0x169>
    ec3f:	8b 55 10             	mov    0x10(%ebp),%edx
    ec42:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec45:	01 d0                	add    %edx,%eax
    ec47:	0f b6 00             	movzbl (%eax),%eax
    ec4a:	84 c0                	test   %al,%al
    ec4c:	75 e1                	jne    ec2f <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    ec4e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec51:	83 c0 01             	add    $0x1,%eax
    ec54:	83 ec 0c             	sub    $0xc,%esp
    ec57:	50                   	push   %eax
    ec58:	e8 63 47 ff ff       	call   33c0 <lodepng_malloc>
    ec5d:	83 c4 10             	add    $0x10,%esp
    ec60:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    ec63:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ec67:	75 0c                	jne    ec75 <readChunk_iTXt+0x190>
    ec69:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ec70:	e9 97 01 00 00       	jmp    ee0c <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    ec75:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec78:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ec7b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ec7e:	01 ca                	add    %ecx,%edx
    ec80:	83 ec 04             	sub    $0x4,%esp
    ec83:	50                   	push   %eax
    ec84:	52                   	push   %edx
    ec85:	ff 75 e4             	pushl  -0x1c(%ebp)
    ec88:	e8 71 47 ff ff       	call   33fe <lodepng_memcpy>
    ec8d:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    ec90:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ec93:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec96:	01 d0                	add    %edx,%eax
    ec98:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    ec9b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec9e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    eca1:	01 d0                	add    %edx,%eax
    eca3:	83 c0 01             	add    $0x1,%eax
    eca6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    eca9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ecb0:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ecb3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ecb6:	eb 08                	jmp    ecc0 <readChunk_iTXt+0x1db>
    ecb8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ecbc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ecc0:	8b 45 14             	mov    0x14(%ebp),%eax
    ecc3:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ecc6:	73 0f                	jae    ecd7 <readChunk_iTXt+0x1f2>
    ecc8:	8b 55 10             	mov    0x10(%ebp),%edx
    eccb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ecce:	01 d0                	add    %edx,%eax
    ecd0:	0f b6 00             	movzbl (%eax),%eax
    ecd3:	84 c0                	test   %al,%al
    ecd5:	75 e1                	jne    ecb8 <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    ecd7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ecda:	83 c0 01             	add    $0x1,%eax
    ecdd:	83 ec 0c             	sub    $0xc,%esp
    ece0:	50                   	push   %eax
    ece1:	e8 da 46 ff ff       	call   33c0 <lodepng_malloc>
    ece6:	83 c4 10             	add    $0x10,%esp
    ece9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    ecec:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ecf0:	75 0c                	jne    ecfe <readChunk_iTXt+0x219>
    ecf2:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ecf9:	e9 0e 01 00 00       	jmp    ee0c <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    ecfe:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed01:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ed04:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ed07:	01 ca                	add    %ecx,%edx
    ed09:	83 ec 04             	sub    $0x4,%esp
    ed0c:	50                   	push   %eax
    ed0d:	52                   	push   %edx
    ed0e:	ff 75 e0             	pushl  -0x20(%ebp)
    ed11:	e8 e8 46 ff ff       	call   33fe <lodepng_memcpy>
    ed16:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    ed19:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ed1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed1f:	01 d0                	add    %edx,%eax
    ed21:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    ed24:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ed27:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ed2a:	01 d0                	add    %edx,%eax
    ed2c:	83 c0 01             	add    $0x1,%eax
    ed2f:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    ed32:	8b 45 14             	mov    0x14(%ebp),%eax
    ed35:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ed38:	72 08                	jb     ed42 <readChunk_iTXt+0x25d>
    ed3a:	8b 45 14             	mov    0x14(%ebp),%eax
    ed3d:	2b 45 d8             	sub    -0x28(%ebp),%eax
    ed40:	eb 05                	jmp    ed47 <readChunk_iTXt+0x262>
    ed42:	b8 00 00 00 00       	mov    $0x0,%eax
    ed47:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    ed4a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    ed4e:	0f 84 90 00 00 00    	je     ede4 <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    ed54:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    ed5b:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    ed62:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed65:	8b 40 30             	mov    0x30(%eax),%eax
    ed68:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    ed6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed6e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ed71:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ed74:	01 d1                	add    %edx,%ecx
    ed76:	83 ec 08             	sub    $0x8,%esp
    ed79:	8d 55 c0             	lea    -0x40(%ebp),%edx
    ed7c:	52                   	push   %edx
    ed7d:	50                   	push   %eax
    ed7e:	51                   	push   %ecx
    ed7f:	6a 00                	push   $0x0
    ed81:	8d 45 b8             	lea    -0x48(%ebp),%eax
    ed84:	50                   	push   %eax
    ed85:	8d 45 bc             	lea    -0x44(%ebp),%eax
    ed88:	50                   	push   %eax
    ed89:	e8 ed 90 ff ff       	call   7e7b <zlib_decompress>
    ed8e:	83 c4 20             	add    $0x20,%esp
    ed91:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    ed94:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ed98:	74 11                	je     edab <readChunk_iTXt+0x2c6>
    ed9a:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ed9d:	8b 45 b8             	mov    -0x48(%ebp),%eax
    eda0:	39 c2                	cmp    %eax,%edx
    eda2:	7d 07                	jge    edab <readChunk_iTXt+0x2c6>
    eda4:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    edab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    edaf:	75 22                	jne    edd3 <readChunk_iTXt+0x2ee>
    edb1:	8b 55 b8             	mov    -0x48(%ebp),%edx
    edb4:	8b 45 bc             	mov    -0x44(%ebp),%eax
    edb7:	83 ec 08             	sub    $0x8,%esp
    edba:	52                   	push   %edx
    edbb:	50                   	push   %eax
    edbc:	ff 75 e0             	pushl  -0x20(%ebp)
    edbf:	ff 75 e4             	pushl  -0x1c(%ebp)
    edc2:	ff 75 e8             	pushl  -0x18(%ebp)
    edc5:	ff 75 08             	pushl  0x8(%ebp)
    edc8:	e8 94 a9 ff ff       	call   9761 <lodepng_add_itext_sized>
    edcd:	83 c4 20             	add    $0x20,%esp
    edd0:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    edd3:	8b 45 bc             	mov    -0x44(%ebp),%eax
    edd6:	83 ec 0c             	sub    $0xc,%esp
    edd9:	50                   	push   %eax
    edda:	e8 02 46 ff ff       	call   33e1 <lodepng_free>
    eddf:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    ede2:	eb 27                	jmp    ee0b <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    ede4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ede7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    edea:	8b 55 d8             	mov    -0x28(%ebp),%edx
    eded:	01 ca                	add    %ecx,%edx
    edef:	83 ec 08             	sub    $0x8,%esp
    edf2:	50                   	push   %eax
    edf3:	52                   	push   %edx
    edf4:	ff 75 e0             	pushl  -0x20(%ebp)
    edf7:	ff 75 e4             	pushl  -0x1c(%ebp)
    edfa:	ff 75 e8             	pushl  -0x18(%ebp)
    edfd:	ff 75 08             	pushl  0x8(%ebp)
    ee00:	e8 5c a9 ff ff       	call   9761 <lodepng_add_itext_sized>
    ee05:	83 c4 20             	add    $0x20,%esp
    ee08:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    ee0b:	90                   	nop
  }

  lodepng_free(key);
    ee0c:	83 ec 0c             	sub    $0xc,%esp
    ee0f:	ff 75 e8             	pushl  -0x18(%ebp)
    ee12:	e8 ca 45 ff ff       	call   33e1 <lodepng_free>
    ee17:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    ee1a:	83 ec 0c             	sub    $0xc,%esp
    ee1d:	ff 75 e4             	pushl  -0x1c(%ebp)
    ee20:	e8 bc 45 ff ff       	call   33e1 <lodepng_free>
    ee25:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    ee28:	83 ec 0c             	sub    $0xc,%esp
    ee2b:	ff 75 e0             	pushl  -0x20(%ebp)
    ee2e:	e8 ae 45 ff ff       	call   33e1 <lodepng_free>
    ee33:	83 c4 10             	add    $0x10,%esp

  return error;
    ee36:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ee39:	c9                   	leave  
    ee3a:	c3                   	ret    

0000ee3b <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ee3b:	55                   	push   %ebp
    ee3c:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    ee3e:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    ee42:	74 0a                	je     ee4e <readChunk_tIME+0x13>
    ee44:	b8 49 00 00 00       	mov    $0x49,%eax
    ee49:	e9 8b 00 00 00       	jmp    eed9 <readChunk_tIME+0x9e>

  info->time_defined = 1;
    ee4e:	8b 45 08             	mov    0x8(%ebp),%eax
    ee51:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    ee58:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee5b:	0f b6 00             	movzbl (%eax),%eax
    ee5e:	0f b6 c0             	movzbl %al,%eax
    ee61:	c1 e0 08             	shl    $0x8,%eax
    ee64:	89 c2                	mov    %eax,%edx
    ee66:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee69:	83 c0 01             	add    $0x1,%eax
    ee6c:	0f b6 00             	movzbl (%eax),%eax
    ee6f:	0f b6 c0             	movzbl %al,%eax
    ee72:	01 c2                	add    %eax,%edx
    ee74:	8b 45 08             	mov    0x8(%ebp),%eax
    ee77:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    ee7a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee7d:	83 c0 02             	add    $0x2,%eax
    ee80:	0f b6 00             	movzbl (%eax),%eax
    ee83:	0f b6 d0             	movzbl %al,%edx
    ee86:	8b 45 08             	mov    0x8(%ebp),%eax
    ee89:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    ee8c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee8f:	83 c0 03             	add    $0x3,%eax
    ee92:	0f b6 00             	movzbl (%eax),%eax
    ee95:	0f b6 d0             	movzbl %al,%edx
    ee98:	8b 45 08             	mov    0x8(%ebp),%eax
    ee9b:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    ee9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    eea1:	83 c0 04             	add    $0x4,%eax
    eea4:	0f b6 00             	movzbl (%eax),%eax
    eea7:	0f b6 d0             	movzbl %al,%edx
    eeaa:	8b 45 08             	mov    0x8(%ebp),%eax
    eead:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    eeb0:	8b 45 0c             	mov    0xc(%ebp),%eax
    eeb3:	83 c0 05             	add    $0x5,%eax
    eeb6:	0f b6 00             	movzbl (%eax),%eax
    eeb9:	0f b6 d0             	movzbl %al,%edx
    eebc:	8b 45 08             	mov    0x8(%ebp),%eax
    eebf:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    eec2:	8b 45 0c             	mov    0xc(%ebp),%eax
    eec5:	83 c0 06             	add    $0x6,%eax
    eec8:	0f b6 00             	movzbl (%eax),%eax
    eecb:	0f b6 d0             	movzbl %al,%edx
    eece:	8b 45 08             	mov    0x8(%ebp),%eax
    eed1:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    eed4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    eed9:	5d                   	pop    %ebp
    eeda:	c3                   	ret    

0000eedb <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    eedb:	55                   	push   %ebp
    eedc:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    eede:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    eee2:	74 0a                	je     eeee <readChunk_pHYs+0x13>
    eee4:	b8 4a 00 00 00       	mov    $0x4a,%eax
    eee9:	e9 ba 00 00 00       	jmp    efa8 <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    eeee:	8b 45 08             	mov    0x8(%ebp),%eax
    eef1:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    eef8:	8b 45 0c             	mov    0xc(%ebp),%eax
    eefb:	0f b6 00             	movzbl (%eax),%eax
    eefe:	0f b6 c0             	movzbl %al,%eax
    ef01:	c1 e0 08             	shl    $0x8,%eax
    ef04:	89 c2                	mov    %eax,%edx
    ef06:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef09:	83 c0 01             	add    $0x1,%eax
    ef0c:	0f b6 00             	movzbl (%eax),%eax
    ef0f:	0f b6 c0             	movzbl %al,%eax
    ef12:	01 d0                	add    %edx,%eax
    ef14:	c1 e0 08             	shl    $0x8,%eax
    ef17:	89 c2                	mov    %eax,%edx
    ef19:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef1c:	83 c0 02             	add    $0x2,%eax
    ef1f:	0f b6 00             	movzbl (%eax),%eax
    ef22:	0f b6 c0             	movzbl %al,%eax
    ef25:	01 d0                	add    %edx,%eax
    ef27:	c1 e0 08             	shl    $0x8,%eax
    ef2a:	89 c2                	mov    %eax,%edx
    ef2c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef2f:	83 c0 03             	add    $0x3,%eax
    ef32:	0f b6 00             	movzbl (%eax),%eax
    ef35:	0f b6 c0             	movzbl %al,%eax
    ef38:	01 c2                	add    %eax,%edx
    ef3a:	8b 45 08             	mov    0x8(%ebp),%eax
    ef3d:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    ef40:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef43:	83 c0 04             	add    $0x4,%eax
    ef46:	0f b6 00             	movzbl (%eax),%eax
    ef49:	0f b6 c0             	movzbl %al,%eax
    ef4c:	c1 e0 08             	shl    $0x8,%eax
    ef4f:	89 c2                	mov    %eax,%edx
    ef51:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef54:	83 c0 05             	add    $0x5,%eax
    ef57:	0f b6 00             	movzbl (%eax),%eax
    ef5a:	0f b6 c0             	movzbl %al,%eax
    ef5d:	01 d0                	add    %edx,%eax
    ef5f:	c1 e0 08             	shl    $0x8,%eax
    ef62:	89 c2                	mov    %eax,%edx
    ef64:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef67:	83 c0 06             	add    $0x6,%eax
    ef6a:	0f b6 00             	movzbl (%eax),%eax
    ef6d:	0f b6 c0             	movzbl %al,%eax
    ef70:	01 d0                	add    %edx,%eax
    ef72:	c1 e0 08             	shl    $0x8,%eax
    ef75:	89 c2                	mov    %eax,%edx
    ef77:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef7a:	83 c0 07             	add    $0x7,%eax
    ef7d:	0f b6 00             	movzbl (%eax),%eax
    ef80:	0f b6 c0             	movzbl %al,%eax
    ef83:	01 c2                	add    %eax,%edx
    ef85:	8b 45 08             	mov    0x8(%ebp),%eax
    ef88:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    ef8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef91:	83 c0 08             	add    $0x8,%eax
    ef94:	0f b6 00             	movzbl (%eax),%eax
    ef97:	0f b6 d0             	movzbl %al,%edx
    ef9a:	8b 45 08             	mov    0x8(%ebp),%eax
    ef9d:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    efa3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    efa8:	5d                   	pop    %ebp
    efa9:	c3                   	ret    

0000efaa <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    efaa:	55                   	push   %ebp
    efab:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    efad:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    efb1:	74 07                	je     efba <readChunk_gAMA+0x10>
    efb3:	b8 60 00 00 00       	mov    $0x60,%eax
    efb8:	eb 5d                	jmp    f017 <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    efba:	8b 45 08             	mov    0x8(%ebp),%eax
    efbd:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    efc4:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    efc7:	8b 45 0c             	mov    0xc(%ebp),%eax
    efca:	0f b6 00             	movzbl (%eax),%eax
    efcd:	0f b6 c0             	movzbl %al,%eax
    efd0:	c1 e0 08             	shl    $0x8,%eax
    efd3:	89 c2                	mov    %eax,%edx
    efd5:	8b 45 0c             	mov    0xc(%ebp),%eax
    efd8:	83 c0 01             	add    $0x1,%eax
    efdb:	0f b6 00             	movzbl (%eax),%eax
    efde:	0f b6 c0             	movzbl %al,%eax
    efe1:	01 d0                	add    %edx,%eax
    efe3:	c1 e0 08             	shl    $0x8,%eax
    efe6:	89 c2                	mov    %eax,%edx
    efe8:	8b 45 0c             	mov    0xc(%ebp),%eax
    efeb:	83 c0 02             	add    $0x2,%eax
    efee:	0f b6 00             	movzbl (%eax),%eax
    eff1:	0f b6 c0             	movzbl %al,%eax
    eff4:	01 d0                	add    %edx,%eax
    eff6:	c1 e0 08             	shl    $0x8,%eax
    eff9:	89 c2                	mov    %eax,%edx
    effb:	8b 45 0c             	mov    0xc(%ebp),%eax
    effe:	83 c0 03             	add    $0x3,%eax
    f001:	0f b6 00             	movzbl (%eax),%eax
    f004:	0f b6 c0             	movzbl %al,%eax
    f007:	01 c2                	add    %eax,%edx
    f009:	8b 45 08             	mov    0x8(%ebp),%eax
    f00c:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    f012:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f017:	5d                   	pop    %ebp
    f018:	c3                   	ret    

0000f019 <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f019:	55                   	push   %ebp
    f01a:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    f01c:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    f020:	74 0a                	je     f02c <readChunk_cHRM+0x13>
    f022:	b8 61 00 00 00       	mov    $0x61,%eax
    f027:	e9 7f 02 00 00       	jmp    f2ab <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    f02c:	8b 45 08             	mov    0x8(%ebp),%eax
    f02f:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    f036:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    f039:	8b 45 0c             	mov    0xc(%ebp),%eax
    f03c:	0f b6 00             	movzbl (%eax),%eax
    f03f:	0f b6 c0             	movzbl %al,%eax
    f042:	c1 e0 08             	shl    $0x8,%eax
    f045:	89 c2                	mov    %eax,%edx
    f047:	8b 45 0c             	mov    0xc(%ebp),%eax
    f04a:	83 c0 01             	add    $0x1,%eax
    f04d:	0f b6 00             	movzbl (%eax),%eax
    f050:	0f b6 c0             	movzbl %al,%eax
    f053:	01 d0                	add    %edx,%eax
    f055:	c1 e0 08             	shl    $0x8,%eax
    f058:	89 c2                	mov    %eax,%edx
    f05a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f05d:	83 c0 02             	add    $0x2,%eax
    f060:	0f b6 00             	movzbl (%eax),%eax
    f063:	0f b6 c0             	movzbl %al,%eax
    f066:	01 d0                	add    %edx,%eax
    f068:	c1 e0 08             	shl    $0x8,%eax
    f06b:	89 c2                	mov    %eax,%edx
    f06d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f070:	83 c0 03             	add    $0x3,%eax
    f073:	0f b6 00             	movzbl (%eax),%eax
    f076:	0f b6 c0             	movzbl %al,%eax
    f079:	01 c2                	add    %eax,%edx
    f07b:	8b 45 08             	mov    0x8(%ebp),%eax
    f07e:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    f084:	8b 45 0c             	mov    0xc(%ebp),%eax
    f087:	83 c0 04             	add    $0x4,%eax
    f08a:	0f b6 00             	movzbl (%eax),%eax
    f08d:	0f b6 c0             	movzbl %al,%eax
    f090:	c1 e0 08             	shl    $0x8,%eax
    f093:	89 c2                	mov    %eax,%edx
    f095:	8b 45 0c             	mov    0xc(%ebp),%eax
    f098:	83 c0 05             	add    $0x5,%eax
    f09b:	0f b6 00             	movzbl (%eax),%eax
    f09e:	0f b6 c0             	movzbl %al,%eax
    f0a1:	01 d0                	add    %edx,%eax
    f0a3:	c1 e0 08             	shl    $0x8,%eax
    f0a6:	89 c2                	mov    %eax,%edx
    f0a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0ab:	83 c0 06             	add    $0x6,%eax
    f0ae:	0f b6 00             	movzbl (%eax),%eax
    f0b1:	0f b6 c0             	movzbl %al,%eax
    f0b4:	01 d0                	add    %edx,%eax
    f0b6:	c1 e0 08             	shl    $0x8,%eax
    f0b9:	89 c2                	mov    %eax,%edx
    f0bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0be:	83 c0 07             	add    $0x7,%eax
    f0c1:	0f b6 00             	movzbl (%eax),%eax
    f0c4:	0f b6 c0             	movzbl %al,%eax
    f0c7:	01 c2                	add    %eax,%edx
    f0c9:	8b 45 08             	mov    0x8(%ebp),%eax
    f0cc:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    f0d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0d5:	83 c0 08             	add    $0x8,%eax
    f0d8:	0f b6 00             	movzbl (%eax),%eax
    f0db:	0f b6 c0             	movzbl %al,%eax
    f0de:	c1 e0 08             	shl    $0x8,%eax
    f0e1:	89 c2                	mov    %eax,%edx
    f0e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0e6:	83 c0 09             	add    $0x9,%eax
    f0e9:	0f b6 00             	movzbl (%eax),%eax
    f0ec:	0f b6 c0             	movzbl %al,%eax
    f0ef:	01 d0                	add    %edx,%eax
    f0f1:	c1 e0 08             	shl    $0x8,%eax
    f0f4:	89 c2                	mov    %eax,%edx
    f0f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0f9:	83 c0 0a             	add    $0xa,%eax
    f0fc:	0f b6 00             	movzbl (%eax),%eax
    f0ff:	0f b6 c0             	movzbl %al,%eax
    f102:	01 d0                	add    %edx,%eax
    f104:	c1 e0 08             	shl    $0x8,%eax
    f107:	89 c2                	mov    %eax,%edx
    f109:	8b 45 0c             	mov    0xc(%ebp),%eax
    f10c:	83 c0 0b             	add    $0xb,%eax
    f10f:	0f b6 00             	movzbl (%eax),%eax
    f112:	0f b6 c0             	movzbl %al,%eax
    f115:	01 c2                	add    %eax,%edx
    f117:	8b 45 08             	mov    0x8(%ebp),%eax
    f11a:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f120:	8b 45 0c             	mov    0xc(%ebp),%eax
    f123:	83 c0 0c             	add    $0xc,%eax
    f126:	0f b6 00             	movzbl (%eax),%eax
    f129:	0f b6 c0             	movzbl %al,%eax
    f12c:	c1 e0 08             	shl    $0x8,%eax
    f12f:	89 c2                	mov    %eax,%edx
    f131:	8b 45 0c             	mov    0xc(%ebp),%eax
    f134:	83 c0 0d             	add    $0xd,%eax
    f137:	0f b6 00             	movzbl (%eax),%eax
    f13a:	0f b6 c0             	movzbl %al,%eax
    f13d:	01 d0                	add    %edx,%eax
    f13f:	c1 e0 08             	shl    $0x8,%eax
    f142:	89 c2                	mov    %eax,%edx
    f144:	8b 45 0c             	mov    0xc(%ebp),%eax
    f147:	83 c0 0e             	add    $0xe,%eax
    f14a:	0f b6 00             	movzbl (%eax),%eax
    f14d:	0f b6 c0             	movzbl %al,%eax
    f150:	01 d0                	add    %edx,%eax
    f152:	c1 e0 08             	shl    $0x8,%eax
    f155:	89 c2                	mov    %eax,%edx
    f157:	8b 45 0c             	mov    0xc(%ebp),%eax
    f15a:	83 c0 0f             	add    $0xf,%eax
    f15d:	0f b6 00             	movzbl (%eax),%eax
    f160:	0f b6 c0             	movzbl %al,%eax
    f163:	01 c2                	add    %eax,%edx
    f165:	8b 45 08             	mov    0x8(%ebp),%eax
    f168:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f16e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f171:	83 c0 10             	add    $0x10,%eax
    f174:	0f b6 00             	movzbl (%eax),%eax
    f177:	0f b6 c0             	movzbl %al,%eax
    f17a:	c1 e0 08             	shl    $0x8,%eax
    f17d:	89 c2                	mov    %eax,%edx
    f17f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f182:	83 c0 11             	add    $0x11,%eax
    f185:	0f b6 00             	movzbl (%eax),%eax
    f188:	0f b6 c0             	movzbl %al,%eax
    f18b:	01 d0                	add    %edx,%eax
    f18d:	c1 e0 08             	shl    $0x8,%eax
    f190:	89 c2                	mov    %eax,%edx
    f192:	8b 45 0c             	mov    0xc(%ebp),%eax
    f195:	83 c0 12             	add    $0x12,%eax
    f198:	0f b6 00             	movzbl (%eax),%eax
    f19b:	0f b6 c0             	movzbl %al,%eax
    f19e:	01 d0                	add    %edx,%eax
    f1a0:	c1 e0 08             	shl    $0x8,%eax
    f1a3:	89 c2                	mov    %eax,%edx
    f1a5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1a8:	83 c0 13             	add    $0x13,%eax
    f1ab:	0f b6 00             	movzbl (%eax),%eax
    f1ae:	0f b6 c0             	movzbl %al,%eax
    f1b1:	01 c2                	add    %eax,%edx
    f1b3:	8b 45 08             	mov    0x8(%ebp),%eax
    f1b6:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f1bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1bf:	83 c0 14             	add    $0x14,%eax
    f1c2:	0f b6 00             	movzbl (%eax),%eax
    f1c5:	0f b6 c0             	movzbl %al,%eax
    f1c8:	c1 e0 08             	shl    $0x8,%eax
    f1cb:	89 c2                	mov    %eax,%edx
    f1cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1d0:	83 c0 15             	add    $0x15,%eax
    f1d3:	0f b6 00             	movzbl (%eax),%eax
    f1d6:	0f b6 c0             	movzbl %al,%eax
    f1d9:	01 d0                	add    %edx,%eax
    f1db:	c1 e0 08             	shl    $0x8,%eax
    f1de:	89 c2                	mov    %eax,%edx
    f1e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1e3:	83 c0 16             	add    $0x16,%eax
    f1e6:	0f b6 00             	movzbl (%eax),%eax
    f1e9:	0f b6 c0             	movzbl %al,%eax
    f1ec:	01 d0                	add    %edx,%eax
    f1ee:	c1 e0 08             	shl    $0x8,%eax
    f1f1:	89 c2                	mov    %eax,%edx
    f1f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1f6:	83 c0 17             	add    $0x17,%eax
    f1f9:	0f b6 00             	movzbl (%eax),%eax
    f1fc:	0f b6 c0             	movzbl %al,%eax
    f1ff:	01 c2                	add    %eax,%edx
    f201:	8b 45 08             	mov    0x8(%ebp),%eax
    f204:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f20a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f20d:	83 c0 18             	add    $0x18,%eax
    f210:	0f b6 00             	movzbl (%eax),%eax
    f213:	0f b6 c0             	movzbl %al,%eax
    f216:	c1 e0 08             	shl    $0x8,%eax
    f219:	89 c2                	mov    %eax,%edx
    f21b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f21e:	83 c0 19             	add    $0x19,%eax
    f221:	0f b6 00             	movzbl (%eax),%eax
    f224:	0f b6 c0             	movzbl %al,%eax
    f227:	01 d0                	add    %edx,%eax
    f229:	c1 e0 08             	shl    $0x8,%eax
    f22c:	89 c2                	mov    %eax,%edx
    f22e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f231:	83 c0 1a             	add    $0x1a,%eax
    f234:	0f b6 00             	movzbl (%eax),%eax
    f237:	0f b6 c0             	movzbl %al,%eax
    f23a:	01 d0                	add    %edx,%eax
    f23c:	c1 e0 08             	shl    $0x8,%eax
    f23f:	89 c2                	mov    %eax,%edx
    f241:	8b 45 0c             	mov    0xc(%ebp),%eax
    f244:	83 c0 1b             	add    $0x1b,%eax
    f247:	0f b6 00             	movzbl (%eax),%eax
    f24a:	0f b6 c0             	movzbl %al,%eax
    f24d:	01 c2                	add    %eax,%edx
    f24f:	8b 45 08             	mov    0x8(%ebp),%eax
    f252:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f258:	8b 45 0c             	mov    0xc(%ebp),%eax
    f25b:	83 c0 1c             	add    $0x1c,%eax
    f25e:	0f b6 00             	movzbl (%eax),%eax
    f261:	0f b6 c0             	movzbl %al,%eax
    f264:	c1 e0 08             	shl    $0x8,%eax
    f267:	89 c2                	mov    %eax,%edx
    f269:	8b 45 0c             	mov    0xc(%ebp),%eax
    f26c:	83 c0 1d             	add    $0x1d,%eax
    f26f:	0f b6 00             	movzbl (%eax),%eax
    f272:	0f b6 c0             	movzbl %al,%eax
    f275:	01 d0                	add    %edx,%eax
    f277:	c1 e0 08             	shl    $0x8,%eax
    f27a:	89 c2                	mov    %eax,%edx
    f27c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f27f:	83 c0 1e             	add    $0x1e,%eax
    f282:	0f b6 00             	movzbl (%eax),%eax
    f285:	0f b6 c0             	movzbl %al,%eax
    f288:	01 d0                	add    %edx,%eax
    f28a:	c1 e0 08             	shl    $0x8,%eax
    f28d:	89 c2                	mov    %eax,%edx
    f28f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f292:	83 c0 1f             	add    $0x1f,%eax
    f295:	0f b6 00             	movzbl (%eax),%eax
    f298:	0f b6 c0             	movzbl %al,%eax
    f29b:	01 c2                	add    %eax,%edx
    f29d:	8b 45 08             	mov    0x8(%ebp),%eax
    f2a0:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f2a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f2ab:	5d                   	pop    %ebp
    f2ac:	c3                   	ret    

0000f2ad <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f2ad:	55                   	push   %ebp
    f2ae:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f2b0:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f2b4:	74 07                	je     f2bd <readChunk_sRGB+0x10>
    f2b6:	b8 62 00 00 00       	mov    $0x62,%eax
    f2bb:	eb 24                	jmp    f2e1 <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f2bd:	8b 45 08             	mov    0x8(%ebp),%eax
    f2c0:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f2c7:	00 00 00 
  info->srgb_intent = data[0];
    f2ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2cd:	0f b6 00             	movzbl (%eax),%eax
    f2d0:	0f b6 d0             	movzbl %al,%edx
    f2d3:	8b 45 08             	mov    0x8(%ebp),%eax
    f2d6:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f2dc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f2e1:	5d                   	pop    %ebp
    f2e2:	c3                   	ret    

0000f2e3 <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f2e3:	55                   	push   %ebp
    f2e4:	89 e5                	mov    %esp,%ebp
    f2e6:	53                   	push   %ebx
    f2e7:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f2ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f2f1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f2f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2fb:	8b 10                	mov    (%eax),%edx
    f2fd:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f300:	8b 50 04             	mov    0x4(%eax),%edx
    f303:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f306:	8b 50 08             	mov    0x8(%eax),%edx
    f309:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f30c:	8b 50 0c             	mov    0xc(%eax),%edx
    f30f:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f312:	8b 50 10             	mov    0x10(%eax),%edx
    f315:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f318:	8b 40 14             	mov    0x14(%eax),%eax
    f31b:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f31e:	8b 45 08             	mov    0x8(%ebp),%eax
    f321:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f328:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f32b:	8b 45 08             	mov    0x8(%ebp),%eax
    f32e:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f334:	85 c0                	test   %eax,%eax
    f336:	74 0e                	je     f346 <readChunk_iCCP+0x63>
    f338:	83 ec 0c             	sub    $0xc,%esp
    f33b:	ff 75 08             	pushl  0x8(%ebp)
    f33e:	e8 ca a6 ff ff       	call   9a0d <lodepng_clear_icc>
    f343:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f346:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f34d:	eb 04                	jmp    f353 <readChunk_iCCP+0x70>
    f34f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f353:	8b 45 14             	mov    0x14(%ebp),%eax
    f356:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f359:	73 0f                	jae    f36a <readChunk_iCCP+0x87>
    f35b:	8b 55 10             	mov    0x10(%ebp),%edx
    f35e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f361:	01 d0                	add    %edx,%eax
    f363:	0f b6 00             	movzbl (%eax),%eax
    f366:	84 c0                	test   %al,%al
    f368:	75 e5                	jne    f34f <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f36a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f36d:	8d 50 02             	lea    0x2(%eax),%edx
    f370:	8b 45 14             	mov    0x14(%ebp),%eax
    f373:	39 c2                	cmp    %eax,%edx
    f375:	72 0a                	jb     f381 <readChunk_iCCP+0x9e>
    f377:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f37c:	e9 46 01 00 00       	jmp    f4c7 <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f381:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f385:	74 06                	je     f38d <readChunk_iCCP+0xaa>
    f387:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f38b:	76 0a                	jbe    f397 <readChunk_iCCP+0xb4>
    f38d:	b8 59 00 00 00       	mov    $0x59,%eax
    f392:	e9 30 01 00 00       	jmp    f4c7 <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    f397:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f39a:	83 c0 01             	add    $0x1,%eax
    f39d:	83 ec 0c             	sub    $0xc,%esp
    f3a0:	50                   	push   %eax
    f3a1:	e8 1a 40 ff ff       	call   33c0 <lodepng_malloc>
    f3a6:	83 c4 10             	add    $0x10,%esp
    f3a9:	89 c2                	mov    %eax,%edx
    f3ab:	8b 45 08             	mov    0x8(%ebp),%eax
    f3ae:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    f3b4:	8b 45 08             	mov    0x8(%ebp),%eax
    f3b7:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f3bd:	85 c0                	test   %eax,%eax
    f3bf:	75 0a                	jne    f3cb <readChunk_iCCP+0xe8>
    f3c1:	b8 53 00 00 00       	mov    $0x53,%eax
    f3c6:	e9 fc 00 00 00       	jmp    f4c7 <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    f3cb:	8b 45 08             	mov    0x8(%ebp),%eax
    f3ce:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f3d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f3d7:	01 d0                	add    %edx,%eax
    f3d9:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    f3dc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f3e3:	eb 1f                	jmp    f404 <readChunk_iCCP+0x121>
    f3e5:	8b 45 08             	mov    0x8(%ebp),%eax
    f3e8:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f3ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f3f1:	01 d0                	add    %edx,%eax
    f3f3:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f3f6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f3f9:	01 ca                	add    %ecx,%edx
    f3fb:	0f b6 12             	movzbl (%edx),%edx
    f3fe:	88 10                	mov    %dl,(%eax)
    f400:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f404:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f407:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f40a:	75 d9                	jne    f3e5 <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    f40c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f40f:	8d 50 01             	lea    0x1(%eax),%edx
    f412:	8b 45 10             	mov    0x10(%ebp),%eax
    f415:	01 d0                	add    %edx,%eax
    f417:	0f b6 00             	movzbl (%eax),%eax
    f41a:	84 c0                	test   %al,%al
    f41c:	74 0a                	je     f428 <readChunk_iCCP+0x145>
    f41e:	b8 48 00 00 00       	mov    $0x48,%eax
    f423:	e9 9f 00 00 00       	jmp    f4c7 <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    f428:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f42b:	83 c0 02             	add    $0x2,%eax
    f42e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    f431:	8b 45 14             	mov    0x14(%ebp),%eax
    f434:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f437:	76 0a                	jbe    f443 <readChunk_iCCP+0x160>
    f439:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f43e:	e9 84 00 00 00       	jmp    f4c7 <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    f443:	8b 45 14             	mov    0x14(%ebp),%eax
    f446:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f449:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    f44c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f44f:	8b 40 34             	mov    0x34(%eax),%eax
    f452:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    f455:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f458:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f45b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f45e:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    f461:	8b 55 08             	mov    0x8(%ebp),%edx
    f464:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    f46a:	83 ec 08             	sub    $0x8,%esp
    f46d:	8d 55 cc             	lea    -0x34(%ebp),%edx
    f470:	52                   	push   %edx
    f471:	50                   	push   %eax
    f472:	53                   	push   %ebx
    f473:	6a 00                	push   $0x0
    f475:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    f478:	50                   	push   %eax
    f479:	51                   	push   %ecx
    f47a:	e8 fc 89 ff ff       	call   7e7b <zlib_decompress>
    f47f:	83 c4 20             	add    $0x20,%esp
    f482:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    f485:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f489:	74 11                	je     f49c <readChunk_iCCP+0x1b9>
    f48b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    f48e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f491:	39 c2                	cmp    %eax,%edx
    f493:	7d 07                	jge    f49c <readChunk_iCCP+0x1b9>
    f495:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    f49c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f49f:	89 c2                	mov    %eax,%edx
    f4a1:	8b 45 08             	mov    0x8(%ebp),%eax
    f4a4:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    f4aa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f4ae:	75 14                	jne    f4c4 <readChunk_iCCP+0x1e1>
    f4b0:	8b 45 08             	mov    0x8(%ebp),%eax
    f4b3:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    f4b9:	85 c0                	test   %eax,%eax
    f4bb:	75 07                	jne    f4c4 <readChunk_iCCP+0x1e1>
    f4bd:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    f4c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f4c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f4ca:	c9                   	leave  
    f4cb:	c3                   	ret    

0000f4cc <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    f4cc:	55                   	push   %ebp
    f4cd:	89 e5                	mov    %esp,%ebp
    f4cf:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    f4d2:	8b 55 0c             	mov    0xc(%ebp),%edx
    f4d5:	8b 45 10             	mov    0x10(%ebp),%eax
    f4d8:	01 d0                	add    %edx,%eax
    f4da:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    f4dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    f4e4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    f4eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4ee:	83 c0 04             	add    $0x4,%eax
    f4f1:	3b 45 14             	cmp    0x14(%ebp),%eax
    f4f4:	7e 0a                	jle    f500 <lodepng_inspect_chunk+0x34>
    f4f6:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f4fb:	e9 43 03 00 00       	jmp    f843 <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    f500:	ff 75 ec             	pushl  -0x14(%ebp)
    f503:	e8 3a 8e ff ff       	call   8342 <lodepng_chunk_length>
    f508:	83 c4 04             	add    $0x4,%esp
    f50b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    f50e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f511:	85 c0                	test   %eax,%eax
    f513:	79 0a                	jns    f51f <lodepng_inspect_chunk+0x53>
    f515:	b8 3f 00 00 00       	mov    $0x3f,%eax
    f51a:	e9 24 03 00 00       	jmp    f843 <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    f51f:	ff 75 ec             	pushl  -0x14(%ebp)
    f522:	e8 53 8f ff ff       	call   847a <lodepng_chunk_data_const>
    f527:	83 c4 04             	add    $0x4,%esp
    f52a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    f52d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f530:	8d 50 04             	lea    0x4(%eax),%edx
    f533:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f536:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    f539:	8b 55 14             	mov    0x14(%ebp),%edx
    f53c:	8b 45 10             	mov    0x10(%ebp),%eax
    f53f:	01 d0                	add    %edx,%eax
    f541:	39 c1                	cmp    %eax,%ecx
    f543:	76 0a                	jbe    f54f <lodepng_inspect_chunk+0x83>
    f545:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f54a:	e9 f4 02 00 00       	jmp    f843 <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    f54f:	68 08 a1 01 00       	push   $0x1a108
    f554:	ff 75 ec             	pushl  -0x14(%ebp)
    f557:	e8 33 8e ff ff       	call   838f <lodepng_chunk_type_equals>
    f55c:	83 c4 08             	add    $0x8,%esp
    f55f:	84 c0                	test   %al,%al
    f561:	74 24                	je     f587 <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    f563:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f566:	8b 55 08             	mov    0x8(%ebp),%edx
    f569:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f56f:	83 ec 04             	sub    $0x4,%esp
    f572:	50                   	push   %eax
    f573:	ff 75 e4             	pushl  -0x1c(%ebp)
    f576:	52                   	push   %edx
    f577:	e8 5b ee ff ff       	call   e3d7 <readChunk_PLTE>
    f57c:	83 c4 10             	add    $0x10,%esp
    f57f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f582:	e9 8a 02 00 00       	jmp    f811 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    f587:	83 ec 08             	sub    $0x8,%esp
    f58a:	68 0d a1 01 00       	push   $0x1a10d
    f58f:	ff 75 ec             	pushl  -0x14(%ebp)
    f592:	e8 f8 8d ff ff       	call   838f <lodepng_chunk_type_equals>
    f597:	83 c4 10             	add    $0x10,%esp
    f59a:	84 c0                	test   %al,%al
    f59c:	74 24                	je     f5c2 <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    f59e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f5a1:	8b 55 08             	mov    0x8(%ebp),%edx
    f5a4:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f5aa:	83 ec 04             	sub    $0x4,%esp
    f5ad:	50                   	push   %eax
    f5ae:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5b1:	52                   	push   %edx
    f5b2:	e8 40 ef ff ff       	call   e4f7 <readChunk_tRNS>
    f5b7:	83 c4 10             	add    $0x10,%esp
    f5ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f5bd:	e9 4f 02 00 00       	jmp    f811 <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    f5c2:	83 ec 08             	sub    $0x8,%esp
    f5c5:	68 12 a1 01 00       	push   $0x1a112
    f5ca:	ff 75 ec             	pushl  -0x14(%ebp)
    f5cd:	e8 bd 8d ff ff       	call   838f <lodepng_chunk_type_equals>
    f5d2:	83 c4 10             	add    $0x10,%esp
    f5d5:	84 c0                	test   %al,%al
    f5d7:	74 24                	je     f5fd <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    f5d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f5dc:	8b 55 08             	mov    0x8(%ebp),%edx
    f5df:	81 c2 98 00 00 00    	add    $0x98,%edx
    f5e5:	83 ec 04             	sub    $0x4,%esp
    f5e8:	50                   	push   %eax
    f5e9:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5ec:	52                   	push   %edx
    f5ed:	e8 68 f0 ff ff       	call   e65a <readChunk_bKGD>
    f5f2:	83 c4 10             	add    $0x10,%esp
    f5f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f5f8:	e9 14 02 00 00       	jmp    f811 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    f5fd:	83 ec 08             	sub    $0x8,%esp
    f600:	68 17 a1 01 00       	push   $0x1a117
    f605:	ff 75 ec             	pushl  -0x14(%ebp)
    f608:	e8 82 8d ff ff       	call   838f <lodepng_chunk_type_equals>
    f60d:	83 c4 10             	add    $0x10,%esp
    f610:	84 c0                	test   %al,%al
    f612:	74 24                	je     f638 <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    f614:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f617:	8b 55 08             	mov    0x8(%ebp),%edx
    f61a:	81 c2 98 00 00 00    	add    $0x98,%edx
    f620:	83 ec 04             	sub    $0x4,%esp
    f623:	50                   	push   %eax
    f624:	ff 75 e4             	pushl  -0x1c(%ebp)
    f627:	52                   	push   %edx
    f628:	e8 b0 f1 ff ff       	call   e7dd <readChunk_tEXt>
    f62d:	83 c4 10             	add    $0x10,%esp
    f630:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f633:	e9 d9 01 00 00       	jmp    f811 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    f638:	83 ec 08             	sub    $0x8,%esp
    f63b:	68 1c a1 01 00       	push   $0x1a11c
    f640:	ff 75 ec             	pushl  -0x14(%ebp)
    f643:	e8 47 8d ff ff       	call   838f <lodepng_chunk_type_equals>
    f648:	83 c4 10             	add    $0x10,%esp
    f64b:	84 c0                	test   %al,%al
    f64d:	74 25                	je     f674 <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    f64f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f652:	8b 45 08             	mov    0x8(%ebp),%eax
    f655:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f658:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f65e:	52                   	push   %edx
    f65f:	ff 75 e4             	pushl  -0x1c(%ebp)
    f662:	50                   	push   %eax
    f663:	51                   	push   %ecx
    f664:	e8 c0 f2 ff ff       	call   e929 <readChunk_zTXt>
    f669:	83 c4 10             	add    $0x10,%esp
    f66c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f66f:	e9 9d 01 00 00       	jmp    f811 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    f674:	83 ec 08             	sub    $0x8,%esp
    f677:	68 21 a1 01 00       	push   $0x1a121
    f67c:	ff 75 ec             	pushl  -0x14(%ebp)
    f67f:	e8 0b 8d ff ff       	call   838f <lodepng_chunk_type_equals>
    f684:	83 c4 10             	add    $0x10,%esp
    f687:	84 c0                	test   %al,%al
    f689:	74 25                	je     f6b0 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    f68b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f68e:	8b 45 08             	mov    0x8(%ebp),%eax
    f691:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f694:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f69a:	52                   	push   %edx
    f69b:	ff 75 e4             	pushl  -0x1c(%ebp)
    f69e:	50                   	push   %eax
    f69f:	51                   	push   %ecx
    f6a0:	e8 40 f4 ff ff       	call   eae5 <readChunk_iTXt>
    f6a5:	83 c4 10             	add    $0x10,%esp
    f6a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6ab:	e9 61 01 00 00       	jmp    f811 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    f6b0:	83 ec 08             	sub    $0x8,%esp
    f6b3:	68 26 a1 01 00       	push   $0x1a126
    f6b8:	ff 75 ec             	pushl  -0x14(%ebp)
    f6bb:	e8 cf 8c ff ff       	call   838f <lodepng_chunk_type_equals>
    f6c0:	83 c4 10             	add    $0x10,%esp
    f6c3:	84 c0                	test   %al,%al
    f6c5:	74 24                	je     f6eb <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    f6c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f6ca:	8b 55 08             	mov    0x8(%ebp),%edx
    f6cd:	81 c2 98 00 00 00    	add    $0x98,%edx
    f6d3:	83 ec 04             	sub    $0x4,%esp
    f6d6:	50                   	push   %eax
    f6d7:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6da:	52                   	push   %edx
    f6db:	e8 5b f7 ff ff       	call   ee3b <readChunk_tIME>
    f6e0:	83 c4 10             	add    $0x10,%esp
    f6e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6e6:	e9 26 01 00 00       	jmp    f811 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    f6eb:	83 ec 08             	sub    $0x8,%esp
    f6ee:	68 2b a1 01 00       	push   $0x1a12b
    f6f3:	ff 75 ec             	pushl  -0x14(%ebp)
    f6f6:	e8 94 8c ff ff       	call   838f <lodepng_chunk_type_equals>
    f6fb:	83 c4 10             	add    $0x10,%esp
    f6fe:	84 c0                	test   %al,%al
    f700:	74 24                	je     f726 <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    f702:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f705:	8b 55 08             	mov    0x8(%ebp),%edx
    f708:	81 c2 98 00 00 00    	add    $0x98,%edx
    f70e:	83 ec 04             	sub    $0x4,%esp
    f711:	50                   	push   %eax
    f712:	ff 75 e4             	pushl  -0x1c(%ebp)
    f715:	52                   	push   %edx
    f716:	e8 c0 f7 ff ff       	call   eedb <readChunk_pHYs>
    f71b:	83 c4 10             	add    $0x10,%esp
    f71e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f721:	e9 eb 00 00 00       	jmp    f811 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    f726:	83 ec 08             	sub    $0x8,%esp
    f729:	68 30 a1 01 00       	push   $0x1a130
    f72e:	ff 75 ec             	pushl  -0x14(%ebp)
    f731:	e8 59 8c ff ff       	call   838f <lodepng_chunk_type_equals>
    f736:	83 c4 10             	add    $0x10,%esp
    f739:	84 c0                	test   %al,%al
    f73b:	74 24                	je     f761 <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    f73d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f740:	8b 55 08             	mov    0x8(%ebp),%edx
    f743:	81 c2 98 00 00 00    	add    $0x98,%edx
    f749:	83 ec 04             	sub    $0x4,%esp
    f74c:	50                   	push   %eax
    f74d:	ff 75 e4             	pushl  -0x1c(%ebp)
    f750:	52                   	push   %edx
    f751:	e8 54 f8 ff ff       	call   efaa <readChunk_gAMA>
    f756:	83 c4 10             	add    $0x10,%esp
    f759:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f75c:	e9 b0 00 00 00       	jmp    f811 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    f761:	83 ec 08             	sub    $0x8,%esp
    f764:	68 35 a1 01 00       	push   $0x1a135
    f769:	ff 75 ec             	pushl  -0x14(%ebp)
    f76c:	e8 1e 8c ff ff       	call   838f <lodepng_chunk_type_equals>
    f771:	83 c4 10             	add    $0x10,%esp
    f774:	84 c0                	test   %al,%al
    f776:	74 21                	je     f799 <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    f778:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f77b:	8b 55 08             	mov    0x8(%ebp),%edx
    f77e:	81 c2 98 00 00 00    	add    $0x98,%edx
    f784:	83 ec 04             	sub    $0x4,%esp
    f787:	50                   	push   %eax
    f788:	ff 75 e4             	pushl  -0x1c(%ebp)
    f78b:	52                   	push   %edx
    f78c:	e8 88 f8 ff ff       	call   f019 <readChunk_cHRM>
    f791:	83 c4 10             	add    $0x10,%esp
    f794:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f797:	eb 78                	jmp    f811 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    f799:	83 ec 08             	sub    $0x8,%esp
    f79c:	68 3a a1 01 00       	push   $0x1a13a
    f7a1:	ff 75 ec             	pushl  -0x14(%ebp)
    f7a4:	e8 e6 8b ff ff       	call   838f <lodepng_chunk_type_equals>
    f7a9:	83 c4 10             	add    $0x10,%esp
    f7ac:	84 c0                	test   %al,%al
    f7ae:	74 21                	je     f7d1 <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    f7b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f7b3:	8b 55 08             	mov    0x8(%ebp),%edx
    f7b6:	81 c2 98 00 00 00    	add    $0x98,%edx
    f7bc:	83 ec 04             	sub    $0x4,%esp
    f7bf:	50                   	push   %eax
    f7c0:	ff 75 e4             	pushl  -0x1c(%ebp)
    f7c3:	52                   	push   %edx
    f7c4:	e8 e4 fa ff ff       	call   f2ad <readChunk_sRGB>
    f7c9:	83 c4 10             	add    $0x10,%esp
    f7cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f7cf:	eb 40                	jmp    f811 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    f7d1:	83 ec 08             	sub    $0x8,%esp
    f7d4:	68 3f a1 01 00       	push   $0x1a13f
    f7d9:	ff 75 ec             	pushl  -0x14(%ebp)
    f7dc:	e8 ae 8b ff ff       	call   838f <lodepng_chunk_type_equals>
    f7e1:	83 c4 10             	add    $0x10,%esp
    f7e4:	84 c0                	test   %al,%al
    f7e6:	74 22                	je     f80a <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    f7e8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f7eb:	8b 45 08             	mov    0x8(%ebp),%eax
    f7ee:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f7f1:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f7f7:	52                   	push   %edx
    f7f8:	ff 75 e4             	pushl  -0x1c(%ebp)
    f7fb:	50                   	push   %eax
    f7fc:	51                   	push   %ecx
    f7fd:	e8 e1 fa ff ff       	call   f2e3 <readChunk_iCCP>
    f802:	83 c4 10             	add    $0x10,%esp
    f805:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f808:	eb 07                	jmp    f811 <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    f80a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    f811:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f815:	75 29                	jne    f840 <lodepng_inspect_chunk+0x374>
    f817:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f81b:	75 23                	jne    f840 <lodepng_inspect_chunk+0x374>
    f81d:	8b 45 08             	mov    0x8(%ebp),%eax
    f820:	8b 40 18             	mov    0x18(%eax),%eax
    f823:	85 c0                	test   %eax,%eax
    f825:	75 19                	jne    f840 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    f827:	83 ec 0c             	sub    $0xc,%esp
    f82a:	ff 75 ec             	pushl  -0x14(%ebp)
    f82d:	e8 53 8c ff ff       	call   8485 <lodepng_chunk_check_crc>
    f832:	83 c4 10             	add    $0x10,%esp
    f835:	85 c0                	test   %eax,%eax
    f837:	74 07                	je     f840 <lodepng_inspect_chunk+0x374>
    f839:	b8 39 00 00 00       	mov    $0x39,%eax
    f83e:	eb 03                	jmp    f843 <lodepng_inspect_chunk+0x377>
  }

  return error;
    f840:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    f843:	c9                   	leave  
    f844:	c3                   	ret    

0000f845 <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    f845:	55                   	push   %ebp
    f846:	89 e5                	mov    %esp,%ebp
    f848:	56                   	push   %esi
    f849:	53                   	push   %ebx
    f84a:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    f84d:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    f851:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    f858:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    f85f:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    f866:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    f86d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    f874:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    f87b:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    f882:	8b 45 08             	mov    0x8(%ebp),%eax
    f885:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    f88b:	8b 45 10             	mov    0x10(%ebp),%eax
    f88e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    f894:	8b 45 10             	mov    0x10(%ebp),%eax
    f897:	8b 10                	mov    (%eax),%edx
    f899:	8b 45 0c             	mov    0xc(%ebp),%eax
    f89c:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    f89e:	83 ec 0c             	sub    $0xc,%esp
    f8a1:	ff 75 1c             	pushl  0x1c(%ebp)
    f8a4:	ff 75 18             	pushl  0x18(%ebp)
    f8a7:	ff 75 14             	pushl  0x14(%ebp)
    f8aa:	ff 75 10             	pushl  0x10(%ebp)
    f8ad:	ff 75 0c             	pushl  0xc(%ebp)
    f8b0:	e8 d3 da ff ff       	call   d388 <lodepng_inspect>
    f8b5:	83 c4 20             	add    $0x20,%esp
    f8b8:	89 c2                	mov    %eax,%edx
    f8ba:	8b 45 14             	mov    0x14(%ebp),%eax
    f8bd:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    f8c3:	8b 45 14             	mov    0x14(%ebp),%eax
    f8c6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    f8cc:	85 c0                	test   %eax,%eax
    f8ce:	0f 85 24 0a 00 00    	jne    102f8 <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    f8d4:	8b 45 14             	mov    0x14(%ebp),%eax
    f8d7:	8d 58 78             	lea    0x78(%eax),%ebx
    f8da:	8b 45 14             	mov    0x14(%ebp),%eax
    f8dd:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    f8e3:	8b 45 10             	mov    0x10(%ebp),%eax
    f8e6:	8b 10                	mov    (%eax),%edx
    f8e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f8eb:	8b 00                	mov    (%eax),%eax
    f8ed:	53                   	push   %ebx
    f8ee:	51                   	push   %ecx
    f8ef:	52                   	push   %edx
    f8f0:	50                   	push   %eax
    f8f1:	e8 76 97 ff ff       	call   906c <lodepng_pixel_overflow>
    f8f6:	83 c4 10             	add    $0x10,%esp
    f8f9:	85 c0                	test   %eax,%eax
    f8fb:	74 12                	je     f90f <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    f8fd:	8b 45 14             	mov    0x14(%ebp),%eax
    f900:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    f907:	00 00 00 
    f90a:	e9 ea 09 00 00       	jmp    102f9 <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    f90f:	83 ec 0c             	sub    $0xc,%esp
    f912:	ff 75 1c             	pushl  0x1c(%ebp)
    f915:	e8 a6 3a ff ff       	call   33c0 <lodepng_malloc>
    f91a:	83 c4 10             	add    $0x10,%esp
    f91d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    f920:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    f924:	75 12                	jne    f938 <decodeGeneric+0xf3>
    f926:	8b 45 14             	mov    0x14(%ebp),%eax
    f929:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    f930:	00 00 00 
    f933:	e9 c1 09 00 00       	jmp    102f9 <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    f938:	8b 45 18             	mov    0x18(%ebp),%eax
    f93b:	83 c0 21             	add    $0x21,%eax
    f93e:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    f941:	e9 81 06 00 00       	jmp    ffc7 <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    f946:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f949:	8b 45 18             	mov    0x18(%ebp),%eax
    f94c:	29 c2                	sub    %eax,%edx
    f94e:	89 d0                	mov    %edx,%eax
    f950:	83 c0 0c             	add    $0xc,%eax
    f953:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f956:	7f 08                	jg     f960 <decodeGeneric+0x11b>
    f958:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f95b:	3b 45 18             	cmp    0x18(%ebp),%eax
    f95e:	73 20                	jae    f980 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f960:	8b 45 14             	mov    0x14(%ebp),%eax
    f963:	8b 40 20             	mov    0x20(%eax),%eax
    f966:	85 c0                	test   %eax,%eax
    f968:	0f 85 72 06 00 00    	jne    ffe0 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    f96e:	8b 45 14             	mov    0x14(%ebp),%eax
    f971:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    f978:	00 00 00 
    f97b:	e9 6a 06 00 00       	jmp    ffea <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    f980:	83 ec 0c             	sub    $0xc,%esp
    f983:	ff 75 f0             	pushl  -0x10(%ebp)
    f986:	e8 b7 89 ff ff       	call   8342 <lodepng_chunk_length>
    f98b:	83 c4 10             	add    $0x10,%esp
    f98e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
    f991:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f994:	85 c0                	test   %eax,%eax
    f996:	79 20                	jns    f9b8 <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f998:	8b 45 14             	mov    0x14(%ebp),%eax
    f99b:	8b 40 20             	mov    0x20(%eax),%eax
    f99e:	85 c0                	test   %eax,%eax
    f9a0:	0f 85 3d 06 00 00    	jne    ffe3 <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
    f9a6:	8b 45 14             	mov    0x14(%ebp),%eax
    f9a9:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
    f9b0:	00 00 00 
    f9b3:	e9 32 06 00 00       	jmp    ffea <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
    f9b8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f9bb:	8b 45 18             	mov    0x18(%ebp),%eax
    f9be:	29 c2                	sub    %eax,%edx
    f9c0:	89 d0                	mov    %edx,%eax
    f9c2:	89 c2                	mov    %eax,%edx
    f9c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9c7:	01 d0                	add    %edx,%eax
    f9c9:	83 c0 0c             	add    $0xc,%eax
    f9cc:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f9cf:	7f 10                	jg     f9e1 <decodeGeneric+0x19c>
    f9d1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9d4:	8d 50 0c             	lea    0xc(%eax),%edx
    f9d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f9da:	01 d0                	add    %edx,%eax
    f9dc:	3b 45 18             	cmp    0x18(%ebp),%eax
    f9df:	73 12                	jae    f9f3 <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    f9e1:	8b 45 14             	mov    0x14(%ebp),%eax
    f9e4:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
    f9eb:	00 00 00 
    f9ee:	e9 f7 05 00 00       	jmp    ffea <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
    f9f3:	83 ec 0c             	sub    $0xc,%esp
    f9f6:	ff 75 f0             	pushl  -0x10(%ebp)
    f9f9:	e8 7c 8a ff ff       	call   847a <lodepng_chunk_data_const>
    f9fe:	83 c4 10             	add    $0x10,%esp
    fa01:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
    fa04:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
    fa0b:	83 ec 08             	sub    $0x8,%esp
    fa0e:	68 44 a1 01 00       	push   $0x1a144
    fa13:	ff 75 f0             	pushl  -0x10(%ebp)
    fa16:	e8 74 89 ff ff       	call   838f <lodepng_chunk_type_equals>
    fa1b:	83 c4 10             	add    $0x10,%esp
    fa1e:	84 c0                	test   %al,%al
    fa20:	74 79                	je     fa9b <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
    fa22:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa25:	83 ec 04             	sub    $0x4,%esp
    fa28:	8d 55 bc             	lea    -0x44(%ebp),%edx
    fa2b:	52                   	push   %edx
    fa2c:	50                   	push   %eax
    fa2d:	ff 75 ec             	pushl  -0x14(%ebp)
    fa30:	e8 4f 3a ff ff       	call   3484 <lodepng_addofl>
    fa35:	83 c4 10             	add    $0x10,%esp
    fa38:	85 c0                	test   %eax,%eax
    fa3a:	74 12                	je     fa4e <decodeGeneric+0x209>
    fa3c:	8b 45 14             	mov    0x14(%ebp),%eax
    fa3f:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    fa46:	00 00 00 
    fa49:	e9 9c 05 00 00       	jmp    ffea <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
    fa4e:	8b 45 bc             	mov    -0x44(%ebp),%eax
    fa51:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fa54:	7e 13                	jle    fa69 <decodeGeneric+0x224>
    fa56:	8b 45 14             	mov    0x14(%ebp),%eax
    fa59:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    fa60:	00 00 00 
    fa63:	90                   	nop
    fa64:	e9 81 05 00 00       	jmp    ffea <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
    fa69:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa6c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    fa6f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fa72:	01 ca                	add    %ecx,%edx
    fa74:	83 ec 04             	sub    $0x4,%esp
    fa77:	50                   	push   %eax
    fa78:	ff 75 d0             	pushl  -0x30(%ebp)
    fa7b:	52                   	push   %edx
    fa7c:	e8 7d 39 ff ff       	call   33fe <lodepng_memcpy>
    fa81:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
    fa84:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fa87:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa8a:	01 d0                	add    %edx,%eax
    fa8c:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
    fa8f:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    fa96:	e9 db 04 00 00       	jmp    ff76 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
    fa9b:	83 ec 08             	sub    $0x8,%esp
    fa9e:	68 49 a1 01 00       	push   $0x1a149
    faa3:	ff 75 f0             	pushl  -0x10(%ebp)
    faa6:	e8 e4 88 ff ff       	call   838f <lodepng_chunk_type_equals>
    faab:	83 c4 10             	add    $0x10,%esp
    faae:	84 c0                	test   %al,%al
    fab0:	74 09                	je     fabb <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
    fab2:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    fab6:	e9 bb 04 00 00       	jmp    ff76 <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    fabb:	83 ec 08             	sub    $0x8,%esp
    fabe:	68 08 a1 01 00       	push   $0x1a108
    fac3:	ff 75 f0             	pushl  -0x10(%ebp)
    fac6:	e8 c4 88 ff ff       	call   838f <lodepng_chunk_type_equals>
    facb:	83 c4 10             	add    $0x10,%esp
    face:	84 c0                	test   %al,%al
    fad0:	74 44                	je     fb16 <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    fad2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fad5:	8b 55 14             	mov    0x14(%ebp),%edx
    fad8:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fade:	83 ec 04             	sub    $0x4,%esp
    fae1:	50                   	push   %eax
    fae2:	ff 75 d0             	pushl  -0x30(%ebp)
    fae5:	52                   	push   %edx
    fae6:	e8 ec e8 ff ff       	call   e3d7 <readChunk_PLTE>
    faeb:	83 c4 10             	add    $0x10,%esp
    faee:	89 c2                	mov    %eax,%edx
    faf0:	8b 45 14             	mov    0x14(%ebp),%eax
    faf3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    faf9:	8b 45 14             	mov    0x14(%ebp),%eax
    fafc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb02:	85 c0                	test   %eax,%eax
    fb04:	0f 85 dc 04 00 00    	jne    ffe6 <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
    fb0a:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    fb11:	e9 60 04 00 00       	jmp    ff76 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fb16:	83 ec 08             	sub    $0x8,%esp
    fb19:	68 0d a1 01 00       	push   $0x1a10d
    fb1e:	ff 75 f0             	pushl  -0x10(%ebp)
    fb21:	e8 69 88 ff ff       	call   838f <lodepng_chunk_type_equals>
    fb26:	83 c4 10             	add    $0x10,%esp
    fb29:	84 c0                	test   %al,%al
    fb2b:	74 3d                	je     fb6a <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    fb2d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb30:	8b 55 14             	mov    0x14(%ebp),%edx
    fb33:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fb39:	83 ec 04             	sub    $0x4,%esp
    fb3c:	50                   	push   %eax
    fb3d:	ff 75 d0             	pushl  -0x30(%ebp)
    fb40:	52                   	push   %edx
    fb41:	e8 b1 e9 ff ff       	call   e4f7 <readChunk_tRNS>
    fb46:	83 c4 10             	add    $0x10,%esp
    fb49:	89 c2                	mov    %eax,%edx
    fb4b:	8b 45 14             	mov    0x14(%ebp),%eax
    fb4e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fb54:	8b 45 14             	mov    0x14(%ebp),%eax
    fb57:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb5d:	85 c0                	test   %eax,%eax
    fb5f:	0f 84 11 04 00 00    	je     ff76 <decodeGeneric+0x731>
    fb65:	e9 80 04 00 00       	jmp    ffea <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    fb6a:	83 ec 08             	sub    $0x8,%esp
    fb6d:	68 12 a1 01 00       	push   $0x1a112
    fb72:	ff 75 f0             	pushl  -0x10(%ebp)
    fb75:	e8 15 88 ff ff       	call   838f <lodepng_chunk_type_equals>
    fb7a:	83 c4 10             	add    $0x10,%esp
    fb7d:	84 c0                	test   %al,%al
    fb7f:	74 3d                	je     fbbe <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fb81:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb84:	8b 55 14             	mov    0x14(%ebp),%edx
    fb87:	81 c2 98 00 00 00    	add    $0x98,%edx
    fb8d:	83 ec 04             	sub    $0x4,%esp
    fb90:	50                   	push   %eax
    fb91:	ff 75 d0             	pushl  -0x30(%ebp)
    fb94:	52                   	push   %edx
    fb95:	e8 c0 ea ff ff       	call   e65a <readChunk_bKGD>
    fb9a:	83 c4 10             	add    $0x10,%esp
    fb9d:	89 c2                	mov    %eax,%edx
    fb9f:	8b 45 14             	mov    0x14(%ebp),%eax
    fba2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fba8:	8b 45 14             	mov    0x14(%ebp),%eax
    fbab:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fbb1:	85 c0                	test   %eax,%eax
    fbb3:	0f 84 bd 03 00 00    	je     ff76 <decodeGeneric+0x731>
    fbb9:	e9 2c 04 00 00       	jmp    ffea <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fbbe:	83 ec 08             	sub    $0x8,%esp
    fbc1:	68 17 a1 01 00       	push   $0x1a117
    fbc6:	ff 75 f0             	pushl  -0x10(%ebp)
    fbc9:	e8 c1 87 ff ff       	call   838f <lodepng_chunk_type_equals>
    fbce:	83 c4 10             	add    $0x10,%esp
    fbd1:	84 c0                	test   %al,%al
    fbd3:	74 4b                	je     fc20 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
    fbd5:	8b 45 14             	mov    0x14(%ebp),%eax
    fbd8:	8b 40 28             	mov    0x28(%eax),%eax
    fbdb:	85 c0                	test   %eax,%eax
    fbdd:	0f 84 93 03 00 00    	je     ff76 <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
    fbe3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fbe6:	8b 55 14             	mov    0x14(%ebp),%edx
    fbe9:	81 c2 98 00 00 00    	add    $0x98,%edx
    fbef:	83 ec 04             	sub    $0x4,%esp
    fbf2:	50                   	push   %eax
    fbf3:	ff 75 d0             	pushl  -0x30(%ebp)
    fbf6:	52                   	push   %edx
    fbf7:	e8 e1 eb ff ff       	call   e7dd <readChunk_tEXt>
    fbfc:	83 c4 10             	add    $0x10,%esp
    fbff:	89 c2                	mov    %eax,%edx
    fc01:	8b 45 14             	mov    0x14(%ebp),%eax
    fc04:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fc0a:	8b 45 14             	mov    0x14(%ebp),%eax
    fc0d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc13:	85 c0                	test   %eax,%eax
    fc15:	0f 84 5b 03 00 00    	je     ff76 <decodeGeneric+0x731>
    fc1b:	e9 ca 03 00 00       	jmp    ffea <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    fc20:	83 ec 08             	sub    $0x8,%esp
    fc23:	68 1c a1 01 00       	push   $0x1a11c
    fc28:	ff 75 f0             	pushl  -0x10(%ebp)
    fc2b:	e8 5f 87 ff ff       	call   838f <lodepng_chunk_type_equals>
    fc30:	83 c4 10             	add    $0x10,%esp
    fc33:	84 c0                	test   %al,%al
    fc35:	74 4c                	je     fc83 <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
    fc37:	8b 45 14             	mov    0x14(%ebp),%eax
    fc3a:	8b 40 28             	mov    0x28(%eax),%eax
    fc3d:	85 c0                	test   %eax,%eax
    fc3f:	0f 84 31 03 00 00    	je     ff76 <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    fc45:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fc48:	8b 45 14             	mov    0x14(%ebp),%eax
    fc4b:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fc4e:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fc54:	52                   	push   %edx
    fc55:	ff 75 d0             	pushl  -0x30(%ebp)
    fc58:	50                   	push   %eax
    fc59:	51                   	push   %ecx
    fc5a:	e8 ca ec ff ff       	call   e929 <readChunk_zTXt>
    fc5f:	83 c4 10             	add    $0x10,%esp
    fc62:	89 c2                	mov    %eax,%edx
    fc64:	8b 45 14             	mov    0x14(%ebp),%eax
    fc67:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fc6d:	8b 45 14             	mov    0x14(%ebp),%eax
    fc70:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc76:	85 c0                	test   %eax,%eax
    fc78:	0f 84 f8 02 00 00    	je     ff76 <decodeGeneric+0x731>
    fc7e:	e9 67 03 00 00       	jmp    ffea <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    fc83:	83 ec 08             	sub    $0x8,%esp
    fc86:	68 21 a1 01 00       	push   $0x1a121
    fc8b:	ff 75 f0             	pushl  -0x10(%ebp)
    fc8e:	e8 fc 86 ff ff       	call   838f <lodepng_chunk_type_equals>
    fc93:	83 c4 10             	add    $0x10,%esp
    fc96:	84 c0                	test   %al,%al
    fc98:	74 4c                	je     fce6 <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
    fc9a:	8b 45 14             	mov    0x14(%ebp),%eax
    fc9d:	8b 40 28             	mov    0x28(%eax),%eax
    fca0:	85 c0                	test   %eax,%eax
    fca2:	0f 84 ce 02 00 00    	je     ff76 <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    fca8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fcab:	8b 45 14             	mov    0x14(%ebp),%eax
    fcae:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fcb1:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fcb7:	52                   	push   %edx
    fcb8:	ff 75 d0             	pushl  -0x30(%ebp)
    fcbb:	50                   	push   %eax
    fcbc:	51                   	push   %ecx
    fcbd:	e8 23 ee ff ff       	call   eae5 <readChunk_iTXt>
    fcc2:	83 c4 10             	add    $0x10,%esp
    fcc5:	89 c2                	mov    %eax,%edx
    fcc7:	8b 45 14             	mov    0x14(%ebp),%eax
    fcca:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fcd0:	8b 45 14             	mov    0x14(%ebp),%eax
    fcd3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fcd9:	85 c0                	test   %eax,%eax
    fcdb:	0f 84 95 02 00 00    	je     ff76 <decodeGeneric+0x731>
    fce1:	e9 04 03 00 00       	jmp    ffea <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    fce6:	83 ec 08             	sub    $0x8,%esp
    fce9:	68 26 a1 01 00       	push   $0x1a126
    fcee:	ff 75 f0             	pushl  -0x10(%ebp)
    fcf1:	e8 99 86 ff ff       	call   838f <lodepng_chunk_type_equals>
    fcf6:	83 c4 10             	add    $0x10,%esp
    fcf9:	84 c0                	test   %al,%al
    fcfb:	74 3d                	je     fd3a <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
    fcfd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd00:	8b 55 14             	mov    0x14(%ebp),%edx
    fd03:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd09:	83 ec 04             	sub    $0x4,%esp
    fd0c:	50                   	push   %eax
    fd0d:	ff 75 d0             	pushl  -0x30(%ebp)
    fd10:	52                   	push   %edx
    fd11:	e8 25 f1 ff ff       	call   ee3b <readChunk_tIME>
    fd16:	83 c4 10             	add    $0x10,%esp
    fd19:	89 c2                	mov    %eax,%edx
    fd1b:	8b 45 14             	mov    0x14(%ebp),%eax
    fd1e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd24:	8b 45 14             	mov    0x14(%ebp),%eax
    fd27:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd2d:	85 c0                	test   %eax,%eax
    fd2f:	0f 84 41 02 00 00    	je     ff76 <decodeGeneric+0x731>
    fd35:	e9 b0 02 00 00       	jmp    ffea <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    fd3a:	83 ec 08             	sub    $0x8,%esp
    fd3d:	68 2b a1 01 00       	push   $0x1a12b
    fd42:	ff 75 f0             	pushl  -0x10(%ebp)
    fd45:	e8 45 86 ff ff       	call   838f <lodepng_chunk_type_equals>
    fd4a:	83 c4 10             	add    $0x10,%esp
    fd4d:	84 c0                	test   %al,%al
    fd4f:	74 3d                	je     fd8e <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
    fd51:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd54:	8b 55 14             	mov    0x14(%ebp),%edx
    fd57:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd5d:	83 ec 04             	sub    $0x4,%esp
    fd60:	50                   	push   %eax
    fd61:	ff 75 d0             	pushl  -0x30(%ebp)
    fd64:	52                   	push   %edx
    fd65:	e8 71 f1 ff ff       	call   eedb <readChunk_pHYs>
    fd6a:	83 c4 10             	add    $0x10,%esp
    fd6d:	89 c2                	mov    %eax,%edx
    fd6f:	8b 45 14             	mov    0x14(%ebp),%eax
    fd72:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd78:	8b 45 14             	mov    0x14(%ebp),%eax
    fd7b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd81:	85 c0                	test   %eax,%eax
    fd83:	0f 84 ed 01 00 00    	je     ff76 <decodeGeneric+0x731>
    fd89:	e9 5c 02 00 00       	jmp    ffea <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    fd8e:	83 ec 08             	sub    $0x8,%esp
    fd91:	68 30 a1 01 00       	push   $0x1a130
    fd96:	ff 75 f0             	pushl  -0x10(%ebp)
    fd99:	e8 f1 85 ff ff       	call   838f <lodepng_chunk_type_equals>
    fd9e:	83 c4 10             	add    $0x10,%esp
    fda1:	84 c0                	test   %al,%al
    fda3:	74 3d                	je     fde2 <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
    fda5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fda8:	8b 55 14             	mov    0x14(%ebp),%edx
    fdab:	81 c2 98 00 00 00    	add    $0x98,%edx
    fdb1:	83 ec 04             	sub    $0x4,%esp
    fdb4:	50                   	push   %eax
    fdb5:	ff 75 d0             	pushl  -0x30(%ebp)
    fdb8:	52                   	push   %edx
    fdb9:	e8 ec f1 ff ff       	call   efaa <readChunk_gAMA>
    fdbe:	83 c4 10             	add    $0x10,%esp
    fdc1:	89 c2                	mov    %eax,%edx
    fdc3:	8b 45 14             	mov    0x14(%ebp),%eax
    fdc6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fdcc:	8b 45 14             	mov    0x14(%ebp),%eax
    fdcf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fdd5:	85 c0                	test   %eax,%eax
    fdd7:	0f 84 99 01 00 00    	je     ff76 <decodeGeneric+0x731>
    fddd:	e9 08 02 00 00       	jmp    ffea <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    fde2:	83 ec 08             	sub    $0x8,%esp
    fde5:	68 35 a1 01 00       	push   $0x1a135
    fdea:	ff 75 f0             	pushl  -0x10(%ebp)
    fded:	e8 9d 85 ff ff       	call   838f <lodepng_chunk_type_equals>
    fdf2:	83 c4 10             	add    $0x10,%esp
    fdf5:	84 c0                	test   %al,%al
    fdf7:	74 3d                	je     fe36 <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
    fdf9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fdfc:	8b 55 14             	mov    0x14(%ebp),%edx
    fdff:	81 c2 98 00 00 00    	add    $0x98,%edx
    fe05:	83 ec 04             	sub    $0x4,%esp
    fe08:	50                   	push   %eax
    fe09:	ff 75 d0             	pushl  -0x30(%ebp)
    fe0c:	52                   	push   %edx
    fe0d:	e8 07 f2 ff ff       	call   f019 <readChunk_cHRM>
    fe12:	83 c4 10             	add    $0x10,%esp
    fe15:	89 c2                	mov    %eax,%edx
    fe17:	8b 45 14             	mov    0x14(%ebp),%eax
    fe1a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe20:	8b 45 14             	mov    0x14(%ebp),%eax
    fe23:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe29:	85 c0                	test   %eax,%eax
    fe2b:	0f 84 45 01 00 00    	je     ff76 <decodeGeneric+0x731>
    fe31:	e9 b4 01 00 00       	jmp    ffea <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    fe36:	83 ec 08             	sub    $0x8,%esp
    fe39:	68 3a a1 01 00       	push   $0x1a13a
    fe3e:	ff 75 f0             	pushl  -0x10(%ebp)
    fe41:	e8 49 85 ff ff       	call   838f <lodepng_chunk_type_equals>
    fe46:	83 c4 10             	add    $0x10,%esp
    fe49:	84 c0                	test   %al,%al
    fe4b:	74 3d                	je     fe8a <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
    fe4d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fe50:	8b 55 14             	mov    0x14(%ebp),%edx
    fe53:	81 c2 98 00 00 00    	add    $0x98,%edx
    fe59:	83 ec 04             	sub    $0x4,%esp
    fe5c:	50                   	push   %eax
    fe5d:	ff 75 d0             	pushl  -0x30(%ebp)
    fe60:	52                   	push   %edx
    fe61:	e8 47 f4 ff ff       	call   f2ad <readChunk_sRGB>
    fe66:	83 c4 10             	add    $0x10,%esp
    fe69:	89 c2                	mov    %eax,%edx
    fe6b:	8b 45 14             	mov    0x14(%ebp),%eax
    fe6e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe74:	8b 45 14             	mov    0x14(%ebp),%eax
    fe77:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe7d:	85 c0                	test   %eax,%eax
    fe7f:	0f 84 f1 00 00 00    	je     ff76 <decodeGeneric+0x731>
    fe85:	e9 60 01 00 00       	jmp    ffea <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    fe8a:	83 ec 08             	sub    $0x8,%esp
    fe8d:	68 3f a1 01 00       	push   $0x1a13f
    fe92:	ff 75 f0             	pushl  -0x10(%ebp)
    fe95:	e8 f5 84 ff ff       	call   838f <lodepng_chunk_type_equals>
    fe9a:	83 c4 10             	add    $0x10,%esp
    fe9d:	84 c0                	test   %al,%al
    fe9f:	74 3e                	je     fedf <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    fea1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fea4:	8b 45 14             	mov    0x14(%ebp),%eax
    fea7:	8b 4d 14             	mov    0x14(%ebp),%ecx
    feaa:	81 c1 98 00 00 00    	add    $0x98,%ecx
    feb0:	52                   	push   %edx
    feb1:	ff 75 d0             	pushl  -0x30(%ebp)
    feb4:	50                   	push   %eax
    feb5:	51                   	push   %ecx
    feb6:	e8 28 f4 ff ff       	call   f2e3 <readChunk_iCCP>
    febb:	83 c4 10             	add    $0x10,%esp
    febe:	89 c2                	mov    %eax,%edx
    fec0:	8b 45 14             	mov    0x14(%ebp),%eax
    fec3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fec9:	8b 45 14             	mov    0x14(%ebp),%eax
    fecc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fed2:	85 c0                	test   %eax,%eax
    fed4:	0f 84 9c 00 00 00    	je     ff76 <decodeGeneric+0x731>
    feda:	e9 0b 01 00 00       	jmp    ffea <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
    fedf:	8b 45 14             	mov    0x14(%ebp),%eax
    fee2:	8b 40 1c             	mov    0x1c(%eax),%eax
    fee5:	85 c0                	test   %eax,%eax
    fee7:	75 24                	jne    ff0d <decodeGeneric+0x6c8>
    fee9:	83 ec 0c             	sub    $0xc,%esp
    feec:	ff 75 f0             	pushl  -0x10(%ebp)
    feef:	e8 30 85 ff ff       	call   8424 <lodepng_chunk_ancillary>
    fef4:	83 c4 10             	add    $0x10,%esp
    fef7:	84 c0                	test   %al,%al
    fef9:	75 12                	jne    ff0d <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
    fefb:	8b 45 14             	mov    0x14(%ebp),%eax
    fefe:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
    ff05:	00 00 00 
    ff08:	e9 dd 00 00 00       	jmp    ffea <decodeGeneric+0x7a5>
      }

      unknown = 1;
    ff0d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
    ff14:	8b 45 14             	mov    0x14(%ebp),%eax
    ff17:	8b 40 2c             	mov    0x2c(%eax),%eax
    ff1a:	85 c0                	test   %eax,%eax
    ff1c:	74 58                	je     ff76 <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
    ff1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ff21:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
    ff24:	83 c0 58             	add    $0x58,%eax
    ff27:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ff2e:	8b 45 14             	mov    0x14(%ebp),%eax
    ff31:	01 d0                	add    %edx,%eax
    ff33:	8d 50 10             	lea    0x10(%eax),%edx
    ff36:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ff39:	83 e8 01             	sub    $0x1,%eax
    ff3c:	83 c0 54             	add    $0x54,%eax
    ff3f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    ff46:	8b 45 14             	mov    0x14(%ebp),%eax
    ff49:	01 c8                	add    %ecx,%eax
    ff4b:	83 c0 14             	add    $0x14,%eax
    ff4e:	83 ec 04             	sub    $0x4,%esp
    ff51:	ff 75 f0             	pushl  -0x10(%ebp)
    ff54:	52                   	push   %edx
    ff55:	50                   	push   %eax
    ff56:	e8 15 88 ff ff       	call   8770 <lodepng_chunk_append>
    ff5b:	83 c4 10             	add    $0x10,%esp
    ff5e:	89 c2                	mov    %eax,%edx
    ff60:	8b 45 14             	mov    0x14(%ebp),%eax
    ff63:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    ff69:	8b 45 14             	mov    0x14(%ebp),%eax
    ff6c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff72:	85 c0                	test   %eax,%eax
    ff74:	75 73                	jne    ffe9 <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
    ff76:	8b 45 14             	mov    0x14(%ebp),%eax
    ff79:	8b 40 18             	mov    0x18(%eax),%eax
    ff7c:	85 c0                	test   %eax,%eax
    ff7e:	75 27                	jne    ffa7 <decodeGeneric+0x762>
    ff80:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ff84:	75 21                	jne    ffa7 <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
    ff86:	83 ec 0c             	sub    $0xc,%esp
    ff89:	ff 75 f0             	pushl  -0x10(%ebp)
    ff8c:	e8 f4 84 ff ff       	call   8485 <lodepng_chunk_check_crc>
    ff91:	83 c4 10             	add    $0x10,%esp
    ff94:	85 c0                	test   %eax,%eax
    ff96:	74 0f                	je     ffa7 <decodeGeneric+0x762>
    ff98:	8b 45 14             	mov    0x14(%ebp),%eax
    ff9b:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    ffa2:	00 00 00 
    ffa5:	eb 43                	jmp    ffea <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
    ffa7:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    ffab:	75 1a                	jne    ffc7 <decodeGeneric+0x782>
    ffad:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ffb0:	8b 45 18             	mov    0x18(%ebp),%eax
    ffb3:	01 d0                	add    %edx,%eax
    ffb5:	83 ec 08             	sub    $0x8,%esp
    ffb8:	50                   	push   %eax
    ffb9:	ff 75 f0             	pushl  -0x10(%ebp)
    ffbc:	e8 3f 86 ff ff       	call   8600 <lodepng_chunk_next_const>
    ffc1:	83 c4 10             	add    $0x10,%esp
    ffc4:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    ffc7:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    ffcb:	75 1d                	jne    ffea <decodeGeneric+0x7a5>
    ffcd:	8b 45 14             	mov    0x14(%ebp),%eax
    ffd0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ffd6:	85 c0                	test   %eax,%eax
    ffd8:	0f 84 68 f9 ff ff    	je     f946 <decodeGeneric+0x101>
    ffde:	eb 0a                	jmp    ffea <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ffe0:	90                   	nop
    ffe1:	eb 07                	jmp    ffea <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ffe3:	90                   	nop
    ffe4:	eb 04                	jmp    ffea <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
    ffe6:	90                   	nop
    ffe7:	eb 01                	jmp    ffea <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    ffe9:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
    ffea:	8b 45 14             	mov    0x14(%ebp),%eax
    ffed:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fff3:	85 c0                	test   %eax,%eax
    fff5:	75 28                	jne    1001f <decodeGeneric+0x7da>
    fff7:	8b 45 14             	mov    0x14(%ebp),%eax
    fffa:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   10000:	83 f8 03             	cmp    $0x3,%eax
   10003:	75 1a                	jne    1001f <decodeGeneric+0x7da>
   10005:	8b 45 14             	mov    0x14(%ebp),%eax
   10008:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   1000e:	85 c0                	test   %eax,%eax
   10010:	75 0d                	jne    1001f <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   10012:	8b 45 14             	mov    0x14(%ebp),%eax
   10015:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   1001c:	00 00 00 
  }

  if(!state->error) {
   1001f:	8b 45 14             	mov    0x14(%ebp),%eax
   10022:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10028:	85 c0                	test   %eax,%eax
   1002a:	0f 85 d2 01 00 00    	jne    10202 <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   10030:	8b 45 14             	mov    0x14(%ebp),%eax
   10033:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   10039:	85 c0                	test   %eax,%eax
   1003b:	75 3a                	jne    10077 <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   1003d:	8b 45 14             	mov    0x14(%ebp),%eax
   10040:	05 a4 00 00 00       	add    $0xa4,%eax
   10045:	83 ec 0c             	sub    $0xc,%esp
   10048:	50                   	push   %eax
   10049:	e8 8e 8e ff ff       	call   8edc <lodepng_get_bpp>
   1004e:	83 c4 10             	add    $0x10,%esp
   10051:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   10054:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   10057:	8b 45 10             	mov    0x10(%ebp),%eax
   1005a:	8b 10                	mov    (%eax),%edx
   1005c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1005f:	8b 00                	mov    (%eax),%eax
   10061:	83 ec 04             	sub    $0x4,%esp
   10064:	51                   	push   %ecx
   10065:	52                   	push   %edx
   10066:	50                   	push   %eax
   10067:	e8 cf 8f ff ff       	call   903b <lodepng_get_raw_size_idat>
   1006c:	83 c4 10             	add    $0x10,%esp
   1006f:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10072:	e9 60 01 00 00       	jmp    101d7 <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   10077:	8b 45 14             	mov    0x14(%ebp),%eax
   1007a:	05 a4 00 00 00       	add    $0xa4,%eax
   1007f:	83 ec 0c             	sub    $0xc,%esp
   10082:	50                   	push   %eax
   10083:	e8 54 8e ff ff       	call   8edc <lodepng_get_bpp>
   10088:	83 c4 10             	add    $0x10,%esp
   1008b:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   1008e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   10095:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10098:	8b 55 10             	mov    0x10(%ebp),%edx
   1009b:	8b 12                	mov    (%edx),%edx
   1009d:	83 c2 07             	add    $0x7,%edx
   100a0:	89 d1                	mov    %edx,%ecx
   100a2:	c1 e9 03             	shr    $0x3,%ecx
   100a5:	8b 55 0c             	mov    0xc(%ebp),%edx
   100a8:	8b 12                	mov    (%edx),%edx
   100aa:	83 c2 07             	add    $0x7,%edx
   100ad:	c1 ea 03             	shr    $0x3,%edx
   100b0:	83 ec 04             	sub    $0x4,%esp
   100b3:	50                   	push   %eax
   100b4:	51                   	push   %ecx
   100b5:	52                   	push   %edx
   100b6:	e8 80 8f ff ff       	call   903b <lodepng_get_raw_size_idat>
   100bb:	83 c4 10             	add    $0x10,%esp
   100be:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   100c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   100c4:	8b 00                	mov    (%eax),%eax
   100c6:	83 f8 04             	cmp    $0x4,%eax
   100c9:	76 2c                	jbe    100f7 <decodeGeneric+0x8b2>
   100cb:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100ce:	8b 55 10             	mov    0x10(%ebp),%edx
   100d1:	8b 12                	mov    (%edx),%edx
   100d3:	83 c2 07             	add    $0x7,%edx
   100d6:	89 d1                	mov    %edx,%ecx
   100d8:	c1 e9 03             	shr    $0x3,%ecx
   100db:	8b 55 0c             	mov    0xc(%ebp),%edx
   100de:	8b 12                	mov    (%edx),%edx
   100e0:	83 c2 03             	add    $0x3,%edx
   100e3:	c1 ea 03             	shr    $0x3,%edx
   100e6:	83 ec 04             	sub    $0x4,%esp
   100e9:	50                   	push   %eax
   100ea:	51                   	push   %ecx
   100eb:	52                   	push   %edx
   100ec:	e8 4a 8f ff ff       	call   903b <lodepng_get_raw_size_idat>
   100f1:	83 c4 10             	add    $0x10,%esp
   100f4:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   100f7:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100fa:	8b 55 10             	mov    0x10(%ebp),%edx
   100fd:	8b 12                	mov    (%edx),%edx
   100ff:	83 c2 03             	add    $0x3,%edx
   10102:	89 d1                	mov    %edx,%ecx
   10104:	c1 e9 03             	shr    $0x3,%ecx
   10107:	8b 55 0c             	mov    0xc(%ebp),%edx
   1010a:	8b 12                	mov    (%edx),%edx
   1010c:	83 c2 03             	add    $0x3,%edx
   1010f:	c1 ea 02             	shr    $0x2,%edx
   10112:	83 ec 04             	sub    $0x4,%esp
   10115:	50                   	push   %eax
   10116:	51                   	push   %ecx
   10117:	52                   	push   %edx
   10118:	e8 1e 8f ff ff       	call   903b <lodepng_get_raw_size_idat>
   1011d:	83 c4 10             	add    $0x10,%esp
   10120:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   10123:	8b 45 0c             	mov    0xc(%ebp),%eax
   10126:	8b 00                	mov    (%eax),%eax
   10128:	83 f8 02             	cmp    $0x2,%eax
   1012b:	76 2c                	jbe    10159 <decodeGeneric+0x914>
   1012d:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10130:	8b 55 10             	mov    0x10(%ebp),%edx
   10133:	8b 12                	mov    (%edx),%edx
   10135:	83 c2 03             	add    $0x3,%edx
   10138:	89 d1                	mov    %edx,%ecx
   1013a:	c1 e9 02             	shr    $0x2,%ecx
   1013d:	8b 55 0c             	mov    0xc(%ebp),%edx
   10140:	8b 12                	mov    (%edx),%edx
   10142:	83 c2 01             	add    $0x1,%edx
   10145:	c1 ea 02             	shr    $0x2,%edx
   10148:	83 ec 04             	sub    $0x4,%esp
   1014b:	50                   	push   %eax
   1014c:	51                   	push   %ecx
   1014d:	52                   	push   %edx
   1014e:	e8 e8 8e ff ff       	call   903b <lodepng_get_raw_size_idat>
   10153:	83 c4 10             	add    $0x10,%esp
   10156:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   10159:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1015c:	8b 55 10             	mov    0x10(%ebp),%edx
   1015f:	8b 12                	mov    (%edx),%edx
   10161:	83 c2 01             	add    $0x1,%edx
   10164:	89 d1                	mov    %edx,%ecx
   10166:	c1 e9 02             	shr    $0x2,%ecx
   10169:	8b 55 0c             	mov    0xc(%ebp),%edx
   1016c:	8b 12                	mov    (%edx),%edx
   1016e:	83 c2 01             	add    $0x1,%edx
   10171:	d1 ea                	shr    %edx
   10173:	83 ec 04             	sub    $0x4,%esp
   10176:	50                   	push   %eax
   10177:	51                   	push   %ecx
   10178:	52                   	push   %edx
   10179:	e8 bd 8e ff ff       	call   903b <lodepng_get_raw_size_idat>
   1017e:	83 c4 10             	add    $0x10,%esp
   10181:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   10184:	8b 45 0c             	mov    0xc(%ebp),%eax
   10187:	8b 00                	mov    (%eax),%eax
   10189:	83 f8 01             	cmp    $0x1,%eax
   1018c:	76 27                	jbe    101b5 <decodeGeneric+0x970>
   1018e:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10191:	8b 55 10             	mov    0x10(%ebp),%edx
   10194:	8b 12                	mov    (%edx),%edx
   10196:	83 c2 01             	add    $0x1,%edx
   10199:	89 d1                	mov    %edx,%ecx
   1019b:	d1 e9                	shr    %ecx
   1019d:	8b 55 0c             	mov    0xc(%ebp),%edx
   101a0:	8b 12                	mov    (%edx),%edx
   101a2:	d1 ea                	shr    %edx
   101a4:	83 ec 04             	sub    $0x4,%esp
   101a7:	50                   	push   %eax
   101a8:	51                   	push   %ecx
   101a9:	52                   	push   %edx
   101aa:	e8 8c 8e ff ff       	call   903b <lodepng_get_raw_size_idat>
   101af:	83 c4 10             	add    $0x10,%esp
   101b2:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   101b5:	8b 55 c8             	mov    -0x38(%ebp),%edx
   101b8:	8b 45 10             	mov    0x10(%ebp),%eax
   101bb:	8b 00                	mov    (%eax),%eax
   101bd:	d1 e8                	shr    %eax
   101bf:	89 c1                	mov    %eax,%ecx
   101c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   101c4:	8b 00                	mov    (%eax),%eax
   101c6:	83 ec 04             	sub    $0x4,%esp
   101c9:	52                   	push   %edx
   101ca:	51                   	push   %ecx
   101cb:	50                   	push   %eax
   101cc:	e8 6a 8e ff ff       	call   903b <lodepng_get_raw_size_idat>
   101d1:	83 c4 10             	add    $0x10,%esp
   101d4:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   101d7:	8b 45 14             	mov    0x14(%ebp),%eax
   101da:	83 ec 08             	sub    $0x8,%esp
   101dd:	50                   	push   %eax
   101de:	ff 75 ec             	pushl  -0x14(%ebp)
   101e1:	ff 75 d8             	pushl  -0x28(%ebp)
   101e4:	ff 75 e8             	pushl  -0x18(%ebp)
   101e7:	8d 45 c0             	lea    -0x40(%ebp),%eax
   101ea:	50                   	push   %eax
   101eb:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   101ee:	50                   	push   %eax
   101ef:	e8 87 7c ff ff       	call   7e7b <zlib_decompress>
   101f4:	83 c4 20             	add    $0x20,%esp
   101f7:	89 c2                	mov    %eax,%edx
   101f9:	8b 45 14             	mov    0x14(%ebp),%eax
   101fc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   10202:	8b 45 14             	mov    0x14(%ebp),%eax
   10205:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1020b:	85 c0                	test   %eax,%eax
   1020d:	75 15                	jne    10224 <decodeGeneric+0x9df>
   1020f:	8b 45 c0             	mov    -0x40(%ebp),%eax
   10212:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   10215:	74 0d                	je     10224 <decodeGeneric+0x9df>
   10217:	8b 45 14             	mov    0x14(%ebp),%eax
   1021a:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   10221:	00 00 00 
  lodepng_free(idat);
   10224:	83 ec 0c             	sub    $0xc,%esp
   10227:	ff 75 d8             	pushl  -0x28(%ebp)
   1022a:	e8 b2 31 ff ff       	call   33e1 <lodepng_free>
   1022f:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   10232:	8b 45 14             	mov    0x14(%ebp),%eax
   10235:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1023b:	85 c0                	test   %eax,%eax
   1023d:	75 4f                	jne    1028e <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   1023f:	8b 45 14             	mov    0x14(%ebp),%eax
   10242:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   10248:	8b 45 10             	mov    0x10(%ebp),%eax
   1024b:	8b 10                	mov    (%eax),%edx
   1024d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10250:	8b 00                	mov    (%eax),%eax
   10252:	83 ec 04             	sub    $0x4,%esp
   10255:	51                   	push   %ecx
   10256:	52                   	push   %edx
   10257:	50                   	push   %eax
   10258:	e8 be 8d ff ff       	call   901b <lodepng_get_raw_size>
   1025d:	83 c4 10             	add    $0x10,%esp
   10260:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10263:	83 ec 0c             	sub    $0xc,%esp
   10266:	ff 75 e4             	pushl  -0x1c(%ebp)
   10269:	e8 52 31 ff ff       	call   33c0 <lodepng_malloc>
   1026e:	83 c4 10             	add    $0x10,%esp
   10271:	89 c2                	mov    %eax,%edx
   10273:	8b 45 08             	mov    0x8(%ebp),%eax
   10276:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   10278:	8b 45 08             	mov    0x8(%ebp),%eax
   1027b:	8b 00                	mov    (%eax),%eax
   1027d:	85 c0                	test   %eax,%eax
   1027f:	75 0d                	jne    1028e <decodeGeneric+0xa49>
   10281:	8b 45 14             	mov    0x14(%ebp),%eax
   10284:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   1028b:	00 00 00 
  }
  if(!state->error) {
   1028e:	8b 45 14             	mov    0x14(%ebp),%eax
   10291:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10297:	85 c0                	test   %eax,%eax
   10299:	75 4c                	jne    102e7 <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   1029b:	8b 45 08             	mov    0x8(%ebp),%eax
   1029e:	8b 00                	mov    (%eax),%eax
   102a0:	83 ec 04             	sub    $0x4,%esp
   102a3:	ff 75 e4             	pushl  -0x1c(%ebp)
   102a6:	6a 00                	push   $0x0
   102a8:	50                   	push   %eax
   102a9:	e8 83 31 ff ff       	call   3431 <lodepng_memset>
   102ae:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   102b1:	8b 45 14             	mov    0x14(%ebp),%eax
   102b4:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   102ba:	8b 45 10             	mov    0x10(%ebp),%eax
   102bd:	8b 18                	mov    (%eax),%ebx
   102bf:	8b 45 0c             	mov    0xc(%ebp),%eax
   102c2:	8b 08                	mov    (%eax),%ecx
   102c4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   102c7:	8b 45 08             	mov    0x8(%ebp),%eax
   102ca:	8b 00                	mov    (%eax),%eax
   102cc:	83 ec 0c             	sub    $0xc,%esp
   102cf:	56                   	push   %esi
   102d0:	53                   	push   %ebx
   102d1:	51                   	push   %ecx
   102d2:	52                   	push   %edx
   102d3:	50                   	push   %eax
   102d4:	e8 05 df ff ff       	call   e1de <postProcessScanlines>
   102d9:	83 c4 20             	add    $0x20,%esp
   102dc:	89 c2                	mov    %eax,%edx
   102de:	8b 45 14             	mov    0x14(%ebp),%eax
   102e1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   102e7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   102ea:	83 ec 0c             	sub    $0xc,%esp
   102ed:	50                   	push   %eax
   102ee:	e8 ee 30 ff ff       	call   33e1 <lodepng_free>
   102f3:	83 c4 10             	add    $0x10,%esp
   102f6:	eb 01                	jmp    102f9 <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   102f8:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   102f9:	8d 65 f8             	lea    -0x8(%ebp),%esp
   102fc:	5b                   	pop    %ebx
   102fd:	5e                   	pop    %esi
   102fe:	5d                   	pop    %ebp
   102ff:	c3                   	ret    

00010300 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   10300:	55                   	push   %ebp
   10301:	89 e5                	mov    %esp,%ebp
   10303:	56                   	push   %esi
   10304:	53                   	push   %ebx
   10305:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   10308:	8b 45 08             	mov    0x8(%ebp),%eax
   1030b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   10311:	83 ec 08             	sub    $0x8,%esp
   10314:	ff 75 1c             	pushl  0x1c(%ebp)
   10317:	ff 75 18             	pushl  0x18(%ebp)
   1031a:	ff 75 14             	pushl  0x14(%ebp)
   1031d:	ff 75 10             	pushl  0x10(%ebp)
   10320:	ff 75 0c             	pushl  0xc(%ebp)
   10323:	ff 75 08             	pushl  0x8(%ebp)
   10326:	e8 1a f5 ff ff       	call   f845 <decodeGeneric>
   1032b:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   1032e:	8b 45 14             	mov    0x14(%ebp),%eax
   10331:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10337:	85 c0                	test   %eax,%eax
   10339:	74 0e                	je     10349 <lodepng_decode+0x49>
   1033b:	8b 45 14             	mov    0x14(%ebp),%eax
   1033e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10344:	e9 55 01 00 00       	jmp    1049e <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   10349:	8b 45 14             	mov    0x14(%ebp),%eax
   1034c:	8b 40 24             	mov    0x24(%eax),%eax
   1034f:	85 c0                	test   %eax,%eax
   10351:	74 20                	je     10373 <lodepng_decode+0x73>
   10353:	8b 45 14             	mov    0x14(%ebp),%eax
   10356:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   1035c:	8b 45 14             	mov    0x14(%ebp),%eax
   1035f:	83 c0 78             	add    $0x78,%eax
   10362:	83 ec 08             	sub    $0x8,%esp
   10365:	52                   	push   %edx
   10366:	50                   	push   %eax
   10367:	e8 56 89 ff ff       	call   8cc2 <lodepng_color_mode_equal>
   1036c:	83 c4 10             	add    $0x10,%esp
   1036f:	85 c0                	test   %eax,%eax
   10371:	74 54                	je     103c7 <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   10373:	8b 45 14             	mov    0x14(%ebp),%eax
   10376:	8b 40 24             	mov    0x24(%eax),%eax
   10379:	85 c0                	test   %eax,%eax
   1037b:	0f 85 13 01 00 00    	jne    10494 <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   10381:	8b 45 14             	mov    0x14(%ebp),%eax
   10384:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   1038a:	8b 45 14             	mov    0x14(%ebp),%eax
   1038d:	83 c0 78             	add    $0x78,%eax
   10390:	83 ec 08             	sub    $0x8,%esp
   10393:	52                   	push   %edx
   10394:	50                   	push   %eax
   10395:	e8 3f 88 ff ff       	call   8bd9 <lodepng_color_mode_copy>
   1039a:	83 c4 10             	add    $0x10,%esp
   1039d:	89 c2                	mov    %eax,%edx
   1039f:	8b 45 14             	mov    0x14(%ebp),%eax
   103a2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   103a8:	8b 45 14             	mov    0x14(%ebp),%eax
   103ab:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   103b1:	85 c0                	test   %eax,%eax
   103b3:	0f 84 db 00 00 00    	je     10494 <lodepng_decode+0x194>
   103b9:	8b 45 14             	mov    0x14(%ebp),%eax
   103bc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   103c2:	e9 d7 00 00 00       	jmp    1049e <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   103c7:	8b 45 08             	mov    0x8(%ebp),%eax
   103ca:	8b 00                	mov    (%eax),%eax
   103cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   103cf:	8b 45 14             	mov    0x14(%ebp),%eax
   103d2:	8b 40 78             	mov    0x78(%eax),%eax
   103d5:	83 f8 02             	cmp    $0x2,%eax
   103d8:	74 20                	je     103fa <lodepng_decode+0xfa>
   103da:	8b 45 14             	mov    0x14(%ebp),%eax
   103dd:	8b 40 78             	mov    0x78(%eax),%eax
   103e0:	83 f8 06             	cmp    $0x6,%eax
   103e3:	74 15                	je     103fa <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   103e5:	8b 45 14             	mov    0x14(%ebp),%eax
   103e8:	8b 40 7c             	mov    0x7c(%eax),%eax
   103eb:	83 f8 08             	cmp    $0x8,%eax
   103ee:	74 0a                	je     103fa <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   103f0:	b8 38 00 00 00       	mov    $0x38,%eax
   103f5:	e9 a4 00 00 00       	jmp    1049e <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   103fa:	8b 45 14             	mov    0x14(%ebp),%eax
   103fd:	8d 48 78             	lea    0x78(%eax),%ecx
   10400:	8b 45 10             	mov    0x10(%ebp),%eax
   10403:	8b 10                	mov    (%eax),%edx
   10405:	8b 45 0c             	mov    0xc(%ebp),%eax
   10408:	8b 00                	mov    (%eax),%eax
   1040a:	83 ec 04             	sub    $0x4,%esp
   1040d:	51                   	push   %ecx
   1040e:	52                   	push   %edx
   1040f:	50                   	push   %eax
   10410:	e8 06 8c ff ff       	call   901b <lodepng_get_raw_size>
   10415:	83 c4 10             	add    $0x10,%esp
   10418:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   1041b:	83 ec 0c             	sub    $0xc,%esp
   1041e:	ff 75 f0             	pushl  -0x10(%ebp)
   10421:	e8 9a 2f ff ff       	call   33c0 <lodepng_malloc>
   10426:	83 c4 10             	add    $0x10,%esp
   10429:	89 c2                	mov    %eax,%edx
   1042b:	8b 45 08             	mov    0x8(%ebp),%eax
   1042e:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   10430:	8b 45 08             	mov    0x8(%ebp),%eax
   10433:	8b 00                	mov    (%eax),%eax
   10435:	85 c0                	test   %eax,%eax
   10437:	75 0f                	jne    10448 <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   10439:	8b 45 14             	mov    0x14(%ebp),%eax
   1043c:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   10443:	00 00 00 
   10446:	eb 3c                	jmp    10484 <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   10448:	8b 45 10             	mov    0x10(%ebp),%eax
   1044b:	8b 08                	mov    (%eax),%ecx
   1044d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10450:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   10452:	8b 45 14             	mov    0x14(%ebp),%eax
   10455:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   1045b:	8b 45 14             	mov    0x14(%ebp),%eax
   1045e:	8d 58 78             	lea    0x78(%eax),%ebx
   10461:	8b 45 08             	mov    0x8(%ebp),%eax
   10464:	8b 00                	mov    (%eax),%eax
   10466:	83 ec 08             	sub    $0x8,%esp
   10469:	51                   	push   %ecx
   1046a:	52                   	push   %edx
   1046b:	56                   	push   %esi
   1046c:	53                   	push   %ebx
   1046d:	ff 75 f4             	pushl  -0xc(%ebp)
   10470:	50                   	push   %eax
   10471:	e8 51 b6 ff ff       	call   bac7 <lodepng_convert>
   10476:	83 c4 20             	add    $0x20,%esp
   10479:	89 c2                	mov    %eax,%edx
   1047b:	8b 45 14             	mov    0x14(%ebp),%eax
   1047e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   10484:	83 ec 0c             	sub    $0xc,%esp
   10487:	ff 75 f4             	pushl  -0xc(%ebp)
   1048a:	e8 52 2f ff ff       	call   33e1 <lodepng_free>
   1048f:	83 c4 10             	add    $0x10,%esp
   10492:	eb 01                	jmp    10495 <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   10494:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   10495:	8b 45 14             	mov    0x14(%ebp),%eax
   10498:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   1049e:	8d 65 f8             	lea    -0x8(%ebp),%esp
   104a1:	5b                   	pop    %ebx
   104a2:	5e                   	pop    %esi
   104a3:	5d                   	pop    %ebp
   104a4:	c3                   	ret    

000104a5 <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   104a5:	55                   	push   %ebp
   104a6:	89 e5                	mov    %esp,%ebp
   104a8:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   104ae:	83 ec 0c             	sub    $0xc,%esp
   104b1:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   104b7:	50                   	push   %eax
   104b8:	e8 d9 01 00 00       	call   10696 <lodepng_state_init>
   104bd:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   104c0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   104c3:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   104c9:	8b 45 20             	mov    0x20(%ebp),%eax
   104cc:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   104d2:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   104d9:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   104dc:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   104e3:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   104e6:	83 ec 08             	sub    $0x8,%esp
   104e9:	ff 75 18             	pushl  0x18(%ebp)
   104ec:	ff 75 14             	pushl  0x14(%ebp)
   104ef:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   104f5:	50                   	push   %eax
   104f6:	ff 75 10             	pushl  0x10(%ebp)
   104f9:	ff 75 0c             	pushl  0xc(%ebp)
   104fc:	ff 75 08             	pushl  0x8(%ebp)
   104ff:	e8 fc fd ff ff       	call   10300 <lodepng_decode>
   10504:	83 c4 20             	add    $0x20,%esp
   10507:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   1050a:	83 ec 0c             	sub    $0xc,%esp
   1050d:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10513:	50                   	push   %eax
   10514:	e8 d7 01 00 00       	call   106f0 <lodepng_state_cleanup>
   10519:	83 c4 10             	add    $0x10,%esp
  return error;
   1051c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1051f:	c9                   	leave  
   10520:	c3                   	ret    

00010521 <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10521:	55                   	push   %ebp
   10522:	89 e5                	mov    %esp,%ebp
   10524:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   10527:	83 ec 04             	sub    $0x4,%esp
   1052a:	6a 08                	push   $0x8
   1052c:	6a 06                	push   $0x6
   1052e:	ff 75 18             	pushl  0x18(%ebp)
   10531:	ff 75 14             	pushl  0x14(%ebp)
   10534:	ff 75 10             	pushl  0x10(%ebp)
   10537:	ff 75 0c             	pushl  0xc(%ebp)
   1053a:	ff 75 08             	pushl  0x8(%ebp)
   1053d:	e8 63 ff ff ff       	call   104a5 <lodepng_decode_memory>
   10542:	83 c4 20             	add    $0x20,%esp
}
   10545:	c9                   	leave  
   10546:	c3                   	ret    

00010547 <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10547:	55                   	push   %ebp
   10548:	89 e5                	mov    %esp,%ebp
   1054a:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   1054d:	83 ec 04             	sub    $0x4,%esp
   10550:	6a 08                	push   $0x8
   10552:	6a 02                	push   $0x2
   10554:	ff 75 18             	pushl  0x18(%ebp)
   10557:	ff 75 14             	pushl  0x14(%ebp)
   1055a:	ff 75 10             	pushl  0x10(%ebp)
   1055d:	ff 75 0c             	pushl  0xc(%ebp)
   10560:	ff 75 08             	pushl  0x8(%ebp)
   10563:	e8 3d ff ff ff       	call   104a5 <lodepng_decode_memory>
   10568:	83 c4 20             	add    $0x20,%esp
}
   1056b:	c9                   	leave  
   1056c:	c3                   	ret    

0001056d <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   1056d:	55                   	push   %ebp
   1056e:	89 e5                	mov    %esp,%ebp
   10570:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   10573:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   1057a:	8b 45 08             	mov    0x8(%ebp),%eax
   1057d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   10583:	8b 45 10             	mov    0x10(%ebp),%eax
   10586:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1058c:	8b 45 10             	mov    0x10(%ebp),%eax
   1058f:	8b 10                	mov    (%eax),%edx
   10591:	8b 45 0c             	mov    0xc(%ebp),%eax
   10594:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   10596:	83 ec 04             	sub    $0x4,%esp
   10599:	ff 75 14             	pushl  0x14(%ebp)
   1059c:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1059f:	50                   	push   %eax
   105a0:	8d 45 f0             	lea    -0x10(%ebp),%eax
   105a3:	50                   	push   %eax
   105a4:	e8 70 32 ff ff       	call   3819 <lodepng_load_file>
   105a9:	83 c4 10             	add    $0x10,%esp
   105ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   105af:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   105b3:	75 25                	jne    105da <lodepng_decode_file+0x6d>
   105b5:	8b 55 ec             	mov    -0x14(%ebp),%edx
   105b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105bb:	83 ec 04             	sub    $0x4,%esp
   105be:	ff 75 1c             	pushl  0x1c(%ebp)
   105c1:	ff 75 18             	pushl  0x18(%ebp)
   105c4:	52                   	push   %edx
   105c5:	50                   	push   %eax
   105c6:	ff 75 10             	pushl  0x10(%ebp)
   105c9:	ff 75 0c             	pushl  0xc(%ebp)
   105cc:	ff 75 08             	pushl  0x8(%ebp)
   105cf:	e8 d1 fe ff ff       	call   104a5 <lodepng_decode_memory>
   105d4:	83 c4 20             	add    $0x20,%esp
   105d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   105da:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105dd:	83 ec 0c             	sub    $0xc,%esp
   105e0:	50                   	push   %eax
   105e1:	e8 fb 2d ff ff       	call   33e1 <lodepng_free>
   105e6:	83 c4 10             	add    $0x10,%esp
  return error;
   105e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   105ec:	c9                   	leave  
   105ed:	c3                   	ret    

000105ee <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   105ee:	55                   	push   %ebp
   105ef:	89 e5                	mov    %esp,%ebp
   105f1:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   105f4:	83 ec 08             	sub    $0x8,%esp
   105f7:	6a 08                	push   $0x8
   105f9:	6a 06                	push   $0x6
   105fb:	ff 75 14             	pushl  0x14(%ebp)
   105fe:	ff 75 10             	pushl  0x10(%ebp)
   10601:	ff 75 0c             	pushl  0xc(%ebp)
   10604:	ff 75 08             	pushl  0x8(%ebp)
   10607:	e8 61 ff ff ff       	call   1056d <lodepng_decode_file>
   1060c:	83 c4 20             	add    $0x20,%esp
}
   1060f:	c9                   	leave  
   10610:	c3                   	ret    

00010611 <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10611:	55                   	push   %ebp
   10612:	89 e5                	mov    %esp,%ebp
   10614:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   10617:	83 ec 08             	sub    $0x8,%esp
   1061a:	6a 08                	push   $0x8
   1061c:	6a 02                	push   $0x2
   1061e:	ff 75 14             	pushl  0x14(%ebp)
   10621:	ff 75 10             	pushl  0x10(%ebp)
   10624:	ff 75 0c             	pushl  0xc(%ebp)
   10627:	ff 75 08             	pushl  0x8(%ebp)
   1062a:	e8 3e ff ff ff       	call   1056d <lodepng_decode_file>
   1062f:	83 c4 20             	add    $0x20,%esp
}
   10632:	c9                   	leave  
   10633:	c3                   	ret    

00010634 <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   10634:	55                   	push   %ebp
   10635:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   10637:	8b 45 08             	mov    0x8(%ebp),%eax
   1063a:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   10641:	8b 45 08             	mov    0x8(%ebp),%eax
   10644:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   1064b:	8b 45 08             	mov    0x8(%ebp),%eax
   1064e:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   10655:	8b 45 08             	mov    0x8(%ebp),%eax
   10658:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   1065f:	8b 45 08             	mov    0x8(%ebp),%eax
   10662:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   10669:	8b 45 08             	mov    0x8(%ebp),%eax
   1066c:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   10673:	8b 45 08             	mov    0x8(%ebp),%eax
   10676:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   1067d:	8b 45 08             	mov    0x8(%ebp),%eax
   10680:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   10687:	8b 45 08             	mov    0x8(%ebp),%eax
   1068a:	50                   	push   %eax
   1068b:	e8 ff 7a ff ff       	call   818f <lodepng_decompress_settings_init>
   10690:	83 c4 04             	add    $0x4,%esp
}
   10693:	90                   	nop
   10694:	c9                   	leave  
   10695:	c3                   	ret    

00010696 <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   10696:	55                   	push   %ebp
   10697:	89 e5                	mov    %esp,%ebp
   10699:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   1069c:	8b 45 08             	mov    0x8(%ebp),%eax
   1069f:	50                   	push   %eax
   106a0:	e8 8f ff ff ff       	call   10634 <lodepng_decoder_settings_init>
   106a5:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   106a8:	8b 45 08             	mov    0x8(%ebp),%eax
   106ab:	83 c0 38             	add    $0x38,%eax
   106ae:	83 ec 0c             	sub    $0xc,%esp
   106b1:	50                   	push   %eax
   106b2:	e8 fc 30 00 00       	call   137b3 <lodepng_encoder_settings_init>
   106b7:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   106ba:	8b 45 08             	mov    0x8(%ebp),%eax
   106bd:	83 c0 78             	add    $0x78,%eax
   106c0:	83 ec 0c             	sub    $0xc,%esp
   106c3:	50                   	push   %eax
   106c4:	e8 06 84 ff ff       	call   8acf <lodepng_color_mode_init>
   106c9:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   106cc:	8b 45 08             	mov    0x8(%ebp),%eax
   106cf:	05 98 00 00 00       	add    $0x98,%eax
   106d4:	83 ec 0c             	sub    $0xc,%esp
   106d7:	50                   	push   %eax
   106d8:	e8 89 93 ff ff       	call   9a66 <lodepng_info_init>
   106dd:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   106e0:	8b 45 08             	mov    0x8(%ebp),%eax
   106e3:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   106ea:	00 00 00 
}
   106ed:	90                   	nop
   106ee:	c9                   	leave  
   106ef:	c3                   	ret    

000106f0 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   106f0:	55                   	push   %ebp
   106f1:	89 e5                	mov    %esp,%ebp
   106f3:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   106f6:	8b 45 08             	mov    0x8(%ebp),%eax
   106f9:	83 c0 78             	add    $0x78,%eax
   106fc:	83 ec 0c             	sub    $0xc,%esp
   106ff:	50                   	push   %eax
   10700:	e8 bd 84 ff ff       	call   8bc2 <lodepng_color_mode_cleanup>
   10705:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   10708:	8b 45 08             	mov    0x8(%ebp),%eax
   1070b:	05 98 00 00 00       	add    $0x98,%eax
   10710:	83 ec 0c             	sub    $0xc,%esp
   10713:	50                   	push   %eax
   10714:	e8 2e 94 ff ff       	call   9b47 <lodepng_info_cleanup>
   10719:	83 c4 10             	add    $0x10,%esp
}
   1071c:	90                   	nop
   1071d:	c9                   	leave  
   1071e:	c3                   	ret    

0001071f <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   1071f:	55                   	push   %ebp
   10720:	89 e5                	mov    %esp,%ebp
   10722:	57                   	push   %edi
   10723:	56                   	push   %esi
   10724:	53                   	push   %ebx
   10725:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   10728:	83 ec 0c             	sub    $0xc,%esp
   1072b:	ff 75 08             	pushl  0x8(%ebp)
   1072e:	e8 bd ff ff ff       	call   106f0 <lodepng_state_cleanup>
   10733:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   10736:	8b 55 08             	mov    0x8(%ebp),%edx
   10739:	8b 45 0c             	mov    0xc(%ebp),%eax
   1073c:	89 c3                	mov    %eax,%ebx
   1073e:	b8 60 00 00 00       	mov    $0x60,%eax
   10743:	89 d7                	mov    %edx,%edi
   10745:	89 de                	mov    %ebx,%esi
   10747:	89 c1                	mov    %eax,%ecx
   10749:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   1074b:	8b 45 08             	mov    0x8(%ebp),%eax
   1074e:	83 c0 78             	add    $0x78,%eax
   10751:	83 ec 0c             	sub    $0xc,%esp
   10754:	50                   	push   %eax
   10755:	e8 75 83 ff ff       	call   8acf <lodepng_color_mode_init>
   1075a:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   1075d:	8b 45 08             	mov    0x8(%ebp),%eax
   10760:	05 98 00 00 00       	add    $0x98,%eax
   10765:	83 ec 0c             	sub    $0xc,%esp
   10768:	50                   	push   %eax
   10769:	e8 f8 92 ff ff       	call   9a66 <lodepng_info_init>
   1076e:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   10771:	8b 45 0c             	mov    0xc(%ebp),%eax
   10774:	8d 50 78             	lea    0x78(%eax),%edx
   10777:	8b 45 08             	mov    0x8(%ebp),%eax
   1077a:	83 c0 78             	add    $0x78,%eax
   1077d:	83 ec 08             	sub    $0x8,%esp
   10780:	52                   	push   %edx
   10781:	50                   	push   %eax
   10782:	e8 52 84 ff ff       	call   8bd9 <lodepng_color_mode_copy>
   10787:	83 c4 10             	add    $0x10,%esp
   1078a:	89 c2                	mov    %eax,%edx
   1078c:	8b 45 08             	mov    0x8(%ebp),%eax
   1078f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10795:	8b 45 08             	mov    0x8(%ebp),%eax
   10798:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1079e:	85 c0                	test   %eax,%eax
   107a0:	75 36                	jne    107d8 <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   107a2:	8b 45 0c             	mov    0xc(%ebp),%eax
   107a5:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   107ab:	8b 45 08             	mov    0x8(%ebp),%eax
   107ae:	05 98 00 00 00       	add    $0x98,%eax
   107b3:	83 ec 08             	sub    $0x8,%esp
   107b6:	52                   	push   %edx
   107b7:	50                   	push   %eax
   107b8:	e8 dd 93 ff ff       	call   9b9a <lodepng_info_copy>
   107bd:	83 c4 10             	add    $0x10,%esp
   107c0:	89 c2                	mov    %eax,%edx
   107c2:	8b 45 08             	mov    0x8(%ebp),%eax
   107c5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   107cb:	8b 45 08             	mov    0x8(%ebp),%eax
   107ce:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   107d4:	85 c0                	test   %eax,%eax
   107d6:	eb 01                	jmp    107d9 <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   107d8:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   107d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
   107dc:	5b                   	pop    %ebx
   107dd:	5e                   	pop    %esi
   107de:	5f                   	pop    %edi
   107df:	5d                   	pop    %ebp
   107e0:	c3                   	ret    

000107e1 <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   107e1:	55                   	push   %ebp
   107e2:	89 e5                	mov    %esp,%ebp
   107e4:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   107e7:	8b 45 08             	mov    0x8(%ebp),%eax
   107ea:	8b 40 04             	mov    0x4(%eax),%eax
   107ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   107f0:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   107f4:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   107f8:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   107fc:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   10800:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   10804:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   10808:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   1080c:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   10810:	8b 45 08             	mov    0x8(%ebp),%eax
   10813:	8b 40 04             	mov    0x4(%eax),%eax
   10816:	83 c0 08             	add    $0x8,%eax
   10819:	50                   	push   %eax
   1081a:	ff 75 08             	pushl  0x8(%ebp)
   1081d:	e8 f8 2d ff ff       	call   361a <ucvector_resize>
   10822:	83 c4 08             	add    $0x8,%esp
   10825:	85 c0                	test   %eax,%eax
   10827:	75 07                	jne    10830 <writeSignature+0x4f>
   10829:	b8 53 00 00 00       	mov    $0x53,%eax
   1082e:	eb 1e                	jmp    1084e <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   10830:	8b 45 08             	mov    0x8(%ebp),%eax
   10833:	8b 10                	mov    (%eax),%edx
   10835:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10838:	01 c2                	add    %eax,%edx
   1083a:	6a 08                	push   $0x8
   1083c:	8d 45 f4             	lea    -0xc(%ebp),%eax
   1083f:	50                   	push   %eax
   10840:	52                   	push   %edx
   10841:	e8 b8 2b ff ff       	call   33fe <lodepng_memcpy>
   10846:	83 c4 0c             	add    $0xc,%esp
  return 0;
   10849:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1084e:	c9                   	leave  
   1084f:	c3                   	ret    

00010850 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   10850:	55                   	push   %ebp
   10851:	89 e5                	mov    %esp,%ebp
   10853:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   10856:	68 ec a0 01 00       	push   $0x1a0ec
   1085b:	6a 0d                	push   $0xd
   1085d:	ff 75 08             	pushl  0x8(%ebp)
   10860:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10863:	50                   	push   %eax
   10864:	e8 cf 7f ff ff       	call   8838 <lodepng_chunk_init>
   10869:	83 c4 10             	add    $0x10,%esp
   1086c:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1086f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10873:	74 05                	je     1087a <addChunk_IHDR+0x2a>
   10875:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10878:	eb 6d                	jmp    108e7 <addChunk_IHDR+0x97>
  data = chunk + 8;
   1087a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1087d:	83 c0 08             	add    $0x8,%eax
   10880:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   10883:	ff 75 0c             	pushl  0xc(%ebp)
   10886:	ff 75 f8             	pushl  -0x8(%ebp)
   10889:	e8 f3 2e ff ff       	call   3781 <lodepng_set32bitInt>
   1088e:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   10891:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10894:	83 c0 04             	add    $0x4,%eax
   10897:	ff 75 10             	pushl  0x10(%ebp)
   1089a:	50                   	push   %eax
   1089b:	e8 e1 2e ff ff       	call   3781 <lodepng_set32bitInt>
   108a0:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   108a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108a6:	83 c0 08             	add    $0x8,%eax
   108a9:	8b 55 18             	mov    0x18(%ebp),%edx
   108ac:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   108ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108b1:	83 c0 09             	add    $0x9,%eax
   108b4:	8b 55 14             	mov    0x14(%ebp),%edx
   108b7:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   108b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108bc:	83 c0 0a             	add    $0xa,%eax
   108bf:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   108c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108c5:	83 c0 0b             	add    $0xb,%eax
   108c8:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   108cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108ce:	83 c0 0c             	add    $0xc,%eax
   108d1:	8b 55 1c             	mov    0x1c(%ebp),%edx
   108d4:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   108d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   108d9:	50                   	push   %eax
   108da:	e8 02 7c ff ff       	call   84e1 <lodepng_chunk_generate_crc>
   108df:	83 c4 04             	add    $0x4,%esp
  return 0;
   108e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   108e7:	c9                   	leave  
   108e8:	c3                   	ret    

000108e9 <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   108e9:	55                   	push   %ebp
   108ea:	89 e5                	mov    %esp,%ebp
   108ec:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   108ef:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   108f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   108f9:	8b 50 0c             	mov    0xc(%eax),%edx
   108fc:	89 d0                	mov    %edx,%eax
   108fe:	01 c0                	add    %eax,%eax
   10900:	01 d0                	add    %edx,%eax
   10902:	68 08 a1 01 00       	push   $0x1a108
   10907:	50                   	push   %eax
   10908:	ff 75 08             	pushl  0x8(%ebp)
   1090b:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1090e:	50                   	push   %eax
   1090f:	e8 24 7f ff ff       	call   8838 <lodepng_chunk_init>
   10914:	83 c4 10             	add    $0x10,%esp
   10917:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1091a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1091e:	74 08                	je     10928 <addChunk_PLTE+0x3f>
   10920:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10923:	e9 95 00 00 00       	jmp    109bd <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   10928:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1092f:	eb 70                	jmp    109a1 <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   10931:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10934:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10937:	8d 50 01             	lea    0x1(%eax),%edx
   1093a:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1093d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10940:	8b 45 0c             	mov    0xc(%ebp),%eax
   10943:	8b 40 08             	mov    0x8(%eax),%eax
   10946:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10949:	c1 e1 02             	shl    $0x2,%ecx
   1094c:	01 c8                	add    %ecx,%eax
   1094e:	0f b6 00             	movzbl (%eax),%eax
   10951:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   10953:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10956:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10959:	8d 50 01             	lea    0x1(%eax),%edx
   1095c:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1095f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10962:	8b 45 0c             	mov    0xc(%ebp),%eax
   10965:	8b 40 08             	mov    0x8(%eax),%eax
   10968:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   1096b:	c1 e1 02             	shl    $0x2,%ecx
   1096e:	83 c1 01             	add    $0x1,%ecx
   10971:	01 c8                	add    %ecx,%eax
   10973:	0f b6 00             	movzbl (%eax),%eax
   10976:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   10978:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   1097b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1097e:	8d 50 01             	lea    0x1(%eax),%edx
   10981:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10984:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10987:	8b 45 0c             	mov    0xc(%ebp),%eax
   1098a:	8b 40 08             	mov    0x8(%eax),%eax
   1098d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10990:	c1 e1 02             	shl    $0x2,%ecx
   10993:	83 c1 02             	add    $0x2,%ecx
   10996:	01 c8                	add    %ecx,%eax
   10998:	0f b6 00             	movzbl (%eax),%eax
   1099b:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   1099d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   109a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   109a4:	8b 40 0c             	mov    0xc(%eax),%eax
   109a7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   109aa:	75 85                	jne    10931 <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   109ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   109af:	50                   	push   %eax
   109b0:	e8 2c 7b ff ff       	call   84e1 <lodepng_chunk_generate_crc>
   109b5:	83 c4 04             	add    $0x4,%esp
  return 0;
   109b8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   109bd:	c9                   	leave  
   109be:	c3                   	ret    

000109bf <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   109bf:	55                   	push   %ebp
   109c0:	89 e5                	mov    %esp,%ebp
   109c2:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   109c5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   109cc:	8b 45 0c             	mov    0xc(%ebp),%eax
   109cf:	8b 00                	mov    (%eax),%eax
   109d1:	83 f8 03             	cmp    $0x3,%eax
   109d4:	0f 85 ae 00 00 00    	jne    10a88 <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   109da:	8b 45 0c             	mov    0xc(%ebp),%eax
   109dd:	8b 40 0c             	mov    0xc(%eax),%eax
   109e0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   109e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   109e6:	8b 40 0c             	mov    0xc(%eax),%eax
   109e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
   109ec:	eb 23                	jmp    10a11 <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   109ee:	8b 45 0c             	mov    0xc(%ebp),%eax
   109f1:	8b 40 08             	mov    0x8(%eax),%eax
   109f4:	8b 55 fc             	mov    -0x4(%ebp),%edx
   109f7:	83 ea 01             	sub    $0x1,%edx
   109fa:	c1 e2 02             	shl    $0x2,%edx
   109fd:	83 c2 03             	add    $0x3,%edx
   10a00:	01 d0                	add    %edx,%eax
   10a02:	0f b6 00             	movzbl (%eax),%eax
   10a05:	3c ff                	cmp    $0xff,%al
   10a07:	75 10                	jne    10a19 <addChunk_tRNS+0x5a>
      --amount;
   10a09:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10a0d:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   10a11:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10a15:	75 d7                	jne    109ee <addChunk_tRNS+0x2f>
   10a17:	eb 01                	jmp    10a1a <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10a19:	90                   	nop
      --amount;
    }
    if(amount) {
   10a1a:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10a1e:	0f 84 63 01 00 00    	je     10b87 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   10a24:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10a27:	68 0d a1 01 00       	push   $0x1a10d
   10a2c:	50                   	push   %eax
   10a2d:	ff 75 08             	pushl  0x8(%ebp)
   10a30:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10a33:	50                   	push   %eax
   10a34:	e8 ff 7d ff ff       	call   8838 <lodepng_chunk_init>
   10a39:	83 c4 10             	add    $0x10,%esp
   10a3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10a3f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10a43:	74 08                	je     10a4d <addChunk_tRNS+0x8e>
   10a45:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a48:	e9 52 01 00 00       	jmp    10b9f <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   10a4d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10a54:	eb 25                	jmp    10a7b <addChunk_tRNS+0xbc>
   10a56:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a59:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10a5c:	83 c2 08             	add    $0x8,%edx
   10a5f:	01 c2                	add    %eax,%edx
   10a61:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a64:	8b 40 08             	mov    0x8(%eax),%eax
   10a67:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10a6a:	c1 e1 02             	shl    $0x2,%ecx
   10a6d:	83 c1 03             	add    $0x3,%ecx
   10a70:	01 c8                	add    %ecx,%eax
   10a72:	0f b6 00             	movzbl (%eax),%eax
   10a75:	88 02                	mov    %al,(%edx)
   10a77:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10a7b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10a7e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   10a81:	75 d3                	jne    10a56 <addChunk_tRNS+0x97>
   10a83:	e9 ff 00 00 00       	jmp    10b87 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   10a88:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a8b:	8b 00                	mov    (%eax),%eax
   10a8d:	85 c0                	test   %eax,%eax
   10a8f:	75 59                	jne    10aea <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   10a91:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a94:	8b 40 10             	mov    0x10(%eax),%eax
   10a97:	85 c0                	test   %eax,%eax
   10a99:	0f 84 e8 00 00 00    	je     10b87 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   10a9f:	68 0d a1 01 00       	push   $0x1a10d
   10aa4:	6a 02                	push   $0x2
   10aa6:	ff 75 08             	pushl  0x8(%ebp)
   10aa9:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10aac:	50                   	push   %eax
   10aad:	e8 86 7d ff ff       	call   8838 <lodepng_chunk_init>
   10ab2:	83 c4 10             	add    $0x10,%esp
   10ab5:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10ab8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10abc:	74 08                	je     10ac6 <addChunk_tRNS+0x107>
   10abe:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ac1:	e9 d9 00 00 00       	jmp    10b9f <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10ac6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ac9:	8d 50 08             	lea    0x8(%eax),%edx
   10acc:	8b 45 0c             	mov    0xc(%ebp),%eax
   10acf:	8b 40 14             	mov    0x14(%eax),%eax
   10ad2:	c1 e8 08             	shr    $0x8,%eax
   10ad5:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10ad7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ada:	8d 50 09             	lea    0x9(%eax),%edx
   10add:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ae0:	8b 40 14             	mov    0x14(%eax),%eax
   10ae3:	88 02                	mov    %al,(%edx)
   10ae5:	e9 9d 00 00 00       	jmp    10b87 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   10aea:	8b 45 0c             	mov    0xc(%ebp),%eax
   10aed:	8b 00                	mov    (%eax),%eax
   10aef:	83 f8 02             	cmp    $0x2,%eax
   10af2:	0f 85 8f 00 00 00    	jne    10b87 <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   10af8:	8b 45 0c             	mov    0xc(%ebp),%eax
   10afb:	8b 40 10             	mov    0x10(%eax),%eax
   10afe:	85 c0                	test   %eax,%eax
   10b00:	0f 84 81 00 00 00    	je     10b87 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   10b06:	68 0d a1 01 00       	push   $0x1a10d
   10b0b:	6a 06                	push   $0x6
   10b0d:	ff 75 08             	pushl  0x8(%ebp)
   10b10:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10b13:	50                   	push   %eax
   10b14:	e8 1f 7d ff ff       	call   8838 <lodepng_chunk_init>
   10b19:	83 c4 10             	add    $0x10,%esp
   10b1c:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10b1f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10b23:	74 05                	je     10b2a <addChunk_tRNS+0x16b>
   10b25:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10b28:	eb 75                	jmp    10b9f <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10b2a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b2d:	8d 50 08             	lea    0x8(%eax),%edx
   10b30:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b33:	8b 40 14             	mov    0x14(%eax),%eax
   10b36:	c1 e8 08             	shr    $0x8,%eax
   10b39:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10b3b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b3e:	8d 50 09             	lea    0x9(%eax),%edx
   10b41:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b44:	8b 40 14             	mov    0x14(%eax),%eax
   10b47:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   10b49:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b4c:	8d 50 0a             	lea    0xa(%eax),%edx
   10b4f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b52:	8b 40 18             	mov    0x18(%eax),%eax
   10b55:	c1 e8 08             	shr    $0x8,%eax
   10b58:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   10b5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b5d:	8d 50 0b             	lea    0xb(%eax),%edx
   10b60:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b63:	8b 40 18             	mov    0x18(%eax),%eax
   10b66:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   10b68:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b6b:	8d 50 0c             	lea    0xc(%eax),%edx
   10b6e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b71:	8b 40 1c             	mov    0x1c(%eax),%eax
   10b74:	c1 e8 08             	shr    $0x8,%eax
   10b77:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   10b79:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b7c:	8d 50 0d             	lea    0xd(%eax),%edx
   10b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b82:	8b 40 1c             	mov    0x1c(%eax),%eax
   10b85:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   10b87:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b8a:	85 c0                	test   %eax,%eax
   10b8c:	74 0c                	je     10b9a <addChunk_tRNS+0x1db>
   10b8e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b91:	50                   	push   %eax
   10b92:	e8 4a 79 ff ff       	call   84e1 <lodepng_chunk_generate_crc>
   10b97:	83 c4 04             	add    $0x4,%esp
  return 0;
   10b9a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10b9f:	c9                   	leave  
   10ba0:	c3                   	ret    

00010ba1 <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   10ba1:	55                   	push   %ebp
   10ba2:	89 e5                	mov    %esp,%ebp
   10ba4:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   10ba7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   10bae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   10bb5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   10bbc:	83 ec 0c             	sub    $0xc,%esp
   10bbf:	ff 75 14             	pushl  0x14(%ebp)
   10bc2:	ff 75 10             	pushl  0x10(%ebp)
   10bc5:	ff 75 0c             	pushl  0xc(%ebp)
   10bc8:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10bcb:	50                   	push   %eax
   10bcc:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10bcf:	50                   	push   %eax
   10bd0:	e8 fb 74 ff ff       	call   80d0 <zlib_compress>
   10bd5:	83 c4 20             	add    $0x20,%esp
   10bd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   10bdb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10bdf:	75 1b                	jne    10bfc <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   10be1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10be4:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10be7:	50                   	push   %eax
   10be8:	68 44 a1 01 00       	push   $0x1a144
   10bed:	52                   	push   %edx
   10bee:	ff 75 08             	pushl  0x8(%ebp)
   10bf1:	e8 ea 7c ff ff       	call   88e0 <lodepng_chunk_createv>
   10bf6:	83 c4 10             	add    $0x10,%esp
   10bf9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   10bfc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10bff:	83 ec 0c             	sub    $0xc,%esp
   10c02:	50                   	push   %eax
   10c03:	e8 d9 27 ff ff       	call   33e1 <lodepng_free>
   10c08:	83 c4 10             	add    $0x10,%esp
  return error;
   10c0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10c0e:	c9                   	leave  
   10c0f:	c3                   	ret    

00010c10 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   10c10:	55                   	push   %ebp
   10c11:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   10c13:	6a 00                	push   $0x0
   10c15:	68 49 a1 01 00       	push   $0x1a149
   10c1a:	6a 00                	push   $0x0
   10c1c:	ff 75 08             	pushl  0x8(%ebp)
   10c1f:	e8 bc 7c ff ff       	call   88e0 <lodepng_chunk_createv>
   10c24:	83 c4 10             	add    $0x10,%esp
}
   10c27:	c9                   	leave  
   10c28:	c3                   	ret    

00010c29 <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   10c29:	55                   	push   %ebp
   10c2a:	89 e5                	mov    %esp,%ebp
   10c2c:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10c2f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   10c36:	ff 75 0c             	pushl  0xc(%ebp)
   10c39:	e8 1e 28 ff ff       	call   345c <lodepng_strlen>
   10c3e:	83 c4 04             	add    $0x4,%esp
   10c41:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10c44:	ff 75 10             	pushl  0x10(%ebp)
   10c47:	e8 10 28 ff ff       	call   345c <lodepng_strlen>
   10c4c:	83 c4 04             	add    $0x4,%esp
   10c4f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   10c52:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10c55:	8d 50 01             	lea    0x1(%eax),%edx
   10c58:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10c5b:	01 d0                	add    %edx,%eax
   10c5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10c60:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10c64:	7e 06                	jle    10c6c <addChunk_tEXt+0x43>
   10c66:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   10c6a:	7e 07                	jle    10c73 <addChunk_tEXt+0x4a>
   10c6c:	b8 59 00 00 00       	mov    $0x59,%eax
   10c71:	eb 74                	jmp    10ce7 <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   10c73:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10c76:	68 17 a1 01 00       	push   $0x1a117
   10c7b:	50                   	push   %eax
   10c7c:	ff 75 08             	pushl  0x8(%ebp)
   10c7f:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10c82:	50                   	push   %eax
   10c83:	e8 b0 7b ff ff       	call   8838 <lodepng_chunk_init>
   10c88:	83 c4 10             	add    $0x10,%esp
   10c8b:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10c8e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10c92:	74 05                	je     10c99 <addChunk_tEXt+0x70>
   10c94:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10c97:	eb 4e                	jmp    10ce7 <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   10c99:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c9c:	83 c0 08             	add    $0x8,%eax
   10c9f:	ff 75 fc             	pushl  -0x4(%ebp)
   10ca2:	ff 75 0c             	pushl  0xc(%ebp)
   10ca5:	50                   	push   %eax
   10ca6:	e8 53 27 ff ff       	call   33fe <lodepng_memcpy>
   10cab:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   10cae:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10cb1:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10cb4:	83 c2 08             	add    $0x8,%edx
   10cb7:	01 d0                	add    %edx,%eax
   10cb9:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   10cbc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10cbf:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10cc2:	83 c2 09             	add    $0x9,%edx
   10cc5:	01 d0                	add    %edx,%eax
   10cc7:	ff 75 f8             	pushl  -0x8(%ebp)
   10cca:	ff 75 10             	pushl  0x10(%ebp)
   10ccd:	50                   	push   %eax
   10cce:	e8 2b 27 ff ff       	call   33fe <lodepng_memcpy>
   10cd3:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   10cd6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10cd9:	50                   	push   %eax
   10cda:	e8 02 78 ff ff       	call   84e1 <lodepng_chunk_generate_crc>
   10cdf:	83 c4 04             	add    $0x4,%esp
  return 0;
   10ce2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10ce7:	c9                   	leave  
   10ce8:	c3                   	ret    

00010ce9 <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   10ce9:	55                   	push   %ebp
   10cea:	89 e5                	mov    %esp,%ebp
   10cec:	53                   	push   %ebx
   10ced:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   10cf0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10cf7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   10cfe:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   10d05:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10d0c:	ff 75 10             	pushl  0x10(%ebp)
   10d0f:	e8 48 27 ff ff       	call   345c <lodepng_strlen>
   10d14:	83 c4 04             	add    $0x4,%esp
   10d17:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   10d1a:	ff 75 0c             	pushl  0xc(%ebp)
   10d1d:	e8 3a 27 ff ff       	call   345c <lodepng_strlen>
   10d22:	83 c4 04             	add    $0x4,%esp
   10d25:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10d28:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10d2c:	7e 06                	jle    10d34 <addChunk_zTXt+0x4b>
   10d2e:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10d32:	7e 0a                	jle    10d3e <addChunk_zTXt+0x55>
   10d34:	b8 59 00 00 00       	mov    $0x59,%eax
   10d39:	e9 c8 00 00 00       	jmp    10e06 <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   10d3e:	83 ec 0c             	sub    $0xc,%esp
   10d41:	ff 75 14             	pushl  0x14(%ebp)
   10d44:	ff 75 f0             	pushl  -0x10(%ebp)
   10d47:	ff 75 10             	pushl  0x10(%ebp)
   10d4a:	8d 45 dc             	lea    -0x24(%ebp),%eax
   10d4d:	50                   	push   %eax
   10d4e:	8d 45 e0             	lea    -0x20(%ebp),%eax
   10d51:	50                   	push   %eax
   10d52:	e8 79 73 ff ff       	call   80d0 <zlib_compress>
   10d57:	83 c4 20             	add    $0x20,%esp
   10d5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   10d5d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10d61:	75 29                	jne    10d8c <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   10d63:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d66:	8d 50 02             	lea    0x2(%eax),%edx
   10d69:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10d6c:	01 d0                	add    %edx,%eax
   10d6e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   10d71:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d74:	68 1c a1 01 00       	push   $0x1a11c
   10d79:	50                   	push   %eax
   10d7a:	ff 75 08             	pushl  0x8(%ebp)
   10d7d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   10d80:	50                   	push   %eax
   10d81:	e8 b2 7a ff ff       	call   8838 <lodepng_chunk_init>
   10d86:	83 c4 10             	add    $0x10,%esp
   10d89:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10d8c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10d90:	75 62                	jne    10df4 <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   10d92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d95:	83 c0 08             	add    $0x8,%eax
   10d98:	83 ec 04             	sub    $0x4,%esp
   10d9b:	ff 75 ec             	pushl  -0x14(%ebp)
   10d9e:	ff 75 0c             	pushl  0xc(%ebp)
   10da1:	50                   	push   %eax
   10da2:	e8 57 26 ff ff       	call   33fe <lodepng_memcpy>
   10da7:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   10daa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dad:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10db0:	83 c2 08             	add    $0x8,%edx
   10db3:	01 d0                	add    %edx,%eax
   10db5:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   10db8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dbb:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10dbe:	83 c2 09             	add    $0x9,%edx
   10dc1:	01 d0                	add    %edx,%eax
   10dc3:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   10dc6:	8b 55 dc             	mov    -0x24(%ebp),%edx
   10dc9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10dcc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10dcf:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   10dd2:	83 c3 0a             	add    $0xa,%ebx
   10dd5:	01 d9                	add    %ebx,%ecx
   10dd7:	83 ec 04             	sub    $0x4,%esp
   10dda:	52                   	push   %edx
   10ddb:	50                   	push   %eax
   10ddc:	51                   	push   %ecx
   10ddd:	e8 1c 26 ff ff       	call   33fe <lodepng_memcpy>
   10de2:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   10de5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10de8:	83 ec 0c             	sub    $0xc,%esp
   10deb:	50                   	push   %eax
   10dec:	e8 f0 76 ff ff       	call   84e1 <lodepng_chunk_generate_crc>
   10df1:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10df4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10df7:	83 ec 0c             	sub    $0xc,%esp
   10dfa:	50                   	push   %eax
   10dfb:	e8 e1 25 ff ff       	call   33e1 <lodepng_free>
   10e00:	83 c4 10             	add    $0x10,%esp
  return error;
   10e03:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10e06:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10e09:	c9                   	leave  
   10e0a:	c3                   	ret    

00010e0b <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   10e0b:	55                   	push   %ebp
   10e0c:	89 e5                	mov    %esp,%ebp
   10e0e:	53                   	push   %ebx
   10e0f:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   10e12:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10e19:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   10e20:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   10e27:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10e2e:	ff 75 1c             	pushl  0x1c(%ebp)
   10e31:	e8 26 26 ff ff       	call   345c <lodepng_strlen>
   10e36:	83 c4 04             	add    $0x4,%esp
   10e39:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   10e3c:	ff 75 10             	pushl  0x10(%ebp)
   10e3f:	e8 18 26 ff ff       	call   345c <lodepng_strlen>
   10e44:	83 c4 04             	add    $0x4,%esp
   10e47:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10e4a:	ff 75 14             	pushl  0x14(%ebp)
   10e4d:	e8 0a 26 ff ff       	call   345c <lodepng_strlen>
   10e52:	83 c4 04             	add    $0x4,%esp
   10e55:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10e58:	ff 75 18             	pushl  0x18(%ebp)
   10e5b:	e8 fc 25 ff ff       	call   345c <lodepng_strlen>
   10e60:	83 c4 04             	add    $0x4,%esp
   10e63:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10e66:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10e6a:	7e 06                	jle    10e72 <addChunk_iTXt+0x67>
   10e6c:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10e70:	7e 0a                	jle    10e7c <addChunk_iTXt+0x71>
   10e72:	b8 59 00 00 00       	mov    $0x59,%eax
   10e77:	e9 9a 01 00 00       	jmp    11016 <addChunk_iTXt+0x20b>

  if(compress) {
   10e7c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10e80:	74 1f                	je     10ea1 <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   10e82:	83 ec 0c             	sub    $0xc,%esp
   10e85:	ff 75 20             	pushl  0x20(%ebp)
   10e88:	ff 75 f0             	pushl  -0x10(%ebp)
   10e8b:	ff 75 1c             	pushl  0x1c(%ebp)
   10e8e:	8d 45 d0             	lea    -0x30(%ebp),%eax
   10e91:	50                   	push   %eax
   10e92:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   10e95:	50                   	push   %eax
   10e96:	e8 35 72 ff ff       	call   80d0 <zlib_compress>
   10e9b:	83 c4 20             	add    $0x20,%esp
   10e9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   10ea1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10ea5:	75 44                	jne    10eeb <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   10ea7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10eaa:	8d 50 03             	lea    0x3(%eax),%edx
   10ead:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10eb0:	01 d0                	add    %edx,%eax
   10eb2:	8d 50 01             	lea    0x1(%eax),%edx
   10eb5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10eb8:	01 d0                	add    %edx,%eax
   10eba:	8d 50 01             	lea    0x1(%eax),%edx
   10ebd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10ec1:	74 05                	je     10ec8 <addChunk_iTXt+0xbd>
   10ec3:	8b 45 d0             	mov    -0x30(%ebp),%eax
   10ec6:	eb 03                	jmp    10ecb <addChunk_iTXt+0xc0>
   10ec8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ecb:	01 d0                	add    %edx,%eax
   10ecd:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   10ed0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10ed3:	68 21 a1 01 00       	push   $0x1a121
   10ed8:	50                   	push   %eax
   10ed9:	ff 75 08             	pushl  0x8(%ebp)
   10edc:	8d 45 d8             	lea    -0x28(%ebp),%eax
   10edf:	50                   	push   %eax
   10ee0:	e8 53 79 ff ff       	call   8838 <lodepng_chunk_init>
   10ee5:	83 c4 10             	add    $0x10,%esp
   10ee8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10eeb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10eef:	0f 85 0f 01 00 00    	jne    11004 <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   10ef5:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   10efc:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10eff:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f02:	01 d0                	add    %edx,%eax
   10f04:	83 ec 04             	sub    $0x4,%esp
   10f07:	ff 75 ec             	pushl  -0x14(%ebp)
   10f0a:	ff 75 10             	pushl  0x10(%ebp)
   10f0d:	50                   	push   %eax
   10f0e:	e8 eb 24 ff ff       	call   33fe <lodepng_memcpy>
   10f13:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   10f16:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10f19:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10f1c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f1f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f22:	8d 50 01             	lea    0x1(%eax),%edx
   10f25:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f28:	01 c8                	add    %ecx,%eax
   10f2a:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   10f2d:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f30:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f33:	8d 50 01             	lea    0x1(%eax),%edx
   10f36:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f39:	01 c8                	add    %ecx,%eax
   10f3b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10f3f:	0f 95 c2             	setne  %dl
   10f42:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   10f44:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f47:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f4a:	8d 50 01             	lea    0x1(%eax),%edx
   10f4d:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f50:	01 c8                	add    %ecx,%eax
   10f52:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   10f55:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10f58:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f5b:	01 d0                	add    %edx,%eax
   10f5d:	83 ec 04             	sub    $0x4,%esp
   10f60:	ff 75 e8             	pushl  -0x18(%ebp)
   10f63:	ff 75 14             	pushl  0x14(%ebp)
   10f66:	50                   	push   %eax
   10f67:	e8 92 24 ff ff       	call   33fe <lodepng_memcpy>
   10f6c:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   10f6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10f72:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10f75:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f78:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f7b:	8d 50 01             	lea    0x1(%eax),%edx
   10f7e:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f81:	01 c8                	add    %ecx,%eax
   10f83:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   10f86:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10f89:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f8c:	01 d0                	add    %edx,%eax
   10f8e:	83 ec 04             	sub    $0x4,%esp
   10f91:	ff 75 e4             	pushl  -0x1c(%ebp)
   10f94:	ff 75 18             	pushl  0x18(%ebp)
   10f97:	50                   	push   %eax
   10f98:	e8 61 24 ff ff       	call   33fe <lodepng_memcpy>
   10f9d:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   10fa0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10fa3:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10fa6:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10fa9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10fac:	8d 50 01             	lea    0x1(%eax),%edx
   10faf:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10fb2:	01 c8                	add    %ecx,%eax
   10fb4:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   10fb7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10fbb:	74 1e                	je     10fdb <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   10fbd:	8b 55 d0             	mov    -0x30(%ebp),%edx
   10fc0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10fc3:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   10fc6:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   10fc9:	01 d9                	add    %ebx,%ecx
   10fcb:	83 ec 04             	sub    $0x4,%esp
   10fce:	52                   	push   %edx
   10fcf:	50                   	push   %eax
   10fd0:	51                   	push   %ecx
   10fd1:	e8 28 24 ff ff       	call   33fe <lodepng_memcpy>
   10fd6:	83 c4 10             	add    $0x10,%esp
   10fd9:	eb 1a                	jmp    10ff5 <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   10fdb:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10fde:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10fe1:	01 d0                	add    %edx,%eax
   10fe3:	83 ec 04             	sub    $0x4,%esp
   10fe6:	ff 75 f0             	pushl  -0x10(%ebp)
   10fe9:	ff 75 1c             	pushl  0x1c(%ebp)
   10fec:	50                   	push   %eax
   10fed:	e8 0c 24 ff ff       	call   33fe <lodepng_memcpy>
   10ff2:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   10ff5:	8b 45 d8             	mov    -0x28(%ebp),%eax
   10ff8:	83 ec 0c             	sub    $0xc,%esp
   10ffb:	50                   	push   %eax
   10ffc:	e8 e0 74 ff ff       	call   84e1 <lodepng_chunk_generate_crc>
   11001:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11004:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   11007:	83 ec 0c             	sub    $0xc,%esp
   1100a:	50                   	push   %eax
   1100b:	e8 d1 23 ff ff       	call   33e1 <lodepng_free>
   11010:	83 c4 10             	add    $0x10,%esp
  return error;
   11013:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11016:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11019:	c9                   	leave  
   1101a:	c3                   	ret    

0001101b <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   1101b:	55                   	push   %ebp
   1101c:	89 e5                	mov    %esp,%ebp
   1101e:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   11021:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   11028:	8b 45 0c             	mov    0xc(%ebp),%eax
   1102b:	8b 40 0c             	mov    0xc(%eax),%eax
   1102e:	85 c0                	test   %eax,%eax
   11030:	74 0b                	je     1103d <addChunk_bKGD+0x22>
   11032:	8b 45 0c             	mov    0xc(%ebp),%eax
   11035:	8b 40 0c             	mov    0xc(%eax),%eax
   11038:	83 f8 04             	cmp    $0x4,%eax
   1103b:	75 4b                	jne    11088 <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   1103d:	68 12 a1 01 00       	push   $0x1a112
   11042:	6a 02                	push   $0x2
   11044:	ff 75 08             	pushl  0x8(%ebp)
   11047:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1104a:	50                   	push   %eax
   1104b:	e8 e8 77 ff ff       	call   8838 <lodepng_chunk_init>
   11050:	83 c4 10             	add    $0x10,%esp
   11053:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11056:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1105a:	74 08                	je     11064 <addChunk_bKGD+0x49>
   1105c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1105f:	e9 19 01 00 00       	jmp    1117d <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   11064:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11067:	8d 50 08             	lea    0x8(%eax),%edx
   1106a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1106d:	8b 40 30             	mov    0x30(%eax),%eax
   11070:	c1 e8 08             	shr    $0x8,%eax
   11073:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   11075:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11078:	8d 50 09             	lea    0x9(%eax),%edx
   1107b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1107e:	8b 40 30             	mov    0x30(%eax),%eax
   11081:	88 02                	mov    %al,(%edx)
   11083:	e9 dd 00 00 00       	jmp    11165 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   11088:	8b 45 0c             	mov    0xc(%ebp),%eax
   1108b:	8b 40 0c             	mov    0xc(%eax),%eax
   1108e:	83 f8 02             	cmp    $0x2,%eax
   11091:	74 0f                	je     110a2 <addChunk_bKGD+0x87>
   11093:	8b 45 0c             	mov    0xc(%ebp),%eax
   11096:	8b 40 0c             	mov    0xc(%eax),%eax
   11099:	83 f8 06             	cmp    $0x6,%eax
   1109c:	0f 85 86 00 00 00    	jne    11128 <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   110a2:	68 12 a1 01 00       	push   $0x1a112
   110a7:	6a 06                	push   $0x6
   110a9:	ff 75 08             	pushl  0x8(%ebp)
   110ac:	8d 45 f0             	lea    -0x10(%ebp),%eax
   110af:	50                   	push   %eax
   110b0:	e8 83 77 ff ff       	call   8838 <lodepng_chunk_init>
   110b5:	83 c4 10             	add    $0x10,%esp
   110b8:	89 45 f8             	mov    %eax,-0x8(%ebp)
   110bb:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   110bf:	74 08                	je     110c9 <addChunk_bKGD+0xae>
   110c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   110c4:	e9 b4 00 00 00       	jmp    1117d <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   110c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110cc:	8d 50 08             	lea    0x8(%eax),%edx
   110cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   110d2:	8b 40 30             	mov    0x30(%eax),%eax
   110d5:	c1 e8 08             	shr    $0x8,%eax
   110d8:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   110da:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110dd:	8d 50 09             	lea    0x9(%eax),%edx
   110e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   110e3:	8b 40 30             	mov    0x30(%eax),%eax
   110e6:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   110e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110eb:	8d 50 0a             	lea    0xa(%eax),%edx
   110ee:	8b 45 0c             	mov    0xc(%ebp),%eax
   110f1:	8b 40 34             	mov    0x34(%eax),%eax
   110f4:	c1 e8 08             	shr    $0x8,%eax
   110f7:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   110f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110fc:	8d 50 0b             	lea    0xb(%eax),%edx
   110ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   11102:	8b 40 34             	mov    0x34(%eax),%eax
   11105:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   11107:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1110a:	8d 50 0c             	lea    0xc(%eax),%edx
   1110d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11110:	8b 40 38             	mov    0x38(%eax),%eax
   11113:	c1 e8 08             	shr    $0x8,%eax
   11116:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   11118:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1111b:	8d 50 0d             	lea    0xd(%eax),%edx
   1111e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11121:	8b 40 38             	mov    0x38(%eax),%eax
   11124:	88 02                	mov    %al,(%edx)
   11126:	eb 3d                	jmp    11165 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   11128:	8b 45 0c             	mov    0xc(%ebp),%eax
   1112b:	8b 40 0c             	mov    0xc(%eax),%eax
   1112e:	83 f8 03             	cmp    $0x3,%eax
   11131:	75 32                	jne    11165 <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   11133:	68 12 a1 01 00       	push   $0x1a112
   11138:	6a 01                	push   $0x1
   1113a:	ff 75 08             	pushl  0x8(%ebp)
   1113d:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11140:	50                   	push   %eax
   11141:	e8 f2 76 ff ff       	call   8838 <lodepng_chunk_init>
   11146:	83 c4 10             	add    $0x10,%esp
   11149:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1114c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11150:	74 05                	je     11157 <addChunk_bKGD+0x13c>
   11152:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11155:	eb 26                	jmp    1117d <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   11157:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1115a:	8d 50 08             	lea    0x8(%eax),%edx
   1115d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11160:	8b 40 30             	mov    0x30(%eax),%eax
   11163:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   11165:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11168:	85 c0                	test   %eax,%eax
   1116a:	74 0c                	je     11178 <addChunk_bKGD+0x15d>
   1116c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1116f:	50                   	push   %eax
   11170:	e8 6c 73 ff ff       	call   84e1 <lodepng_chunk_generate_crc>
   11175:	83 c4 04             	add    $0x4,%esp
  return 0;
   11178:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1117d:	c9                   	leave  
   1117e:	c3                   	ret    

0001117f <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   1117f:	55                   	push   %ebp
   11180:	89 e5                	mov    %esp,%ebp
   11182:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   11185:	68 26 a1 01 00       	push   $0x1a126
   1118a:	6a 07                	push   $0x7
   1118c:	ff 75 08             	pushl  0x8(%ebp)
   1118f:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11192:	50                   	push   %eax
   11193:	e8 a0 76 ff ff       	call   8838 <lodepng_chunk_init>
   11198:	83 c4 10             	add    $0x10,%esp
   1119b:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1119e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   111a2:	74 05                	je     111a9 <addChunk_tIME+0x2a>
   111a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   111a7:	eb 74                	jmp    1121d <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   111a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111ac:	8d 50 08             	lea    0x8(%eax),%edx
   111af:	8b 45 0c             	mov    0xc(%ebp),%eax
   111b2:	8b 00                	mov    (%eax),%eax
   111b4:	c1 e8 08             	shr    $0x8,%eax
   111b7:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   111b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111bc:	8d 50 09             	lea    0x9(%eax),%edx
   111bf:	8b 45 0c             	mov    0xc(%ebp),%eax
   111c2:	8b 00                	mov    (%eax),%eax
   111c4:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   111c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111c9:	8d 50 0a             	lea    0xa(%eax),%edx
   111cc:	8b 45 0c             	mov    0xc(%ebp),%eax
   111cf:	8b 40 04             	mov    0x4(%eax),%eax
   111d2:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   111d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111d7:	8d 50 0b             	lea    0xb(%eax),%edx
   111da:	8b 45 0c             	mov    0xc(%ebp),%eax
   111dd:	8b 40 08             	mov    0x8(%eax),%eax
   111e0:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   111e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111e5:	8d 50 0c             	lea    0xc(%eax),%edx
   111e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   111eb:	8b 40 0c             	mov    0xc(%eax),%eax
   111ee:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   111f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111f3:	8d 50 0d             	lea    0xd(%eax),%edx
   111f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   111f9:	8b 40 10             	mov    0x10(%eax),%eax
   111fc:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   111fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11201:	8d 50 0e             	lea    0xe(%eax),%edx
   11204:	8b 45 0c             	mov    0xc(%ebp),%eax
   11207:	8b 40 14             	mov    0x14(%eax),%eax
   1120a:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   1120c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1120f:	50                   	push   %eax
   11210:	e8 cc 72 ff ff       	call   84e1 <lodepng_chunk_generate_crc>
   11215:	83 c4 04             	add    $0x4,%esp
  return 0;
   11218:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1121d:	c9                   	leave  
   1121e:	c3                   	ret    

0001121f <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   1121f:	55                   	push   %ebp
   11220:	89 e5                	mov    %esp,%ebp
   11222:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   11225:	68 2b a1 01 00       	push   $0x1a12b
   1122a:	6a 09                	push   $0x9
   1122c:	ff 75 08             	pushl  0x8(%ebp)
   1122f:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11232:	50                   	push   %eax
   11233:	e8 00 76 ff ff       	call   8838 <lodepng_chunk_init>
   11238:	83 c4 10             	add    $0x10,%esp
   1123b:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1123e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11242:	74 05                	je     11249 <addChunk_pHYs+0x2a>
   11244:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11247:	eb 51                	jmp    1129a <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   11249:	8b 45 0c             	mov    0xc(%ebp),%eax
   1124c:	8b 40 7c             	mov    0x7c(%eax),%eax
   1124f:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11252:	83 c2 08             	add    $0x8,%edx
   11255:	50                   	push   %eax
   11256:	52                   	push   %edx
   11257:	e8 25 25 ff ff       	call   3781 <lodepng_set32bitInt>
   1125c:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   1125f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11262:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   11268:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1126b:	83 c2 0c             	add    $0xc,%edx
   1126e:	50                   	push   %eax
   1126f:	52                   	push   %edx
   11270:	e8 0c 25 ff ff       	call   3781 <lodepng_set32bitInt>
   11275:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   11278:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1127b:	8d 50 10             	lea    0x10(%eax),%edx
   1127e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11281:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   11287:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   11289:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1128c:	50                   	push   %eax
   1128d:	e8 4f 72 ff ff       	call   84e1 <lodepng_chunk_generate_crc>
   11292:	83 c4 04             	add    $0x4,%esp
  return 0;
   11295:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1129a:	c9                   	leave  
   1129b:	c3                   	ret    

0001129c <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   1129c:	55                   	push   %ebp
   1129d:	89 e5                	mov    %esp,%ebp
   1129f:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   112a2:	68 30 a1 01 00       	push   $0x1a130
   112a7:	6a 04                	push   $0x4
   112a9:	ff 75 08             	pushl  0x8(%ebp)
   112ac:	8d 45 f8             	lea    -0x8(%ebp),%eax
   112af:	50                   	push   %eax
   112b0:	e8 83 75 ff ff       	call   8838 <lodepng_chunk_init>
   112b5:	83 c4 10             	add    $0x10,%esp
   112b8:	89 45 fc             	mov    %eax,-0x4(%ebp)
   112bb:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   112bf:	74 05                	je     112c6 <addChunk_gAMA+0x2a>
   112c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   112c4:	eb 2a                	jmp    112f0 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   112c6:	8b 45 0c             	mov    0xc(%ebp),%eax
   112c9:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   112cf:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112d2:	83 c2 08             	add    $0x8,%edx
   112d5:	50                   	push   %eax
   112d6:	52                   	push   %edx
   112d7:	e8 a5 24 ff ff       	call   3781 <lodepng_set32bitInt>
   112dc:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   112df:	8b 45 f8             	mov    -0x8(%ebp),%eax
   112e2:	50                   	push   %eax
   112e3:	e8 f9 71 ff ff       	call   84e1 <lodepng_chunk_generate_crc>
   112e8:	83 c4 04             	add    $0x4,%esp
  return 0;
   112eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
   112f0:	c9                   	leave  
   112f1:	c3                   	ret    

000112f2 <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   112f2:	55                   	push   %ebp
   112f3:	89 e5                	mov    %esp,%ebp
   112f5:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   112f8:	68 35 a1 01 00       	push   $0x1a135
   112fd:	6a 20                	push   $0x20
   112ff:	ff 75 08             	pushl  0x8(%ebp)
   11302:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11305:	50                   	push   %eax
   11306:	e8 2d 75 ff ff       	call   8838 <lodepng_chunk_init>
   1130b:	83 c4 10             	add    $0x10,%esp
   1130e:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11311:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11315:	74 08                	je     1131f <addChunk_cHRM+0x2d>
   11317:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1131a:	e9 d9 00 00 00       	jmp    113f8 <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   1131f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11322:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   11328:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1132b:	83 c2 08             	add    $0x8,%edx
   1132e:	50                   	push   %eax
   1132f:	52                   	push   %edx
   11330:	e8 4c 24 ff ff       	call   3781 <lodepng_set32bitInt>
   11335:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   11338:	8b 45 0c             	mov    0xc(%ebp),%eax
   1133b:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   11341:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11344:	83 c2 0c             	add    $0xc,%edx
   11347:	50                   	push   %eax
   11348:	52                   	push   %edx
   11349:	e8 33 24 ff ff       	call   3781 <lodepng_set32bitInt>
   1134e:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   11351:	8b 45 0c             	mov    0xc(%ebp),%eax
   11354:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   1135a:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1135d:	83 c2 10             	add    $0x10,%edx
   11360:	50                   	push   %eax
   11361:	52                   	push   %edx
   11362:	e8 1a 24 ff ff       	call   3781 <lodepng_set32bitInt>
   11367:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   1136a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1136d:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11373:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11376:	83 c2 14             	add    $0x14,%edx
   11379:	50                   	push   %eax
   1137a:	52                   	push   %edx
   1137b:	e8 01 24 ff ff       	call   3781 <lodepng_set32bitInt>
   11380:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   11383:	8b 45 0c             	mov    0xc(%ebp),%eax
   11386:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   1138c:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1138f:	83 c2 18             	add    $0x18,%edx
   11392:	50                   	push   %eax
   11393:	52                   	push   %edx
   11394:	e8 e8 23 ff ff       	call   3781 <lodepng_set32bitInt>
   11399:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   1139c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1139f:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   113a5:	8b 55 f8             	mov    -0x8(%ebp),%edx
   113a8:	83 c2 1c             	add    $0x1c,%edx
   113ab:	50                   	push   %eax
   113ac:	52                   	push   %edx
   113ad:	e8 cf 23 ff ff       	call   3781 <lodepng_set32bitInt>
   113b2:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   113b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   113b8:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   113be:	8b 55 f8             	mov    -0x8(%ebp),%edx
   113c1:	83 c2 20             	add    $0x20,%edx
   113c4:	50                   	push   %eax
   113c5:	52                   	push   %edx
   113c6:	e8 b6 23 ff ff       	call   3781 <lodepng_set32bitInt>
   113cb:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   113ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   113d1:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   113d7:	8b 55 f8             	mov    -0x8(%ebp),%edx
   113da:	83 c2 24             	add    $0x24,%edx
   113dd:	50                   	push   %eax
   113de:	52                   	push   %edx
   113df:	e8 9d 23 ff ff       	call   3781 <lodepng_set32bitInt>
   113e4:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   113e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   113ea:	50                   	push   %eax
   113eb:	e8 f1 70 ff ff       	call   84e1 <lodepng_chunk_generate_crc>
   113f0:	83 c4 04             	add    $0x4,%esp
  return 0;
   113f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
   113f8:	c9                   	leave  
   113f9:	c3                   	ret    

000113fa <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   113fa:	55                   	push   %ebp
   113fb:	89 e5                	mov    %esp,%ebp
   113fd:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   11400:	8b 45 0c             	mov    0xc(%ebp),%eax
   11403:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   11409:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   1140c:	8d 45 ff             	lea    -0x1(%ebp),%eax
   1140f:	50                   	push   %eax
   11410:	68 3a a1 01 00       	push   $0x1a13a
   11415:	6a 01                	push   $0x1
   11417:	ff 75 08             	pushl  0x8(%ebp)
   1141a:	e8 c1 74 ff ff       	call   88e0 <lodepng_chunk_createv>
   1141f:	83 c4 10             	add    $0x10,%esp
}
   11422:	c9                   	leave  
   11423:	c3                   	ret    

00011424 <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   11424:	55                   	push   %ebp
   11425:	89 e5                	mov    %esp,%ebp
   11427:	53                   	push   %ebx
   11428:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   1142b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11432:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   11439:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   11440:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   11447:	8b 45 0c             	mov    0xc(%ebp),%eax
   1144a:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11450:	50                   	push   %eax
   11451:	e8 06 20 ff ff       	call   345c <lodepng_strlen>
   11456:	83 c4 04             	add    $0x4,%esp
   11459:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   1145c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11460:	7e 06                	jle    11468 <addChunk_iCCP+0x44>
   11462:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   11466:	7e 0a                	jle    11472 <addChunk_iCCP+0x4e>
   11468:	b8 59 00 00 00       	mov    $0x59,%eax
   1146d:	e9 df 00 00 00       	jmp    11551 <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   11472:	8b 45 0c             	mov    0xc(%ebp),%eax
   11475:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   1147b:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   1147d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11480:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   11486:	83 ec 0c             	sub    $0xc,%esp
   11489:	ff 75 10             	pushl  0x10(%ebp)
   1148c:	52                   	push   %edx
   1148d:	50                   	push   %eax
   1148e:	8d 45 e0             	lea    -0x20(%ebp),%eax
   11491:	50                   	push   %eax
   11492:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   11495:	50                   	push   %eax
   11496:	e8 35 6c ff ff       	call   80d0 <zlib_compress>
   1149b:	83 c4 20             	add    $0x20,%esp
   1149e:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   114a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   114a5:	75 29                	jne    114d0 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   114a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   114aa:	8d 50 02             	lea    0x2(%eax),%edx
   114ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
   114b0:	01 d0                	add    %edx,%eax
   114b2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   114b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   114b8:	68 3f a1 01 00       	push   $0x1a13f
   114bd:	50                   	push   %eax
   114be:	ff 75 08             	pushl  0x8(%ebp)
   114c1:	8d 45 e8             	lea    -0x18(%ebp),%eax
   114c4:	50                   	push   %eax
   114c5:	e8 6e 73 ff ff       	call   8838 <lodepng_chunk_init>
   114ca:	83 c4 10             	add    $0x10,%esp
   114cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   114d0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   114d4:	75 69                	jne    1153f <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   114d6:	8b 45 0c             	mov    0xc(%ebp),%eax
   114d9:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   114df:	8b 55 e8             	mov    -0x18(%ebp),%edx
   114e2:	83 c2 08             	add    $0x8,%edx
   114e5:	83 ec 04             	sub    $0x4,%esp
   114e8:	ff 75 f0             	pushl  -0x10(%ebp)
   114eb:	50                   	push   %eax
   114ec:	52                   	push   %edx
   114ed:	e8 0c 1f ff ff       	call   33fe <lodepng_memcpy>
   114f2:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   114f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   114f8:	8b 55 f0             	mov    -0x10(%ebp),%edx
   114fb:	83 c2 08             	add    $0x8,%edx
   114fe:	01 d0                	add    %edx,%eax
   11500:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   11503:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11506:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11509:	83 c2 09             	add    $0x9,%edx
   1150c:	01 d0                	add    %edx,%eax
   1150e:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11511:	8b 55 e0             	mov    -0x20(%ebp),%edx
   11514:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11517:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1151a:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   1151d:	83 c3 0a             	add    $0xa,%ebx
   11520:	01 d9                	add    %ebx,%ecx
   11522:	83 ec 04             	sub    $0x4,%esp
   11525:	52                   	push   %edx
   11526:	50                   	push   %eax
   11527:	51                   	push   %ecx
   11528:	e8 d1 1e ff ff       	call   33fe <lodepng_memcpy>
   1152d:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   11530:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11533:	83 ec 0c             	sub    $0xc,%esp
   11536:	50                   	push   %eax
   11537:	e8 a5 6f ff ff       	call   84e1 <lodepng_chunk_generate_crc>
   1153c:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   1153f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11542:	83 ec 0c             	sub    $0xc,%esp
   11545:	50                   	push   %eax
   11546:	e8 96 1e ff ff       	call   33e1 <lodepng_free>
   1154b:	83 c4 10             	add    $0x10,%esp
  return error;
   1154e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11551:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11554:	c9                   	leave  
   11555:	c3                   	ret    

00011556 <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   11556:	55                   	push   %ebp
   11557:	89 e5                	mov    %esp,%ebp
   11559:	56                   	push   %esi
   1155a:	53                   	push   %ebx
   1155b:	83 ec 14             	sub    $0x14,%esp
   1155e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11561:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   11564:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   11568:	83 f8 04             	cmp    $0x4,%eax
   1156b:	0f 87 41 03 00 00    	ja     118b2 <filterScanline+0x35c>
   11571:	8b 04 85 50 a1 01 00 	mov    0x1a150(,%eax,4),%eax
   11578:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   1157a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11581:	eb 19                	jmp    1159c <filterScanline+0x46>
   11583:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11586:	8b 45 08             	mov    0x8(%ebp),%eax
   11589:	01 c2                	add    %eax,%edx
   1158b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1158e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11591:	01 c8                	add    %ecx,%eax
   11593:	0f b6 00             	movzbl (%eax),%eax
   11596:	88 02                	mov    %al,(%edx)
   11598:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1159c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1159f:	3b 45 14             	cmp    0x14(%ebp),%eax
   115a2:	75 df                	jne    11583 <filterScanline+0x2d>
      break;
   115a4:	e9 0a 03 00 00       	jmp    118b3 <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   115a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   115b0:	eb 19                	jmp    115cb <filterScanline+0x75>
   115b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115b5:	8b 45 08             	mov    0x8(%ebp),%eax
   115b8:	01 c2                	add    %eax,%edx
   115ba:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   115bd:	8b 45 0c             	mov    0xc(%ebp),%eax
   115c0:	01 c8                	add    %ecx,%eax
   115c2:	0f b6 00             	movzbl (%eax),%eax
   115c5:	88 02                	mov    %al,(%edx)
   115c7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115ce:	3b 45 18             	cmp    0x18(%ebp),%eax
   115d1:	75 df                	jne    115b2 <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   115d3:	8b 45 18             	mov    0x18(%ebp),%eax
   115d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
   115d9:	eb 2d                	jmp    11608 <filterScanline+0xb2>
   115db:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115de:	8b 45 08             	mov    0x8(%ebp),%eax
   115e1:	01 c2                	add    %eax,%edx
   115e3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   115e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   115e9:	01 c8                	add    %ecx,%eax
   115eb:	0f b6 08             	movzbl (%eax),%ecx
   115ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115f1:	2b 45 18             	sub    0x18(%ebp),%eax
   115f4:	89 c3                	mov    %eax,%ebx
   115f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   115f9:	01 d8                	add    %ebx,%eax
   115fb:	0f b6 00             	movzbl (%eax),%eax
   115fe:	29 c1                	sub    %eax,%ecx
   11600:	89 c8                	mov    %ecx,%eax
   11602:	88 02                	mov    %al,(%edx)
   11604:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11608:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1160b:	3b 45 14             	cmp    0x14(%ebp),%eax
   1160e:	7c cb                	jl     115db <filterScanline+0x85>
      break;
   11610:	e9 9e 02 00 00       	jmp    118b3 <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   11615:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11619:	74 3e                	je     11659 <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   1161b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11622:	eb 28                	jmp    1164c <filterScanline+0xf6>
   11624:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11627:	8b 45 08             	mov    0x8(%ebp),%eax
   1162a:	01 d0                	add    %edx,%eax
   1162c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1162f:	8b 55 0c             	mov    0xc(%ebp),%edx
   11632:	01 ca                	add    %ecx,%edx
   11634:	0f b6 0a             	movzbl (%edx),%ecx
   11637:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1163a:	8b 55 10             	mov    0x10(%ebp),%edx
   1163d:	01 da                	add    %ebx,%edx
   1163f:	0f b6 12             	movzbl (%edx),%edx
   11642:	29 d1                	sub    %edx,%ecx
   11644:	89 ca                	mov    %ecx,%edx
   11646:	88 10                	mov    %dl,(%eax)
   11648:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1164c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1164f:	3b 45 14             	cmp    0x14(%ebp),%eax
   11652:	75 d0                	jne    11624 <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   11654:	e9 5a 02 00 00       	jmp    118b3 <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   11659:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11660:	eb 19                	jmp    1167b <filterScanline+0x125>
   11662:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11665:	8b 45 08             	mov    0x8(%ebp),%eax
   11668:	01 c2                	add    %eax,%edx
   1166a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1166d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11670:	01 c8                	add    %ecx,%eax
   11672:	0f b6 00             	movzbl (%eax),%eax
   11675:	88 02                	mov    %al,(%edx)
   11677:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1167b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1167e:	3b 45 14             	cmp    0x14(%ebp),%eax
   11681:	75 df                	jne    11662 <filterScanline+0x10c>
      }
      break;
   11683:	e9 2b 02 00 00       	jmp    118b3 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   11688:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1168c:	0f 84 90 00 00 00    	je     11722 <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   11692:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11699:	eb 28                	jmp    116c3 <filterScanline+0x16d>
   1169b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1169e:	8b 45 08             	mov    0x8(%ebp),%eax
   116a1:	01 d0                	add    %edx,%eax
   116a3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   116a6:	8b 55 0c             	mov    0xc(%ebp),%edx
   116a9:	01 ca                	add    %ecx,%edx
   116ab:	0f b6 12             	movzbl (%edx),%edx
   116ae:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   116b1:	8b 4d 10             	mov    0x10(%ebp),%ecx
   116b4:	01 d9                	add    %ebx,%ecx
   116b6:	0f b6 09             	movzbl (%ecx),%ecx
   116b9:	d0 e9                	shr    %cl
   116bb:	29 ca                	sub    %ecx,%edx
   116bd:	88 10                	mov    %dl,(%eax)
   116bf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   116c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116c6:	3b 45 18             	cmp    0x18(%ebp),%eax
   116c9:	75 d0                	jne    1169b <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   116cb:	8b 45 18             	mov    0x18(%ebp),%eax
   116ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
   116d1:	eb 42                	jmp    11715 <filterScanline+0x1bf>
   116d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116d6:	8b 45 08             	mov    0x8(%ebp),%eax
   116d9:	01 c2                	add    %eax,%edx
   116db:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   116de:	8b 45 0c             	mov    0xc(%ebp),%eax
   116e1:	01 c8                	add    %ecx,%eax
   116e3:	0f b6 08             	movzbl (%eax),%ecx
   116e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116e9:	2b 45 18             	sub    0x18(%ebp),%eax
   116ec:	89 c3                	mov    %eax,%ebx
   116ee:	8b 45 0c             	mov    0xc(%ebp),%eax
   116f1:	01 d8                	add    %ebx,%eax
   116f3:	0f b6 00             	movzbl (%eax),%eax
   116f6:	0f b6 d8             	movzbl %al,%ebx
   116f9:	8b 75 f4             	mov    -0xc(%ebp),%esi
   116fc:	8b 45 10             	mov    0x10(%ebp),%eax
   116ff:	01 f0                	add    %esi,%eax
   11701:	0f b6 00             	movzbl (%eax),%eax
   11704:	0f b6 c0             	movzbl %al,%eax
   11707:	01 d8                	add    %ebx,%eax
   11709:	d1 f8                	sar    %eax
   1170b:	29 c1                	sub    %eax,%ecx
   1170d:	89 c8                	mov    %ecx,%eax
   1170f:	88 02                	mov    %al,(%edx)
   11711:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11715:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11718:	3b 45 14             	cmp    0x14(%ebp),%eax
   1171b:	7c b6                	jl     116d3 <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   1171d:	e9 91 01 00 00       	jmp    118b3 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11722:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11729:	eb 19                	jmp    11744 <filterScanline+0x1ee>
   1172b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1172e:	8b 45 08             	mov    0x8(%ebp),%eax
   11731:	01 c2                	add    %eax,%edx
   11733:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11736:	8b 45 0c             	mov    0xc(%ebp),%eax
   11739:	01 c8                	add    %ecx,%eax
   1173b:	0f b6 00             	movzbl (%eax),%eax
   1173e:	88 02                	mov    %al,(%edx)
   11740:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11744:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11747:	3b 45 18             	cmp    0x18(%ebp),%eax
   1174a:	75 df                	jne    1172b <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   1174c:	8b 45 18             	mov    0x18(%ebp),%eax
   1174f:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11752:	eb 2f                	jmp    11783 <filterScanline+0x22d>
   11754:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11757:	8b 45 08             	mov    0x8(%ebp),%eax
   1175a:	01 c2                	add    %eax,%edx
   1175c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1175f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11762:	01 c8                	add    %ecx,%eax
   11764:	0f b6 08             	movzbl (%eax),%ecx
   11767:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1176a:	2b 45 18             	sub    0x18(%ebp),%eax
   1176d:	89 c3                	mov    %eax,%ebx
   1176f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11772:	01 d8                	add    %ebx,%eax
   11774:	0f b6 00             	movzbl (%eax),%eax
   11777:	d0 e8                	shr    %al
   11779:	29 c1                	sub    %eax,%ecx
   1177b:	89 c8                	mov    %ecx,%eax
   1177d:	88 02                	mov    %al,(%edx)
   1177f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11783:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11786:	3b 45 14             	cmp    0x14(%ebp),%eax
   11789:	7c c9                	jl     11754 <filterScanline+0x1fe>
      }
      break;
   1178b:	e9 23 01 00 00       	jmp    118b3 <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   11790:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11794:	0f 84 af 00 00 00    	je     11849 <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   1179a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   117a1:	eb 28                	jmp    117cb <filterScanline+0x275>
   117a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117a6:	8b 45 08             	mov    0x8(%ebp),%eax
   117a9:	01 d0                	add    %edx,%eax
   117ab:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117ae:	8b 55 0c             	mov    0xc(%ebp),%edx
   117b1:	01 ca                	add    %ecx,%edx
   117b3:	0f b6 0a             	movzbl (%edx),%ecx
   117b6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   117b9:	8b 55 10             	mov    0x10(%ebp),%edx
   117bc:	01 da                	add    %ebx,%edx
   117be:	0f b6 12             	movzbl (%edx),%edx
   117c1:	29 d1                	sub    %edx,%ecx
   117c3:	89 ca                	mov    %ecx,%edx
   117c5:	88 10                	mov    %dl,(%eax)
   117c7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117ce:	3b 45 18             	cmp    0x18(%ebp),%eax
   117d1:	75 d0                	jne    117a3 <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   117d3:	8b 45 18             	mov    0x18(%ebp),%eax
   117d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
   117d9:	eb 64                	jmp    1183f <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   117db:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117de:	8b 45 08             	mov    0x8(%ebp),%eax
   117e1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   117e4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   117ea:	01 d0                	add    %edx,%eax
   117ec:	0f b6 00             	movzbl (%eax),%eax
   117ef:	88 45 e7             	mov    %al,-0x19(%ebp)
   117f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117f5:	2b 45 18             	sub    0x18(%ebp),%eax
   117f8:	89 c2                	mov    %eax,%edx
   117fa:	8b 45 10             	mov    0x10(%ebp),%eax
   117fd:	01 d0                	add    %edx,%eax
   117ff:	0f b6 00             	movzbl (%eax),%eax
   11802:	0f b6 c8             	movzbl %al,%ecx
   11805:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11808:	8b 45 10             	mov    0x10(%ebp),%eax
   1180b:	01 d0                	add    %edx,%eax
   1180d:	0f b6 00             	movzbl (%eax),%eax
   11810:	0f b6 d0             	movzbl %al,%edx
   11813:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11816:	2b 45 18             	sub    0x18(%ebp),%eax
   11819:	89 c6                	mov    %eax,%esi
   1181b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1181e:	01 f0                	add    %esi,%eax
   11820:	0f b6 00             	movzbl (%eax),%eax
   11823:	0f b6 c0             	movzbl %al,%eax
   11826:	51                   	push   %ecx
   11827:	52                   	push   %edx
   11828:	50                   	push   %eax
   11829:	e8 49 b8 ff ff       	call   d077 <paethPredictor>
   1182e:	83 c4 0c             	add    $0xc,%esp
   11831:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   11835:	29 c1                	sub    %eax,%ecx
   11837:	89 c8                	mov    %ecx,%eax
   11839:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   1183b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1183f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11842:	3b 45 14             	cmp    0x14(%ebp),%eax
   11845:	7c 94                	jl     117db <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   11847:	eb 6a                	jmp    118b3 <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11849:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11850:	eb 19                	jmp    1186b <filterScanline+0x315>
   11852:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11855:	8b 45 08             	mov    0x8(%ebp),%eax
   11858:	01 c2                	add    %eax,%edx
   1185a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1185d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11860:	01 c8                	add    %ecx,%eax
   11862:	0f b6 00             	movzbl (%eax),%eax
   11865:	88 02                	mov    %al,(%edx)
   11867:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1186b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1186e:	3b 45 18             	cmp    0x18(%ebp),%eax
   11871:	75 df                	jne    11852 <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   11873:	8b 45 18             	mov    0x18(%ebp),%eax
   11876:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11879:	eb 2d                	jmp    118a8 <filterScanline+0x352>
   1187b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1187e:	8b 45 08             	mov    0x8(%ebp),%eax
   11881:	01 c2                	add    %eax,%edx
   11883:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11886:	8b 45 0c             	mov    0xc(%ebp),%eax
   11889:	01 c8                	add    %ecx,%eax
   1188b:	0f b6 08             	movzbl (%eax),%ecx
   1188e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11891:	2b 45 18             	sub    0x18(%ebp),%eax
   11894:	89 c3                	mov    %eax,%ebx
   11896:	8b 45 0c             	mov    0xc(%ebp),%eax
   11899:	01 d8                	add    %ebx,%eax
   1189b:	0f b6 00             	movzbl (%eax),%eax
   1189e:	29 c1                	sub    %eax,%ecx
   118a0:	89 c8                	mov    %ecx,%eax
   118a2:	88 02                	mov    %al,(%edx)
   118a4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   118a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118ab:	3b 45 14             	cmp    0x14(%ebp),%eax
   118ae:	7c cb                	jl     1187b <filterScanline+0x325>
      }
      break;
   118b0:	eb 01                	jmp    118b3 <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   118b2:	90                   	nop
  }
}
   118b3:	8d 65 f8             	lea    -0x8(%ebp),%esp
   118b6:	5b                   	pop    %ebx
   118b7:	5e                   	pop    %esi
   118b8:	5d                   	pop    %ebp
   118b9:	c3                   	ret    

000118ba <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   118ba:	55                   	push   %ebp
   118bb:	89 e5                	mov    %esp,%ebp
   118bd:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   118c0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   118c7:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   118ce:	7e 08                	jle    118d8 <ilog2+0x1e>
   118d0:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   118d4:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   118d8:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   118df:	7e 08                	jle    118e9 <ilog2+0x2f>
   118e1:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   118e5:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   118e9:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   118ed:	7e 08                	jle    118f7 <ilog2+0x3d>
   118ef:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   118f3:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   118f7:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   118fb:	7e 08                	jle    11905 <ilog2+0x4b>
   118fd:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   11901:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   11905:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   11909:	7e 04                	jle    1190f <ilog2+0x55>
   1190b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   1190f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11912:	c9                   	leave  
   11913:	c3                   	ret    

00011914 <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   11914:	55                   	push   %ebp
   11915:	89 e5                	mov    %esp,%ebp
   11917:	56                   	push   %esi
   11918:	53                   	push   %ebx
   11919:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   1191c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11920:	75 07                	jne    11929 <ilog2i+0x15>
   11922:	b8 00 00 00 00       	mov    $0x0,%eax
   11927:	eb 30                	jmp    11959 <ilog2i+0x45>
  l = ilog2(i);
   11929:	ff 75 08             	pushl  0x8(%ebp)
   1192c:	e8 89 ff ff ff       	call   118ba <ilog2>
   11931:	83 c4 04             	add    $0x4,%esp
   11934:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   11937:	8b 45 08             	mov    0x8(%ebp),%eax
   1193a:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   1193e:	89 c3                	mov    %eax,%ebx
   11940:	8b 55 08             	mov    0x8(%ebp),%edx
   11943:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11946:	be 01 00 00 00       	mov    $0x1,%esi
   1194b:	89 c1                	mov    %eax,%ecx
   1194d:	d3 e6                	shl    %cl,%esi
   1194f:	89 f0                	mov    %esi,%eax
   11951:	29 c2                	sub    %eax,%edx
   11953:	89 d0                	mov    %edx,%eax
   11955:	01 c0                	add    %eax,%eax
   11957:	01 d8                	add    %ebx,%eax
}
   11959:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1195c:	5b                   	pop    %ebx
   1195d:	5e                   	pop    %esi
   1195e:	5d                   	pop    %ebp
   1195f:	c3                   	ret    

00011960 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   11960:	55                   	push   %ebp
   11961:	89 e5                	mov    %esp,%ebp
   11963:	53                   	push   %ebx
   11964:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   1196a:	ff 75 18             	pushl  0x18(%ebp)
   1196d:	e8 6a 75 ff ff       	call   8edc <lodepng_get_bpp>
   11972:	83 c4 04             	add    $0x4,%esp
   11975:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   11978:	ff 75 b8             	pushl  -0x48(%ebp)
   1197b:	6a 01                	push   $0x1
   1197d:	ff 75 10             	pushl  0x10(%ebp)
   11980:	e8 b6 76 ff ff       	call   903b <lodepng_get_raw_size_idat>
   11985:	83 c4 0c             	add    $0xc,%esp
   11988:	83 e8 01             	sub    $0x1,%eax
   1198b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   1198e:	8b 45 b8             	mov    -0x48(%ebp),%eax
   11991:	83 c0 07             	add    $0x7,%eax
   11994:	c1 e8 03             	shr    $0x3,%eax
   11997:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   1199a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   119a1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   119a8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   119ab:	8b 40 2c             	mov    0x2c(%eax),%eax
   119ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   119b1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   119b4:	8b 40 28             	mov    0x28(%eax),%eax
   119b7:	85 c0                	test   %eax,%eax
   119b9:	74 1c                	je     119d7 <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   119bb:	8b 45 18             	mov    0x18(%ebp),%eax
   119be:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   119c0:	83 f8 03             	cmp    $0x3,%eax
   119c3:	74 0b                	je     119d0 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   119c5:	8b 45 18             	mov    0x18(%ebp),%eax
   119c8:	8b 40 04             	mov    0x4(%eax),%eax
   119cb:	83 f8 07             	cmp    $0x7,%eax
   119ce:	77 07                	ja     119d7 <filter+0x77>
   119d0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   119d7:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   119db:	75 0a                	jne    119e7 <filter+0x87>
   119dd:	b8 1f 00 00 00       	mov    $0x1f,%eax
   119e2:	e9 5b 07 00 00       	jmp    12142 <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   119e7:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   119eb:	77 7b                	ja     11a68 <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   119ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119f0:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   119f3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   119fa:	eb 5f                	jmp    11a5b <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   119fc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   119ff:	83 c0 01             	add    $0x1,%eax
   11a02:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11a06:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   11a09:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11a0c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11a10:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   11a13:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11a16:	8b 45 08             	mov    0x8(%ebp),%eax
   11a19:	01 c2                	add    %eax,%edx
   11a1b:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11a1f:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11a21:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11a25:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   11a28:	8b 55 0c             	mov    0xc(%ebp),%edx
   11a2b:	01 d1                	add    %edx,%ecx
   11a2d:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11a30:	8d 5a 01             	lea    0x1(%edx),%ebx
   11a33:	8b 55 08             	mov    0x8(%ebp),%edx
   11a36:	01 da                	add    %ebx,%edx
   11a38:	50                   	push   %eax
   11a39:	ff 75 b0             	pushl  -0x50(%ebp)
   11a3c:	ff 75 b4             	pushl  -0x4c(%ebp)
   11a3f:	ff 75 f4             	pushl  -0xc(%ebp)
   11a42:	51                   	push   %ecx
   11a43:	52                   	push   %edx
   11a44:	e8 0d fb ff ff       	call   11556 <filterScanline>
   11a49:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   11a4c:	8b 55 98             	mov    -0x68(%ebp),%edx
   11a4f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a52:	01 d0                	add    %edx,%eax
   11a54:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   11a57:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11a5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a5e:	3b 45 14             	cmp    0x14(%ebp),%eax
   11a61:	75 99                	jne    119fc <filter+0x9c>
   11a63:	e9 d7 06 00 00       	jmp    1213f <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   11a68:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   11a6c:	0f 85 e3 01 00 00    	jne    11c55 <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11a72:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   11a79:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   11a7d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11a81:	eb 2d                	jmp    11ab0 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11a83:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   11a87:	83 ec 0c             	sub    $0xc,%esp
   11a8a:	ff 75 b4             	pushl  -0x4c(%ebp)
   11a8d:	e8 2e 19 ff ff       	call   33c0 <lodepng_malloc>
   11a92:	83 c4 10             	add    $0x10,%esp
   11a95:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11a99:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a9d:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11aa1:	85 c0                	test   %eax,%eax
   11aa3:	75 07                	jne    11aac <filter+0x14c>
   11aa5:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   11aac:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11ab0:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11ab4:	75 cd                	jne    11a83 <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11ab6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11aba:	0f 85 6c 01 00 00    	jne    11c2c <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   11ac0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11ac7:	e9 54 01 00 00       	jmp    11c20 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11acc:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11ad0:	e9 d5 00 00 00       	jmp    11baa <filter+0x24a>
          size_t sum = 0;
   11ad5:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11adc:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   11ae0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ae3:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ae7:	89 c1                	mov    %eax,%ecx
   11ae9:	8b 45 0c             	mov    0xc(%ebp),%eax
   11aec:	01 c1                	add    %eax,%ecx
   11aee:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11af2:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11af6:	83 ec 08             	sub    $0x8,%esp
   11af9:	52                   	push   %edx
   11afa:	ff 75 b0             	pushl  -0x50(%ebp)
   11afd:	ff 75 b4             	pushl  -0x4c(%ebp)
   11b00:	ff 75 f4             	pushl  -0xc(%ebp)
   11b03:	51                   	push   %ecx
   11b04:	50                   	push   %eax
   11b05:	e8 4c fa ff ff       	call   11556 <filterScanline>
   11b0a:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   11b0d:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11b11:	75 2d                	jne    11b40 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   11b13:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11b1a:	eb 1a                	jmp    11b36 <filter+0x1d6>
   11b1c:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b20:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11b24:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b27:	01 d0                	add    %edx,%eax
   11b29:	0f b6 00             	movzbl (%eax),%eax
   11b2c:	0f b6 c0             	movzbl %al,%eax
   11b2f:	01 45 d8             	add    %eax,-0x28(%ebp)
   11b32:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11b36:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b39:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11b3c:	75 de                	jne    11b1c <filter+0x1bc>
   11b3e:	eb 4b                	jmp    11b8b <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   11b40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11b47:	eb 3a                	jmp    11b83 <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   11b49:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b4d:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11b51:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b54:	01 d0                	add    %edx,%eax
   11b56:	0f b6 00             	movzbl (%eax),%eax
   11b59:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   11b5c:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11b60:	84 c0                	test   %al,%al
   11b62:	78 06                	js     11b6a <filter+0x20a>
   11b64:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11b68:	eb 0d                	jmp    11b77 <filter+0x217>
   11b6a:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11b6e:	ba ff 00 00 00       	mov    $0xff,%edx
   11b73:	29 c2                	sub    %eax,%edx
   11b75:	89 d0                	mov    %edx,%eax
   11b77:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11b7a:	01 d0                	add    %edx,%eax
   11b7c:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   11b7f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11b83:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b86:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11b89:	75 be                	jne    11b49 <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   11b8b:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11b8f:	74 08                	je     11b99 <filter+0x239>
   11b91:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11b94:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   11b97:	7d 0d                	jge    11ba6 <filter+0x246>
            bestType = type;
   11b99:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b9d:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   11ba0:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ba3:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11ba6:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11baa:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11bae:	0f 85 21 ff ff ff    	jne    11ad5 <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   11bb4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11bb7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11bbb:	89 c2                	mov    %eax,%edx
   11bbd:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bc0:	01 d0                	add    %edx,%eax
   11bc2:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11bc5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11bc8:	83 c0 01             	add    $0x1,%eax
   11bcb:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11bcf:	89 c2                	mov    %eax,%edx
   11bd1:	8b 45 08             	mov    0x8(%ebp),%eax
   11bd4:	01 c2                	add    %eax,%edx
   11bd6:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11bda:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11bdc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11be3:	eb 2f                	jmp    11c14 <filter+0x2b4>
   11be5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11be8:	83 c0 01             	add    $0x1,%eax
   11beb:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11bef:	89 c2                	mov    %eax,%edx
   11bf1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11bf4:	01 d0                	add    %edx,%eax
   11bf6:	8d 50 01             	lea    0x1(%eax),%edx
   11bf9:	8b 45 08             	mov    0x8(%ebp),%eax
   11bfc:	01 c2                	add    %eax,%edx
   11bfe:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11c02:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   11c06:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c09:	01 c8                	add    %ecx,%eax
   11c0b:	0f b6 00             	movzbl (%eax),%eax
   11c0e:	88 02                	mov    %al,(%edx)
   11c10:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11c14:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c17:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11c1a:	75 c9                	jne    11be5 <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11c1c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11c20:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11c23:	3b 45 14             	cmp    0x14(%ebp),%eax
   11c26:	0f 85 a0 fe ff ff    	jne    11acc <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11c2c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11c30:	eb 18                	jmp    11c4a <filter+0x2ea>
   11c32:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11c36:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11c3a:	83 ec 0c             	sub    $0xc,%esp
   11c3d:	50                   	push   %eax
   11c3e:	e8 9e 17 ff ff       	call   33e1 <lodepng_free>
   11c43:	83 c4 10             	add    $0x10,%esp
   11c46:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11c4a:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11c4e:	75 e2                	jne    11c32 <filter+0x2d2>
   11c50:	e9 ea 04 00 00       	jmp    1213f <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   11c55:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   11c59:	0f 85 17 02 00 00    	jne    11e76 <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   11c5f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   11c66:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11c6d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11c74:	eb 33                	jmp    11ca9 <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11c76:	83 ec 0c             	sub    $0xc,%esp
   11c79:	ff 75 b4             	pushl  -0x4c(%ebp)
   11c7c:	e8 3f 17 ff ff       	call   33c0 <lodepng_malloc>
   11c81:	83 c4 10             	add    $0x10,%esp
   11c84:	89 c2                	mov    %eax,%edx
   11c86:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c89:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11c90:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c93:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11c9a:	85 c0                	test   %eax,%eax
   11c9c:	75 07                	jne    11ca5 <filter+0x345>
   11c9e:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11ca5:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11ca9:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11cad:	75 c7                	jne    11c76 <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11caf:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11cb3:	0f 85 8f 01 00 00    	jne    11e48 <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   11cb9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11cc0:	e9 77 01 00 00       	jmp    11e3c <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11cc5:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11ccc:	e9 f4 00 00 00       	jmp    11dc5 <filter+0x465>
          size_t sum = 0;
   11cd1:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11cd8:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11cdb:	0f b6 d0             	movzbl %al,%edx
   11cde:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ce1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ce5:	89 c1                	mov    %eax,%ecx
   11ce7:	8b 45 0c             	mov    0xc(%ebp),%eax
   11cea:	01 c1                	add    %eax,%ecx
   11cec:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11cef:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11cf6:	83 ec 08             	sub    $0x8,%esp
   11cf9:	52                   	push   %edx
   11cfa:	ff 75 b0             	pushl  -0x50(%ebp)
   11cfd:	ff 75 b4             	pushl  -0x4c(%ebp)
   11d00:	ff 75 f4             	pushl  -0xc(%ebp)
   11d03:	51                   	push   %ecx
   11d04:	50                   	push   %eax
   11d05:	e8 4c f8 ff ff       	call   11556 <filterScanline>
   11d0a:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   11d0d:	83 ec 04             	sub    $0x4,%esp
   11d10:	68 00 04 00 00       	push   $0x400
   11d15:	6a 00                	push   $0x0
   11d17:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11d1d:	50                   	push   %eax
   11d1e:	e8 0e 17 ff ff       	call   3431 <lodepng_memset>
   11d23:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   11d26:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d2d:	eb 2a                	jmp    11d59 <filter+0x3f9>
   11d2f:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d32:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   11d39:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d3c:	01 d0                	add    %edx,%eax
   11d3e:	0f b6 00             	movzbl (%eax),%eax
   11d41:	0f b6 c0             	movzbl %al,%eax
   11d44:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   11d4b:	83 c2 01             	add    $0x1,%edx
   11d4e:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   11d55:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d59:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d5c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11d5f:	75 ce                	jne    11d2f <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   11d61:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d64:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11d6b:	8d 50 01             	lea    0x1(%eax),%edx
   11d6e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d71:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   11d78:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d7f:	eb 1d                	jmp    11d9e <filter+0x43e>
            sum += ilog2i(count[x]);
   11d81:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d84:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11d8b:	83 ec 0c             	sub    $0xc,%esp
   11d8e:	50                   	push   %eax
   11d8f:	e8 80 fb ff ff       	call   11914 <ilog2i>
   11d94:	83 c4 10             	add    $0x10,%esp
   11d97:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   11d9a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d9e:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   11da5:	75 da                	jne    11d81 <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   11da7:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   11dab:	74 08                	je     11db5 <filter+0x455>
   11dad:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11db0:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   11db3:	7e 0c                	jle    11dc1 <filter+0x461>
            bestType = type;
   11db5:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11db8:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   11dbb:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11dbe:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11dc1:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11dc5:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11dc9:	0f 85 02 ff ff ff    	jne    11cd1 <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   11dcf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11dd2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11dd6:	89 c2                	mov    %eax,%edx
   11dd8:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ddb:	01 d0                	add    %edx,%eax
   11ddd:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11de0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11de3:	83 c0 01             	add    $0x1,%eax
   11de6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11dea:	89 c2                	mov    %eax,%edx
   11dec:	8b 45 08             	mov    0x8(%ebp),%eax
   11def:	01 d0                	add    %edx,%eax
   11df1:	8b 55 cc             	mov    -0x34(%ebp),%edx
   11df4:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11df6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11dfd:	eb 31                	jmp    11e30 <filter+0x4d0>
   11dff:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e02:	83 c0 01             	add    $0x1,%eax
   11e05:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e09:	89 c2                	mov    %eax,%edx
   11e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e0e:	01 d0                	add    %edx,%eax
   11e10:	8d 50 01             	lea    0x1(%eax),%edx
   11e13:	8b 45 08             	mov    0x8(%ebp),%eax
   11e16:	01 c2                	add    %eax,%edx
   11e18:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11e1b:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   11e22:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e25:	01 c8                	add    %ecx,%eax
   11e27:	0f b6 00             	movzbl (%eax),%eax
   11e2a:	88 02                	mov    %al,(%edx)
   11e2c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11e30:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e33:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11e36:	75 c7                	jne    11dff <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11e38:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11e3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e3f:	3b 45 14             	cmp    0x14(%ebp),%eax
   11e42:	0f 85 7d fe ff ff    	jne    11cc5 <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11e48:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11e4f:	eb 1a                	jmp    11e6b <filter+0x50b>
   11e51:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11e54:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11e5b:	83 ec 0c             	sub    $0xc,%esp
   11e5e:	50                   	push   %eax
   11e5f:	e8 7d 15 ff ff       	call   33e1 <lodepng_free>
   11e64:	83 c4 10             	add    $0x10,%esp
   11e67:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11e6b:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11e6f:	75 e0                	jne    11e51 <filter+0x4f1>
   11e71:	e9 c9 02 00 00       	jmp    1213f <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   11e76:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   11e7a:	0f 85 89 00 00 00    	jne    11f09 <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   11e80:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11e87:	eb 73                	jmp    11efc <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11e89:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e8c:	83 c0 01             	add    $0x1,%eax
   11e8f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e93:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   11e96:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e99:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e9d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   11ea0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11ea3:	8b 50 30             	mov    0x30(%eax),%edx
   11ea6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11ea9:	01 d0                	add    %edx,%eax
   11eab:	0f b6 00             	movzbl (%eax),%eax
   11eae:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   11eb1:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11eb4:	8b 45 08             	mov    0x8(%ebp),%eax
   11eb7:	01 c2                	add    %eax,%edx
   11eb9:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11ebd:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11ebf:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11ec3:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   11ec6:	8b 55 0c             	mov    0xc(%ebp),%edx
   11ec9:	01 d1                	add    %edx,%ecx
   11ecb:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11ece:	8d 5a 01             	lea    0x1(%edx),%ebx
   11ed1:	8b 55 08             	mov    0x8(%ebp),%edx
   11ed4:	01 da                	add    %ebx,%edx
   11ed6:	83 ec 08             	sub    $0x8,%esp
   11ed9:	50                   	push   %eax
   11eda:	ff 75 b0             	pushl  -0x50(%ebp)
   11edd:	ff 75 b4             	pushl  -0x4c(%ebp)
   11ee0:	ff 75 f4             	pushl  -0xc(%ebp)
   11ee3:	51                   	push   %ecx
   11ee4:	52                   	push   %edx
   11ee5:	e8 6c f6 ff ff       	call   11556 <filterScanline>
   11eea:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   11eed:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   11ef0:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ef3:	01 d0                	add    %edx,%eax
   11ef5:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   11ef8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11efc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11eff:	3b 45 14             	cmp    0x14(%ebp),%eax
   11f02:	75 85                	jne    11e89 <filter+0x529>
   11f04:	e9 36 02 00 00       	jmp    1213f <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   11f09:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   11f0d:	0f 85 25 02 00 00    	jne    12138 <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11f13:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   11f1a:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11f21:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   11f28:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11f2b:	83 ec 04             	sub    $0x4,%esp
   11f2e:	6a 24                	push   $0x24
   11f30:	50                   	push   %eax
   11f31:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11f37:	50                   	push   %eax
   11f38:	e8 c1 14 ff ff       	call   33fe <lodepng_memcpy>
   11f3d:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   11f40:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   11f47:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   11f4a:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   11f51:	00 00 00 
    zlibsettings.custom_deflate = 0;
   11f54:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   11f5b:	00 00 00 
    for(type = 0; type != 5; ++type) {
   11f5e:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11f65:	eb 33                	jmp    11f9a <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11f67:	83 ec 0c             	sub    $0xc,%esp
   11f6a:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f6d:	e8 4e 14 ff ff       	call   33c0 <lodepng_malloc>
   11f72:	83 c4 10             	add    $0x10,%esp
   11f75:	89 c2                	mov    %eax,%edx
   11f77:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f7a:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11f81:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f84:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11f8b:	85 c0                	test   %eax,%eax
   11f8d:	75 07                	jne    11f96 <filter+0x636>
   11f8f:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   11f96:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   11f9a:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   11f9e:	75 c7                	jne    11f67 <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   11fa0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11fa4:	0f 85 63 01 00 00    	jne    1210d <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   11faa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11fb1:	e9 4b 01 00 00       	jmp    12101 <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   11fb6:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11fbd:	e9 c8 00 00 00       	jmp    1208a <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   11fc2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11fc5:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11fc8:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fcb:	0f b6 d0             	movzbl %al,%edx
   11fce:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11fd1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11fd5:	89 c1                	mov    %eax,%ecx
   11fd7:	8b 45 0c             	mov    0xc(%ebp),%eax
   11fda:	01 c1                	add    %eax,%ecx
   11fdc:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fdf:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11fe6:	83 ec 08             	sub    $0x8,%esp
   11fe9:	52                   	push   %edx
   11fea:	ff 75 b0             	pushl  -0x50(%ebp)
   11fed:	ff 75 b4             	pushl  -0x4c(%ebp)
   11ff0:	ff 75 f4             	pushl  -0xc(%ebp)
   11ff3:	51                   	push   %ecx
   11ff4:	50                   	push   %eax
   11ff5:	e8 5c f5 ff ff       	call   11556 <filterScanline>
   11ffa:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   11ffd:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12000:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   12007:	00 00 00 00 
          dummy = 0;
   1200b:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   12012:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   12015:	8b 55 ac             	mov    -0x54(%ebp),%edx
   12018:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1201b:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12022:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   12028:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   1202b:	c1 e3 02             	shl    $0x2,%ebx
   1202e:	01 cb                	add    %ecx,%ebx
   12030:	83 ec 0c             	sub    $0xc,%esp
   12033:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   12039:	51                   	push   %ecx
   1203a:	52                   	push   %edx
   1203b:	50                   	push   %eax
   1203c:	53                   	push   %ebx
   1203d:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   12043:	50                   	push   %eax
   12044:	e8 87 60 ff ff       	call   80d0 <zlib_compress>
   12049:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   1204c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   12052:	83 ec 0c             	sub    $0xc,%esp
   12055:	50                   	push   %eax
   12056:	e8 86 13 ff ff       	call   33e1 <lodepng_free>
   1205b:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   1205e:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   12062:	74 0f                	je     12073 <filter+0x713>
   12064:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12067:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   1206e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   12071:	7d 13                	jge    12086 <filter+0x726>
            bestType = type;
   12073:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12076:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   12079:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1207c:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   12083:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   12086:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   1208a:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   1208e:	0f 85 2e ff ff ff    	jne    11fc2 <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   12094:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12097:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1209b:	89 c2                	mov    %eax,%edx
   1209d:	8b 45 0c             	mov    0xc(%ebp),%eax
   120a0:	01 d0                	add    %edx,%eax
   120a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   120a5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120a8:	83 c0 01             	add    $0x1,%eax
   120ab:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   120af:	89 c2                	mov    %eax,%edx
   120b1:	8b 45 08             	mov    0x8(%ebp),%eax
   120b4:	01 d0                	add    %edx,%eax
   120b6:	8b 55 bc             	mov    -0x44(%ebp),%edx
   120b9:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   120bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   120c2:	eb 31                	jmp    120f5 <filter+0x795>
   120c4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120c7:	83 c0 01             	add    $0x1,%eax
   120ca:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   120ce:	89 c2                	mov    %eax,%edx
   120d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120d3:	01 d0                	add    %edx,%eax
   120d5:	8d 50 01             	lea    0x1(%eax),%edx
   120d8:	8b 45 08             	mov    0x8(%ebp),%eax
   120db:	01 c2                	add    %eax,%edx
   120dd:	8b 45 bc             	mov    -0x44(%ebp),%eax
   120e0:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   120e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120ea:	01 c8                	add    %ecx,%eax
   120ec:	0f b6 00             	movzbl (%eax),%eax
   120ef:	88 02                	mov    %al,(%edx)
   120f1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   120f5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120f8:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   120fb:	75 c7                	jne    120c4 <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   120fd:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12101:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12104:	3b 45 14             	cmp    0x14(%ebp),%eax
   12107:	0f 85 a9 fe ff ff    	jne    11fb6 <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   1210d:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12114:	eb 1a                	jmp    12130 <filter+0x7d0>
   12116:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12119:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12120:	83 ec 0c             	sub    $0xc,%esp
   12123:	50                   	push   %eax
   12124:	e8 b8 12 ff ff       	call   33e1 <lodepng_free>
   12129:	83 c4 10             	add    $0x10,%esp
   1212c:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12130:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12134:	75 e0                	jne    12116 <filter+0x7b6>
   12136:	eb 07                	jmp    1213f <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   12138:	b8 58 00 00 00       	mov    $0x58,%eax
   1213d:	eb 03                	jmp    12142 <filter+0x7e2>

  return error;
   1213f:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   12142:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12145:	c9                   	leave  
   12146:	c3                   	ret    

00012147 <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   12147:	55                   	push   %ebp
   12148:	89 e5                	mov    %esp,%ebp
   1214a:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   1214d:	8b 45 10             	mov    0x10(%ebp),%eax
   12150:	2b 45 14             	sub    0x14(%ebp),%eax
   12153:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   12156:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1215d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   12164:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1216b:	eb 65                	jmp    121d2 <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   1216d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12174:	eb 2a                	jmp    121a0 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   12176:	ff 75 0c             	pushl  0xc(%ebp)
   12179:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1217c:	50                   	push   %eax
   1217d:	e8 9d 60 ff ff       	call   821f <readBitFromReversedStream>
   12182:	83 c4 08             	add    $0x8,%esp
   12185:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   12188:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   1218c:	50                   	push   %eax
   1218d:	ff 75 08             	pushl  0x8(%ebp)
   12190:	8d 45 ec             	lea    -0x14(%ebp),%eax
   12193:	50                   	push   %eax
   12194:	e8 08 61 ff ff       	call   82a1 <setBitOfReversedStream>
   12199:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   1219c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   121a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   121a3:	3b 45 14             	cmp    0x14(%ebp),%eax
   121a6:	7c ce                	jl     12176 <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   121a8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   121af:	eb 15                	jmp    121c6 <addPaddingBits+0x7f>
   121b1:	6a 00                	push   $0x0
   121b3:	ff 75 08             	pushl  0x8(%ebp)
   121b6:	8d 45 ec             	lea    -0x14(%ebp),%eax
   121b9:	50                   	push   %eax
   121ba:	e8 e2 60 ff ff       	call   82a1 <setBitOfReversedStream>
   121bf:	83 c4 0c             	add    $0xc,%esp
   121c2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   121c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   121c9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   121cc:	75 e3                	jne    121b1 <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   121ce:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   121d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121d5:	3b 45 18             	cmp    0x18(%ebp),%eax
   121d8:	75 93                	jne    1216d <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   121da:	90                   	nop
   121db:	c9                   	leave  
   121dc:	c3                   	ret    

000121dd <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   121dd:	55                   	push   %ebp
   121de:	89 e5                	mov    %esp,%ebp
   121e0:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   121e6:	ff 75 18             	pushl  0x18(%ebp)
   121e9:	ff 75 14             	pushl  0x14(%ebp)
   121ec:	ff 75 10             	pushl  0x10(%ebp)
   121ef:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   121f5:	50                   	push   %eax
   121f6:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   121fc:	50                   	push   %eax
   121fd:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12203:	50                   	push   %eax
   12204:	8d 45 94             	lea    -0x6c(%ebp),%eax
   12207:	50                   	push   %eax
   12208:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1220b:	50                   	push   %eax
   1220c:	e8 fc ae ff ff       	call   d10d <Adam7_getpassvalues>
   12211:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   12214:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   12218:	0f 86 0a 01 00 00    	jbe    12328 <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   1221e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12225:	e9 ef 00 00 00       	jmp    12319 <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   1222a:	8b 45 18             	mov    0x18(%ebp),%eax
   1222d:	c1 e8 03             	shr    $0x3,%eax
   12230:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   12233:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1223a:	e9 c6 00 00 00       	jmp    12305 <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   1223f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12246:	e9 a6 00 00 00       	jmp    122f1 <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   1224b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1224e:	8b 14 85 98 a0 01 00 	mov    0x1a098(,%eax,4),%edx
   12255:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12258:	8b 04 85 d0 a0 01 00 	mov    0x1a0d0(,%eax,4),%eax
   1225f:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   12263:	01 d0                	add    %edx,%eax
   12265:	0f af 45 10          	imul   0x10(%ebp),%eax
   12269:	89 c2                	mov    %eax,%edx
   1226b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1226e:	8b 04 85 b4 a0 01 00 	mov    0x1a0b4(,%eax,4),%eax
   12275:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   12279:	01 c2                	add    %eax,%edx
   1227b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1227e:	8b 04 85 7c a0 01 00 	mov    0x1a07c(,%eax,4),%eax
   12285:	01 c2                	add    %eax,%edx
   12287:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1228a:	0f af c2             	imul   %edx,%eax
   1228d:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   12290:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12293:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   1229a:	89 c1                	mov    %eax,%ecx
   1229c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1229f:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   122a3:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   122a7:	89 c2                	mov    %eax,%edx
   122a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   122ac:	01 c2                	add    %eax,%edx
   122ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
   122b1:	0f af c2             	imul   %edx,%eax
   122b4:	01 c8                	add    %ecx,%eax
   122b6:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   122b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   122c0:	eb 23                	jmp    122e5 <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   122c2:	8b 55 d8             	mov    -0x28(%ebp),%edx
   122c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   122c8:	01 c2                	add    %eax,%edx
   122ca:	8b 45 08             	mov    0x8(%ebp),%eax
   122cd:	01 c2                	add    %eax,%edx
   122cf:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   122d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   122d5:	01 c1                	add    %eax,%ecx
   122d7:	8b 45 0c             	mov    0xc(%ebp),%eax
   122da:	01 c8                	add    %ecx,%eax
   122dc:	0f b6 00             	movzbl (%eax),%eax
   122df:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   122e1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   122e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   122e8:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   122eb:	72 d5                	jb     122c2 <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   122ed:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   122f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122f4:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   122f8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   122fb:	0f 87 4a ff ff ff    	ja     1224b <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   12301:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12305:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12308:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   1230c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1230f:	0f 87 2a ff ff ff    	ja     1223f <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   12315:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12319:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   1231d:	0f 85 07 ff ff ff    	jne    1222a <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12323:	e9 22 01 00 00       	jmp    1244a <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   12328:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1232f:	e9 0c 01 00 00       	jmp    12440 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   12334:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12337:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1233b:	0f af 45 18          	imul   0x18(%ebp),%eax
   1233f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   12342:	8b 45 18             	mov    0x18(%ebp),%eax
   12345:	0f af 45 10          	imul   0x10(%ebp),%eax
   12349:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   1234c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   12353:	e9 d4 00 00 00       	jmp    1242c <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   12358:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1235f:	e9 b4 00 00 00       	jmp    12418 <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   12364:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12367:	8b 14 85 98 a0 01 00 	mov    0x1a098(,%eax,4),%edx
   1236e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12371:	8b 04 85 d0 a0 01 00 	mov    0x1a0d0(,%eax,4),%eax
   12378:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   1237c:	01 d0                	add    %edx,%eax
   1237e:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   12382:	89 c2                	mov    %eax,%edx
   12384:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12387:	8b 0c 85 7c a0 01 00 	mov    0x1a07c(,%eax,4),%ecx
   1238e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12391:	8b 04 85 b4 a0 01 00 	mov    0x1a0b4(,%eax,4),%eax
   12398:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1239c:	01 c8                	add    %ecx,%eax
   1239e:	0f af 45 18          	imul   0x18(%ebp),%eax
   123a2:	01 d0                	add    %edx,%eax
   123a4:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   123aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123ad:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   123b4:	c1 e0 03             	shl    $0x3,%eax
   123b7:	89 c1                	mov    %eax,%ecx
   123b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   123bc:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   123c0:	89 c2                	mov    %eax,%edx
   123c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   123c5:	0f af 45 18          	imul   0x18(%ebp),%eax
   123c9:	01 d0                	add    %edx,%eax
   123cb:	01 c8                	add    %ecx,%eax
   123cd:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   123d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   123da:	eb 30                	jmp    1240c <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   123dc:	ff 75 0c             	pushl  0xc(%ebp)
   123df:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   123e5:	50                   	push   %eax
   123e6:	e8 34 5e ff ff       	call   821f <readBitFromReversedStream>
   123eb:	83 c4 08             	add    $0x8,%esp
   123ee:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   123f1:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   123f5:	50                   	push   %eax
   123f6:	ff 75 08             	pushl  0x8(%ebp)
   123f9:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   123ff:	50                   	push   %eax
   12400:	e8 9c 5e ff ff       	call   82a1 <setBitOfReversedStream>
   12405:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   12408:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1240c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1240f:	3b 45 18             	cmp    0x18(%ebp),%eax
   12412:	72 c8                	jb     123dc <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12414:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12418:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1241b:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1241f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   12422:	0f 87 3c ff ff ff    	ja     12364 <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   12428:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   1242c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1242f:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12433:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   12436:	0f 87 1c ff ff ff    	ja     12358 <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1243c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12440:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12444:	0f 85 ea fe ff ff    	jne    12334 <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   1244a:	90                   	nop
   1244b:	c9                   	leave  
   1244c:	c3                   	ret    

0001244d <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   1244d:	55                   	push   %ebp
   1244e:	89 e5                	mov    %esp,%ebp
   12450:	57                   	push   %edi
   12451:	56                   	push   %esi
   12452:	53                   	push   %ebx
   12453:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   12459:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1245c:	83 c0 0c             	add    $0xc,%eax
   1245f:	50                   	push   %eax
   12460:	e8 77 6a ff ff       	call   8edc <lodepng_get_bpp>
   12465:	83 c4 04             	add    $0x4,%esp
   12468:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   1246b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   12472:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12475:	8b 40 08             	mov    0x8(%eax),%eax
   12478:	85 c0                	test   %eax,%eax
   1247a:	0f 85 49 01 00 00    	jne    125c9 <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   12480:	8b 45 14             	mov    0x14(%ebp),%eax
   12483:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12487:	83 c0 07             	add    $0x7,%eax
   1248a:	c1 e8 03             	shr    $0x3,%eax
   1248d:	83 c0 01             	add    $0x1,%eax
   12490:	0f af 45 18          	imul   0x18(%ebp),%eax
   12494:	89 c2                	mov    %eax,%edx
   12496:	8b 45 0c             	mov    0xc(%ebp),%eax
   12499:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   1249b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1249e:	8b 00                	mov    (%eax),%eax
   124a0:	83 ec 0c             	sub    $0xc,%esp
   124a3:	50                   	push   %eax
   124a4:	e8 17 0f ff ff       	call   33c0 <lodepng_malloc>
   124a9:	83 c4 10             	add    $0x10,%esp
   124ac:	89 c2                	mov    %eax,%edx
   124ae:	8b 45 08             	mov    0x8(%ebp),%eax
   124b1:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   124b3:	8b 45 08             	mov    0x8(%ebp),%eax
   124b6:	8b 00                	mov    (%eax),%eax
   124b8:	85 c0                	test   %eax,%eax
   124ba:	75 10                	jne    124cc <preProcessScanlines+0x7f>
   124bc:	8b 45 0c             	mov    0xc(%ebp),%eax
   124bf:	8b 00                	mov    (%eax),%eax
   124c1:	85 c0                	test   %eax,%eax
   124c3:	74 07                	je     124cc <preProcessScanlines+0x7f>
   124c5:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   124cc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   124d0:	0f 85 fb 02 00 00    	jne    127d1 <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   124d6:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   124da:	0f 87 bd 00 00 00    	ja     1259d <preProcessScanlines+0x150>
   124e0:	8b 45 14             	mov    0x14(%ebp),%eax
   124e3:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   124e7:	89 c2                	mov    %eax,%edx
   124e9:	8b 45 14             	mov    0x14(%ebp),%eax
   124ec:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   124f0:	83 c0 07             	add    $0x7,%eax
   124f3:	c1 e8 03             	shr    $0x3,%eax
   124f6:	c1 e0 03             	shl    $0x3,%eax
   124f9:	39 c2                	cmp    %eax,%edx
   124fb:	0f 84 9c 00 00 00    	je     1259d <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   12501:	8b 45 14             	mov    0x14(%ebp),%eax
   12504:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12508:	83 c0 07             	add    $0x7,%eax
   1250b:	c1 e8 03             	shr    $0x3,%eax
   1250e:	0f af 45 18          	imul   0x18(%ebp),%eax
   12512:	83 ec 0c             	sub    $0xc,%esp
   12515:	50                   	push   %eax
   12516:	e8 a5 0e ff ff       	call   33c0 <lodepng_malloc>
   1251b:	83 c4 10             	add    $0x10,%esp
   1251e:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   12521:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12525:	75 07                	jne    1252e <preProcessScanlines+0xe1>
   12527:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   1252e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12532:	75 56                	jne    1258a <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   12534:	8b 45 14             	mov    0x14(%ebp),%eax
   12537:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1253b:	89 c2                	mov    %eax,%edx
   1253d:	8b 45 14             	mov    0x14(%ebp),%eax
   12540:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12544:	83 c0 07             	add    $0x7,%eax
   12547:	c1 e8 03             	shr    $0x3,%eax
   1254a:	c1 e0 03             	shl    $0x3,%eax
   1254d:	83 ec 0c             	sub    $0xc,%esp
   12550:	ff 75 18             	pushl  0x18(%ebp)
   12553:	52                   	push   %edx
   12554:	50                   	push   %eax
   12555:	ff 75 10             	pushl  0x10(%ebp)
   12558:	ff 75 d8             	pushl  -0x28(%ebp)
   1255b:	e8 e7 fb ff ff       	call   12147 <addPaddingBits>
   12560:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   12563:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12566:	8d 50 0c             	lea    0xc(%eax),%edx
   12569:	8b 45 08             	mov    0x8(%ebp),%eax
   1256c:	8b 00                	mov    (%eax),%eax
   1256e:	83 ec 08             	sub    $0x8,%esp
   12571:	ff 75 20             	pushl  0x20(%ebp)
   12574:	52                   	push   %edx
   12575:	ff 75 18             	pushl  0x18(%ebp)
   12578:	ff 75 14             	pushl  0x14(%ebp)
   1257b:	ff 75 d8             	pushl  -0x28(%ebp)
   1257e:	50                   	push   %eax
   1257f:	e8 dc f3 ff ff       	call   11960 <filter>
   12584:	83 c4 20             	add    $0x20,%esp
   12587:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   1258a:	83 ec 0c             	sub    $0xc,%esp
   1258d:	ff 75 d8             	pushl  -0x28(%ebp)
   12590:	e8 4c 0e ff ff       	call   33e1 <lodepng_free>
   12595:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   12598:	e9 34 02 00 00       	jmp    127d1 <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   1259d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   125a0:	8d 50 0c             	lea    0xc(%eax),%edx
   125a3:	8b 45 08             	mov    0x8(%ebp),%eax
   125a6:	8b 00                	mov    (%eax),%eax
   125a8:	83 ec 08             	sub    $0x8,%esp
   125ab:	ff 75 20             	pushl  0x20(%ebp)
   125ae:	52                   	push   %edx
   125af:	ff 75 18             	pushl  0x18(%ebp)
   125b2:	ff 75 14             	pushl  0x14(%ebp)
   125b5:	ff 75 10             	pushl  0x10(%ebp)
   125b8:	50                   	push   %eax
   125b9:	e8 a2 f3 ff ff       	call   11960 <filter>
   125be:	83 c4 20             	add    $0x20,%esp
   125c1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   125c4:	e9 08 02 00 00       	jmp    127d1 <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   125c9:	ff 75 dc             	pushl  -0x24(%ebp)
   125cc:	ff 75 18             	pushl  0x18(%ebp)
   125cf:	ff 75 14             	pushl  0x14(%ebp)
   125d2:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   125d8:	50                   	push   %eax
   125d9:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   125df:	50                   	push   %eax
   125e0:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   125e6:	50                   	push   %eax
   125e7:	8d 45 98             	lea    -0x68(%ebp),%eax
   125ea:	50                   	push   %eax
   125eb:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   125ee:	50                   	push   %eax
   125ef:	e8 19 ab ff ff       	call   d10d <Adam7_getpassvalues>
   125f4:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   125f7:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   125fd:	8b 45 0c             	mov    0xc(%ebp),%eax
   12600:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12602:	8b 45 0c             	mov    0xc(%ebp),%eax
   12605:	8b 00                	mov    (%eax),%eax
   12607:	83 ec 0c             	sub    $0xc,%esp
   1260a:	50                   	push   %eax
   1260b:	e8 b0 0d ff ff       	call   33c0 <lodepng_malloc>
   12610:	83 c4 10             	add    $0x10,%esp
   12613:	89 c2                	mov    %eax,%edx
   12615:	8b 45 08             	mov    0x8(%ebp),%eax
   12618:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   1261a:	8b 45 08             	mov    0x8(%ebp),%eax
   1261d:	8b 00                	mov    (%eax),%eax
   1261f:	85 c0                	test   %eax,%eax
   12621:	75 07                	jne    1262a <preProcessScanlines+0x1dd>
   12623:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   1262a:	8b 45 94             	mov    -0x6c(%ebp),%eax
   1262d:	83 ec 0c             	sub    $0xc,%esp
   12630:	50                   	push   %eax
   12631:	e8 8a 0d ff ff       	call   33c0 <lodepng_malloc>
   12636:	83 c4 10             	add    $0x10,%esp
   12639:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   1263c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12640:	75 0e                	jne    12650 <preProcessScanlines+0x203>
   12642:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12645:	85 c0                	test   %eax,%eax
   12647:	74 07                	je     12650 <preProcessScanlines+0x203>
   12649:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   12650:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12654:	0f 85 69 01 00 00    	jne    127c3 <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   1265a:	83 ec 0c             	sub    $0xc,%esp
   1265d:	ff 75 dc             	pushl  -0x24(%ebp)
   12660:	ff 75 18             	pushl  0x18(%ebp)
   12663:	ff 75 14             	pushl  0x14(%ebp)
   12666:	ff 75 10             	pushl  0x10(%ebp)
   12669:	ff 75 d4             	pushl  -0x2c(%ebp)
   1266c:	e8 6c fb ff ff       	call   121dd <Adam7_interlace>
   12671:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   12674:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   1267b:	e9 36 01 00 00       	jmp    127b6 <preProcessScanlines+0x369>
        if(bpp < 8) {
   12680:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   12684:	0f 87 d6 00 00 00    	ja     12760 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   1268a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1268d:	83 c0 01             	add    $0x1,%eax
   12690:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   12697:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1269a:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   126a1:	29 c2                	sub    %eax,%edx
   126a3:	89 d0                	mov    %edx,%eax
   126a5:	83 ec 0c             	sub    $0xc,%esp
   126a8:	50                   	push   %eax
   126a9:	e8 12 0d ff ff       	call   33c0 <lodepng_malloc>
   126ae:	83 c4 10             	add    $0x10,%esp
   126b1:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   126b4:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   126b8:	75 0c                	jne    126c6 <preProcessScanlines+0x279>
   126ba:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   126c1:	e9 fd 00 00 00       	jmp    127c3 <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   126c6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126c9:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   126cd:	8b 55 e0             	mov    -0x20(%ebp),%edx
   126d0:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   126d4:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   126d8:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   126da:	8b 55 e0             	mov    -0x20(%ebp),%edx
   126dd:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   126e1:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   126e5:	83 c2 07             	add    $0x7,%edx
   126e8:	c1 ea 03             	shr    $0x3,%edx
   126eb:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   126ee:	89 d1                	mov    %edx,%ecx
   126f0:	8b 55 e0             	mov    -0x20(%ebp),%edx
   126f3:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   126fa:	89 d6                	mov    %edx,%esi
   126fc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   126ff:	01 f2                	add    %esi,%edx
   12701:	83 ec 0c             	sub    $0xc,%esp
   12704:	50                   	push   %eax
   12705:	53                   	push   %ebx
   12706:	51                   	push   %ecx
   12707:	52                   	push   %edx
   12708:	ff 75 d0             	pushl  -0x30(%ebp)
   1270b:	e8 37 fa ff ff       	call   12147 <addPaddingBits>
   12710:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   12713:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12716:	8d 58 0c             	lea    0xc(%eax),%ebx
   12719:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1271c:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12720:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12723:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   12727:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1272a:	8b 31                	mov    (%ecx),%esi
   1272c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1272f:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12736:	01 f1                	add    %esi,%ecx
   12738:	83 ec 08             	sub    $0x8,%esp
   1273b:	ff 75 20             	pushl  0x20(%ebp)
   1273e:	53                   	push   %ebx
   1273f:	52                   	push   %edx
   12740:	50                   	push   %eax
   12741:	ff 75 d0             	pushl  -0x30(%ebp)
   12744:	51                   	push   %ecx
   12745:	e8 16 f2 ff ff       	call   11960 <filter>
   1274a:	83 c4 20             	add    $0x20,%esp
   1274d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   12750:	83 ec 0c             	sub    $0xc,%esp
   12753:	ff 75 d0             	pushl  -0x30(%ebp)
   12756:	e8 86 0c ff ff       	call   33e1 <lodepng_free>
   1275b:	83 c4 10             	add    $0x10,%esp
   1275e:	eb 4c                	jmp    127ac <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   12760:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12763:	8d 70 0c             	lea    0xc(%eax),%esi
   12766:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12769:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   1276d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12770:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   12774:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12777:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   1277e:	89 cb                	mov    %ecx,%ebx
   12780:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   12783:	01 cb                	add    %ecx,%ebx
   12785:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12788:	8b 39                	mov    (%ecx),%edi
   1278a:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1278d:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12794:	01 f9                	add    %edi,%ecx
   12796:	83 ec 08             	sub    $0x8,%esp
   12799:	ff 75 20             	pushl  0x20(%ebp)
   1279c:	56                   	push   %esi
   1279d:	52                   	push   %edx
   1279e:	50                   	push   %eax
   1279f:	53                   	push   %ebx
   127a0:	51                   	push   %ecx
   127a1:	e8 ba f1 ff ff       	call   11960 <filter>
   127a6:	83 c4 20             	add    $0x20,%esp
   127a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   127ac:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   127b0:	75 10                	jne    127c2 <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   127b2:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   127b6:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   127ba:	0f 85 c0 fe ff ff    	jne    12680 <preProcessScanlines+0x233>
   127c0:	eb 01                	jmp    127c3 <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   127c2:	90                   	nop
      }
    }

    lodepng_free(adam7);
   127c3:	83 ec 0c             	sub    $0xc,%esp
   127c6:	ff 75 d4             	pushl  -0x2c(%ebp)
   127c9:	e8 13 0c ff ff       	call   33e1 <lodepng_free>
   127ce:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   127d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   127d4:	8d 65 f4             	lea    -0xc(%ebp),%esp
   127d7:	5b                   	pop    %ebx
   127d8:	5e                   	pop    %esi
   127d9:	5f                   	pop    %edi
   127da:	5d                   	pop    %ebp
   127db:	c3                   	ret    

000127dc <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   127dc:	55                   	push   %ebp
   127dd:	89 e5                	mov    %esp,%ebp
   127df:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   127e2:	8b 45 0c             	mov    0xc(%ebp),%eax
   127e5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   127e8:	eb 47                	jmp    12831 <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   127ea:	8b 45 08             	mov    0x8(%ebp),%eax
   127ed:	8d 50 04             	lea    0x4(%eax),%edx
   127f0:	8b 45 08             	mov    0x8(%ebp),%eax
   127f3:	ff 75 fc             	pushl  -0x4(%ebp)
   127f6:	52                   	push   %edx
   127f7:	50                   	push   %eax
   127f8:	e8 73 5f ff ff       	call   8770 <lodepng_chunk_append>
   127fd:	83 c4 0c             	add    $0xc,%esp
   12800:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12803:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   12807:	74 05                	je     1280e <addUnknownChunks+0x32>
   12809:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1280c:	eb 37                	jmp    12845 <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   1280e:	8b 45 08             	mov    0x8(%ebp),%eax
   12811:	8b 50 04             	mov    0x4(%eax),%edx
   12814:	8b 45 08             	mov    0x8(%ebp),%eax
   12817:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   1281a:	8b 55 10             	mov    0x10(%ebp),%edx
   1281d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12820:	01 d0                	add    %edx,%eax
   12822:	50                   	push   %eax
   12823:	ff 75 fc             	pushl  -0x4(%ebp)
   12826:	e8 ff 5c ff ff       	call   852a <lodepng_chunk_next>
   1282b:	83 c4 08             	add    $0x8,%esp
   1282e:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   12831:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12834:	8b 45 0c             	mov    0xc(%ebp),%eax
   12837:	29 c2                	sub    %eax,%edx
   12839:	89 d0                	mov    %edx,%eax
   1283b:	3b 45 10             	cmp    0x10(%ebp),%eax
   1283e:	7c aa                	jl     127ea <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   12840:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12845:	c9                   	leave  
   12846:	c3                   	ret    

00012847 <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   12847:	55                   	push   %ebp
   12848:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   1284a:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   1284e:	77 07                	ja     12857 <isGrayICCProfile+0x10>
   12850:	b8 00 00 00 00       	mov    $0x0,%eax
   12855:	eb 40                	jmp    12897 <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   12857:	8b 45 08             	mov    0x8(%ebp),%eax
   1285a:	83 c0 10             	add    $0x10,%eax
   1285d:	0f b6 00             	movzbl (%eax),%eax
   12860:	3c 47                	cmp    $0x47,%al
   12862:	75 2e                	jne    12892 <isGrayICCProfile+0x4b>
   12864:	8b 45 08             	mov    0x8(%ebp),%eax
   12867:	83 c0 11             	add    $0x11,%eax
   1286a:	0f b6 00             	movzbl (%eax),%eax
   1286d:	3c 52                	cmp    $0x52,%al
   1286f:	75 21                	jne    12892 <isGrayICCProfile+0x4b>
   12871:	8b 45 08             	mov    0x8(%ebp),%eax
   12874:	83 c0 12             	add    $0x12,%eax
   12877:	0f b6 00             	movzbl (%eax),%eax
   1287a:	3c 41                	cmp    $0x41,%al
   1287c:	75 14                	jne    12892 <isGrayICCProfile+0x4b>
   1287e:	8b 45 08             	mov    0x8(%ebp),%eax
   12881:	83 c0 13             	add    $0x13,%eax
   12884:	0f b6 00             	movzbl (%eax),%eax
   12887:	3c 59                	cmp    $0x59,%al
   12889:	75 07                	jne    12892 <isGrayICCProfile+0x4b>
   1288b:	b8 01 00 00 00       	mov    $0x1,%eax
   12890:	eb 05                	jmp    12897 <isGrayICCProfile+0x50>
   12892:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12897:	5d                   	pop    %ebp
   12898:	c3                   	ret    

00012899 <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   12899:	55                   	push   %ebp
   1289a:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   1289c:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   128a0:	77 07                	ja     128a9 <isRGBICCProfile+0x10>
   128a2:	b8 00 00 00 00       	mov    $0x0,%eax
   128a7:	eb 40                	jmp    128e9 <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   128a9:	8b 45 08             	mov    0x8(%ebp),%eax
   128ac:	83 c0 10             	add    $0x10,%eax
   128af:	0f b6 00             	movzbl (%eax),%eax
   128b2:	3c 52                	cmp    $0x52,%al
   128b4:	75 2e                	jne    128e4 <isRGBICCProfile+0x4b>
   128b6:	8b 45 08             	mov    0x8(%ebp),%eax
   128b9:	83 c0 11             	add    $0x11,%eax
   128bc:	0f b6 00             	movzbl (%eax),%eax
   128bf:	3c 47                	cmp    $0x47,%al
   128c1:	75 21                	jne    128e4 <isRGBICCProfile+0x4b>
   128c3:	8b 45 08             	mov    0x8(%ebp),%eax
   128c6:	83 c0 12             	add    $0x12,%eax
   128c9:	0f b6 00             	movzbl (%eax),%eax
   128cc:	3c 42                	cmp    $0x42,%al
   128ce:	75 14                	jne    128e4 <isRGBICCProfile+0x4b>
   128d0:	8b 45 08             	mov    0x8(%ebp),%eax
   128d3:	83 c0 13             	add    $0x13,%eax
   128d6:	0f b6 00             	movzbl (%eax),%eax
   128d9:	3c 20                	cmp    $0x20,%al
   128db:	75 07                	jne    128e4 <isRGBICCProfile+0x4b>
   128dd:	b8 01 00 00 00       	mov    $0x1,%eax
   128e2:	eb 05                	jmp    128e9 <isRGBICCProfile+0x50>
   128e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
   128e9:	5d                   	pop    %ebp
   128ea:	c3                   	ret    

000128eb <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   128eb:	55                   	push   %ebp
   128ec:	89 e5                	mov    %esp,%ebp
   128ee:	57                   	push   %edi
   128ef:	56                   	push   %esi
   128f0:	53                   	push   %ebx
   128f1:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   128f7:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   128fe:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   12905:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12908:	6a 00                	push   $0x0
   1290a:	6a 00                	push   $0x0
   1290c:	50                   	push   %eax
   1290d:	e8 6f 0d ff ff       	call   3681 <ucvector_init>
   12912:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   12915:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12918:	05 98 00 00 00       	add    $0x98,%eax
   1291d:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   12920:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12926:	50                   	push   %eax
   12927:	e8 3a 71 ff ff       	call   9a66 <lodepng_info_init>
   1292c:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   1292f:	8b 45 08             	mov    0x8(%ebp),%eax
   12932:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   12938:	8b 45 0c             	mov    0xc(%ebp),%eax
   1293b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   12941:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12944:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   1294b:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   1294e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12951:	8b 40 0c             	mov    0xc(%eax),%eax
   12954:	83 f8 03             	cmp    $0x3,%eax
   12957:	74 0a                	je     12963 <lodepng_encode+0x78>
   12959:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1295c:	8b 40 6c             	mov    0x6c(%eax),%eax
   1295f:	85 c0                	test   %eax,%eax
   12961:	74 29                	je     1298c <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   12963:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12966:	8b 40 18             	mov    0x18(%eax),%eax
   12969:	85 c0                	test   %eax,%eax
   1296b:	74 0d                	je     1297a <lodepng_encode+0x8f>
   1296d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12970:	8b 40 18             	mov    0x18(%eax),%eax
   12973:	3d 00 01 00 00       	cmp    $0x100,%eax
   12978:	7e 12                	jle    1298c <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   1297a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1297d:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   12984:	00 00 00 
    goto cleanup;
   12987:	e9 78 0c 00 00       	jmp    13604 <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   1298c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1298f:	8b 40 38             	mov    0x38(%eax),%eax
   12992:	83 f8 02             	cmp    $0x2,%eax
   12995:	76 12                	jbe    129a9 <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   12997:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1299a:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   129a1:	00 00 00 
    goto cleanup;
   129a4:	e9 5b 0c 00 00       	jmp    13604 <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   129a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129ac:	8b 40 08             	mov    0x8(%eax),%eax
   129af:	83 f8 01             	cmp    $0x1,%eax
   129b2:	76 12                	jbe    129c6 <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   129b4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129b7:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   129be:	00 00 00 
    goto cleanup;
   129c1:	e9 3e 0c 00 00       	jmp    13604 <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   129c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129c9:	8b 50 10             	mov    0x10(%eax),%edx
   129cc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129cf:	8b 40 0c             	mov    0xc(%eax),%eax
   129d2:	52                   	push   %edx
   129d3:	50                   	push   %eax
   129d4:	e8 a4 5f ff ff       	call   897d <checkColorValidity>
   129d9:	83 c4 08             	add    $0x8,%esp
   129dc:	89 c2                	mov    %eax,%edx
   129de:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129e1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   129e7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129ea:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   129f0:	85 c0                	test   %eax,%eax
   129f2:	0f 85 c6 0b 00 00    	jne    135be <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   129f8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129fb:	8b 50 7c             	mov    0x7c(%eax),%edx
   129fe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a01:	8b 40 78             	mov    0x78(%eax),%eax
   12a04:	52                   	push   %edx
   12a05:	50                   	push   %eax
   12a06:	e8 72 5f ff ff       	call   897d <checkColorValidity>
   12a0b:	83 c4 08             	add    $0x8,%esp
   12a0e:	89 c2                	mov    %eax,%edx
   12a10:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a13:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12a19:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a1c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12a22:	85 c0                	test   %eax,%eax
   12a24:	0f 85 97 0b 00 00    	jne    135c1 <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   12a2a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a2d:	05 98 00 00 00       	add    $0x98,%eax
   12a32:	83 ec 08             	sub    $0x8,%esp
   12a35:	50                   	push   %eax
   12a36:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12a3c:	50                   	push   %eax
   12a3d:	e8 58 71 ff ff       	call   9b9a <lodepng_info_copy>
   12a42:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   12a45:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a48:	8b 40 5c             	mov    0x5c(%eax),%eax
   12a4b:	85 c0                	test   %eax,%eax
   12a4d:	0f 84 3c 02 00 00    	je     12c8f <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   12a53:	83 ec 0c             	sub    $0xc,%esp
   12a56:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12a5c:	50                   	push   %eax
   12a5d:	e8 5f 96 ff ff       	call   c0c1 <lodepng_color_stats_init>
   12a62:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12a65:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a68:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12a6e:	85 c0                	test   %eax,%eax
   12a70:	74 2d                	je     12a9f <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12a72:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a75:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12a7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a7e:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12a84:	83 ec 08             	sub    $0x8,%esp
   12a87:	52                   	push   %edx
   12a88:	50                   	push   %eax
   12a89:	e8 b9 fd ff ff       	call   12847 <isGrayICCProfile>
   12a8e:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12a91:	85 c0                	test   %eax,%eax
   12a93:	74 0a                	je     12a9f <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   12a95:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   12a9c:	00 00 00 
    }
    if(info_png->iccp_defined &&
   12a9f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12aa2:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12aa8:	85 c0                	test   %eax,%eax
   12aaa:	74 2d                	je     12ad9 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12aac:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12aaf:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12ab5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ab8:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12abe:	83 ec 08             	sub    $0x8,%esp
   12ac1:	52                   	push   %edx
   12ac2:	50                   	push   %eax
   12ac3:	e8 d1 fd ff ff       	call   12899 <isRGBICCProfile>
   12ac8:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   12acb:	85 c0                	test   %eax,%eax
   12acd:	74 0a                	je     12ad9 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   12acf:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   12ad6:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   12ad9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12adc:	83 c0 78             	add    $0x78,%eax
   12adf:	83 ec 0c             	sub    $0xc,%esp
   12ae2:	50                   	push   %eax
   12ae3:	ff 75 18             	pushl  0x18(%ebp)
   12ae6:	ff 75 14             	pushl  0x14(%ebp)
   12ae9:	ff 75 10             	pushl  0x10(%ebp)
   12aec:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12af2:	50                   	push   %eax
   12af3:	e8 e0 96 ff ff       	call   c1d8 <lodepng_compute_color_stats>
   12af8:	83 c4 20             	add    $0x20,%esp
   12afb:	89 c2                	mov    %eax,%edx
   12afd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b00:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12b06:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b09:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12b0f:	85 c0                	test   %eax,%eax
   12b11:	0f 85 ad 0a 00 00    	jne    135c4 <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   12b17:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b1a:	8b 40 2c             	mov    0x2c(%eax),%eax
   12b1d:	85 c0                	test   %eax,%eax
   12b1f:	0f 84 be 00 00 00    	je     12be3 <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   12b25:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   12b2c:	00 00 00 
   12b2f:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   12b36:	00 00 00 
   12b39:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   12b40:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   12b43:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   12b49:	83 ec 04             	sub    $0x4,%esp
   12b4c:	6a 10                	push   $0x10
   12b4e:	6a 02                	push   $0x2
   12b50:	50                   	push   %eax
   12b51:	e8 15 61 ff ff       	call   8c6b <lodepng_color_mode_make>
   12b56:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   12b59:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b5c:	8d 58 0c             	lea    0xc(%eax),%ebx
   12b5f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b62:	8b 48 38             	mov    0x38(%eax),%ecx
   12b65:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b68:	8b 50 34             	mov    0x34(%eax),%edx
   12b6b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b6e:	8b 40 30             	mov    0x30(%eax),%eax
   12b71:	53                   	push   %ebx
   12b72:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   12b78:	53                   	push   %ebx
   12b79:	51                   	push   %ecx
   12b7a:	52                   	push   %edx
   12b7b:	50                   	push   %eax
   12b7c:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   12b82:	50                   	push   %eax
   12b83:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   12b89:	50                   	push   %eax
   12b8a:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   12b90:	50                   	push   %eax
   12b91:	e8 8a 92 ff ff       	call   be20 <lodepng_convert_rgb>
   12b96:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   12b99:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   12b9f:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   12ba5:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   12bab:	83 ec 0c             	sub    $0xc,%esp
   12bae:	68 ff ff 00 00       	push   $0xffff
   12bb3:	51                   	push   %ecx
   12bb4:	52                   	push   %edx
   12bb5:	50                   	push   %eax
   12bb6:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12bbc:	50                   	push   %eax
   12bbd:	e8 26 a1 ff ff       	call   cce8 <lodepng_color_stats_add>
   12bc2:	83 c4 20             	add    $0x20,%esp
   12bc5:	89 c2                	mov    %eax,%edx
   12bc7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bca:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12bd0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bd3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12bd9:	85 c0                	test   %eax,%eax
   12bdb:	74 06                	je     12be3 <lodepng_encode+0x2f8>
   12bdd:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   12bde:	e9 e1 09 00 00       	jmp    135c4 <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   12be3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12be6:	8d 50 78             	lea    0x78(%eax),%edx
   12be9:	83 ec 04             	sub    $0x4,%esp
   12bec:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12bf2:	50                   	push   %eax
   12bf3:	52                   	push   %edx
   12bf4:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12bfa:	83 c0 0c             	add    $0xc,%eax
   12bfd:	50                   	push   %eax
   12bfe:	e8 79 a1 ff ff       	call   cd7c <auto_choose_color>
   12c03:	83 c4 10             	add    $0x10,%esp
   12c06:	89 c2                	mov    %eax,%edx
   12c08:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c0b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12c11:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c14:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12c1a:	85 c0                	test   %eax,%eax
   12c1c:	0f 85 a5 09 00 00    	jne    135c7 <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   12c22:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c25:	8b 40 2c             	mov    0x2c(%eax),%eax
   12c28:	85 c0                	test   %eax,%eax
   12c2a:	74 63                	je     12c8f <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   12c2c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c2f:	8d 58 0c             	lea    0xc(%eax),%ebx
   12c32:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c35:	8b 48 38             	mov    0x38(%eax),%ecx
   12c38:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c3b:	8b 50 34             	mov    0x34(%eax),%edx
   12c3e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c41:	8b 40 30             	mov    0x30(%eax),%eax
   12c44:	53                   	push   %ebx
   12c45:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   12c4b:	83 c3 0c             	add    $0xc,%ebx
   12c4e:	53                   	push   %ebx
   12c4f:	51                   	push   %ecx
   12c50:	52                   	push   %edx
   12c51:	50                   	push   %eax
   12c52:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12c58:	83 c0 38             	add    $0x38,%eax
   12c5b:	50                   	push   %eax
   12c5c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12c62:	83 c0 34             	add    $0x34,%eax
   12c65:	50                   	push   %eax
   12c66:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12c6c:	83 c0 30             	add    $0x30,%eax
   12c6f:	50                   	push   %eax
   12c70:	e8 ab 91 ff ff       	call   be20 <lodepng_convert_rgb>
   12c75:	83 c4 20             	add    $0x20,%esp
   12c78:	85 c0                	test   %eax,%eax
   12c7a:	74 13                	je     12c8f <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   12c7c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c7f:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   12c86:	00 00 00 
        goto cleanup;
   12c89:	90                   	nop
   12c8a:	e9 75 09 00 00       	jmp    13604 <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   12c8f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c92:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12c98:	85 c0                	test   %eax,%eax
   12c9a:	0f 84 b2 00 00 00    	je     12d52 <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12ca0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ca3:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12ca9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cac:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12cb2:	83 ec 08             	sub    $0x8,%esp
   12cb5:	52                   	push   %edx
   12cb6:	50                   	push   %eax
   12cb7:	e8 8b fb ff ff       	call   12847 <isGrayICCProfile>
   12cbc:	83 c4 10             	add    $0x10,%esp
   12cbf:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12cc2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cc5:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12ccb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cce:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12cd4:	83 ec 08             	sub    $0x8,%esp
   12cd7:	52                   	push   %edx
   12cd8:	50                   	push   %eax
   12cd9:	e8 bb fb ff ff       	call   12899 <isRGBICCProfile>
   12cde:	83 c4 10             	add    $0x10,%esp
   12ce1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   12ce4:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12cea:	85 c0                	test   %eax,%eax
   12cec:	74 0b                	je     12cf9 <lodepng_encode+0x40e>
   12cee:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12cf4:	83 f8 04             	cmp    $0x4,%eax
   12cf7:	75 07                	jne    12d00 <lodepng_encode+0x415>
   12cf9:	b8 01 00 00 00       	mov    $0x1,%eax
   12cfe:	eb 05                	jmp    12d05 <lodepng_encode+0x41a>
   12d00:	b8 00 00 00 00       	mov    $0x0,%eax
   12d05:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   12d08:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12d0c:	75 18                	jne    12d26 <lodepng_encode+0x43b>
   12d0e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12d12:	75 12                	jne    12d26 <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   12d14:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d17:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   12d1e:	00 00 00 
      goto cleanup;
   12d21:	e9 de 08 00 00       	jmp    13604 <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   12d26:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12d29:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   12d2c:	74 24                	je     12d52 <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   12d2e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d31:	8b 40 5c             	mov    0x5c(%eax),%eax
   12d34:	85 c0                	test   %eax,%eax
   12d36:	74 07                	je     12d3f <lodepng_encode+0x454>
   12d38:	ba 66 00 00 00       	mov    $0x66,%edx
   12d3d:	eb 05                	jmp    12d44 <lodepng_encode+0x459>
   12d3f:	ba 65 00 00 00       	mov    $0x65,%edx
   12d44:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d47:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   12d4d:	e9 b2 08 00 00       	jmp    13604 <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   12d52:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d55:	83 c0 78             	add    $0x78,%eax
   12d58:	83 ec 08             	sub    $0x8,%esp
   12d5b:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   12d61:	83 c2 0c             	add    $0xc,%edx
   12d64:	52                   	push   %edx
   12d65:	50                   	push   %eax
   12d66:	e8 57 5f ff ff       	call   8cc2 <lodepng_color_mode_equal>
   12d6b:	83 c4 10             	add    $0x10,%esp
   12d6e:	85 c0                	test   %eax,%eax
   12d70:	0f 85 f8 00 00 00    	jne    12e6e <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   12d76:	8b 55 14             	mov    0x14(%ebp),%edx
   12d79:	8b 45 18             	mov    0x18(%ebp),%eax
   12d7c:	89 d3                	mov    %edx,%ebx
   12d7e:	0f af d8             	imul   %eax,%ebx
   12d81:	83 ec 0c             	sub    $0xc,%esp
   12d84:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d8a:	83 c0 0c             	add    $0xc,%eax
   12d8d:	50                   	push   %eax
   12d8e:	e8 49 61 ff ff       	call   8edc <lodepng_get_bpp>
   12d93:	83 c4 10             	add    $0x10,%esp
   12d96:	0f af c3             	imul   %ebx,%eax
   12d99:	83 c0 07             	add    $0x7,%eax
   12d9c:	c1 e8 03             	shr    $0x3,%eax
   12d9f:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   12da2:	83 ec 0c             	sub    $0xc,%esp
   12da5:	ff 75 cc             	pushl  -0x34(%ebp)
   12da8:	e8 13 06 ff ff       	call   33c0 <lodepng_malloc>
   12dad:	83 c4 10             	add    $0x10,%esp
   12db0:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   12db3:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12db7:	75 13                	jne    12dcc <lodepng_encode+0x4e1>
   12db9:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   12dbd:	74 0d                	je     12dcc <lodepng_encode+0x4e1>
   12dbf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dc2:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   12dc9:	00 00 00 
    if(!state->error) {
   12dcc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dcf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12dd5:	85 c0                	test   %eax,%eax
   12dd7:	75 33                	jne    12e0c <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   12dd9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ddc:	83 c0 78             	add    $0x78,%eax
   12ddf:	83 ec 08             	sub    $0x8,%esp
   12de2:	ff 75 18             	pushl  0x18(%ebp)
   12de5:	ff 75 14             	pushl  0x14(%ebp)
   12de8:	50                   	push   %eax
   12de9:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12def:	83 c0 0c             	add    $0xc,%eax
   12df2:	50                   	push   %eax
   12df3:	ff 75 10             	pushl  0x10(%ebp)
   12df6:	ff 75 c8             	pushl  -0x38(%ebp)
   12df9:	e8 c9 8c ff ff       	call   bac7 <lodepng_convert>
   12dfe:	83 c4 20             	add    $0x20,%esp
   12e01:	89 c2                	mov    %eax,%edx
   12e03:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e06:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   12e0c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e0f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e15:	85 c0                	test   %eax,%eax
   12e17:	75 35                	jne    12e4e <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   12e19:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e1c:	83 c0 38             	add    $0x38,%eax
   12e1f:	83 ec 04             	sub    $0x4,%esp
   12e22:	50                   	push   %eax
   12e23:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e29:	50                   	push   %eax
   12e2a:	ff 75 18             	pushl  0x18(%ebp)
   12e2d:	ff 75 14             	pushl  0x14(%ebp)
   12e30:	ff 75 c8             	pushl  -0x38(%ebp)
   12e33:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12e36:	50                   	push   %eax
   12e37:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12e3a:	50                   	push   %eax
   12e3b:	e8 0d f6 ff ff       	call   1244d <preProcessScanlines>
   12e40:	83 c4 20             	add    $0x20,%esp
   12e43:	89 c2                	mov    %eax,%edx
   12e45:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e48:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   12e4e:	83 ec 0c             	sub    $0xc,%esp
   12e51:	ff 75 c8             	pushl  -0x38(%ebp)
   12e54:	e8 88 05 ff ff       	call   33e1 <lodepng_free>
   12e59:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   12e5c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e5f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e65:	85 c0                	test   %eax,%eax
   12e67:	74 4b                	je     12eb4 <lodepng_encode+0x5c9>
   12e69:	e9 96 07 00 00       	jmp    13604 <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   12e6e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e71:	83 c0 38             	add    $0x38,%eax
   12e74:	83 ec 04             	sub    $0x4,%esp
   12e77:	50                   	push   %eax
   12e78:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e7e:	50                   	push   %eax
   12e7f:	ff 75 18             	pushl  0x18(%ebp)
   12e82:	ff 75 14             	pushl  0x14(%ebp)
   12e85:	ff 75 10             	pushl  0x10(%ebp)
   12e88:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12e8b:	50                   	push   %eax
   12e8c:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12e8f:	50                   	push   %eax
   12e90:	e8 b8 f5 ff ff       	call   1244d <preProcessScanlines>
   12e95:	83 c4 20             	add    $0x20,%esp
   12e98:	89 c2                	mov    %eax,%edx
   12e9a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e9d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12ea3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ea6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12eac:	85 c0                	test   %eax,%eax
   12eae:	0f 85 16 07 00 00    	jne    135ca <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   12eb4:	83 ec 0c             	sub    $0xc,%esp
   12eb7:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12eba:	50                   	push   %eax
   12ebb:	e8 21 d9 ff ff       	call   107e1 <writeSignature>
   12ec0:	83 c4 10             	add    $0x10,%esp
   12ec3:	89 c2                	mov    %eax,%edx
   12ec5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ec8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12ece:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ed1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ed7:	85 c0                	test   %eax,%eax
   12ed9:	0f 85 ee 06 00 00    	jne    135cd <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   12edf:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   12ee5:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   12eeb:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12ef1:	83 ec 08             	sub    $0x8,%esp
   12ef4:	51                   	push   %ecx
   12ef5:	52                   	push   %edx
   12ef6:	50                   	push   %eax
   12ef7:	ff 75 18             	pushl  0x18(%ebp)
   12efa:	ff 75 14             	pushl  0x14(%ebp)
   12efd:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f00:	50                   	push   %eax
   12f01:	e8 4a d9 ff ff       	call   10850 <addChunk_IHDR>
   12f06:	83 c4 20             	add    $0x20,%esp
   12f09:	89 c2                	mov    %eax,%edx
   12f0b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f0e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12f14:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f17:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f1d:	85 c0                	test   %eax,%eax
   12f1f:	0f 85 ab 06 00 00    	jne    135d0 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   12f25:	8b 45 98             	mov    -0x68(%ebp),%eax
   12f28:	85 c0                	test   %eax,%eax
   12f2a:	74 33                	je     12f5f <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   12f2c:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   12f2f:	8b 45 98             	mov    -0x68(%ebp),%eax
   12f32:	83 ec 04             	sub    $0x4,%esp
   12f35:	52                   	push   %edx
   12f36:	50                   	push   %eax
   12f37:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f3a:	50                   	push   %eax
   12f3b:	e8 9c f8 ff ff       	call   127dc <addUnknownChunks>
   12f40:	83 c4 10             	add    $0x10,%esp
   12f43:	89 c2                	mov    %eax,%edx
   12f45:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f48:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f4e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f51:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f57:	85 c0                	test   %eax,%eax
   12f59:	0f 85 74 06 00 00    	jne    135d3 <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   12f5f:	8b 45 88             	mov    -0x78(%ebp),%eax
   12f62:	85 c0                	test   %eax,%eax
   12f64:	74 39                	je     12f9f <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   12f66:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f69:	83 c0 38             	add    $0x38,%eax
   12f6c:	83 ec 04             	sub    $0x4,%esp
   12f6f:	50                   	push   %eax
   12f70:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f76:	50                   	push   %eax
   12f77:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f7a:	50                   	push   %eax
   12f7b:	e8 a4 e4 ff ff       	call   11424 <addChunk_iCCP>
   12f80:	83 c4 10             	add    $0x10,%esp
   12f83:	89 c2                	mov    %eax,%edx
   12f85:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f88:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f8e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f91:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f97:	85 c0                	test   %eax,%eax
   12f99:	0f 85 37 06 00 00    	jne    135d6 <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   12f9f:	8b 45 80             	mov    -0x80(%ebp),%eax
   12fa2:	85 c0                	test   %eax,%eax
   12fa4:	74 32                	je     12fd8 <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   12fa6:	83 ec 08             	sub    $0x8,%esp
   12fa9:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12faf:	50                   	push   %eax
   12fb0:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12fb3:	50                   	push   %eax
   12fb4:	e8 41 e4 ff ff       	call   113fa <addChunk_sRGB>
   12fb9:	83 c4 10             	add    $0x10,%esp
   12fbc:	89 c2                	mov    %eax,%edx
   12fbe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fc1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12fc7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fca:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12fd0:	85 c0                	test   %eax,%eax
   12fd2:	0f 85 01 06 00 00    	jne    135d9 <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   12fd8:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   12fde:	85 c0                	test   %eax,%eax
   12fe0:	74 32                	je     13014 <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   12fe2:	83 ec 08             	sub    $0x8,%esp
   12fe5:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12feb:	50                   	push   %eax
   12fec:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12fef:	50                   	push   %eax
   12ff0:	e8 a7 e2 ff ff       	call   1129c <addChunk_gAMA>
   12ff5:	83 c4 10             	add    $0x10,%esp
   12ff8:	89 c2                	mov    %eax,%edx
   12ffa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ffd:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13003:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13006:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1300c:	85 c0                	test   %eax,%eax
   1300e:	0f 85 c8 05 00 00    	jne    135dc <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   13014:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   1301a:	85 c0                	test   %eax,%eax
   1301c:	74 32                	je     13050 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   1301e:	83 ec 08             	sub    $0x8,%esp
   13021:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13027:	50                   	push   %eax
   13028:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1302b:	50                   	push   %eax
   1302c:	e8 c1 e2 ff ff       	call   112f2 <addChunk_cHRM>
   13031:	83 c4 10             	add    $0x10,%esp
   13034:	89 c2                	mov    %eax,%edx
   13036:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13039:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1303f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13042:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13048:	85 c0                	test   %eax,%eax
   1304a:	0f 85 8f 05 00 00    	jne    135df <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   13050:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13056:	83 f8 03             	cmp    $0x3,%eax
   13059:	75 35                	jne    13090 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   1305b:	83 ec 08             	sub    $0x8,%esp
   1305e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13064:	83 c0 0c             	add    $0xc,%eax
   13067:	50                   	push   %eax
   13068:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1306b:	50                   	push   %eax
   1306c:	e8 78 d8 ff ff       	call   108e9 <addChunk_PLTE>
   13071:	83 c4 10             	add    $0x10,%esp
   13074:	89 c2                	mov    %eax,%edx
   13076:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13079:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1307f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13082:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13088:	85 c0                	test   %eax,%eax
   1308a:	0f 85 52 05 00 00    	jne    135e2 <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   13090:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13093:	8b 40 6c             	mov    0x6c(%eax),%eax
   13096:	85 c0                	test   %eax,%eax
   13098:	74 4b                	je     130e5 <lodepng_encode+0x7fa>
   1309a:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   130a0:	83 f8 02             	cmp    $0x2,%eax
   130a3:	74 0b                	je     130b0 <lodepng_encode+0x7c5>
   130a5:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   130ab:	83 f8 06             	cmp    $0x6,%eax
   130ae:	75 35                	jne    130e5 <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   130b0:	83 ec 08             	sub    $0x8,%esp
   130b3:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130b9:	83 c0 0c             	add    $0xc,%eax
   130bc:	50                   	push   %eax
   130bd:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130c0:	50                   	push   %eax
   130c1:	e8 23 d8 ff ff       	call   108e9 <addChunk_PLTE>
   130c6:	83 c4 10             	add    $0x10,%esp
   130c9:	89 c2                	mov    %eax,%edx
   130cb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130ce:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   130d4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130d7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130dd:	85 c0                	test   %eax,%eax
   130df:	0f 85 00 05 00 00    	jne    135e5 <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   130e5:	83 ec 08             	sub    $0x8,%esp
   130e8:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130ee:	83 c0 0c             	add    $0xc,%eax
   130f1:	50                   	push   %eax
   130f2:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130f5:	50                   	push   %eax
   130f6:	e8 c4 d8 ff ff       	call   109bf <addChunk_tRNS>
   130fb:	83 c4 10             	add    $0x10,%esp
   130fe:	89 c2                	mov    %eax,%edx
   13100:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13103:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13109:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1310c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13112:	85 c0                	test   %eax,%eax
   13114:	0f 85 ce 04 00 00    	jne    135e8 <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   1311a:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   13120:	85 c0                	test   %eax,%eax
   13122:	74 32                	je     13156 <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   13124:	83 ec 08             	sub    $0x8,%esp
   13127:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1312d:	50                   	push   %eax
   1312e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13131:	50                   	push   %eax
   13132:	e8 e4 de ff ff       	call   1101b <addChunk_bKGD>
   13137:	83 c4 10             	add    $0x10,%esp
   1313a:	89 c2                	mov    %eax,%edx
   1313c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1313f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13145:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13148:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1314e:	85 c0                	test   %eax,%eax
   13150:	0f 85 95 04 00 00    	jne    135eb <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   13156:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   1315c:	85 c0                	test   %eax,%eax
   1315e:	74 32                	je     13192 <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   13160:	83 ec 08             	sub    $0x8,%esp
   13163:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13169:	50                   	push   %eax
   1316a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1316d:	50                   	push   %eax
   1316e:	e8 ac e0 ff ff       	call   1121f <addChunk_pHYs>
   13173:	83 c4 10             	add    $0x10,%esp
   13176:	89 c2                	mov    %eax,%edx
   13178:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1317b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13181:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13184:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1318a:	85 c0                	test   %eax,%eax
   1318c:	0f 85 5c 04 00 00    	jne    135ee <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   13192:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13195:	85 c0                	test   %eax,%eax
   13197:	74 33                	je     131cc <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   13199:	8b 55 a8             	mov    -0x58(%ebp),%edx
   1319c:	8b 45 9c             	mov    -0x64(%ebp),%eax
   1319f:	83 ec 04             	sub    $0x4,%esp
   131a2:	52                   	push   %edx
   131a3:	50                   	push   %eax
   131a4:	8d 45 b0             	lea    -0x50(%ebp),%eax
   131a7:	50                   	push   %eax
   131a8:	e8 2f f6 ff ff       	call   127dc <addUnknownChunks>
   131ad:	83 c4 10             	add    $0x10,%esp
   131b0:	89 c2                	mov    %eax,%edx
   131b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131b5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   131bb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131be:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   131c4:	85 c0                	test   %eax,%eax
   131c6:	0f 85 25 04 00 00    	jne    135f1 <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   131cc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131cf:	8d 48 38             	lea    0x38(%eax),%ecx
   131d2:	8b 55 bc             	mov    -0x44(%ebp),%edx
   131d5:	8b 45 c0             	mov    -0x40(%ebp),%eax
   131d8:	51                   	push   %ecx
   131d9:	52                   	push   %edx
   131da:	50                   	push   %eax
   131db:	8d 45 b0             	lea    -0x50(%ebp),%eax
   131de:	50                   	push   %eax
   131df:	e8 bd d9 ff ff       	call   10ba1 <addChunk_IDAT>
   131e4:	83 c4 10             	add    $0x10,%esp
   131e7:	89 c2                	mov    %eax,%edx
   131e9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131ec:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   131f2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131f5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   131fb:	85 c0                	test   %eax,%eax
   131fd:	0f 85 f1 03 00 00    	jne    135f4 <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   13203:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   13209:	85 c0                	test   %eax,%eax
   1320b:	74 35                	je     13242 <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   1320d:	83 ec 08             	sub    $0x8,%esp
   13210:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13216:	83 c0 60             	add    $0x60,%eax
   13219:	50                   	push   %eax
   1321a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1321d:	50                   	push   %eax
   1321e:	e8 5c df ff ff       	call   1117f <addChunk_tIME>
   13223:	83 c4 10             	add    $0x10,%esp
   13226:	89 c2                	mov    %eax,%edx
   13228:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1322b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13231:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13234:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1323a:	85 c0                	test   %eax,%eax
   1323c:	0f 85 b5 03 00 00    	jne    135f7 <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13242:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13249:	e9 12 01 00 00       	jmp    13360 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   1324e:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13254:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13257:	c1 e2 02             	shl    $0x2,%edx
   1325a:	01 d0                	add    %edx,%eax
   1325c:	8b 00                	mov    (%eax),%eax
   1325e:	83 ec 0c             	sub    $0xc,%esp
   13261:	50                   	push   %eax
   13262:	e8 f5 01 ff ff       	call   345c <lodepng_strlen>
   13267:	83 c4 10             	add    $0x10,%esp
   1326a:	83 f8 4f             	cmp    $0x4f,%eax
   1326d:	7e 12                	jle    13281 <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   1326f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13272:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   13279:	00 00 00 
        goto cleanup;
   1327c:	e9 83 03 00 00       	jmp    13604 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   13281:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13287:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1328a:	c1 e2 02             	shl    $0x2,%edx
   1328d:	01 d0                	add    %edx,%eax
   1328f:	8b 00                	mov    (%eax),%eax
   13291:	83 ec 0c             	sub    $0xc,%esp
   13294:	50                   	push   %eax
   13295:	e8 c2 01 ff ff       	call   345c <lodepng_strlen>
   1329a:	83 c4 10             	add    $0x10,%esp
   1329d:	85 c0                	test   %eax,%eax
   1329f:	7f 12                	jg     132b3 <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   132a1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132a4:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   132ab:	00 00 00 
        goto cleanup;
   132ae:	e9 51 03 00 00       	jmp    13604 <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   132b3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132b6:	8b 40 74             	mov    0x74(%eax),%eax
   132b9:	85 c0                	test   %eax,%eax
   132bb:	74 52                	je     1330f <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   132bd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132c0:	8d 48 38             	lea    0x38(%eax),%ecx
   132c3:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   132c9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   132cc:	c1 e2 02             	shl    $0x2,%edx
   132cf:	01 d0                	add    %edx,%eax
   132d1:	8b 10                	mov    (%eax),%edx
   132d3:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   132d9:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   132dc:	c1 e3 02             	shl    $0x2,%ebx
   132df:	01 d8                	add    %ebx,%eax
   132e1:	8b 00                	mov    (%eax),%eax
   132e3:	51                   	push   %ecx
   132e4:	52                   	push   %edx
   132e5:	50                   	push   %eax
   132e6:	8d 45 b0             	lea    -0x50(%ebp),%eax
   132e9:	50                   	push   %eax
   132ea:	e8 fa d9 ff ff       	call   10ce9 <addChunk_zTXt>
   132ef:	83 c4 10             	add    $0x10,%esp
   132f2:	89 c2                	mov    %eax,%edx
   132f4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132f7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   132fd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13300:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13306:	85 c0                	test   %eax,%eax
   13308:	74 52                	je     1335c <lodepng_encode+0xa71>
   1330a:	e9 f5 02 00 00       	jmp    13604 <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   1330f:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   13315:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13318:	c1 e2 02             	shl    $0x2,%edx
   1331b:	01 d0                	add    %edx,%eax
   1331d:	8b 10                	mov    (%eax),%edx
   1331f:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13325:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   13328:	c1 e1 02             	shl    $0x2,%ecx
   1332b:	01 c8                	add    %ecx,%eax
   1332d:	8b 00                	mov    (%eax),%eax
   1332f:	83 ec 04             	sub    $0x4,%esp
   13332:	52                   	push   %edx
   13333:	50                   	push   %eax
   13334:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13337:	50                   	push   %eax
   13338:	e8 ec d8 ff ff       	call   10c29 <addChunk_tEXt>
   1333d:	83 c4 10             	add    $0x10,%esp
   13340:	89 c2                	mov    %eax,%edx
   13342:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13345:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   1334b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1334e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13354:	85 c0                	test   %eax,%eax
   13356:	0f 85 9e 02 00 00    	jne    135fa <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   1335c:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13360:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   13366:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13369:	0f 85 df fe ff ff    	jne    1324e <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   1336f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13372:	8b 40 70             	mov    0x70(%eax),%eax
   13375:	85 c0                	test   %eax,%eax
   13377:	0f 84 e3 00 00 00    	je     13460 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   1337d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   13384:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1338b:	e9 85 00 00 00       	jmp    13415 <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   13390:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13396:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13399:	c1 e2 02             	shl    $0x2,%edx
   1339c:	01 d0                	add    %edx,%eax
   1339e:	8b 00                	mov    (%eax),%eax
   133a0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   133a3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133a6:	0f b6 00             	movzbl (%eax),%eax
   133a9:	3c 4c                	cmp    $0x4c,%al
   133ab:	75 64                	jne    13411 <lodepng_encode+0xb26>
   133ad:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133b0:	83 c0 01             	add    $0x1,%eax
   133b3:	0f b6 00             	movzbl (%eax),%eax
   133b6:	3c 6f                	cmp    $0x6f,%al
   133b8:	75 57                	jne    13411 <lodepng_encode+0xb26>
   133ba:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133bd:	83 c0 02             	add    $0x2,%eax
   133c0:	0f b6 00             	movzbl (%eax),%eax
   133c3:	3c 64                	cmp    $0x64,%al
   133c5:	75 4a                	jne    13411 <lodepng_encode+0xb26>
   133c7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133ca:	83 c0 03             	add    $0x3,%eax
   133cd:	0f b6 00             	movzbl (%eax),%eax
   133d0:	3c 65                	cmp    $0x65,%al
   133d2:	75 3d                	jne    13411 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   133d4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133d7:	83 c0 04             	add    $0x4,%eax
   133da:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   133dd:	3c 50                	cmp    $0x50,%al
   133df:	75 30                	jne    13411 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   133e1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133e4:	83 c0 05             	add    $0x5,%eax
   133e7:	0f b6 00             	movzbl (%eax),%eax
   133ea:	3c 4e                	cmp    $0x4e,%al
   133ec:	75 23                	jne    13411 <lodepng_encode+0xb26>
   133ee:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133f1:	83 c0 06             	add    $0x6,%eax
   133f4:	0f b6 00             	movzbl (%eax),%eax
   133f7:	3c 47                	cmp    $0x47,%al
   133f9:	75 16                	jne    13411 <lodepng_encode+0xb26>
   133fb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   133fe:	83 c0 07             	add    $0x7,%eax
   13401:	0f b6 00             	movzbl (%eax),%eax
   13404:	84 c0                	test   %al,%al
   13406:	75 09                	jne    13411 <lodepng_encode+0xb26>
          already_added_id_text = 1;
   13408:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   1340f:	eb 13                	jmp    13424 <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   13411:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13415:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   1341b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1341e:	0f 85 6c ff ff ff    	jne    13390 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   13424:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   13428:	75 36                	jne    13460 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   1342a:	a1 c0 e1 01 00       	mov    0x1e1c0,%eax
   1342f:	83 ec 04             	sub    $0x4,%esp
   13432:	50                   	push   %eax
   13433:	68 64 a1 01 00       	push   $0x1a164
   13438:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1343b:	50                   	push   %eax
   1343c:	e8 e8 d7 ff ff       	call   10c29 <addChunk_tEXt>
   13441:	83 c4 10             	add    $0x10,%esp
   13444:	89 c2                	mov    %eax,%edx
   13446:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13449:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   1344f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13452:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13458:	85 c0                	test   %eax,%eax
   1345a:	0f 85 9d 01 00 00    	jne    135fd <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13460:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13467:	e9 e6 00 00 00       	jmp    13552 <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   1346c:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13472:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13475:	c1 e2 02             	shl    $0x2,%edx
   13478:	01 d0                	add    %edx,%eax
   1347a:	8b 00                	mov    (%eax),%eax
   1347c:	83 ec 0c             	sub    $0xc,%esp
   1347f:	50                   	push   %eax
   13480:	e8 d7 ff fe ff       	call   345c <lodepng_strlen>
   13485:	83 c4 10             	add    $0x10,%esp
   13488:	83 f8 4f             	cmp    $0x4f,%eax
   1348b:	7e 12                	jle    1349f <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   1348d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13490:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   13497:	00 00 00 
        goto cleanup;
   1349a:	e9 65 01 00 00       	jmp    13604 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   1349f:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   134a5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   134a8:	c1 e2 02             	shl    $0x2,%edx
   134ab:	01 d0                	add    %edx,%eax
   134ad:	8b 00                	mov    (%eax),%eax
   134af:	83 ec 0c             	sub    $0xc,%esp
   134b2:	50                   	push   %eax
   134b3:	e8 a4 ff fe ff       	call   345c <lodepng_strlen>
   134b8:	83 c4 10             	add    $0x10,%esp
   134bb:	85 c0                	test   %eax,%eax
   134bd:	7f 12                	jg     134d1 <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   134bf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134c2:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   134c9:	00 00 00 
        goto cleanup;
   134cc:	e9 33 01 00 00       	jmp    13604 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   134d1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134d4:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   134d7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   134dd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   134e0:	c1 e2 02             	shl    $0x2,%edx
   134e3:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   134e5:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   134e7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   134ed:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   134f0:	c1 e2 02             	shl    $0x2,%edx
   134f3:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   134f5:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   134f7:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   134fd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13500:	c1 e2 02             	shl    $0x2,%edx
   13503:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13505:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13507:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   1350d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13510:	c1 e2 02             	shl    $0x2,%edx
   13513:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13515:	8b 10                	mov    (%eax),%edx
   13517:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1351a:	8b 40 74             	mov    0x74(%eax),%eax
   1351d:	83 ec 04             	sub    $0x4,%esp
   13520:	57                   	push   %edi
   13521:	56                   	push   %esi
   13522:	53                   	push   %ebx
   13523:	51                   	push   %ecx
   13524:	52                   	push   %edx
   13525:	50                   	push   %eax
   13526:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13529:	50                   	push   %eax
   1352a:	e8 dc d8 ff ff       	call   10e0b <addChunk_iTXt>
   1352f:	83 c4 20             	add    $0x20,%esp
   13532:	89 c2                	mov    %eax,%edx
   13534:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13537:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   1353d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13540:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13546:	85 c0                	test   %eax,%eax
   13548:	0f 85 b2 00 00 00    	jne    13600 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   1354e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13552:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   13558:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1355b:	0f 85 0b ff ff ff    	jne    1346c <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   13561:	8b 45 a0             	mov    -0x60(%ebp),%eax
   13564:	85 c0                	test   %eax,%eax
   13566:	74 2f                	je     13597 <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   13568:	8b 55 ac             	mov    -0x54(%ebp),%edx
   1356b:	8b 45 a0             	mov    -0x60(%ebp),%eax
   1356e:	83 ec 04             	sub    $0x4,%esp
   13571:	52                   	push   %edx
   13572:	50                   	push   %eax
   13573:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13576:	50                   	push   %eax
   13577:	e8 60 f2 ff ff       	call   127dc <addUnknownChunks>
   1357c:	83 c4 10             	add    $0x10,%esp
   1357f:	89 c2                	mov    %eax,%edx
   13581:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13584:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1358a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1358d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13593:	85 c0                	test   %eax,%eax
   13595:	75 6c                	jne    13603 <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   13597:	83 ec 0c             	sub    $0xc,%esp
   1359a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1359d:	50                   	push   %eax
   1359e:	e8 6d d6 ff ff       	call   10c10 <addChunk_IEND>
   135a3:	83 c4 10             	add    $0x10,%esp
   135a6:	89 c2                	mov    %eax,%edx
   135a8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135ab:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   135b1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135b4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   135ba:	85 c0                	test   %eax,%eax
   135bc:	eb 46                	jmp    13604 <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   135be:	90                   	nop
   135bf:	eb 43                	jmp    13604 <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   135c1:	90                   	nop
   135c2:	eb 40                	jmp    13604 <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   135c4:	90                   	nop
   135c5:	eb 3d                	jmp    13604 <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   135c7:	90                   	nop
   135c8:	eb 3a                	jmp    13604 <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   135ca:	90                   	nop
   135cb:	eb 37                	jmp    13604 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   135cd:	90                   	nop
   135ce:	eb 34                	jmp    13604 <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   135d0:	90                   	nop
   135d1:	eb 31                	jmp    13604 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   135d3:	90                   	nop
   135d4:	eb 2e                	jmp    13604 <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   135d6:	90                   	nop
   135d7:	eb 2b                	jmp    13604 <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   135d9:	90                   	nop
   135da:	eb 28                	jmp    13604 <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   135dc:	90                   	nop
   135dd:	eb 25                	jmp    13604 <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   135df:	90                   	nop
   135e0:	eb 22                	jmp    13604 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   135e2:	90                   	nop
   135e3:	eb 1f                	jmp    13604 <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   135e5:	90                   	nop
   135e6:	eb 1c                	jmp    13604 <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   135e8:	90                   	nop
   135e9:	eb 19                	jmp    13604 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   135eb:	90                   	nop
   135ec:	eb 16                	jmp    13604 <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   135ee:	90                   	nop
   135ef:	eb 13                	jmp    13604 <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   135f1:	90                   	nop
   135f2:	eb 10                	jmp    13604 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   135f4:	90                   	nop
   135f5:	eb 0d                	jmp    13604 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   135f7:	90                   	nop
   135f8:	eb 0a                	jmp    13604 <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   135fa:	90                   	nop
   135fb:	eb 07                	jmp    13604 <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   135fd:	90                   	nop
   135fe:	eb 04                	jmp    13604 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13600:	90                   	nop
   13601:	eb 01                	jmp    13604 <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   13603:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   13604:	83 ec 0c             	sub    $0xc,%esp
   13607:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1360d:	50                   	push   %eax
   1360e:	e8 34 65 ff ff       	call   9b47 <lodepng_info_cleanup>
   13613:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   13616:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13619:	83 ec 0c             	sub    $0xc,%esp
   1361c:	50                   	push   %eax
   1361d:	e8 bf fd fe ff       	call   33e1 <lodepng_free>
   13622:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   13625:	8b 55 b0             	mov    -0x50(%ebp),%edx
   13628:	8b 45 08             	mov    0x8(%ebp),%eax
   1362b:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   1362d:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   13630:	8b 45 0c             	mov    0xc(%ebp),%eax
   13633:	89 10                	mov    %edx,(%eax)

  return state->error;
   13635:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13638:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   1363e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13641:	5b                   	pop    %ebx
   13642:	5e                   	pop    %esi
   13643:	5f                   	pop    %edi
   13644:	5d                   	pop    %ebp
   13645:	c3                   	ret    

00013646 <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   13646:	55                   	push   %ebp
   13647:	89 e5                	mov    %esp,%ebp
   13649:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   1364f:	83 ec 0c             	sub    $0xc,%esp
   13652:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13658:	50                   	push   %eax
   13659:	e8 38 d0 ff ff       	call   10696 <lodepng_state_init>
   1365e:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   13661:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13664:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   1366a:	8b 45 20             	mov    0x20(%ebp),%eax
   1366d:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   13673:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13676:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   1367c:	8b 45 20             	mov    0x20(%ebp),%eax
   1367f:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   13685:	83 ec 08             	sub    $0x8,%esp
   13688:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1368e:	50                   	push   %eax
   1368f:	ff 75 18             	pushl  0x18(%ebp)
   13692:	ff 75 14             	pushl  0x14(%ebp)
   13695:	ff 75 10             	pushl  0x10(%ebp)
   13698:	ff 75 0c             	pushl  0xc(%ebp)
   1369b:	ff 75 08             	pushl  0x8(%ebp)
   1369e:	e8 48 f2 ff ff       	call   128eb <lodepng_encode>
   136a3:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   136a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   136a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   136ac:	83 ec 0c             	sub    $0xc,%esp
   136af:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   136b5:	50                   	push   %eax
   136b6:	e8 35 d0 ff ff       	call   106f0 <lodepng_state_cleanup>
   136bb:	83 c4 10             	add    $0x10,%esp
  return error;
   136be:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   136c1:	c9                   	leave  
   136c2:	c3                   	ret    

000136c3 <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   136c3:	55                   	push   %ebp
   136c4:	89 e5                	mov    %esp,%ebp
   136c6:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   136c9:	83 ec 04             	sub    $0x4,%esp
   136cc:	6a 08                	push   $0x8
   136ce:	6a 06                	push   $0x6
   136d0:	ff 75 18             	pushl  0x18(%ebp)
   136d3:	ff 75 14             	pushl  0x14(%ebp)
   136d6:	ff 75 10             	pushl  0x10(%ebp)
   136d9:	ff 75 0c             	pushl  0xc(%ebp)
   136dc:	ff 75 08             	pushl  0x8(%ebp)
   136df:	e8 62 ff ff ff       	call   13646 <lodepng_encode_memory>
   136e4:	83 c4 20             	add    $0x20,%esp
}
   136e7:	c9                   	leave  
   136e8:	c3                   	ret    

000136e9 <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   136e9:	55                   	push   %ebp
   136ea:	89 e5                	mov    %esp,%ebp
   136ec:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   136ef:	83 ec 04             	sub    $0x4,%esp
   136f2:	6a 08                	push   $0x8
   136f4:	6a 02                	push   $0x2
   136f6:	ff 75 18             	pushl  0x18(%ebp)
   136f9:	ff 75 14             	pushl  0x14(%ebp)
   136fc:	ff 75 10             	pushl  0x10(%ebp)
   136ff:	ff 75 0c             	pushl  0xc(%ebp)
   13702:	ff 75 08             	pushl  0x8(%ebp)
   13705:	e8 3c ff ff ff       	call   13646 <lodepng_encode_memory>
   1370a:	83 c4 20             	add    $0x20,%esp
}
   1370d:	c9                   	leave  
   1370e:	c3                   	ret    

0001370f <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   1370f:	55                   	push   %ebp
   13710:	89 e5                	mov    %esp,%ebp
   13712:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   13715:	83 ec 04             	sub    $0x4,%esp
   13718:	ff 75 1c             	pushl  0x1c(%ebp)
   1371b:	ff 75 18             	pushl  0x18(%ebp)
   1371e:	ff 75 14             	pushl  0x14(%ebp)
   13721:	ff 75 10             	pushl  0x10(%ebp)
   13724:	ff 75 0c             	pushl  0xc(%ebp)
   13727:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1372a:	50                   	push   %eax
   1372b:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1372e:	50                   	push   %eax
   1372f:	e8 12 ff ff ff       	call   13646 <lodepng_encode_memory>
   13734:	83 c4 20             	add    $0x20,%esp
   13737:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   1373a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1373e:	75 19                	jne    13759 <lodepng_encode_file+0x4a>
   13740:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13743:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13746:	83 ec 04             	sub    $0x4,%esp
   13749:	ff 75 08             	pushl  0x8(%ebp)
   1374c:	52                   	push   %edx
   1374d:	50                   	push   %eax
   1374e:	e8 36 01 ff ff       	call   3889 <lodepng_save_file>
   13753:	83 c4 10             	add    $0x10,%esp
   13756:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   13759:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1375c:	83 ec 0c             	sub    $0xc,%esp
   1375f:	50                   	push   %eax
   13760:	e8 7c fc fe ff       	call   33e1 <lodepng_free>
   13765:	83 c4 10             	add    $0x10,%esp
  return error;
   13768:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1376b:	c9                   	leave  
   1376c:	c3                   	ret    

0001376d <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   1376d:	55                   	push   %ebp
   1376e:	89 e5                	mov    %esp,%ebp
   13770:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   13773:	83 ec 08             	sub    $0x8,%esp
   13776:	6a 08                	push   $0x8
   13778:	6a 06                	push   $0x6
   1377a:	ff 75 14             	pushl  0x14(%ebp)
   1377d:	ff 75 10             	pushl  0x10(%ebp)
   13780:	ff 75 0c             	pushl  0xc(%ebp)
   13783:	ff 75 08             	pushl  0x8(%ebp)
   13786:	e8 84 ff ff ff       	call   1370f <lodepng_encode_file>
   1378b:	83 c4 20             	add    $0x20,%esp
}
   1378e:	c9                   	leave  
   1378f:	c3                   	ret    

00013790 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   13790:	55                   	push   %ebp
   13791:	89 e5                	mov    %esp,%ebp
   13793:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   13796:	83 ec 08             	sub    $0x8,%esp
   13799:	6a 08                	push   $0x8
   1379b:	6a 02                	push   $0x2
   1379d:	ff 75 14             	pushl  0x14(%ebp)
   137a0:	ff 75 10             	pushl  0x10(%ebp)
   137a3:	ff 75 0c             	pushl  0xc(%ebp)
   137a6:	ff 75 08             	pushl  0x8(%ebp)
   137a9:	e8 61 ff ff ff       	call   1370f <lodepng_encode_file>
   137ae:	83 c4 20             	add    $0x20,%esp
}
   137b1:	c9                   	leave  
   137b2:	c3                   	ret    

000137b3 <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   137b3:	55                   	push   %ebp
   137b4:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   137b6:	8b 45 08             	mov    0x8(%ebp),%eax
   137b9:	50                   	push   %eax
   137ba:	e8 71 49 ff ff       	call   8130 <lodepng_compress_settings_init>
   137bf:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   137c2:	8b 45 08             	mov    0x8(%ebp),%eax
   137c5:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   137cc:	8b 45 08             	mov    0x8(%ebp),%eax
   137cf:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   137d6:	8b 45 08             	mov    0x8(%ebp),%eax
   137d9:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   137e0:	8b 45 08             	mov    0x8(%ebp),%eax
   137e3:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   137ea:	8b 45 08             	mov    0x8(%ebp),%eax
   137ed:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   137f4:	8b 45 08             	mov    0x8(%ebp),%eax
   137f7:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   137fe:	8b 45 08             	mov    0x8(%ebp),%eax
   13801:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   13808:	90                   	nop
   13809:	c9                   	leave  
   1380a:	c3                   	ret    

0001380b <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   1380b:	55                   	push   %ebp
   1380c:	89 e5                	mov    %esp,%ebp
  switch(code) {
   1380e:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   13812:	0f 87 c1 03 00 00    	ja     13bd9 <lodepng_error_text+0x3ce>
   13818:	8b 45 08             	mov    0x8(%ebp),%eax
   1381b:	c1 e0 02             	shl    $0x2,%eax
   1381e:	05 a0 b4 01 00       	add    $0x1b4a0,%eax
   13823:	8b 00                	mov    (%eax),%eax
   13825:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   13827:	b8 6c a1 01 00       	mov    $0x1a16c,%eax
   1382c:	e9 ad 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   13831:	b8 89 a1 01 00       	mov    $0x1a189,%eax
   13836:	e9 a3 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   1383b:	b8 9c a1 01 00       	mov    $0x1a19c,%eax
   13840:	e9 99 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   13845:	b8 d4 a1 01 00       	mov    $0x1a1d4,%eax
   1384a:	e9 8f 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   1384f:	b8 0c a2 01 00       	mov    $0x1a20c,%eax
   13854:	e9 85 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   13859:	b8 0c a2 01 00       	mov    $0x1a20c,%eax
   1385e:	e9 7b 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   13863:	b8 0c a2 01 00       	mov    $0x1a20c,%eax
   13868:	e9 71 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   1386d:	b8 3c a2 01 00       	mov    $0x1a23c,%eax
   13872:	e9 67 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   13877:	b8 70 a2 01 00       	mov    $0x1a270,%eax
   1387c:	e9 5d 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   13881:	b8 a4 a2 01 00       	mov    $0x1a2a4,%eax
   13886:	e9 53 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   1388b:	b8 70 a2 01 00       	mov    $0x1a270,%eax
   13890:	e9 49 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   13895:	b8 cc a2 01 00       	mov    $0x1a2cc,%eax
   1389a:	e9 3f 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   1389f:	b8 04 a3 01 00       	mov    $0x1a304,%eax
   138a4:	e9 35 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   138a9:	b8 70 a2 01 00       	mov    $0x1a270,%eax
   138ae:	e9 2b 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   138b3:	b8 3c a3 01 00       	mov    $0x1a33c,%eax
   138b8:	e9 21 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   138bd:	b8 6c a3 01 00       	mov    $0x1a36c,%eax
   138c2:	e9 17 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   138c7:	b8 8c a3 01 00       	mov    $0x1a38c,%eax
   138cc:	e9 0d 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   138d1:	b8 b8 a3 01 00       	mov    $0x1a3b8,%eax
   138d6:	e9 03 03 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   138db:	b8 f8 a3 01 00       	mov    $0x1a3f8,%eax
   138e0:	e9 f9 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   138e5:	b8 20 a4 01 00       	mov    $0x1a420,%eax
   138ea:	e9 ef 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   138ef:	b8 54 a4 01 00       	mov    $0x1a454,%eax
   138f4:	e9 e5 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   138f9:	b8 78 a4 01 00       	mov    $0x1a478,%eax
   138fe:	e9 db 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   13903:	b8 b0 a4 01 00       	mov    $0x1a4b0,%eax
   13908:	e9 d1 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   1390d:	b8 d0 a4 01 00       	mov    $0x1a4d0,%eax
   13912:	e9 c7 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   13917:	b8 ef a4 01 00       	mov    $0x1a4ef,%eax
   1391c:	e9 bd 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   13921:	b8 09 a5 01 00       	mov    $0x1a509,%eax
   13926:	e9 b3 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   1392b:	b8 28 a5 01 00       	mov    $0x1a528,%eax
   13930:	e9 a9 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   13935:	b8 64 a5 01 00       	mov    $0x1a564,%eax
   1393a:	e9 9f 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   1393f:	b8 88 a5 01 00       	mov    $0x1a588,%eax
   13944:	e9 95 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   13949:	b8 b4 a5 01 00       	mov    $0x1a5b4,%eax
   1394e:	e9 8b 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   13953:	b8 d8 a5 01 00       	mov    $0x1a5d8,%eax
   13958:	e9 81 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   1395d:	b8 18 a6 01 00       	mov    $0x1a618,%eax
   13962:	e9 77 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   13967:	b8 48 a6 01 00       	mov    $0x1a648,%eax
   1396c:	e9 6d 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   13971:	b8 70 a6 01 00       	mov    $0x1a670,%eax
   13976:	e9 63 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   1397b:	b8 b4 a6 01 00       	mov    $0x1a6b4,%eax
   13980:	e9 59 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   13985:	b8 e0 a6 01 00       	mov    $0x1a6e0,%eax
   1398a:	e9 4f 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   1398f:	b8 10 a7 01 00       	mov    $0x1a710,%eax
   13994:	e9 45 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   13999:	b8 38 a7 01 00       	mov    $0x1a738,%eax
   1399e:	e9 3b 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   139a3:	b8 80 a7 01 00       	mov    $0x1a780,%eax
   139a8:	e9 31 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   139ad:	b8 80 a7 01 00       	mov    $0x1a780,%eax
   139b2:	e9 27 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   139b7:	b8 bc a7 01 00       	mov    $0x1a7bc,%eax
   139bc:	e9 1d 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   139c1:	b8 f0 a7 01 00       	mov    $0x1a7f0,%eax
   139c6:	e9 13 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   139cb:	b8 13 a8 01 00       	mov    $0x1a813,%eax
   139d0:	e9 09 02 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   139d5:	b8 30 a8 01 00       	mov    $0x1a830,%eax
   139da:	e9 ff 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   139df:	b8 6c a8 01 00       	mov    $0x1a86c,%eax
   139e4:	e9 f5 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   139e9:	b8 9c a8 01 00       	mov    $0x1a89c,%eax
   139ee:	e9 eb 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   139f3:	b8 e8 a8 01 00       	mov    $0x1a8e8,%eax
   139f8:	e9 e1 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   139fd:	b8 20 a9 01 00       	mov    $0x1a920,%eax
   13a02:	e9 d7 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   13a07:	b8 60 a9 01 00       	mov    $0x1a960,%eax
   13a0c:	e9 cd 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   13a11:	b8 8c a9 01 00       	mov    $0x1a98c,%eax
   13a16:	e9 c3 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   13a1b:	b8 d8 a9 01 00       	mov    $0x1a9d8,%eax
   13a20:	e9 b9 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   13a25:	b8 2c aa 01 00       	mov    $0x1aa2c,%eax
   13a2a:	e9 af 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   13a2f:	b8 60 aa 01 00       	mov    $0x1aa60,%eax
   13a34:	e9 a5 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   13a39:	b8 b0 aa 01 00       	mov    $0x1aab0,%eax
   13a3e:	e9 9b 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   13a43:	b8 ec aa 01 00       	mov    $0x1aaec,%eax
   13a48:	e9 91 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   13a4d:	b8 4c ab 01 00       	mov    $0x1ab4c,%eax
   13a52:	e9 87 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   13a57:	b8 ac ab 01 00       	mov    $0x1abac,%eax
   13a5c:	e9 7d 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   13a61:	b8 08 ac 01 00       	mov    $0x1ac08,%eax
   13a66:	e9 73 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   13a6b:	b8 4c ac 01 00       	mov    $0x1ac4c,%eax
   13a70:	e9 69 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   13a75:	b8 88 ac 01 00       	mov    $0x1ac88,%eax
   13a7a:	e9 5f 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   13a7f:	b8 e5 ac 01 00       	mov    $0x1ace5,%eax
   13a84:	e9 55 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   13a89:	b8 fd ac 01 00       	mov    $0x1acfd,%eax
   13a8e:	e9 4b 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   13a93:	b8 18 ad 01 00       	mov    $0x1ad18,%eax
   13a98:	e9 41 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   13a9d:	b8 54 ad 01 00       	mov    $0x1ad54,%eax
   13aa2:	e9 37 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   13aa7:	b8 84 ad 01 00       	mov    $0x1ad84,%eax
   13aac:	e9 2d 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   13ab1:	b8 a4 ad 01 00       	mov    $0x1ada4,%eax
   13ab6:	e9 23 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   13abb:	b8 c4 ad 01 00       	mov    $0x1adc4,%eax
   13ac0:	e9 19 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   13ac5:	b8 e4 ad 01 00       	mov    $0x1ade4,%eax
   13aca:	e9 0f 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   13acf:	b8 08 ae 01 00       	mov    $0x1ae08,%eax
   13ad4:	e9 05 01 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   13ad9:	b8 30 ae 01 00       	mov    $0x1ae30,%eax
   13ade:	e9 fb 00 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   13ae3:	b8 8d ae 01 00       	mov    $0x1ae8d,%eax
   13ae8:	e9 f1 00 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   13aed:	b8 a8 ae 01 00       	mov    $0x1aea8,%eax
   13af2:	e9 e7 00 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   13af7:	b8 e4 ae 01 00       	mov    $0x1aee4,%eax
   13afc:	e9 dd 00 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   13b01:	b8 18 af 01 00       	mov    $0x1af18,%eax
   13b06:	e9 d3 00 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   13b0b:	b8 6c af 01 00       	mov    $0x1af6c,%eax
   13b10:	e9 c9 00 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   13b15:	b8 b8 af 01 00       	mov    $0x1afb8,%eax
   13b1a:	e9 bf 00 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   13b1f:	b8 f4 af 01 00       	mov    $0x1aff4,%eax
   13b24:	e9 b5 00 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   13b29:	b8 18 b0 01 00       	mov    $0x1b018,%eax
   13b2e:	e9 ab 00 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   13b33:	b8 38 b0 01 00       	mov    $0x1b038,%eax
   13b38:	e9 a1 00 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   13b3d:	b8 60 b0 01 00       	mov    $0x1b060,%eax
   13b42:	e9 97 00 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   13b47:	b8 80 b0 01 00       	mov    $0x1b080,%eax
   13b4c:	e9 8d 00 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   13b51:	b8 ac b0 01 00       	mov    $0x1b0ac,%eax
   13b56:	e9 83 00 00 00       	jmp    13bde <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   13b5b:	b8 db b0 01 00       	mov    $0x1b0db,%eax
   13b60:	eb 7c                	jmp    13bde <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   13b62:	b8 f3 b0 01 00       	mov    $0x1b0f3,%eax
   13b67:	eb 75                	jmp    13bde <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   13b69:	b8 0b b1 01 00       	mov    $0x1b10b,%eax
   13b6e:	eb 6e                	jmp    13bde <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   13b70:	b8 23 b1 01 00       	mov    $0x1b123,%eax
   13b75:	eb 67                	jmp    13bde <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   13b77:	b8 44 b1 01 00       	mov    $0x1b144,%eax
   13b7c:	eb 60                	jmp    13bde <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   13b7e:	b8 94 b1 01 00       	mov    $0x1b194,%eax
   13b83:	eb 59                	jmp    13bde <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   13b85:	b8 e8 b1 01 00       	mov    $0x1b1e8,%eax
   13b8a:	eb 52                	jmp    13bde <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   13b8c:	b8 3c b2 01 00       	mov    $0x1b23c,%eax
   13b91:	eb 4b                	jmp    13bde <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   13b93:	b8 84 b2 01 00       	mov    $0x1b284,%eax
   13b98:	eb 44                	jmp    13bde <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   13b9a:	b8 c8 b2 01 00       	mov    $0x1b2c8,%eax
   13b9f:	eb 3d                	jmp    13bde <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   13ba1:	b8 e4 b2 01 00       	mov    $0x1b2e4,%eax
   13ba6:	eb 36                	jmp    13bde <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   13ba8:	b8 1c b3 01 00       	mov    $0x1b31c,%eax
   13bad:	eb 2f                	jmp    13bde <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   13baf:	b8 70 b3 01 00       	mov    $0x1b370,%eax
   13bb4:	eb 28                	jmp    13bde <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   13bb6:	b8 a0 b3 01 00       	mov    $0x1b3a0,%eax
   13bbb:	eb 21                	jmp    13bde <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   13bbd:	b8 f0 b3 01 00       	mov    $0x1b3f0,%eax
   13bc2:	eb 1a                	jmp    13bde <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   13bc4:	b8 1c b4 01 00       	mov    $0x1b41c,%eax
   13bc9:	eb 13                	jmp    13bde <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   13bcb:	b8 48 b4 01 00       	mov    $0x1b448,%eax
   13bd0:	eb 0c                	jmp    13bde <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   13bd2:	b8 6c b4 01 00       	mov    $0x1b46c,%eax
   13bd7:	eb 05                	jmp    13bde <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   13bd9:	b8 8b b4 01 00       	mov    $0x1b48b,%eax
}
   13bde:	5d                   	pop    %ebp
   13bdf:	c3                   	ret    

00013be0 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   13be0:	55                   	push   %ebp
   13be1:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   13be3:	8b 45 08             	mov    0x8(%ebp),%eax
   13be6:	8b 40 28             	mov    0x28(%eax),%eax
   13be9:	83 f8 01             	cmp    $0x1,%eax
   13bec:	75 08                	jne    13bf6 <GetImage+0x16>
   13bee:	8b 45 08             	mov    0x8(%ebp),%eax
   13bf1:	8b 40 54             	mov    0x54(%eax),%eax
   13bf4:	eb 09                	jmp    13bff <GetImage+0x1f>
   13bf6:	8b 45 08             	mov    0x8(%ebp),%eax
   13bf9:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   13bff:	5d                   	pop    %ebp
   13c00:	c3                   	ret    

00013c01 <GetWidth>:

int GetWidth(Context* ctx){
   13c01:	55                   	push   %ebp
   13c02:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   13c04:	8b 45 08             	mov    0x8(%ebp),%eax
   13c07:	8b 40 10             	mov    0x10(%eax),%eax
}
   13c0a:	5d                   	pop    %ebp
   13c0b:	c3                   	ret    

00013c0c <GetHeight>:

int GetHeight(Context* ctx){
   13c0c:	55                   	push   %ebp
   13c0d:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   13c0f:	8b 45 08             	mov    0x8(%ebp),%eax
   13c12:	8b 40 14             	mov    0x14(%eax),%eax
}
   13c15:	5d                   	pop    %ebp
   13c16:	c3                   	ret    

00013c17 <GetImageSize>:

uint GetImageSize(Context* ctx){
   13c17:	55                   	push   %ebp
   13c18:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   13c1a:	8b 45 08             	mov    0x8(%ebp),%eax
   13c1d:	8b 50 10             	mov    0x10(%eax),%edx
   13c20:	8b 45 08             	mov    0x8(%ebp),%eax
   13c23:	8b 40 14             	mov    0x14(%eax),%eax
   13c26:	0f af d0             	imul   %eax,%edx
   13c29:	8b 45 08             	mov    0x8(%ebp),%eax
   13c2c:	8b 40 28             	mov    0x28(%eax),%eax
   13c2f:	0f af c2             	imul   %edx,%eax
}
   13c32:	5d                   	pop    %ebp
   13c33:	c3                   	ret    

00013c34 <_Clip>:

uchar _Clip(const int x){
   13c34:	55                   	push   %ebp
   13c35:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   13c37:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13c3b:	78 15                	js     13c52 <_Clip+0x1e>
   13c3d:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   13c44:	7f 05                	jg     13c4b <_Clip+0x17>
   13c46:	8b 45 08             	mov    0x8(%ebp),%eax
   13c49:	eb 0c                	jmp    13c57 <_Clip+0x23>
   13c4b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13c50:	eb 05                	jmp    13c57 <_Clip+0x23>
   13c52:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13c57:	5d                   	pop    %ebp
   13c58:	c3                   	ret    

00013c59 <_Skip>:

void _Skip(Context* ctx, int c){
   13c59:	55                   	push   %ebp
   13c5a:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   13c5c:	8b 45 08             	mov    0x8(%ebp),%eax
   13c5f:	8b 50 04             	mov    0x4(%eax),%edx
   13c62:	8b 45 0c             	mov    0xc(%ebp),%eax
   13c65:	01 c2                	add    %eax,%edx
   13c67:	8b 45 08             	mov    0x8(%ebp),%eax
   13c6a:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   13c6d:	8b 45 08             	mov    0x8(%ebp),%eax
   13c70:	8b 40 08             	mov    0x8(%eax),%eax
   13c73:	2b 45 0c             	sub    0xc(%ebp),%eax
   13c76:	89 c2                	mov    %eax,%edx
   13c78:	8b 45 08             	mov    0x8(%ebp),%eax
   13c7b:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   13c7e:	8b 45 08             	mov    0x8(%ebp),%eax
   13c81:	8b 40 0c             	mov    0xc(%eax),%eax
   13c84:	2b 45 0c             	sub    0xc(%ebp),%eax
   13c87:	89 c2                	mov    %eax,%edx
   13c89:	8b 45 08             	mov    0x8(%ebp),%eax
   13c8c:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   13c8f:	8b 45 08             	mov    0x8(%ebp),%eax
   13c92:	8b 40 08             	mov    0x8(%eax),%eax
   13c95:	85 c0                	test   %eax,%eax
   13c97:	79 09                	jns    13ca2 <_Skip+0x49>
   13c99:	8b 45 08             	mov    0x8(%ebp),%eax
   13c9c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   13ca2:	90                   	nop
   13ca3:	5d                   	pop    %ebp
   13ca4:	c3                   	ret    

00013ca5 <_DecodeLength>:

void _DecodeLength(Context* ctx){
   13ca5:	55                   	push   %ebp
   13ca6:	89 e5                	mov    %esp,%ebp
   13ca8:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   13cab:	8b 45 08             	mov    0x8(%ebp),%eax
   13cae:	8b 40 08             	mov    0x8(%eax),%eax
   13cb1:	83 f8 01             	cmp    $0x1,%eax
   13cb4:	7f 0b                	jg     13cc1 <_DecodeLength+0x1c>
   13cb6:	8b 45 08             	mov    0x8(%ebp),%eax
   13cb9:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13cbf:	eb 45                	jmp    13d06 <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   13cc1:	8b 45 08             	mov    0x8(%ebp),%eax
   13cc4:	8b 40 04             	mov    0x4(%eax),%eax
   13cc7:	83 ec 0c             	sub    $0xc,%esp
   13cca:	50                   	push   %eax
   13ccb:	e8 38 00 00 00       	call   13d08 <_Decode2Bytes>
   13cd0:	83 c4 10             	add    $0x10,%esp
   13cd3:	89 c2                	mov    %eax,%edx
   13cd5:	8b 45 08             	mov    0x8(%ebp),%eax
   13cd8:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   13cdb:	8b 45 08             	mov    0x8(%ebp),%eax
   13cde:	8b 50 0c             	mov    0xc(%eax),%edx
   13ce1:	8b 45 08             	mov    0x8(%ebp),%eax
   13ce4:	8b 40 08             	mov    0x8(%eax),%eax
   13ce7:	39 c2                	cmp    %eax,%edx
   13ce9:	7e 0b                	jle    13cf6 <_DecodeLength+0x51>
   13ceb:	8b 45 08             	mov    0x8(%ebp),%eax
   13cee:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13cf4:	eb 10                	jmp    13d06 <_DecodeLength+0x61>
    _Skip(ctx, 2);
   13cf6:	83 ec 08             	sub    $0x8,%esp
   13cf9:	6a 02                	push   $0x2
   13cfb:	ff 75 08             	pushl  0x8(%ebp)
   13cfe:	e8 56 ff ff ff       	call   13c59 <_Skip>
   13d03:	83 c4 10             	add    $0x10,%esp
}
   13d06:	c9                   	leave  
   13d07:	c3                   	ret    

00013d08 <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   13d08:	55                   	push   %ebp
   13d09:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   13d0b:	8b 45 08             	mov    0x8(%ebp),%eax
   13d0e:	0f b6 00             	movzbl (%eax),%eax
   13d11:	0f b6 c0             	movzbl %al,%eax
   13d14:	c1 e0 08             	shl    $0x8,%eax
   13d17:	89 c2                	mov    %eax,%edx
   13d19:	8b 45 08             	mov    0x8(%ebp),%eax
   13d1c:	83 c0 01             	add    $0x1,%eax
   13d1f:	0f b6 00             	movzbl (%eax),%eax
   13d22:	0f b6 c0             	movzbl %al,%eax
   13d25:	09 d0                	or     %edx,%eax
}
   13d27:	5d                   	pop    %ebp
   13d28:	c3                   	ret    

00013d29 <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   13d29:	55                   	push   %ebp
   13d2a:	89 e5                	mov    %esp,%ebp
   13d2c:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   13d2f:	8b 45 08             	mov    0x8(%ebp),%eax
   13d32:	8b 55 10             	mov    0x10(%ebp),%edx
   13d35:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   13d38:	8b 45 14             	mov    0x14(%ebp),%eax
   13d3b:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   13d40:	89 c2                	mov    %eax,%edx
   13d42:	8b 45 08             	mov    0x8(%ebp),%eax
   13d45:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   13d48:	8b 45 08             	mov    0x8(%ebp),%eax
   13d4b:	8b 40 08             	mov    0x8(%eax),%eax
   13d4e:	83 f8 01             	cmp    $0x1,%eax
   13d51:	7e 1d                	jle    13d70 <_DecodeJPEG+0x47>
   13d53:	8b 45 08             	mov    0x8(%ebp),%eax
   13d56:	8b 40 04             	mov    0x4(%eax),%eax
   13d59:	0f b6 00             	movzbl (%eax),%eax
   13d5c:	3c ff                	cmp    $0xff,%al
   13d5e:	75 10                	jne    13d70 <_DecodeJPEG+0x47>
   13d60:	8b 45 08             	mov    0x8(%ebp),%eax
   13d63:	8b 40 04             	mov    0x4(%eax),%eax
   13d66:	83 c0 01             	add    $0x1,%eax
   13d69:	0f b6 00             	movzbl (%eax),%eax
   13d6c:	3c d8                	cmp    $0xd8,%al
   13d6e:	74 0a                	je     13d7a <_DecodeJPEG+0x51>
   13d70:	b8 01 00 00 00       	mov    $0x1,%eax
   13d75:	e9 56 01 00 00       	jmp    13ed0 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   13d7a:	6a 02                	push   $0x2
   13d7c:	ff 75 08             	pushl  0x8(%ebp)
   13d7f:	e8 d5 fe ff ff       	call   13c59 <_Skip>
   13d84:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   13d87:	e9 0a 01 00 00       	jmp    13e96 <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   13d8c:	8b 45 08             	mov    0x8(%ebp),%eax
   13d8f:	8b 40 08             	mov    0x8(%eax),%eax
   13d92:	85 c0                	test   %eax,%eax
   13d94:	78 0d                	js     13da3 <_DecodeJPEG+0x7a>
   13d96:	8b 45 08             	mov    0x8(%ebp),%eax
   13d99:	8b 40 04             	mov    0x4(%eax),%eax
   13d9c:	0f b6 00             	movzbl (%eax),%eax
   13d9f:	3c ff                	cmp    $0xff,%al
   13da1:	74 0a                	je     13dad <_DecodeJPEG+0x84>
   13da3:	b8 05 00 00 00       	mov    $0x5,%eax
   13da8:	e9 23 01 00 00       	jmp    13ed0 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   13dad:	6a 02                	push   $0x2
   13daf:	ff 75 08             	pushl  0x8(%ebp)
   13db2:	e8 a2 fe ff ff       	call   13c59 <_Skip>
   13db7:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   13dba:	8b 45 08             	mov    0x8(%ebp),%eax
   13dbd:	8b 40 04             	mov    0x4(%eax),%eax
   13dc0:	83 e8 01             	sub    $0x1,%eax
   13dc3:	0f b6 00             	movzbl (%eax),%eax
   13dc6:	0f b6 c0             	movzbl %al,%eax
   13dc9:	3d da 00 00 00       	cmp    $0xda,%eax
   13dce:	74 71                	je     13e41 <_DecodeJPEG+0x118>
   13dd0:	3d da 00 00 00       	cmp    $0xda,%eax
   13dd5:	7f 10                	jg     13de7 <_DecodeJPEG+0xbe>
   13dd7:	3d c0 00 00 00       	cmp    $0xc0,%eax
   13ddc:	74 20                	je     13dfe <_DecodeJPEG+0xd5>
   13dde:	3d c4 00 00 00       	cmp    $0xc4,%eax
   13de3:	74 2c                	je     13e11 <_DecodeJPEG+0xe8>
   13de5:	eb 7d                	jmp    13e64 <_DecodeJPEG+0x13b>
   13de7:	3d dd 00 00 00       	cmp    $0xdd,%eax
   13dec:	74 43                	je     13e31 <_DecodeJPEG+0x108>
   13dee:	3d fe 00 00 00       	cmp    $0xfe,%eax
   13df3:	74 5f                	je     13e54 <_DecodeJPEG+0x12b>
   13df5:	3d db 00 00 00       	cmp    $0xdb,%eax
   13dfa:	74 25                	je     13e21 <_DecodeJPEG+0xf8>
   13dfc:	eb 66                	jmp    13e64 <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   13dfe:	83 ec 0c             	sub    $0xc,%esp
   13e01:	ff 75 08             	pushl  0x8(%ebp)
   13e04:	e8 c9 00 00 00       	call   13ed2 <_DecodeSOF>
   13e09:	83 c4 10             	add    $0x10,%esp
   13e0c:	e9 85 00 00 00       	jmp    13e96 <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   13e11:	83 ec 0c             	sub    $0xc,%esp
   13e14:	ff 75 08             	pushl  0x8(%ebp)
   13e17:	e8 28 05 00 00       	call   14344 <_DecodeDHT>
   13e1c:	83 c4 10             	add    $0x10,%esp
   13e1f:	eb 75                	jmp    13e96 <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   13e21:	83 ec 0c             	sub    $0xc,%esp
   13e24:	ff 75 08             	pushl  0x8(%ebp)
   13e27:	e8 05 07 00 00       	call   14531 <_DecodeDQT>
   13e2c:	83 c4 10             	add    $0x10,%esp
   13e2f:	eb 65                	jmp    13e96 <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   13e31:	83 ec 0c             	sub    $0xc,%esp
   13e34:	ff 75 08             	pushl  0x8(%ebp)
   13e37:	e8 ff 07 00 00       	call   1463b <_DecodeDRI>
   13e3c:	83 c4 10             	add    $0x10,%esp
   13e3f:	eb 55                	jmp    13e96 <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   13e41:	83 ec 08             	sub    $0x8,%esp
   13e44:	ff 75 0c             	pushl  0xc(%ebp)
   13e47:	ff 75 08             	pushl  0x8(%ebp)
   13e4a:	e8 56 08 00 00       	call   146a5 <_DecodeSOS>
   13e4f:	83 c4 10             	add    $0x10,%esp
   13e52:	eb 42                	jmp    13e96 <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   13e54:	83 ec 0c             	sub    $0xc,%esp
   13e57:	ff 75 08             	pushl  0x8(%ebp)
   13e5a:	e8 a8 15 00 00       	call   15407 <_SkipMarker>
   13e5f:	83 c4 10             	add    $0x10,%esp
   13e62:	eb 32                	jmp    13e96 <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   13e64:	8b 45 08             	mov    0x8(%ebp),%eax
   13e67:	8b 40 04             	mov    0x4(%eax),%eax
   13e6a:	83 e8 01             	sub    $0x1,%eax
   13e6d:	0f b6 00             	movzbl (%eax),%eax
   13e70:	0f b6 c0             	movzbl %al,%eax
   13e73:	25 f0 00 00 00       	and    $0xf0,%eax
   13e78:	3d e0 00 00 00       	cmp    $0xe0,%eax
   13e7d:	75 10                	jne    13e8f <_DecodeJPEG+0x166>
   13e7f:	83 ec 0c             	sub    $0xc,%esp
   13e82:	ff 75 08             	pushl  0x8(%ebp)
   13e85:	e8 7d 15 00 00       	call   15407 <_SkipMarker>
   13e8a:	83 c4 10             	add    $0x10,%esp
   13e8d:	eb 07                	jmp    13e96 <_DecodeJPEG+0x16d>
                else return Unsupported;
   13e8f:	b8 02 00 00 00       	mov    $0x2,%eax
   13e94:	eb 3a                	jmp    13ed0 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   13e96:	8b 45 08             	mov    0x8(%ebp),%eax
   13e99:	8b 00                	mov    (%eax),%eax
   13e9b:	85 c0                	test   %eax,%eax
   13e9d:	0f 84 e9 fe ff ff    	je     13d8c <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   13ea3:	8b 45 08             	mov    0x8(%ebp),%eax
   13ea6:	8b 00                	mov    (%eax),%eax
   13ea8:	83 f8 06             	cmp    $0x6,%eax
   13eab:	74 07                	je     13eb4 <_DecodeJPEG+0x18b>
   13ead:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb0:	8b 00                	mov    (%eax),%eax
   13eb2:	eb 1c                	jmp    13ed0 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   13eb4:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   13ebd:	83 ec 0c             	sub    $0xc,%esp
   13ec0:	ff 75 08             	pushl  0x8(%ebp)
   13ec3:	e8 6b 15 00 00       	call   15433 <_Convert>
   13ec8:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   13ecb:	8b 45 08             	mov    0x8(%ebp),%eax
   13ece:	8b 00                	mov    (%eax),%eax
 }
   13ed0:	c9                   	leave  
   13ed1:	c3                   	ret    

00013ed2 <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   13ed2:	55                   	push   %ebp
   13ed3:	89 e5                	mov    %esp,%ebp
   13ed5:	53                   	push   %ebx
   13ed6:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   13ed9:	83 ec 0c             	sub    $0xc,%esp
   13edc:	ff 75 08             	pushl  0x8(%ebp)
   13edf:	e8 c1 fd ff ff       	call   13ca5 <_DecodeLength>
   13ee4:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   13ee7:	8b 45 08             	mov    0x8(%ebp),%eax
   13eea:	8b 00                	mov    (%eax),%eax
   13eec:	85 c0                	test   %eax,%eax
   13eee:	0f 85 4a 04 00 00    	jne    1433e <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   13ef4:	8b 45 08             	mov    0x8(%ebp),%eax
   13ef7:	8b 40 0c             	mov    0xc(%eax),%eax
   13efa:	83 f8 08             	cmp    $0x8,%eax
   13efd:	7f 0e                	jg     13f0d <_DecodeSOF+0x3b>
   13eff:	8b 45 08             	mov    0x8(%ebp),%eax
   13f02:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13f08:	e9 32 04 00 00       	jmp    1433f <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   13f0d:	8b 45 08             	mov    0x8(%ebp),%eax
   13f10:	8b 40 04             	mov    0x4(%eax),%eax
   13f13:	0f b6 00             	movzbl (%eax),%eax
   13f16:	3c 08                	cmp    $0x8,%al
   13f18:	74 0e                	je     13f28 <_DecodeSOF+0x56>
   13f1a:	8b 45 08             	mov    0x8(%ebp),%eax
   13f1d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13f23:	e9 17 04 00 00       	jmp    1433f <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   13f28:	8b 45 08             	mov    0x8(%ebp),%eax
   13f2b:	8b 40 04             	mov    0x4(%eax),%eax
   13f2e:	83 c0 01             	add    $0x1,%eax
   13f31:	83 ec 0c             	sub    $0xc,%esp
   13f34:	50                   	push   %eax
   13f35:	e8 ce fd ff ff       	call   13d08 <_Decode2Bytes>
   13f3a:	83 c4 10             	add    $0x10,%esp
   13f3d:	89 c2                	mov    %eax,%edx
   13f3f:	8b 45 08             	mov    0x8(%ebp),%eax
   13f42:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   13f45:	8b 45 08             	mov    0x8(%ebp),%eax
   13f48:	8b 40 04             	mov    0x4(%eax),%eax
   13f4b:	83 c0 03             	add    $0x3,%eax
   13f4e:	83 ec 0c             	sub    $0xc,%esp
   13f51:	50                   	push   %eax
   13f52:	e8 b1 fd ff ff       	call   13d08 <_Decode2Bytes>
   13f57:	83 c4 10             	add    $0x10,%esp
   13f5a:	89 c2                	mov    %eax,%edx
   13f5c:	8b 45 08             	mov    0x8(%ebp),%eax
   13f5f:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   13f62:	8b 45 08             	mov    0x8(%ebp),%eax
   13f65:	8b 40 04             	mov    0x4(%eax),%eax
   13f68:	83 c0 05             	add    $0x5,%eax
   13f6b:	0f b6 00             	movzbl (%eax),%eax
   13f6e:	0f b6 d0             	movzbl %al,%edx
   13f71:	8b 45 08             	mov    0x8(%ebp),%eax
   13f74:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   13f77:	83 ec 08             	sub    $0x8,%esp
   13f7a:	6a 06                	push   $0x6
   13f7c:	ff 75 08             	pushl  0x8(%ebp)
   13f7f:	e8 d5 fc ff ff       	call   13c59 <_Skip>
   13f84:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   13f87:	8b 45 08             	mov    0x8(%ebp),%eax
   13f8a:	8b 40 28             	mov    0x28(%eax),%eax
   13f8d:	83 f8 01             	cmp    $0x1,%eax
   13f90:	74 13                	je     13fa5 <_DecodeSOF+0xd3>
   13f92:	83 f8 03             	cmp    $0x3,%eax
   13f95:	74 0e                	je     13fa5 <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   13f97:	8b 45 08             	mov    0x8(%ebp),%eax
   13f9a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13fa0:	e9 9a 03 00 00       	jmp    1433f <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   13fa5:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   13fa6:	8b 45 08             	mov    0x8(%ebp),%eax
   13fa9:	8b 48 0c             	mov    0xc(%eax),%ecx
   13fac:	8b 45 08             	mov    0x8(%ebp),%eax
   13faf:	8b 50 28             	mov    0x28(%eax),%edx
   13fb2:	89 d0                	mov    %edx,%eax
   13fb4:	01 c0                	add    %eax,%eax
   13fb6:	01 d0                	add    %edx,%eax
   13fb8:	39 c1                	cmp    %eax,%ecx
   13fba:	7d 0e                	jge    13fca <_DecodeSOF+0xf8>
   13fbc:	8b 45 08             	mov    0x8(%ebp),%eax
   13fbf:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13fc5:	e9 75 03 00 00       	jmp    1433f <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   13fca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13fd1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   13fd8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13fdf:	8b 45 08             	mov    0x8(%ebp),%eax
   13fe2:	83 c0 2c             	add    $0x2c,%eax
   13fe5:	89 45 e8             	mov    %eax,-0x18(%ebp)
   13fe8:	e9 50 01 00 00       	jmp    1413d <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   13fed:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff0:	8b 40 04             	mov    0x4(%eax),%eax
   13ff3:	0f b6 00             	movzbl (%eax),%eax
   13ff6:	0f b6 d0             	movzbl %al,%edx
   13ff9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13ffc:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   13ffe:	8b 45 08             	mov    0x8(%ebp),%eax
   14001:	8b 40 04             	mov    0x4(%eax),%eax
   14004:	83 c0 01             	add    $0x1,%eax
   14007:	0f b6 00             	movzbl (%eax),%eax
   1400a:	c0 e8 04             	shr    $0x4,%al
   1400d:	0f b6 d0             	movzbl %al,%edx
   14010:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14013:	89 50 04             	mov    %edx,0x4(%eax)
   14016:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14019:	8b 40 04             	mov    0x4(%eax),%eax
   1401c:	85 c0                	test   %eax,%eax
   1401e:	75 0e                	jne    1402e <_DecodeSOF+0x15c>
   14020:	8b 45 08             	mov    0x8(%ebp),%eax
   14023:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14029:	e9 11 03 00 00       	jmp    1433f <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   1402e:	8b 45 08             	mov    0x8(%ebp),%eax
   14031:	8b 40 04             	mov    0x4(%eax),%eax
   14034:	83 c0 01             	add    $0x1,%eax
   14037:	0f b6 00             	movzbl (%eax),%eax
   1403a:	0f b6 c0             	movzbl %al,%eax
   1403d:	83 e0 0f             	and    $0xf,%eax
   14040:	89 c2                	mov    %eax,%edx
   14042:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14045:	89 50 08             	mov    %edx,0x8(%eax)
   14048:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1404b:	8b 40 08             	mov    0x8(%eax),%eax
   1404e:	85 c0                	test   %eax,%eax
   14050:	75 0e                	jne    14060 <_DecodeSOF+0x18e>
   14052:	8b 45 08             	mov    0x8(%ebp),%eax
   14055:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1405b:	e9 df 02 00 00       	jmp    1433f <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   14060:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14063:	8b 50 04             	mov    0x4(%eax),%edx
   14066:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14069:	8b 40 04             	mov    0x4(%eax),%eax
   1406c:	83 e8 01             	sub    $0x1,%eax
   1406f:	21 d0                	and    %edx,%eax
   14071:	85 c0                	test   %eax,%eax
   14073:	74 0e                	je     14083 <_DecodeSOF+0x1b1>
   14075:	8b 45 08             	mov    0x8(%ebp),%eax
   14078:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1407e:	e9 bc 02 00 00       	jmp    1433f <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   14083:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14086:	8b 50 08             	mov    0x8(%eax),%edx
   14089:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1408c:	8b 40 08             	mov    0x8(%eax),%eax
   1408f:	83 e8 01             	sub    $0x1,%eax
   14092:	21 d0                	and    %edx,%eax
   14094:	85 c0                	test   %eax,%eax
   14096:	74 0e                	je     140a6 <_DecodeSOF+0x1d4>
   14098:	8b 45 08             	mov    0x8(%ebp),%eax
   1409b:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   140a1:	e9 99 02 00 00       	jmp    1433f <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   140a6:	8b 45 08             	mov    0x8(%ebp),%eax
   140a9:	8b 40 04             	mov    0x4(%eax),%eax
   140ac:	83 c0 02             	add    $0x2,%eax
   140af:	0f b6 00             	movzbl (%eax),%eax
   140b2:	0f b6 d0             	movzbl %al,%edx
   140b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140b8:	89 50 18             	mov    %edx,0x18(%eax)
   140bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140be:	8b 40 18             	mov    0x18(%eax),%eax
   140c1:	25 fc 00 00 00       	and    $0xfc,%eax
   140c6:	85 c0                	test   %eax,%eax
   140c8:	74 0e                	je     140d8 <_DecodeSOF+0x206>
   140ca:	8b 45 08             	mov    0x8(%ebp),%eax
   140cd:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   140d3:	e9 67 02 00 00       	jmp    1433f <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   140d8:	83 ec 08             	sub    $0x8,%esp
   140db:	6a 03                	push   $0x3
   140dd:	ff 75 08             	pushl  0x8(%ebp)
   140e0:	e8 74 fb ff ff       	call   13c59 <_Skip>
   140e5:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   140e8:	8b 45 08             	mov    0x8(%ebp),%eax
   140eb:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   140f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140f4:	8b 40 18             	mov    0x18(%eax),%eax
   140f7:	bb 01 00 00 00       	mov    $0x1,%ebx
   140fc:	89 c1                	mov    %eax,%ecx
   140fe:	d3 e3                	shl    %cl,%ebx
   14100:	89 d8                	mov    %ebx,%eax
   14102:	09 c2                	or     %eax,%edx
   14104:	8b 45 08             	mov    0x8(%ebp),%eax
   14107:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   1410d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14110:	8b 40 04             	mov    0x4(%eax),%eax
   14113:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14116:	7e 09                	jle    14121 <_DecodeSOF+0x24f>
   14118:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1411b:	8b 40 04             	mov    0x4(%eax),%eax
   1411e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   14121:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14124:	8b 40 08             	mov    0x8(%eax),%eax
   14127:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1412a:	7e 09                	jle    14135 <_DecodeSOF+0x263>
   1412c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1412f:	8b 40 08             	mov    0x8(%eax),%eax
   14132:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14135:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14139:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   1413d:	8b 45 08             	mov    0x8(%ebp),%eax
   14140:	8b 40 28             	mov    0x28(%eax),%eax
   14143:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14146:	0f 8f a1 fe ff ff    	jg     13fed <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   1414c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1414f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   14156:	8b 45 08             	mov    0x8(%ebp),%eax
   14159:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   1415c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1415f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   14166:	8b 45 08             	mov    0x8(%ebp),%eax
   14169:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   1416c:	8b 45 08             	mov    0x8(%ebp),%eax
   1416f:	8b 50 10             	mov    0x10(%eax),%edx
   14172:	8b 45 08             	mov    0x8(%ebp),%eax
   14175:	8b 40 20             	mov    0x20(%eax),%eax
   14178:	01 d0                	add    %edx,%eax
   1417a:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1417d:	8b 45 08             	mov    0x8(%ebp),%eax
   14180:	8b 58 20             	mov    0x20(%eax),%ebx
   14183:	89 c8                	mov    %ecx,%eax
   14185:	99                   	cltd   
   14186:	f7 fb                	idiv   %ebx
   14188:	89 c2                	mov    %eax,%edx
   1418a:	8b 45 08             	mov    0x8(%ebp),%eax
   1418d:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   14190:	8b 45 08             	mov    0x8(%ebp),%eax
   14193:	8b 50 14             	mov    0x14(%eax),%edx
   14196:	8b 45 08             	mov    0x8(%ebp),%eax
   14199:	8b 40 24             	mov    0x24(%eax),%eax
   1419c:	01 d0                	add    %edx,%eax
   1419e:	8d 48 ff             	lea    -0x1(%eax),%ecx
   141a1:	8b 45 08             	mov    0x8(%ebp),%eax
   141a4:	8b 58 24             	mov    0x24(%eax),%ebx
   141a7:	89 c8                	mov    %ecx,%eax
   141a9:	99                   	cltd   
   141aa:	f7 fb                	idiv   %ebx
   141ac:	89 c2                	mov    %eax,%edx
   141ae:	8b 45 08             	mov    0x8(%ebp),%eax
   141b1:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   141b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   141bb:	8b 45 08             	mov    0x8(%ebp),%eax
   141be:	83 c0 2c             	add    $0x2c,%eax
   141c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
   141c4:	e9 fd 00 00 00       	jmp    142c6 <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   141c9:	8b 45 08             	mov    0x8(%ebp),%eax
   141cc:	8b 50 10             	mov    0x10(%eax),%edx
   141cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141d2:	8b 40 04             	mov    0x4(%eax),%eax
   141d5:	0f af d0             	imul   %eax,%edx
   141d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   141db:	01 d0                	add    %edx,%eax
   141dd:	83 e8 01             	sub    $0x1,%eax
   141e0:	99                   	cltd   
   141e1:	f7 7d ec             	idivl  -0x14(%ebp)
   141e4:	89 c2                	mov    %eax,%edx
   141e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141e9:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   141ec:	8b 45 08             	mov    0x8(%ebp),%eax
   141ef:	8b 50 14             	mov    0x14(%eax),%edx
   141f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141f5:	8b 40 08             	mov    0x8(%eax),%eax
   141f8:	0f af d0             	imul   %eax,%edx
   141fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141fe:	01 d0                	add    %edx,%eax
   14200:	83 e8 01             	sub    $0x1,%eax
   14203:	99                   	cltd   
   14204:	f7 7d f0             	idivl  -0x10(%ebp)
   14207:	89 c2                	mov    %eax,%edx
   14209:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1420c:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   1420f:	8b 45 08             	mov    0x8(%ebp),%eax
   14212:	8b 50 18             	mov    0x18(%eax),%edx
   14215:	8b 45 08             	mov    0x8(%ebp),%eax
   14218:	8b 40 20             	mov    0x20(%eax),%eax
   1421b:	0f af d0             	imul   %eax,%edx
   1421e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14221:	8b 40 04             	mov    0x4(%eax),%eax
   14224:	0f af c2             	imul   %edx,%eax
   14227:	99                   	cltd   
   14228:	f7 7d ec             	idivl  -0x14(%ebp)
   1422b:	89 c2                	mov    %eax,%edx
   1422d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14230:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   14233:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14236:	8b 40 0c             	mov    0xc(%eax),%eax
   14239:	83 f8 02             	cmp    $0x2,%eax
   1423c:	7f 0b                	jg     14249 <_DecodeSOF+0x377>
   1423e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14241:	8b 40 04             	mov    0x4(%eax),%eax
   14244:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14247:	75 16                	jne    1425f <_DecodeSOF+0x38d>
   14249:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1424c:	8b 40 10             	mov    0x10(%eax),%eax
   1424f:	83 f8 02             	cmp    $0x2,%eax
   14252:	7f 19                	jg     1426d <_DecodeSOF+0x39b>
   14254:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14257:	8b 40 08             	mov    0x8(%eax),%eax
   1425a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1425d:	74 0e                	je     1426d <_DecodeSOF+0x39b>
   1425f:	8b 45 08             	mov    0x8(%ebp),%eax
   14262:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14268:	e9 d2 00 00 00       	jmp    1433f <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   1426d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14270:	8b 48 14             	mov    0x14(%eax),%ecx
   14273:	8b 45 08             	mov    0x8(%ebp),%eax
   14276:	8b 50 1c             	mov    0x1c(%eax),%edx
   14279:	8b 45 08             	mov    0x8(%ebp),%eax
   1427c:	8b 40 24             	mov    0x24(%eax),%eax
   1427f:	0f af d0             	imul   %eax,%edx
   14282:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14285:	8b 40 08             	mov    0x8(%eax),%eax
   14288:	0f af c2             	imul   %edx,%eax
   1428b:	99                   	cltd   
   1428c:	f7 7d f0             	idivl  -0x10(%ebp)
   1428f:	0f af c1             	imul   %ecx,%eax
   14292:	83 ec 0c             	sub    $0xc,%esp
   14295:	50                   	push   %eax
   14296:	e8 45 c5 fe ff       	call   7e0 <malloc>
   1429b:	83 c4 10             	add    $0x10,%esp
   1429e:	89 c2                	mov    %eax,%edx
   142a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142a3:	89 50 28             	mov    %edx,0x28(%eax)
   142a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142a9:	8b 40 28             	mov    0x28(%eax),%eax
   142ac:	85 c0                	test   %eax,%eax
   142ae:	75 0e                	jne    142be <_DecodeSOF+0x3ec>
   142b0:	8b 45 08             	mov    0x8(%ebp),%eax
   142b3:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   142b9:	e9 81 00 00 00       	jmp    1433f <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   142be:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   142c2:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   142c6:	8b 45 08             	mov    0x8(%ebp),%eax
   142c9:	8b 40 28             	mov    0x28(%eax),%eax
   142cc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   142cf:	0f 8f f4 fe ff ff    	jg     141c9 <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   142d5:	8b 45 08             	mov    0x8(%ebp),%eax
   142d8:	8b 40 28             	mov    0x28(%eax),%eax
   142db:	83 f8 03             	cmp    $0x3,%eax
   142de:	75 47                	jne    14327 <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   142e0:	8b 45 08             	mov    0x8(%ebp),%eax
   142e3:	8b 50 10             	mov    0x10(%eax),%edx
   142e6:	8b 45 08             	mov    0x8(%ebp),%eax
   142e9:	8b 40 14             	mov    0x14(%eax),%eax
   142ec:	0f af d0             	imul   %eax,%edx
   142ef:	8b 45 08             	mov    0x8(%ebp),%eax
   142f2:	8b 40 28             	mov    0x28(%eax),%eax
   142f5:	0f af c2             	imul   %edx,%eax
   142f8:	83 ec 0c             	sub    $0xc,%esp
   142fb:	50                   	push   %eax
   142fc:	e8 df c4 fe ff       	call   7e0 <malloc>
   14301:	83 c4 10             	add    $0x10,%esp
   14304:	89 c2                	mov    %eax,%edx
   14306:	8b 45 08             	mov    0x8(%ebp),%eax
   14309:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   1430f:	8b 45 08             	mov    0x8(%ebp),%eax
   14312:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   14318:	85 c0                	test   %eax,%eax
   1431a:	75 0b                	jne    14327 <_DecodeSOF+0x455>
   1431c:	8b 45 08             	mov    0x8(%ebp),%eax
   1431f:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   14325:	eb 18                	jmp    1433f <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   14327:	8b 45 08             	mov    0x8(%ebp),%eax
   1432a:	8b 40 0c             	mov    0xc(%eax),%eax
   1432d:	83 ec 08             	sub    $0x8,%esp
   14330:	50                   	push   %eax
   14331:	ff 75 08             	pushl  0x8(%ebp)
   14334:	e8 20 f9 ff ff       	call   13c59 <_Skip>
   14339:	83 c4 10             	add    $0x10,%esp
   1433c:	eb 01                	jmp    1433f <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   1433e:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   1433f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14342:	c9                   	leave  
   14343:	c3                   	ret    

00014344 <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   14344:	55                   	push   %ebp
   14345:	89 e5                	mov    %esp,%ebp
   14347:	53                   	push   %ebx
   14348:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   1434b:	83 ec 0c             	sub    $0xc,%esp
   1434e:	ff 75 08             	pushl  0x8(%ebp)
   14351:	e8 4f f9 ff ff       	call   13ca5 <_DecodeLength>
   14356:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14359:	8b 45 08             	mov    0x8(%ebp),%eax
   1435c:	8b 00                	mov    (%eax),%eax
   1435e:	85 c0                	test   %eax,%eax
   14360:	0f 85 c5 01 00 00    	jne    1452b <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   14366:	e9 9c 01 00 00       	jmp    14507 <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   1436b:	8b 45 08             	mov    0x8(%ebp),%eax
   1436e:	8b 40 04             	mov    0x4(%eax),%eax
   14371:	0f b6 00             	movzbl (%eax),%eax
   14374:	0f b6 c0             	movzbl %al,%eax
   14377:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   1437a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1437d:	25 ec 00 00 00       	and    $0xec,%eax
   14382:	85 c0                	test   %eax,%eax
   14384:	74 0e                	je     14394 <_DecodeDHT+0x50>
   14386:	8b 45 08             	mov    0x8(%ebp),%eax
   14389:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1438f:	e9 98 01 00 00       	jmp    1452c <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   14394:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14397:	83 e0 02             	and    $0x2,%eax
   1439a:	85 c0                	test   %eax,%eax
   1439c:	74 0e                	je     143ac <_DecodeDHT+0x68>
   1439e:	8b 45 08             	mov    0x8(%ebp),%eax
   143a1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   143a7:	e9 80 01 00 00       	jmp    1452c <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   143ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143af:	c1 f8 03             	sar    $0x3,%eax
   143b2:	0b 45 f4             	or     -0xc(%ebp),%eax
   143b5:	83 e0 03             	and    $0x3,%eax
   143b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   143bb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   143c2:	eb 1c                	jmp    143e0 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   143c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143c7:	8d 50 ff             	lea    -0x1(%eax),%edx
   143ca:	8b 45 08             	mov    0x8(%ebp),%eax
   143cd:	8b 48 04             	mov    0x4(%eax),%ecx
   143d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143d3:	01 c8                	add    %ecx,%eax
   143d5:	0f b6 00             	movzbl (%eax),%eax
   143d8:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   143dc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   143e0:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   143e4:	7e de                	jle    143c4 <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   143e6:	83 ec 08             	sub    $0x8,%esp
   143e9:	6a 11                	push   $0x11
   143eb:	ff 75 08             	pushl  0x8(%ebp)
   143ee:	e8 66 f8 ff ff       	call   13c59 <_Skip>
   143f3:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   143f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143f9:	c1 e0 11             	shl    $0x11,%eax
   143fc:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14402:	8b 45 08             	mov    0x8(%ebp),%eax
   14405:	01 d0                	add    %edx,%eax
   14407:	83 c0 08             	add    $0x8,%eax
   1440a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   1440d:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   14414:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14417:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   1441a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14421:	e9 be 00 00 00       	jmp    144e4 <_DecodeDHT+0x1a0>
            spread >>= 1;
   14426:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   14429:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1442c:	83 e8 01             	sub    $0x1,%eax
   1442f:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   14434:	0f b6 c0             	movzbl %al,%eax
   14437:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   1443a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1443e:	0f 84 9b 00 00 00    	je     144df <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   14444:	8b 45 08             	mov    0x8(%ebp),%eax
   14447:	8b 40 0c             	mov    0xc(%eax),%eax
   1444a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   1444d:	7d 0e                	jge    1445d <_DecodeDHT+0x119>
   1444f:	8b 45 08             	mov    0x8(%ebp),%eax
   14452:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14458:	e9 cf 00 00 00       	jmp    1452c <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   1445d:	b8 10 00 00 00       	mov    $0x10,%eax
   14462:	2b 45 f0             	sub    -0x10(%ebp),%eax
   14465:	8b 55 e0             	mov    -0x20(%ebp),%edx
   14468:	89 c1                	mov    %eax,%ecx
   1446a:	d3 e2                	shl    %cl,%edx
   1446c:	89 d0                	mov    %edx,%eax
   1446e:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   14471:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14475:	79 0e                	jns    14485 <_DecodeDHT+0x141>
   14477:	8b 45 08             	mov    0x8(%ebp),%eax
   1447a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14480:	e9 a7 00 00 00       	jmp    1452c <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   14485:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1448c:	eb 36                	jmp    144c4 <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   1448e:	8b 45 08             	mov    0x8(%ebp),%eax
   14491:	8b 50 04             	mov    0x4(%eax),%edx
   14494:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14497:	01 d0                	add    %edx,%eax
   14499:	0f b6 00             	movzbl (%eax),%eax
   1449c:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   1449e:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   144a1:	eb 14                	jmp    144b7 <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   144a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   144a6:	89 c2                	mov    %eax,%edx
   144a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   144ab:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   144ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   144b0:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   144b3:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   144b7:	89 d8                	mov    %ebx,%eax
   144b9:	8d 58 ff             	lea    -0x1(%eax),%ebx
   144bc:	85 c0                	test   %eax,%eax
   144be:	75 e3                	jne    144a3 <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   144c0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   144c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144c7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   144ca:	7c c2                	jl     1448e <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   144cc:	83 ec 08             	sub    $0x8,%esp
   144cf:	ff 75 e0             	pushl  -0x20(%ebp)
   144d2:	ff 75 08             	pushl  0x8(%ebp)
   144d5:	e8 7f f7 ff ff       	call   13c59 <_Skip>
   144da:	83 c4 10             	add    $0x10,%esp
   144dd:	eb 01                	jmp    144e0 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   144df:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   144e0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   144e4:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   144e8:	0f 8e 38 ff ff ff    	jle    14426 <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   144ee:	eb 0a                	jmp    144fa <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   144f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   144f3:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   144f6:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   144fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
   144fd:	8d 50 ff             	lea    -0x1(%eax),%edx
   14500:	89 55 ec             	mov    %edx,-0x14(%ebp)
   14503:	85 c0                	test   %eax,%eax
   14505:	75 e9                	jne    144f0 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   14507:	8b 45 08             	mov    0x8(%ebp),%eax
   1450a:	8b 40 0c             	mov    0xc(%eax),%eax
   1450d:	83 f8 10             	cmp    $0x10,%eax
   14510:	0f 8f 55 fe ff ff    	jg     1436b <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14516:	8b 45 08             	mov    0x8(%ebp),%eax
   14519:	8b 40 0c             	mov    0xc(%eax),%eax
   1451c:	85 c0                	test   %eax,%eax
   1451e:	74 0c                	je     1452c <_DecodeDHT+0x1e8>
   14520:	8b 45 08             	mov    0x8(%ebp),%eax
   14523:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14529:	eb 01                	jmp    1452c <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   1452b:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   1452c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1452f:	c9                   	leave  
   14530:	c3                   	ret    

00014531 <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   14531:	55                   	push   %ebp
   14532:	89 e5                	mov    %esp,%ebp
   14534:	53                   	push   %ebx
   14535:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   14538:	83 ec 0c             	sub    $0xc,%esp
   1453b:	ff 75 08             	pushl  0x8(%ebp)
   1453e:	e8 62 f7 ff ff       	call   13ca5 <_DecodeLength>
   14543:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14546:	8b 45 08             	mov    0x8(%ebp),%eax
   14549:	8b 00                	mov    (%eax),%eax
   1454b:	85 c0                	test   %eax,%eax
   1454d:	0f 85 e2 00 00 00    	jne    14635 <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   14553:	e9 b8 00 00 00       	jmp    14610 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   14558:	8b 45 08             	mov    0x8(%ebp),%eax
   1455b:	8b 40 04             	mov    0x4(%eax),%eax
   1455e:	0f b6 00             	movzbl (%eax),%eax
   14561:	0f b6 c0             	movzbl %al,%eax
   14564:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   14567:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1456a:	25 ec 00 00 00       	and    $0xec,%eax
   1456f:	85 c0                	test   %eax,%eax
   14571:	74 0e                	je     14581 <_DecodeDQT+0x50>
   14573:	8b 45 08             	mov    0x8(%ebp),%eax
   14576:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1457c:	e9 b5 00 00 00       	jmp    14636 <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   14581:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14584:	83 e0 10             	and    $0x10,%eax
   14587:	85 c0                	test   %eax,%eax
   14589:	74 0e                	je     14599 <_DecodeDQT+0x68>
   1458b:	8b 45 08             	mov    0x8(%ebp),%eax
   1458e:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14594:	e9 9d 00 00 00       	jmp    14636 <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   14599:	8b 45 08             	mov    0x8(%ebp),%eax
   1459c:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   145a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145a5:	bb 01 00 00 00       	mov    $0x1,%ebx
   145aa:	89 c1                	mov    %eax,%ecx
   145ac:	d3 e3                	shl    %cl,%ebx
   145ae:	89 d8                	mov    %ebx,%eax
   145b0:	09 c2                	or     %eax,%edx
   145b2:	8b 45 08             	mov    0x8(%ebp),%eax
   145b5:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   145bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145be:	c1 e0 06             	shl    $0x6,%eax
   145c1:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   145c7:	8b 45 08             	mov    0x8(%ebp),%eax
   145ca:	01 d0                	add    %edx,%eax
   145cc:	83 c0 08             	add    $0x8,%eax
   145cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   145d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   145d9:	eb 1f                	jmp    145fa <_DecodeDQT+0xc9>
   145db:	8b 55 f4             	mov    -0xc(%ebp),%edx
   145de:	8b 45 f0             	mov    -0x10(%ebp),%eax
   145e1:	01 c2                	add    %eax,%edx
   145e3:	8b 45 08             	mov    0x8(%ebp),%eax
   145e6:	8b 40 04             	mov    0x4(%eax),%eax
   145e9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   145ec:	83 c1 01             	add    $0x1,%ecx
   145ef:	01 c8                	add    %ecx,%eax
   145f1:	0f b6 00             	movzbl (%eax),%eax
   145f4:	88 02                	mov    %al,(%edx)
   145f6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   145fa:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   145fe:	7e db                	jle    145db <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   14600:	83 ec 08             	sub    $0x8,%esp
   14603:	6a 41                	push   $0x41
   14605:	ff 75 08             	pushl  0x8(%ebp)
   14608:	e8 4c f6 ff ff       	call   13c59 <_Skip>
   1460d:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   14610:	8b 45 08             	mov    0x8(%ebp),%eax
   14613:	8b 40 0c             	mov    0xc(%eax),%eax
   14616:	83 f8 40             	cmp    $0x40,%eax
   14619:	0f 8f 39 ff ff ff    	jg     14558 <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   1461f:	8b 45 08             	mov    0x8(%ebp),%eax
   14622:	8b 40 0c             	mov    0xc(%eax),%eax
   14625:	85 c0                	test   %eax,%eax
   14627:	74 0d                	je     14636 <_DecodeDQT+0x105>
   14629:	8b 45 08             	mov    0x8(%ebp),%eax
   1462c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14632:	90                   	nop
   14633:	eb 01                	jmp    14636 <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   14635:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14636:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14639:	c9                   	leave  
   1463a:	c3                   	ret    

0001463b <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   1463b:	55                   	push   %ebp
   1463c:	89 e5                	mov    %esp,%ebp
   1463e:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   14641:	83 ec 0c             	sub    $0xc,%esp
   14644:	ff 75 08             	pushl  0x8(%ebp)
   14647:	e8 59 f6 ff ff       	call   13ca5 <_DecodeLength>
   1464c:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1464f:	8b 45 08             	mov    0x8(%ebp),%eax
   14652:	8b 00                	mov    (%eax),%eax
   14654:	85 c0                	test   %eax,%eax
   14656:	75 4a                	jne    146a2 <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   14658:	8b 45 08             	mov    0x8(%ebp),%eax
   1465b:	8b 40 0c             	mov    0xc(%eax),%eax
   1465e:	83 f8 01             	cmp    $0x1,%eax
   14661:	7f 0b                	jg     1466e <_DecodeDRI+0x33>
   14663:	8b 45 08             	mov    0x8(%ebp),%eax
   14666:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1466c:	eb 35                	jmp    146a3 <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   1466e:	8b 45 08             	mov    0x8(%ebp),%eax
   14671:	8b 40 04             	mov    0x4(%eax),%eax
   14674:	83 ec 0c             	sub    $0xc,%esp
   14677:	50                   	push   %eax
   14678:	e8 8b f6 ff ff       	call   13d08 <_Decode2Bytes>
   1467d:	83 c4 10             	add    $0x10,%esp
   14680:	89 c2                	mov    %eax,%edx
   14682:	8b 45 08             	mov    0x8(%ebp),%eax
   14685:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   1468b:	8b 45 08             	mov    0x8(%ebp),%eax
   1468e:	8b 40 0c             	mov    0xc(%eax),%eax
   14691:	83 ec 08             	sub    $0x8,%esp
   14694:	50                   	push   %eax
   14695:	ff 75 08             	pushl  0x8(%ebp)
   14698:	e8 bc f5 ff ff       	call   13c59 <_Skip>
   1469d:	83 c4 10             	add    $0x10,%esp
   146a0:	eb 01                	jmp    146a3 <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   146a2:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   146a3:	c9                   	leave  
   146a4:	c3                   	ret    

000146a5 <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   146a5:	55                   	push   %ebp
   146a6:	89 e5                	mov    %esp,%ebp
   146a8:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   146ab:	8b 45 08             	mov    0x8(%ebp),%eax
   146ae:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   146b4:	89 45 e0             	mov    %eax,-0x20(%ebp)
   146b7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   146be:	83 ec 0c             	sub    $0xc,%esp
   146c1:	ff 75 08             	pushl  0x8(%ebp)
   146c4:	e8 dc f5 ff ff       	call   13ca5 <_DecodeLength>
   146c9:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   146cc:	8b 45 08             	mov    0x8(%ebp),%eax
   146cf:	8b 00                	mov    (%eax),%eax
   146d1:	85 c0                	test   %eax,%eax
   146d3:	0f 85 c2 02 00 00    	jne    1499b <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   146d9:	8b 45 08             	mov    0x8(%ebp),%eax
   146dc:	8b 50 0c             	mov    0xc(%eax),%edx
   146df:	8b 45 08             	mov    0x8(%ebp),%eax
   146e2:	8b 40 28             	mov    0x28(%eax),%eax
   146e5:	83 c0 02             	add    $0x2,%eax
   146e8:	01 c0                	add    %eax,%eax
   146ea:	39 c2                	cmp    %eax,%edx
   146ec:	7c 16                	jl     14704 <_DecodeSOS+0x5f>
   146ee:	8b 45 08             	mov    0x8(%ebp),%eax
   146f1:	8b 40 04             	mov    0x4(%eax),%eax
   146f4:	0f b6 00             	movzbl (%eax),%eax
   146f7:	0f b6 d0             	movzbl %al,%edx
   146fa:	8b 45 08             	mov    0x8(%ebp),%eax
   146fd:	8b 40 28             	mov    0x28(%eax),%eax
   14700:	39 c2                	cmp    %eax,%edx
   14702:	74 0e                	je     14712 <_DecodeSOS+0x6d>
   14704:	8b 45 08             	mov    0x8(%ebp),%eax
   14707:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1470d:	e9 8d 02 00 00       	jmp    1499f <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   14712:	83 ec 08             	sub    $0x8,%esp
   14715:	6a 01                	push   $0x1
   14717:	ff 75 08             	pushl  0x8(%ebp)
   1471a:	e8 3a f5 ff ff       	call   13c59 <_Skip>
   1471f:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14722:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14729:	8b 45 08             	mov    0x8(%ebp),%eax
   1472c:	83 c0 2c             	add    $0x2c,%eax
   1472f:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14732:	e9 ba 00 00 00       	jmp    147f1 <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   14737:	8b 45 08             	mov    0x8(%ebp),%eax
   1473a:	8b 40 04             	mov    0x4(%eax),%eax
   1473d:	0f b6 00             	movzbl (%eax),%eax
   14740:	0f b6 d0             	movzbl %al,%edx
   14743:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14746:	8b 00                	mov    (%eax),%eax
   14748:	39 c2                	cmp    %eax,%edx
   1474a:	74 0e                	je     1475a <_DecodeSOS+0xb5>
   1474c:	8b 45 08             	mov    0x8(%ebp),%eax
   1474f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14755:	e9 45 02 00 00       	jmp    1499f <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   1475a:	8b 45 08             	mov    0x8(%ebp),%eax
   1475d:	8b 40 04             	mov    0x4(%eax),%eax
   14760:	83 c0 01             	add    $0x1,%eax
   14763:	0f b6 00             	movzbl (%eax),%eax
   14766:	0f b6 c0             	movzbl %al,%eax
   14769:	25 ec 00 00 00       	and    $0xec,%eax
   1476e:	85 c0                	test   %eax,%eax
   14770:	74 0e                	je     14780 <_DecodeSOS+0xdb>
   14772:	8b 45 08             	mov    0x8(%ebp),%eax
   14775:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1477b:	e9 1f 02 00 00       	jmp    1499f <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   14780:	8b 45 08             	mov    0x8(%ebp),%eax
   14783:	8b 40 04             	mov    0x4(%eax),%eax
   14786:	83 c0 01             	add    $0x1,%eax
   14789:	0f b6 00             	movzbl (%eax),%eax
   1478c:	0f b6 c0             	movzbl %al,%eax
   1478f:	83 e0 02             	and    $0x2,%eax
   14792:	85 c0                	test   %eax,%eax
   14794:	74 0e                	je     147a4 <_DecodeSOS+0xff>
   14796:	8b 45 08             	mov    0x8(%ebp),%eax
   14799:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1479f:	e9 fb 01 00 00       	jmp    1499f <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   147a4:	8b 45 08             	mov    0x8(%ebp),%eax
   147a7:	8b 40 04             	mov    0x4(%eax),%eax
   147aa:	83 c0 01             	add    $0x1,%eax
   147ad:	0f b6 00             	movzbl (%eax),%eax
   147b0:	c0 e8 04             	shr    $0x4,%al
   147b3:	0f b6 d0             	movzbl %al,%edx
   147b6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   147b9:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   147bc:	8b 45 08             	mov    0x8(%ebp),%eax
   147bf:	8b 40 04             	mov    0x4(%eax),%eax
   147c2:	83 c0 01             	add    $0x1,%eax
   147c5:	0f b6 00             	movzbl (%eax),%eax
   147c8:	0f b6 c0             	movzbl %al,%eax
   147cb:	83 e0 01             	and    $0x1,%eax
   147ce:	83 c8 02             	or     $0x2,%eax
   147d1:	89 c2                	mov    %eax,%edx
   147d3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   147d6:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   147d9:	83 ec 08             	sub    $0x8,%esp
   147dc:	6a 02                	push   $0x2
   147de:	ff 75 08             	pushl  0x8(%ebp)
   147e1:	e8 73 f4 ff ff       	call   13c59 <_Skip>
   147e6:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   147e9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   147ed:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   147f1:	8b 45 08             	mov    0x8(%ebp),%eax
   147f4:	8b 40 28             	mov    0x28(%eax),%eax
   147f7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   147fa:	0f 8f 37 ff ff ff    	jg     14737 <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   14800:	8b 45 08             	mov    0x8(%ebp),%eax
   14803:	8b 40 04             	mov    0x4(%eax),%eax
   14806:	0f b6 00             	movzbl (%eax),%eax
   14809:	84 c0                	test   %al,%al
   1480b:	75 10                	jne    1481d <_DecodeSOS+0x178>
   1480d:	8b 45 08             	mov    0x8(%ebp),%eax
   14810:	8b 40 04             	mov    0x4(%eax),%eax
   14813:	83 c0 01             	add    $0x1,%eax
   14816:	0f b6 00             	movzbl (%eax),%eax
   14819:	3c 3f                	cmp    $0x3f,%al
   1481b:	74 0e                	je     1482b <_DecodeSOS+0x186>
   1481d:	8b 45 08             	mov    0x8(%ebp),%eax
   14820:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14826:	e9 74 01 00 00       	jmp    1499f <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   1482b:	8b 45 08             	mov    0x8(%ebp),%eax
   1482e:	8b 40 04             	mov    0x4(%eax),%eax
   14831:	83 c0 02             	add    $0x2,%eax
   14834:	0f b6 00             	movzbl (%eax),%eax
   14837:	84 c0                	test   %al,%al
   14839:	74 0e                	je     14849 <_DecodeSOS+0x1a4>
   1483b:	8b 45 08             	mov    0x8(%ebp),%eax
   1483e:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14844:	e9 56 01 00 00       	jmp    1499f <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   14849:	8b 45 08             	mov    0x8(%ebp),%eax
   1484c:	8b 40 0c             	mov    0xc(%eax),%eax
   1484f:	83 ec 08             	sub    $0x8,%esp
   14852:	50                   	push   %eax
   14853:	ff 75 08             	pushl  0x8(%ebp)
   14856:	e8 fe f3 ff ff       	call   13c59 <_Skip>
   1485b:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   1485e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   14865:	e9 17 01 00 00       	jmp    14981 <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   1486a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14871:	e9 f8 00 00 00       	jmp    1496e <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14876:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1487d:	8b 45 08             	mov    0x8(%ebp),%eax
   14880:	83 c0 2c             	add    $0x2c,%eax
   14883:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14886:	e9 8d 00 00 00       	jmp    14918 <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   1488b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   14892:	eb 71                	jmp    14905 <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14894:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   1489b:	eb 59                	jmp    148f6 <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   1489d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   148a0:	8b 50 28             	mov    0x28(%eax),%edx
   148a3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   148a6:	8b 40 08             	mov    0x8(%eax),%eax
   148a9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   148ad:	89 c1                	mov    %eax,%ecx
   148af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   148b2:	01 c1                	add    %eax,%ecx
   148b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   148b7:	8b 40 14             	mov    0x14(%eax),%eax
   148ba:	0f af c8             	imul   %eax,%ecx
   148bd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   148c0:	8b 40 04             	mov    0x4(%eax),%eax
   148c3:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   148c7:	01 c1                	add    %eax,%ecx
   148c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   148cc:	01 c8                	add    %ecx,%eax
   148ce:	c1 e0 03             	shl    $0x3,%eax
   148d1:	01 d0                	add    %edx,%eax
   148d3:	50                   	push   %eax
   148d4:	ff 75 dc             	pushl  -0x24(%ebp)
   148d7:	ff 75 0c             	pushl  0xc(%ebp)
   148da:	ff 75 08             	pushl  0x8(%ebp)
   148dd:	e8 bf 00 00 00       	call   149a1 <_DecodeBlock>
   148e2:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   148e5:	8b 45 08             	mov    0x8(%ebp),%eax
   148e8:	8b 00                	mov    (%eax),%eax
   148ea:	85 c0                	test   %eax,%eax
   148ec:	0f 85 ac 00 00 00    	jne    1499e <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   148f2:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   148f6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   148f9:	8b 40 04             	mov    0x4(%eax),%eax
   148fc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   148ff:	7f 9c                	jg     1489d <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   14901:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   14905:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14908:	8b 40 08             	mov    0x8(%eax),%eax
   1490b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1490e:	7f 84                	jg     14894 <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14910:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14914:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14918:	8b 45 08             	mov    0x8(%ebp),%eax
   1491b:	8b 40 28             	mov    0x28(%eax),%eax
   1491e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14921:	0f 8f 64 ff ff ff    	jg     1488b <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   14927:	8b 45 08             	mov    0x8(%ebp),%eax
   1492a:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14930:	85 c0                	test   %eax,%eax
   14932:	74 36                	je     1496a <_DecodeSOS+0x2c5>
   14934:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   14938:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1493c:	75 2c                	jne    1496a <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   1493e:	83 ec 0c             	sub    $0xc,%esp
   14941:	ff 75 08             	pushl  0x8(%ebp)
   14944:	e8 9f 0a 00 00       	call   153e8 <_ByteAlign>
   14949:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   1494c:	83 ec 08             	sub    $0x8,%esp
   1494f:	6a 10                	push   $0x10
   14951:	ff 75 08             	pushl  0x8(%ebp)
   14954:	e8 ce 04 00 00       	call   14e27 <_GetBits>
   14959:	83 c4 10             	add    $0x10,%esp
   1495c:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   1495f:	8b 45 08             	mov    0x8(%ebp),%eax
   14962:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14968:	eb 35                	jmp    1499f <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   1496a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1496e:	8b 45 08             	mov    0x8(%ebp),%eax
   14971:	8b 40 18             	mov    0x18(%eax),%eax
   14974:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14977:	0f 8f f9 fe ff ff    	jg     14876 <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   1497d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   14981:	8b 45 08             	mov    0x8(%ebp),%eax
   14984:	8b 40 1c             	mov    0x1c(%eax),%eax
   14987:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1498a:	0f 8f da fe ff ff    	jg     1486a <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   14990:	8b 45 08             	mov    0x8(%ebp),%eax
   14993:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   14999:	eb 04                	jmp    1499f <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   1499b:	90                   	nop
   1499c:	eb 01                	jmp    1499f <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   1499e:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   1499f:	c9                   	leave  
   149a0:	c3                   	ret    

000149a1 <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   149a1:	55                   	push   %ebp
   149a2:	89 e5                	mov    %esp,%ebp
   149a4:	53                   	push   %ebx
   149a5:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   149a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   149af:	8b 45 08             	mov    0x8(%ebp),%eax
   149b2:	05 c0 01 08 00       	add    $0x801c0,%eax
   149b7:	83 ec 04             	sub    $0x4,%esp
   149ba:	68 00 01 00 00       	push   $0x100
   149bf:	6a 00                	push   $0x0
   149c1:	50                   	push   %eax
   149c2:	e8 04 b8 fe ff       	call   1cb <memset>
   149c7:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   149ca:	8b 45 10             	mov    0x10(%ebp),%eax
   149cd:	8b 40 20             	mov    0x20(%eax),%eax
   149d0:	c1 e0 11             	shl    $0x11,%eax
   149d3:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   149d9:	8b 45 08             	mov    0x8(%ebp),%eax
   149dc:	01 d0                	add    %edx,%eax
   149de:	83 c0 08             	add    $0x8,%eax
   149e1:	83 ec 04             	sub    $0x4,%esp
   149e4:	6a 00                	push   $0x0
   149e6:	50                   	push   %eax
   149e7:	ff 75 08             	pushl  0x8(%ebp)
   149ea:	e8 86 01 00 00       	call   14b75 <_GetVLC>
   149ef:	83 c4 10             	add    $0x10,%esp
   149f2:	89 c2                	mov    %eax,%edx
   149f4:	8b 45 10             	mov    0x10(%ebp),%eax
   149f7:	8b 40 24             	mov    0x24(%eax),%eax
   149fa:	01 c2                	add    %eax,%edx
   149fc:	8b 45 10             	mov    0x10(%ebp),%eax
   149ff:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   14a02:	8b 45 10             	mov    0x10(%ebp),%eax
   14a05:	8b 50 24             	mov    0x24(%eax),%edx
   14a08:	8b 45 10             	mov    0x10(%ebp),%eax
   14a0b:	8b 48 18             	mov    0x18(%eax),%ecx
   14a0e:	8b 45 08             	mov    0x8(%ebp),%eax
   14a11:	c1 e1 06             	shl    $0x6,%ecx
   14a14:	01 c8                	add    %ecx,%eax
   14a16:	05 b8 00 00 00       	add    $0xb8,%eax
   14a1b:	0f b6 00             	movzbl (%eax),%eax
   14a1e:	0f b6 c0             	movzbl %al,%eax
   14a21:	0f af d0             	imul   %eax,%edx
   14a24:	8b 45 08             	mov    0x8(%ebp),%eax
   14a27:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   14a2d:	8b 45 10             	mov    0x10(%ebp),%eax
   14a30:	8b 40 1c             	mov    0x1c(%eax),%eax
   14a33:	c1 e0 11             	shl    $0x11,%eax
   14a36:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14a3c:	8b 45 08             	mov    0x8(%ebp),%eax
   14a3f:	01 d0                	add    %edx,%eax
   14a41:	8d 50 08             	lea    0x8(%eax),%edx
   14a44:	83 ec 04             	sub    $0x4,%esp
   14a47:	8d 45 ef             	lea    -0x11(%ebp),%eax
   14a4a:	50                   	push   %eax
   14a4b:	52                   	push   %edx
   14a4c:	ff 75 08             	pushl  0x8(%ebp)
   14a4f:	e8 21 01 00 00       	call   14b75 <_GetVLC>
   14a54:	83 c4 10             	add    $0x10,%esp
   14a57:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   14a5a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14a5e:	84 c0                	test   %al,%al
   14a60:	0f 84 92 00 00 00    	je     14af8 <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   14a66:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14a6a:	0f b6 c0             	movzbl %al,%eax
   14a6d:	83 e0 0f             	and    $0xf,%eax
   14a70:	85 c0                	test   %eax,%eax
   14a72:	75 16                	jne    14a8a <_DecodeBlock+0xe9>
   14a74:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14a78:	3c f0                	cmp    $0xf0,%al
   14a7a:	74 0e                	je     14a8a <_DecodeBlock+0xe9>
   14a7c:	8b 45 08             	mov    0x8(%ebp),%eax
   14a7f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a85:	e9 e6 00 00 00       	jmp    14b70 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   14a8a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14a8e:	c0 e8 04             	shr    $0x4,%al
   14a91:	0f b6 c0             	movzbl %al,%eax
   14a94:	83 c0 01             	add    $0x1,%eax
   14a97:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   14a9a:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14a9e:	7e 0e                	jle    14aae <_DecodeBlock+0x10d>
   14aa0:	8b 45 08             	mov    0x8(%ebp),%eax
   14aa3:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14aa9:	e9 c2 00 00 00       	jmp    14b70 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   14aae:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14ab1:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ab4:	01 d0                	add    %edx,%eax
   14ab6:	0f b6 00             	movzbl (%eax),%eax
   14ab9:	0f be c8             	movsbl %al,%ecx
   14abc:	8b 45 10             	mov    0x10(%ebp),%eax
   14abf:	8b 50 18             	mov    0x18(%eax),%edx
   14ac2:	8b 45 08             	mov    0x8(%ebp),%eax
   14ac5:	c1 e2 06             	shl    $0x6,%edx
   14ac8:	01 c2                	add    %eax,%edx
   14aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14acd:	01 d0                	add    %edx,%eax
   14acf:	05 b8 00 00 00       	add    $0xb8,%eax
   14ad4:	0f b6 00             	movzbl (%eax),%eax
   14ad7:	0f b6 c0             	movzbl %al,%eax
   14ada:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14ade:	89 c2                	mov    %eax,%edx
   14ae0:	8b 45 08             	mov    0x8(%ebp),%eax
   14ae3:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   14ae9:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   14aec:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   14af0:	0f 8e 37 ff ff ff    	jle    14a2d <_DecodeBlock+0x8c>
   14af6:	eb 01                	jmp    14af9 <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   14af8:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   14af9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14b00:	eb 24                	jmp    14b26 <_DecodeBlock+0x185>
   14b02:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b05:	05 70 00 02 00       	add    $0x20070,%eax
   14b0a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14b11:	8b 45 08             	mov    0x8(%ebp),%eax
   14b14:	01 d0                	add    %edx,%eax
   14b16:	83 ec 0c             	sub    $0xc,%esp
   14b19:	50                   	push   %eax
   14b1a:	e8 32 03 00 00       	call   14e51 <_RowIDCT>
   14b1f:	83 c4 10             	add    $0x10,%esp
   14b22:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   14b26:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14b2a:	7e d6                	jle    14b02 <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   14b2c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14b33:	eb 35                	jmp    14b6a <_DecodeBlock+0x1c9>
   14b35:	8b 45 10             	mov    0x10(%ebp),%eax
   14b38:	8b 40 14             	mov    0x14(%eax),%eax
   14b3b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14b3e:	8b 55 14             	mov    0x14(%ebp),%edx
   14b41:	01 d1                	add    %edx,%ecx
   14b43:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14b46:	81 c2 70 00 02 00    	add    $0x20070,%edx
   14b4c:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   14b53:	8b 55 08             	mov    0x8(%ebp),%edx
   14b56:	01 da                	add    %ebx,%edx
   14b58:	83 ec 04             	sub    $0x4,%esp
   14b5b:	50                   	push   %eax
   14b5c:	51                   	push   %ecx
   14b5d:	52                   	push   %edx
   14b5e:	e8 7b 05 00 00       	call   150de <_ColIDCT>
   14b63:	83 c4 10             	add    $0x10,%esp
   14b66:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14b6a:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14b6e:	7e c5                	jle    14b35 <_DecodeBlock+0x194>
}
   14b70:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14b73:	c9                   	leave  
   14b74:	c3                   	ret    

00014b75 <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   14b75:	55                   	push   %ebp
   14b76:	89 e5                	mov    %esp,%ebp
   14b78:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   14b7b:	83 ec 08             	sub    $0x8,%esp
   14b7e:	6a 10                	push   $0x10
   14b80:	ff 75 08             	pushl  0x8(%ebp)
   14b83:	e8 c2 00 00 00       	call   14c4a <_ShowBits>
   14b88:	83 c4 10             	add    $0x10,%esp
   14b8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   14b8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b91:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14b94:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b97:	01 d0                	add    %edx,%eax
   14b99:	0f b6 00             	movzbl (%eax),%eax
   14b9c:	0f b6 c0             	movzbl %al,%eax
   14b9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   14ba2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14ba6:	75 13                	jne    14bbb <_GetVLC+0x46>
   14ba8:	8b 45 08             	mov    0x8(%ebp),%eax
   14bab:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14bb1:	b8 00 00 00 00       	mov    $0x0,%eax
   14bb6:	e9 8d 00 00 00       	jmp    14c48 <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   14bbb:	83 ec 08             	sub    $0x8,%esp
   14bbe:	ff 75 f0             	pushl  -0x10(%ebp)
   14bc1:	ff 75 08             	pushl  0x8(%ebp)
   14bc4:	e8 25 02 00 00       	call   14dee <_SkipBits>
   14bc9:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   14bcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14bcf:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14bd2:	8b 45 0c             	mov    0xc(%ebp),%eax
   14bd5:	01 d0                	add    %edx,%eax
   14bd7:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   14bdb:	0f b6 c0             	movzbl %al,%eax
   14bde:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   14be1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14be5:	74 0a                	je     14bf1 <_GetVLC+0x7c>
   14be7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14bea:	89 c2                	mov    %eax,%edx
   14bec:	8b 45 10             	mov    0x10(%ebp),%eax
   14bef:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   14bf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14bf4:	83 e0 0f             	and    $0xf,%eax
   14bf7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   14bfa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14bfe:	75 07                	jne    14c07 <_GetVLC+0x92>
   14c00:	b8 00 00 00 00       	mov    $0x0,%eax
   14c05:	eb 41                	jmp    14c48 <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   14c07:	83 ec 08             	sub    $0x8,%esp
   14c0a:	ff 75 f0             	pushl  -0x10(%ebp)
   14c0d:	ff 75 08             	pushl  0x8(%ebp)
   14c10:	e8 12 02 00 00       	call   14e27 <_GetBits>
   14c15:	83 c4 10             	add    $0x10,%esp
   14c18:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   14c1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c1e:	83 e8 01             	sub    $0x1,%eax
   14c21:	ba 01 00 00 00       	mov    $0x1,%edx
   14c26:	89 c1                	mov    %eax,%ecx
   14c28:	d3 e2                	shl    %cl,%edx
   14c2a:	89 d0                	mov    %edx,%eax
   14c2c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14c2f:	7e 14                	jle    14c45 <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   14c31:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c34:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   14c39:	89 c1                	mov    %eax,%ecx
   14c3b:	d3 e2                	shl    %cl,%edx
   14c3d:	89 d0                	mov    %edx,%eax
   14c3f:	83 c0 01             	add    $0x1,%eax
   14c42:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   14c45:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14c48:	c9                   	leave  
   14c49:	c3                   	ret    

00014c4a <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   14c4a:	55                   	push   %ebp
   14c4b:	89 e5                	mov    %esp,%ebp
   14c4d:	53                   	push   %ebx
   14c4e:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   14c51:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14c55:	0f 85 4f 01 00 00    	jne    14daa <_ShowBits+0x160>
   14c5b:	b8 00 00 00 00       	mov    $0x0,%eax
   14c60:	e9 83 01 00 00       	jmp    14de8 <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   14c65:	8b 45 08             	mov    0x8(%ebp),%eax
   14c68:	8b 40 08             	mov    0x8(%eax),%eax
   14c6b:	85 c0                	test   %eax,%eax
   14c6d:	7f 33                	jg     14ca2 <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   14c6f:	8b 45 08             	mov    0x8(%ebp),%eax
   14c72:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14c78:	c1 e0 08             	shl    $0x8,%eax
   14c7b:	0c ff                	or     $0xff,%al
   14c7d:	89 c2                	mov    %eax,%edx
   14c7f:	8b 45 08             	mov    0x8(%ebp),%eax
   14c82:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   14c88:	8b 45 08             	mov    0x8(%ebp),%eax
   14c8b:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14c91:	8d 50 08             	lea    0x8(%eax),%edx
   14c94:	8b 45 08             	mov    0x8(%ebp),%eax
   14c97:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   14c9d:	e9 08 01 00 00       	jmp    14daa <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   14ca2:	8b 45 08             	mov    0x8(%ebp),%eax
   14ca5:	8b 40 04             	mov    0x4(%eax),%eax
   14ca8:	8d 48 01             	lea    0x1(%eax),%ecx
   14cab:	8b 55 08             	mov    0x8(%ebp),%edx
   14cae:	89 4a 04             	mov    %ecx,0x4(%edx)
   14cb1:	0f b6 00             	movzbl (%eax),%eax
   14cb4:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   14cb7:	8b 45 08             	mov    0x8(%ebp),%eax
   14cba:	8b 40 08             	mov    0x8(%eax),%eax
   14cbd:	8d 50 ff             	lea    -0x1(%eax),%edx
   14cc0:	8b 45 08             	mov    0x8(%ebp),%eax
   14cc3:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   14cc6:	8b 45 08             	mov    0x8(%ebp),%eax
   14cc9:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14ccf:	8d 50 08             	lea    0x8(%eax),%edx
   14cd2:	8b 45 08             	mov    0x8(%ebp),%eax
   14cd5:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   14cdb:	8b 45 08             	mov    0x8(%ebp),%eax
   14cde:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14ce4:	c1 e0 08             	shl    $0x8,%eax
   14ce7:	89 c2                	mov    %eax,%edx
   14ce9:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   14ced:	09 c2                	or     %eax,%edx
   14cef:	8b 45 08             	mov    0x8(%ebp),%eax
   14cf2:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   14cf8:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   14cfc:	0f 85 a8 00 00 00    	jne    14daa <_ShowBits+0x160>
            if(ctx->size){
   14d02:	8b 45 08             	mov    0x8(%ebp),%eax
   14d05:	8b 40 08             	mov    0x8(%eax),%eax
   14d08:	85 c0                	test   %eax,%eax
   14d0a:	0f 84 91 00 00 00    	je     14da1 <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   14d10:	8b 45 08             	mov    0x8(%ebp),%eax
   14d13:	8b 40 04             	mov    0x4(%eax),%eax
   14d16:	8d 48 01             	lea    0x1(%eax),%ecx
   14d19:	8b 55 08             	mov    0x8(%ebp),%edx
   14d1c:	89 4a 04             	mov    %ecx,0x4(%edx)
   14d1f:	0f b6 00             	movzbl (%eax),%eax
   14d22:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   14d25:	8b 45 08             	mov    0x8(%ebp),%eax
   14d28:	8b 40 08             	mov    0x8(%eax),%eax
   14d2b:	8d 50 ff             	lea    -0x1(%eax),%edx
   14d2e:	8b 45 08             	mov    0x8(%ebp),%eax
   14d31:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   14d34:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14d38:	85 c0                	test   %eax,%eax
   14d3a:	74 62                	je     14d9e <_ShowBits+0x154>
   14d3c:	3d d9 00 00 00       	cmp    $0xd9,%eax
   14d41:	75 0c                	jne    14d4f <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   14d43:	8b 45 08             	mov    0x8(%ebp),%eax
   14d46:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   14d4d:	eb 5b                	jmp    14daa <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   14d4f:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14d53:	25 f8 00 00 00       	and    $0xf8,%eax
   14d58:	3d d0 00 00 00       	cmp    $0xd0,%eax
   14d5d:	74 0b                	je     14d6a <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   14d5f:	8b 45 08             	mov    0x8(%ebp),%eax
   14d62:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14d68:	eb 40                	jmp    14daa <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   14d6a:	8b 45 08             	mov    0x8(%ebp),%eax
   14d6d:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14d73:	c1 e0 08             	shl    $0x8,%eax
   14d76:	89 c2                	mov    %eax,%edx
   14d78:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14d7c:	09 c2                	or     %eax,%edx
   14d7e:	8b 45 08             	mov    0x8(%ebp),%eax
   14d81:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   14d87:	8b 45 08             	mov    0x8(%ebp),%eax
   14d8a:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d90:	8d 50 08             	lea    0x8(%eax),%edx
   14d93:	8b 45 08             	mov    0x8(%ebp),%eax
   14d96:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   14d9c:	eb 0c                	jmp    14daa <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   14d9e:	90                   	nop
   14d9f:	eb 09                	jmp    14daa <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   14da1:	8b 45 08             	mov    0x8(%ebp),%eax
   14da4:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   14daa:	8b 45 08             	mov    0x8(%ebp),%eax
   14dad:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14db3:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14db6:	0f 8c a9 fe ff ff    	jl     14c65 <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   14dbc:	8b 45 08             	mov    0x8(%ebp),%eax
   14dbf:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   14dc5:	8b 45 08             	mov    0x8(%ebp),%eax
   14dc8:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14dce:	2b 45 0c             	sub    0xc(%ebp),%eax
   14dd1:	89 c1                	mov    %eax,%ecx
   14dd3:	d3 fa                	sar    %cl,%edx
   14dd5:	8b 45 0c             	mov    0xc(%ebp),%eax
   14dd8:	bb 01 00 00 00       	mov    $0x1,%ebx
   14ddd:	89 c1                	mov    %eax,%ecx
   14ddf:	d3 e3                	shl    %cl,%ebx
   14de1:	89 d8                	mov    %ebx,%eax
   14de3:	83 e8 01             	sub    $0x1,%eax
   14de6:	21 d0                	and    %edx,%eax
}
   14de8:	83 c4 10             	add    $0x10,%esp
   14deb:	5b                   	pop    %ebx
   14dec:	5d                   	pop    %ebp
   14ded:	c3                   	ret    

00014dee <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   14dee:	55                   	push   %ebp
   14def:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   14df1:	8b 45 08             	mov    0x8(%ebp),%eax
   14df4:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14dfa:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14dfd:	7d 0e                	jge    14e0d <_SkipBits+0x1f>
   14dff:	ff 75 0c             	pushl  0xc(%ebp)
   14e02:	ff 75 08             	pushl  0x8(%ebp)
   14e05:	e8 40 fe ff ff       	call   14c4a <_ShowBits>
   14e0a:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   14e0d:	8b 45 08             	mov    0x8(%ebp),%eax
   14e10:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14e16:	2b 45 0c             	sub    0xc(%ebp),%eax
   14e19:	89 c2                	mov    %eax,%edx
   14e1b:	8b 45 08             	mov    0x8(%ebp),%eax
   14e1e:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   14e24:	90                   	nop
   14e25:	c9                   	leave  
   14e26:	c3                   	ret    

00014e27 <_GetBits>:

int _GetBits(Context* ctx, int bits){
   14e27:	55                   	push   %ebp
   14e28:	89 e5                	mov    %esp,%ebp
   14e2a:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   14e2d:	ff 75 0c             	pushl  0xc(%ebp)
   14e30:	ff 75 08             	pushl  0x8(%ebp)
   14e33:	e8 12 fe ff ff       	call   14c4a <_ShowBits>
   14e38:	83 c4 08             	add    $0x8,%esp
   14e3b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   14e3e:	ff 75 0c             	pushl  0xc(%ebp)
   14e41:	ff 75 08             	pushl  0x8(%ebp)
   14e44:	e8 a5 ff ff ff       	call   14dee <_SkipBits>
   14e49:	83 c4 08             	add    $0x8,%esp
    return res;
   14e4c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   14e4f:	c9                   	leave  
   14e50:	c3                   	ret    

00014e51 <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   14e51:	55                   	push   %ebp
   14e52:	89 e5                	mov    %esp,%ebp
   14e54:	57                   	push   %edi
   14e55:	56                   	push   %esi
   14e56:	53                   	push   %ebx
   14e57:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14e5a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e5d:	83 c0 10             	add    $0x10,%eax
   14e60:	8b 00                	mov    (%eax),%eax
   14e62:	c1 e0 0b             	shl    $0xb,%eax
   14e65:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   14e68:	8b 45 08             	mov    0x8(%ebp),%eax
   14e6b:	8b 40 18             	mov    0x18(%eax),%eax
   14e6e:	89 45 ec             	mov    %eax,-0x14(%ebp)
   14e71:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14e74:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   14e77:	8b 55 08             	mov    0x8(%ebp),%edx
   14e7a:	8b 52 08             	mov    0x8(%edx),%edx
   14e7d:	89 55 e8             	mov    %edx,-0x18(%ebp)
   14e80:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   14e83:	8b 55 08             	mov    0x8(%ebp),%edx
   14e86:	8b 52 04             	mov    0x4(%edx),%edx
   14e89:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   14e8c:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   14e8f:	8b 55 08             	mov    0x8(%ebp),%edx
   14e92:	8b 52 1c             	mov    0x1c(%edx),%edx
   14e95:	89 55 e0             	mov    %edx,-0x20(%ebp)
   14e98:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   14e9b:	8b 55 08             	mov    0x8(%ebp),%edx
   14e9e:	8b 52 14             	mov    0x14(%edx),%edx
   14ea1:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14ea4:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   14ea7:	8b 55 08             	mov    0x8(%ebp),%edx
   14eaa:	8b 52 0c             	mov    0xc(%edx),%edx
   14ead:	89 55 d8             	mov    %edx,-0x28(%ebp)
   14eb0:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14eb3:	85 c0                	test   %eax,%eax
   14eb5:	75 68                	jne    14f1f <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   14eb7:	8b 45 08             	mov    0x8(%ebp),%eax
   14eba:	8d 48 04             	lea    0x4(%eax),%ecx
   14ebd:	8b 45 08             	mov    0x8(%ebp),%eax
   14ec0:	8d 58 08             	lea    0x8(%eax),%ebx
   14ec3:	8b 45 08             	mov    0x8(%ebp),%eax
   14ec6:	8d 70 0c             	lea    0xc(%eax),%esi
   14ec9:	8b 45 08             	mov    0x8(%ebp),%eax
   14ecc:	8d 78 10             	lea    0x10(%eax),%edi
   14ecf:	8b 45 08             	mov    0x8(%ebp),%eax
   14ed2:	83 c0 14             	add    $0x14,%eax
   14ed5:	89 45 c0             	mov    %eax,-0x40(%ebp)
   14ed8:	8b 45 08             	mov    0x8(%ebp),%eax
   14edb:	83 c0 18             	add    $0x18,%eax
   14ede:	89 45 bc             	mov    %eax,-0x44(%ebp)
   14ee1:	8b 45 08             	mov    0x8(%ebp),%eax
   14ee4:	8d 50 1c             	lea    0x1c(%eax),%edx
   14ee7:	8b 45 08             	mov    0x8(%ebp),%eax
   14eea:	8b 00                	mov    (%eax),%eax
   14eec:	c1 e0 03             	shl    $0x3,%eax
   14eef:	89 02                	mov    %eax,(%edx)
   14ef1:	8b 02                	mov    (%edx),%eax
   14ef3:	8b 55 bc             	mov    -0x44(%ebp),%edx
   14ef6:	89 02                	mov    %eax,(%edx)
   14ef8:	89 d0                	mov    %edx,%eax
   14efa:	8b 00                	mov    (%eax),%eax
   14efc:	8b 55 c0             	mov    -0x40(%ebp),%edx
   14eff:	89 02                	mov    %eax,(%edx)
   14f01:	89 d0                	mov    %edx,%eax
   14f03:	8b 00                	mov    (%eax),%eax
   14f05:	89 07                	mov    %eax,(%edi)
   14f07:	8b 07                	mov    (%edi),%eax
   14f09:	89 06                	mov    %eax,(%esi)
   14f0b:	8b 06                	mov    (%esi),%eax
   14f0d:	89 03                	mov    %eax,(%ebx)
   14f0f:	8b 03                	mov    (%ebx),%eax
   14f11:	89 01                	mov    %eax,(%ecx)
   14f13:	8b 11                	mov    (%ecx),%edx
   14f15:	8b 45 08             	mov    0x8(%ebp),%eax
   14f18:	89 10                	mov    %edx,(%eax)
        return;
   14f1a:	e9 b7 01 00 00       	jmp    150d6 <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   14f1f:	8b 45 08             	mov    0x8(%ebp),%eax
   14f22:	8b 00                	mov    (%eax),%eax
   14f24:	c1 e0 0b             	shl    $0xb,%eax
   14f27:	83 e8 80             	sub    $0xffffff80,%eax
   14f2a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   14f2d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14f30:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14f33:	01 d0                	add    %edx,%eax
   14f35:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   14f3b:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   14f3e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14f41:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   14f47:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14f4a:	01 d0                	add    %edx,%eax
   14f4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   14f4f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14f52:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   14f58:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14f5b:	01 d0                	add    %edx,%eax
   14f5d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   14f60:	8b 55 dc             	mov    -0x24(%ebp),%edx
   14f63:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f66:	01 d0                	add    %edx,%eax
   14f68:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   14f6e:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   14f71:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f74:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   14f7a:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14f7d:	01 d0                	add    %edx,%eax
   14f7f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   14f82:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f85:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   14f8b:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14f8e:	01 d0                	add    %edx,%eax
   14f90:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   14f93:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14f96:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f99:	01 d0                	add    %edx,%eax
   14f9b:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   14f9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14fa1:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   14fa4:	8b 55 e8             	mov    -0x18(%ebp),%edx
   14fa7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14faa:	01 d0                	add    %edx,%eax
   14fac:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14fb2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   14fb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14fb8:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   14fbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14fc1:	01 d0                	add    %edx,%eax
   14fc3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   14fc6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14fc9:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   14fcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14fd2:	01 d0                	add    %edx,%eax
   14fd4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   14fd7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14fda:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14fdd:	01 d0                	add    %edx,%eax
   14fdf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   14fe2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14fe5:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   14fe8:	8b 55 e0             	mov    -0x20(%ebp),%edx
   14feb:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14fee:	01 d0                	add    %edx,%eax
   14ff0:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   14ff3:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14ff6:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   14ff9:	8b 55 d0             	mov    -0x30(%ebp),%edx
   14ffc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14fff:	01 d0                	add    %edx,%eax
   15001:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   15004:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15007:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   1500a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   1500d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15010:	01 d0                	add    %edx,%eax
   15012:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   15015:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15018:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   1501b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1501e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15021:	01 d0                	add    %edx,%eax
   15023:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15029:	83 e8 80             	sub    $0xffffff80,%eax
   1502c:	c1 f8 08             	sar    $0x8,%eax
   1502f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   15032:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15035:	2b 45 e0             	sub    -0x20(%ebp),%eax
   15038:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1503e:	83 e8 80             	sub    $0xffffff80,%eax
   15041:	c1 f8 08             	sar    $0x8,%eax
   15044:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   15047:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1504a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1504d:	01 d0                	add    %edx,%eax
   1504f:	c1 f8 08             	sar    $0x8,%eax
   15052:	89 c2                	mov    %eax,%edx
   15054:	8b 45 08             	mov    0x8(%ebp),%eax
   15057:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   15059:	8b 45 08             	mov    0x8(%ebp),%eax
   1505c:	83 c0 04             	add    $0x4,%eax
   1505f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   15062:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15065:	01 ca                	add    %ecx,%edx
   15067:	c1 fa 08             	sar    $0x8,%edx
   1506a:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   1506c:	8b 45 08             	mov    0x8(%ebp),%eax
   1506f:	83 c0 08             	add    $0x8,%eax
   15072:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   15075:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15078:	01 ca                	add    %ecx,%edx
   1507a:	c1 fa 08             	sar    $0x8,%edx
   1507d:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   1507f:	8b 45 08             	mov    0x8(%ebp),%eax
   15082:	83 c0 0c             	add    $0xc,%eax
   15085:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   15088:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1508b:	01 ca                	add    %ecx,%edx
   1508d:	c1 fa 08             	sar    $0x8,%edx
   15090:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   15092:	8b 45 08             	mov    0x8(%ebp),%eax
   15095:	8d 50 10             	lea    0x10(%eax),%edx
   15098:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1509b:	2b 45 dc             	sub    -0x24(%ebp),%eax
   1509e:	c1 f8 08             	sar    $0x8,%eax
   150a1:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   150a3:	8b 45 08             	mov    0x8(%ebp),%eax
   150a6:	8d 50 14             	lea    0x14(%eax),%edx
   150a9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   150ac:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   150af:	c1 f8 08             	sar    $0x8,%eax
   150b2:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   150b4:	8b 45 08             	mov    0x8(%ebp),%eax
   150b7:	8d 50 18             	lea    0x18(%eax),%edx
   150ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
   150bd:	2b 45 ec             	sub    -0x14(%ebp),%eax
   150c0:	c1 f8 08             	sar    $0x8,%eax
   150c3:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   150c5:	8b 45 08             	mov    0x8(%ebp),%eax
   150c8:	8d 50 1c             	lea    0x1c(%eax),%edx
   150cb:	8b 45 d8             	mov    -0x28(%ebp),%eax
   150ce:	2b 45 f0             	sub    -0x10(%ebp),%eax
   150d1:	c1 f8 08             	sar    $0x8,%eax
   150d4:	89 02                	mov    %eax,(%edx)
}
   150d6:	83 c4 38             	add    $0x38,%esp
   150d9:	5b                   	pop    %ebx
   150da:	5e                   	pop    %esi
   150db:	5f                   	pop    %edi
   150dc:	5d                   	pop    %ebp
   150dd:	c3                   	ret    

000150de <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   150de:	55                   	push   %ebp
   150df:	89 e5                	mov    %esp,%ebp
   150e1:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   150e4:	8b 45 08             	mov    0x8(%ebp),%eax
   150e7:	83 e8 80             	sub    $0xffffff80,%eax
   150ea:	8b 00                	mov    (%eax),%eax
   150ec:	c1 e0 08             	shl    $0x8,%eax
   150ef:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   150f2:	8b 45 08             	mov    0x8(%ebp),%eax
   150f5:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   150fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
   150fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15101:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   15104:	8b 55 08             	mov    0x8(%ebp),%edx
   15107:	8b 52 40             	mov    0x40(%edx),%edx
   1510a:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1510d:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   15110:	8b 55 08             	mov    0x8(%ebp),%edx
   15113:	8b 52 20             	mov    0x20(%edx),%edx
   15116:	89 55 ec             	mov    %edx,-0x14(%ebp)
   15119:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   1511c:	8b 55 08             	mov    0x8(%ebp),%edx
   1511f:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   15125:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15128:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   1512b:	8b 55 08             	mov    0x8(%ebp),%edx
   1512e:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   15134:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   15137:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   1513a:	8b 55 08             	mov    0x8(%ebp),%edx
   1513d:	8b 52 60             	mov    0x60(%edx),%edx
   15140:	89 55 e0             	mov    %edx,-0x20(%ebp)
   15143:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   15146:	85 c0                	test   %eax,%eax
   15148:	75 45                	jne    1518f <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   1514a:	8b 45 08             	mov    0x8(%ebp),%eax
   1514d:	8b 00                	mov    (%eax),%eax
   1514f:	83 c0 20             	add    $0x20,%eax
   15152:	c1 f8 06             	sar    $0x6,%eax
   15155:	83 e8 80             	sub    $0xffffff80,%eax
   15158:	50                   	push   %eax
   15159:	e8 d6 ea ff ff       	call   13c34 <_Clip>
   1515e:	83 c4 04             	add    $0x4,%esp
   15161:	0f b6 c0             	movzbl %al,%eax
   15164:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   15167:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   1516e:	eb 14                	jmp    15184 <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   15170:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15173:	89 c2                	mov    %eax,%edx
   15175:	8b 45 0c             	mov    0xc(%ebp),%eax
   15178:	88 10                	mov    %dl,(%eax)
            out += stride;
   1517a:	8b 45 10             	mov    0x10(%ebp),%eax
   1517d:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   15180:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   15184:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   15188:	75 e6                	jne    15170 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   1518a:	e9 57 02 00 00       	jmp    153e6 <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   1518f:	8b 45 08             	mov    0x8(%ebp),%eax
   15192:	8b 00                	mov    (%eax),%eax
   15194:	c1 e0 08             	shl    $0x8,%eax
   15197:	05 00 20 00 00       	add    $0x2000,%eax
   1519c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   1519f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   151a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   151a5:	01 d0                	add    %edx,%eax
   151a7:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   151ad:	83 c0 04             	add    $0x4,%eax
   151b0:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   151b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   151b6:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   151bc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   151bf:	01 d0                	add    %edx,%eax
   151c1:	c1 f8 03             	sar    $0x3,%eax
   151c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   151c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   151ca:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   151d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   151d3:	01 d0                	add    %edx,%eax
   151d5:	c1 f8 03             	sar    $0x3,%eax
   151d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   151db:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   151de:	8b 45 e0             	mov    -0x20(%ebp),%eax
   151e1:	01 d0                	add    %edx,%eax
   151e3:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   151e9:	83 c0 04             	add    $0x4,%eax
   151ec:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   151ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   151f2:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   151f8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   151fb:	01 d0                	add    %edx,%eax
   151fd:	c1 f8 03             	sar    $0x3,%eax
   15200:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   15203:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15206:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   1520c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1520f:	01 d0                	add    %edx,%eax
   15211:	c1 f8 03             	sar    $0x3,%eax
   15214:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   15217:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1521a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1521d:	01 d0                	add    %edx,%eax
   1521f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   15222:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15225:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   15228:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1522b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1522e:	01 d0                	add    %edx,%eax
   15230:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   15236:	83 c0 04             	add    $0x4,%eax
   15239:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   1523c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1523f:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   15245:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15248:	01 d0                	add    %edx,%eax
   1524a:	c1 f8 03             	sar    $0x3,%eax
   1524d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   15250:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15253:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   15259:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1525c:	01 d0                	add    %edx,%eax
   1525e:	c1 f8 03             	sar    $0x3,%eax
   15261:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   15264:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15267:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1526a:	01 d0                	add    %edx,%eax
   1526c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   1526f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15272:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   15275:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15278:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1527b:	01 d0                	add    %edx,%eax
   1527d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   15280:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15283:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   15286:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15289:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1528c:	01 d0                	add    %edx,%eax
   1528e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   15291:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15294:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   15297:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1529a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1529d:	01 d0                	add    %edx,%eax
   1529f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   152a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   152a5:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   152a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
   152ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
   152ae:	01 d0                	add    %edx,%eax
   152b0:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   152b6:	83 e8 80             	sub    $0xffffff80,%eax
   152b9:	c1 f8 08             	sar    $0x8,%eax
   152bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   152bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
   152c2:	2b 45 e8             	sub    -0x18(%ebp),%eax
   152c5:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   152cb:	83 e8 80             	sub    $0xffffff80,%eax
   152ce:	c1 f8 08             	sar    $0x8,%eax
   152d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   152d4:	8b 55 e0             	mov    -0x20(%ebp),%edx
   152d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   152da:	01 d0                	add    %edx,%eax
   152dc:	c1 f8 0e             	sar    $0xe,%eax
   152df:	83 e8 80             	sub    $0xffffff80,%eax
   152e2:	50                   	push   %eax
   152e3:	e8 4c e9 ff ff       	call   13c34 <_Clip>
   152e8:	83 c4 04             	add    $0x4,%esp
   152eb:	89 c2                	mov    %eax,%edx
   152ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   152f0:	88 10                	mov    %dl,(%eax)
   152f2:	8b 45 10             	mov    0x10(%ebp),%eax
   152f5:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   152f8:	8b 55 f0             	mov    -0x10(%ebp),%edx
   152fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   152fe:	01 d0                	add    %edx,%eax
   15300:	c1 f8 0e             	sar    $0xe,%eax
   15303:	83 e8 80             	sub    $0xffffff80,%eax
   15306:	50                   	push   %eax
   15307:	e8 28 e9 ff ff       	call   13c34 <_Clip>
   1530c:	83 c4 04             	add    $0x4,%esp
   1530f:	89 c2                	mov    %eax,%edx
   15311:	8b 45 0c             	mov    0xc(%ebp),%eax
   15314:	88 10                	mov    %dl,(%eax)
   15316:	8b 45 10             	mov    0x10(%ebp),%eax
   15319:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   1531c:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1531f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15322:	01 d0                	add    %edx,%eax
   15324:	c1 f8 0e             	sar    $0xe,%eax
   15327:	83 e8 80             	sub    $0xffffff80,%eax
   1532a:	50                   	push   %eax
   1532b:	e8 04 e9 ff ff       	call   13c34 <_Clip>
   15330:	83 c4 04             	add    $0x4,%esp
   15333:	89 c2                	mov    %eax,%edx
   15335:	8b 45 0c             	mov    0xc(%ebp),%eax
   15338:	88 10                	mov    %dl,(%eax)
   1533a:	8b 45 10             	mov    0x10(%ebp),%eax
   1533d:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   15340:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15343:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15346:	01 d0                	add    %edx,%eax
   15348:	c1 f8 0e             	sar    $0xe,%eax
   1534b:	83 e8 80             	sub    $0xffffff80,%eax
   1534e:	50                   	push   %eax
   1534f:	e8 e0 e8 ff ff       	call   13c34 <_Clip>
   15354:	83 c4 04             	add    $0x4,%esp
   15357:	89 c2                	mov    %eax,%edx
   15359:	8b 45 0c             	mov    0xc(%ebp),%eax
   1535c:	88 10                	mov    %dl,(%eax)
   1535e:	8b 45 10             	mov    0x10(%ebp),%eax
   15361:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   15364:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15367:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   1536a:	c1 f8 0e             	sar    $0xe,%eax
   1536d:	83 e8 80             	sub    $0xffffff80,%eax
   15370:	50                   	push   %eax
   15371:	e8 be e8 ff ff       	call   13c34 <_Clip>
   15376:	83 c4 04             	add    $0x4,%esp
   15379:	89 c2                	mov    %eax,%edx
   1537b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1537e:	88 10                	mov    %dl,(%eax)
   15380:	8b 45 10             	mov    0x10(%ebp),%eax
   15383:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   15386:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15389:	2b 45 ec             	sub    -0x14(%ebp),%eax
   1538c:	c1 f8 0e             	sar    $0xe,%eax
   1538f:	83 e8 80             	sub    $0xffffff80,%eax
   15392:	50                   	push   %eax
   15393:	e8 9c e8 ff ff       	call   13c34 <_Clip>
   15398:	83 c4 04             	add    $0x4,%esp
   1539b:	89 c2                	mov    %eax,%edx
   1539d:	8b 45 0c             	mov    0xc(%ebp),%eax
   153a0:	88 10                	mov    %dl,(%eax)
   153a2:	8b 45 10             	mov    0x10(%ebp),%eax
   153a5:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   153a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   153ab:	2b 45 f4             	sub    -0xc(%ebp),%eax
   153ae:	c1 f8 0e             	sar    $0xe,%eax
   153b1:	83 e8 80             	sub    $0xffffff80,%eax
   153b4:	50                   	push   %eax
   153b5:	e8 7a e8 ff ff       	call   13c34 <_Clip>
   153ba:	83 c4 04             	add    $0x4,%esp
   153bd:	89 c2                	mov    %eax,%edx
   153bf:	8b 45 0c             	mov    0xc(%ebp),%eax
   153c2:	88 10                	mov    %dl,(%eax)
   153c4:	8b 45 10             	mov    0x10(%ebp),%eax
   153c7:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   153ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
   153cd:	2b 45 f8             	sub    -0x8(%ebp),%eax
   153d0:	c1 f8 0e             	sar    $0xe,%eax
   153d3:	83 e8 80             	sub    $0xffffff80,%eax
   153d6:	50                   	push   %eax
   153d7:	e8 58 e8 ff ff       	call   13c34 <_Clip>
   153dc:	83 c4 04             	add    $0x4,%esp
   153df:	89 c2                	mov    %eax,%edx
   153e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   153e4:	88 10                	mov    %dl,(%eax)
}
   153e6:	c9                   	leave  
   153e7:	c3                   	ret    

000153e8 <_ByteAlign>:

void _ByteAlign(Context* ctx){
   153e8:	55                   	push   %ebp
   153e9:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   153eb:	8b 45 08             	mov    0x8(%ebp),%eax
   153ee:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   153f4:	25 f8 00 00 00       	and    $0xf8,%eax
   153f9:	89 c2                	mov    %eax,%edx
   153fb:	8b 45 08             	mov    0x8(%ebp),%eax
   153fe:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   15404:	90                   	nop
   15405:	5d                   	pop    %ebp
   15406:	c3                   	ret    

00015407 <_SkipMarker>:

void _SkipMarker(Context* ctx){
   15407:	55                   	push   %ebp
   15408:	89 e5                	mov    %esp,%ebp
   1540a:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   1540d:	83 ec 0c             	sub    $0xc,%esp
   15410:	ff 75 08             	pushl  0x8(%ebp)
   15413:	e8 8d e8 ff ff       	call   13ca5 <_DecodeLength>
   15418:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   1541b:	8b 45 08             	mov    0x8(%ebp),%eax
   1541e:	8b 40 0c             	mov    0xc(%eax),%eax
   15421:	83 ec 08             	sub    $0x8,%esp
   15424:	50                   	push   %eax
   15425:	ff 75 08             	pushl  0x8(%ebp)
   15428:	e8 2c e8 ff ff       	call   13c59 <_Skip>
   1542d:	83 c4 10             	add    $0x10,%esp
}
   15430:	90                   	nop
   15431:	c9                   	leave  
   15432:	c3                   	ret    

00015433 <_Convert>:

void _Convert(Context* ctx){
   15433:	55                   	push   %ebp
   15434:	89 e5                	mov    %esp,%ebp
   15436:	57                   	push   %edi
   15437:	56                   	push   %esi
   15438:	53                   	push   %ebx
   15439:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1543c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   15443:	8b 45 08             	mov    0x8(%ebp),%eax
   15446:	83 c0 2c             	add    $0x2c,%eax
   15449:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1544c:	e9 b2 00 00 00       	jmp    15503 <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   15451:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15454:	8b 50 0c             	mov    0xc(%eax),%edx
   15457:	8b 45 08             	mov    0x8(%ebp),%eax
   1545a:	8b 40 10             	mov    0x10(%eax),%eax
   1545d:	39 c2                	cmp    %eax,%edx
   1545f:	7d 11                	jge    15472 <_Convert+0x3f>
   15461:	83 ec 08             	sub    $0x8,%esp
   15464:	ff 75 e0             	pushl  -0x20(%ebp)
   15467:	ff 75 08             	pushl  0x8(%ebp)
   1546a:	e8 79 02 00 00       	call   156e8 <_UpsampleH>
   1546f:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15472:	8b 45 08             	mov    0x8(%ebp),%eax
   15475:	8b 00                	mov    (%eax),%eax
   15477:	85 c0                	test   %eax,%eax
   15479:	0f 85 5d 02 00 00    	jne    156dc <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   1547f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15482:	8b 50 10             	mov    0x10(%eax),%edx
   15485:	8b 45 08             	mov    0x8(%ebp),%eax
   15488:	8b 40 14             	mov    0x14(%eax),%eax
   1548b:	39 c2                	cmp    %eax,%edx
   1548d:	7d 11                	jge    154a0 <_Convert+0x6d>
   1548f:	83 ec 08             	sub    $0x8,%esp
   15492:	ff 75 e0             	pushl  -0x20(%ebp)
   15495:	ff 75 08             	pushl  0x8(%ebp)
   15498:	e8 db 05 00 00       	call   15a78 <_UpsampleV>
   1549d:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   154a0:	8b 45 08             	mov    0x8(%ebp),%eax
   154a3:	8b 00                	mov    (%eax),%eax
   154a5:	85 c0                	test   %eax,%eax
   154a7:	0f 85 32 02 00 00    	jne    156df <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   154ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154b0:	8b 50 0c             	mov    0xc(%eax),%edx
   154b3:	8b 45 08             	mov    0x8(%ebp),%eax
   154b6:	8b 40 10             	mov    0x10(%eax),%eax
   154b9:	39 c2                	cmp    %eax,%edx
   154bb:	7c 94                	jl     15451 <_Convert+0x1e>
   154bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154c0:	8b 50 10             	mov    0x10(%eax),%edx
   154c3:	8b 45 08             	mov    0x8(%ebp),%eax
   154c6:	8b 40 14             	mov    0x14(%eax),%eax
   154c9:	39 c2                	cmp    %eax,%edx
   154cb:	7c 84                	jl     15451 <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   154cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154d0:	8b 50 0c             	mov    0xc(%eax),%edx
   154d3:	8b 45 08             	mov    0x8(%ebp),%eax
   154d6:	8b 40 10             	mov    0x10(%eax),%eax
   154d9:	39 c2                	cmp    %eax,%edx
   154db:	7c 10                	jl     154ed <_Convert+0xba>
   154dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154e0:	8b 50 10             	mov    0x10(%eax),%edx
   154e3:	8b 45 08             	mov    0x8(%ebp),%eax
   154e6:	8b 40 14             	mov    0x14(%eax),%eax
   154e9:	39 c2                	cmp    %eax,%edx
   154eb:	7d 0e                	jge    154fb <_Convert+0xc8>
   154ed:	8b 45 08             	mov    0x8(%ebp),%eax
   154f0:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   154f6:	e9 e5 01 00 00       	jmp    156e0 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   154fb:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   154ff:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   15503:	8b 45 08             	mov    0x8(%ebp),%eax
   15506:	8b 40 28             	mov    0x28(%eax),%eax
   15509:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1550c:	7f 9f                	jg     154ad <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   1550e:	8b 45 08             	mov    0x8(%ebp),%eax
   15511:	8b 40 28             	mov    0x28(%eax),%eax
   15514:	83 f8 03             	cmp    $0x3,%eax
   15517:	0f 85 3d 01 00 00    	jne    1565a <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   1551d:	8b 45 08             	mov    0x8(%ebp),%eax
   15520:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   15526:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   15529:	8b 45 08             	mov    0x8(%ebp),%eax
   1552c:	8b 40 54             	mov    0x54(%eax),%eax
   1552f:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   15532:	8b 45 08             	mov    0x8(%ebp),%eax
   15535:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   1553b:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   1553e:	8b 45 08             	mov    0x8(%ebp),%eax
   15541:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   15547:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   1554a:	8b 45 08             	mov    0x8(%ebp),%eax
   1554d:	8b 40 14             	mov    0x14(%eax),%eax
   15550:	89 45 d8             	mov    %eax,-0x28(%ebp)
   15553:	e9 f3 00 00 00       	jmp    1564b <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   15558:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   1555f:	e9 b6 00 00 00       	jmp    1561a <_Convert+0x1e7>
                register int y = py[x] << 8;
   15564:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15567:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1556a:	01 d0                	add    %edx,%eax
   1556c:	0f b6 00             	movzbl (%eax),%eax
   1556f:	0f b6 c0             	movzbl %al,%eax
   15572:	c1 e0 08             	shl    $0x8,%eax
   15575:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   15577:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1557a:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1557d:	01 d0                	add    %edx,%eax
   1557f:	0f b6 00             	movzbl (%eax),%eax
   15582:	0f b6 c0             	movzbl %al,%eax
   15585:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   15588:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1558b:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1558e:	01 d0                	add    %edx,%eax
   15590:	0f b6 00             	movzbl (%eax),%eax
   15593:	0f b6 c0             	movzbl %al,%eax
   15596:	83 c0 80             	add    $0xffffff80,%eax
   15599:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   1559b:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1559e:	8d 46 01             	lea    0x1(%esi),%eax
   155a1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   155a4:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   155a7:	89 c8                	mov    %ecx,%eax
   155a9:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   155af:	01 d8                	add    %ebx,%eax
   155b1:	83 e8 80             	sub    $0xffffff80,%eax
   155b4:	c1 f8 08             	sar    $0x8,%eax
   155b7:	83 ec 0c             	sub    $0xc,%esp
   155ba:	50                   	push   %eax
   155bb:	e8 74 e6 ff ff       	call   13c34 <_Clip>
   155c0:	83 c4 10             	add    $0x10,%esp
   155c3:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   155c5:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   155c8:	8d 46 01             	lea    0x1(%esi),%eax
   155cb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   155ce:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   155d1:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   155d4:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   155db:	01 d0                	add    %edx,%eax
   155dd:	83 e8 80             	sub    $0xffffff80,%eax
   155e0:	c1 f8 08             	sar    $0x8,%eax
   155e3:	83 ec 0c             	sub    $0xc,%esp
   155e6:	50                   	push   %eax
   155e7:	e8 48 e6 ff ff       	call   13c34 <_Clip>
   155ec:	83 c4 10             	add    $0x10,%esp
   155ef:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   155f1:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   155f4:	8d 46 01             	lea    0x1(%esi),%eax
   155f7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   155fa:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   15600:	01 d8                	add    %ebx,%eax
   15602:	83 e8 80             	sub    $0xffffff80,%eax
   15605:	c1 f8 08             	sar    $0x8,%eax
   15608:	83 ec 0c             	sub    $0xc,%esp
   1560b:	50                   	push   %eax
   1560c:	e8 23 e6 ff ff       	call   13c34 <_Clip>
   15611:	83 c4 10             	add    $0x10,%esp
   15614:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   15616:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   1561a:	8b 45 08             	mov    0x8(%ebp),%eax
   1561d:	8b 40 10             	mov    0x10(%eax),%eax
   15620:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   15623:	0f 8f 3b ff ff ff    	jg     15564 <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   15629:	8b 45 08             	mov    0x8(%ebp),%eax
   1562c:	8b 40 40             	mov    0x40(%eax),%eax
   1562f:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   15632:	8b 45 08             	mov    0x8(%ebp),%eax
   15635:	8b 40 6c             	mov    0x6c(%eax),%eax
   15638:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   1563b:	8b 45 08             	mov    0x8(%ebp),%eax
   1563e:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   15644:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   15647:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   1564b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1564f:	0f 85 03 ff ff ff    	jne    15558 <_Convert+0x125>
   15655:	e9 86 00 00 00       	jmp    156e0 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   1565a:	8b 45 08             	mov    0x8(%ebp),%eax
   1565d:	8b 50 38             	mov    0x38(%eax),%edx
   15660:	8b 45 08             	mov    0x8(%ebp),%eax
   15663:	8b 40 40             	mov    0x40(%eax),%eax
   15666:	39 c2                	cmp    %eax,%edx
   15668:	74 76                	je     156e0 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   1566a:	8b 45 08             	mov    0x8(%ebp),%eax
   1566d:	8b 50 54             	mov    0x54(%eax),%edx
   15670:	8b 45 08             	mov    0x8(%ebp),%eax
   15673:	8b 40 40             	mov    0x40(%eax),%eax
   15676:	01 d0                	add    %edx,%eax
   15678:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   1567b:	8b 45 08             	mov    0x8(%ebp),%eax
   1567e:	8b 50 54             	mov    0x54(%eax),%edx
   15681:	8b 45 08             	mov    0x8(%ebp),%eax
   15684:	8b 40 38             	mov    0x38(%eax),%eax
   15687:	01 d0                	add    %edx,%eax
   15689:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   1568c:	8b 45 08             	mov    0x8(%ebp),%eax
   1568f:	8b 40 3c             	mov    0x3c(%eax),%eax
   15692:	83 e8 01             	sub    $0x1,%eax
   15695:	89 45 bc             	mov    %eax,-0x44(%ebp)
   15698:	eb 2e                	jmp    156c8 <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   1569a:	8b 45 08             	mov    0x8(%ebp),%eax
   1569d:	8b 40 38             	mov    0x38(%eax),%eax
   156a0:	83 ec 04             	sub    $0x4,%esp
   156a3:	50                   	push   %eax
   156a4:	ff 75 c4             	pushl  -0x3c(%ebp)
   156a7:	ff 75 c0             	pushl  -0x40(%ebp)
   156aa:	e8 72 ac fe ff       	call   321 <memmove>
   156af:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   156b2:	8b 45 08             	mov    0x8(%ebp),%eax
   156b5:	8b 40 40             	mov    0x40(%eax),%eax
   156b8:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   156bb:	8b 45 08             	mov    0x8(%ebp),%eax
   156be:	8b 40 38             	mov    0x38(%eax),%eax
   156c1:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   156c4:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   156c8:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   156cc:	75 cc                	jne    1569a <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   156ce:	8b 45 08             	mov    0x8(%ebp),%eax
   156d1:	8b 50 38             	mov    0x38(%eax),%edx
   156d4:	8b 45 08             	mov    0x8(%ebp),%eax
   156d7:	89 50 40             	mov    %edx,0x40(%eax)
   156da:	eb 04                	jmp    156e0 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   156dc:	90                   	nop
   156dd:	eb 01                	jmp    156e0 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   156df:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   156e0:	8d 65 f4             	lea    -0xc(%ebp),%esp
   156e3:	5b                   	pop    %ebx
   156e4:	5e                   	pop    %esi
   156e5:	5f                   	pop    %edi
   156e6:	5d                   	pop    %ebp
   156e7:	c3                   	ret    

000156e8 <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   156e8:	55                   	push   %ebp
   156e9:	89 e5                	mov    %esp,%ebp
   156eb:	53                   	push   %ebx
   156ec:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   156ef:	8b 45 0c             	mov    0xc(%ebp),%eax
   156f2:	8b 40 0c             	mov    0xc(%eax),%eax
   156f5:	83 e8 03             	sub    $0x3,%eax
   156f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   156fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   156fe:	8b 50 0c             	mov    0xc(%eax),%edx
   15701:	8b 45 0c             	mov    0xc(%ebp),%eax
   15704:	8b 40 10             	mov    0x10(%eax),%eax
   15707:	0f af c2             	imul   %edx,%eax
   1570a:	01 c0                	add    %eax,%eax
   1570c:	83 ec 0c             	sub    $0xc,%esp
   1570f:	50                   	push   %eax
   15710:	e8 cb b0 fe ff       	call   7e0 <malloc>
   15715:	83 c4 10             	add    $0x10,%esp
   15718:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   1571b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1571f:	75 0e                	jne    1572f <_UpsampleH+0x47>
   15721:	8b 45 08             	mov    0x8(%ebp),%eax
   15724:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1572a:	e9 44 03 00 00       	jmp    15a73 <_UpsampleH+0x38b>
    lin = c->pixels;
   1572f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15732:	8b 40 28             	mov    0x28(%eax),%eax
   15735:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   15738:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1573b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   1573e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15741:	8b 40 10             	mov    0x10(%eax),%eax
   15744:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   15747:	e9 e0 02 00 00       	jmp    15a2c <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   1574c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1574f:	0f b6 00             	movzbl (%eax),%eax
   15752:	0f b6 c0             	movzbl %al,%eax
   15755:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   1575b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1575e:	83 c0 01             	add    $0x1,%eax
   15761:	0f b6 00             	movzbl (%eax),%eax
   15764:	0f b6 c0             	movzbl %al,%eax
   15767:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   1576a:	01 d0                	add    %edx,%eax
   1576c:	83 ec 0c             	sub    $0xc,%esp
   1576f:	50                   	push   %eax
   15770:	e8 c4 06 00 00       	call   15e39 <CF>
   15775:	83 c4 10             	add    $0x10,%esp
   15778:	89 c2                	mov    %eax,%edx
   1577a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1577d:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   1577f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15782:	8d 58 01             	lea    0x1(%eax),%ebx
   15785:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15788:	0f b6 00             	movzbl (%eax),%eax
   1578b:	0f b6 c0             	movzbl %al,%eax
   1578e:	6b c8 68             	imul   $0x68,%eax,%ecx
   15791:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15794:	83 c0 01             	add    $0x1,%eax
   15797:	0f b6 00             	movzbl (%eax),%eax
   1579a:	0f b6 d0             	movzbl %al,%edx
   1579d:	89 d0                	mov    %edx,%eax
   1579f:	01 c0                	add    %eax,%eax
   157a1:	01 d0                	add    %edx,%eax
   157a3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   157aa:	01 d0                	add    %edx,%eax
   157ac:	01 c1                	add    %eax,%ecx
   157ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157b1:	83 c0 02             	add    $0x2,%eax
   157b4:	0f b6 00             	movzbl (%eax),%eax
   157b7:	0f b6 d0             	movzbl %al,%edx
   157ba:	89 d0                	mov    %edx,%eax
   157bc:	01 c0                	add    %eax,%eax
   157be:	01 d0                	add    %edx,%eax
   157c0:	f7 d8                	neg    %eax
   157c2:	01 c8                	add    %ecx,%eax
   157c4:	83 ec 0c             	sub    $0xc,%esp
   157c7:	50                   	push   %eax
   157c8:	e8 6c 06 00 00       	call   15e39 <CF>
   157cd:	83 c4 10             	add    $0x10,%esp
   157d0:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   157d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   157d5:	8d 58 02             	lea    0x2(%eax),%ebx
   157d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157db:	0f b6 00             	movzbl (%eax),%eax
   157de:	0f b6 c0             	movzbl %al,%eax
   157e1:	c1 e0 02             	shl    $0x2,%eax
   157e4:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   157eb:	29 c2                	sub    %eax,%edx
   157ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157f0:	83 c0 01             	add    $0x1,%eax
   157f3:	0f b6 00             	movzbl (%eax),%eax
   157f6:	0f b6 c0             	movzbl %al,%eax
   157f9:	6b c0 6d             	imul   $0x6d,%eax,%eax
   157fc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   157ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15802:	83 c0 02             	add    $0x2,%eax
   15805:	0f b6 00             	movzbl (%eax),%eax
   15808:	0f b6 d0             	movzbl %al,%edx
   1580b:	89 d0                	mov    %edx,%eax
   1580d:	c1 e0 03             	shl    $0x3,%eax
   15810:	01 d0                	add    %edx,%eax
   15812:	f7 d8                	neg    %eax
   15814:	01 c8                	add    %ecx,%eax
   15816:	83 ec 0c             	sub    $0xc,%esp
   15819:	50                   	push   %eax
   1581a:	e8 1a 06 00 00       	call   15e39 <CF>
   1581f:	83 c4 10             	add    $0x10,%esp
   15822:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   15824:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1582b:	e9 fa 00 00 00       	jmp    1592a <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   15830:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15833:	01 c0                	add    %eax,%eax
   15835:	8d 50 03             	lea    0x3(%eax),%edx
   15838:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1583b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1583e:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15841:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15844:	01 d0                	add    %edx,%eax
   15846:	0f b6 00             	movzbl (%eax),%eax
   15849:	0f b6 d0             	movzbl %al,%edx
   1584c:	89 d0                	mov    %edx,%eax
   1584e:	c1 e0 03             	shl    $0x3,%eax
   15851:	01 d0                	add    %edx,%eax
   15853:	f7 d8                	neg    %eax
   15855:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15858:	8d 4a 01             	lea    0x1(%edx),%ecx
   1585b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1585e:	01 ca                	add    %ecx,%edx
   15860:	0f b6 12             	movzbl (%edx),%edx
   15863:	0f b6 d2             	movzbl %dl,%edx
   15866:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15869:	01 c2                	add    %eax,%edx
   1586b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1586e:	8d 48 02             	lea    0x2(%eax),%ecx
   15871:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15874:	01 c8                	add    %ecx,%eax
   15876:	0f b6 00             	movzbl (%eax),%eax
   15879:	0f b6 c0             	movzbl %al,%eax
   1587c:	6b c0 1d             	imul   $0x1d,%eax,%eax
   1587f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15882:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15885:	8d 50 03             	lea    0x3(%eax),%edx
   15888:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1588b:	01 d0                	add    %edx,%eax
   1588d:	0f b6 00             	movzbl (%eax),%eax
   15890:	0f b6 d0             	movzbl %al,%edx
   15893:	89 d0                	mov    %edx,%eax
   15895:	01 c0                	add    %eax,%eax
   15897:	01 d0                	add    %edx,%eax
   15899:	f7 d8                	neg    %eax
   1589b:	01 c8                	add    %ecx,%eax
   1589d:	83 ec 0c             	sub    $0xc,%esp
   158a0:	50                   	push   %eax
   158a1:	e8 93 05 00 00       	call   15e39 <CF>
   158a6:	83 c4 10             	add    $0x10,%esp
   158a9:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   158ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
   158ae:	01 c0                	add    %eax,%eax
   158b0:	8d 50 04             	lea    0x4(%eax),%edx
   158b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158b6:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   158b9:	8b 55 ec             	mov    -0x14(%ebp),%edx
   158bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158bf:	01 d0                	add    %edx,%eax
   158c1:	0f b6 00             	movzbl (%eax),%eax
   158c4:	0f b6 d0             	movzbl %al,%edx
   158c7:	89 d0                	mov    %edx,%eax
   158c9:	01 c0                	add    %eax,%eax
   158cb:	01 d0                	add    %edx,%eax
   158cd:	f7 d8                	neg    %eax
   158cf:	8b 55 ec             	mov    -0x14(%ebp),%edx
   158d2:	8d 4a 01             	lea    0x1(%edx),%ecx
   158d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   158d8:	01 ca                	add    %ecx,%edx
   158da:	0f b6 12             	movzbl (%edx),%edx
   158dd:	0f b6 d2             	movzbl %dl,%edx
   158e0:	6b d2 1d             	imul   $0x1d,%edx,%edx
   158e3:	01 c2                	add    %eax,%edx
   158e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   158e8:	8d 48 02             	lea    0x2(%eax),%ecx
   158eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158ee:	01 c8                	add    %ecx,%eax
   158f0:	0f b6 00             	movzbl (%eax),%eax
   158f3:	0f b6 c0             	movzbl %al,%eax
   158f6:	6b c0 6f             	imul   $0x6f,%eax,%eax
   158f9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   158fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   158ff:	8d 50 03             	lea    0x3(%eax),%edx
   15902:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15905:	01 d0                	add    %edx,%eax
   15907:	0f b6 00             	movzbl (%eax),%eax
   1590a:	0f b6 d0             	movzbl %al,%edx
   1590d:	89 d0                	mov    %edx,%eax
   1590f:	c1 e0 03             	shl    $0x3,%eax
   15912:	01 d0                	add    %edx,%eax
   15914:	f7 d8                	neg    %eax
   15916:	01 c8                	add    %ecx,%eax
   15918:	83 ec 0c             	sub    $0xc,%esp
   1591b:	50                   	push   %eax
   1591c:	e8 18 05 00 00       	call   15e39 <CF>
   15921:	83 c4 10             	add    $0x10,%esp
   15924:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   15926:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1592a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1592d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15930:	0f 8c fa fe ff ff    	jl     15830 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   15936:	8b 45 0c             	mov    0xc(%ebp),%eax
   15939:	8b 40 14             	mov    0x14(%eax),%eax
   1593c:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   1593f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15942:	8b 40 0c             	mov    0xc(%eax),%eax
   15945:	01 c0                	add    %eax,%eax
   15947:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   1594a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1594d:	8d 58 fd             	lea    -0x3(%eax),%ebx
   15950:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15953:	83 e8 01             	sub    $0x1,%eax
   15956:	0f b6 00             	movzbl (%eax),%eax
   15959:	0f b6 c0             	movzbl %al,%eax
   1595c:	c1 e0 02             	shl    $0x2,%eax
   1595f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15966:	29 c2                	sub    %eax,%edx
   15968:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1596b:	83 e8 02             	sub    $0x2,%eax
   1596e:	0f b6 00             	movzbl (%eax),%eax
   15971:	0f b6 c0             	movzbl %al,%eax
   15974:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15977:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1597a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1597d:	83 e8 03             	sub    $0x3,%eax
   15980:	0f b6 00             	movzbl (%eax),%eax
   15983:	0f b6 d0             	movzbl %al,%edx
   15986:	89 d0                	mov    %edx,%eax
   15988:	c1 e0 03             	shl    $0x3,%eax
   1598b:	01 d0                	add    %edx,%eax
   1598d:	f7 d8                	neg    %eax
   1598f:	01 c8                	add    %ecx,%eax
   15991:	83 ec 0c             	sub    $0xc,%esp
   15994:	50                   	push   %eax
   15995:	e8 9f 04 00 00       	call   15e39 <CF>
   1599a:	83 c4 10             	add    $0x10,%esp
   1599d:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   1599f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   159a2:	8d 58 fe             	lea    -0x2(%eax),%ebx
   159a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159a8:	83 e8 01             	sub    $0x1,%eax
   159ab:	0f b6 00             	movzbl (%eax),%eax
   159ae:	0f b6 c0             	movzbl %al,%eax
   159b1:	6b c8 68             	imul   $0x68,%eax,%ecx
   159b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159b7:	83 e8 02             	sub    $0x2,%eax
   159ba:	0f b6 00             	movzbl (%eax),%eax
   159bd:	0f b6 d0             	movzbl %al,%edx
   159c0:	89 d0                	mov    %edx,%eax
   159c2:	01 c0                	add    %eax,%eax
   159c4:	01 d0                	add    %edx,%eax
   159c6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   159cd:	01 d0                	add    %edx,%eax
   159cf:	01 c1                	add    %eax,%ecx
   159d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159d4:	83 e8 03             	sub    $0x3,%eax
   159d7:	0f b6 00             	movzbl (%eax),%eax
   159da:	0f b6 d0             	movzbl %al,%edx
   159dd:	89 d0                	mov    %edx,%eax
   159df:	01 c0                	add    %eax,%eax
   159e1:	01 d0                	add    %edx,%eax
   159e3:	f7 d8                	neg    %eax
   159e5:	01 c8                	add    %ecx,%eax
   159e7:	83 ec 0c             	sub    $0xc,%esp
   159ea:	50                   	push   %eax
   159eb:	e8 49 04 00 00       	call   15e39 <CF>
   159f0:	83 c4 10             	add    $0x10,%esp
   159f3:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   159f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   159f8:	8d 58 ff             	lea    -0x1(%eax),%ebx
   159fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159fe:	83 e8 01             	sub    $0x1,%eax
   15a01:	0f b6 00             	movzbl (%eax),%eax
   15a04:	0f b6 c0             	movzbl %al,%eax
   15a07:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15a0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a10:	83 e8 02             	sub    $0x2,%eax
   15a13:	0f b6 00             	movzbl (%eax),%eax
   15a16:	0f b6 c0             	movzbl %al,%eax
   15a19:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15a1c:	01 d0                	add    %edx,%eax
   15a1e:	83 ec 0c             	sub    $0xc,%esp
   15a21:	50                   	push   %eax
   15a22:	e8 12 04 00 00       	call   15e39 <CF>
   15a27:	83 c4 10             	add    $0x10,%esp
   15a2a:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   15a2c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15a2f:	8d 50 ff             	lea    -0x1(%eax),%edx
   15a32:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15a35:	85 c0                	test   %eax,%eax
   15a37:	0f 85 0f fd ff ff    	jne    1574c <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   15a3d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a40:	8b 40 0c             	mov    0xc(%eax),%eax
   15a43:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15a46:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a49:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   15a4c:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a4f:	8b 50 0c             	mov    0xc(%eax),%edx
   15a52:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a55:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15a58:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a5b:	8b 40 28             	mov    0x28(%eax),%eax
   15a5e:	83 ec 0c             	sub    $0xc,%esp
   15a61:	50                   	push   %eax
   15a62:	e8 37 ac fe ff       	call   69e <free>
   15a67:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15a6a:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a6d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15a70:	89 50 28             	mov    %edx,0x28(%eax)
}
   15a73:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15a76:	c9                   	leave  
   15a77:	c3                   	ret    

00015a78 <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   15a78:	55                   	push   %ebp
   15a79:	89 e5                	mov    %esp,%ebp
   15a7b:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   15a7e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a81:	8b 40 0c             	mov    0xc(%eax),%eax
   15a84:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   15a87:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a8a:	8b 40 14             	mov    0x14(%eax),%eax
   15a8d:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15a90:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15a93:	01 c0                	add    %eax,%eax
   15a95:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15a98:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a9b:	8b 50 0c             	mov    0xc(%eax),%edx
   15a9e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15aa1:	8b 40 10             	mov    0x10(%eax),%eax
   15aa4:	0f af c2             	imul   %edx,%eax
   15aa7:	01 c0                	add    %eax,%eax
   15aa9:	83 ec 0c             	sub    $0xc,%esp
   15aac:	50                   	push   %eax
   15aad:	e8 2e ad fe ff       	call   7e0 <malloc>
   15ab2:	83 c4 10             	add    $0x10,%esp
   15ab5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15ab8:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15abc:	75 0e                	jne    15acc <_UpsampleV+0x54>
   15abe:	8b 45 08             	mov    0x8(%ebp),%eax
   15ac1:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15ac7:	e9 6b 03 00 00       	jmp    15e37 <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   15acc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15ad3:	e9 1d 03 00 00       	jmp    15df5 <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   15ad8:	8b 45 0c             	mov    0xc(%ebp),%eax
   15adb:	8b 50 28             	mov    0x28(%eax),%edx
   15ade:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15ae1:	01 d0                	add    %edx,%eax
   15ae3:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   15ae6:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15ae9:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15aec:	01 d0                	add    %edx,%eax
   15aee:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   15af1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15af4:	0f b6 00             	movzbl (%eax),%eax
   15af7:	0f b6 c0             	movzbl %al,%eax
   15afa:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15b00:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15b03:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b06:	01 c8                	add    %ecx,%eax
   15b08:	0f b6 00             	movzbl (%eax),%eax
   15b0b:	0f b6 c0             	movzbl %al,%eax
   15b0e:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15b11:	01 d0                	add    %edx,%eax
   15b13:	83 ec 0c             	sub    $0xc,%esp
   15b16:	50                   	push   %eax
   15b17:	e8 1d 03 00 00       	call   15e39 <CF>
   15b1c:	83 c4 10             	add    $0x10,%esp
   15b1f:	89 c2                	mov    %eax,%edx
   15b21:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b24:	88 10                	mov    %dl,(%eax)
   15b26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b29:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   15b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b2f:	0f b6 00             	movzbl (%eax),%eax
   15b32:	0f b6 c0             	movzbl %al,%eax
   15b35:	6b c8 68             	imul   $0x68,%eax,%ecx
   15b38:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15b3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b3e:	01 d0                	add    %edx,%eax
   15b40:	0f b6 00             	movzbl (%eax),%eax
   15b43:	0f b6 d0             	movzbl %al,%edx
   15b46:	89 d0                	mov    %edx,%eax
   15b48:	01 c0                	add    %eax,%eax
   15b4a:	01 d0                	add    %edx,%eax
   15b4c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15b53:	01 d0                	add    %edx,%eax
   15b55:	01 c1                	add    %eax,%ecx
   15b57:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15b5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b5d:	01 d0                	add    %edx,%eax
   15b5f:	0f b6 00             	movzbl (%eax),%eax
   15b62:	0f b6 d0             	movzbl %al,%edx
   15b65:	89 d0                	mov    %edx,%eax
   15b67:	01 c0                	add    %eax,%eax
   15b69:	01 d0                	add    %edx,%eax
   15b6b:	f7 d8                	neg    %eax
   15b6d:	01 c8                	add    %ecx,%eax
   15b6f:	83 ec 0c             	sub    $0xc,%esp
   15b72:	50                   	push   %eax
   15b73:	e8 c1 02 00 00       	call   15e39 <CF>
   15b78:	83 c4 10             	add    $0x10,%esp
   15b7b:	89 c2                	mov    %eax,%edx
   15b7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b80:	88 10                	mov    %dl,(%eax)
   15b82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b85:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   15b88:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b8b:	0f b6 00             	movzbl (%eax),%eax
   15b8e:	0f b6 c0             	movzbl %al,%eax
   15b91:	c1 e0 02             	shl    $0x2,%eax
   15b94:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15b9b:	89 d1                	mov    %edx,%ecx
   15b9d:	29 c1                	sub    %eax,%ecx
   15b9f:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15ba2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ba5:	01 d0                	add    %edx,%eax
   15ba7:	0f b6 00             	movzbl (%eax),%eax
   15baa:	0f b6 c0             	movzbl %al,%eax
   15bad:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15bb0:	01 c1                	add    %eax,%ecx
   15bb2:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15bb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bb8:	01 d0                	add    %edx,%eax
   15bba:	0f b6 00             	movzbl (%eax),%eax
   15bbd:	0f b6 d0             	movzbl %al,%edx
   15bc0:	89 d0                	mov    %edx,%eax
   15bc2:	c1 e0 03             	shl    $0x3,%eax
   15bc5:	01 d0                	add    %edx,%eax
   15bc7:	f7 d8                	neg    %eax
   15bc9:	01 c8                	add    %ecx,%eax
   15bcb:	83 ec 0c             	sub    $0xc,%esp
   15bce:	50                   	push   %eax
   15bcf:	e8 65 02 00 00       	call   15e39 <CF>
   15bd4:	83 c4 10             	add    $0x10,%esp
   15bd7:	89 c2                	mov    %eax,%edx
   15bd9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15bdc:	88 10                	mov    %dl,(%eax)
   15bde:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15be1:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   15be4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15be7:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   15bea:	8b 45 0c             	mov    0xc(%ebp),%eax
   15bed:	8b 40 10             	mov    0x10(%eax),%eax
   15bf0:	83 e8 03             	sub    $0x3,%eax
   15bf3:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15bf6:	e9 e6 00 00 00       	jmp    15ce1 <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   15bfb:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15bfe:	f7 d8                	neg    %eax
   15c00:	89 c2                	mov    %eax,%edx
   15c02:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c05:	01 d0                	add    %edx,%eax
   15c07:	0f b6 00             	movzbl (%eax),%eax
   15c0a:	0f b6 d0             	movzbl %al,%edx
   15c0d:	89 d0                	mov    %edx,%eax
   15c0f:	c1 e0 03             	shl    $0x3,%eax
   15c12:	01 d0                	add    %edx,%eax
   15c14:	f7 d8                	neg    %eax
   15c16:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15c19:	0f b6 12             	movzbl (%edx),%edx
   15c1c:	0f b6 d2             	movzbl %dl,%edx
   15c1f:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15c22:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15c25:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15c28:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c2b:	01 d0                	add    %edx,%eax
   15c2d:	0f b6 00             	movzbl (%eax),%eax
   15c30:	0f b6 c0             	movzbl %al,%eax
   15c33:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15c36:	01 c1                	add    %eax,%ecx
   15c38:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15c3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c3e:	01 d0                	add    %edx,%eax
   15c40:	0f b6 00             	movzbl (%eax),%eax
   15c43:	0f b6 d0             	movzbl %al,%edx
   15c46:	89 d0                	mov    %edx,%eax
   15c48:	01 c0                	add    %eax,%eax
   15c4a:	01 d0                	add    %edx,%eax
   15c4c:	f7 d8                	neg    %eax
   15c4e:	01 c8                	add    %ecx,%eax
   15c50:	83 ec 0c             	sub    $0xc,%esp
   15c53:	50                   	push   %eax
   15c54:	e8 e0 01 00 00       	call   15e39 <CF>
   15c59:	83 c4 10             	add    $0x10,%esp
   15c5c:	89 c2                	mov    %eax,%edx
   15c5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c61:	88 10                	mov    %dl,(%eax)
   15c63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15c66:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   15c69:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c6c:	f7 d8                	neg    %eax
   15c6e:	89 c2                	mov    %eax,%edx
   15c70:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c73:	01 d0                	add    %edx,%eax
   15c75:	0f b6 00             	movzbl (%eax),%eax
   15c78:	0f b6 d0             	movzbl %al,%edx
   15c7b:	89 d0                	mov    %edx,%eax
   15c7d:	01 c0                	add    %eax,%eax
   15c7f:	01 d0                	add    %edx,%eax
   15c81:	f7 d8                	neg    %eax
   15c83:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15c86:	0f b6 12             	movzbl (%edx),%edx
   15c89:	0f b6 d2             	movzbl %dl,%edx
   15c8c:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15c8f:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15c92:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15c95:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c98:	01 d0                	add    %edx,%eax
   15c9a:	0f b6 00             	movzbl (%eax),%eax
   15c9d:	0f b6 c0             	movzbl %al,%eax
   15ca0:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15ca3:	01 c1                	add    %eax,%ecx
   15ca5:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15ca8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cab:	01 d0                	add    %edx,%eax
   15cad:	0f b6 00             	movzbl (%eax),%eax
   15cb0:	0f b6 d0             	movzbl %al,%edx
   15cb3:	89 d0                	mov    %edx,%eax
   15cb5:	c1 e0 03             	shl    $0x3,%eax
   15cb8:	01 d0                	add    %edx,%eax
   15cba:	f7 d8                	neg    %eax
   15cbc:	01 c8                	add    %ecx,%eax
   15cbe:	83 ec 0c             	sub    $0xc,%esp
   15cc1:	50                   	push   %eax
   15cc2:	e8 72 01 00 00       	call   15e39 <CF>
   15cc7:	83 c4 10             	add    $0x10,%esp
   15cca:	89 c2                	mov    %eax,%edx
   15ccc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15ccf:	88 10                	mov    %dl,(%eax)
   15cd1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15cd4:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   15cd7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15cda:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   15cdd:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   15ce1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15ce5:	0f 85 10 ff ff ff    	jne    15bfb <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   15ceb:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15cee:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   15cf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cf4:	0f b6 00             	movzbl (%eax),%eax
   15cf7:	0f b6 c0             	movzbl %al,%eax
   15cfa:	c1 e0 02             	shl    $0x2,%eax
   15cfd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15d04:	29 c2                	sub    %eax,%edx
   15d06:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d09:	f7 d8                	neg    %eax
   15d0b:	89 c1                	mov    %eax,%ecx
   15d0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d10:	01 c8                	add    %ecx,%eax
   15d12:	0f b6 00             	movzbl (%eax),%eax
   15d15:	0f b6 c0             	movzbl %al,%eax
   15d18:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15d1b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15d1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15d21:	f7 d8                	neg    %eax
   15d23:	89 c2                	mov    %eax,%edx
   15d25:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d28:	01 d0                	add    %edx,%eax
   15d2a:	0f b6 00             	movzbl (%eax),%eax
   15d2d:	0f b6 d0             	movzbl %al,%edx
   15d30:	89 d0                	mov    %edx,%eax
   15d32:	c1 e0 03             	shl    $0x3,%eax
   15d35:	01 d0                	add    %edx,%eax
   15d37:	f7 d8                	neg    %eax
   15d39:	01 c8                	add    %ecx,%eax
   15d3b:	83 ec 0c             	sub    $0xc,%esp
   15d3e:	50                   	push   %eax
   15d3f:	e8 f5 00 00 00       	call   15e39 <CF>
   15d44:	83 c4 10             	add    $0x10,%esp
   15d47:	89 c2                	mov    %eax,%edx
   15d49:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d4c:	88 10                	mov    %dl,(%eax)
   15d4e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d51:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   15d54:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d57:	0f b6 00             	movzbl (%eax),%eax
   15d5a:	0f b6 c0             	movzbl %al,%eax
   15d5d:	6b c8 68             	imul   $0x68,%eax,%ecx
   15d60:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d63:	f7 d8                	neg    %eax
   15d65:	89 c2                	mov    %eax,%edx
   15d67:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d6a:	01 d0                	add    %edx,%eax
   15d6c:	0f b6 00             	movzbl (%eax),%eax
   15d6f:	0f b6 d0             	movzbl %al,%edx
   15d72:	89 d0                	mov    %edx,%eax
   15d74:	01 c0                	add    %eax,%eax
   15d76:	01 d0                	add    %edx,%eax
   15d78:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15d7f:	01 d0                	add    %edx,%eax
   15d81:	01 c1                	add    %eax,%ecx
   15d83:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15d86:	f7 d8                	neg    %eax
   15d88:	89 c2                	mov    %eax,%edx
   15d8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d8d:	01 d0                	add    %edx,%eax
   15d8f:	0f b6 00             	movzbl (%eax),%eax
   15d92:	0f b6 d0             	movzbl %al,%edx
   15d95:	89 d0                	mov    %edx,%eax
   15d97:	01 c0                	add    %eax,%eax
   15d99:	01 d0                	add    %edx,%eax
   15d9b:	f7 d8                	neg    %eax
   15d9d:	01 c8                	add    %ecx,%eax
   15d9f:	83 ec 0c             	sub    $0xc,%esp
   15da2:	50                   	push   %eax
   15da3:	e8 91 00 00 00       	call   15e39 <CF>
   15da8:	83 c4 10             	add    $0x10,%esp
   15dab:	89 c2                	mov    %eax,%edx
   15dad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15db0:	88 10                	mov    %dl,(%eax)
   15db2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15db5:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   15db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dbb:	0f b6 00             	movzbl (%eax),%eax
   15dbe:	0f b6 c0             	movzbl %al,%eax
   15dc1:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15dc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15dca:	f7 d8                	neg    %eax
   15dcc:	89 c1                	mov    %eax,%ecx
   15dce:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dd1:	01 c8                	add    %ecx,%eax
   15dd3:	0f b6 00             	movzbl (%eax),%eax
   15dd6:	0f b6 c0             	movzbl %al,%eax
   15dd9:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15ddc:	01 d0                	add    %edx,%eax
   15dde:	83 ec 0c             	sub    $0xc,%esp
   15de1:	50                   	push   %eax
   15de2:	e8 52 00 00 00       	call   15e39 <CF>
   15de7:	83 c4 10             	add    $0x10,%esp
   15dea:	89 c2                	mov    %eax,%edx
   15dec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15def:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   15df1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15df5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15df8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15dfb:	0f 8c d7 fc ff ff    	jl     15ad8 <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   15e01:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e04:	8b 40 10             	mov    0x10(%eax),%eax
   15e07:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15e0a:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e0d:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   15e10:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e13:	8b 50 0c             	mov    0xc(%eax),%edx
   15e16:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e19:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15e1c:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e1f:	8b 40 28             	mov    0x28(%eax),%eax
   15e22:	83 ec 0c             	sub    $0xc,%esp
   15e25:	50                   	push   %eax
   15e26:	e8 73 a8 fe ff       	call   69e <free>
   15e2b:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15e2e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e31:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15e34:	89 50 28             	mov    %edx,0x28(%eax)
}
   15e37:	c9                   	leave  
   15e38:	c3                   	ret    

00015e39 <CF>:

uchar CF(const int x){
   15e39:	55                   	push   %ebp
   15e3a:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   15e3c:	8b 45 08             	mov    0x8(%ebp),%eax
   15e3f:	83 c0 40             	add    $0x40,%eax
   15e42:	c1 f8 07             	sar    $0x7,%eax
   15e45:	50                   	push   %eax
   15e46:	e8 e9 dd ff ff       	call   13c34 <_Clip>
   15e4b:	83 c4 04             	add    $0x4,%esp
}
   15e4e:	c9                   	leave  
   15e4f:	c3                   	ret    
