
_mkdir：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <main>:
#include "stat.h"
#include "user.h"

int
main(int argc, char *argv[])
{
       0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
       4:	83 e4 f0             	and    $0xfffffff0,%esp
       7:	ff 71 fc             	pushl  -0x4(%ecx)
       a:	55                   	push   %ebp
       b:	89 e5                	mov    %esp,%ebp
       d:	53                   	push   %ebx
       e:	51                   	push   %ecx
       f:	83 ec 10             	sub    $0x10,%esp
      12:	89 cb                	mov    %ecx,%ebx
  int i;

  if(argc < 2){
      14:	83 3b 01             	cmpl   $0x1,(%ebx)
      17:	7f 17                	jg     30 <main+0x30>
    printf(2, "Usage: mkdir files...\n");
      19:	83 ec 08             	sub    $0x8,%esp
      1c:	68 e0 5d 01 00       	push   $0x15de0
      21:	6a 02                	push   $0x2
      23:	e8 66 04 00 00       	call   48e <printf>
      28:	83 c4 10             	add    $0x10,%esp
    exit();
      2b:	e8 b7 02 00 00       	call   2e7 <exit>
  }

  for(i = 1; i < argc; i++){
      30:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
      37:	eb 4b                	jmp    84 <main+0x84>
    if(mkdir(argv[i]) < 0){
      39:	8b 45 f4             	mov    -0xc(%ebp),%eax
      3c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
      43:	8b 43 04             	mov    0x4(%ebx),%eax
      46:	01 d0                	add    %edx,%eax
      48:	8b 00                	mov    (%eax),%eax
      4a:	83 ec 0c             	sub    $0xc,%esp
      4d:	50                   	push   %eax
      4e:	e8 fc 02 00 00       	call   34f <mkdir>
      53:	83 c4 10             	add    $0x10,%esp
      56:	85 c0                	test   %eax,%eax
      58:	79 26                	jns    80 <main+0x80>
      printf(2, "mkdir: %s failed to create\n", argv[i]);
      5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
      5d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
      64:	8b 43 04             	mov    0x4(%ebx),%eax
      67:	01 d0                	add    %edx,%eax
      69:	8b 00                	mov    (%eax),%eax
      6b:	83 ec 04             	sub    $0x4,%esp
      6e:	50                   	push   %eax
      6f:	68 f7 5d 01 00       	push   $0x15df7
      74:	6a 02                	push   $0x2
      76:	e8 13 04 00 00       	call   48e <printf>
      7b:	83 c4 10             	add    $0x10,%esp
      break;
      7e:	eb 0b                	jmp    8b <main+0x8b>
  if(argc < 2){
    printf(2, "Usage: mkdir files...\n");
    exit();
  }

  for(i = 1; i < argc; i++){
      80:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      84:	8b 45 f4             	mov    -0xc(%ebp),%eax
      87:	3b 03                	cmp    (%ebx),%eax
      89:	7c ae                	jl     39 <main+0x39>
      printf(2, "mkdir: %s failed to create\n", argv[i]);
      break;
    }
  }

  exit();
      8b:	e8 57 02 00 00       	call   2e7 <exit>

00000090 <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
      90:	55                   	push   %ebp
      91:	89 e5                	mov    %esp,%ebp
      93:	57                   	push   %edi
      94:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
      95:	8b 4d 08             	mov    0x8(%ebp),%ecx
      98:	8b 55 10             	mov    0x10(%ebp),%edx
      9b:	8b 45 0c             	mov    0xc(%ebp),%eax
      9e:	89 cb                	mov    %ecx,%ebx
      a0:	89 df                	mov    %ebx,%edi
      a2:	89 d1                	mov    %edx,%ecx
      a4:	fc                   	cld    
      a5:	f3 aa                	rep stos %al,%es:(%edi)
      a7:	89 ca                	mov    %ecx,%edx
      a9:	89 fb                	mov    %edi,%ebx
      ab:	89 5d 08             	mov    %ebx,0x8(%ebp)
      ae:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
      b1:	90                   	nop
      b2:	5b                   	pop    %ebx
      b3:	5f                   	pop    %edi
      b4:	5d                   	pop    %ebp
      b5:	c3                   	ret    

000000b6 <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
      b6:	55                   	push   %ebp
      b7:	89 e5                	mov    %esp,%ebp
      b9:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
      bc:	8b 45 08             	mov    0x8(%ebp),%eax
      bf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
      c2:	90                   	nop
      c3:	8b 45 08             	mov    0x8(%ebp),%eax
      c6:	8d 50 01             	lea    0x1(%eax),%edx
      c9:	89 55 08             	mov    %edx,0x8(%ebp)
      cc:	8b 55 0c             	mov    0xc(%ebp),%edx
      cf:	8d 4a 01             	lea    0x1(%edx),%ecx
      d2:	89 4d 0c             	mov    %ecx,0xc(%ebp)
      d5:	0f b6 12             	movzbl (%edx),%edx
      d8:	88 10                	mov    %dl,(%eax)
      da:	0f b6 00             	movzbl (%eax),%eax
      dd:	84 c0                	test   %al,%al
      df:	75 e2                	jne    c3 <strcpy+0xd>
    ;
  return os;
      e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
      e4:	c9                   	leave  
      e5:	c3                   	ret    

000000e6 <strcmp>:

int
strcmp(const char *p, const char *q)
{
      e6:	55                   	push   %ebp
      e7:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
      e9:	eb 08                	jmp    f3 <strcmp+0xd>
    p++, q++;
      eb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      ef:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
      f3:	8b 45 08             	mov    0x8(%ebp),%eax
      f6:	0f b6 00             	movzbl (%eax),%eax
      f9:	84 c0                	test   %al,%al
      fb:	74 10                	je     10d <strcmp+0x27>
      fd:	8b 45 08             	mov    0x8(%ebp),%eax
     100:	0f b6 10             	movzbl (%eax),%edx
     103:	8b 45 0c             	mov    0xc(%ebp),%eax
     106:	0f b6 00             	movzbl (%eax),%eax
     109:	38 c2                	cmp    %al,%dl
     10b:	74 de                	je     eb <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
     10d:	8b 45 08             	mov    0x8(%ebp),%eax
     110:	0f b6 00             	movzbl (%eax),%eax
     113:	0f b6 d0             	movzbl %al,%edx
     116:	8b 45 0c             	mov    0xc(%ebp),%eax
     119:	0f b6 00             	movzbl (%eax),%eax
     11c:	0f b6 c0             	movzbl %al,%eax
     11f:	29 c2                	sub    %eax,%edx
     121:	89 d0                	mov    %edx,%eax
}
     123:	5d                   	pop    %ebp
     124:	c3                   	ret    

00000125 <strlen>:

uint
strlen(char *s)
{
     125:	55                   	push   %ebp
     126:	89 e5                	mov    %esp,%ebp
     128:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     12b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     132:	eb 04                	jmp    138 <strlen+0x13>
     134:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     138:	8b 55 fc             	mov    -0x4(%ebp),%edx
     13b:	8b 45 08             	mov    0x8(%ebp),%eax
     13e:	01 d0                	add    %edx,%eax
     140:	0f b6 00             	movzbl (%eax),%eax
     143:	84 c0                	test   %al,%al
     145:	75 ed                	jne    134 <strlen+0xf>
    ;
  return n;
     147:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     14a:	c9                   	leave  
     14b:	c3                   	ret    

0000014c <memset>:

void*
memset(void *dst, int c, uint n)
{
     14c:	55                   	push   %ebp
     14d:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     14f:	8b 45 10             	mov    0x10(%ebp),%eax
     152:	50                   	push   %eax
     153:	ff 75 0c             	pushl  0xc(%ebp)
     156:	ff 75 08             	pushl  0x8(%ebp)
     159:	e8 32 ff ff ff       	call   90 <stosb>
     15e:	83 c4 0c             	add    $0xc,%esp
  return dst;
     161:	8b 45 08             	mov    0x8(%ebp),%eax
}
     164:	c9                   	leave  
     165:	c3                   	ret    

00000166 <strchr>:

char*
strchr(const char *s, char c)
{
     166:	55                   	push   %ebp
     167:	89 e5                	mov    %esp,%ebp
     169:	83 ec 04             	sub    $0x4,%esp
     16c:	8b 45 0c             	mov    0xc(%ebp),%eax
     16f:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     172:	eb 14                	jmp    188 <strchr+0x22>
    if(*s == c)
     174:	8b 45 08             	mov    0x8(%ebp),%eax
     177:	0f b6 00             	movzbl (%eax),%eax
     17a:	3a 45 fc             	cmp    -0x4(%ebp),%al
     17d:	75 05                	jne    184 <strchr+0x1e>
      return (char*)s;
     17f:	8b 45 08             	mov    0x8(%ebp),%eax
     182:	eb 13                	jmp    197 <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     184:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     188:	8b 45 08             	mov    0x8(%ebp),%eax
     18b:	0f b6 00             	movzbl (%eax),%eax
     18e:	84 c0                	test   %al,%al
     190:	75 e2                	jne    174 <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     192:	b8 00 00 00 00       	mov    $0x0,%eax
}
     197:	c9                   	leave  
     198:	c3                   	ret    

00000199 <gets>:

char*
gets(char *buf, int max)
{
     199:	55                   	push   %ebp
     19a:	89 e5                	mov    %esp,%ebp
     19c:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     19f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     1a6:	eb 42                	jmp    1ea <gets+0x51>
    cc = read(0, &c, 1);
     1a8:	83 ec 04             	sub    $0x4,%esp
     1ab:	6a 01                	push   $0x1
     1ad:	8d 45 ef             	lea    -0x11(%ebp),%eax
     1b0:	50                   	push   %eax
     1b1:	6a 00                	push   $0x0
     1b3:	e8 47 01 00 00       	call   2ff <read>
     1b8:	83 c4 10             	add    $0x10,%esp
     1bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     1be:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     1c2:	7e 33                	jle    1f7 <gets+0x5e>
      break;
    buf[i++] = c;
     1c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
     1c7:	8d 50 01             	lea    0x1(%eax),%edx
     1ca:	89 55 f4             	mov    %edx,-0xc(%ebp)
     1cd:	89 c2                	mov    %eax,%edx
     1cf:	8b 45 08             	mov    0x8(%ebp),%eax
     1d2:	01 c2                	add    %eax,%edx
     1d4:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     1d8:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     1da:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     1de:	3c 0a                	cmp    $0xa,%al
     1e0:	74 16                	je     1f8 <gets+0x5f>
     1e2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     1e6:	3c 0d                	cmp    $0xd,%al
     1e8:	74 0e                	je     1f8 <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     1ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
     1ed:	83 c0 01             	add    $0x1,%eax
     1f0:	3b 45 0c             	cmp    0xc(%ebp),%eax
     1f3:	7c b3                	jl     1a8 <gets+0xf>
     1f5:	eb 01                	jmp    1f8 <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     1f7:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     1f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
     1fb:	8b 45 08             	mov    0x8(%ebp),%eax
     1fe:	01 d0                	add    %edx,%eax
     200:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     203:	8b 45 08             	mov    0x8(%ebp),%eax
}
     206:	c9                   	leave  
     207:	c3                   	ret    

00000208 <stat>:

int
stat(char *n, struct stat *st)
{
     208:	55                   	push   %ebp
     209:	89 e5                	mov    %esp,%ebp
     20b:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     20e:	83 ec 08             	sub    $0x8,%esp
     211:	6a 00                	push   $0x0
     213:	ff 75 08             	pushl  0x8(%ebp)
     216:	e8 0c 01 00 00       	call   327 <open>
     21b:	83 c4 10             	add    $0x10,%esp
     21e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     221:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     225:	79 07                	jns    22e <stat+0x26>
    return -1;
     227:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     22c:	eb 25                	jmp    253 <stat+0x4b>
  r = fstat(fd, st);
     22e:	83 ec 08             	sub    $0x8,%esp
     231:	ff 75 0c             	pushl  0xc(%ebp)
     234:	ff 75 f4             	pushl  -0xc(%ebp)
     237:	e8 03 01 00 00       	call   33f <fstat>
     23c:	83 c4 10             	add    $0x10,%esp
     23f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     242:	83 ec 0c             	sub    $0xc,%esp
     245:	ff 75 f4             	pushl  -0xc(%ebp)
     248:	e8 c2 00 00 00       	call   30f <close>
     24d:	83 c4 10             	add    $0x10,%esp
  return r;
     250:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     253:	c9                   	leave  
     254:	c3                   	ret    

00000255 <atoi>:

int
atoi(const char *s)
{
     255:	55                   	push   %ebp
     256:	89 e5                	mov    %esp,%ebp
     258:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     25b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     262:	eb 25                	jmp    289 <atoi+0x34>
    n = n*10 + *s++ - '0';
     264:	8b 55 fc             	mov    -0x4(%ebp),%edx
     267:	89 d0                	mov    %edx,%eax
     269:	c1 e0 02             	shl    $0x2,%eax
     26c:	01 d0                	add    %edx,%eax
     26e:	01 c0                	add    %eax,%eax
     270:	89 c1                	mov    %eax,%ecx
     272:	8b 45 08             	mov    0x8(%ebp),%eax
     275:	8d 50 01             	lea    0x1(%eax),%edx
     278:	89 55 08             	mov    %edx,0x8(%ebp)
     27b:	0f b6 00             	movzbl (%eax),%eax
     27e:	0f be c0             	movsbl %al,%eax
     281:	01 c8                	add    %ecx,%eax
     283:	83 e8 30             	sub    $0x30,%eax
     286:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     289:	8b 45 08             	mov    0x8(%ebp),%eax
     28c:	0f b6 00             	movzbl (%eax),%eax
     28f:	3c 2f                	cmp    $0x2f,%al
     291:	7e 0a                	jle    29d <atoi+0x48>
     293:	8b 45 08             	mov    0x8(%ebp),%eax
     296:	0f b6 00             	movzbl (%eax),%eax
     299:	3c 39                	cmp    $0x39,%al
     29b:	7e c7                	jle    264 <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     29d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     2a0:	c9                   	leave  
     2a1:	c3                   	ret    

000002a2 <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     2a2:	55                   	push   %ebp
     2a3:	89 e5                	mov    %esp,%ebp
     2a5:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     2a8:	8b 45 08             	mov    0x8(%ebp),%eax
     2ab:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     2ae:	8b 45 0c             	mov    0xc(%ebp),%eax
     2b1:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     2b4:	eb 17                	jmp    2cd <memmove+0x2b>
    *dst++ = *src++;
     2b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
     2b9:	8d 50 01             	lea    0x1(%eax),%edx
     2bc:	89 55 fc             	mov    %edx,-0x4(%ebp)
     2bf:	8b 55 f8             	mov    -0x8(%ebp),%edx
     2c2:	8d 4a 01             	lea    0x1(%edx),%ecx
     2c5:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     2c8:	0f b6 12             	movzbl (%edx),%edx
     2cb:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     2cd:	8b 45 10             	mov    0x10(%ebp),%eax
     2d0:	8d 50 ff             	lea    -0x1(%eax),%edx
     2d3:	89 55 10             	mov    %edx,0x10(%ebp)
     2d6:	85 c0                	test   %eax,%eax
     2d8:	7f dc                	jg     2b6 <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     2da:	8b 45 08             	mov    0x8(%ebp),%eax
}
     2dd:	c9                   	leave  
     2de:	c3                   	ret    

000002df <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     2df:	b8 01 00 00 00       	mov    $0x1,%eax
     2e4:	cd 40                	int    $0x40
     2e6:	c3                   	ret    

000002e7 <exit>:
SYSCALL(exit)
     2e7:	b8 02 00 00 00       	mov    $0x2,%eax
     2ec:	cd 40                	int    $0x40
     2ee:	c3                   	ret    

000002ef <wait>:
SYSCALL(wait)
     2ef:	b8 03 00 00 00       	mov    $0x3,%eax
     2f4:	cd 40                	int    $0x40
     2f6:	c3                   	ret    

000002f7 <pipe>:
SYSCALL(pipe)
     2f7:	b8 04 00 00 00       	mov    $0x4,%eax
     2fc:	cd 40                	int    $0x40
     2fe:	c3                   	ret    

000002ff <read>:
SYSCALL(read)
     2ff:	b8 05 00 00 00       	mov    $0x5,%eax
     304:	cd 40                	int    $0x40
     306:	c3                   	ret    

00000307 <write>:
SYSCALL(write)
     307:	b8 10 00 00 00       	mov    $0x10,%eax
     30c:	cd 40                	int    $0x40
     30e:	c3                   	ret    

0000030f <close>:
SYSCALL(close)
     30f:	b8 15 00 00 00       	mov    $0x15,%eax
     314:	cd 40                	int    $0x40
     316:	c3                   	ret    

00000317 <kill>:
SYSCALL(kill)
     317:	b8 06 00 00 00       	mov    $0x6,%eax
     31c:	cd 40                	int    $0x40
     31e:	c3                   	ret    

0000031f <exec>:
SYSCALL(exec)
     31f:	b8 07 00 00 00       	mov    $0x7,%eax
     324:	cd 40                	int    $0x40
     326:	c3                   	ret    

00000327 <open>:
SYSCALL(open)
     327:	b8 0f 00 00 00       	mov    $0xf,%eax
     32c:	cd 40                	int    $0x40
     32e:	c3                   	ret    

0000032f <mknod>:
SYSCALL(mknod)
     32f:	b8 11 00 00 00       	mov    $0x11,%eax
     334:	cd 40                	int    $0x40
     336:	c3                   	ret    

00000337 <unlink>:
SYSCALL(unlink)
     337:	b8 12 00 00 00       	mov    $0x12,%eax
     33c:	cd 40                	int    $0x40
     33e:	c3                   	ret    

0000033f <fstat>:
SYSCALL(fstat)
     33f:	b8 08 00 00 00       	mov    $0x8,%eax
     344:	cd 40                	int    $0x40
     346:	c3                   	ret    

00000347 <link>:
SYSCALL(link)
     347:	b8 13 00 00 00       	mov    $0x13,%eax
     34c:	cd 40                	int    $0x40
     34e:	c3                   	ret    

0000034f <mkdir>:
SYSCALL(mkdir)
     34f:	b8 14 00 00 00       	mov    $0x14,%eax
     354:	cd 40                	int    $0x40
     356:	c3                   	ret    

00000357 <chdir>:
SYSCALL(chdir)
     357:	b8 09 00 00 00       	mov    $0x9,%eax
     35c:	cd 40                	int    $0x40
     35e:	c3                   	ret    

0000035f <dup>:
SYSCALL(dup)
     35f:	b8 0a 00 00 00       	mov    $0xa,%eax
     364:	cd 40                	int    $0x40
     366:	c3                   	ret    

00000367 <getpid>:
SYSCALL(getpid)
     367:	b8 0b 00 00 00       	mov    $0xb,%eax
     36c:	cd 40                	int    $0x40
     36e:	c3                   	ret    

0000036f <sbrk>:
SYSCALL(sbrk)
     36f:	b8 0c 00 00 00       	mov    $0xc,%eax
     374:	cd 40                	int    $0x40
     376:	c3                   	ret    

00000377 <sleep>:
SYSCALL(sleep)
     377:	b8 0d 00 00 00       	mov    $0xd,%eax
     37c:	cd 40                	int    $0x40
     37e:	c3                   	ret    

0000037f <uptime>:
SYSCALL(uptime)
     37f:	b8 0e 00 00 00       	mov    $0xe,%eax
     384:	cd 40                	int    $0x40
     386:	c3                   	ret    

00000387 <createwindow>:
SYSCALL(createwindow)
     387:	b8 16 00 00 00       	mov    $0x16,%eax
     38c:	cd 40                	int    $0x40
     38e:	c3                   	ret    

0000038f <repaintwindow>:
SYSCALL(repaintwindow)
     38f:	b8 17 00 00 00       	mov    $0x17,%eax
     394:	cd 40                	int    $0x40
     396:	c3                   	ret    

00000397 <getmessage>:
SYSCALL(getmessage)
     397:	b8 18 00 00 00       	mov    $0x18,%eax
     39c:	cd 40                	int    $0x40
     39e:	c3                   	ret    

0000039f <settimer>:
SYSCALL(settimer)
     39f:	b8 19 00 00 00       	mov    $0x19,%eax
     3a4:	cd 40                	int    $0x40
     3a6:	c3                   	ret    

000003a7 <updatewindow>:
SYSCALL(updatewindow)
     3a7:	b8 1a 00 00 00       	mov    $0x1a,%eax
     3ac:	cd 40                	int    $0x40
     3ae:	c3                   	ret    

000003af <destroywindow>:
SYSCALL(destroywindow)
     3af:	b8 1b 00 00 00       	mov    $0x1b,%eax
     3b4:	cd 40                	int    $0x40
     3b6:	c3                   	ret    

000003b7 <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     3b7:	55                   	push   %ebp
     3b8:	89 e5                	mov    %esp,%ebp
     3ba:	83 ec 18             	sub    $0x18,%esp
     3bd:	8b 45 0c             	mov    0xc(%ebp),%eax
     3c0:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     3c3:	83 ec 04             	sub    $0x4,%esp
     3c6:	6a 01                	push   $0x1
     3c8:	8d 45 f4             	lea    -0xc(%ebp),%eax
     3cb:	50                   	push   %eax
     3cc:	ff 75 08             	pushl  0x8(%ebp)
     3cf:	e8 33 ff ff ff       	call   307 <write>
     3d4:	83 c4 10             	add    $0x10,%esp
}
     3d7:	90                   	nop
     3d8:	c9                   	leave  
     3d9:	c3                   	ret    

000003da <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     3da:	55                   	push   %ebp
     3db:	89 e5                	mov    %esp,%ebp
     3dd:	53                   	push   %ebx
     3de:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     3e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     3e8:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     3ec:	74 17                	je     405 <printint+0x2b>
     3ee:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     3f2:	79 11                	jns    405 <printint+0x2b>
    neg = 1;
     3f4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     3fb:	8b 45 0c             	mov    0xc(%ebp),%eax
     3fe:	f7 d8                	neg    %eax
     400:	89 45 ec             	mov    %eax,-0x14(%ebp)
     403:	eb 06                	jmp    40b <printint+0x31>
  } else {
    x = xx;
     405:	8b 45 0c             	mov    0xc(%ebp),%eax
     408:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     40b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     412:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     415:	8d 41 01             	lea    0x1(%ecx),%eax
     418:	89 45 f4             	mov    %eax,-0xc(%ebp)
     41b:	8b 5d 10             	mov    0x10(%ebp),%ebx
     41e:	8b 45 ec             	mov    -0x14(%ebp),%eax
     421:	ba 00 00 00 00       	mov    $0x0,%edx
     426:	f7 f3                	div    %ebx
     428:	89 d0                	mov    %edx,%eax
     42a:	0f b6 80 00 e1 01 00 	movzbl 0x1e100(%eax),%eax
     431:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     435:	8b 5d 10             	mov    0x10(%ebp),%ebx
     438:	8b 45 ec             	mov    -0x14(%ebp),%eax
     43b:	ba 00 00 00 00       	mov    $0x0,%edx
     440:	f7 f3                	div    %ebx
     442:	89 45 ec             	mov    %eax,-0x14(%ebp)
     445:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     449:	75 c7                	jne    412 <printint+0x38>
  if(neg)
     44b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     44f:	74 2d                	je     47e <printint+0xa4>
    buf[i++] = '-';
     451:	8b 45 f4             	mov    -0xc(%ebp),%eax
     454:	8d 50 01             	lea    0x1(%eax),%edx
     457:	89 55 f4             	mov    %edx,-0xc(%ebp)
     45a:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     45f:	eb 1d                	jmp    47e <printint+0xa4>
    putc(fd, buf[i]);
     461:	8d 55 dc             	lea    -0x24(%ebp),%edx
     464:	8b 45 f4             	mov    -0xc(%ebp),%eax
     467:	01 d0                	add    %edx,%eax
     469:	0f b6 00             	movzbl (%eax),%eax
     46c:	0f be c0             	movsbl %al,%eax
     46f:	83 ec 08             	sub    $0x8,%esp
     472:	50                   	push   %eax
     473:	ff 75 08             	pushl  0x8(%ebp)
     476:	e8 3c ff ff ff       	call   3b7 <putc>
     47b:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     47e:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     482:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     486:	79 d9                	jns    461 <printint+0x87>
    putc(fd, buf[i]);
}
     488:	90                   	nop
     489:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     48c:	c9                   	leave  
     48d:	c3                   	ret    

0000048e <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     48e:	55                   	push   %ebp
     48f:	89 e5                	mov    %esp,%ebp
     491:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     494:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     49b:	8d 45 0c             	lea    0xc(%ebp),%eax
     49e:	83 c0 04             	add    $0x4,%eax
     4a1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     4a4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     4ab:	e9 59 01 00 00       	jmp    609 <printf+0x17b>
    c = fmt[i] & 0xff;
     4b0:	8b 55 0c             	mov    0xc(%ebp),%edx
     4b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
     4b6:	01 d0                	add    %edx,%eax
     4b8:	0f b6 00             	movzbl (%eax),%eax
     4bb:	0f be c0             	movsbl %al,%eax
     4be:	25 ff 00 00 00       	and    $0xff,%eax
     4c3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     4c6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     4ca:	75 2c                	jne    4f8 <printf+0x6a>
      if(c == '%'){
     4cc:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     4d0:	75 0c                	jne    4de <printf+0x50>
        state = '%';
     4d2:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     4d9:	e9 27 01 00 00       	jmp    605 <printf+0x177>
      } else {
        putc(fd, c);
     4de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     4e1:	0f be c0             	movsbl %al,%eax
     4e4:	83 ec 08             	sub    $0x8,%esp
     4e7:	50                   	push   %eax
     4e8:	ff 75 08             	pushl  0x8(%ebp)
     4eb:	e8 c7 fe ff ff       	call   3b7 <putc>
     4f0:	83 c4 10             	add    $0x10,%esp
     4f3:	e9 0d 01 00 00       	jmp    605 <printf+0x177>
      }
    } else if(state == '%'){
     4f8:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     4fc:	0f 85 03 01 00 00    	jne    605 <printf+0x177>
      if(c == 'd'){
     502:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     506:	75 1e                	jne    526 <printf+0x98>
        printint(fd, *ap, 10, 1);
     508:	8b 45 e8             	mov    -0x18(%ebp),%eax
     50b:	8b 00                	mov    (%eax),%eax
     50d:	6a 01                	push   $0x1
     50f:	6a 0a                	push   $0xa
     511:	50                   	push   %eax
     512:	ff 75 08             	pushl  0x8(%ebp)
     515:	e8 c0 fe ff ff       	call   3da <printint>
     51a:	83 c4 10             	add    $0x10,%esp
        ap++;
     51d:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     521:	e9 d8 00 00 00       	jmp    5fe <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     526:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     52a:	74 06                	je     532 <printf+0xa4>
     52c:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     530:	75 1e                	jne    550 <printf+0xc2>
        printint(fd, *ap, 16, 0);
     532:	8b 45 e8             	mov    -0x18(%ebp),%eax
     535:	8b 00                	mov    (%eax),%eax
     537:	6a 00                	push   $0x0
     539:	6a 10                	push   $0x10
     53b:	50                   	push   %eax
     53c:	ff 75 08             	pushl  0x8(%ebp)
     53f:	e8 96 fe ff ff       	call   3da <printint>
     544:	83 c4 10             	add    $0x10,%esp
        ap++;
     547:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     54b:	e9 ae 00 00 00       	jmp    5fe <printf+0x170>
      } else if(c == 's'){
     550:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     554:	75 43                	jne    599 <printf+0x10b>
        s = (char*)*ap;
     556:	8b 45 e8             	mov    -0x18(%ebp),%eax
     559:	8b 00                	mov    (%eax),%eax
     55b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     55e:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     562:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     566:	75 25                	jne    58d <printf+0xff>
          s = "(null)";
     568:	c7 45 f4 13 5e 01 00 	movl   $0x15e13,-0xc(%ebp)
        while(*s != 0){
     56f:	eb 1c                	jmp    58d <printf+0xff>
          putc(fd, *s);
     571:	8b 45 f4             	mov    -0xc(%ebp),%eax
     574:	0f b6 00             	movzbl (%eax),%eax
     577:	0f be c0             	movsbl %al,%eax
     57a:	83 ec 08             	sub    $0x8,%esp
     57d:	50                   	push   %eax
     57e:	ff 75 08             	pushl  0x8(%ebp)
     581:	e8 31 fe ff ff       	call   3b7 <putc>
     586:	83 c4 10             	add    $0x10,%esp
          s++;
     589:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     58d:	8b 45 f4             	mov    -0xc(%ebp),%eax
     590:	0f b6 00             	movzbl (%eax),%eax
     593:	84 c0                	test   %al,%al
     595:	75 da                	jne    571 <printf+0xe3>
     597:	eb 65                	jmp    5fe <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     599:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     59d:	75 1d                	jne    5bc <printf+0x12e>
        putc(fd, *ap);
     59f:	8b 45 e8             	mov    -0x18(%ebp),%eax
     5a2:	8b 00                	mov    (%eax),%eax
     5a4:	0f be c0             	movsbl %al,%eax
     5a7:	83 ec 08             	sub    $0x8,%esp
     5aa:	50                   	push   %eax
     5ab:	ff 75 08             	pushl  0x8(%ebp)
     5ae:	e8 04 fe ff ff       	call   3b7 <putc>
     5b3:	83 c4 10             	add    $0x10,%esp
        ap++;
     5b6:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     5ba:	eb 42                	jmp    5fe <printf+0x170>
      } else if(c == '%'){
     5bc:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     5c0:	75 17                	jne    5d9 <printf+0x14b>
        putc(fd, c);
     5c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     5c5:	0f be c0             	movsbl %al,%eax
     5c8:	83 ec 08             	sub    $0x8,%esp
     5cb:	50                   	push   %eax
     5cc:	ff 75 08             	pushl  0x8(%ebp)
     5cf:	e8 e3 fd ff ff       	call   3b7 <putc>
     5d4:	83 c4 10             	add    $0x10,%esp
     5d7:	eb 25                	jmp    5fe <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     5d9:	83 ec 08             	sub    $0x8,%esp
     5dc:	6a 25                	push   $0x25
     5de:	ff 75 08             	pushl  0x8(%ebp)
     5e1:	e8 d1 fd ff ff       	call   3b7 <putc>
     5e6:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     5e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     5ec:	0f be c0             	movsbl %al,%eax
     5ef:	83 ec 08             	sub    $0x8,%esp
     5f2:	50                   	push   %eax
     5f3:	ff 75 08             	pushl  0x8(%ebp)
     5f6:	e8 bc fd ff ff       	call   3b7 <putc>
     5fb:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     5fe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     605:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     609:	8b 55 0c             	mov    0xc(%ebp),%edx
     60c:	8b 45 f0             	mov    -0x10(%ebp),%eax
     60f:	01 d0                	add    %edx,%eax
     611:	0f b6 00             	movzbl (%eax),%eax
     614:	84 c0                	test   %al,%al
     616:	0f 85 94 fe ff ff    	jne    4b0 <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     61c:	90                   	nop
     61d:	c9                   	leave  
     61e:	c3                   	ret    

0000061f <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     61f:	55                   	push   %ebp
     620:	89 e5                	mov    %esp,%ebp
     622:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     625:	8b 45 08             	mov    0x8(%ebp),%eax
     628:	83 e8 08             	sub    $0x8,%eax
     62b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     62e:	a1 48 e5 01 00       	mov    0x1e548,%eax
     633:	89 45 fc             	mov    %eax,-0x4(%ebp)
     636:	eb 24                	jmp    65c <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     638:	8b 45 fc             	mov    -0x4(%ebp),%eax
     63b:	8b 00                	mov    (%eax),%eax
     63d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     640:	77 12                	ja     654 <free+0x35>
     642:	8b 45 f8             	mov    -0x8(%ebp),%eax
     645:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     648:	77 24                	ja     66e <free+0x4f>
     64a:	8b 45 fc             	mov    -0x4(%ebp),%eax
     64d:	8b 00                	mov    (%eax),%eax
     64f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     652:	77 1a                	ja     66e <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     654:	8b 45 fc             	mov    -0x4(%ebp),%eax
     657:	8b 00                	mov    (%eax),%eax
     659:	89 45 fc             	mov    %eax,-0x4(%ebp)
     65c:	8b 45 f8             	mov    -0x8(%ebp),%eax
     65f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     662:	76 d4                	jbe    638 <free+0x19>
     664:	8b 45 fc             	mov    -0x4(%ebp),%eax
     667:	8b 00                	mov    (%eax),%eax
     669:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     66c:	76 ca                	jbe    638 <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     66e:	8b 45 f8             	mov    -0x8(%ebp),%eax
     671:	8b 40 04             	mov    0x4(%eax),%eax
     674:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     67b:	8b 45 f8             	mov    -0x8(%ebp),%eax
     67e:	01 c2                	add    %eax,%edx
     680:	8b 45 fc             	mov    -0x4(%ebp),%eax
     683:	8b 00                	mov    (%eax),%eax
     685:	39 c2                	cmp    %eax,%edx
     687:	75 24                	jne    6ad <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     689:	8b 45 f8             	mov    -0x8(%ebp),%eax
     68c:	8b 50 04             	mov    0x4(%eax),%edx
     68f:	8b 45 fc             	mov    -0x4(%ebp),%eax
     692:	8b 00                	mov    (%eax),%eax
     694:	8b 40 04             	mov    0x4(%eax),%eax
     697:	01 c2                	add    %eax,%edx
     699:	8b 45 f8             	mov    -0x8(%ebp),%eax
     69c:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     69f:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6a2:	8b 00                	mov    (%eax),%eax
     6a4:	8b 10                	mov    (%eax),%edx
     6a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6a9:	89 10                	mov    %edx,(%eax)
     6ab:	eb 0a                	jmp    6b7 <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     6ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6b0:	8b 10                	mov    (%eax),%edx
     6b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6b5:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     6b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6ba:	8b 40 04             	mov    0x4(%eax),%eax
     6bd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     6c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6c7:	01 d0                	add    %edx,%eax
     6c9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     6cc:	75 20                	jne    6ee <free+0xcf>
    p->s.size += bp->s.size;
     6ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6d1:	8b 50 04             	mov    0x4(%eax),%edx
     6d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6d7:	8b 40 04             	mov    0x4(%eax),%eax
     6da:	01 c2                	add    %eax,%edx
     6dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6df:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     6e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6e5:	8b 10                	mov    (%eax),%edx
     6e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6ea:	89 10                	mov    %edx,(%eax)
     6ec:	eb 08                	jmp    6f6 <free+0xd7>
  } else
    p->s.ptr = bp;
     6ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6f1:	8b 55 f8             	mov    -0x8(%ebp),%edx
     6f4:	89 10                	mov    %edx,(%eax)
  freep = p;
     6f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6f9:	a3 48 e5 01 00       	mov    %eax,0x1e548
}
     6fe:	90                   	nop
     6ff:	c9                   	leave  
     700:	c3                   	ret    

00000701 <morecore>:

static Header*
morecore(uint nu)
{
     701:	55                   	push   %ebp
     702:	89 e5                	mov    %esp,%ebp
     704:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     707:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     70e:	77 07                	ja     717 <morecore+0x16>
    nu = 4096;
     710:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     717:	8b 45 08             	mov    0x8(%ebp),%eax
     71a:	c1 e0 03             	shl    $0x3,%eax
     71d:	83 ec 0c             	sub    $0xc,%esp
     720:	50                   	push   %eax
     721:	e8 49 fc ff ff       	call   36f <sbrk>
     726:	83 c4 10             	add    $0x10,%esp
     729:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     72c:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     730:	75 07                	jne    739 <morecore+0x38>
    return 0;
     732:	b8 00 00 00 00       	mov    $0x0,%eax
     737:	eb 26                	jmp    75f <morecore+0x5e>
  hp = (Header*)p;
     739:	8b 45 f4             	mov    -0xc(%ebp),%eax
     73c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     73f:	8b 45 f0             	mov    -0x10(%ebp),%eax
     742:	8b 55 08             	mov    0x8(%ebp),%edx
     745:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     748:	8b 45 f0             	mov    -0x10(%ebp),%eax
     74b:	83 c0 08             	add    $0x8,%eax
     74e:	83 ec 0c             	sub    $0xc,%esp
     751:	50                   	push   %eax
     752:	e8 c8 fe ff ff       	call   61f <free>
     757:	83 c4 10             	add    $0x10,%esp
  return freep;
     75a:	a1 48 e5 01 00       	mov    0x1e548,%eax
}
     75f:	c9                   	leave  
     760:	c3                   	ret    

00000761 <malloc>:

void*
malloc(uint nbytes)
{
     761:	55                   	push   %ebp
     762:	89 e5                	mov    %esp,%ebp
     764:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     767:	8b 45 08             	mov    0x8(%ebp),%eax
     76a:	83 c0 07             	add    $0x7,%eax
     76d:	c1 e8 03             	shr    $0x3,%eax
     770:	83 c0 01             	add    $0x1,%eax
     773:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     776:	a1 48 e5 01 00       	mov    0x1e548,%eax
     77b:	89 45 f0             	mov    %eax,-0x10(%ebp)
     77e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     782:	75 23                	jne    7a7 <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     784:	c7 45 f0 40 e5 01 00 	movl   $0x1e540,-0x10(%ebp)
     78b:	8b 45 f0             	mov    -0x10(%ebp),%eax
     78e:	a3 48 e5 01 00       	mov    %eax,0x1e548
     793:	a1 48 e5 01 00       	mov    0x1e548,%eax
     798:	a3 40 e5 01 00       	mov    %eax,0x1e540
    base.s.size = 0;
     79d:	c7 05 44 e5 01 00 00 	movl   $0x0,0x1e544
     7a4:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     7a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7aa:	8b 00                	mov    (%eax),%eax
     7ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     7af:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7b2:	8b 40 04             	mov    0x4(%eax),%eax
     7b5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     7b8:	72 4d                	jb     807 <malloc+0xa6>
      if(p->s.size == nunits)
     7ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7bd:	8b 40 04             	mov    0x4(%eax),%eax
     7c0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     7c3:	75 0c                	jne    7d1 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     7c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7c8:	8b 10                	mov    (%eax),%edx
     7ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7cd:	89 10                	mov    %edx,(%eax)
     7cf:	eb 26                	jmp    7f7 <malloc+0x96>
      else {
        p->s.size -= nunits;
     7d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7d4:	8b 40 04             	mov    0x4(%eax),%eax
     7d7:	2b 45 ec             	sub    -0x14(%ebp),%eax
     7da:	89 c2                	mov    %eax,%edx
     7dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7df:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     7e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7e5:	8b 40 04             	mov    0x4(%eax),%eax
     7e8:	c1 e0 03             	shl    $0x3,%eax
     7eb:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     7ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7f1:	8b 55 ec             	mov    -0x14(%ebp),%edx
     7f4:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     7f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7fa:	a3 48 e5 01 00       	mov    %eax,0x1e548
      return (void*)(p + 1);
     7ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
     802:	83 c0 08             	add    $0x8,%eax
     805:	eb 3b                	jmp    842 <malloc+0xe1>
    }
    if(p == freep)
     807:	a1 48 e5 01 00       	mov    0x1e548,%eax
     80c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     80f:	75 1e                	jne    82f <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     811:	83 ec 0c             	sub    $0xc,%esp
     814:	ff 75 ec             	pushl  -0x14(%ebp)
     817:	e8 e5 fe ff ff       	call   701 <morecore>
     81c:	83 c4 10             	add    $0x10,%esp
     81f:	89 45 f4             	mov    %eax,-0xc(%ebp)
     822:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     826:	75 07                	jne    82f <malloc+0xce>
        return 0;
     828:	b8 00 00 00 00       	mov    $0x0,%eax
     82d:	eb 13                	jmp    842 <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     82f:	8b 45 f4             	mov    -0xc(%ebp),%eax
     832:	89 45 f0             	mov    %eax,-0x10(%ebp)
     835:	8b 45 f4             	mov    -0xc(%ebp),%eax
     838:	8b 00                	mov    (%eax),%eax
     83a:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     83d:	e9 6d ff ff ff       	jmp    7af <malloc+0x4e>
}
     842:	c9                   	leave  
     843:	c3                   	ret    

00000844 <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     844:	55                   	push   %ebp
     845:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     847:	a1 4c e5 01 00       	mov    0x1e54c,%eax
     84c:	83 c0 01             	add    $0x1,%eax
     84f:	a3 4c e5 01 00       	mov    %eax,0x1e54c
    g_seed = (214013*g_seed+2531011);
     854:	a1 4c e5 01 00       	mov    0x1e54c,%eax
     859:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     85f:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     864:	a3 4c e5 01 00       	mov    %eax,0x1e54c
    return (g_seed>>16)&0x7FFF;
     869:	a1 4c e5 01 00       	mov    0x1e54c,%eax
     86e:	c1 e8 10             	shr    $0x10,%eax
     871:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     876:	5d                   	pop    %ebp
     877:	c3                   	ret    

00000878 <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     878:	55                   	push   %ebp
     879:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     87b:	d9 45 08             	flds   0x8(%ebp)
     87e:	d9 ee                	fldz   
     880:	d9 c9                	fxch   %st(1)
     882:	df e9                	fucomip %st(1),%st
     884:	dd d8                	fstp   %st(0)
     886:	76 05                	jbe    88d <abs+0x15>
     888:	d9 45 08             	flds   0x8(%ebp)
     88b:	eb 05                	jmp    892 <abs+0x1a>
	return -x;
     88d:	d9 45 08             	flds   0x8(%ebp)
     890:	d9 e0                	fchs   
}
     892:	5d                   	pop    %ebp
     893:	c3                   	ret    

00000894 <pow>:

float pow(float a, int b)
{
     894:	55                   	push   %ebp
     895:	89 e5                	mov    %esp,%ebp
     897:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     89a:	d9 45 08             	flds   0x8(%ebp)
     89d:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     8a0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     8a4:	7e 17                	jle    8bd <pow+0x29>
		while (--b)
     8a6:	eb 09                	jmp    8b1 <pow+0x1d>
			r *= a;
     8a8:	d9 45 fc             	flds   -0x4(%ebp)
     8ab:	d8 4d 08             	fmuls  0x8(%ebp)
     8ae:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     8b1:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     8b5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     8b9:	75 ed                	jne    8a8 <pow+0x14>
     8bb:	eb 2a                	jmp    8e7 <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     8bd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     8c1:	79 1f                	jns    8e2 <pow+0x4e>
		while (++b)
     8c3:	eb 09                	jmp    8ce <pow+0x3a>
			r *= a;
     8c5:	d9 45 fc             	flds   -0x4(%ebp)
     8c8:	d8 4d 08             	fmuls  0x8(%ebp)
     8cb:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     8ce:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     8d2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     8d6:	75 ed                	jne    8c5 <pow+0x31>
			r *= a;
		r = 1.0 / r;
     8d8:	d9 e8                	fld1   
     8da:	d8 75 fc             	fdivs  -0x4(%ebp)
     8dd:	d9 5d fc             	fstps  -0x4(%ebp)
     8e0:	eb 05                	jmp    8e7 <pow+0x53>
	}
	else r = 0;
     8e2:	d9 ee                	fldz   
     8e4:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     8e7:	d9 45 fc             	flds   -0x4(%ebp)
}
     8ea:	c9                   	leave  
     8eb:	c3                   	ret    

000008ec <sqrt>:

float sqrt(float number) {
     8ec:	55                   	push   %ebp
     8ed:	89 e5                	mov    %esp,%ebp
     8ef:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     8f2:	d9 ee                	fldz   
     8f4:	d9 45 08             	flds   0x8(%ebp)
     8f7:	d9 c9                	fxch   %st(1)
     8f9:	df e9                	fucomip %st(1),%st
     8fb:	dd d8                	fstp   %st(0)
     8fd:	76 06                	jbe    905 <sqrt+0x19>
		return -1;
     8ff:	d9 e8                	fld1   
     901:	d9 e0                	fchs   
     903:	eb 3a                	jmp    93f <sqrt+0x53>
	}

	new_guess = 1;
     905:	d9 e8                	fld1   
     907:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
     90a:	d9 45 fc             	flds   -0x4(%ebp)
     90d:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
     910:	d9 45 08             	flds   0x8(%ebp)
     913:	d8 75 f8             	fdivs  -0x8(%ebp)
     916:	d8 45 f8             	fadds  -0x8(%ebp)
     919:	d9 05 20 5e 01 00    	flds   0x15e20
     91f:	de f9                	fdivrp %st,%st(1)
     921:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
     924:	d9 45 fc             	flds   -0x4(%ebp)
     927:	d9 45 f8             	flds   -0x8(%ebp)
     92a:	df e9                	fucomip %st(1),%st
     92c:	dd d8                	fstp   %st(0)
     92e:	7a da                	jp     90a <sqrt+0x1e>
     930:	d9 45 fc             	flds   -0x4(%ebp)
     933:	d9 45 f8             	flds   -0x8(%ebp)
     936:	df e9                	fucomip %st(1),%st
     938:	dd d8                	fstp   %st(0)
     93a:	75 ce                	jne    90a <sqrt+0x1e>

	return new_guess;
     93c:	d9 45 fc             	flds   -0x4(%ebp)
}
     93f:	c9                   	leave  
     940:	c3                   	ret    

00000941 <cos>:

float cos(float x)
{
     941:	55                   	push   %ebp
     942:	89 e5                	mov    %esp,%ebp
     944:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     947:	d9 e8                	fld1   
     949:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     94c:	d9 45 08             	flds   0x8(%ebp)
     94f:	dd 05 28 5e 01 00    	fldl   0x15e28
     955:	d9 c9                	fxch   %st(1)
     957:	df e9                	fucomip %st(1),%st
     959:	dd d8                	fstp   %st(0)
     95b:	77 0f                	ja     96c <cos+0x2b>
     95d:	d9 45 08             	flds   0x8(%ebp)
     960:	dd 05 30 5e 01 00    	fldl   0x15e30
     966:	df e9                	fucomip %st(1),%st
     968:	dd d8                	fstp   %st(0)
     96a:	76 3c                	jbe    9a8 <cos+0x67>
     96c:	d9 45 08             	flds   0x8(%ebp)
     96f:	d9 45 08             	flds   0x8(%ebp)
     972:	dd 05 28 5e 01 00    	fldl   0x15e28
     978:	de f9                	fdivrp %st,%st(1)
     97a:	d9 7d e2             	fnstcw -0x1e(%ebp)
     97d:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     981:	b4 0c                	mov    $0xc,%ah
     983:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     987:	d9 6d e0             	fldcw  -0x20(%ebp)
     98a:	db 5d dc             	fistpl -0x24(%ebp)
     98d:	d9 6d e2             	fldcw  -0x1e(%ebp)
     990:	8b 45 dc             	mov    -0x24(%ebp),%eax
     993:	01 c0                	add    %eax,%eax
     995:	89 45 d8             	mov    %eax,-0x28(%ebp)
     998:	db 45 d8             	fildl  -0x28(%ebp)
     99b:	dd 05 38 5e 01 00    	fldl   0x15e38
     9a1:	de c9                	fmulp  %st,%st(1)
     9a3:	de e9                	fsubrp %st,%st(1)
     9a5:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     9a8:	d9 45 08             	flds   0x8(%ebp)
     9ab:	dd 05 38 5e 01 00    	fldl   0x15e38
     9b1:	d9 c9                	fxch   %st(1)
     9b3:	df e9                	fucomip %st(1),%st
     9b5:	dd d8                	fstp   %st(0)
     9b7:	76 0e                	jbe    9c7 <cos+0x86>
     9b9:	d9 45 08             	flds   0x8(%ebp)
     9bc:	dd 05 28 5e 01 00    	fldl   0x15e28
     9c2:	de e9                	fsubrp %st,%st(1)
     9c4:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     9c7:	d9 45 08             	flds   0x8(%ebp)
     9ca:	dd 05 40 5e 01 00    	fldl   0x15e40
     9d0:	df e9                	fucomip %st(1),%st
     9d2:	dd d8                	fstp   %st(0)
     9d4:	76 0e                	jbe    9e4 <cos+0xa3>
     9d6:	d9 45 08             	flds   0x8(%ebp)
     9d9:	dd 05 28 5e 01 00    	fldl   0x15e28
     9df:	de c1                	faddp  %st,%st(1)
     9e1:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     9e4:	d9 45 08             	flds   0x8(%ebp)
     9e7:	dd 05 48 5e 01 00    	fldl   0x15e48
     9ed:	d9 c9                	fxch   %st(1)
     9ef:	df e9                	fucomip %st(1),%st
     9f1:	dd d8                	fstp   %st(0)
     9f3:	76 16                	jbe    a0b <cos+0xca>
    {
        x -= PI;
     9f5:	d9 45 08             	flds   0x8(%ebp)
     9f8:	dd 05 38 5e 01 00    	fldl   0x15e38
     9fe:	de e9                	fsubrp %st,%st(1)
     a00:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     a03:	d9 45 f4             	flds   -0xc(%ebp)
     a06:	d9 e0                	fchs   
     a08:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     a0b:	d9 45 08             	flds   0x8(%ebp)
     a0e:	dd 05 50 5e 01 00    	fldl   0x15e50
     a14:	df e9                	fucomip %st(1),%st
     a16:	dd d8                	fstp   %st(0)
     a18:	76 16                	jbe    a30 <cos+0xef>
    {
        x += PI;
     a1a:	d9 45 08             	flds   0x8(%ebp)
     a1d:	dd 05 38 5e 01 00    	fldl   0x15e38
     a23:	de c1                	faddp  %st,%st(1)
     a25:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     a28:	d9 45 f4             	flds   -0xc(%ebp)
     a2b:	d9 e0                	fchs   
     a2d:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
     a30:	d9 45 08             	flds   0x8(%ebp)
     a33:	dd 05 58 5e 01 00    	fldl   0x15e58
     a39:	d9 c9                	fxch   %st(1)
     a3b:	df e9                	fucomip %st(1),%st
     a3d:	dd d8                	fstp   %st(0)
     a3f:	76 28                	jbe    a69 <cos+0x128>
     a41:	d9 45 08             	flds   0x8(%ebp)
     a44:	dd 05 48 5e 01 00    	fldl   0x15e48
     a4a:	de e1                	fsubp  %st,%st(1)
     a4c:	d9 5d e4             	fstps  -0x1c(%ebp)
     a4f:	d9 45 e4             	flds   -0x1c(%ebp)
     a52:	83 ec 0c             	sub    $0xc,%esp
     a55:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     a59:	d9 1c 24             	fstps  (%esp)
     a5c:	e8 83 00 00 00       	call   ae4 <sin>
     a61:	83 c4 10             	add    $0x10,%esp
     a64:	d8 4d f4             	fmuls  -0xc(%ebp)
     a67:	eb 79                	jmp    ae2 <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
     a69:	83 ec 08             	sub    $0x8,%esp
     a6c:	6a 02                	push   $0x2
     a6e:	ff 75 08             	pushl  0x8(%ebp)
     a71:	e8 1e fe ff ff       	call   894 <pow>
     a76:	83 c4 10             	add    $0x10,%esp
     a79:	d9 05 20 5e 01 00    	flds   0x15e20
     a7f:	de f9                	fdivrp %st,%st(1)
     a81:	d9 e8                	fld1   
     a83:	de e1                	fsubp  %st,%st(1)
     a85:	d9 5d d8             	fstps  -0x28(%ebp)
     a88:	83 ec 08             	sub    $0x8,%esp
     a8b:	6a 04                	push   $0x4
     a8d:	ff 75 08             	pushl  0x8(%ebp)
     a90:	e8 ff fd ff ff       	call   894 <pow>
     a95:	83 c4 10             	add    $0x10,%esp
     a98:	d9 05 60 5e 01 00    	flds   0x15e60
     a9e:	de f9                	fdivrp %st,%st(1)
     aa0:	d8 45 d8             	fadds  -0x28(%ebp)
     aa3:	d9 5d d8             	fstps  -0x28(%ebp)
     aa6:	83 ec 08             	sub    $0x8,%esp
     aa9:	6a 06                	push   $0x6
     aab:	ff 75 08             	pushl  0x8(%ebp)
     aae:	e8 e1 fd ff ff       	call   894 <pow>
     ab3:	83 c4 10             	add    $0x10,%esp
     ab6:	d9 05 64 5e 01 00    	flds   0x15e64
     abc:	de f9                	fdivrp %st,%st(1)
     abe:	d8 6d d8             	fsubrs -0x28(%ebp)
     ac1:	d9 5d d8             	fstps  -0x28(%ebp)
     ac4:	83 ec 08             	sub    $0x8,%esp
     ac7:	6a 08                	push   $0x8
     ac9:	ff 75 08             	pushl  0x8(%ebp)
     acc:	e8 c3 fd ff ff       	call   894 <pow>
     ad1:	83 c4 10             	add    $0x10,%esp
     ad4:	d9 05 68 5e 01 00    	flds   0x15e68
     ada:	de f9                	fdivrp %st,%st(1)
     adc:	d8 45 d8             	fadds  -0x28(%ebp)
     adf:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     ae2:	c9                   	leave  
     ae3:	c3                   	ret    

00000ae4 <sin>:

float sin(float x)
{
     ae4:	55                   	push   %ebp
     ae5:	89 e5                	mov    %esp,%ebp
     ae7:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     aea:	d9 e8                	fld1   
     aec:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     aef:	d9 45 08             	flds   0x8(%ebp)
     af2:	dd 05 28 5e 01 00    	fldl   0x15e28
     af8:	d9 c9                	fxch   %st(1)
     afa:	df e9                	fucomip %st(1),%st
     afc:	dd d8                	fstp   %st(0)
     afe:	77 0f                	ja     b0f <sin+0x2b>
     b00:	d9 45 08             	flds   0x8(%ebp)
     b03:	dd 05 30 5e 01 00    	fldl   0x15e30
     b09:	df e9                	fucomip %st(1),%st
     b0b:	dd d8                	fstp   %st(0)
     b0d:	76 3c                	jbe    b4b <sin+0x67>
     b0f:	d9 45 08             	flds   0x8(%ebp)
     b12:	d9 45 08             	flds   0x8(%ebp)
     b15:	dd 05 28 5e 01 00    	fldl   0x15e28
     b1b:	de f9                	fdivrp %st,%st(1)
     b1d:	d9 7d e2             	fnstcw -0x1e(%ebp)
     b20:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     b24:	b4 0c                	mov    $0xc,%ah
     b26:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     b2a:	d9 6d e0             	fldcw  -0x20(%ebp)
     b2d:	db 5d dc             	fistpl -0x24(%ebp)
     b30:	d9 6d e2             	fldcw  -0x1e(%ebp)
     b33:	8b 45 dc             	mov    -0x24(%ebp),%eax
     b36:	01 c0                	add    %eax,%eax
     b38:	89 45 d8             	mov    %eax,-0x28(%ebp)
     b3b:	db 45 d8             	fildl  -0x28(%ebp)
     b3e:	dd 05 38 5e 01 00    	fldl   0x15e38
     b44:	de c9                	fmulp  %st,%st(1)
     b46:	de e9                	fsubrp %st,%st(1)
     b48:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     b4b:	d9 45 08             	flds   0x8(%ebp)
     b4e:	dd 05 38 5e 01 00    	fldl   0x15e38
     b54:	d9 c9                	fxch   %st(1)
     b56:	df e9                	fucomip %st(1),%st
     b58:	dd d8                	fstp   %st(0)
     b5a:	76 0e                	jbe    b6a <sin+0x86>
     b5c:	d9 45 08             	flds   0x8(%ebp)
     b5f:	dd 05 28 5e 01 00    	fldl   0x15e28
     b65:	de e9                	fsubrp %st,%st(1)
     b67:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     b6a:	d9 45 08             	flds   0x8(%ebp)
     b6d:	dd 05 40 5e 01 00    	fldl   0x15e40
     b73:	df e9                	fucomip %st(1),%st
     b75:	dd d8                	fstp   %st(0)
     b77:	76 0e                	jbe    b87 <sin+0xa3>
     b79:	d9 45 08             	flds   0x8(%ebp)
     b7c:	dd 05 28 5e 01 00    	fldl   0x15e28
     b82:	de c1                	faddp  %st,%st(1)
     b84:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     b87:	d9 45 08             	flds   0x8(%ebp)
     b8a:	dd 05 48 5e 01 00    	fldl   0x15e48
     b90:	d9 c9                	fxch   %st(1)
     b92:	df e9                	fucomip %st(1),%st
     b94:	dd d8                	fstp   %st(0)
     b96:	76 16                	jbe    bae <sin+0xca>
    {
        x -= PI;
     b98:	d9 45 08             	flds   0x8(%ebp)
     b9b:	dd 05 38 5e 01 00    	fldl   0x15e38
     ba1:	de e9                	fsubrp %st,%st(1)
     ba3:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     ba6:	d9 45 f4             	flds   -0xc(%ebp)
     ba9:	d9 e0                	fchs   
     bab:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     bae:	d9 45 08             	flds   0x8(%ebp)
     bb1:	dd 05 50 5e 01 00    	fldl   0x15e50
     bb7:	df e9                	fucomip %st(1),%st
     bb9:	dd d8                	fstp   %st(0)
     bbb:	76 16                	jbe    bd3 <sin+0xef>
    {
        x += PI;
     bbd:	d9 45 08             	flds   0x8(%ebp)
     bc0:	dd 05 38 5e 01 00    	fldl   0x15e38
     bc6:	de c1                	faddp  %st,%st(1)
     bc8:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     bcb:	d9 45 f4             	flds   -0xc(%ebp)
     bce:	d9 e0                	fchs   
     bd0:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
     bd3:	d9 ee                	fldz   
     bd5:	d9 45 08             	flds   0x8(%ebp)
     bd8:	d9 c9                	fxch   %st(1)
     bda:	df e9                	fucomip %st(1),%st
     bdc:	dd d8                	fstp   %st(0)
     bde:	76 10                	jbe    bf0 <sin+0x10c>
    {
        x *= -1;
     be0:	d9 45 08             	flds   0x8(%ebp)
     be3:	d9 e0                	fchs   
     be5:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     be8:	d9 45 f4             	flds   -0xc(%ebp)
     beb:	d9 e0                	fchs   
     bed:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
     bf0:	d9 45 08             	flds   0x8(%ebp)
     bf3:	dd 05 58 5e 01 00    	fldl   0x15e58
     bf9:	d9 c9                	fxch   %st(1)
     bfb:	df e9                	fucomip %st(1),%st
     bfd:	dd d8                	fstp   %st(0)
     bff:	76 28                	jbe    c29 <sin+0x145>
     c01:	d9 45 08             	flds   0x8(%ebp)
     c04:	dd 05 48 5e 01 00    	fldl   0x15e48
     c0a:	de e1                	fsubp  %st,%st(1)
     c0c:	d9 5d e4             	fstps  -0x1c(%ebp)
     c0f:	d9 45 e4             	flds   -0x1c(%ebp)
     c12:	83 ec 0c             	sub    $0xc,%esp
     c15:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     c19:	d9 1c 24             	fstps  (%esp)
     c1c:	e8 20 fd ff ff       	call   941 <cos>
     c21:	83 c4 10             	add    $0x10,%esp
     c24:	d8 4d f4             	fmuls  -0xc(%ebp)
     c27:	eb 7a                	jmp    ca3 <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
     c29:	83 ec 08             	sub    $0x8,%esp
     c2c:	6a 03                	push   $0x3
     c2e:	ff 75 08             	pushl  0x8(%ebp)
     c31:	e8 5e fc ff ff       	call   894 <pow>
     c36:	83 c4 10             	add    $0x10,%esp
     c39:	d9 05 6c 5e 01 00    	flds   0x15e6c
     c3f:	de f9                	fdivrp %st,%st(1)
     c41:	d9 45 08             	flds   0x8(%ebp)
     c44:	de e1                	fsubp  %st,%st(1)
     c46:	d9 5d d8             	fstps  -0x28(%ebp)
     c49:	83 ec 08             	sub    $0x8,%esp
     c4c:	6a 05                	push   $0x5
     c4e:	ff 75 08             	pushl  0x8(%ebp)
     c51:	e8 3e fc ff ff       	call   894 <pow>
     c56:	83 c4 10             	add    $0x10,%esp
     c59:	d9 05 70 5e 01 00    	flds   0x15e70
     c5f:	de f9                	fdivrp %st,%st(1)
     c61:	d8 45 d8             	fadds  -0x28(%ebp)
     c64:	d9 5d d8             	fstps  -0x28(%ebp)
     c67:	83 ec 08             	sub    $0x8,%esp
     c6a:	6a 07                	push   $0x7
     c6c:	ff 75 08             	pushl  0x8(%ebp)
     c6f:	e8 20 fc ff ff       	call   894 <pow>
     c74:	83 c4 10             	add    $0x10,%esp
     c77:	d9 05 74 5e 01 00    	flds   0x15e74
     c7d:	de f9                	fdivrp %st,%st(1)
     c7f:	d8 6d d8             	fsubrs -0x28(%ebp)
     c82:	d9 5d d8             	fstps  -0x28(%ebp)
     c85:	83 ec 08             	sub    $0x8,%esp
     c88:	6a 09                	push   $0x9
     c8a:	ff 75 08             	pushl  0x8(%ebp)
     c8d:	e8 02 fc ff ff       	call   894 <pow>
     c92:	83 c4 10             	add    $0x10,%esp
     c95:	d9 05 78 5e 01 00    	flds   0x15e78
     c9b:	de f9                	fdivrp %st,%st(1)
     c9d:	d8 45 d8             	fadds  -0x28(%ebp)
     ca0:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     ca3:	c9                   	leave  
     ca4:	c3                   	ret    

00000ca5 <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
     ca5:	55                   	push   %ebp
     ca6:	89 e5                	mov    %esp,%ebp
     ca8:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
     cab:	83 ec 04             	sub    $0x4,%esp
     cae:	6a 0e                	push   $0xe
     cb0:	ff 75 0c             	pushl  0xc(%ebp)
     cb3:	ff 75 08             	pushl  0x8(%ebp)
     cb6:	e8 44 f6 ff ff       	call   2ff <read>
     cbb:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
     cbe:	83 ec 04             	sub    $0x4,%esp
     cc1:	6a 28                	push   $0x28
     cc3:	ff 75 10             	pushl  0x10(%ebp)
     cc6:	ff 75 08             	pushl  0x8(%ebp)
     cc9:	e8 31 f6 ff ff       	call   2ff <read>
     cce:	83 c4 10             	add    $0x10,%esp
}
     cd1:	90                   	nop
     cd2:	c9                   	leave  
     cd3:	c3                   	ret    

00000cd4 <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
     cd4:	55                   	push   %ebp
     cd5:	89 e5                	mov    %esp,%ebp
     cd7:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     cdd:	83 ec 08             	sub    $0x8,%esp
     ce0:	6a 00                	push   $0x0
     ce2:	ff 75 08             	pushl  0x8(%ebp)
     ce5:	e8 3d f6 ff ff       	call   327 <open>
     cea:	83 c4 10             	add    $0x10,%esp
     ced:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     cf0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     cf4:	79 0a                	jns    d00 <readBitmapFile+0x2c>
        return -1;
     cf6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     cfb:	e9 6e 01 00 00       	jmp    e6e <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     d00:	83 ec 04             	sub    $0x4,%esp
     d03:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     d06:	50                   	push   %eax
     d07:	8d 45 ca             	lea    -0x36(%ebp),%eax
     d0a:	50                   	push   %eax
     d0b:	ff 75 ec             	pushl  -0x14(%ebp)
     d0e:	e8 92 ff ff ff       	call   ca5 <readBitmapHeader>
     d13:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     d16:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     d19:	83 e8 36             	sub    $0x36,%eax
     d1c:	83 ec 04             	sub    $0x4,%esp
     d1f:	50                   	push   %eax
     d20:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     d26:	50                   	push   %eax
     d27:	ff 75 ec             	pushl  -0x14(%ebp)
     d2a:	e8 d0 f5 ff ff       	call   2ff <read>
     d2f:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     d32:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     d35:	8b 45 14             	mov    0x14(%ebp),%eax
     d38:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     d3a:	8b 55 aa             	mov    -0x56(%ebp),%edx
     d3d:	8b 45 10             	mov    0x10(%ebp),%eax
     d40:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     d42:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     d45:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     d48:	8b 45 aa             	mov    -0x56(%ebp),%eax
     d4b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     d4e:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     d52:	0f b7 c0             	movzwl %ax,%eax
     d55:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
     d58:	8b 45 e8             	mov    -0x18(%ebp),%eax
     d5b:	0f af 45 e0          	imul   -0x20(%ebp),%eax
     d5f:	8d 50 07             	lea    0x7(%eax),%edx
     d62:	85 c0                	test   %eax,%eax
     d64:	0f 48 c2             	cmovs  %edx,%eax
     d67:	c1 f8 03             	sar    $0x3,%eax
     d6a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     d6d:	8b 45 0c             	mov    0xc(%ebp),%eax
     d70:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     d73:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     d76:	83 e8 01             	sub    $0x1,%eax
     d79:	89 45 f4             	mov    %eax,-0xc(%ebp)
     d7c:	e9 d0 00 00 00       	jmp    e51 <readBitmapFile+0x17d>
        if (bits == 32) {
     d81:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
     d85:	75 22                	jne    da9 <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     d87:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d8a:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     d8e:	89 c2                	mov    %eax,%edx
     d90:	8b 45 d8             	mov    -0x28(%ebp),%eax
     d93:	01 d0                	add    %edx,%eax
     d95:	83 ec 04             	sub    $0x4,%esp
     d98:	ff 75 dc             	pushl  -0x24(%ebp)
     d9b:	50                   	push   %eax
     d9c:	ff 75 ec             	pushl  -0x14(%ebp)
     d9f:	e8 5b f5 ff ff       	call   2ff <read>
     da4:	83 c4 10             	add    $0x10,%esp
     da7:	eb 65                	jmp    e0e <readBitmapFile+0x13a>
        } else {
            int j = 0;
     da9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     db0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     db7:	eb 4d                	jmp    e06 <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
     db9:	8b 45 f4             	mov    -0xc(%ebp),%eax
     dbc:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     dc0:	c1 e0 02             	shl    $0x2,%eax
     dc3:	89 c2                	mov    %eax,%edx
     dc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
     dc8:	c1 e0 02             	shl    $0x2,%eax
     dcb:	01 c2                	add    %eax,%edx
     dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
     dd0:	01 d0                	add    %edx,%eax
     dd2:	83 ec 04             	sub    $0x4,%esp
     dd5:	6a 03                	push   $0x3
     dd7:	50                   	push   %eax
     dd8:	ff 75 ec             	pushl  -0x14(%ebp)
     ddb:	e8 1f f5 ff ff       	call   2ff <read>
     de0:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
     de3:	8b 45 f4             	mov    -0xc(%ebp),%eax
     de6:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     dea:	c1 e0 02             	shl    $0x2,%eax
     ded:	89 c2                	mov    %eax,%edx
     def:	8b 45 f0             	mov    -0x10(%ebp),%eax
     df2:	c1 e0 02             	shl    $0x2,%eax
     df5:	01 d0                	add    %edx,%eax
     df7:	8d 50 03             	lea    0x3(%eax),%edx
     dfa:	8b 45 d8             	mov    -0x28(%ebp),%eax
     dfd:	01 d0                	add    %edx,%eax
     dff:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     e02:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     e06:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e09:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     e0c:	7c ab                	jl     db9 <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
     e0e:	8b 45 dc             	mov    -0x24(%ebp),%eax
     e11:	99                   	cltd   
     e12:	c1 ea 1e             	shr    $0x1e,%edx
     e15:	01 d0                	add    %edx,%eax
     e17:	83 e0 03             	and    $0x3,%eax
     e1a:	29 d0                	sub    %edx,%eax
     e1c:	85 c0                	test   %eax,%eax
     e1e:	7e 2d                	jle    e4d <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     e20:	8b 45 dc             	mov    -0x24(%ebp),%eax
     e23:	99                   	cltd   
     e24:	c1 ea 1e             	shr    $0x1e,%edx
     e27:	01 d0                	add    %edx,%eax
     e29:	83 e0 03             	and    $0x3,%eax
     e2c:	29 d0                	sub    %edx,%eax
     e2e:	ba 04 00 00 00       	mov    $0x4,%edx
     e33:	29 c2                	sub    %eax,%edx
     e35:	89 d0                	mov    %edx,%eax
     e37:	83 ec 04             	sub    $0x4,%esp
     e3a:	50                   	push   %eax
     e3b:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     e41:	50                   	push   %eax
     e42:	ff 75 ec             	pushl  -0x14(%ebp)
     e45:	e8 b5 f4 ff ff       	call   2ff <read>
     e4a:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     e4d:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     e51:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     e55:	0f 89 26 ff ff ff    	jns    d81 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     e5b:	83 ec 0c             	sub    $0xc,%esp
     e5e:	ff 75 ec             	pushl  -0x14(%ebp)
     e61:	e8 a9 f4 ff ff       	call   30f <close>
     e66:	83 c4 10             	add    $0x10,%esp
    return 0;
     e69:	b8 00 00 00 00       	mov    $0x0,%eax
}
     e6e:	c9                   	leave  
     e6f:	c3                   	ret    

00000e70 <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
     e70:	55                   	push   %ebp
     e71:	89 e5                	mov    %esp,%ebp
     e73:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     e79:	83 ec 08             	sub    $0x8,%esp
     e7c:	6a 00                	push   $0x0
     e7e:	ff 75 08             	pushl  0x8(%ebp)
     e81:	e8 a1 f4 ff ff       	call   327 <open>
     e86:	83 c4 10             	add    $0x10,%esp
     e89:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     e8c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     e90:	79 0a                	jns    e9c <read24BitmapFile+0x2c>
        return -1;
     e92:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     e97:	e9 66 01 00 00       	jmp    1002 <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     e9c:	83 ec 04             	sub    $0x4,%esp
     e9f:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     ea2:	50                   	push   %eax
     ea3:	8d 45 ca             	lea    -0x36(%ebp),%eax
     ea6:	50                   	push   %eax
     ea7:	ff 75 ec             	pushl  -0x14(%ebp)
     eaa:	e8 f6 fd ff ff       	call   ca5 <readBitmapHeader>
     eaf:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     eb2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     eb5:	83 e8 36             	sub    $0x36,%eax
     eb8:	83 ec 04             	sub    $0x4,%esp
     ebb:	50                   	push   %eax
     ebc:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     ec2:	50                   	push   %eax
     ec3:	ff 75 ec             	pushl  -0x14(%ebp)
     ec6:	e8 34 f4 ff ff       	call   2ff <read>
     ecb:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     ece:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     ed1:	8b 45 14             	mov    0x14(%ebp),%eax
     ed4:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     ed6:	8b 55 aa             	mov    -0x56(%ebp),%edx
     ed9:	8b 45 10             	mov    0x10(%ebp),%eax
     edc:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     ede:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     ee1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     ee4:	8b 45 aa             	mov    -0x56(%ebp),%eax
     ee7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     eea:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     eee:	0f b7 c0             	movzwl %ax,%eax
     ef1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
     ef4:	8b 55 e8             	mov    -0x18(%ebp),%edx
     ef7:	89 d0                	mov    %edx,%eax
     ef9:	01 c0                	add    %eax,%eax
     efb:	01 d0                	add    %edx,%eax
     efd:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     f00:	8b 45 0c             	mov    0xc(%ebp),%eax
     f03:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     f06:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     f09:	83 e8 01             	sub    $0x1,%eax
     f0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
     f0f:	e9 d1 00 00 00       	jmp    fe5 <read24BitmapFile+0x175>
        if (bits == 24) {
     f14:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
     f18:	75 22                	jne    f3c <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     f1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     f1d:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     f21:	89 c2                	mov    %eax,%edx
     f23:	8b 45 d8             	mov    -0x28(%ebp),%eax
     f26:	01 d0                	add    %edx,%eax
     f28:	83 ec 04             	sub    $0x4,%esp
     f2b:	ff 75 dc             	pushl  -0x24(%ebp)
     f2e:	50                   	push   %eax
     f2f:	ff 75 ec             	pushl  -0x14(%ebp)
     f32:	e8 c8 f3 ff ff       	call   2ff <read>
     f37:	83 c4 10             	add    $0x10,%esp
     f3a:	eb 66                	jmp    fa2 <read24BitmapFile+0x132>
        } else {
            int j = 0;
     f3c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     f43:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     f4a:	eb 4e                	jmp    f9a <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
     f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
     f4f:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     f53:	89 c2                	mov    %eax,%edx
     f55:	89 d0                	mov    %edx,%eax
     f57:	01 c0                	add    %eax,%eax
     f59:	01 d0                	add    %edx,%eax
     f5b:	89 c1                	mov    %eax,%ecx
     f5d:	8b 55 f0             	mov    -0x10(%ebp),%edx
     f60:	89 d0                	mov    %edx,%eax
     f62:	01 c0                	add    %eax,%eax
     f64:	01 d0                	add    %edx,%eax
     f66:	8d 14 01             	lea    (%ecx,%eax,1),%edx
     f69:	8b 45 d8             	mov    -0x28(%ebp),%eax
     f6c:	01 d0                	add    %edx,%eax
     f6e:	83 ec 04             	sub    $0x4,%esp
     f71:	6a 03                	push   $0x3
     f73:	50                   	push   %eax
     f74:	ff 75 ec             	pushl  -0x14(%ebp)
     f77:	e8 83 f3 ff ff       	call   2ff <read>
     f7c:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
     f7f:	83 ec 04             	sub    $0x4,%esp
     f82:	6a 01                	push   $0x1
     f84:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     f8a:	50                   	push   %eax
     f8b:	ff 75 ec             	pushl  -0x14(%ebp)
     f8e:	e8 6c f3 ff ff       	call   2ff <read>
     f93:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     f96:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     f9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
     f9d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     fa0:	7c aa                	jl     f4c <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
     fa2:	8b 45 dc             	mov    -0x24(%ebp),%eax
     fa5:	99                   	cltd   
     fa6:	c1 ea 1e             	shr    $0x1e,%edx
     fa9:	01 d0                	add    %edx,%eax
     fab:	83 e0 03             	and    $0x3,%eax
     fae:	29 d0                	sub    %edx,%eax
     fb0:	85 c0                	test   %eax,%eax
     fb2:	7e 2d                	jle    fe1 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     fb4:	8b 45 dc             	mov    -0x24(%ebp),%eax
     fb7:	99                   	cltd   
     fb8:	c1 ea 1e             	shr    $0x1e,%edx
     fbb:	01 d0                	add    %edx,%eax
     fbd:	83 e0 03             	and    $0x3,%eax
     fc0:	29 d0                	sub    %edx,%eax
     fc2:	ba 04 00 00 00       	mov    $0x4,%edx
     fc7:	29 c2                	sub    %eax,%edx
     fc9:	89 d0                	mov    %edx,%eax
     fcb:	83 ec 04             	sub    $0x4,%esp
     fce:	50                   	push   %eax
     fcf:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     fd5:	50                   	push   %eax
     fd6:	ff 75 ec             	pushl  -0x14(%ebp)
     fd9:	e8 21 f3 ff ff       	call   2ff <read>
     fde:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     fe1:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     fe5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     fe9:	0f 89 25 ff ff ff    	jns    f14 <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     fef:	83 ec 0c             	sub    $0xc,%esp
     ff2:	ff 75 ec             	pushl  -0x14(%ebp)
     ff5:	e8 15 f3 ff ff       	call   30f <close>
     ffa:	83 c4 10             	add    $0x10,%esp
    return 0;
     ffd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1002:	c9                   	leave  
    1003:	c3                   	ret    

00001004 <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    1004:	55                   	push   %ebp
    1005:	89 e5                	mov    %esp,%ebp
    1007:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    100a:	8b 55 10             	mov    0x10(%ebp),%edx
    100d:	89 d0                	mov    %edx,%eax
    100f:	01 c0                	add    %eax,%eax
    1011:	01 d0                	add    %edx,%eax
    1013:	c1 e0 03             	shl    $0x3,%eax
    1016:	83 c0 1f             	add    $0x1f,%eax
    1019:	8d 50 1f             	lea    0x1f(%eax),%edx
    101c:	85 c0                	test   %eax,%eax
    101e:	0f 48 c2             	cmovs  %edx,%eax
    1021:	c1 f8 05             	sar    $0x5,%eax
    1024:	c1 e0 02             	shl    $0x2,%eax
    1027:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    102a:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    1030:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1033:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1037:	83 c0 36             	add    $0x36,%eax
    103a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    103d:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    1043:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    1049:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    1050:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    1057:	8b 45 10             	mov    0x10(%ebp),%eax
    105a:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    105d:	8b 45 0c             	mov    0xc(%ebp),%eax
    1060:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    1063:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    1069:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    106f:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    1076:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1079:	0f af 45 0c          	imul   0xc(%ebp),%eax
    107d:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    1080:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    1087:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    108e:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    1095:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    109c:	83 ec 04             	sub    $0x4,%esp
    109f:	6a 0e                	push   $0xe
    10a1:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    10a4:	50                   	push   %eax
    10a5:	ff 75 08             	pushl  0x8(%ebp)
    10a8:	e8 5a f2 ff ff       	call   307 <write>
    10ad:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    10b0:	83 ec 04             	sub    $0x4,%esp
    10b3:	6a 28                	push   $0x28
    10b5:	8d 45 be             	lea    -0x42(%ebp),%eax
    10b8:	50                   	push   %eax
    10b9:	ff 75 08             	pushl  0x8(%ebp)
    10bc:	e8 46 f2 ff ff       	call   307 <write>
    10c1:	83 c4 10             	add    $0x10,%esp
}
    10c4:	90                   	nop
    10c5:	c9                   	leave  
    10c6:	c3                   	ret    

000010c7 <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    10c7:	55                   	push   %ebp
    10c8:	89 e5                	mov    %esp,%ebp
    10ca:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    10cd:	83 ec 08             	sub    $0x8,%esp
    10d0:	68 02 02 00 00       	push   $0x202
    10d5:	ff 75 08             	pushl  0x8(%ebp)
    10d8:	e8 4a f2 ff ff       	call   327 <open>
    10dd:	83 c4 10             	add    $0x10,%esp
    10e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    10e3:	8b 55 14             	mov    0x14(%ebp),%edx
    10e6:	89 d0                	mov    %edx,%eax
    10e8:	01 c0                	add    %eax,%eax
    10ea:	01 d0                	add    %edx,%eax
    10ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    10ef:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    10f3:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    10f7:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    10fb:	83 ec 04             	sub    $0x4,%esp
    10fe:	ff 75 14             	pushl  0x14(%ebp)
    1101:	ff 75 10             	pushl  0x10(%ebp)
    1104:	ff 75 f0             	pushl  -0x10(%ebp)
    1107:	e8 f8 fe ff ff       	call   1004 <write24BitmapFileHeader>
    110c:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    110f:	8b 45 10             	mov    0x10(%ebp),%eax
    1112:	83 e8 01             	sub    $0x1,%eax
    1115:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1118:	eb 66                	jmp    1180 <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    111a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    111d:	0f af 45 14          	imul   0x14(%ebp),%eax
    1121:	89 c2                	mov    %eax,%edx
    1123:	89 d0                	mov    %edx,%eax
    1125:	01 c0                	add    %eax,%eax
    1127:	01 c2                	add    %eax,%edx
    1129:	8b 45 0c             	mov    0xc(%ebp),%eax
    112c:	01 d0                	add    %edx,%eax
    112e:	83 ec 04             	sub    $0x4,%esp
    1131:	ff 75 ec             	pushl  -0x14(%ebp)
    1134:	50                   	push   %eax
    1135:	ff 75 f0             	pushl  -0x10(%ebp)
    1138:	e8 ca f1 ff ff       	call   307 <write>
    113d:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    1140:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1143:	99                   	cltd   
    1144:	c1 ea 1e             	shr    $0x1e,%edx
    1147:	01 d0                	add    %edx,%eax
    1149:	83 e0 03             	and    $0x3,%eax
    114c:	29 d0                	sub    %edx,%eax
    114e:	85 c0                	test   %eax,%eax
    1150:	7e 2a                	jle    117c <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1152:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1155:	99                   	cltd   
    1156:	c1 ea 1e             	shr    $0x1e,%edx
    1159:	01 d0                	add    %edx,%eax
    115b:	83 e0 03             	and    $0x3,%eax
    115e:	29 d0                	sub    %edx,%eax
    1160:	ba 04 00 00 00       	mov    $0x4,%edx
    1165:	29 c2                	sub    %eax,%edx
    1167:	89 d0                	mov    %edx,%eax
    1169:	83 ec 04             	sub    $0x4,%esp
    116c:	50                   	push   %eax
    116d:	8d 45 e9             	lea    -0x17(%ebp),%eax
    1170:	50                   	push   %eax
    1171:	ff 75 f0             	pushl  -0x10(%ebp)
    1174:	e8 8e f1 ff ff       	call   307 <write>
    1179:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    117c:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1180:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1184:	79 94                	jns    111a <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1186:	83 ec 0c             	sub    $0xc,%esp
    1189:	ff 75 f0             	pushl  -0x10(%ebp)
    118c:	e8 7e f1 ff ff       	call   30f <close>
    1191:	83 c4 10             	add    $0x10,%esp
    return 0;
    1194:	b8 00 00 00 00       	mov    $0x0,%eax
    1199:	c9                   	leave  
    119a:	c3                   	ret    

0000119b <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    119b:	55                   	push   %ebp
    119c:	89 e5                	mov    %esp,%ebp
    119e:	57                   	push   %edi
    119f:	56                   	push   %esi
    11a0:	53                   	push   %ebx
    11a1:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    11a4:	8b 45 08             	mov    0x8(%ebp),%eax
    11a7:	8b 50 10             	mov    0x10(%eax),%edx
    11aa:	8b 40 0c             	mov    0xc(%eax),%eax
    11ad:	89 45 e0             	mov    %eax,-0x20(%ebp)
    11b0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    11b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    11b6:	8b 55 e0             	mov    -0x20(%ebp),%edx
    11b9:	83 c2 1e             	add    $0x1e,%edx
    11bc:	0f af d0             	imul   %eax,%edx
    11bf:	89 d0                	mov    %edx,%eax
    11c1:	01 c0                	add    %eax,%eax
    11c3:	01 d0                	add    %edx,%eax
    11c5:	83 ec 0c             	sub    $0xc,%esp
    11c8:	50                   	push   %eax
    11c9:	e8 93 f5 ff ff       	call   761 <malloc>
    11ce:	83 c4 10             	add    $0x10,%esp
    11d1:	89 c2                	mov    %eax,%edx
    11d3:	8b 45 08             	mov    0x8(%ebp),%eax
    11d6:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    11d9:	8b 45 08             	mov    0x8(%ebp),%eax
    11dc:	8b 40 1c             	mov    0x1c(%eax),%eax
    11df:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    11e2:	6b d2 5a             	imul   $0x5a,%edx,%edx
    11e5:	01 c2                	add    %eax,%edx
    11e7:	8b 45 08             	mov    0x8(%ebp),%eax
    11ea:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    11ed:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    11f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    11f3:	0f af d0             	imul   %eax,%edx
    11f6:	89 d0                	mov    %edx,%eax
    11f8:	01 c0                	add    %eax,%eax
    11fa:	01 d0                	add    %edx,%eax
    11fc:	89 c2                	mov    %eax,%edx
    11fe:	8b 45 08             	mov    0x8(%ebp),%eax
    1201:	8b 40 18             	mov    0x18(%eax),%eax
    1204:	83 ec 04             	sub    $0x4,%esp
    1207:	52                   	push   %edx
    1208:	68 ff 00 00 00       	push   $0xff
    120d:	50                   	push   %eax
    120e:	e8 39 ef ff ff       	call   14c <memset>
    1213:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    1216:	8b 45 08             	mov    0x8(%ebp),%eax
    1219:	8b 78 1c             	mov    0x1c(%eax),%edi
    121c:	8b 45 08             	mov    0x8(%ebp),%eax
    121f:	8b 70 14             	mov    0x14(%eax),%esi
    1222:	8b 45 08             	mov    0x8(%ebp),%eax
    1225:	8b 58 0c             	mov    0xc(%eax),%ebx
    1228:	8b 45 08             	mov    0x8(%ebp),%eax
    122b:	8b 48 10             	mov    0x10(%eax),%ecx
    122e:	8b 45 08             	mov    0x8(%ebp),%eax
    1231:	8b 50 08             	mov    0x8(%eax),%edx
    1234:	8b 45 08             	mov    0x8(%ebp),%eax
    1237:	8b 40 04             	mov    0x4(%eax),%eax
    123a:	83 ec 08             	sub    $0x8,%esp
    123d:	57                   	push   %edi
    123e:	56                   	push   %esi
    123f:	53                   	push   %ebx
    1240:	51                   	push   %ecx
    1241:	52                   	push   %edx
    1242:	50                   	push   %eax
    1243:	e8 3f f1 ff ff       	call   387 <createwindow>
    1248:	83 c4 20             	add    $0x20,%esp
    124b:	89 c2                	mov    %eax,%edx
    124d:	8b 45 08             	mov    0x8(%ebp),%eax
    1250:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    1252:	8b 45 08             	mov    0x8(%ebp),%eax
    1255:	8b 00                	mov    (%eax),%eax
}
    1257:	8d 65 f4             	lea    -0xc(%ebp),%esp
    125a:	5b                   	pop    %ebx
    125b:	5e                   	pop    %esi
    125c:	5f                   	pop    %edi
    125d:	5d                   	pop    %ebp
    125e:	c3                   	ret    

0000125f <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    125f:	55                   	push   %ebp
    1260:	89 e5                	mov    %esp,%ebp
    1262:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    1265:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    126c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1273:	8b 45 08             	mov    0x8(%ebp),%eax
    1276:	8b 40 18             	mov    0x18(%eax),%eax
    1279:	ff 75 1c             	pushl  0x1c(%ebp)
    127c:	ff 75 18             	pushl  0x18(%ebp)
    127f:	ff 75 1c             	pushl  0x1c(%ebp)
    1282:	ff 75 18             	pushl  0x18(%ebp)
    1285:	8b 55 08             	mov    0x8(%ebp),%edx
    1288:	ff 72 10             	pushl  0x10(%edx)
    128b:	ff 72 0c             	pushl  0xc(%edx)
    128e:	ff 75 f4             	pushl  -0xc(%ebp)
    1291:	ff 75 f0             	pushl  -0x10(%ebp)
    1294:	ff 75 14             	pushl  0x14(%ebp)
    1297:	ff 75 10             	pushl  0x10(%ebp)
    129a:	ff 75 0c             	pushl  0xc(%ebp)
    129d:	50                   	push   %eax
    129e:	e8 d5 07 00 00       	call   1a78 <drawBitmap>
    12a3:	83 c4 30             	add    $0x30,%esp
    return 0;
    12a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    12ab:	c9                   	leave  
    12ac:	c3                   	ret    

000012ad <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    12ad:	55                   	push   %ebp
    12ae:	89 e5                	mov    %esp,%ebp
    12b0:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    12b3:	8b 45 08             	mov    0x8(%ebp),%eax
    12b6:	8b 40 18             	mov    0x18(%eax),%eax
    12b9:	ff 75 2c             	pushl  0x2c(%ebp)
    12bc:	ff 75 28             	pushl  0x28(%ebp)
    12bf:	ff 75 24             	pushl  0x24(%ebp)
    12c2:	ff 75 20             	pushl  0x20(%ebp)
    12c5:	8b 55 08             	mov    0x8(%ebp),%edx
    12c8:	ff 72 10             	pushl  0x10(%edx)
    12cb:	ff 72 0c             	pushl  0xc(%edx)
    12ce:	ff 75 1c             	pushl  0x1c(%ebp)
    12d1:	ff 75 18             	pushl  0x18(%ebp)
    12d4:	ff 75 14             	pushl  0x14(%ebp)
    12d7:	ff 75 10             	pushl  0x10(%ebp)
    12da:	ff 75 0c             	pushl  0xc(%ebp)
    12dd:	50                   	push   %eax
    12de:	e8 95 07 00 00       	call   1a78 <drawBitmap>
    12e3:	83 c4 30             	add    $0x30,%esp
    return 0;
    12e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    12eb:	c9                   	leave  
    12ec:	c3                   	ret    

000012ed <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    12ed:	55                   	push   %ebp
    12ee:	89 e5                	mov    %esp,%ebp
    12f0:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    12f3:	8b 45 08             	mov    0x8(%ebp),%eax
    12f6:	8b 40 18             	mov    0x18(%eax),%eax
    12f9:	ff 75 2c             	pushl  0x2c(%ebp)
    12fc:	ff 75 28             	pushl  0x28(%ebp)
    12ff:	ff 75 24             	pushl  0x24(%ebp)
    1302:	ff 75 20             	pushl  0x20(%ebp)
    1305:	8b 55 08             	mov    0x8(%ebp),%edx
    1308:	ff 72 10             	pushl  0x10(%edx)
    130b:	ff 72 0c             	pushl  0xc(%edx)
    130e:	ff 75 1c             	pushl  0x1c(%ebp)
    1311:	ff 75 18             	pushl  0x18(%ebp)
    1314:	ff 75 14             	pushl  0x14(%ebp)
    1317:	ff 75 10             	pushl  0x10(%ebp)
    131a:	ff 75 0c             	pushl  0xc(%ebp)
    131d:	50                   	push   %eax
    131e:	e8 75 08 00 00       	call   1b98 <drawTransparentBitmap>
    1323:	83 c4 30             	add    $0x30,%esp
    return 0;
    1326:	b8 00 00 00 00       	mov    $0x0,%eax
}
    132b:	c9                   	leave  
    132c:	c3                   	ret    

0000132d <api_repaint>:

int api_repaint(Window* wnd)
{
    132d:	55                   	push   %ebp
    132e:	89 e5                	mov    %esp,%ebp
    1330:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    1333:	8b 45 08             	mov    0x8(%ebp),%eax
    1336:	8b 00                	mov    (%eax),%eax
    1338:	83 ec 0c             	sub    $0xc,%esp
    133b:	50                   	push   %eax
    133c:	e8 4e f0 ff ff       	call   38f <repaintwindow>
    1341:	83 c4 10             	add    $0x10,%esp
    return 0;
    1344:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1349:	c9                   	leave  
    134a:	c3                   	ret    

0000134b <api_update>:

int api_update(Window* wnd, Rect rect)
{
    134b:	55                   	push   %ebp
    134c:	89 e5                	mov    %esp,%ebp
    134e:	56                   	push   %esi
    134f:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    1350:	8b 75 18             	mov    0x18(%ebp),%esi
    1353:	8b 5d 14             	mov    0x14(%ebp),%ebx
    1356:	8b 4d 10             	mov    0x10(%ebp),%ecx
    1359:	8b 55 0c             	mov    0xc(%ebp),%edx
    135c:	8b 45 08             	mov    0x8(%ebp),%eax
    135f:	8b 00                	mov    (%eax),%eax
    1361:	83 ec 0c             	sub    $0xc,%esp
    1364:	56                   	push   %esi
    1365:	53                   	push   %ebx
    1366:	51                   	push   %ecx
    1367:	52                   	push   %edx
    1368:	50                   	push   %eax
    1369:	e8 39 f0 ff ff       	call   3a7 <updatewindow>
    136e:	83 c4 20             	add    $0x20,%esp
    return 0;
    1371:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1376:	8d 65 f8             	lea    -0x8(%ebp),%esp
    1379:	5b                   	pop    %ebx
    137a:	5e                   	pop    %esi
    137b:	5d                   	pop    %ebp
    137c:	c3                   	ret    

0000137d <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    137d:	55                   	push   %ebp
    137e:	89 e5                	mov    %esp,%ebp
    1380:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    1383:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    138a:	8b 45 08             	mov    0x8(%ebp),%eax
    138d:	8b 00                	mov    (%eax),%eax
    138f:	83 ec 08             	sub    $0x8,%esp
    1392:	8d 55 c8             	lea    -0x38(%ebp),%edx
    1395:	52                   	push   %edx
    1396:	50                   	push   %eax
    1397:	e8 fb ef ff ff       	call   397 <getmessage>
    139c:	83 c4 10             	add    $0x10,%esp
    139f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    13a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    13a6:	74 e2                	je     138a <api_exec+0xd>
        {
            pf(&msg);
    13a8:	83 ec 0c             	sub    $0xc,%esp
    13ab:	8d 45 c8             	lea    -0x38(%ebp),%eax
    13ae:	50                   	push   %eax
    13af:	8b 45 0c             	mov    0xc(%ebp),%eax
    13b2:	ff d0                	call   *%eax
    13b4:	83 c4 10             	add    $0x10,%esp
        }
    }
    13b7:	eb d1                	jmp    138a <api_exec+0xd>

000013b9 <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    13b9:	55                   	push   %ebp
    13ba:	89 e5                	mov    %esp,%ebp
    13bc:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    13bf:	8b 45 08             	mov    0x8(%ebp),%eax
    13c2:	8b 00                	mov    (%eax),%eax
    13c4:	83 ec 08             	sub    $0x8,%esp
    13c7:	ff 75 0c             	pushl  0xc(%ebp)
    13ca:	50                   	push   %eax
    13cb:	e8 cf ef ff ff       	call   39f <settimer>
    13d0:	83 c4 10             	add    $0x10,%esp
    return 0;
    13d3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13d8:	c9                   	leave  
    13d9:	c3                   	ret    

000013da <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    13da:	55                   	push   %ebp
    13db:	89 e5                	mov    %esp,%ebp
    13dd:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    13e0:	8b 45 08             	mov    0x8(%ebp),%eax
    13e3:	8b 50 18             	mov    0x18(%eax),%edx
    13e6:	ff 75 18             	pushl  0x18(%ebp)
    13e9:	ff 75 14             	pushl  0x14(%ebp)
    13ec:	83 ec 04             	sub    $0x4,%esp
    13ef:	89 e0                	mov    %esp,%eax
    13f1:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    13f5:	66 89 08             	mov    %cx,(%eax)
    13f8:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    13fc:	88 48 02             	mov    %cl,0x2(%eax)
    13ff:	8b 45 08             	mov    0x8(%ebp),%eax
    1402:	ff 70 10             	pushl  0x10(%eax)
    1405:	ff 70 0c             	pushl  0xc(%eax)
    1408:	ff 75 10             	pushl  0x10(%ebp)
    140b:	ff 75 0c             	pushl  0xc(%ebp)
    140e:	52                   	push   %edx
    140f:	e8 6f 04 00 00       	call   1883 <drawRect>
    1414:	83 c4 20             	add    $0x20,%esp
    return 0;
    1417:	b8 00 00 00 00       	mov    $0x0,%eax
}
    141c:	c9                   	leave  
    141d:	c3                   	ret    

0000141e <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    141e:	55                   	push   %ebp
    141f:	89 e5                	mov    %esp,%ebp
    1421:	83 ec 28             	sub    $0x28,%esp
    1424:	8b 45 14             	mov    0x14(%ebp),%eax
    1427:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    142a:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    142e:	8b 45 0c             	mov    0xc(%ebp),%eax
    1431:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1434:	8b 45 10             	mov    0x10(%ebp),%eax
    1437:	89 45 f4             	mov    %eax,-0xc(%ebp)
    143a:	8b 45 08             	mov    0x8(%ebp),%eax
    143d:	8b 40 18             	mov    0x18(%eax),%eax
    1440:	83 ec 04             	sub    $0x4,%esp
    1443:	ff 75 18             	pushl  0x18(%ebp)
    1446:	52                   	push   %edx
    1447:	8b 55 08             	mov    0x8(%ebp),%edx
    144a:	ff 72 10             	pushl  0x10(%edx)
    144d:	ff 72 0c             	pushl  0xc(%edx)
    1450:	ff 75 f4             	pushl  -0xc(%ebp)
    1453:	ff 75 f0             	pushl  -0x10(%ebp)
    1456:	50                   	push   %eax
    1457:	e8 d4 02 00 00       	call   1730 <drawCharacter>
    145c:	83 c4 20             	add    $0x20,%esp
    return 0;
    145f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1464:	c9                   	leave  
    1465:	c3                   	ret    

00001466 <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    1466:	55                   	push   %ebp
    1467:	89 e5                	mov    %esp,%ebp
    1469:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    146c:	8b 45 0c             	mov    0xc(%ebp),%eax
    146f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1472:	8b 45 10             	mov    0x10(%ebp),%eax
    1475:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1478:	8b 45 08             	mov    0x8(%ebp),%eax
    147b:	8b 40 18             	mov    0x18(%eax),%eax
    147e:	83 ec 04             	sub    $0x4,%esp
    1481:	ff 75 18             	pushl  0x18(%ebp)
    1484:	ff 75 14             	pushl  0x14(%ebp)
    1487:	8b 55 08             	mov    0x8(%ebp),%edx
    148a:	ff 72 10             	pushl  0x10(%edx)
    148d:	ff 72 0c             	pushl  0xc(%edx)
    1490:	ff 75 f4             	pushl  -0xc(%ebp)
    1493:	ff 75 f0             	pushl  -0x10(%ebp)
    1496:	50                   	push   %eax
    1497:	e8 8e 03 00 00       	call   182a <drawString>
    149c:	83 c4 20             	add    $0x20,%esp
    return 0;
    149f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    14a4:	c9                   	leave  
    14a5:	c3                   	ret    

000014a6 <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    14a6:	55                   	push   %ebp
    14a7:	89 e5                	mov    %esp,%ebp
    14a9:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    14ac:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    14b0:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    14b4:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    14b8:	83 ec 08             	sub    $0x8,%esp
    14bb:	83 ec 04             	sub    $0x4,%esp
    14be:	89 e0                	mov    %esp,%eax
    14c0:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    14c4:	66 89 10             	mov    %dx,(%eax)
    14c7:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    14cb:	88 50 02             	mov    %dl,0x2(%eax)
    14ce:	ff 75 18             	pushl  0x18(%ebp)
    14d1:	ff 75 14             	pushl  0x14(%ebp)
    14d4:	ff 75 10             	pushl  0x10(%ebp)
    14d7:	ff 75 0c             	pushl  0xc(%ebp)
    14da:	ff 75 08             	pushl  0x8(%ebp)
    14dd:	e8 f8 fe ff ff       	call   13da <api_drawRect>
    14e2:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    14e5:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    14e9:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    14ed:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    14f1:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    14f5:	8b 45 10             	mov    0x10(%ebp),%eax
    14f8:	8d 50 0a             	lea    0xa(%eax),%edx
    14fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    14fe:	83 c0 0a             	add    $0xa,%eax
    1501:	83 ec 0c             	sub    $0xc,%esp
    1504:	ff 75 f4             	pushl  -0xc(%ebp)
    1507:	ff 75 1c             	pushl  0x1c(%ebp)
    150a:	52                   	push   %edx
    150b:	50                   	push   %eax
    150c:	ff 75 08             	pushl  0x8(%ebp)
    150f:	e8 52 ff ff ff       	call   1466 <api_drawString>
    1514:	83 c4 20             	add    $0x20,%esp
    return 0;
    1517:	b8 00 00 00 00       	mov    $0x0,%eax
}
    151c:	c9                   	leave  
    151d:	c3                   	ret    

0000151e <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    151e:	55                   	push   %ebp
    151f:	89 e5                	mov    %esp,%ebp
    1521:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    1524:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    152b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1532:	8b 45 08             	mov    0x8(%ebp),%eax
    1535:	8b 40 18             	mov    0x18(%eax),%eax
    1538:	ff 75 1c             	pushl  0x1c(%ebp)
    153b:	ff 75 18             	pushl  0x18(%ebp)
    153e:	ff 75 1c             	pushl  0x1c(%ebp)
    1541:	ff 75 18             	pushl  0x18(%ebp)
    1544:	8b 55 08             	mov    0x8(%ebp),%edx
    1547:	ff 72 10             	pushl  0x10(%edx)
    154a:	ff 72 0c             	pushl  0xc(%edx)
    154d:	ff 75 f4             	pushl  -0xc(%ebp)
    1550:	ff 75 f0             	pushl  -0x10(%ebp)
    1553:	ff 75 14             	pushl  0x14(%ebp)
    1556:	ff 75 10             	pushl  0x10(%ebp)
    1559:	ff 75 0c             	pushl  0xc(%ebp)
    155c:	50                   	push   %eax
    155d:	e8 16 05 00 00       	call   1a78 <drawBitmap>
    1562:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    1565:	8b 45 08             	mov    0x8(%ebp),%eax
    1568:	8b 40 18             	mov    0x18(%eax),%eax
    156b:	ff 75 28             	pushl  0x28(%ebp)
    156e:	ff 75 1c             	pushl  0x1c(%ebp)
    1571:	ff 75 18             	pushl  0x18(%ebp)
    1574:	8b 55 08             	mov    0x8(%ebp),%edx
    1577:	ff 72 10             	pushl  0x10(%edx)
    157a:	ff 72 0c             	pushl  0xc(%edx)
    157d:	ff 75 14             	pushl  0x14(%ebp)
    1580:	ff 75 10             	pushl  0x10(%ebp)
    1583:	50                   	push   %eax
    1584:	e8 99 07 00 00       	call   1d22 <colorShift>
    1589:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    158c:	8b 45 08             	mov    0x8(%ebp),%eax
    158f:	8b 50 18             	mov    0x18(%eax),%edx
    1592:	83 ec 0c             	sub    $0xc,%esp
    1595:	ff 75 20             	pushl  0x20(%ebp)
    1598:	ff 75 1c             	pushl  0x1c(%ebp)
    159b:	ff 75 18             	pushl  0x18(%ebp)
    159e:	83 ec 04             	sub    $0x4,%esp
    15a1:	89 e0                	mov    %esp,%eax
    15a3:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    15a7:	66 89 08             	mov    %cx,(%eax)
    15aa:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    15ae:	88 48 02             	mov    %cl,0x2(%eax)
    15b1:	8b 45 08             	mov    0x8(%ebp),%eax
    15b4:	ff 70 10             	pushl  0x10(%eax)
    15b7:	ff 70 0c             	pushl  0xc(%eax)
    15ba:	ff 75 14             	pushl  0x14(%ebp)
    15bd:	ff 75 10             	pushl  0x10(%ebp)
    15c0:	52                   	push   %edx
    15c1:	e8 6d 03 00 00       	call   1933 <drawBorder>
    15c6:	83 c4 30             	add    $0x30,%esp
    return 0;
    15c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    15ce:	c9                   	leave  
    15cf:	c3                   	ret    

000015d0 <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    15d0:	55                   	push   %ebp
    15d1:	89 e5                	mov    %esp,%ebp
    15d3:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    15d6:	8b 45 08             	mov    0x8(%ebp),%eax
    15d9:	8b 00                	mov    (%eax),%eax
    15db:	83 ec 0c             	sub    $0xc,%esp
    15de:	50                   	push   %eax
    15df:	e8 cb ed ff ff       	call   3af <destroywindow>
    15e4:	83 c4 10             	add    $0x10,%esp
    return 0;
    15e7:	b8 00 00 00 00       	mov    $0x0,%eax
    15ec:	c9                   	leave  
    15ed:	c3                   	ret    

000015ee <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    15ee:	55                   	push   %ebp
    15ef:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    15f1:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    15f5:	8b 45 08             	mov    0x8(%ebp),%eax
    15f8:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    15fb:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    15ff:	8b 45 08             	mov    0x8(%ebp),%eax
    1602:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    1605:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    1609:	8b 45 08             	mov    0x8(%ebp),%eax
    160c:	88 10                	mov    %dl,(%eax)
}
    160e:	90                   	nop
    160f:	5d                   	pop    %ebp
    1610:	c3                   	ret    

00001611 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    1611:	55                   	push   %ebp
    1612:	89 e5                	mov    %esp,%ebp
    1614:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    1617:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    161b:	3c ff                	cmp    $0xff,%al
    161d:	75 22                	jne    1641 <drawPointAlpha+0x30>
        color->R = origin.R;
    161f:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    1623:	8b 45 08             	mov    0x8(%ebp),%eax
    1626:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    1629:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    162d:	8b 45 08             	mov    0x8(%ebp),%eax
    1630:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    1633:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    1637:	8b 45 08             	mov    0x8(%ebp),%eax
    163a:	88 10                	mov    %dl,(%eax)
        return;
    163c:	e9 ed 00 00 00       	jmp    172e <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    1641:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1645:	84 c0                	test   %al,%al
    1647:	0f 84 e0 00 00 00    	je     172d <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    164d:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1651:	0f b6 c0             	movzbl %al,%eax
    1654:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    1658:	df 45 e4             	fild   -0x1c(%ebp)
    165b:	d9 05 c0 9c 01 00    	flds   0x19cc0
    1661:	de f9                	fdivrp %st,%st(1)
    1663:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    1666:	8b 45 08             	mov    0x8(%ebp),%eax
    1669:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    166d:	0f b6 c0             	movzbl %al,%eax
    1670:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1673:	db 45 e4             	fildl  -0x1c(%ebp)
    1676:	d9 e8                	fld1   
    1678:	d8 65 fc             	fsubs  -0x4(%ebp)
    167b:	de c9                	fmulp  %st,%st(1)
    167d:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    1681:	0f b6 c0             	movzbl %al,%eax
    1684:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1687:	db 45 e4             	fildl  -0x1c(%ebp)
    168a:	d8 4d fc             	fmuls  -0x4(%ebp)
    168d:	de c1                	faddp  %st,%st(1)
    168f:	d9 7d ee             	fnstcw -0x12(%ebp)
    1692:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    1696:	b4 0c                	mov    $0xc,%ah
    1698:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    169c:	d9 6d ec             	fldcw  -0x14(%ebp)
    169f:	df 5d ea             	fistp  -0x16(%ebp)
    16a2:	d9 6d ee             	fldcw  -0x12(%ebp)
    16a5:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    16a9:	89 c2                	mov    %eax,%edx
    16ab:	8b 45 08             	mov    0x8(%ebp),%eax
    16ae:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    16b1:	8b 45 08             	mov    0x8(%ebp),%eax
    16b4:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    16b8:	0f b6 c0             	movzbl %al,%eax
    16bb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16be:	db 45 e4             	fildl  -0x1c(%ebp)
    16c1:	d9 e8                	fld1   
    16c3:	d8 65 fc             	fsubs  -0x4(%ebp)
    16c6:	de c9                	fmulp  %st,%st(1)
    16c8:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    16cc:	0f b6 c0             	movzbl %al,%eax
    16cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16d2:	db 45 e4             	fildl  -0x1c(%ebp)
    16d5:	d8 4d fc             	fmuls  -0x4(%ebp)
    16d8:	de c1                	faddp  %st,%st(1)
    16da:	d9 6d ec             	fldcw  -0x14(%ebp)
    16dd:	df 5d ea             	fistp  -0x16(%ebp)
    16e0:	d9 6d ee             	fldcw  -0x12(%ebp)
    16e3:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    16e7:	89 c2                	mov    %eax,%edx
    16e9:	8b 45 08             	mov    0x8(%ebp),%eax
    16ec:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    16ef:	8b 45 08             	mov    0x8(%ebp),%eax
    16f2:	0f b6 00             	movzbl (%eax),%eax
    16f5:	0f b6 c0             	movzbl %al,%eax
    16f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16fb:	db 45 e4             	fildl  -0x1c(%ebp)
    16fe:	d9 e8                	fld1   
    1700:	d8 65 fc             	fsubs  -0x4(%ebp)
    1703:	de c9                	fmulp  %st,%st(1)
    1705:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    1709:	0f b6 c0             	movzbl %al,%eax
    170c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    170f:	db 45 e4             	fildl  -0x1c(%ebp)
    1712:	d8 4d fc             	fmuls  -0x4(%ebp)
    1715:	de c1                	faddp  %st,%st(1)
    1717:	d9 6d ec             	fldcw  -0x14(%ebp)
    171a:	df 5d ea             	fistp  -0x16(%ebp)
    171d:	d9 6d ee             	fldcw  -0x12(%ebp)
    1720:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1724:	89 c2                	mov    %eax,%edx
    1726:	8b 45 08             	mov    0x8(%ebp),%eax
    1729:	88 10                	mov    %dl,(%eax)
    172b:	eb 01                	jmp    172e <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    172d:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    172e:	c9                   	leave  
    172f:	c3                   	ret    

00001730 <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    1730:	55                   	push   %ebp
    1731:	89 e5                	mov    %esp,%ebp
    1733:	83 ec 14             	sub    $0x14,%esp
    1736:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1739:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    173c:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    1740:	83 e8 20             	sub    $0x20,%eax
    1743:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    1746:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    174a:	0f 88 d7 00 00 00    	js     1827 <drawCharacter+0xf7>
    1750:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    1754:	0f 8f cd 00 00 00    	jg     1827 <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    175a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1761:	e9 b5 00 00 00       	jmp    181b <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    1766:	8b 55 10             	mov    0x10(%ebp),%edx
    1769:	8b 45 fc             	mov    -0x4(%ebp),%eax
    176c:	01 c2                	add    %eax,%edx
    176e:	8b 45 14             	mov    0x14(%ebp),%eax
    1771:	39 c2                	cmp    %eax,%edx
    1773:	0f 8f af 00 00 00    	jg     1828 <drawCharacter+0xf8>
    1779:	8b 55 10             	mov    0x10(%ebp),%edx
    177c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    177f:	01 d0                	add    %edx,%eax
    1781:	85 c0                	test   %eax,%eax
    1783:	0f 88 9f 00 00 00    	js     1828 <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1789:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1790:	eb 7b                	jmp    180d <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    1792:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1795:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    1798:	89 d0                	mov    %edx,%eax
    179a:	c1 e0 03             	shl    $0x3,%eax
    179d:	01 d0                	add    %edx,%eax
    179f:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    17a5:	01 c2                	add    %eax,%edx
    17a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17aa:	01 d0                	add    %edx,%eax
    17ac:	05 a0 60 01 00       	add    $0x160a0,%eax
    17b1:	0f b6 00             	movzbl (%eax),%eax
    17b4:	3c 01                	cmp    $0x1,%al
    17b6:	75 51                	jne    1809 <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    17b8:	8b 55 0c             	mov    0xc(%ebp),%edx
    17bb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17be:	01 c2                	add    %eax,%edx
    17c0:	8b 45 18             	mov    0x18(%ebp),%eax
    17c3:	39 c2                	cmp    %eax,%edx
    17c5:	7f 50                	jg     1817 <drawCharacter+0xe7>
    17c7:	8b 55 0c             	mov    0xc(%ebp),%edx
    17ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17cd:	01 d0                	add    %edx,%eax
    17cf:	85 c0                	test   %eax,%eax
    17d1:	78 44                	js     1817 <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    17d3:	8b 55 10             	mov    0x10(%ebp),%edx
    17d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    17d9:	01 c2                	add    %eax,%edx
    17db:	8b 45 18             	mov    0x18(%ebp),%eax
    17de:	0f af c2             	imul   %edx,%eax
    17e1:	89 c2                	mov    %eax,%edx
    17e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    17e6:	01 c2                	add    %eax,%edx
    17e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17eb:	01 c2                	add    %eax,%edx
    17ed:	89 d0                	mov    %edx,%eax
    17ef:	01 c0                	add    %eax,%eax
    17f1:	01 c2                	add    %eax,%edx
    17f3:	8b 45 08             	mov    0x8(%ebp),%eax
    17f6:	01 d0                	add    %edx,%eax
    17f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    17fb:	ff 75 20             	pushl  0x20(%ebp)
    17fe:	ff 75 f0             	pushl  -0x10(%ebp)
    1801:	e8 0b fe ff ff       	call   1611 <drawPointAlpha>
    1806:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1809:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    180d:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    1811:	0f 8e 7b ff ff ff    	jle    1792 <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1817:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    181b:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    181f:	0f 8e 41 ff ff ff    	jle    1766 <drawCharacter+0x36>
    1825:	eb 01                	jmp    1828 <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    1827:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    1828:	c9                   	leave  
    1829:	c3                   	ret    

0000182a <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    182a:	55                   	push   %ebp
    182b:	89 e5                	mov    %esp,%ebp
    182d:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    1830:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    1837:	eb 3d                	jmp    1876 <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    1839:	8b 45 1c             	mov    0x1c(%ebp),%eax
    183c:	0f b6 00             	movzbl (%eax),%eax
    183f:	0f be c0             	movsbl %al,%eax
    1842:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1845:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1848:	01 ca                	add    %ecx,%edx
    184a:	89 55 f4             	mov    %edx,-0xc(%ebp)
    184d:	8b 55 10             	mov    0x10(%ebp),%edx
    1850:	89 55 f8             	mov    %edx,-0x8(%ebp)
    1853:	ff 75 20             	pushl  0x20(%ebp)
    1856:	50                   	push   %eax
    1857:	ff 75 18             	pushl  0x18(%ebp)
    185a:	ff 75 14             	pushl  0x14(%ebp)
    185d:	ff 75 f8             	pushl  -0x8(%ebp)
    1860:	ff 75 f4             	pushl  -0xc(%ebp)
    1863:	ff 75 08             	pushl  0x8(%ebp)
    1866:	e8 c5 fe ff ff       	call   1730 <drawCharacter>
    186b:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    186e:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    1872:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    1876:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1879:	0f b6 00             	movzbl (%eax),%eax
    187c:	84 c0                	test   %al,%al
    187e:	75 b9                	jne    1839 <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    1880:	90                   	nop
    1881:	c9                   	leave  
    1882:	c3                   	ret    

00001883 <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    1883:	55                   	push   %ebp
    1884:	89 e5                	mov    %esp,%ebp
    1886:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1889:	8b 45 20             	mov    0x20(%ebp),%eax
    188c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    188f:	8b 45 24             	mov    0x24(%ebp),%eax
    1892:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1895:	8b 55 14             	mov    0x14(%ebp),%edx
    1898:	8b 45 10             	mov    0x10(%ebp),%eax
    189b:	29 c2                	sub    %eax,%edx
    189d:	89 d0                	mov    %edx,%eax
    189f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    18a2:	7d 0d                	jge    18b1 <drawRect+0x2e>
        draw_h = s.h - p.y;
    18a4:	8b 55 14             	mov    0x14(%ebp),%edx
    18a7:	8b 45 10             	mov    0x10(%ebp),%eax
    18aa:	29 c2                	sub    %eax,%edx
    18ac:	89 d0                	mov    %edx,%eax
    18ae:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    18b1:	8b 55 18             	mov    0x18(%ebp),%edx
    18b4:	8b 45 0c             	mov    0xc(%ebp),%eax
    18b7:	29 c2                	sub    %eax,%edx
    18b9:	89 d0                	mov    %edx,%eax
    18bb:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    18be:	7d 0d                	jge    18cd <drawRect+0x4a>
        draw_w = s.w - p.x;
    18c0:	8b 55 18             	mov    0x18(%ebp),%edx
    18c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    18c6:	29 c2                	sub    %eax,%edx
    18c8:	89 d0                	mov    %edx,%eax
    18ca:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    18cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    18d4:	eb 52                	jmp    1928 <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    18d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    18dd:	eb 3d                	jmp    191c <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    18df:	8b 55 10             	mov    0x10(%ebp),%edx
    18e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    18e5:	01 c2                	add    %eax,%edx
    18e7:	8b 45 18             	mov    0x18(%ebp),%eax
    18ea:	0f af c2             	imul   %edx,%eax
    18ed:	89 c2                	mov    %eax,%edx
    18ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    18f2:	01 c2                	add    %eax,%edx
    18f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    18f7:	01 c2                	add    %eax,%edx
    18f9:	89 d0                	mov    %edx,%eax
    18fb:	01 c0                	add    %eax,%eax
    18fd:	01 c2                	add    %eax,%edx
    18ff:	8b 45 08             	mov    0x8(%ebp),%eax
    1902:	01 d0                	add    %edx,%eax
    1904:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    1907:	8b 45 ec             	mov    -0x14(%ebp),%eax
    190a:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    190e:	66 89 10             	mov    %dx,(%eax)
    1911:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1915:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1918:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    191c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    191f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1922:	7c bb                	jl     18df <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1924:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1928:	8b 45 f4             	mov    -0xc(%ebp),%eax
    192b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    192e:	7c a6                	jl     18d6 <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    1930:	90                   	nop
    1931:	c9                   	leave  
    1932:	c3                   	ret    

00001933 <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    1933:	55                   	push   %ebp
    1934:	89 e5                	mov    %esp,%ebp
    1936:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    1939:	8b 45 28             	mov    0x28(%ebp),%eax
    193c:	89 45 c8             	mov    %eax,-0x38(%ebp)
    193f:	8b 45 24             	mov    0x24(%ebp),%eax
    1942:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1945:	ff 75 cc             	pushl  -0x34(%ebp)
    1948:	ff 75 c8             	pushl  -0x38(%ebp)
    194b:	83 ec 04             	sub    $0x4,%esp
    194e:	89 e0                	mov    %esp,%eax
    1950:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1954:	66 89 10             	mov    %dx,(%eax)
    1957:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    195b:	88 50 02             	mov    %dl,0x2(%eax)
    195e:	ff 75 18             	pushl  0x18(%ebp)
    1961:	ff 75 14             	pushl  0x14(%ebp)
    1964:	ff 75 10             	pushl  0x10(%ebp)
    1967:	ff 75 0c             	pushl  0xc(%ebp)
    196a:	ff 75 08             	pushl  0x8(%ebp)
    196d:	e8 11 ff ff ff       	call   1883 <drawRect>
    1972:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    1975:	8b 45 28             	mov    0x28(%ebp),%eax
    1978:	89 45 d0             	mov    %eax,-0x30(%ebp)
    197b:	8b 45 24             	mov    0x24(%ebp),%eax
    197e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1981:	8b 45 0c             	mov    0xc(%ebp),%eax
    1984:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1987:	8b 55 10             	mov    0x10(%ebp),%edx
    198a:	8b 45 20             	mov    0x20(%ebp),%eax
    198d:	01 d0                	add    %edx,%eax
    198f:	2b 45 28             	sub    0x28(%ebp),%eax
    1992:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1995:	ff 75 d4             	pushl  -0x2c(%ebp)
    1998:	ff 75 d0             	pushl  -0x30(%ebp)
    199b:	83 ec 04             	sub    $0x4,%esp
    199e:	89 e0                	mov    %esp,%eax
    19a0:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    19a4:	66 89 10             	mov    %dx,(%eax)
    19a7:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    19ab:	88 50 02             	mov    %dl,0x2(%eax)
    19ae:	ff 75 18             	pushl  0x18(%ebp)
    19b1:	ff 75 14             	pushl  0x14(%ebp)
    19b4:	ff 75 dc             	pushl  -0x24(%ebp)
    19b7:	ff 75 d8             	pushl  -0x28(%ebp)
    19ba:	ff 75 08             	pushl  0x8(%ebp)
    19bd:	e8 c1 fe ff ff       	call   1883 <drawRect>
    19c2:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    19c5:	8b 45 20             	mov    0x20(%ebp),%eax
    19c8:	8b 55 28             	mov    0x28(%ebp),%edx
    19cb:	01 d2                	add    %edx,%edx
    19cd:	29 d0                	sub    %edx,%eax
    19cf:	89 45 e0             	mov    %eax,-0x20(%ebp)
    19d2:	8b 45 28             	mov    0x28(%ebp),%eax
    19d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    19d8:	8b 45 0c             	mov    0xc(%ebp),%eax
    19db:	89 45 e8             	mov    %eax,-0x18(%ebp)
    19de:	8b 55 10             	mov    0x10(%ebp),%edx
    19e1:	8b 45 28             	mov    0x28(%ebp),%eax
    19e4:	01 d0                	add    %edx,%eax
    19e6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    19e9:	ff 75 e4             	pushl  -0x1c(%ebp)
    19ec:	ff 75 e0             	pushl  -0x20(%ebp)
    19ef:	83 ec 04             	sub    $0x4,%esp
    19f2:	89 e0                	mov    %esp,%eax
    19f4:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    19f8:	66 89 10             	mov    %dx,(%eax)
    19fb:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    19ff:	88 50 02             	mov    %dl,0x2(%eax)
    1a02:	ff 75 18             	pushl  0x18(%ebp)
    1a05:	ff 75 14             	pushl  0x14(%ebp)
    1a08:	ff 75 ec             	pushl  -0x14(%ebp)
    1a0b:	ff 75 e8             	pushl  -0x18(%ebp)
    1a0e:	ff 75 08             	pushl  0x8(%ebp)
    1a11:	e8 6d fe ff ff       	call   1883 <drawRect>
    1a16:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1a19:	8b 45 20             	mov    0x20(%ebp),%eax
    1a1c:	8b 55 28             	mov    0x28(%ebp),%edx
    1a1f:	01 d2                	add    %edx,%edx
    1a21:	29 d0                	sub    %edx,%eax
    1a23:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1a26:	8b 45 28             	mov    0x28(%ebp),%eax
    1a29:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1a2c:	8b 55 0c             	mov    0xc(%ebp),%edx
    1a2f:	8b 45 24             	mov    0x24(%ebp),%eax
    1a32:	01 d0                	add    %edx,%eax
    1a34:	2b 45 28             	sub    0x28(%ebp),%eax
    1a37:	89 45 f8             	mov    %eax,-0x8(%ebp)
    1a3a:	8b 55 10             	mov    0x10(%ebp),%edx
    1a3d:	8b 45 28             	mov    0x28(%ebp),%eax
    1a40:	01 d0                	add    %edx,%eax
    1a42:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1a45:	ff 75 f4             	pushl  -0xc(%ebp)
    1a48:	ff 75 f0             	pushl  -0x10(%ebp)
    1a4b:	83 ec 04             	sub    $0x4,%esp
    1a4e:	89 e0                	mov    %esp,%eax
    1a50:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1a54:	66 89 10             	mov    %dx,(%eax)
    1a57:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1a5b:	88 50 02             	mov    %dl,0x2(%eax)
    1a5e:	ff 75 18             	pushl  0x18(%ebp)
    1a61:	ff 75 14             	pushl  0x14(%ebp)
    1a64:	ff 75 fc             	pushl  -0x4(%ebp)
    1a67:	ff 75 f8             	pushl  -0x8(%ebp)
    1a6a:	ff 75 08             	pushl  0x8(%ebp)
    1a6d:	e8 11 fe ff ff       	call   1883 <drawRect>
    1a72:	83 c4 20             	add    $0x20,%esp
}
    1a75:	90                   	nop
    1a76:	c9                   	leave  
    1a77:	c3                   	ret    

00001a78 <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1a78:	55                   	push   %ebp
    1a79:	89 e5                	mov    %esp,%ebp
    1a7b:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1a7e:	8b 45 30             	mov    0x30(%ebp),%eax
    1a81:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    1a84:	8b 45 34             	mov    0x34(%ebp),%eax
    1a87:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    1a8a:	8b 55 20             	mov    0x20(%ebp),%edx
    1a8d:	8b 45 14             	mov    0x14(%ebp),%eax
    1a90:	29 c2                	sub    %eax,%edx
    1a92:	89 d0                	mov    %edx,%eax
    1a94:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1a97:	7d 0d                	jge    1aa6 <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    1a99:	8b 55 20             	mov    0x20(%ebp),%edx
    1a9c:	8b 45 14             	mov    0x14(%ebp),%eax
    1a9f:	29 c2                	sub    %eax,%edx
    1aa1:	89 d0                	mov    %edx,%eax
    1aa3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1aa6:	8b 55 28             	mov    0x28(%ebp),%edx
    1aa9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1aac:	29 c2                	sub    %eax,%edx
    1aae:	89 d0                	mov    %edx,%eax
    1ab0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1ab3:	7d 0d                	jge    1ac2 <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1ab5:	8b 55 28             	mov    0x28(%ebp),%edx
    1ab8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1abb:	29 c2                	sub    %eax,%edx
    1abd:	89 d0                	mov    %edx,%eax
    1abf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1ac2:	8b 55 24             	mov    0x24(%ebp),%edx
    1ac5:	8b 45 10             	mov    0x10(%ebp),%eax
    1ac8:	29 c2                	sub    %eax,%edx
    1aca:	89 d0                	mov    %edx,%eax
    1acc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1acf:	7d 0d                	jge    1ade <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    1ad1:	8b 55 24             	mov    0x24(%ebp),%edx
    1ad4:	8b 45 10             	mov    0x10(%ebp),%eax
    1ad7:	29 c2                	sub    %eax,%edx
    1ad9:	89 d0                	mov    %edx,%eax
    1adb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1ade:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1ae1:	8b 45 18             	mov    0x18(%ebp),%eax
    1ae4:	29 c2                	sub    %eax,%edx
    1ae6:	89 d0                	mov    %edx,%eax
    1ae8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1aeb:	7d 0d                	jge    1afa <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    1aed:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1af0:	8b 45 18             	mov    0x18(%ebp),%eax
    1af3:	29 c2                	sub    %eax,%edx
    1af5:	89 d0                	mov    %edx,%eax
    1af7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1afa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    1b01:	e9 83 00 00 00       	jmp    1b89 <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    1b06:	8b 55 14             	mov    0x14(%ebp),%edx
    1b09:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b0c:	01 d0                	add    %edx,%eax
    1b0e:	85 c0                	test   %eax,%eax
    1b10:	78 72                	js     1b84 <drawBitmap+0x10c>
    1b12:	8b 55 14             	mov    0x14(%ebp),%edx
    1b15:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b18:	01 c2                	add    %eax,%edx
    1b1a:	8b 45 20             	mov    0x20(%ebp),%eax
    1b1d:	39 c2                	cmp    %eax,%edx
    1b1f:	7d 63                	jge    1b84 <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    1b21:	8b 55 14             	mov    0x14(%ebp),%edx
    1b24:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b27:	01 c2                	add    %eax,%edx
    1b29:	8b 45 24             	mov    0x24(%ebp),%eax
    1b2c:	0f af c2             	imul   %edx,%eax
    1b2f:	89 c2                	mov    %eax,%edx
    1b31:	8b 45 10             	mov    0x10(%ebp),%eax
    1b34:	01 c2                	add    %eax,%edx
    1b36:	89 d0                	mov    %edx,%eax
    1b38:	01 c0                	add    %eax,%eax
    1b3a:	01 c2                	add    %eax,%edx
    1b3c:	8b 45 08             	mov    0x8(%ebp),%eax
    1b3f:	01 d0                	add    %edx,%eax
    1b41:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    1b44:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1b47:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b4a:	01 c2                	add    %eax,%edx
    1b4c:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1b4f:	0f af c2             	imul   %edx,%eax
    1b52:	89 c2                	mov    %eax,%edx
    1b54:	8b 45 18             	mov    0x18(%ebp),%eax
    1b57:	01 c2                	add    %eax,%edx
    1b59:	89 d0                	mov    %edx,%eax
    1b5b:	01 c0                	add    %eax,%eax
    1b5d:	01 c2                	add    %eax,%edx
    1b5f:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b62:	01 d0                	add    %edx,%eax
    1b64:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    1b67:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1b6a:	89 d0                	mov    %edx,%eax
    1b6c:	01 c0                	add    %eax,%eax
    1b6e:	01 d0                	add    %edx,%eax
    1b70:	83 ec 04             	sub    $0x4,%esp
    1b73:	50                   	push   %eax
    1b74:	ff 75 e4             	pushl  -0x1c(%ebp)
    1b77:	ff 75 e8             	pushl  -0x18(%ebp)
    1b7a:	e8 23 e7 ff ff       	call   2a2 <memmove>
    1b7f:	83 c4 10             	add    $0x10,%esp
    1b82:	eb 01                	jmp    1b85 <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    1b84:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1b85:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    1b89:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b8c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1b8f:	0f 8c 71 ff ff ff    	jl     1b06 <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    1b95:	90                   	nop
    1b96:	c9                   	leave  
    1b97:	c3                   	ret    

00001b98 <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1b98:	55                   	push   %ebp
    1b99:	89 e5                	mov    %esp,%ebp
    1b9b:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1b9e:	8b 45 30             	mov    0x30(%ebp),%eax
    1ba1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    1ba4:	8b 45 34             	mov    0x34(%ebp),%eax
    1ba7:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    1baa:	8b 55 20             	mov    0x20(%ebp),%edx
    1bad:	8b 45 14             	mov    0x14(%ebp),%eax
    1bb0:	29 c2                	sub    %eax,%edx
    1bb2:	89 d0                	mov    %edx,%eax
    1bb4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1bb7:	7d 0d                	jge    1bc6 <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    1bb9:	8b 55 20             	mov    0x20(%ebp),%edx
    1bbc:	8b 45 14             	mov    0x14(%ebp),%eax
    1bbf:	29 c2                	sub    %eax,%edx
    1bc1:	89 d0                	mov    %edx,%eax
    1bc3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1bc6:	8b 55 28             	mov    0x28(%ebp),%edx
    1bc9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1bcc:	29 c2                	sub    %eax,%edx
    1bce:	89 d0                	mov    %edx,%eax
    1bd0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1bd3:	7d 0d                	jge    1be2 <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1bd5:	8b 55 28             	mov    0x28(%ebp),%edx
    1bd8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1bdb:	29 c2                	sub    %eax,%edx
    1bdd:	89 d0                	mov    %edx,%eax
    1bdf:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1be2:	8b 55 24             	mov    0x24(%ebp),%edx
    1be5:	8b 45 10             	mov    0x10(%ebp),%eax
    1be8:	29 c2                	sub    %eax,%edx
    1bea:	89 d0                	mov    %edx,%eax
    1bec:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1bef:	7d 0d                	jge    1bfe <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    1bf1:	8b 55 24             	mov    0x24(%ebp),%edx
    1bf4:	8b 45 10             	mov    0x10(%ebp),%eax
    1bf7:	29 c2                	sub    %eax,%edx
    1bf9:	89 d0                	mov    %edx,%eax
    1bfb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1bfe:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1c01:	8b 45 18             	mov    0x18(%ebp),%eax
    1c04:	29 c2                	sub    %eax,%edx
    1c06:	89 d0                	mov    %edx,%eax
    1c08:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1c0b:	7d 0d                	jge    1c1a <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    1c0d:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1c10:	8b 45 18             	mov    0x18(%ebp),%eax
    1c13:	29 c2                	sub    %eax,%edx
    1c15:	89 d0                	mov    %edx,%eax
    1c17:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    1c1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1c21:	e9 b8 00 00 00       	jmp    1cde <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    1c26:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1c2d:	e9 9c 00 00 00       	jmp    1cce <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    1c32:	8b 55 14             	mov    0x14(%ebp),%edx
    1c35:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1c38:	01 c2                	add    %eax,%edx
    1c3a:	8b 45 24             	mov    0x24(%ebp),%eax
    1c3d:	0f af c2             	imul   %edx,%eax
    1c40:	89 c2                	mov    %eax,%edx
    1c42:	8b 45 10             	mov    0x10(%ebp),%eax
    1c45:	01 c2                	add    %eax,%edx
    1c47:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1c4a:	01 c2                	add    %eax,%edx
    1c4c:	89 d0                	mov    %edx,%eax
    1c4e:	01 c0                	add    %eax,%eax
    1c50:	01 c2                	add    %eax,%edx
    1c52:	8b 45 08             	mov    0x8(%ebp),%eax
    1c55:	01 d0                	add    %edx,%eax
    1c57:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    1c5a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1c5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1c60:	01 c2                	add    %eax,%edx
    1c62:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1c65:	0f af c2             	imul   %edx,%eax
    1c68:	89 c2                	mov    %eax,%edx
    1c6a:	8b 45 18             	mov    0x18(%ebp),%eax
    1c6d:	01 c2                	add    %eax,%edx
    1c6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1c72:	01 c2                	add    %eax,%edx
    1c74:	89 d0                	mov    %edx,%eax
    1c76:	01 c0                	add    %eax,%eax
    1c78:	01 c2                	add    %eax,%edx
    1c7a:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c7d:	01 d0                	add    %edx,%eax
    1c7f:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    1c82:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c85:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1c89:	3c ff                	cmp    $0xff,%al
    1c8b:	75 15                	jne    1ca2 <drawTransparentBitmap+0x10a>
    1c8d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c90:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1c94:	3c ff                	cmp    $0xff,%al
    1c96:	75 0a                	jne    1ca2 <drawTransparentBitmap+0x10a>
    1c98:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c9b:	0f b6 00             	movzbl (%eax),%eax
    1c9e:	3c ff                	cmp    $0xff,%al
    1ca0:	74 27                	je     1cc9 <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    1ca2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1ca5:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    1ca9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1cac:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    1caf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1cb2:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    1cb6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1cb9:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    1cbc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1cbf:	0f b6 10             	movzbl (%eax),%edx
    1cc2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1cc5:	88 10                	mov    %dl,(%eax)
    1cc7:	eb 01                	jmp    1cca <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    1cc9:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    1cca:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1cce:	8b 45 34             	mov    0x34(%ebp),%eax
    1cd1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1cd4:	0f 8f 58 ff ff ff    	jg     1c32 <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    1cda:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1cde:	8b 45 30             	mov    0x30(%ebp),%eax
    1ce1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1ce4:	0f 8f 3c ff ff ff    	jg     1c26 <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    1cea:	90                   	nop
    1ceb:	c9                   	leave  
    1cec:	c3                   	ret    

00001ced <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    1ced:	55                   	push   %ebp
    1cee:	89 e5                	mov    %esp,%ebp
    1cf0:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    1cf3:	ff 75 24             	pushl  0x24(%ebp)
    1cf6:	ff 75 20             	pushl  0x20(%ebp)
    1cf9:	ff 75 1c             	pushl  0x1c(%ebp)
    1cfc:	ff 75 18             	pushl  0x18(%ebp)
    1cff:	ff 75 1c             	pushl  0x1c(%ebp)
    1d02:	ff 75 18             	pushl  0x18(%ebp)
    1d05:	ff 75 14             	pushl  0x14(%ebp)
    1d08:	ff 75 10             	pushl  0x10(%ebp)
    1d0b:	ff 75 14             	pushl  0x14(%ebp)
    1d0e:	ff 75 10             	pushl  0x10(%ebp)
    1d11:	ff 75 0c             	pushl  0xc(%ebp)
    1d14:	ff 75 08             	pushl  0x8(%ebp)
    1d17:	e8 5c fd ff ff       	call   1a78 <drawBitmap>
    1d1c:	83 c4 30             	add    $0x30,%esp
}
    1d1f:	90                   	nop
    1d20:	c9                   	leave  
    1d21:	c3                   	ret    

00001d22 <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    1d22:	55                   	push   %ebp
    1d23:	89 e5                	mov    %esp,%ebp
    1d25:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1d28:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1d2b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1d2e:	8b 45 20             	mov    0x20(%ebp),%eax
    1d31:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1d34:	8b 55 14             	mov    0x14(%ebp),%edx
    1d37:	8b 45 10             	mov    0x10(%ebp),%eax
    1d3a:	29 c2                	sub    %eax,%edx
    1d3c:	89 d0                	mov    %edx,%eax
    1d3e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1d41:	7d 0d                	jge    1d50 <colorShift+0x2e>
        draw_h = s.h - p.y;
    1d43:	8b 55 14             	mov    0x14(%ebp),%edx
    1d46:	8b 45 10             	mov    0x10(%ebp),%eax
    1d49:	29 c2                	sub    %eax,%edx
    1d4b:	89 d0                	mov    %edx,%eax
    1d4d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1d50:	8b 55 18             	mov    0x18(%ebp),%edx
    1d53:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d56:	29 c2                	sub    %eax,%edx
    1d58:	89 d0                	mov    %edx,%eax
    1d5a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1d5d:	7d 0d                	jge    1d6c <colorShift+0x4a>
        draw_w = s.w - p.x;
    1d5f:	8b 55 18             	mov    0x18(%ebp),%edx
    1d62:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d65:	29 c2                	sub    %eax,%edx
    1d67:	89 d0                	mov    %edx,%eax
    1d69:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1d6c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1d73:	e9 fc 00 00 00       	jmp    1e74 <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    1d78:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1d7f:	e9 e0 00 00 00       	jmp    1e64 <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    1d84:	8b 55 10             	mov    0x10(%ebp),%edx
    1d87:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1d8a:	01 c2                	add    %eax,%edx
    1d8c:	8b 45 18             	mov    0x18(%ebp),%eax
    1d8f:	0f af c2             	imul   %edx,%eax
    1d92:	89 c2                	mov    %eax,%edx
    1d94:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d97:	01 c2                	add    %eax,%edx
    1d99:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1d9c:	01 c2                	add    %eax,%edx
    1d9e:	89 d0                	mov    %edx,%eax
    1da0:	01 c0                	add    %eax,%eax
    1da2:	01 c2                	add    %eax,%edx
    1da4:	8b 45 08             	mov    0x8(%ebp),%eax
    1da7:	01 d0                	add    %edx,%eax
    1da9:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    1dac:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1daf:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1db3:	3c c8                	cmp    $0xc8,%al
    1db5:	0f 86 a5 00 00 00    	jbe    1e60 <colorShift+0x13e>
    1dbb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dbe:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1dc2:	3c c8                	cmp    $0xc8,%al
    1dc4:	0f 86 96 00 00 00    	jbe    1e60 <colorShift+0x13e>
    1dca:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dcd:	0f b6 00             	movzbl (%eax),%eax
    1dd0:	3c c8                	cmp    $0xc8,%al
    1dd2:	0f 86 88 00 00 00    	jbe    1e60 <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    1dd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ddb:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1ddf:	0f b6 d0             	movzbl %al,%edx
    1de2:	8b 45 24             	mov    0x24(%ebp),%eax
    1de5:	01 d0                	add    %edx,%eax
    1de7:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1ded:	89 d0                	mov    %edx,%eax
    1def:	c1 f8 1f             	sar    $0x1f,%eax
    1df2:	c1 e8 18             	shr    $0x18,%eax
    1df5:	01 c2                	add    %eax,%edx
    1df7:	0f b6 d2             	movzbl %dl,%edx
    1dfa:	29 c2                	sub    %eax,%edx
    1dfc:	89 d0                	mov    %edx,%eax
    1dfe:	89 c2                	mov    %eax,%edx
    1e00:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e03:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    1e06:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e09:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1e0d:	0f b6 d0             	movzbl %al,%edx
    1e10:	8b 45 24             	mov    0x24(%ebp),%eax
    1e13:	01 d0                	add    %edx,%eax
    1e15:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1e1b:	89 d0                	mov    %edx,%eax
    1e1d:	c1 f8 1f             	sar    $0x1f,%eax
    1e20:	c1 e8 18             	shr    $0x18,%eax
    1e23:	01 c2                	add    %eax,%edx
    1e25:	0f b6 d2             	movzbl %dl,%edx
    1e28:	29 c2                	sub    %eax,%edx
    1e2a:	89 d0                	mov    %edx,%eax
    1e2c:	89 c2                	mov    %eax,%edx
    1e2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e31:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    1e34:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e37:	0f b6 00             	movzbl (%eax),%eax
    1e3a:	0f b6 d0             	movzbl %al,%edx
    1e3d:	8b 45 24             	mov    0x24(%ebp),%eax
    1e40:	01 d0                	add    %edx,%eax
    1e42:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1e48:	89 d0                	mov    %edx,%eax
    1e4a:	c1 f8 1f             	sar    $0x1f,%eax
    1e4d:	c1 e8 18             	shr    $0x18,%eax
    1e50:	01 c2                	add    %eax,%edx
    1e52:	0f b6 d2             	movzbl %dl,%edx
    1e55:	29 c2                	sub    %eax,%edx
    1e57:	89 d0                	mov    %edx,%eax
    1e59:	89 c2                	mov    %eax,%edx
    1e5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e5e:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1e60:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1e64:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e67:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1e6a:	0f 8c 14 ff ff ff    	jl     1d84 <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1e70:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1e74:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e77:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1e7a:	0f 8c f8 fe ff ff    	jl     1d78 <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    1e80:	90                   	nop
    1e81:	c9                   	leave  
    1e82:	c3                   	ret    

00001e83 <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    1e83:	55                   	push   %ebp
    1e84:	89 e5                	mov    %esp,%ebp
    1e86:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1e89:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1e90:	e9 fb 00 00 00       	jmp    1f90 <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    1e95:	8b 55 14             	mov    0x14(%ebp),%edx
    1e98:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1e9b:	01 c2                	add    %eax,%edx
    1e9d:	0f b7 05 56 e5 01 00 	movzwl 0x1e556,%eax
    1ea4:	0f b7 c0             	movzwl %ax,%eax
    1ea7:	39 c2                	cmp    %eax,%edx
    1ea9:	0f 8f eb 00 00 00    	jg     1f9a <drawMouse+0x117>
    1eaf:	8b 55 14             	mov    0x14(%ebp),%edx
    1eb2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1eb5:	01 d0                	add    %edx,%eax
    1eb7:	85 c0                	test   %eax,%eax
    1eb9:	0f 88 db 00 00 00    	js     1f9a <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1ebf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1ec6:	e9 b7 00 00 00       	jmp    1f82 <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    1ecb:	8b 55 10             	mov    0x10(%ebp),%edx
    1ece:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1ed1:	01 c2                	add    %eax,%edx
    1ed3:	0f b7 05 54 e5 01 00 	movzwl 0x1e554,%eax
    1eda:	0f b7 c0             	movzwl %ax,%eax
    1edd:	39 c2                	cmp    %eax,%edx
    1edf:	0f 8f a7 00 00 00    	jg     1f8c <drawMouse+0x109>
    1ee5:	8b 55 10             	mov    0x10(%ebp),%edx
    1ee8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1eeb:	01 d0                	add    %edx,%eax
    1eed:	85 c0                	test   %eax,%eax
    1eef:	0f 88 97 00 00 00    	js     1f8c <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    1ef5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1ef8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1efb:	89 d0                	mov    %edx,%eax
    1efd:	c1 e0 04             	shl    $0x4,%eax
    1f00:	29 d0                	sub    %edx,%eax
    1f02:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    1f08:	01 c2                	add    %eax,%edx
    1f0a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1f0d:	01 d0                	add    %edx,%eax
    1f0f:	05 80 5e 01 00       	add    $0x15e80,%eax
    1f14:	0f b6 00             	movzbl (%eax),%eax
    1f17:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    1f1a:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    1f1e:	74 5e                	je     1f7e <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    1f20:	8b 55 14             	mov    0x14(%ebp),%edx
    1f23:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1f26:	01 c2                	add    %eax,%edx
    1f28:	0f b7 05 54 e5 01 00 	movzwl 0x1e554,%eax
    1f2f:	0f b7 c0             	movzwl %ax,%eax
    1f32:	0f af c2             	imul   %edx,%eax
    1f35:	89 c2                	mov    %eax,%edx
    1f37:	8b 45 10             	mov    0x10(%ebp),%eax
    1f3a:	01 c2                	add    %eax,%edx
    1f3c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1f3f:	01 c2                	add    %eax,%edx
    1f41:	89 d0                	mov    %edx,%eax
    1f43:	01 c0                	add    %eax,%eax
    1f45:	01 c2                	add    %eax,%edx
    1f47:	8b 45 08             	mov    0x8(%ebp),%eax
    1f4a:	01 d0                	add    %edx,%eax
    1f4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    1f4f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    1f53:	8d 50 ff             	lea    -0x1(%eax),%edx
    1f56:	89 d0                	mov    %edx,%eax
    1f58:	01 c0                	add    %eax,%eax
    1f5a:	01 d0                	add    %edx,%eax
    1f5c:	05 5c e5 01 00       	add    $0x1e55c,%eax
    1f61:	83 ec 04             	sub    $0x4,%esp
    1f64:	89 e2                	mov    %esp,%edx
    1f66:	0f b7 08             	movzwl (%eax),%ecx
    1f69:	66 89 0a             	mov    %cx,(%edx)
    1f6c:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1f70:	88 42 02             	mov    %al,0x2(%edx)
    1f73:	ff 75 f0             	pushl  -0x10(%ebp)
    1f76:	e8 73 f6 ff ff       	call   15ee <drawPoint>
    1f7b:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1f7e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    1f82:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    1f86:	0f 8e 3f ff ff ff    	jle    1ecb <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1f8c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    1f90:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    1f94:	0f 8e fb fe ff ff    	jle    1e95 <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    1f9a:	90                   	nop
    1f9b:	c9                   	leave  
    1f9c:	c3                   	ret    

00001f9d <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    1f9d:	55                   	push   %ebp
    1f9e:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    1fa0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1fa4:	78 1b                	js     1fc1 <getColor+0x24>
    1fa6:	8b 45 08             	mov    0x8(%ebp),%eax
    1fa9:	8b 40 04             	mov    0x4(%eax),%eax
    1fac:	3b 45 0c             	cmp    0xc(%ebp),%eax
    1faf:	7c 10                	jl     1fc1 <getColor+0x24>
    1fb1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    1fb5:	78 0a                	js     1fc1 <getColor+0x24>
    1fb7:	8b 45 08             	mov    0x8(%ebp),%eax
    1fba:	8b 00                	mov    (%eax),%eax
    1fbc:	3b 45 10             	cmp    0x10(%ebp),%eax
    1fbf:	7d 10                	jge    1fd1 <getColor+0x34>
    {
        *isInPic = 1;
    1fc1:	8b 45 14             	mov    0x14(%ebp),%eax
    1fc4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    1fca:	b8 11 e1 01 00       	mov    $0x1e111,%eax
    1fcf:	eb 44                	jmp    2015 <getColor+0x78>
    }

    if (y == pic->height)
    1fd1:	8b 45 08             	mov    0x8(%ebp),%eax
    1fd4:	8b 40 04             	mov    0x4(%eax),%eax
    1fd7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    1fda:	75 04                	jne    1fe0 <getColor+0x43>
        y--;
    1fdc:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    1fe0:	8b 45 08             	mov    0x8(%ebp),%eax
    1fe3:	8b 00                	mov    (%eax),%eax
    1fe5:	3b 45 10             	cmp    0x10(%ebp),%eax
    1fe8:	75 04                	jne    1fee <getColor+0x51>
        x--;
    1fea:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    1fee:	8b 45 14             	mov    0x14(%ebp),%eax
    1ff1:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    1ff7:	8b 45 08             	mov    0x8(%ebp),%eax
    1ffa:	8b 48 08             	mov    0x8(%eax),%ecx
    1ffd:	8b 45 08             	mov    0x8(%ebp),%eax
    2000:	8b 00                	mov    (%eax),%eax
    2002:	0f af 45 0c          	imul   0xc(%ebp),%eax
    2006:	89 c2                	mov    %eax,%edx
    2008:	8b 45 10             	mov    0x10(%ebp),%eax
    200b:	01 c2                	add    %eax,%edx
    200d:	89 d0                	mov    %edx,%eax
    200f:	01 c0                	add    %eax,%eax
    2011:	01 d0                	add    %edx,%eax
    2013:	01 c8                	add    %ecx,%eax
}
    2015:	5d                   	pop    %ebp
    2016:	c3                   	ret    

00002017 <setColor>:

int setColor(RGB *src, RGB *dst)
{
    2017:	55                   	push   %ebp
    2018:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    201a:	8b 45 08             	mov    0x8(%ebp),%eax
    201d:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    2021:	8b 45 0c             	mov    0xc(%ebp),%eax
    2024:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    2027:	8b 45 08             	mov    0x8(%ebp),%eax
    202a:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    202e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2031:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    2034:	8b 45 08             	mov    0x8(%ebp),%eax
    2037:	0f b6 10             	movzbl (%eax),%edx
    203a:	8b 45 0c             	mov    0xc(%ebp),%eax
    203d:	88 10                	mov    %dl,(%eax)

    return 1;
    203f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2044:	5d                   	pop    %ebp
    2045:	c3                   	ret    

00002046 <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    2046:	55                   	push   %ebp
    2047:	89 e5                	mov    %esp,%ebp
    2049:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    204c:	d9 45 10             	flds   0x10(%ebp)
    204f:	d9 7d be             	fnstcw -0x42(%ebp)
    2052:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    2056:	b4 0c                	mov    $0xc,%ah
    2058:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    205c:	d9 6d bc             	fldcw  -0x44(%ebp)
    205f:	db 5d fc             	fistpl -0x4(%ebp)
    2062:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    2065:	d9 45 0c             	flds   0xc(%ebp)
    2068:	d9 6d bc             	fldcw  -0x44(%ebp)
    206b:	db 5d f8             	fistpl -0x8(%ebp)
    206e:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    2071:	db 45 fc             	fildl  -0x4(%ebp)
    2074:	d9 45 10             	flds   0x10(%ebp)
    2077:	d9 c9                	fxch   %st(1)
    2079:	df e9                	fucomip %st(1),%st
    207b:	dd d8                	fstp   %st(0)
    207d:	76 04                	jbe    2083 <mixColor+0x3d>
        x--;
    207f:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    2083:	db 45 f8             	fildl  -0x8(%ebp)
    2086:	d9 45 0c             	flds   0xc(%ebp)
    2089:	d9 c9                	fxch   %st(1)
    208b:	df e9                	fucomip %st(1),%st
    208d:	dd d8                	fstp   %st(0)
    208f:	76 04                	jbe    2095 <mixColor+0x4f>
        y--;
    2091:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2095:	8d 45 c0             	lea    -0x40(%ebp),%eax
    2098:	50                   	push   %eax
    2099:	ff 75 fc             	pushl  -0x4(%ebp)
    209c:	ff 75 f8             	pushl  -0x8(%ebp)
    209f:	ff 75 08             	pushl  0x8(%ebp)
    20a2:	e8 f6 fe ff ff       	call   1f9d <getColor>
    20a7:	83 c4 10             	add    $0x10,%esp
    20aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    20ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
    20b0:	83 c0 01             	add    $0x1,%eax
    20b3:	8d 55 c0             	lea    -0x40(%ebp),%edx
    20b6:	83 c2 04             	add    $0x4,%edx
    20b9:	52                   	push   %edx
    20ba:	ff 75 fc             	pushl  -0x4(%ebp)
    20bd:	50                   	push   %eax
    20be:	ff 75 08             	pushl  0x8(%ebp)
    20c1:	e8 d7 fe ff ff       	call   1f9d <getColor>
    20c6:	83 c4 10             	add    $0x10,%esp
    20c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    20cc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    20cf:	83 c0 01             	add    $0x1,%eax
    20d2:	8d 55 c0             	lea    -0x40(%ebp),%edx
    20d5:	83 c2 08             	add    $0x8,%edx
    20d8:	52                   	push   %edx
    20d9:	50                   	push   %eax
    20da:	ff 75 f8             	pushl  -0x8(%ebp)
    20dd:	ff 75 08             	pushl  0x8(%ebp)
    20e0:	e8 b8 fe ff ff       	call   1f9d <getColor>
    20e5:	83 c4 10             	add    $0x10,%esp
    20e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    20eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    20ee:	8d 50 01             	lea    0x1(%eax),%edx
    20f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    20f4:	83 c0 01             	add    $0x1,%eax
    20f7:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    20fa:	83 c1 0c             	add    $0xc,%ecx
    20fd:	51                   	push   %ecx
    20fe:	52                   	push   %edx
    20ff:	50                   	push   %eax
    2100:	ff 75 08             	pushl  0x8(%ebp)
    2103:	e8 95 fe ff ff       	call   1f9d <getColor>
    2108:	83 c4 10             	add    $0x10,%esp
    210b:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    210e:	db 45 fc             	fildl  -0x4(%ebp)
    2111:	d9 45 10             	flds   0x10(%ebp)
    2114:	de e1                	fsubp  %st,%st(1)
    2116:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    2119:	db 45 f8             	fildl  -0x8(%ebp)
    211c:	d9 45 0c             	flds   0xc(%ebp)
    211f:	de e1                	fsubp  %st,%st(1)
    2121:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    2124:	d9 45 e4             	flds   -0x1c(%ebp)
    2127:	d8 4d e0             	fmuls  -0x20(%ebp)
    212a:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    212d:	d9 e8                	fld1   
    212f:	d8 65 e0             	fsubs  -0x20(%ebp)
    2132:	d8 4d e4             	fmuls  -0x1c(%ebp)
    2135:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    2138:	d9 e8                	fld1   
    213a:	d8 65 e4             	fsubs  -0x1c(%ebp)
    213d:	d8 4d e0             	fmuls  -0x20(%ebp)
    2140:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    2143:	d9 e8                	fld1   
    2145:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2148:	d9 e8                	fld1   
    214a:	d8 65 e0             	fsubs  -0x20(%ebp)
    214d:	de c9                	fmulp  %st,%st(1)
    214f:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    2152:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2155:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2159:	0f b6 c0             	movzbl %al,%eax
    215c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    215f:	db 45 b4             	fildl  -0x4c(%ebp)
    2162:	d8 4d d0             	fmuls  -0x30(%ebp)
    2165:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2168:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    216b:	db 45 b4             	fildl  -0x4c(%ebp)
    216e:	de c9                	fmulp  %st,%st(1)
    2170:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2173:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2177:	0f b6 c0             	movzbl %al,%eax
    217a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    217d:	db 45 b4             	fildl  -0x4c(%ebp)
    2180:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2183:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2186:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2189:	db 45 b4             	fildl  -0x4c(%ebp)
    218c:	de c9                	fmulp  %st,%st(1)
    218e:	de c1                	faddp  %st,%st(1)
    2190:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2193:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2197:	0f b6 c0             	movzbl %al,%eax
    219a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    219d:	db 45 b4             	fildl  -0x4c(%ebp)
    21a0:	d8 4d d8             	fmuls  -0x28(%ebp)
    21a3:	8b 45 c8             	mov    -0x38(%ebp),%eax
    21a6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21a9:	db 45 b4             	fildl  -0x4c(%ebp)
    21ac:	de c9                	fmulp  %st,%st(1)
    21ae:	de c1                	faddp  %st,%st(1)
    21b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    21b3:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    21b7:	0f b6 c0             	movzbl %al,%eax
    21ba:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21bd:	db 45 b4             	fildl  -0x4c(%ebp)
    21c0:	d8 4d dc             	fmuls  -0x24(%ebp)
    21c3:	8b 45 cc             	mov    -0x34(%ebp),%eax
    21c6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21c9:	db 45 b4             	fildl  -0x4c(%ebp)
    21cc:	de c9                	fmulp  %st,%st(1)
    21ce:	de c1                	faddp  %st,%st(1)
    21d0:	d9 7d be             	fnstcw -0x42(%ebp)
    21d3:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    21d7:	b4 0c                	mov    $0xc,%ah
    21d9:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    21dd:	d9 6d bc             	fldcw  -0x44(%ebp)
    21e0:	db 5d b8             	fistpl -0x48(%ebp)
    21e3:	d9 6d be             	fldcw  -0x42(%ebp)
    21e6:	8b 45 b8             	mov    -0x48(%ebp),%eax
    21e9:	89 c2                	mov    %eax,%edx
    21eb:	8b 45 14             	mov    0x14(%ebp),%eax
    21ee:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    21f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    21f4:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    21f8:	0f b6 c0             	movzbl %al,%eax
    21fb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21fe:	db 45 b4             	fildl  -0x4c(%ebp)
    2201:	d8 4d d0             	fmuls  -0x30(%ebp)
    2204:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2207:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    220a:	db 45 b4             	fildl  -0x4c(%ebp)
    220d:	de c9                	fmulp  %st,%st(1)
    220f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2212:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2216:	0f b6 c0             	movzbl %al,%eax
    2219:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    221c:	db 45 b4             	fildl  -0x4c(%ebp)
    221f:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2222:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2225:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2228:	db 45 b4             	fildl  -0x4c(%ebp)
    222b:	de c9                	fmulp  %st,%st(1)
    222d:	de c1                	faddp  %st,%st(1)
    222f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2232:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2236:	0f b6 c0             	movzbl %al,%eax
    2239:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    223c:	db 45 b4             	fildl  -0x4c(%ebp)
    223f:	d8 4d d8             	fmuls  -0x28(%ebp)
    2242:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2245:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2248:	db 45 b4             	fildl  -0x4c(%ebp)
    224b:	de c9                	fmulp  %st,%st(1)
    224d:	de c1                	faddp  %st,%st(1)
    224f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2252:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2256:	0f b6 c0             	movzbl %al,%eax
    2259:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    225c:	db 45 b4             	fildl  -0x4c(%ebp)
    225f:	d8 4d dc             	fmuls  -0x24(%ebp)
    2262:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2265:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2268:	db 45 b4             	fildl  -0x4c(%ebp)
    226b:	de c9                	fmulp  %st,%st(1)
    226d:	de c1                	faddp  %st,%st(1)
    226f:	d9 6d bc             	fldcw  -0x44(%ebp)
    2272:	db 5d b8             	fistpl -0x48(%ebp)
    2275:	d9 6d be             	fldcw  -0x42(%ebp)
    2278:	8b 45 b8             	mov    -0x48(%ebp),%eax
    227b:	89 c2                	mov    %eax,%edx
    227d:	8b 45 14             	mov    0x14(%ebp),%eax
    2280:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    2283:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2286:	0f b6 00             	movzbl (%eax),%eax
    2289:	0f b6 c0             	movzbl %al,%eax
    228c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    228f:	db 45 b4             	fildl  -0x4c(%ebp)
    2292:	d8 4d d0             	fmuls  -0x30(%ebp)
    2295:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2298:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    229b:	db 45 b4             	fildl  -0x4c(%ebp)
    229e:	de c9                	fmulp  %st,%st(1)
    22a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    22a3:	0f b6 00             	movzbl (%eax),%eax
    22a6:	0f b6 c0             	movzbl %al,%eax
    22a9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22ac:	db 45 b4             	fildl  -0x4c(%ebp)
    22af:	d8 4d d4             	fmuls  -0x2c(%ebp)
    22b2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    22b5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22b8:	db 45 b4             	fildl  -0x4c(%ebp)
    22bb:	de c9                	fmulp  %st,%st(1)
    22bd:	de c1                	faddp  %st,%st(1)
    22bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    22c2:	0f b6 00             	movzbl (%eax),%eax
    22c5:	0f b6 c0             	movzbl %al,%eax
    22c8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22cb:	db 45 b4             	fildl  -0x4c(%ebp)
    22ce:	d8 4d d8             	fmuls  -0x28(%ebp)
    22d1:	8b 45 c8             	mov    -0x38(%ebp),%eax
    22d4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22d7:	db 45 b4             	fildl  -0x4c(%ebp)
    22da:	de c9                	fmulp  %st,%st(1)
    22dc:	de c1                	faddp  %st,%st(1)
    22de:	8b 45 e8             	mov    -0x18(%ebp),%eax
    22e1:	0f b6 00             	movzbl (%eax),%eax
    22e4:	0f b6 c0             	movzbl %al,%eax
    22e7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22ea:	db 45 b4             	fildl  -0x4c(%ebp)
    22ed:	d8 4d dc             	fmuls  -0x24(%ebp)
    22f0:	8b 45 cc             	mov    -0x34(%ebp),%eax
    22f3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22f6:	db 45 b4             	fildl  -0x4c(%ebp)
    22f9:	de c9                	fmulp  %st,%st(1)
    22fb:	de c1                	faddp  %st,%st(1)
    22fd:	d9 6d bc             	fldcw  -0x44(%ebp)
    2300:	db 5d b8             	fistpl -0x48(%ebp)
    2303:	d9 6d be             	fldcw  -0x42(%ebp)
    2306:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2309:	89 c2                	mov    %eax,%edx
    230b:	8b 45 14             	mov    0x14(%ebp),%eax
    230e:	88 10                	mov    %dl,(%eax)

    return 1;
    2310:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2315:	c9                   	leave  
    2316:	c3                   	ret    

00002317 <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    2317:	55                   	push   %ebp
    2318:	89 e5                	mov    %esp,%ebp
    231a:	53                   	push   %ebx
    231b:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    231e:	8b 45 10             	mov    0x10(%ebp),%eax
    2321:	c1 f8 10             	sar    $0x10,%eax
    2324:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    2327:	8b 45 0c             	mov    0xc(%ebp),%eax
    232a:	c1 f8 10             	sar    $0x10,%eax
    232d:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2330:	8d 45 bc             	lea    -0x44(%ebp),%eax
    2333:	50                   	push   %eax
    2334:	ff 75 f8             	pushl  -0x8(%ebp)
    2337:	ff 75 f4             	pushl  -0xc(%ebp)
    233a:	ff 75 08             	pushl  0x8(%ebp)
    233d:	e8 5b fc ff ff       	call   1f9d <getColor>
    2342:	83 c4 10             	add    $0x10,%esp
    2345:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    2348:	8b 45 f4             	mov    -0xc(%ebp),%eax
    234b:	83 c0 01             	add    $0x1,%eax
    234e:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2351:	83 c2 04             	add    $0x4,%edx
    2354:	52                   	push   %edx
    2355:	ff 75 f8             	pushl  -0x8(%ebp)
    2358:	50                   	push   %eax
    2359:	ff 75 08             	pushl  0x8(%ebp)
    235c:	e8 3c fc ff ff       	call   1f9d <getColor>
    2361:	83 c4 10             	add    $0x10,%esp
    2364:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    2367:	8b 45 f8             	mov    -0x8(%ebp),%eax
    236a:	83 c0 01             	add    $0x1,%eax
    236d:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2370:	83 c2 08             	add    $0x8,%edx
    2373:	52                   	push   %edx
    2374:	50                   	push   %eax
    2375:	ff 75 f4             	pushl  -0xc(%ebp)
    2378:	ff 75 08             	pushl  0x8(%ebp)
    237b:	e8 1d fc ff ff       	call   1f9d <getColor>
    2380:	83 c4 10             	add    $0x10,%esp
    2383:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    2386:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2389:	8d 50 01             	lea    0x1(%eax),%edx
    238c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    238f:	83 c0 01             	add    $0x1,%eax
    2392:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    2395:	83 c1 0c             	add    $0xc,%ecx
    2398:	51                   	push   %ecx
    2399:	52                   	push   %edx
    239a:	50                   	push   %eax
    239b:	ff 75 08             	pushl  0x8(%ebp)
    239e:	e8 fa fb ff ff       	call   1f9d <getColor>
    23a3:	83 c4 10             	add    $0x10,%esp
    23a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    23a9:	8b 45 10             	mov    0x10(%ebp),%eax
    23ac:	0f b7 c0             	movzwl %ax,%eax
    23af:	c1 f8 08             	sar    $0x8,%eax
    23b2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    23b5:	8b 45 0c             	mov    0xc(%ebp),%eax
    23b8:	0f b7 c0             	movzwl %ax,%eax
    23bb:	c1 f8 08             	sar    $0x8,%eax
    23be:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    23c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    23c4:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    23c8:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    23cb:	b8 ff 00 00 00       	mov    $0xff,%eax
    23d0:	2b 45 dc             	sub    -0x24(%ebp),%eax
    23d3:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    23d7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    23da:	b8 ff 00 00 00       	mov    $0xff,%eax
    23df:	2b 45 e0             	sub    -0x20(%ebp),%eax
    23e2:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    23e6:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    23e9:	b8 ff 00 00 00       	mov    $0xff,%eax
    23ee:	2b 45 e0             	sub    -0x20(%ebp),%eax
    23f1:	89 c2                	mov    %eax,%edx
    23f3:	b8 ff 00 00 00       	mov    $0xff,%eax
    23f8:	2b 45 dc             	sub    -0x24(%ebp),%eax
    23fb:	0f af c2             	imul   %edx,%eax
    23fe:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    2401:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2404:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2408:	0f b6 c0             	movzbl %al,%eax
    240b:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    240f:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2412:	0f af d0             	imul   %eax,%edx
    2415:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2418:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    241c:	0f b6 c0             	movzbl %al,%eax
    241f:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2423:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2426:	0f af c1             	imul   %ecx,%eax
    2429:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    242c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    242f:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2433:	0f b6 c0             	movzbl %al,%eax
    2436:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    243a:	8b 55 c8             	mov    -0x38(%ebp),%edx
    243d:	0f af d0             	imul   %eax,%edx
    2440:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2443:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2447:	0f b6 c0             	movzbl %al,%eax
    244a:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    244e:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2451:	0f af c1             	imul   %ecx,%eax
    2454:	01 d0                	add    %edx,%eax
    2456:	01 d8                	add    %ebx,%eax
    2458:	c1 e8 10             	shr    $0x10,%eax
    245b:	89 c2                	mov    %eax,%edx
    245d:	8b 45 14             	mov    0x14(%ebp),%eax
    2460:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    2463:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2466:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    246a:	0f b6 c0             	movzbl %al,%eax
    246d:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2471:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2474:	0f af d0             	imul   %eax,%edx
    2477:	8b 45 ec             	mov    -0x14(%ebp),%eax
    247a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    247e:	0f b6 c0             	movzbl %al,%eax
    2481:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2485:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2488:	0f af c1             	imul   %ecx,%eax
    248b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    248e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2491:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2495:	0f b6 c0             	movzbl %al,%eax
    2498:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    249c:	8b 55 c8             	mov    -0x38(%ebp),%edx
    249f:	0f af d0             	imul   %eax,%edx
    24a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    24a5:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    24a9:	0f b6 c0             	movzbl %al,%eax
    24ac:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    24b0:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    24b3:	0f af c1             	imul   %ecx,%eax
    24b6:	01 d0                	add    %edx,%eax
    24b8:	01 d8                	add    %ebx,%eax
    24ba:	c1 e8 10             	shr    $0x10,%eax
    24bd:	89 c2                	mov    %eax,%edx
    24bf:	8b 45 14             	mov    0x14(%ebp),%eax
    24c2:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    24c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    24c8:	0f b6 00             	movzbl (%eax),%eax
    24cb:	0f b6 c0             	movzbl %al,%eax
    24ce:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    24d2:	8b 55 bc             	mov    -0x44(%ebp),%edx
    24d5:	0f af d0             	imul   %eax,%edx
    24d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24db:	0f b6 00             	movzbl (%eax),%eax
    24de:	0f b6 c0             	movzbl %al,%eax
    24e1:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    24e5:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    24e8:	0f af c1             	imul   %ecx,%eax
    24eb:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    24ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    24f1:	0f b6 00             	movzbl (%eax),%eax
    24f4:	0f b6 c0             	movzbl %al,%eax
    24f7:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    24fb:	8b 55 c8             	mov    -0x38(%ebp),%edx
    24fe:	0f af d0             	imul   %eax,%edx
    2501:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2504:	0f b6 00             	movzbl (%eax),%eax
    2507:	0f b6 c0             	movzbl %al,%eax
    250a:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    250e:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2511:	0f af c1             	imul   %ecx,%eax
    2514:	01 d0                	add    %edx,%eax
    2516:	01 d8                	add    %ebx,%eax
    2518:	c1 e8 10             	shr    $0x10,%eax
    251b:	89 c2                	mov    %eax,%edx
    251d:	8b 45 14             	mov    0x14(%ebp),%eax
    2520:	88 10                	mov    %dl,(%eax)
}
    2522:	90                   	nop
    2523:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2526:	c9                   	leave  
    2527:	c3                   	ret    

00002528 <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    2528:	55                   	push   %ebp
    2529:	89 e5                	mov    %esp,%ebp
    252b:	53                   	push   %ebx
    252c:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    252f:	8b 45 08             	mov    0x8(%ebp),%eax
    2532:	8b 00                	mov    (%eax),%eax
    2534:	c1 e0 10             	shl    $0x10,%eax
    2537:	89 c1                	mov    %eax,%ecx
    2539:	8b 45 0c             	mov    0xc(%ebp),%eax
    253c:	8b 18                	mov    (%eax),%ebx
    253e:	89 c8                	mov    %ecx,%eax
    2540:	99                   	cltd   
    2541:	f7 fb                	idiv   %ebx
    2543:	83 c0 01             	add    $0x1,%eax
    2546:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    2549:	8b 45 08             	mov    0x8(%ebp),%eax
    254c:	8b 40 04             	mov    0x4(%eax),%eax
    254f:	c1 e0 10             	shl    $0x10,%eax
    2552:	89 c1                	mov    %eax,%ecx
    2554:	8b 45 0c             	mov    0xc(%ebp),%eax
    2557:	8b 58 04             	mov    0x4(%eax),%ebx
    255a:	89 c8                	mov    %ecx,%eax
    255c:	99                   	cltd   
    255d:	f7 fb                	idiv   %ebx
    255f:	83 c0 01             	add    $0x1,%eax
    2562:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    2565:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2568:	d1 f8                	sar    %eax
    256a:	2d 00 80 00 00       	sub    $0x8000,%eax
    256f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    2572:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2575:	d1 f8                	sar    %eax
    2577:	2d 00 80 00 00       	sub    $0x8000,%eax
    257c:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    257f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2582:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    2585:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    258c:	eb 5d                	jmp    25eb <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    258e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2591:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    2594:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    259b:	eb 3a                	jmp    25d7 <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    259d:	8b 45 0c             	mov    0xc(%ebp),%eax
    25a0:	8b 48 08             	mov    0x8(%eax),%ecx
    25a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    25a6:	8b 00                	mov    (%eax),%eax
    25a8:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    25ac:	89 c2                	mov    %eax,%edx
    25ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
    25b1:	01 c2                	add    %eax,%edx
    25b3:	89 d0                	mov    %edx,%eax
    25b5:	01 c0                	add    %eax,%eax
    25b7:	01 d0                	add    %edx,%eax
    25b9:	01 c8                	add    %ecx,%eax
    25bb:	50                   	push   %eax
    25bc:	ff 75 f0             	pushl  -0x10(%ebp)
    25bf:	ff 75 f8             	pushl  -0x8(%ebp)
    25c2:	ff 75 08             	pushl  0x8(%ebp)
    25c5:	e8 4d fd ff ff       	call   2317 <mixColorInt>
    25ca:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    25cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    25d0:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    25d3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    25d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    25da:	8b 00                	mov    (%eax),%eax
    25dc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    25df:	7f bc                	jg     259d <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    25e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    25e4:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    25e7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    25eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    25ee:	8b 40 04             	mov    0x4(%eax),%eax
    25f1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    25f4:	7f 98                	jg     258e <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    25f6:	b8 01 00 00 00       	mov    $0x1,%eax
}
    25fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    25fe:	c9                   	leave  
    25ff:	c3                   	ret    

00002600 <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    2600:	55                   	push   %ebp
    2601:	89 e5                	mov    %esp,%ebp
    2603:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    2606:	8b 45 08             	mov    0x8(%ebp),%eax
    2609:	8b 00                	mov    (%eax),%eax
    260b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    260e:	db 45 e4             	fildl  -0x1c(%ebp)
    2611:	8b 45 0c             	mov    0xc(%ebp),%eax
    2614:	8b 00                	mov    (%eax),%eax
    2616:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2619:	db 45 e4             	fildl  -0x1c(%ebp)
    261c:	de f9                	fdivrp %st,%st(1)
    261e:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    2621:	8b 45 08             	mov    0x8(%ebp),%eax
    2624:	8b 40 04             	mov    0x4(%eax),%eax
    2627:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    262a:	db 45 e4             	fildl  -0x1c(%ebp)
    262d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2630:	8b 40 04             	mov    0x4(%eax),%eax
    2633:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2636:	db 45 e4             	fildl  -0x1c(%ebp)
    2639:	de f9                	fdivrp %st,%st(1)
    263b:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    263e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    2645:	eb 5e                	jmp    26a5 <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    2647:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    264e:	eb 47                	jmp    2697 <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    2650:	db 45 f8             	fildl  -0x8(%ebp)
    2653:	d8 4d f4             	fmuls  -0xc(%ebp)
    2656:	d9 7d ee             	fnstcw -0x12(%ebp)
    2659:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    265d:	b4 0c                	mov    $0xc,%ah
    265f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    2663:	d9 6d ec             	fldcw  -0x14(%ebp)
    2666:	db 5d e8             	fistpl -0x18(%ebp)
    2669:	d9 6d ee             	fldcw  -0x12(%ebp)
    266c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    266f:	db 45 fc             	fildl  -0x4(%ebp)
    2672:	d8 4d f0             	fmuls  -0x10(%ebp)
    2675:	d9 6d ec             	fldcw  -0x14(%ebp)
    2678:	db 5d e8             	fistpl -0x18(%ebp)
    267b:	d9 6d ee             	fldcw  -0x12(%ebp)
    267e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2681:	6a 00                	push   $0x0
    2683:	52                   	push   %edx
    2684:	50                   	push   %eax
    2685:	ff 75 08             	pushl  0x8(%ebp)
    2688:	e8 10 f9 ff ff       	call   1f9d <getColor>
    268d:	83 c4 10             	add    $0x10,%esp
    2690:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    2693:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2697:	8b 45 0c             	mov    0xc(%ebp),%eax
    269a:	8b 00                	mov    (%eax),%eax
    269c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    269f:	7f af                	jg     2650 <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    26a1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    26a5:	8b 45 0c             	mov    0xc(%ebp),%eax
    26a8:	8b 40 04             	mov    0x4(%eax),%eax
    26ab:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    26ae:	7f 97                	jg     2647 <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    26b0:	b8 01 00 00 00       	mov    $0x1,%eax
}
    26b5:	c9                   	leave  
    26b6:	c3                   	ret    

000026b7 <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    26b7:	55                   	push   %ebp
    26b8:	89 e5                	mov    %esp,%ebp
    26ba:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    26bd:	8b 45 08             	mov    0x8(%ebp),%eax
    26c0:	8b 00                	mov    (%eax),%eax
    26c2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    26c5:	db 45 e0             	fildl  -0x20(%ebp)
    26c8:	d9 5d e0             	fstps  -0x20(%ebp)
    26cb:	83 ec 0c             	sub    $0xc,%esp
    26ce:	ff 75 10             	pushl  0x10(%ebp)
    26d1:	e8 6b e2 ff ff       	call   941 <cos>
    26d6:	83 c4 10             	add    $0x10,%esp
    26d9:	d9 5d dc             	fstps  -0x24(%ebp)
    26dc:	8b 45 dc             	mov    -0x24(%ebp),%eax
    26df:	83 ec 0c             	sub    $0xc,%esp
    26e2:	50                   	push   %eax
    26e3:	e8 90 e1 ff ff       	call   878 <abs>
    26e8:	83 c4 10             	add    $0x10,%esp
    26eb:	d8 4d e0             	fmuls  -0x20(%ebp)
    26ee:	d9 5d e0             	fstps  -0x20(%ebp)
    26f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    26f4:	8b 00                	mov    (%eax),%eax
    26f6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    26f9:	db 45 dc             	fildl  -0x24(%ebp)
    26fc:	d9 5d dc             	fstps  -0x24(%ebp)
    26ff:	83 ec 0c             	sub    $0xc,%esp
    2702:	ff 75 10             	pushl  0x10(%ebp)
    2705:	e8 da e3 ff ff       	call   ae4 <sin>
    270a:	83 c4 10             	add    $0x10,%esp
    270d:	d9 5d d8             	fstps  -0x28(%ebp)
    2710:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2713:	83 ec 0c             	sub    $0xc,%esp
    2716:	50                   	push   %eax
    2717:	e8 5c e1 ff ff       	call   878 <abs>
    271c:	83 c4 10             	add    $0x10,%esp
    271f:	d8 4d dc             	fmuls  -0x24(%ebp)
    2722:	d8 45 e0             	fadds  -0x20(%ebp)
    2725:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2728:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    272c:	b4 0c                	mov    $0xc,%ah
    272e:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2732:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2735:	db 5d f4             	fistpl -0xc(%ebp)
    2738:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    273b:	8b 45 08             	mov    0x8(%ebp),%eax
    273e:	8b 00                	mov    (%eax),%eax
    2740:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2743:	db 45 e0             	fildl  -0x20(%ebp)
    2746:	d9 5d e0             	fstps  -0x20(%ebp)
    2749:	83 ec 0c             	sub    $0xc,%esp
    274c:	ff 75 10             	pushl  0x10(%ebp)
    274f:	e8 90 e3 ff ff       	call   ae4 <sin>
    2754:	83 c4 10             	add    $0x10,%esp
    2757:	d9 5d dc             	fstps  -0x24(%ebp)
    275a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    275d:	83 ec 0c             	sub    $0xc,%esp
    2760:	50                   	push   %eax
    2761:	e8 12 e1 ff ff       	call   878 <abs>
    2766:	83 c4 10             	add    $0x10,%esp
    2769:	d8 4d e0             	fmuls  -0x20(%ebp)
    276c:	d9 5d e0             	fstps  -0x20(%ebp)
    276f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2772:	8b 00                	mov    (%eax),%eax
    2774:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2777:	db 45 dc             	fildl  -0x24(%ebp)
    277a:	d9 5d dc             	fstps  -0x24(%ebp)
    277d:	83 ec 0c             	sub    $0xc,%esp
    2780:	ff 75 10             	pushl  0x10(%ebp)
    2783:	e8 b9 e1 ff ff       	call   941 <cos>
    2788:	83 c4 10             	add    $0x10,%esp
    278b:	d9 5d d8             	fstps  -0x28(%ebp)
    278e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2791:	83 ec 0c             	sub    $0xc,%esp
    2794:	50                   	push   %eax
    2795:	e8 de e0 ff ff       	call   878 <abs>
    279a:	83 c4 10             	add    $0x10,%esp
    279d:	d8 4d dc             	fmuls  -0x24(%ebp)
    27a0:	d8 45 e0             	fadds  -0x20(%ebp)
    27a3:	d9 7d e6             	fnstcw -0x1a(%ebp)
    27a6:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    27aa:	b4 0c                	mov    $0xc,%ah
    27ac:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    27b0:	d9 6d e4             	fldcw  -0x1c(%ebp)
    27b3:	db 5d f0             	fistpl -0x10(%ebp)
    27b6:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    27b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    27bc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    27bf:	89 10                	mov    %edx,(%eax)
    *width = w;
    27c1:	8b 45 08             	mov    0x8(%ebp),%eax
    27c4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    27c7:	89 10                	mov    %edx,(%eax)
    return 1;
    27c9:	b8 01 00 00 00       	mov    $0x1,%eax
}
    27ce:	c9                   	leave  
    27cf:	c3                   	ret    

000027d0 <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    27d0:	55                   	push   %ebp
    27d1:	89 e5                	mov    %esp,%ebp
    27d3:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    27d6:	8b 45 08             	mov    0x8(%ebp),%eax
    27d9:	8b 40 04             	mov    0x4(%eax),%eax
    27dc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    27df:	db 45 c4             	fildl  -0x3c(%ebp)
    27e2:	d9 05 c4 9c 01 00    	flds   0x19cc4
    27e8:	de f9                	fdivrp %st,%st(1)
    27ea:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    27ed:	8b 45 08             	mov    0x8(%ebp),%eax
    27f0:	8b 00                	mov    (%eax),%eax
    27f2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    27f5:	db 45 c4             	fildl  -0x3c(%ebp)
    27f8:	d9 05 c4 9c 01 00    	flds   0x19cc4
    27fe:	de f9                	fdivrp %st,%st(1)
    2800:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    2803:	8b 45 0c             	mov    0xc(%ebp),%eax
    2806:	8b 50 04             	mov    0x4(%eax),%edx
    2809:	8b 45 08             	mov    0x8(%ebp),%eax
    280c:	8b 40 04             	mov    0x4(%eax),%eax
    280f:	29 c2                	sub    %eax,%edx
    2811:	89 d0                	mov    %edx,%eax
    2813:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2816:	db 45 c4             	fildl  -0x3c(%ebp)
    2819:	d9 05 c4 9c 01 00    	flds   0x19cc4
    281f:	de f9                	fdivrp %st,%st(1)
    2821:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    2824:	8b 45 0c             	mov    0xc(%ebp),%eax
    2827:	8b 10                	mov    (%eax),%edx
    2829:	8b 45 08             	mov    0x8(%ebp),%eax
    282c:	8b 00                	mov    (%eax),%eax
    282e:	29 c2                	sub    %eax,%edx
    2830:	89 d0                	mov    %edx,%eax
    2832:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2835:	db 45 c4             	fildl  -0x3c(%ebp)
    2838:	d9 05 c4 9c 01 00    	flds   0x19cc4
    283e:	de f9                	fdivrp %st,%st(1)
    2840:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    2843:	d9 45 10             	flds   0x10(%ebp)
    2846:	d9 e0                	fchs   
    2848:	83 ec 0c             	sub    $0xc,%esp
    284b:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    284f:	d9 1c 24             	fstps  (%esp)
    2852:	e8 ea e0 ff ff       	call   941 <cos>
    2857:	83 c4 10             	add    $0x10,%esp
    285a:	d9 5d c4             	fstps  -0x3c(%ebp)
    285d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2860:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    2863:	d9 45 10             	flds   0x10(%ebp)
    2866:	d9 e0                	fchs   
    2868:	83 ec 0c             	sub    $0xc,%esp
    286b:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    286f:	d9 1c 24             	fstps  (%esp)
    2872:	e8 6d e2 ff ff       	call   ae4 <sin>
    2877:	83 c4 10             	add    $0x10,%esp
    287a:	d9 5d c4             	fstps  -0x3c(%ebp)
    287d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2880:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    2883:	d9 ee                	fldz   
    2885:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    2888:	d9 ee                	fldz   
    288a:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    288d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2894:	e9 28 01 00 00       	jmp    29c1 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    2899:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    28a0:	e9 0a 01 00 00       	jmp    29af <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    28a5:	db 45 f4             	fildl  -0xc(%ebp)
    28a8:	d8 65 e4             	fsubs  -0x1c(%ebp)
    28ab:	d8 65 ec             	fsubs  -0x14(%ebp)
    28ae:	d8 4d dc             	fmuls  -0x24(%ebp)
    28b1:	db 45 f0             	fildl  -0x10(%ebp)
    28b4:	d8 65 e0             	fsubs  -0x20(%ebp)
    28b7:	d8 65 e8             	fsubs  -0x18(%ebp)
    28ba:	d8 4d d8             	fmuls  -0x28(%ebp)
    28bd:	de c1                	faddp  %st,%st(1)
    28bf:	d8 45 ec             	fadds  -0x14(%ebp)
    28c2:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    28c5:	db 45 f0             	fildl  -0x10(%ebp)
    28c8:	d8 65 e0             	fsubs  -0x20(%ebp)
    28cb:	d8 65 e8             	fsubs  -0x18(%ebp)
    28ce:	d8 4d dc             	fmuls  -0x24(%ebp)
    28d1:	db 45 f4             	fildl  -0xc(%ebp)
    28d4:	d8 65 e4             	fsubs  -0x1c(%ebp)
    28d7:	d8 65 ec             	fsubs  -0x14(%ebp)
    28da:	d8 4d d8             	fmuls  -0x28(%ebp)
    28dd:	de e9                	fsubrp %st,%st(1)
    28df:	d8 45 e8             	fadds  -0x18(%ebp)
    28e2:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    28e5:	d9 45 d4             	flds   -0x2c(%ebp)
    28e8:	d9 ee                	fldz   
    28ea:	d9 c9                	fxch   %st(1)
    28ec:	df e9                	fucomip %st(1),%st
    28ee:	dd d8                	fstp   %st(0)
    28f0:	0f 93 c0             	setae  %al
    28f3:	83 f0 01             	xor    $0x1,%eax
    28f6:	84 c0                	test   %al,%al
    28f8:	75 52                	jne    294c <picTurn+0x17c>
    28fa:	8b 45 08             	mov    0x8(%ebp),%eax
    28fd:	8b 40 04             	mov    0x4(%eax),%eax
    2900:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2903:	db 45 c4             	fildl  -0x3c(%ebp)
    2906:	d9 45 d4             	flds   -0x2c(%ebp)
    2909:	d9 c9                	fxch   %st(1)
    290b:	df e9                	fucomip %st(1),%st
    290d:	dd d8                	fstp   %st(0)
    290f:	0f 97 c0             	seta   %al
    2912:	83 f0 01             	xor    $0x1,%eax
    2915:	84 c0                	test   %al,%al
    2917:	75 33                	jne    294c <picTurn+0x17c>
    2919:	d9 45 d0             	flds   -0x30(%ebp)
    291c:	d9 ee                	fldz   
    291e:	d9 c9                	fxch   %st(1)
    2920:	df e9                	fucomip %st(1),%st
    2922:	dd d8                	fstp   %st(0)
    2924:	0f 93 c0             	setae  %al
    2927:	83 f0 01             	xor    $0x1,%eax
    292a:	84 c0                	test   %al,%al
    292c:	75 1e                	jne    294c <picTurn+0x17c>
    292e:	8b 45 08             	mov    0x8(%ebp),%eax
    2931:	8b 00                	mov    (%eax),%eax
    2933:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2936:	db 45 c4             	fildl  -0x3c(%ebp)
    2939:	d9 45 d0             	flds   -0x30(%ebp)
    293c:	d9 c9                	fxch   %st(1)
    293e:	df e9                	fucomip %st(1),%st
    2940:	dd d8                	fstp   %st(0)
    2942:	0f 97 c0             	seta   %al
    2945:	83 f0 01             	xor    $0x1,%eax
    2948:	84 c0                	test   %al,%al
    294a:	74 2f                	je     297b <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    294c:	8b 45 0c             	mov    0xc(%ebp),%eax
    294f:	8b 48 08             	mov    0x8(%eax),%ecx
    2952:	8b 45 0c             	mov    0xc(%ebp),%eax
    2955:	8b 00                	mov    (%eax),%eax
    2957:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    295b:	89 c2                	mov    %eax,%edx
    295d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2960:	01 c2                	add    %eax,%edx
    2962:	89 d0                	mov    %edx,%eax
    2964:	01 c0                	add    %eax,%eax
    2966:	01 d0                	add    %edx,%eax
    2968:	01 c8                	add    %ecx,%eax
    296a:	83 ec 08             	sub    $0x8,%esp
    296d:	50                   	push   %eax
    296e:	68 11 e1 01 00       	push   $0x1e111
    2973:	e8 9f f6 ff ff       	call   2017 <setColor>
    2978:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    297b:	8b 45 0c             	mov    0xc(%ebp),%eax
    297e:	8b 48 08             	mov    0x8(%eax),%ecx
    2981:	8b 45 0c             	mov    0xc(%ebp),%eax
    2984:	8b 00                	mov    (%eax),%eax
    2986:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    298a:	89 c2                	mov    %eax,%edx
    298c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    298f:	01 c2                	add    %eax,%edx
    2991:	89 d0                	mov    %edx,%eax
    2993:	01 c0                	add    %eax,%eax
    2995:	01 d0                	add    %edx,%eax
    2997:	01 c8                	add    %ecx,%eax
    2999:	50                   	push   %eax
    299a:	ff 75 d0             	pushl  -0x30(%ebp)
    299d:	ff 75 d4             	pushl  -0x2c(%ebp)
    29a0:	ff 75 08             	pushl  0x8(%ebp)
    29a3:	e8 9e f6 ff ff       	call   2046 <mixColor>
    29a8:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    29ab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    29af:	8b 45 0c             	mov    0xc(%ebp),%eax
    29b2:	8b 00                	mov    (%eax),%eax
    29b4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    29b7:	0f 8f e8 fe ff ff    	jg     28a5 <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    29bd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    29c1:	8b 45 0c             	mov    0xc(%ebp),%eax
    29c4:	8b 40 04             	mov    0x4(%eax),%eax
    29c7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    29ca:	0f 8f c9 fe ff ff    	jg     2899 <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    29d0:	b8 01 00 00 00       	mov    $0x1,%eax
}
    29d5:	c9                   	leave  
    29d6:	c3                   	ret    

000029d7 <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    29d7:	55                   	push   %ebp
    29d8:	89 e5                	mov    %esp,%ebp
    29da:	53                   	push   %ebx
    29db:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    29de:	8b 45 08             	mov    0x8(%ebp),%eax
    29e1:	8b 10                	mov    (%eax),%edx
    29e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    29e6:	8b 00                	mov    (%eax),%eax
    29e8:	39 c2                	cmp    %eax,%edx
    29ea:	75 10                	jne    29fc <picRollingOver+0x25>
    29ec:	8b 45 08             	mov    0x8(%ebp),%eax
    29ef:	8b 50 04             	mov    0x4(%eax),%edx
    29f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    29f5:	8b 40 04             	mov    0x4(%eax),%eax
    29f8:	39 c2                	cmp    %eax,%edx
    29fa:	74 0a                	je     2a06 <picRollingOver+0x2f>
        return 0;
    29fc:	b8 00 00 00 00       	mov    $0x0,%eax
    2a01:	e9 88 00 00 00       	jmp    2a8e <picRollingOver+0xb7>

    int h = src->height;
    2a06:	8b 45 08             	mov    0x8(%ebp),%eax
    2a09:	8b 40 04             	mov    0x4(%eax),%eax
    2a0c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2a0f:	8b 45 08             	mov    0x8(%ebp),%eax
    2a12:	8b 00                	mov    (%eax),%eax
    2a14:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2a17:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2a1e:	eb 61                	jmp    2a81 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    2a20:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2a27:	eb 4c                	jmp    2a75 <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    2a29:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a2c:	8b 48 08             	mov    0x8(%eax),%ecx
    2a2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2a32:	2b 45 f8             	sub    -0x8(%ebp),%eax
    2a35:	83 e8 01             	sub    $0x1,%eax
    2a38:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2a3c:	89 c2                	mov    %eax,%edx
    2a3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a41:	01 c2                	add    %eax,%edx
    2a43:	89 d0                	mov    %edx,%eax
    2a45:	01 c0                	add    %eax,%eax
    2a47:	01 d0                	add    %edx,%eax
    2a49:	01 c1                	add    %eax,%ecx
    2a4b:	8b 45 08             	mov    0x8(%ebp),%eax
    2a4e:	8b 58 08             	mov    0x8(%eax),%ebx
    2a51:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a54:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2a58:	89 c2                	mov    %eax,%edx
    2a5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a5d:	01 c2                	add    %eax,%edx
    2a5f:	89 d0                	mov    %edx,%eax
    2a61:	01 c0                	add    %eax,%eax
    2a63:	01 d0                	add    %edx,%eax
    2a65:	01 d8                	add    %ebx,%eax
    2a67:	51                   	push   %ecx
    2a68:	50                   	push   %eax
    2a69:	e8 a9 f5 ff ff       	call   2017 <setColor>
    2a6e:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2a71:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2a75:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a78:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2a7b:	7c ac                	jl     2a29 <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2a7d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2a81:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a84:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2a87:	7c 97                	jl     2a20 <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    2a89:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2a8e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2a91:	c9                   	leave  
    2a92:	c3                   	ret    

00002a93 <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    2a93:	55                   	push   %ebp
    2a94:	89 e5                	mov    %esp,%ebp
    2a96:	53                   	push   %ebx
    2a97:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2a9a:	8b 45 08             	mov    0x8(%ebp),%eax
    2a9d:	8b 10                	mov    (%eax),%edx
    2a9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2aa2:	8b 00                	mov    (%eax),%eax
    2aa4:	39 c2                	cmp    %eax,%edx
    2aa6:	75 10                	jne    2ab8 <picTurnAround+0x25>
    2aa8:	8b 45 08             	mov    0x8(%ebp),%eax
    2aab:	8b 50 04             	mov    0x4(%eax),%edx
    2aae:	8b 45 0c             	mov    0xc(%ebp),%eax
    2ab1:	8b 40 04             	mov    0x4(%eax),%eax
    2ab4:	39 c2                	cmp    %eax,%edx
    2ab6:	74 0a                	je     2ac2 <picTurnAround+0x2f>
        return 0;
    2ab8:	b8 00 00 00 00       	mov    $0x0,%eax
    2abd:	e9 88 00 00 00       	jmp    2b4a <picTurnAround+0xb7>

    int h = src->height;
    2ac2:	8b 45 08             	mov    0x8(%ebp),%eax
    2ac5:	8b 40 04             	mov    0x4(%eax),%eax
    2ac8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2acb:	8b 45 08             	mov    0x8(%ebp),%eax
    2ace:	8b 00                	mov    (%eax),%eax
    2ad0:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2ad3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2ada:	eb 61                	jmp    2b3d <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    2adc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2ae3:	eb 4c                	jmp    2b31 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    2ae5:	8b 45 0c             	mov    0xc(%ebp),%eax
    2ae8:	8b 48 08             	mov    0x8(%eax),%ecx
    2aeb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2aee:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2af2:	89 c2                	mov    %eax,%edx
    2af4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2af7:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2afa:	01 c2                	add    %eax,%edx
    2afc:	89 d0                	mov    %edx,%eax
    2afe:	01 c0                	add    %eax,%eax
    2b00:	01 d0                	add    %edx,%eax
    2b02:	83 e8 03             	sub    $0x3,%eax
    2b05:	01 c1                	add    %eax,%ecx
    2b07:	8b 45 08             	mov    0x8(%ebp),%eax
    2b0a:	8b 58 08             	mov    0x8(%eax),%ebx
    2b0d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2b10:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2b14:	89 c2                	mov    %eax,%edx
    2b16:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b19:	01 c2                	add    %eax,%edx
    2b1b:	89 d0                	mov    %edx,%eax
    2b1d:	01 c0                	add    %eax,%eax
    2b1f:	01 d0                	add    %edx,%eax
    2b21:	01 d8                	add    %ebx,%eax
    2b23:	51                   	push   %ecx
    2b24:	50                   	push   %eax
    2b25:	e8 ed f4 ff ff       	call   2017 <setColor>
    2b2a:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2b2d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2b31:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b34:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2b37:	7c ac                	jl     2ae5 <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2b39:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2b3d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2b40:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2b43:	7c 97                	jl     2adc <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    2b45:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2b4a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2b4d:	c9                   	leave  
    2b4e:	c3                   	ret    

00002b4f <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    2b4f:	55                   	push   %ebp
    2b50:	89 e5                	mov    %esp,%ebp
    2b52:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    2b55:	83 ec 0c             	sub    $0xc,%esp
    2b58:	ff 75 08             	pushl  0x8(%ebp)
    2b5b:	e8 c5 d5 ff ff       	call   125 <strlen>
    2b60:	83 c4 10             	add    $0x10,%esp
    2b63:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    2b66:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b69:	8d 50 ff             	lea    -0x1(%eax),%edx
    2b6c:	8b 45 08             	mov    0x8(%ebp),%eax
    2b6f:	01 d0                	add    %edx,%eax
    2b71:	0f b6 00             	movzbl (%eax),%eax
    2b74:	3c 67                	cmp    $0x67,%al
    2b76:	75 2b                	jne    2ba3 <type+0x54>
    2b78:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b7b:	8d 50 fe             	lea    -0x2(%eax),%edx
    2b7e:	8b 45 08             	mov    0x8(%ebp),%eax
    2b81:	01 d0                	add    %edx,%eax
    2b83:	0f b6 00             	movzbl (%eax),%eax
    2b86:	3c 70                	cmp    $0x70,%al
    2b88:	75 19                	jne    2ba3 <type+0x54>
    2b8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b8d:	8d 50 fd             	lea    -0x3(%eax),%edx
    2b90:	8b 45 08             	mov    0x8(%ebp),%eax
    2b93:	01 d0                	add    %edx,%eax
    2b95:	0f b6 00             	movzbl (%eax),%eax
    2b98:	3c 6a                	cmp    $0x6a,%al
    2b9a:	75 07                	jne    2ba3 <type+0x54>
    2b9c:	b8 00 00 00 00       	mov    $0x0,%eax
    2ba1:	eb 7f                	jmp    2c22 <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    2ba3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ba6:	8d 50 ff             	lea    -0x1(%eax),%edx
    2ba9:	8b 45 08             	mov    0x8(%ebp),%eax
    2bac:	01 d0                	add    %edx,%eax
    2bae:	0f b6 00             	movzbl (%eax),%eax
    2bb1:	3c 70                	cmp    $0x70,%al
    2bb3:	75 2b                	jne    2be0 <type+0x91>
    2bb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bb8:	8d 50 fe             	lea    -0x2(%eax),%edx
    2bbb:	8b 45 08             	mov    0x8(%ebp),%eax
    2bbe:	01 d0                	add    %edx,%eax
    2bc0:	0f b6 00             	movzbl (%eax),%eax
    2bc3:	3c 6d                	cmp    $0x6d,%al
    2bc5:	75 19                	jne    2be0 <type+0x91>
    2bc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bca:	8d 50 fd             	lea    -0x3(%eax),%edx
    2bcd:	8b 45 08             	mov    0x8(%ebp),%eax
    2bd0:	01 d0                	add    %edx,%eax
    2bd2:	0f b6 00             	movzbl (%eax),%eax
    2bd5:	3c 62                	cmp    $0x62,%al
    2bd7:	75 07                	jne    2be0 <type+0x91>
    2bd9:	b8 01 00 00 00       	mov    $0x1,%eax
    2bde:	eb 42                	jmp    2c22 <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    2be0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2be3:	8d 50 ff             	lea    -0x1(%eax),%edx
    2be6:	8b 45 08             	mov    0x8(%ebp),%eax
    2be9:	01 d0                	add    %edx,%eax
    2beb:	0f b6 00             	movzbl (%eax),%eax
    2bee:	3c 67                	cmp    $0x67,%al
    2bf0:	75 2b                	jne    2c1d <type+0xce>
    2bf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bf5:	8d 50 fe             	lea    -0x2(%eax),%edx
    2bf8:	8b 45 08             	mov    0x8(%ebp),%eax
    2bfb:	01 d0                	add    %edx,%eax
    2bfd:	0f b6 00             	movzbl (%eax),%eax
    2c00:	3c 6e                	cmp    $0x6e,%al
    2c02:	75 19                	jne    2c1d <type+0xce>
    2c04:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c07:	8d 50 fd             	lea    -0x3(%eax),%edx
    2c0a:	8b 45 08             	mov    0x8(%ebp),%eax
    2c0d:	01 d0                	add    %edx,%eax
    2c0f:	0f b6 00             	movzbl (%eax),%eax
    2c12:	3c 70                	cmp    $0x70,%al
    2c14:	75 07                	jne    2c1d <type+0xce>
    2c16:	b8 02 00 00 00       	mov    $0x2,%eax
    2c1b:	eb 05                	jmp    2c22 <type+0xd3>
    else return NONE;
    2c1d:	b8 03 00 00 00       	mov    $0x3,%eax
}
    2c22:	c9                   	leave  
    2c23:	c3                   	ret    

00002c24 <LoadBmp>:

PBitmap LoadBmp(char* filename){
    2c24:	55                   	push   %ebp
    2c25:	89 e5                	mov    %esp,%ebp
    2c27:	56                   	push   %esi
    2c28:	53                   	push   %ebx
    2c29:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    2c2c:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    2c33:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    2c3a:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    2c41:	83 ec 08             	sub    $0x8,%esp
    2c44:	6a 00                	push   $0x0
    2c46:	ff 75 0c             	pushl  0xc(%ebp)
    2c49:	e8 d9 d6 ff ff       	call   327 <open>
    2c4e:	83 c4 10             	add    $0x10,%esp
    2c51:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2c54:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2c58:	79 2c                	jns    2c86 <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    2c5a:	83 ec 08             	sub    $0x8,%esp
    2c5d:	ff 75 0c             	pushl  0xc(%ebp)
    2c60:	68 c8 9c 01 00       	push   $0x19cc8
    2c65:	e8 24 d8 ff ff       	call   48e <printf>
    2c6a:	83 c4 10             	add    $0x10,%esp
        return bmp;
    2c6d:	8b 45 08             	mov    0x8(%ebp),%eax
    2c70:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2c73:	89 10                	mov    %edx,(%eax)
    2c75:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2c78:	89 50 04             	mov    %edx,0x4(%eax)
    2c7b:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2c7e:	89 50 08             	mov    %edx,0x8(%eax)
    2c81:	e9 2d 02 00 00       	jmp    2eb3 <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    2c86:	83 ec 04             	sub    $0x4,%esp
    2c89:	6a 0e                	push   $0xe
    2c8b:	8d 45 aa             	lea    -0x56(%ebp),%eax
    2c8e:	50                   	push   %eax
    2c8f:	ff 75 ec             	pushl  -0x14(%ebp)
    2c92:	e8 68 d6 ff ff       	call   2ff <read>
    2c97:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    2c9a:	83 ec 04             	sub    $0x4,%esp
    2c9d:	6a 28                	push   $0x28
    2c9f:	8d 45 82             	lea    -0x7e(%ebp),%eax
    2ca2:	50                   	push   %eax
    2ca3:	ff 75 ec             	pushl  -0x14(%ebp)
    2ca6:	e8 54 d6 ff ff       	call   2ff <read>
    2cab:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2cae:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2cb2:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2cb5:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2cb9:	0f b7 d8             	movzwl %ax,%ebx
    2cbc:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    2cbf:	8b 55 ac             	mov    -0x54(%ebp),%edx
    2cc2:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    2cc6:	0f b7 c0             	movzwl %ax,%eax
    2cc9:	83 ec 04             	sub    $0x4,%esp
    2ccc:	6a 36                	push   $0x36
    2cce:	56                   	push   %esi
    2ccf:	53                   	push   %ebx
    2cd0:	51                   	push   %ecx
    2cd1:	52                   	push   %edx
    2cd2:	50                   	push   %eax
    2cd3:	68 d8 9c 01 00       	push   $0x19cd8
    2cd8:	e8 b1 d7 ff ff       	call   48e <printf>
    2cdd:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    2ce0:	8b 45 86             	mov    -0x7a(%ebp),%eax
    2ce3:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    2ce6:	8b 45 8a             	mov    -0x76(%ebp),%eax
    2ce9:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    2cec:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2cef:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2cf2:	0f af c2             	imul   %edx,%eax
    2cf5:	89 c2                	mov    %eax,%edx
    2cf7:	89 d0                	mov    %edx,%eax
    2cf9:	01 c0                	add    %eax,%eax
    2cfb:	01 d0                	add    %edx,%eax
    2cfd:	83 ec 0c             	sub    $0xc,%esp
    2d00:	50                   	push   %eax
    2d01:	e8 5b da ff ff       	call   761 <malloc>
    2d06:	83 c4 10             	add    $0x10,%esp
    2d09:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    2d0c:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2d10:	0f b7 c0             	movzwl %ax,%eax
    2d13:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    2d16:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2d19:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    2d1d:	83 c0 1f             	add    $0x1f,%eax
    2d20:	c1 f8 05             	sar    $0x5,%eax
    2d23:	c1 e0 02             	shl    $0x2,%eax
    2d26:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    2d29:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2d2c:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2d30:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    2d33:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2d36:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2d39:	83 ec 08             	sub    $0x8,%esp
    2d3c:	52                   	push   %edx
    2d3d:	50                   	push   %eax
    2d3e:	ff 75 e8             	pushl  -0x18(%ebp)
    2d41:	ff 75 e0             	pushl  -0x20(%ebp)
    2d44:	ff 75 e4             	pushl  -0x1c(%ebp)
    2d47:	68 00 9d 01 00       	push   $0x19d00
    2d4c:	e8 3d d7 ff ff       	call   48e <printf>
    2d51:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    2d54:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    2d57:	83 e8 36             	sub    $0x36,%eax
    2d5a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    2d5d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2d60:	83 ec 0c             	sub    $0xc,%esp
    2d63:	50                   	push   %eax
    2d64:	e8 f8 d9 ff ff       	call   761 <malloc>
    2d69:	83 c4 10             	add    $0x10,%esp
    2d6c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    2d6f:	83 ec 04             	sub    $0x4,%esp
    2d72:	ff 75 dc             	pushl  -0x24(%ebp)
    2d75:	ff 75 d8             	pushl  -0x28(%ebp)
    2d78:	ff 75 ec             	pushl  -0x14(%ebp)
    2d7b:	e8 7f d5 ff ff       	call   2ff <read>
    2d80:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    2d83:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2d86:	83 ec 0c             	sub    $0xc,%esp
    2d89:	50                   	push   %eax
    2d8a:	e8 d2 d9 ff ff       	call   761 <malloc>
    2d8f:	83 c4 10             	add    $0x10,%esp
    2d92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    2d95:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2d98:	83 ec 04             	sub    $0x4,%esp
    2d9b:	50                   	push   %eax
    2d9c:	ff 75 d4             	pushl  -0x2c(%ebp)
    2d9f:	ff 75 ec             	pushl  -0x14(%ebp)
    2da2:	e8 58 d5 ff ff       	call   2ff <read>
    2da7:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    2daa:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2dae:	66 c1 e8 03          	shr    $0x3,%ax
    2db2:	0f b7 c0             	movzwl %ax,%eax
    2db5:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    2db8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2dbf:	e9 c1 00 00 00       	jmp    2e85 <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    2dc4:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2dc7:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2dca:	8d 50 ff             	lea    -0x1(%eax),%edx
    2dcd:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2dd0:	0f af c2             	imul   %edx,%eax
    2dd3:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    2dd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2dd9:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2ddd:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    2de0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2de7:	e9 89 00 00 00       	jmp    2e75 <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    2dec:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2def:	83 c0 01             	add    $0x1,%eax
    2df2:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2df6:	89 c2                	mov    %eax,%edx
    2df8:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2dfb:	01 d0                	add    %edx,%eax
    2dfd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    2e00:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e03:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2e06:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e09:	01 c8                	add    %ecx,%eax
    2e0b:	89 c1                	mov    %eax,%ecx
    2e0d:	89 c8                	mov    %ecx,%eax
    2e0f:	01 c0                	add    %eax,%eax
    2e11:	01 c8                	add    %ecx,%eax
    2e13:	01 c2                	add    %eax,%edx
    2e15:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2e18:	8d 48 ff             	lea    -0x1(%eax),%ecx
    2e1b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e1e:	01 c8                	add    %ecx,%eax
    2e20:	0f b6 00             	movzbl (%eax),%eax
    2e23:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    2e26:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e29:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2e2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e2f:	01 c8                	add    %ecx,%eax
    2e31:	89 c1                	mov    %eax,%ecx
    2e33:	89 c8                	mov    %ecx,%eax
    2e35:	01 c0                	add    %eax,%eax
    2e37:	01 c8                	add    %ecx,%eax
    2e39:	01 c2                	add    %eax,%edx
    2e3b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2e3e:	8d 48 fe             	lea    -0x2(%eax),%ecx
    2e41:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e44:	01 c8                	add    %ecx,%eax
    2e46:	0f b6 00             	movzbl (%eax),%eax
    2e49:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    2e4c:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e4f:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2e52:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e55:	01 c8                	add    %ecx,%eax
    2e57:	89 c1                	mov    %eax,%ecx
    2e59:	89 c8                	mov    %ecx,%eax
    2e5b:	01 c0                	add    %eax,%eax
    2e5d:	01 c8                	add    %ecx,%eax
    2e5f:	01 c2                	add    %eax,%edx
    2e61:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2e64:	8d 48 fd             	lea    -0x3(%eax),%ecx
    2e67:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e6a:	01 c8                	add    %ecx,%eax
    2e6c:	0f b6 00             	movzbl (%eax),%eax
    2e6f:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    2e71:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2e75:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2e78:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2e7b:	0f 8f 6b ff ff ff    	jg     2dec <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    2e81:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2e85:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2e88:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2e8b:	0f 8f 33 ff ff ff    	jg     2dc4 <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    2e91:	83 ec 0c             	sub    $0xc,%esp
    2e94:	ff 75 ec             	pushl  -0x14(%ebp)
    2e97:	e8 73 d4 ff ff       	call   30f <close>
    2e9c:	83 c4 10             	add    $0x10,%esp
    return bmp;
    2e9f:	8b 45 08             	mov    0x8(%ebp),%eax
    2ea2:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2ea5:	89 10                	mov    %edx,(%eax)
    2ea7:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2eaa:	89 50 04             	mov    %edx,0x4(%eax)
    2ead:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2eb0:	89 50 08             	mov    %edx,0x8(%eax)
}
    2eb3:	8b 45 08             	mov    0x8(%ebp),%eax
    2eb6:	8d 65 f8             	lea    -0x8(%ebp),%esp
    2eb9:	5b                   	pop    %ebx
    2eba:	5e                   	pop    %esi
    2ebb:	5d                   	pop    %ebp
    2ebc:	c2 04 00             	ret    $0x4

00002ebf <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    2ebf:	55                   	push   %ebp
    2ec0:	89 e5                	mov    %esp,%ebp
    2ec2:	53                   	push   %ebx
    2ec3:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    2ec6:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    2eca:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    2ece:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    2ed2:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    2ed6:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    2eda:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    2ede:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    2ee2:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    2ee6:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    2eea:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    2eee:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    2ef2:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    2ef6:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    2efa:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    2efe:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    2f02:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    2f06:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    2f0a:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    2f0e:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    2f12:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    2f16:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    2f1a:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    2f1e:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    2f22:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    2f26:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    2f2a:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    2f2e:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    2f32:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    2f36:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    2f3a:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    2f3e:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    2f42:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    2f46:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    2f4a:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    2f4e:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    2f52:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    2f56:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    2f5a:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    2f5e:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    2f62:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    2f66:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    2f6a:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    2f6e:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    2f72:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    2f76:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    2f7a:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    2f7e:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    2f82:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    2f86:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    2f8a:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    2f8e:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    2f92:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    2f96:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    2f9a:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    2f9e:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    2fa2:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    2fa6:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    2faa:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    2fae:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    2fb2:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    2fb6:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    2fba:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    2fbe:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    2fc2:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    2fc6:	83 ec 0c             	sub    $0xc,%esp
    2fc9:	68 c8 02 08 00       	push   $0x802c8
    2fce:	e8 8e d7 ff ff       	call   761 <malloc>
    2fd3:	83 c4 10             	add    $0x10,%esp
    2fd6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    2fd9:	83 ec 04             	sub    $0x4,%esp
    2fdc:	68 c8 02 08 00       	push   $0x802c8
    2fe1:	6a 00                	push   $0x0
    2fe3:	ff 75 f0             	pushl  -0x10(%ebp)
    2fe6:	e8 61 d1 ff ff       	call   14c <memset>
    2feb:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    2fee:	83 ec 08             	sub    $0x8,%esp
    2ff1:	6a 00                	push   $0x0
    2ff3:	ff 75 0c             	pushl  0xc(%ebp)
    2ff6:	e8 2c d3 ff ff       	call   327 <open>
    2ffb:	83 c4 10             	add    $0x10,%esp
    2ffe:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    3001:	83 ec 0c             	sub    $0xc,%esp
    3004:	68 40 42 0f 00       	push   $0xf4240
    3009:	e8 53 d7 ff ff       	call   761 <malloc>
    300e:	83 c4 10             	add    $0x10,%esp
    3011:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    3014:	83 ec 04             	sub    $0x4,%esp
    3017:	68 40 42 0f 00       	push   $0xf4240
    301c:	ff 75 e8             	pushl  -0x18(%ebp)
    301f:	ff 75 ec             	pushl  -0x14(%ebp)
    3022:	e8 d8 d2 ff ff       	call   2ff <read>
    3027:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    302a:	83 ec 0c             	sub    $0xc,%esp
    302d:	ff 75 ec             	pushl  -0x14(%ebp)
    3030:	e8 da d2 ff ff       	call   30f <close>
    3035:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    3038:	68 40 42 0f 00       	push   $0xf4240
    303d:	ff 75 e8             	pushl  -0x18(%ebp)
    3040:	8d 45 9c             	lea    -0x64(%ebp),%eax
    3043:	50                   	push   %eax
    3044:	ff 75 f0             	pushl  -0x10(%ebp)
    3047:	e8 5e 0c 01 00       	call   13caa <_DecodeJPEG>
    304c:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    304f:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    3056:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    305d:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    3064:	83 ec 0c             	sub    $0xc,%esp
    3067:	ff 75 f0             	pushl  -0x10(%ebp)
    306a:	e8 29 0b 01 00       	call   13b98 <GetImageSize>
    306f:	83 c4 10             	add    $0x10,%esp
    3072:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    3075:	83 ec 0c             	sub    $0xc,%esp
    3078:	ff 75 f0             	pushl  -0x10(%ebp)
    307b:	e8 e1 0a 01 00       	call   13b61 <GetImage>
    3080:	83 c4 10             	add    $0x10,%esp
    3083:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    3086:	83 ec 0c             	sub    $0xc,%esp
    3089:	ff 75 f0             	pushl  -0x10(%ebp)
    308c:	e8 f1 0a 01 00       	call   13b82 <GetWidth>
    3091:	83 c4 10             	add    $0x10,%esp
    3094:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    3097:	83 ec 0c             	sub    $0xc,%esp
    309a:	ff 75 f0             	pushl  -0x10(%ebp)
    309d:	e8 eb 0a 01 00       	call   13b8d <GetHeight>
    30a2:	83 c4 10             	add    $0x10,%esp
    30a5:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    30a8:	8b 55 90             	mov    -0x70(%ebp),%edx
    30ab:	8b 45 94             	mov    -0x6c(%ebp),%eax
    30ae:	0f af c2             	imul   %edx,%eax
    30b1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    30b4:	8b 55 dc             	mov    -0x24(%ebp),%edx
    30b7:	89 d0                	mov    %edx,%eax
    30b9:	01 c0                	add    %eax,%eax
    30bb:	01 d0                	add    %edx,%eax
    30bd:	83 ec 0c             	sub    $0xc,%esp
    30c0:	50                   	push   %eax
    30c1:	e8 9b d6 ff ff       	call   761 <malloc>
    30c6:	83 c4 10             	add    $0x10,%esp
    30c9:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    30cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    30d3:	e9 9c 00 00 00       	jmp    3174 <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    30d8:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    30db:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    30de:	ba 56 55 55 55       	mov    $0x55555556,%edx
    30e3:	89 c8                	mov    %ecx,%eax
    30e5:	f7 ea                	imul   %edx
    30e7:	89 c8                	mov    %ecx,%eax
    30e9:	c1 f8 1f             	sar    $0x1f,%eax
    30ec:	29 c2                	sub    %eax,%edx
    30ee:	89 d0                	mov    %edx,%eax
    30f0:	89 c2                	mov    %eax,%edx
    30f2:	89 d0                	mov    %edx,%eax
    30f4:	01 c0                	add    %eax,%eax
    30f6:	01 d0                	add    %edx,%eax
    30f8:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    30fb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    30fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3101:	01 c8                	add    %ecx,%eax
    3103:	0f b6 00             	movzbl (%eax),%eax
    3106:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    3109:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    310c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    310f:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3114:	89 c8                	mov    %ecx,%eax
    3116:	f7 ea                	imul   %edx
    3118:	89 c8                	mov    %ecx,%eax
    311a:	c1 f8 1f             	sar    $0x1f,%eax
    311d:	29 c2                	sub    %eax,%edx
    311f:	89 d0                	mov    %edx,%eax
    3121:	89 c2                	mov    %eax,%edx
    3123:	89 d0                	mov    %edx,%eax
    3125:	01 c0                	add    %eax,%eax
    3127:	01 d0                	add    %edx,%eax
    3129:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    312c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    312f:	8d 48 01             	lea    0x1(%eax),%ecx
    3132:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3135:	01 c8                	add    %ecx,%eax
    3137:	0f b6 00             	movzbl (%eax),%eax
    313a:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    313d:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3140:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3143:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3148:	89 c8                	mov    %ecx,%eax
    314a:	f7 ea                	imul   %edx
    314c:	89 c8                	mov    %ecx,%eax
    314e:	c1 f8 1f             	sar    $0x1f,%eax
    3151:	29 c2                	sub    %eax,%edx
    3153:	89 d0                	mov    %edx,%eax
    3155:	89 c2                	mov    %eax,%edx
    3157:	89 d0                	mov    %edx,%eax
    3159:	01 c0                	add    %eax,%eax
    315b:	01 d0                	add    %edx,%eax
    315d:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3160:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3163:	8d 48 02             	lea    0x2(%eax),%ecx
    3166:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3169:	01 c8                	add    %ecx,%eax
    316b:	0f b6 00             	movzbl (%eax),%eax
    316e:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    3170:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    3174:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3177:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    317a:	0f 8c 58 ff ff ff    	jl     30d8 <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    3180:	8b 45 08             	mov    0x8(%ebp),%eax
    3183:	8b 55 90             	mov    -0x70(%ebp),%edx
    3186:	89 10                	mov    %edx,(%eax)
    3188:	8b 55 94             	mov    -0x6c(%ebp),%edx
    318b:	89 50 04             	mov    %edx,0x4(%eax)
    318e:	8b 55 98             	mov    -0x68(%ebp),%edx
    3191:	89 50 08             	mov    %edx,0x8(%eax)
}
    3194:	8b 45 08             	mov    0x8(%ebp),%eax
    3197:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    319a:	c9                   	leave  
    319b:	c2 04 00             	ret    $0x4

0000319e <LoadPng>:

PBitmap LoadPng(char* filename){
    319e:	55                   	push   %ebp
    319f:	89 e5                	mov    %esp,%ebp
    31a1:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    31a4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    31ab:	ff 75 0c             	pushl  0xc(%ebp)
    31ae:	8d 45 e0             	lea    -0x20(%ebp),%eax
    31b1:	50                   	push   %eax
    31b2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    31b5:	50                   	push   %eax
    31b6:	8d 45 e8             	lea    -0x18(%ebp),%eax
    31b9:	50                   	push   %eax
    31ba:	e8 d3 d3 00 00       	call   10592 <lodepng_decode24_file>
    31bf:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    31c2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    31c5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    31c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    31cb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    31ce:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    31d5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    31d8:	8b 45 d8             	mov    -0x28(%ebp),%eax
    31db:	0f af c2             	imul   %edx,%eax
    31de:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    31e1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    31e4:	89 d0                	mov    %edx,%eax
    31e6:	01 c0                	add    %eax,%eax
    31e8:	01 d0                	add    %edx,%eax
    31ea:	83 ec 0c             	sub    $0xc,%esp
    31ed:	50                   	push   %eax
    31ee:	e8 6e d5 ff ff       	call   761 <malloc>
    31f3:	83 c4 10             	add    $0x10,%esp
    31f6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    31f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3200:	e9 87 00 00 00       	jmp    328c <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    3205:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3208:	8b 55 f4             	mov    -0xc(%ebp),%edx
    320b:	89 d0                	mov    %edx,%eax
    320d:	01 c0                	add    %eax,%eax
    320f:	01 d0                	add    %edx,%eax
    3211:	01 c8                	add    %ecx,%eax
    3213:	0f b6 00             	movzbl (%eax),%eax
    3216:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    3219:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    321c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    321f:	89 d0                	mov    %edx,%eax
    3221:	01 c0                	add    %eax,%eax
    3223:	01 d0                	add    %edx,%eax
    3225:	83 c0 01             	add    $0x1,%eax
    3228:	01 c8                	add    %ecx,%eax
    322a:	0f b6 00             	movzbl (%eax),%eax
    322d:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    3230:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3233:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3236:	89 d0                	mov    %edx,%eax
    3238:	01 c0                	add    %eax,%eax
    323a:	01 d0                	add    %edx,%eax
    323c:	83 c0 02             	add    $0x2,%eax
    323f:	01 c8                	add    %ecx,%eax
    3241:	0f b6 00             	movzbl (%eax),%eax
    3244:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    3247:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    324a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    324d:	89 d0                	mov    %edx,%eax
    324f:	01 c0                	add    %eax,%eax
    3251:	01 d0                	add    %edx,%eax
    3253:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3256:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    325a:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    325d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3260:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3263:	89 d0                	mov    %edx,%eax
    3265:	01 c0                	add    %eax,%eax
    3267:	01 d0                	add    %edx,%eax
    3269:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    326c:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    3270:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    3273:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3276:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3279:	89 d0                	mov    %edx,%eax
    327b:	01 c0                	add    %eax,%eax
    327d:	01 d0                	add    %edx,%eax
    327f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3282:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    3286:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    3288:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    328c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    328f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3292:	0f 8c 6d ff ff ff    	jl     3205 <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    3298:	8b 45 e8             	mov    -0x18(%ebp),%eax
    329b:	83 ec 0c             	sub    $0xc,%esp
    329e:	50                   	push   %eax
    329f:	e8 7b d3 ff ff       	call   61f <free>
    32a4:	83 c4 10             	add    $0x10,%esp
    return bmp;
    32a7:	8b 45 08             	mov    0x8(%ebp),%eax
    32aa:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    32ad:	89 10                	mov    %edx,(%eax)
    32af:	8b 55 d8             	mov    -0x28(%ebp),%edx
    32b2:	89 50 04             	mov    %edx,0x4(%eax)
    32b5:	8b 55 dc             	mov    -0x24(%ebp),%edx
    32b8:	89 50 08             	mov    %edx,0x8(%eax)

}
    32bb:	8b 45 08             	mov    0x8(%ebp),%eax
    32be:	c9                   	leave  
    32bf:	c2 04 00             	ret    $0x4

000032c2 <LoadImg>:

PBitmap LoadImg(char* filename){
    32c2:	55                   	push   %ebp
    32c3:	89 e5                	mov    %esp,%ebp
    32c5:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    32c8:	83 ec 0c             	sub    $0xc,%esp
    32cb:	ff 75 0c             	pushl  0xc(%ebp)
    32ce:	e8 7c f8 ff ff       	call   2b4f <type>
    32d3:	83 c4 10             	add    $0x10,%esp
    32d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    32d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    32dc:	83 f8 01             	cmp    $0x1,%eax
    32df:	74 1d                	je     32fe <LoadImg+0x3c>
    32e1:	83 f8 02             	cmp    $0x2,%eax
    32e4:	74 2c                	je     3312 <LoadImg+0x50>
    32e6:	85 c0                	test   %eax,%eax
    32e8:	75 3c                	jne    3326 <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    32ea:	8b 45 08             	mov    0x8(%ebp),%eax
    32ed:	83 ec 08             	sub    $0x8,%esp
    32f0:	ff 75 0c             	pushl  0xc(%ebp)
    32f3:	50                   	push   %eax
    32f4:	e8 c6 fb ff ff       	call   2ebf <LoadJpeg>
    32f9:	83 c4 0c             	add    $0xc,%esp
    32fc:	eb 3c                	jmp    333a <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    32fe:	8b 45 08             	mov    0x8(%ebp),%eax
    3301:	83 ec 08             	sub    $0x8,%esp
    3304:	ff 75 0c             	pushl  0xc(%ebp)
    3307:	50                   	push   %eax
    3308:	e8 17 f9 ff ff       	call   2c24 <LoadBmp>
    330d:	83 c4 0c             	add    $0xc,%esp
    3310:	eb 28                	jmp    333a <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    3312:	8b 45 08             	mov    0x8(%ebp),%eax
    3315:	83 ec 08             	sub    $0x8,%esp
    3318:	ff 75 0c             	pushl  0xc(%ebp)
    331b:	50                   	push   %eax
    331c:	e8 7d fe ff ff       	call   319e <LoadPng>
    3321:	83 c4 0c             	add    $0xc,%esp
    3324:	eb 14                	jmp    333a <LoadImg+0x78>

        default: return bmp;
    3326:	8b 45 08             	mov    0x8(%ebp),%eax
    3329:	8b 55 e8             	mov    -0x18(%ebp),%edx
    332c:	89 10                	mov    %edx,(%eax)
    332e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3331:	89 50 04             	mov    %edx,0x4(%eax)
    3334:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3337:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    333a:	8b 45 08             	mov    0x8(%ebp),%eax
    333d:	c9                   	leave  
    333e:	c2 04 00             	ret    $0x4

00003341 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    3341:	55                   	push   %ebp
    3342:	89 e5                	mov    %esp,%ebp
    3344:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    3347:	8b 45 08             	mov    0x8(%ebp),%eax
    334a:	83 ec 0c             	sub    $0xc,%esp
    334d:	50                   	push   %eax
    334e:	e8 0e d4 ff ff       	call   761 <malloc>
    3353:	83 c4 10             	add    $0x10,%esp
}
    3356:	c9                   	leave  
    3357:	c3                   	ret    

00003358 <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    3358:	55                   	push   %ebp
    3359:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    335b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3360:	5d                   	pop    %ebp
    3361:	c3                   	ret    

00003362 <lodepng_free>:

static void lodepng_free(void* ptr) {
    3362:	55                   	push   %ebp
    3363:	89 e5                	mov    %esp,%ebp
    3365:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    3368:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    336c:	74 0e                	je     337c <lodepng_free+0x1a>
    free(ptr);
    336e:	83 ec 0c             	sub    $0xc,%esp
    3371:	ff 75 08             	pushl  0x8(%ebp)
    3374:	e8 a6 d2 ff ff       	call   61f <free>
    3379:	83 c4 10             	add    $0x10,%esp
}
    337c:	90                   	nop
    337d:	c9                   	leave  
    337e:	c3                   	ret    

0000337f <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    337f:	55                   	push   %ebp
    3380:	89 e5                	mov    %esp,%ebp
    3382:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    3385:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    338c:	eb 19                	jmp    33a7 <lodepng_memcpy+0x28>
    338e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3391:	8b 45 08             	mov    0x8(%ebp),%eax
    3394:	01 c2                	add    %eax,%edx
    3396:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3399:	8b 45 0c             	mov    0xc(%ebp),%eax
    339c:	01 c8                	add    %ecx,%eax
    339e:	0f b6 00             	movzbl (%eax),%eax
    33a1:	88 02                	mov    %al,(%edx)
    33a3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    33a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    33aa:	3b 45 10             	cmp    0x10(%ebp),%eax
    33ad:	7c df                	jl     338e <lodepng_memcpy+0xf>
}
    33af:	90                   	nop
    33b0:	c9                   	leave  
    33b1:	c3                   	ret    

000033b2 <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    33b2:	55                   	push   %ebp
    33b3:	89 e5                	mov    %esp,%ebp
    33b5:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    33b8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    33bf:	eb 11                	jmp    33d2 <lodepng_memset+0x20>
    33c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    33c4:	8b 45 08             	mov    0x8(%ebp),%eax
    33c7:	01 d0                	add    %edx,%eax
    33c9:	8b 55 0c             	mov    0xc(%ebp),%edx
    33cc:	88 10                	mov    %dl,(%eax)
    33ce:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    33d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    33d5:	3b 45 10             	cmp    0x10(%ebp),%eax
    33d8:	7c e7                	jl     33c1 <lodepng_memset+0xf>
}
    33da:	90                   	nop
    33db:	c9                   	leave  
    33dc:	c3                   	ret    

000033dd <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    33dd:	55                   	push   %ebp
    33de:	89 e5                	mov    %esp,%ebp
    33e0:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    33e3:	8b 45 08             	mov    0x8(%ebp),%eax
    33e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    33e9:	eb 04                	jmp    33ef <lodepng_strlen+0x12>
    33eb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    33ef:	8b 45 08             	mov    0x8(%ebp),%eax
    33f2:	0f b6 00             	movzbl (%eax),%eax
    33f5:	84 c0                	test   %al,%al
    33f7:	75 f2                	jne    33eb <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    33f9:	8b 55 08             	mov    0x8(%ebp),%edx
    33fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    33ff:	29 c2                	sub    %eax,%edx
    3401:	89 d0                	mov    %edx,%eax
}
    3403:	c9                   	leave  
    3404:	c3                   	ret    

00003405 <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    3405:	55                   	push   %ebp
    3406:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    3408:	8b 55 08             	mov    0x8(%ebp),%edx
    340b:	8b 45 0c             	mov    0xc(%ebp),%eax
    340e:	01 c2                	add    %eax,%edx
    3410:	8b 45 10             	mov    0x10(%ebp),%eax
    3413:	89 10                	mov    %edx,(%eax)
  return *result < a;
    3415:	8b 45 10             	mov    0x10(%ebp),%eax
    3418:	8b 00                	mov    (%eax),%eax
    341a:	3b 45 08             	cmp    0x8(%ebp),%eax
    341d:	0f 9c c0             	setl   %al
    3420:	0f b6 c0             	movzbl %al,%eax
}
    3423:	5d                   	pop    %ebp
    3424:	c3                   	ret    

00003425 <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    3425:	55                   	push   %ebp
    3426:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    3428:	8b 45 08             	mov    0x8(%ebp),%eax
    342b:	0f af 45 0c          	imul   0xc(%ebp),%eax
    342f:	89 c2                	mov    %eax,%edx
    3431:	8b 45 10             	mov    0x10(%ebp),%eax
    3434:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    3436:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    343a:	74 15                	je     3451 <lodepng_mulofl+0x2c>
    343c:	8b 45 10             	mov    0x10(%ebp),%eax
    343f:	8b 00                	mov    (%eax),%eax
    3441:	99                   	cltd   
    3442:	f7 7d 08             	idivl  0x8(%ebp)
    3445:	3b 45 0c             	cmp    0xc(%ebp),%eax
    3448:	74 07                	je     3451 <lodepng_mulofl+0x2c>
    344a:	b8 01 00 00 00       	mov    $0x1,%eax
    344f:	eb 05                	jmp    3456 <lodepng_mulofl+0x31>
    3451:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3456:	5d                   	pop    %ebp
    3457:	c3                   	ret    

00003458 <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    3458:	55                   	push   %ebp
    3459:	89 e5                	mov    %esp,%ebp
    345b:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    345e:	8d 45 fc             	lea    -0x4(%ebp),%eax
    3461:	50                   	push   %eax
    3462:	ff 75 0c             	pushl  0xc(%ebp)
    3465:	ff 75 08             	pushl  0x8(%ebp)
    3468:	e8 98 ff ff ff       	call   3405 <lodepng_addofl>
    346d:	83 c4 0c             	add    $0xc,%esp
    3470:	85 c0                	test   %eax,%eax
    3472:	74 07                	je     347b <lodepng_gtofl+0x23>
    3474:	b8 01 00 00 00       	mov    $0x1,%eax
    3479:	eb 0c                	jmp    3487 <lodepng_gtofl+0x2f>
  return d > c;
    347b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    347e:	3b 45 10             	cmp    0x10(%ebp),%eax
    3481:	0f 9f c0             	setg   %al
    3484:	0f b6 c0             	movzbl %al,%eax
}
    3487:	c9                   	leave  
    3488:	c3                   	ret    

00003489 <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    3489:	55                   	push   %ebp
    348a:	89 e5                	mov    %esp,%ebp
    348c:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    348f:	8b 45 08             	mov    0x8(%ebp),%eax
    3492:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    3499:	8b 45 08             	mov    0x8(%ebp),%eax
    349c:	8b 50 08             	mov    0x8(%eax),%edx
    349f:	8b 45 08             	mov    0x8(%ebp),%eax
    34a2:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    34a5:	8b 45 08             	mov    0x8(%ebp),%eax
    34a8:	8b 00                	mov    (%eax),%eax
    34aa:	83 ec 0c             	sub    $0xc,%esp
    34ad:	50                   	push   %eax
    34ae:	e8 af fe ff ff       	call   3362 <lodepng_free>
    34b3:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    34b6:	8b 45 08             	mov    0x8(%ebp),%eax
    34b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    34bf:	90                   	nop
    34c0:	c9                   	leave  
    34c1:	c3                   	ret    

000034c2 <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    34c2:	55                   	push   %ebp
    34c3:	89 e5                	mov    %esp,%ebp
    34c5:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    34c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    34cb:	c1 e0 02             	shl    $0x2,%eax
    34ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    34d1:	8b 45 08             	mov    0x8(%ebp),%eax
    34d4:	8b 40 08             	mov    0x8(%eax),%eax
    34d7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    34da:	7d 46                	jge    3522 <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    34dc:	8b 45 08             	mov    0x8(%ebp),%eax
    34df:	8b 40 08             	mov    0x8(%eax),%eax
    34e2:	d1 f8                	sar    %eax
    34e4:	89 c2                	mov    %eax,%edx
    34e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    34e9:	01 d0                	add    %edx,%eax
    34eb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    34ee:	8b 45 08             	mov    0x8(%ebp),%eax
    34f1:	8b 00                	mov    (%eax),%eax
    34f3:	ff 75 f8             	pushl  -0x8(%ebp)
    34f6:	50                   	push   %eax
    34f7:	e8 5c fe ff ff       	call   3358 <lodepng_realloc>
    34fc:	83 c4 08             	add    $0x8,%esp
    34ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    3502:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3506:	74 13                	je     351b <uivector_resize+0x59>
      p->allocsize = newsize;
    3508:	8b 45 08             	mov    0x8(%ebp),%eax
    350b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    350e:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    3511:	8b 45 08             	mov    0x8(%ebp),%eax
    3514:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3517:	89 10                	mov    %edx,(%eax)
    3519:	eb 07                	jmp    3522 <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    351b:	b8 00 00 00 00       	mov    $0x0,%eax
    3520:	eb 0e                	jmp    3530 <uivector_resize+0x6e>
  }
  p->size = size;
    3522:	8b 45 08             	mov    0x8(%ebp),%eax
    3525:	8b 55 0c             	mov    0xc(%ebp),%edx
    3528:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    352b:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3530:	c9                   	leave  
    3531:	c3                   	ret    

00003532 <uivector_init>:

static void uivector_init(uivector* p) {
    3532:	55                   	push   %ebp
    3533:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    3535:	8b 45 08             	mov    0x8(%ebp),%eax
    3538:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    353e:	8b 45 08             	mov    0x8(%ebp),%eax
    3541:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    3548:	8b 45 08             	mov    0x8(%ebp),%eax
    354b:	8b 50 08             	mov    0x8(%eax),%edx
    354e:	8b 45 08             	mov    0x8(%ebp),%eax
    3551:	89 50 04             	mov    %edx,0x4(%eax)
}
    3554:	90                   	nop
    3555:	5d                   	pop    %ebp
    3556:	c3                   	ret    

00003557 <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    3557:	55                   	push   %ebp
    3558:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    355a:	8b 45 08             	mov    0x8(%ebp),%eax
    355d:	8b 40 04             	mov    0x4(%eax),%eax
    3560:	83 c0 01             	add    $0x1,%eax
    3563:	50                   	push   %eax
    3564:	ff 75 08             	pushl  0x8(%ebp)
    3567:	e8 56 ff ff ff       	call   34c2 <uivector_resize>
    356c:	83 c4 08             	add    $0x8,%esp
    356f:	85 c0                	test   %eax,%eax
    3571:	75 07                	jne    357a <uivector_push_back+0x23>
    3573:	b8 00 00 00 00       	mov    $0x0,%eax
    3578:	eb 1f                	jmp    3599 <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    357a:	8b 45 08             	mov    0x8(%ebp),%eax
    357d:	8b 10                	mov    (%eax),%edx
    357f:	8b 45 08             	mov    0x8(%ebp),%eax
    3582:	8b 40 04             	mov    0x4(%eax),%eax
    3585:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    358a:	c1 e0 02             	shl    $0x2,%eax
    358d:	01 c2                	add    %eax,%edx
    358f:	8b 45 0c             	mov    0xc(%ebp),%eax
    3592:	89 02                	mov    %eax,(%edx)
  return 1;
    3594:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3599:	c9                   	leave  
    359a:	c3                   	ret    

0000359b <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    359b:	55                   	push   %ebp
    359c:	89 e5                	mov    %esp,%ebp
    359e:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    35a1:	8b 45 08             	mov    0x8(%ebp),%eax
    35a4:	8b 40 08             	mov    0x8(%eax),%eax
    35a7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    35aa:	7d 46                	jge    35f2 <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    35ac:	8b 45 08             	mov    0x8(%ebp),%eax
    35af:	8b 40 08             	mov    0x8(%eax),%eax
    35b2:	d1 f8                	sar    %eax
    35b4:	89 c2                	mov    %eax,%edx
    35b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    35b9:	01 d0                	add    %edx,%eax
    35bb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    35be:	8b 45 08             	mov    0x8(%ebp),%eax
    35c1:	8b 00                	mov    (%eax),%eax
    35c3:	ff 75 fc             	pushl  -0x4(%ebp)
    35c6:	50                   	push   %eax
    35c7:	e8 8c fd ff ff       	call   3358 <lodepng_realloc>
    35cc:	83 c4 08             	add    $0x8,%esp
    35cf:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    35d2:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    35d6:	74 13                	je     35eb <ucvector_resize+0x50>
      p->allocsize = newsize;
    35d8:	8b 45 08             	mov    0x8(%ebp),%eax
    35db:	8b 55 fc             	mov    -0x4(%ebp),%edx
    35de:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    35e1:	8b 45 08             	mov    0x8(%ebp),%eax
    35e4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    35e7:	89 10                	mov    %edx,(%eax)
    35e9:	eb 07                	jmp    35f2 <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    35eb:	b8 00 00 00 00       	mov    $0x0,%eax
    35f0:	eb 0e                	jmp    3600 <ucvector_resize+0x65>
  }
  p->size = size;
    35f2:	8b 45 08             	mov    0x8(%ebp),%eax
    35f5:	8b 55 0c             	mov    0xc(%ebp),%edx
    35f8:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    35fb:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3600:	c9                   	leave  
    3601:	c3                   	ret    

00003602 <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    3602:	55                   	push   %ebp
    3603:	89 e5                	mov    %esp,%ebp
    3605:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    3608:	8b 45 0c             	mov    0xc(%ebp),%eax
    360b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    360e:	8b 45 10             	mov    0x10(%ebp),%eax
    3611:	89 45 f8             	mov    %eax,-0x8(%ebp)
    3614:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3617:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    361a:	8b 45 08             	mov    0x8(%ebp),%eax
    361d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3620:	89 10                	mov    %edx,(%eax)
    3622:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3625:	89 50 04             	mov    %edx,0x4(%eax)
    3628:	8b 55 fc             	mov    -0x4(%ebp),%edx
    362b:	89 50 08             	mov    %edx,0x8(%eax)
}
    362e:	8b 45 08             	mov    0x8(%ebp),%eax
    3631:	c9                   	leave  
    3632:	c2 04 00             	ret    $0x4

00003635 <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    3635:	55                   	push   %ebp
    3636:	89 e5                	mov    %esp,%ebp
    3638:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    363b:	8b 45 08             	mov    0x8(%ebp),%eax
    363e:	8b 00                	mov    (%eax),%eax
    3640:	83 ec 0c             	sub    $0xc,%esp
    3643:	50                   	push   %eax
    3644:	e8 19 fd ff ff       	call   3362 <lodepng_free>
    3649:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    364c:	8b 45 08             	mov    0x8(%ebp),%eax
    364f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3655:	90                   	nop
    3656:	c9                   	leave  
    3657:	c3                   	ret    

00003658 <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    3658:	55                   	push   %ebp
    3659:	89 e5                	mov    %esp,%ebp
    365b:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    365e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3661:	83 c0 01             	add    $0x1,%eax
    3664:	83 ec 0c             	sub    $0xc,%esp
    3667:	50                   	push   %eax
    3668:	e8 d4 fc ff ff       	call   3341 <lodepng_malloc>
    366d:	83 c4 10             	add    $0x10,%esp
    3670:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    3673:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3677:	74 1f                	je     3698 <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    3679:	83 ec 04             	sub    $0x4,%esp
    367c:	ff 75 0c             	pushl  0xc(%ebp)
    367f:	ff 75 08             	pushl  0x8(%ebp)
    3682:	ff 75 f4             	pushl  -0xc(%ebp)
    3685:	e8 f5 fc ff ff       	call   337f <lodepng_memcpy>
    368a:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    368d:	8b 55 0c             	mov    0xc(%ebp),%edx
    3690:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3693:	01 d0                	add    %edx,%eax
    3695:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    3698:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    369b:	c9                   	leave  
    369c:	c3                   	ret    

0000369d <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    369d:	55                   	push   %ebp
    369e:	89 e5                	mov    %esp,%ebp
    36a0:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    36a3:	ff 75 08             	pushl  0x8(%ebp)
    36a6:	e8 32 fd ff ff       	call   33dd <lodepng_strlen>
    36ab:	83 c4 04             	add    $0x4,%esp
    36ae:	83 ec 08             	sub    $0x8,%esp
    36b1:	50                   	push   %eax
    36b2:	ff 75 08             	pushl  0x8(%ebp)
    36b5:	e8 9e ff ff ff       	call   3658 <alloc_string_sized>
    36ba:	83 c4 10             	add    $0x10,%esp
}
    36bd:	c9                   	leave  
    36be:	c3                   	ret    

000036bf <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    36bf:	55                   	push   %ebp
    36c0:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    36c2:	8b 45 08             	mov    0x8(%ebp),%eax
    36c5:	0f b6 00             	movzbl (%eax),%eax
    36c8:	0f b6 c0             	movzbl %al,%eax
    36cb:	c1 e0 18             	shl    $0x18,%eax
    36ce:	89 c2                	mov    %eax,%edx
    36d0:	8b 45 08             	mov    0x8(%ebp),%eax
    36d3:	83 c0 01             	add    $0x1,%eax
    36d6:	0f b6 00             	movzbl (%eax),%eax
    36d9:	0f b6 c0             	movzbl %al,%eax
    36dc:	c1 e0 10             	shl    $0x10,%eax
    36df:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    36e1:	8b 45 08             	mov    0x8(%ebp),%eax
    36e4:	83 c0 02             	add    $0x2,%eax
    36e7:	0f b6 00             	movzbl (%eax),%eax
    36ea:	0f b6 c0             	movzbl %al,%eax
    36ed:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    36f0:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    36f2:	8b 45 08             	mov    0x8(%ebp),%eax
    36f5:	83 c0 03             	add    $0x3,%eax
    36f8:	0f b6 00             	movzbl (%eax),%eax
    36fb:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    36fe:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    3700:	5d                   	pop    %ebp
    3701:	c3                   	ret    

00003702 <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    3702:	55                   	push   %ebp
    3703:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    3705:	8b 45 0c             	mov    0xc(%ebp),%eax
    3708:	c1 e8 18             	shr    $0x18,%eax
    370b:	89 c2                	mov    %eax,%edx
    370d:	8b 45 08             	mov    0x8(%ebp),%eax
    3710:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    3712:	8b 45 08             	mov    0x8(%ebp),%eax
    3715:	83 c0 01             	add    $0x1,%eax
    3718:	8b 55 0c             	mov    0xc(%ebp),%edx
    371b:	c1 ea 10             	shr    $0x10,%edx
    371e:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    3720:	8b 45 08             	mov    0x8(%ebp),%eax
    3723:	83 c0 02             	add    $0x2,%eax
    3726:	8b 55 0c             	mov    0xc(%ebp),%edx
    3729:	c1 ea 08             	shr    $0x8,%edx
    372c:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    372e:	8b 45 08             	mov    0x8(%ebp),%eax
    3731:	83 c0 03             	add    $0x3,%eax
    3734:	8b 55 0c             	mov    0xc(%ebp),%edx
    3737:	88 10                	mov    %dl,(%eax)
}
    3739:	90                   	nop
    373a:	5d                   	pop    %ebp
    373b:	c3                   	ret    

0000373c <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    373c:	55                   	push   %ebp
    373d:	89 e5                	mov    %esp,%ebp
    373f:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    3742:	83 ec 08             	sub    $0x8,%esp
    3745:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    3748:	50                   	push   %eax
    3749:	ff 75 08             	pushl  0x8(%ebp)
    374c:	e8 b7 ca ff ff       	call   208 <stat>
    3751:	83 c4 10             	add    $0x10,%esp
  return s.size;
    3754:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3757:	c9                   	leave  
    3758:	c3                   	ret    

00003759 <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    3759:	55                   	push   %ebp
    375a:	89 e5                	mov    %esp,%ebp
    375c:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    375f:	83 ec 08             	sub    $0x8,%esp
    3762:	6a 00                	push   $0x0
    3764:	ff 75 10             	pushl  0x10(%ebp)
    3767:	e8 bb cb ff ff       	call   327 <open>
    376c:	83 c4 10             	add    $0x10,%esp
    376f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    3772:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3776:	79 07                	jns    377f <lodepng_buffer_file+0x26>
  {
      return -1;
    3778:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    377d:	eb 19                	jmp    3798 <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    377f:	83 ec 04             	sub    $0x4,%esp
    3782:	ff 75 0c             	pushl  0xc(%ebp)
    3785:	ff 75 08             	pushl  0x8(%ebp)
    3788:	ff 75 f4             	pushl  -0xc(%ebp)
    378b:	e8 6f cb ff ff       	call   2ff <read>
    3790:	83 c4 10             	add    $0x10,%esp
  return 0;
    3793:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3798:	c9                   	leave  
    3799:	c3                   	ret    

0000379a <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    379a:	55                   	push   %ebp
    379b:	89 e5                	mov    %esp,%ebp
    379d:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    37a0:	83 ec 0c             	sub    $0xc,%esp
    37a3:	ff 75 10             	pushl  0x10(%ebp)
    37a6:	e8 91 ff ff ff       	call   373c <lodepng_filesize>
    37ab:	83 c4 10             	add    $0x10,%esp
    37ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    37b1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    37b5:	79 07                	jns    37be <lodepng_load_file+0x24>
    37b7:	b8 4e 00 00 00       	mov    $0x4e,%eax
    37bc:	eb 4a                	jmp    3808 <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    37be:	8b 45 0c             	mov    0xc(%ebp),%eax
    37c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    37c4:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    37c6:	83 ec 0c             	sub    $0xc,%esp
    37c9:	ff 75 f4             	pushl  -0xc(%ebp)
    37cc:	e8 70 fb ff ff       	call   3341 <lodepng_malloc>
    37d1:	83 c4 10             	add    $0x10,%esp
    37d4:	89 c2                	mov    %eax,%edx
    37d6:	8b 45 08             	mov    0x8(%ebp),%eax
    37d9:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    37db:	8b 45 08             	mov    0x8(%ebp),%eax
    37de:	8b 00                	mov    (%eax),%eax
    37e0:	85 c0                	test   %eax,%eax
    37e2:	75 0d                	jne    37f1 <lodepng_load_file+0x57>
    37e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    37e8:	7e 07                	jle    37f1 <lodepng_load_file+0x57>
    37ea:	b8 53 00 00 00       	mov    $0x53,%eax
    37ef:	eb 17                	jmp    3808 <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    37f1:	8b 45 08             	mov    0x8(%ebp),%eax
    37f4:	8b 00                	mov    (%eax),%eax
    37f6:	83 ec 04             	sub    $0x4,%esp
    37f9:	ff 75 10             	pushl  0x10(%ebp)
    37fc:	ff 75 f4             	pushl  -0xc(%ebp)
    37ff:	50                   	push   %eax
    3800:	e8 54 ff ff ff       	call   3759 <lodepng_buffer_file>
    3805:	83 c4 10             	add    $0x10,%esp
}
    3808:	c9                   	leave  
    3809:	c3                   	ret    

0000380a <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    380a:	55                   	push   %ebp
    380b:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    380d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3812:	5d                   	pop    %ebp
    3813:	c3                   	ret    

00003814 <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    3814:	55                   	push   %ebp
    3815:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    3817:	8b 45 08             	mov    0x8(%ebp),%eax
    381a:	8b 55 0c             	mov    0xc(%ebp),%edx
    381d:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    381f:	8b 45 08             	mov    0x8(%ebp),%eax
    3822:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    3826:	90                   	nop
    3827:	5d                   	pop    %ebp
    3828:	c3                   	ret    

00003829 <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3829:	55                   	push   %ebp
    382a:	89 e5                	mov    %esp,%ebp
    382c:	56                   	push   %esi
    382d:	53                   	push   %ebx
    382e:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    3831:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    3835:	0f 85 aa 00 00 00    	jne    38e5 <writeBits+0xbc>
    WRITEBIT(writer, value);
    383b:	8b 45 08             	mov    0x8(%ebp),%eax
    383e:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3842:	0f b6 c0             	movzbl %al,%eax
    3845:	83 e0 07             	and    $0x7,%eax
    3848:	85 c0                	test   %eax,%eax
    384a:	75 39                	jne    3885 <writeBits+0x5c>
    384c:	8b 45 08             	mov    0x8(%ebp),%eax
    384f:	8b 00                	mov    (%eax),%eax
    3851:	8b 40 04             	mov    0x4(%eax),%eax
    3854:	8d 50 01             	lea    0x1(%eax),%edx
    3857:	8b 45 08             	mov    0x8(%ebp),%eax
    385a:	8b 00                	mov    (%eax),%eax
    385c:	52                   	push   %edx
    385d:	50                   	push   %eax
    385e:	e8 38 fd ff ff       	call   359b <ucvector_resize>
    3863:	83 c4 08             	add    $0x8,%esp
    3866:	85 c0                	test   %eax,%eax
    3868:	0f 84 44 01 00 00    	je     39b2 <writeBits+0x189>
    386e:	8b 45 08             	mov    0x8(%ebp),%eax
    3871:	8b 00                	mov    (%eax),%eax
    3873:	8b 10                	mov    (%eax),%edx
    3875:	8b 45 08             	mov    0x8(%ebp),%eax
    3878:	8b 00                	mov    (%eax),%eax
    387a:	8b 40 04             	mov    0x4(%eax),%eax
    387d:	83 e8 01             	sub    $0x1,%eax
    3880:	01 d0                	add    %edx,%eax
    3882:	c6 00 00             	movb   $0x0,(%eax)
    3885:	8b 45 08             	mov    0x8(%ebp),%eax
    3888:	8b 00                	mov    (%eax),%eax
    388a:	8b 10                	mov    (%eax),%edx
    388c:	8b 45 08             	mov    0x8(%ebp),%eax
    388f:	8b 00                	mov    (%eax),%eax
    3891:	8b 40 04             	mov    0x4(%eax),%eax
    3894:	83 e8 01             	sub    $0x1,%eax
    3897:	01 c2                	add    %eax,%edx
    3899:	8b 45 08             	mov    0x8(%ebp),%eax
    389c:	8b 00                	mov    (%eax),%eax
    389e:	8b 08                	mov    (%eax),%ecx
    38a0:	8b 45 08             	mov    0x8(%ebp),%eax
    38a3:	8b 00                	mov    (%eax),%eax
    38a5:	8b 40 04             	mov    0x4(%eax),%eax
    38a8:	83 e8 01             	sub    $0x1,%eax
    38ab:	01 c8                	add    %ecx,%eax
    38ad:	0f b6 00             	movzbl (%eax),%eax
    38b0:	88 45 e7             	mov    %al,-0x19(%ebp)
    38b3:	8b 45 08             	mov    0x8(%ebp),%eax
    38b6:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    38ba:	0f b6 c0             	movzbl %al,%eax
    38bd:	83 e0 07             	and    $0x7,%eax
    38c0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    38c3:	89 de                	mov    %ebx,%esi
    38c5:	89 c1                	mov    %eax,%ecx
    38c7:	d3 e6                	shl    %cl,%esi
    38c9:	89 f0                	mov    %esi,%eax
    38cb:	0a 45 e7             	or     -0x19(%ebp),%al
    38ce:	88 02                	mov    %al,(%edx)
    38d0:	8b 45 08             	mov    0x8(%ebp),%eax
    38d3:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    38d7:	8d 50 01             	lea    0x1(%eax),%edx
    38da:	8b 45 08             	mov    0x8(%ebp),%eax
    38dd:	88 50 04             	mov    %dl,0x4(%eax)
    38e0:	e9 d1 00 00 00       	jmp    39b6 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    38e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    38ec:	e9 b3 00 00 00       	jmp    39a4 <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    38f1:	8b 45 08             	mov    0x8(%ebp),%eax
    38f4:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    38f8:	0f b6 c0             	movzbl %al,%eax
    38fb:	83 e0 07             	and    $0x7,%eax
    38fe:	85 c0                	test   %eax,%eax
    3900:	75 39                	jne    393b <writeBits+0x112>
    3902:	8b 45 08             	mov    0x8(%ebp),%eax
    3905:	8b 00                	mov    (%eax),%eax
    3907:	8b 40 04             	mov    0x4(%eax),%eax
    390a:	8d 50 01             	lea    0x1(%eax),%edx
    390d:	8b 45 08             	mov    0x8(%ebp),%eax
    3910:	8b 00                	mov    (%eax),%eax
    3912:	52                   	push   %edx
    3913:	50                   	push   %eax
    3914:	e8 82 fc ff ff       	call   359b <ucvector_resize>
    3919:	83 c4 08             	add    $0x8,%esp
    391c:	85 c0                	test   %eax,%eax
    391e:	0f 84 91 00 00 00    	je     39b5 <writeBits+0x18c>
    3924:	8b 45 08             	mov    0x8(%ebp),%eax
    3927:	8b 00                	mov    (%eax),%eax
    3929:	8b 10                	mov    (%eax),%edx
    392b:	8b 45 08             	mov    0x8(%ebp),%eax
    392e:	8b 00                	mov    (%eax),%eax
    3930:	8b 40 04             	mov    0x4(%eax),%eax
    3933:	83 e8 01             	sub    $0x1,%eax
    3936:	01 d0                	add    %edx,%eax
    3938:	c6 00 00             	movb   $0x0,(%eax)
    393b:	8b 45 08             	mov    0x8(%ebp),%eax
    393e:	8b 00                	mov    (%eax),%eax
    3940:	8b 10                	mov    (%eax),%edx
    3942:	8b 45 08             	mov    0x8(%ebp),%eax
    3945:	8b 00                	mov    (%eax),%eax
    3947:	8b 40 04             	mov    0x4(%eax),%eax
    394a:	83 e8 01             	sub    $0x1,%eax
    394d:	01 c2                	add    %eax,%edx
    394f:	8b 45 08             	mov    0x8(%ebp),%eax
    3952:	8b 00                	mov    (%eax),%eax
    3954:	8b 08                	mov    (%eax),%ecx
    3956:	8b 45 08             	mov    0x8(%ebp),%eax
    3959:	8b 00                	mov    (%eax),%eax
    395b:	8b 40 04             	mov    0x4(%eax),%eax
    395e:	83 e8 01             	sub    $0x1,%eax
    3961:	01 c8                	add    %ecx,%eax
    3963:	0f b6 00             	movzbl (%eax),%eax
    3966:	89 c6                	mov    %eax,%esi
    3968:	8b 45 f4             	mov    -0xc(%ebp),%eax
    396b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    396e:	89 c1                	mov    %eax,%ecx
    3970:	d3 eb                	shr    %cl,%ebx
    3972:	89 d8                	mov    %ebx,%eax
    3974:	83 e0 01             	and    $0x1,%eax
    3977:	89 c3                	mov    %eax,%ebx
    3979:	8b 45 08             	mov    0x8(%ebp),%eax
    397c:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3980:	0f b6 c0             	movzbl %al,%eax
    3983:	83 e0 07             	and    $0x7,%eax
    3986:	89 c1                	mov    %eax,%ecx
    3988:	d3 e3                	shl    %cl,%ebx
    398a:	89 d8                	mov    %ebx,%eax
    398c:	09 f0                	or     %esi,%eax
    398e:	88 02                	mov    %al,(%edx)
    3990:	8b 45 08             	mov    0x8(%ebp),%eax
    3993:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3997:	8d 50 01             	lea    0x1(%eax),%edx
    399a:	8b 45 08             	mov    0x8(%ebp),%eax
    399d:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    39a0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    39a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    39a7:	3b 45 10             	cmp    0x10(%ebp),%eax
    39aa:	0f 85 41 ff ff ff    	jne    38f1 <writeBits+0xc8>
    39b0:	eb 04                	jmp    39b6 <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    39b2:	90                   	nop
    39b3:	eb 01                	jmp    39b6 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    39b5:	90                   	nop
    }
  }
}
    39b6:	8d 65 f8             	lea    -0x8(%ebp),%esp
    39b9:	5b                   	pop    %ebx
    39ba:	5e                   	pop    %esi
    39bb:	5d                   	pop    %ebp
    39bc:	c3                   	ret    

000039bd <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    39bd:	55                   	push   %ebp
    39be:	89 e5                	mov    %esp,%ebp
    39c0:	56                   	push   %esi
    39c1:	53                   	push   %ebx
    39c2:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    39c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    39cc:	e9 bd 00 00 00       	jmp    3a8e <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    39d1:	8b 45 08             	mov    0x8(%ebp),%eax
    39d4:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    39d8:	0f b6 c0             	movzbl %al,%eax
    39db:	83 e0 07             	and    $0x7,%eax
    39de:	85 c0                	test   %eax,%eax
    39e0:	75 39                	jne    3a1b <writeBitsReversed+0x5e>
    39e2:	8b 45 08             	mov    0x8(%ebp),%eax
    39e5:	8b 00                	mov    (%eax),%eax
    39e7:	8b 40 04             	mov    0x4(%eax),%eax
    39ea:	8d 50 01             	lea    0x1(%eax),%edx
    39ed:	8b 45 08             	mov    0x8(%ebp),%eax
    39f0:	8b 00                	mov    (%eax),%eax
    39f2:	52                   	push   %edx
    39f3:	50                   	push   %eax
    39f4:	e8 a2 fb ff ff       	call   359b <ucvector_resize>
    39f9:	83 c4 08             	add    $0x8,%esp
    39fc:	85 c0                	test   %eax,%eax
    39fe:	0f 84 98 00 00 00    	je     3a9c <writeBitsReversed+0xdf>
    3a04:	8b 45 08             	mov    0x8(%ebp),%eax
    3a07:	8b 00                	mov    (%eax),%eax
    3a09:	8b 10                	mov    (%eax),%edx
    3a0b:	8b 45 08             	mov    0x8(%ebp),%eax
    3a0e:	8b 00                	mov    (%eax),%eax
    3a10:	8b 40 04             	mov    0x4(%eax),%eax
    3a13:	83 e8 01             	sub    $0x1,%eax
    3a16:	01 d0                	add    %edx,%eax
    3a18:	c6 00 00             	movb   $0x0,(%eax)
    3a1b:	8b 45 08             	mov    0x8(%ebp),%eax
    3a1e:	8b 00                	mov    (%eax),%eax
    3a20:	8b 10                	mov    (%eax),%edx
    3a22:	8b 45 08             	mov    0x8(%ebp),%eax
    3a25:	8b 00                	mov    (%eax),%eax
    3a27:	8b 40 04             	mov    0x4(%eax),%eax
    3a2a:	83 e8 01             	sub    $0x1,%eax
    3a2d:	01 c2                	add    %eax,%edx
    3a2f:	8b 45 08             	mov    0x8(%ebp),%eax
    3a32:	8b 00                	mov    (%eax),%eax
    3a34:	8b 08                	mov    (%eax),%ecx
    3a36:	8b 45 08             	mov    0x8(%ebp),%eax
    3a39:	8b 00                	mov    (%eax),%eax
    3a3b:	8b 40 04             	mov    0x4(%eax),%eax
    3a3e:	83 e8 01             	sub    $0x1,%eax
    3a41:	01 c8                	add    %ecx,%eax
    3a43:	0f b6 00             	movzbl (%eax),%eax
    3a46:	89 c6                	mov    %eax,%esi
    3a48:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3a4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a4e:	29 c1                	sub    %eax,%ecx
    3a50:	89 c8                	mov    %ecx,%eax
    3a52:	83 e8 01             	sub    $0x1,%eax
    3a55:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3a58:	89 c1                	mov    %eax,%ecx
    3a5a:	d3 eb                	shr    %cl,%ebx
    3a5c:	89 d8                	mov    %ebx,%eax
    3a5e:	83 e0 01             	and    $0x1,%eax
    3a61:	89 c3                	mov    %eax,%ebx
    3a63:	8b 45 08             	mov    0x8(%ebp),%eax
    3a66:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a6a:	0f b6 c0             	movzbl %al,%eax
    3a6d:	83 e0 07             	and    $0x7,%eax
    3a70:	89 c1                	mov    %eax,%ecx
    3a72:	d3 e3                	shl    %cl,%ebx
    3a74:	89 d8                	mov    %ebx,%eax
    3a76:	09 f0                	or     %esi,%eax
    3a78:	88 02                	mov    %al,(%edx)
    3a7a:	8b 45 08             	mov    0x8(%ebp),%eax
    3a7d:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a81:	8d 50 01             	lea    0x1(%eax),%edx
    3a84:	8b 45 08             	mov    0x8(%ebp),%eax
    3a87:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3a8a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3a8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a91:	3b 45 10             	cmp    0x10(%ebp),%eax
    3a94:	0f 85 37 ff ff ff    	jne    39d1 <writeBitsReversed+0x14>
    3a9a:	eb 01                	jmp    3a9d <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3a9c:	90                   	nop
  }
}
    3a9d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3aa0:	5b                   	pop    %ebx
    3aa1:	5e                   	pop    %esi
    3aa2:	5d                   	pop    %ebp
    3aa3:	c3                   	ret    

00003aa4 <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    3aa4:	55                   	push   %ebp
    3aa5:	89 e5                	mov    %esp,%ebp
    3aa7:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    3aaa:	8b 45 08             	mov    0x8(%ebp),%eax
    3aad:	8b 55 0c             	mov    0xc(%ebp),%edx
    3ab0:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    3ab2:	8b 45 08             	mov    0x8(%ebp),%eax
    3ab5:	8b 55 10             	mov    0x10(%ebp),%edx
    3ab8:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    3abb:	8b 45 08             	mov    0x8(%ebp),%eax
    3abe:	83 c0 08             	add    $0x8,%eax
    3ac1:	50                   	push   %eax
    3ac2:	6a 08                	push   $0x8
    3ac4:	ff 75 10             	pushl  0x10(%ebp)
    3ac7:	e8 59 f9 ff ff       	call   3425 <lodepng_mulofl>
    3acc:	83 c4 0c             	add    $0xc,%esp
    3acf:	85 c0                	test   %eax,%eax
    3ad1:	74 07                	je     3ada <LodePNGBitReader_init+0x36>
    3ad3:	b8 69 00 00 00       	mov    $0x69,%eax
    3ad8:	eb 39                	jmp    3b13 <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    3ada:	8b 45 08             	mov    0x8(%ebp),%eax
    3add:	8b 40 08             	mov    0x8(%eax),%eax
    3ae0:	8d 55 fc             	lea    -0x4(%ebp),%edx
    3ae3:	52                   	push   %edx
    3ae4:	6a 40                	push   $0x40
    3ae6:	50                   	push   %eax
    3ae7:	e8 19 f9 ff ff       	call   3405 <lodepng_addofl>
    3aec:	83 c4 0c             	add    $0xc,%esp
    3aef:	85 c0                	test   %eax,%eax
    3af1:	74 07                	je     3afa <LodePNGBitReader_init+0x56>
    3af3:	b8 69 00 00 00       	mov    $0x69,%eax
    3af8:	eb 19                	jmp    3b13 <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    3afa:	8b 45 08             	mov    0x8(%ebp),%eax
    3afd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    3b04:	8b 45 08             	mov    0x8(%ebp),%eax
    3b07:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    3b0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3b13:	c9                   	leave  
    3b14:	c3                   	ret    

00003b15 <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    3b15:	55                   	push   %ebp
    3b16:	89 e5                	mov    %esp,%ebp
    3b18:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3b1b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b1e:	8b 40 0c             	mov    0xc(%eax),%eax
    3b21:	c1 f8 03             	sar    $0x3,%eax
    3b24:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3b27:	8b 45 08             	mov    0x8(%ebp),%eax
    3b2a:	8b 40 04             	mov    0x4(%eax),%eax
    3b2d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    3b30:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3b33:	8d 50 01             	lea    0x1(%eax),%edx
    3b36:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3b39:	39 c2                	cmp    %eax,%edx
    3b3b:	73 4e                	jae    3b8b <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    3b3d:	8b 45 08             	mov    0x8(%ebp),%eax
    3b40:	8b 10                	mov    (%eax),%edx
    3b42:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3b45:	01 d0                	add    %edx,%eax
    3b47:	0f b6 00             	movzbl (%eax),%eax
    3b4a:	0f b6 d0             	movzbl %al,%edx
    3b4d:	8b 45 08             	mov    0x8(%ebp),%eax
    3b50:	8b 00                	mov    (%eax),%eax
    3b52:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3b55:	83 c1 01             	add    $0x1,%ecx
    3b58:	01 c8                	add    %ecx,%eax
    3b5a:	0f b6 00             	movzbl (%eax),%eax
    3b5d:	0f b6 c0             	movzbl %al,%eax
    3b60:	c1 e0 08             	shl    $0x8,%eax
    3b63:	09 c2                	or     %eax,%edx
    3b65:	8b 45 08             	mov    0x8(%ebp),%eax
    3b68:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3b6b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b6e:	8b 50 10             	mov    0x10(%eax),%edx
    3b71:	8b 45 08             	mov    0x8(%ebp),%eax
    3b74:	8b 40 0c             	mov    0xc(%eax),%eax
    3b77:	83 e0 07             	and    $0x7,%eax
    3b7a:	89 c1                	mov    %eax,%ecx
    3b7c:	d3 ea                	shr    %cl,%edx
    3b7e:	8b 45 08             	mov    0x8(%ebp),%eax
    3b81:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3b84:	b8 01 00 00 00       	mov    $0x1,%eax
    3b89:	eb 64                	jmp    3bef <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    3b8b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b8e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3b95:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3b98:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3b9b:	39 c2                	cmp    %eax,%edx
    3b9d:	73 1e                	jae    3bbd <ensureBits9+0xa8>
    3b9f:	8b 45 08             	mov    0x8(%ebp),%eax
    3ba2:	8b 50 10             	mov    0x10(%eax),%edx
    3ba5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ba8:	8b 08                	mov    (%eax),%ecx
    3baa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3bad:	01 c8                	add    %ecx,%eax
    3baf:	0f b6 00             	movzbl (%eax),%eax
    3bb2:	0f b6 c0             	movzbl %al,%eax
    3bb5:	09 c2                	or     %eax,%edx
    3bb7:	8b 45 08             	mov    0x8(%ebp),%eax
    3bba:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3bbd:	8b 45 08             	mov    0x8(%ebp),%eax
    3bc0:	8b 50 10             	mov    0x10(%eax),%edx
    3bc3:	8b 45 08             	mov    0x8(%ebp),%eax
    3bc6:	8b 40 0c             	mov    0xc(%eax),%eax
    3bc9:	83 e0 07             	and    $0x7,%eax
    3bcc:	89 c1                	mov    %eax,%ecx
    3bce:	d3 ea                	shr    %cl,%edx
    3bd0:	8b 45 08             	mov    0x8(%ebp),%eax
    3bd3:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3bd6:	8b 45 08             	mov    0x8(%ebp),%eax
    3bd9:	8b 50 0c             	mov    0xc(%eax),%edx
    3bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
    3bdf:	01 c2                	add    %eax,%edx
    3be1:	8b 45 08             	mov    0x8(%ebp),%eax
    3be4:	8b 40 08             	mov    0x8(%eax),%eax
    3be7:	39 c2                	cmp    %eax,%edx
    3be9:	0f 9e c0             	setle  %al
    3bec:	0f b6 c0             	movzbl %al,%eax
  }
}
    3bef:	c9                   	leave  
    3bf0:	c3                   	ret    

00003bf1 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    3bf1:	55                   	push   %ebp
    3bf2:	89 e5                	mov    %esp,%ebp
    3bf4:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3bf7:	8b 45 08             	mov    0x8(%ebp),%eax
    3bfa:	8b 40 0c             	mov    0xc(%eax),%eax
    3bfd:	c1 f8 03             	sar    $0x3,%eax
    3c00:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3c03:	8b 45 08             	mov    0x8(%ebp),%eax
    3c06:	8b 40 04             	mov    0x4(%eax),%eax
    3c09:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    3c0c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c0f:	8d 50 02             	lea    0x2(%eax),%edx
    3c12:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c15:	39 c2                	cmp    %eax,%edx
    3c17:	73 6d                	jae    3c86 <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3c19:	8b 45 08             	mov    0x8(%ebp),%eax
    3c1c:	8b 10                	mov    (%eax),%edx
    3c1e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c21:	01 d0                	add    %edx,%eax
    3c23:	0f b6 00             	movzbl (%eax),%eax
    3c26:	0f b6 d0             	movzbl %al,%edx
    3c29:	8b 45 08             	mov    0x8(%ebp),%eax
    3c2c:	8b 00                	mov    (%eax),%eax
    3c2e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3c31:	83 c1 01             	add    $0x1,%ecx
    3c34:	01 c8                	add    %ecx,%eax
    3c36:	0f b6 00             	movzbl (%eax),%eax
    3c39:	0f b6 c0             	movzbl %al,%eax
    3c3c:	c1 e0 08             	shl    $0x8,%eax
    3c3f:	89 d1                	mov    %edx,%ecx
    3c41:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    3c43:	8b 45 08             	mov    0x8(%ebp),%eax
    3c46:	8b 00                	mov    (%eax),%eax
    3c48:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3c4b:	83 c2 02             	add    $0x2,%edx
    3c4e:	01 d0                	add    %edx,%eax
    3c50:	0f b6 00             	movzbl (%eax),%eax
    3c53:	0f b6 c0             	movzbl %al,%eax
    3c56:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3c59:	09 c1                	or     %eax,%ecx
    3c5b:	89 ca                	mov    %ecx,%edx
    3c5d:	8b 45 08             	mov    0x8(%ebp),%eax
    3c60:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    3c63:	8b 45 08             	mov    0x8(%ebp),%eax
    3c66:	8b 50 10             	mov    0x10(%eax),%edx
    3c69:	8b 45 08             	mov    0x8(%ebp),%eax
    3c6c:	8b 40 0c             	mov    0xc(%eax),%eax
    3c6f:	83 e0 07             	and    $0x7,%eax
    3c72:	89 c1                	mov    %eax,%ecx
    3c74:	d3 ea                	shr    %cl,%edx
    3c76:	8b 45 08             	mov    0x8(%ebp),%eax
    3c79:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3c7c:	b8 01 00 00 00       	mov    $0x1,%eax
    3c81:	e9 95 00 00 00       	jmp    3d1b <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    3c86:	8b 45 08             	mov    0x8(%ebp),%eax
    3c89:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3c90:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3c93:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c96:	39 c2                	cmp    %eax,%edx
    3c98:	73 1e                	jae    3cb8 <ensureBits17+0xc7>
    3c9a:	8b 45 08             	mov    0x8(%ebp),%eax
    3c9d:	8b 50 10             	mov    0x10(%eax),%edx
    3ca0:	8b 45 08             	mov    0x8(%ebp),%eax
    3ca3:	8b 08                	mov    (%eax),%ecx
    3ca5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ca8:	01 c8                	add    %ecx,%eax
    3caa:	0f b6 00             	movzbl (%eax),%eax
    3cad:	0f b6 c0             	movzbl %al,%eax
    3cb0:	09 c2                	or     %eax,%edx
    3cb2:	8b 45 08             	mov    0x8(%ebp),%eax
    3cb5:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3cb8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3cbb:	8d 50 01             	lea    0x1(%eax),%edx
    3cbe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3cc1:	39 c2                	cmp    %eax,%edx
    3cc3:	73 24                	jae    3ce9 <ensureBits17+0xf8>
    3cc5:	8b 45 08             	mov    0x8(%ebp),%eax
    3cc8:	8b 50 10             	mov    0x10(%eax),%edx
    3ccb:	8b 45 08             	mov    0x8(%ebp),%eax
    3cce:	8b 00                	mov    (%eax),%eax
    3cd0:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3cd3:	83 c1 01             	add    $0x1,%ecx
    3cd6:	01 c8                	add    %ecx,%eax
    3cd8:	0f b6 00             	movzbl (%eax),%eax
    3cdb:	0f b6 c0             	movzbl %al,%eax
    3cde:	c1 e0 08             	shl    $0x8,%eax
    3ce1:	09 c2                	or     %eax,%edx
    3ce3:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce6:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3ce9:	8b 45 08             	mov    0x8(%ebp),%eax
    3cec:	8b 50 10             	mov    0x10(%eax),%edx
    3cef:	8b 45 08             	mov    0x8(%ebp),%eax
    3cf2:	8b 40 0c             	mov    0xc(%eax),%eax
    3cf5:	83 e0 07             	and    $0x7,%eax
    3cf8:	89 c1                	mov    %eax,%ecx
    3cfa:	d3 ea                	shr    %cl,%edx
    3cfc:	8b 45 08             	mov    0x8(%ebp),%eax
    3cff:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3d02:	8b 45 08             	mov    0x8(%ebp),%eax
    3d05:	8b 50 0c             	mov    0xc(%eax),%edx
    3d08:	8b 45 0c             	mov    0xc(%ebp),%eax
    3d0b:	01 c2                	add    %eax,%edx
    3d0d:	8b 45 08             	mov    0x8(%ebp),%eax
    3d10:	8b 40 08             	mov    0x8(%eax),%eax
    3d13:	39 c2                	cmp    %eax,%edx
    3d15:	0f 9e c0             	setle  %al
    3d18:	0f b6 c0             	movzbl %al,%eax
  }
}
    3d1b:	c9                   	leave  
    3d1c:	c3                   	ret    

00003d1d <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    3d1d:	55                   	push   %ebp
    3d1e:	89 e5                	mov    %esp,%ebp
    3d20:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3d23:	8b 45 08             	mov    0x8(%ebp),%eax
    3d26:	8b 40 0c             	mov    0xc(%eax),%eax
    3d29:	c1 f8 03             	sar    $0x3,%eax
    3d2c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3d2f:	8b 45 08             	mov    0x8(%ebp),%eax
    3d32:	8b 40 04             	mov    0x4(%eax),%eax
    3d35:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    3d38:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d3b:	8d 50 03             	lea    0x3(%eax),%edx
    3d3e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3d41:	39 c2                	cmp    %eax,%edx
    3d43:	0f 83 85 00 00 00    	jae    3dce <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d49:	8b 45 08             	mov    0x8(%ebp),%eax
    3d4c:	8b 10                	mov    (%eax),%edx
    3d4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d51:	01 d0                	add    %edx,%eax
    3d53:	0f b6 00             	movzbl (%eax),%eax
    3d56:	0f b6 d0             	movzbl %al,%edx
    3d59:	8b 45 08             	mov    0x8(%ebp),%eax
    3d5c:	8b 00                	mov    (%eax),%eax
    3d5e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3d61:	83 c1 01             	add    $0x1,%ecx
    3d64:	01 c8                	add    %ecx,%eax
    3d66:	0f b6 00             	movzbl (%eax),%eax
    3d69:	0f b6 c0             	movzbl %al,%eax
    3d6c:	c1 e0 08             	shl    $0x8,%eax
    3d6f:	89 d1                	mov    %edx,%ecx
    3d71:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3d73:	8b 45 08             	mov    0x8(%ebp),%eax
    3d76:	8b 00                	mov    (%eax),%eax
    3d78:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d7b:	83 c2 02             	add    $0x2,%edx
    3d7e:	01 d0                	add    %edx,%eax
    3d80:	0f b6 00             	movzbl (%eax),%eax
    3d83:	0f b6 c0             	movzbl %al,%eax
    3d86:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d89:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3d8b:	8b 45 08             	mov    0x8(%ebp),%eax
    3d8e:	8b 00                	mov    (%eax),%eax
    3d90:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d93:	83 c2 03             	add    $0x3,%edx
    3d96:	01 d0                	add    %edx,%eax
    3d98:	0f b6 00             	movzbl (%eax),%eax
    3d9b:	0f b6 c0             	movzbl %al,%eax
    3d9e:	c1 e0 18             	shl    $0x18,%eax
    3da1:	09 c1                	or     %eax,%ecx
    3da3:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3da5:	8b 45 08             	mov    0x8(%ebp),%eax
    3da8:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3dab:	8b 45 08             	mov    0x8(%ebp),%eax
    3dae:	8b 50 10             	mov    0x10(%eax),%edx
    3db1:	8b 45 08             	mov    0x8(%ebp),%eax
    3db4:	8b 40 0c             	mov    0xc(%eax),%eax
    3db7:	83 e0 07             	and    $0x7,%eax
    3dba:	89 c1                	mov    %eax,%ecx
    3dbc:	d3 ea                	shr    %cl,%edx
    3dbe:	8b 45 08             	mov    0x8(%ebp),%eax
    3dc1:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3dc4:	b8 01 00 00 00       	mov    $0x1,%eax
    3dc9:	e9 c6 00 00 00       	jmp    3e94 <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    3dce:	8b 45 08             	mov    0x8(%ebp),%eax
    3dd1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3dd8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3ddb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3dde:	39 c2                	cmp    %eax,%edx
    3de0:	73 1e                	jae    3e00 <ensureBits25+0xe3>
    3de2:	8b 45 08             	mov    0x8(%ebp),%eax
    3de5:	8b 50 10             	mov    0x10(%eax),%edx
    3de8:	8b 45 08             	mov    0x8(%ebp),%eax
    3deb:	8b 08                	mov    (%eax),%ecx
    3ded:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3df0:	01 c8                	add    %ecx,%eax
    3df2:	0f b6 00             	movzbl (%eax),%eax
    3df5:	0f b6 c0             	movzbl %al,%eax
    3df8:	09 c2                	or     %eax,%edx
    3dfa:	8b 45 08             	mov    0x8(%ebp),%eax
    3dfd:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3e00:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e03:	8d 50 01             	lea    0x1(%eax),%edx
    3e06:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e09:	39 c2                	cmp    %eax,%edx
    3e0b:	73 24                	jae    3e31 <ensureBits25+0x114>
    3e0d:	8b 45 08             	mov    0x8(%ebp),%eax
    3e10:	8b 50 10             	mov    0x10(%eax),%edx
    3e13:	8b 45 08             	mov    0x8(%ebp),%eax
    3e16:	8b 00                	mov    (%eax),%eax
    3e18:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3e1b:	83 c1 01             	add    $0x1,%ecx
    3e1e:	01 c8                	add    %ecx,%eax
    3e20:	0f b6 00             	movzbl (%eax),%eax
    3e23:	0f b6 c0             	movzbl %al,%eax
    3e26:	c1 e0 08             	shl    $0x8,%eax
    3e29:	09 c2                	or     %eax,%edx
    3e2b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e2e:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3e31:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e34:	8d 50 02             	lea    0x2(%eax),%edx
    3e37:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e3a:	39 c2                	cmp    %eax,%edx
    3e3c:	73 24                	jae    3e62 <ensureBits25+0x145>
    3e3e:	8b 45 08             	mov    0x8(%ebp),%eax
    3e41:	8b 50 10             	mov    0x10(%eax),%edx
    3e44:	8b 45 08             	mov    0x8(%ebp),%eax
    3e47:	8b 00                	mov    (%eax),%eax
    3e49:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3e4c:	83 c1 02             	add    $0x2,%ecx
    3e4f:	01 c8                	add    %ecx,%eax
    3e51:	0f b6 00             	movzbl (%eax),%eax
    3e54:	0f b6 c0             	movzbl %al,%eax
    3e57:	c1 e0 10             	shl    $0x10,%eax
    3e5a:	09 c2                	or     %eax,%edx
    3e5c:	8b 45 08             	mov    0x8(%ebp),%eax
    3e5f:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3e62:	8b 45 08             	mov    0x8(%ebp),%eax
    3e65:	8b 50 10             	mov    0x10(%eax),%edx
    3e68:	8b 45 08             	mov    0x8(%ebp),%eax
    3e6b:	8b 40 0c             	mov    0xc(%eax),%eax
    3e6e:	83 e0 07             	and    $0x7,%eax
    3e71:	89 c1                	mov    %eax,%ecx
    3e73:	d3 ea                	shr    %cl,%edx
    3e75:	8b 45 08             	mov    0x8(%ebp),%eax
    3e78:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3e7b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e7e:	8b 50 0c             	mov    0xc(%eax),%edx
    3e81:	8b 45 0c             	mov    0xc(%ebp),%eax
    3e84:	01 c2                	add    %eax,%edx
    3e86:	8b 45 08             	mov    0x8(%ebp),%eax
    3e89:	8b 40 08             	mov    0x8(%eax),%eax
    3e8c:	39 c2                	cmp    %eax,%edx
    3e8e:	0f 9e c0             	setle  %al
    3e91:	0f b6 c0             	movzbl %al,%eax
  }
}
    3e94:	c9                   	leave  
    3e95:	c3                   	ret    

00003e96 <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    3e96:	55                   	push   %ebp
    3e97:	89 e5                	mov    %esp,%ebp
    3e99:	53                   	push   %ebx
    3e9a:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3e9d:	8b 45 08             	mov    0x8(%ebp),%eax
    3ea0:	8b 40 0c             	mov    0xc(%eax),%eax
    3ea3:	c1 f8 03             	sar    $0x3,%eax
    3ea6:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    3ea9:	8b 45 08             	mov    0x8(%ebp),%eax
    3eac:	8b 40 04             	mov    0x4(%eax),%eax
    3eaf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    3eb2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3eb5:	8d 50 04             	lea    0x4(%eax),%edx
    3eb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3ebb:	39 c2                	cmp    %eax,%edx
    3ebd:	0f 83 c3 00 00 00    	jae    3f86 <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ec3:	8b 45 08             	mov    0x8(%ebp),%eax
    3ec6:	8b 10                	mov    (%eax),%edx
    3ec8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ecb:	01 d0                	add    %edx,%eax
    3ecd:	0f b6 00             	movzbl (%eax),%eax
    3ed0:	0f b6 d0             	movzbl %al,%edx
    3ed3:	8b 45 08             	mov    0x8(%ebp),%eax
    3ed6:	8b 00                	mov    (%eax),%eax
    3ed8:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3edb:	83 c1 01             	add    $0x1,%ecx
    3ede:	01 c8                	add    %ecx,%eax
    3ee0:	0f b6 00             	movzbl (%eax),%eax
    3ee3:	0f b6 c0             	movzbl %al,%eax
    3ee6:	c1 e0 08             	shl    $0x8,%eax
    3ee9:	89 d1                	mov    %edx,%ecx
    3eeb:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3eed:	8b 45 08             	mov    0x8(%ebp),%eax
    3ef0:	8b 00                	mov    (%eax),%eax
    3ef2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3ef5:	83 c2 02             	add    $0x2,%edx
    3ef8:	01 d0                	add    %edx,%eax
    3efa:	0f b6 00             	movzbl (%eax),%eax
    3efd:	0f b6 c0             	movzbl %al,%eax
    3f00:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3f03:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3f05:	8b 45 08             	mov    0x8(%ebp),%eax
    3f08:	8b 00                	mov    (%eax),%eax
    3f0a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3f0d:	83 c2 03             	add    $0x3,%edx
    3f10:	01 d0                	add    %edx,%eax
    3f12:	0f b6 00             	movzbl (%eax),%eax
    3f15:	0f b6 c0             	movzbl %al,%eax
    3f18:	c1 e0 18             	shl    $0x18,%eax
    3f1b:	09 c1                	or     %eax,%ecx
    3f1d:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3f1f:	8b 45 08             	mov    0x8(%ebp),%eax
    3f22:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3f25:	8b 45 08             	mov    0x8(%ebp),%eax
    3f28:	8b 50 10             	mov    0x10(%eax),%edx
    3f2b:	8b 45 08             	mov    0x8(%ebp),%eax
    3f2e:	8b 40 0c             	mov    0xc(%eax),%eax
    3f31:	83 e0 07             	and    $0x7,%eax
    3f34:	89 c1                	mov    %eax,%ecx
    3f36:	d3 ea                	shr    %cl,%edx
    3f38:	8b 45 08             	mov    0x8(%ebp),%eax
    3f3b:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    3f3e:	8b 45 08             	mov    0x8(%ebp),%eax
    3f41:	8b 50 10             	mov    0x10(%eax),%edx
    3f44:	8b 45 08             	mov    0x8(%ebp),%eax
    3f47:	8b 00                	mov    (%eax),%eax
    3f49:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3f4c:	83 c1 04             	add    $0x4,%ecx
    3f4f:	01 c8                	add    %ecx,%eax
    3f51:	0f b6 00             	movzbl (%eax),%eax
    3f54:	0f b6 c0             	movzbl %al,%eax
    3f57:	c1 e0 18             	shl    $0x18,%eax
    3f5a:	89 c3                	mov    %eax,%ebx
    3f5c:	8b 45 08             	mov    0x8(%ebp),%eax
    3f5f:	8b 40 0c             	mov    0xc(%eax),%eax
    3f62:	83 e0 07             	and    $0x7,%eax
    3f65:	b9 08 00 00 00       	mov    $0x8,%ecx
    3f6a:	29 c1                	sub    %eax,%ecx
    3f6c:	89 c8                	mov    %ecx,%eax
    3f6e:	89 c1                	mov    %eax,%ecx
    3f70:	d3 e3                	shl    %cl,%ebx
    3f72:	89 d8                	mov    %ebx,%eax
    3f74:	09 c2                	or     %eax,%edx
    3f76:	8b 45 08             	mov    0x8(%ebp),%eax
    3f79:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3f7c:	b8 01 00 00 00       	mov    $0x1,%eax
    3f81:	e9 f7 00 00 00       	jmp    407d <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    3f86:	8b 45 08             	mov    0x8(%ebp),%eax
    3f89:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3f90:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3f93:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3f96:	39 c2                	cmp    %eax,%edx
    3f98:	73 1e                	jae    3fb8 <ensureBits32+0x122>
    3f9a:	8b 45 08             	mov    0x8(%ebp),%eax
    3f9d:	8b 50 10             	mov    0x10(%eax),%edx
    3fa0:	8b 45 08             	mov    0x8(%ebp),%eax
    3fa3:	8b 08                	mov    (%eax),%ecx
    3fa5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3fa8:	01 c8                	add    %ecx,%eax
    3faa:	0f b6 00             	movzbl (%eax),%eax
    3fad:	0f b6 c0             	movzbl %al,%eax
    3fb0:	09 c2                	or     %eax,%edx
    3fb2:	8b 45 08             	mov    0x8(%ebp),%eax
    3fb5:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3fb8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3fbb:	8d 50 01             	lea    0x1(%eax),%edx
    3fbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3fc1:	39 c2                	cmp    %eax,%edx
    3fc3:	73 24                	jae    3fe9 <ensureBits32+0x153>
    3fc5:	8b 45 08             	mov    0x8(%ebp),%eax
    3fc8:	8b 50 10             	mov    0x10(%eax),%edx
    3fcb:	8b 45 08             	mov    0x8(%ebp),%eax
    3fce:	8b 00                	mov    (%eax),%eax
    3fd0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3fd3:	83 c1 01             	add    $0x1,%ecx
    3fd6:	01 c8                	add    %ecx,%eax
    3fd8:	0f b6 00             	movzbl (%eax),%eax
    3fdb:	0f b6 c0             	movzbl %al,%eax
    3fde:	c1 e0 08             	shl    $0x8,%eax
    3fe1:	09 c2                	or     %eax,%edx
    3fe3:	8b 45 08             	mov    0x8(%ebp),%eax
    3fe6:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3fe9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3fec:	8d 50 02             	lea    0x2(%eax),%edx
    3fef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3ff2:	39 c2                	cmp    %eax,%edx
    3ff4:	73 24                	jae    401a <ensureBits32+0x184>
    3ff6:	8b 45 08             	mov    0x8(%ebp),%eax
    3ff9:	8b 50 10             	mov    0x10(%eax),%edx
    3ffc:	8b 45 08             	mov    0x8(%ebp),%eax
    3fff:	8b 00                	mov    (%eax),%eax
    4001:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4004:	83 c1 02             	add    $0x2,%ecx
    4007:	01 c8                	add    %ecx,%eax
    4009:	0f b6 00             	movzbl (%eax),%eax
    400c:	0f b6 c0             	movzbl %al,%eax
    400f:	c1 e0 10             	shl    $0x10,%eax
    4012:	09 c2                	or     %eax,%edx
    4014:	8b 45 08             	mov    0x8(%ebp),%eax
    4017:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    401a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    401d:	8d 50 03             	lea    0x3(%eax),%edx
    4020:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4023:	39 c2                	cmp    %eax,%edx
    4025:	73 24                	jae    404b <ensureBits32+0x1b5>
    4027:	8b 45 08             	mov    0x8(%ebp),%eax
    402a:	8b 50 10             	mov    0x10(%eax),%edx
    402d:	8b 45 08             	mov    0x8(%ebp),%eax
    4030:	8b 00                	mov    (%eax),%eax
    4032:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4035:	83 c1 03             	add    $0x3,%ecx
    4038:	01 c8                	add    %ecx,%eax
    403a:	0f b6 00             	movzbl (%eax),%eax
    403d:	0f b6 c0             	movzbl %al,%eax
    4040:	c1 e0 18             	shl    $0x18,%eax
    4043:	09 c2                	or     %eax,%edx
    4045:	8b 45 08             	mov    0x8(%ebp),%eax
    4048:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    404b:	8b 45 08             	mov    0x8(%ebp),%eax
    404e:	8b 50 10             	mov    0x10(%eax),%edx
    4051:	8b 45 08             	mov    0x8(%ebp),%eax
    4054:	8b 40 0c             	mov    0xc(%eax),%eax
    4057:	83 e0 07             	and    $0x7,%eax
    405a:	89 c1                	mov    %eax,%ecx
    405c:	d3 ea                	shr    %cl,%edx
    405e:	8b 45 08             	mov    0x8(%ebp),%eax
    4061:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4064:	8b 45 08             	mov    0x8(%ebp),%eax
    4067:	8b 50 0c             	mov    0xc(%eax),%edx
    406a:	8b 45 0c             	mov    0xc(%ebp),%eax
    406d:	01 c2                	add    %eax,%edx
    406f:	8b 45 08             	mov    0x8(%ebp),%eax
    4072:	8b 40 08             	mov    0x8(%eax),%eax
    4075:	39 c2                	cmp    %eax,%edx
    4077:	0f 9e c0             	setle  %al
    407a:	0f b6 c0             	movzbl %al,%eax
  }
}
    407d:	83 c4 10             	add    $0x10,%esp
    4080:	5b                   	pop    %ebx
    4081:	5d                   	pop    %ebp
    4082:	c3                   	ret    

00004083 <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    4083:	55                   	push   %ebp
    4084:	89 e5                	mov    %esp,%ebp
    4086:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    4087:	8b 45 08             	mov    0x8(%ebp),%eax
    408a:	8b 50 10             	mov    0x10(%eax),%edx
    408d:	8b 45 0c             	mov    0xc(%ebp),%eax
    4090:	bb 01 00 00 00       	mov    $0x1,%ebx
    4095:	89 c1                	mov    %eax,%ecx
    4097:	d3 e3                	shl    %cl,%ebx
    4099:	89 d8                	mov    %ebx,%eax
    409b:	83 e8 01             	sub    $0x1,%eax
    409e:	21 d0                	and    %edx,%eax
}
    40a0:	5b                   	pop    %ebx
    40a1:	5d                   	pop    %ebp
    40a2:	c3                   	ret    

000040a3 <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    40a3:	55                   	push   %ebp
    40a4:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    40a6:	8b 45 08             	mov    0x8(%ebp),%eax
    40a9:	8b 50 10             	mov    0x10(%eax),%edx
    40ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    40af:	89 c1                	mov    %eax,%ecx
    40b1:	d3 ea                	shr    %cl,%edx
    40b3:	8b 45 08             	mov    0x8(%ebp),%eax
    40b6:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    40b9:	8b 45 08             	mov    0x8(%ebp),%eax
    40bc:	8b 50 0c             	mov    0xc(%eax),%edx
    40bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    40c2:	01 c2                	add    %eax,%edx
    40c4:	8b 45 08             	mov    0x8(%ebp),%eax
    40c7:	89 50 0c             	mov    %edx,0xc(%eax)
}
    40ca:	90                   	nop
    40cb:	5d                   	pop    %ebp
    40cc:	c3                   	ret    

000040cd <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    40cd:	55                   	push   %ebp
    40ce:	89 e5                	mov    %esp,%ebp
    40d0:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    40d3:	ff 75 0c             	pushl  0xc(%ebp)
    40d6:	ff 75 08             	pushl  0x8(%ebp)
    40d9:	e8 a5 ff ff ff       	call   4083 <peekBits>
    40de:	83 c4 08             	add    $0x8,%esp
    40e1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    40e4:	ff 75 0c             	pushl  0xc(%ebp)
    40e7:	ff 75 08             	pushl  0x8(%ebp)
    40ea:	e8 b4 ff ff ff       	call   40a3 <advanceBits>
    40ef:	83 c4 08             	add    $0x8,%esp
  return result;
    40f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    40f5:	c9                   	leave  
    40f6:	c3                   	ret    

000040f7 <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    40f7:	55                   	push   %ebp
    40f8:	89 e5                	mov    %esp,%ebp
    40fa:	53                   	push   %ebx
    40fb:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    40fe:	ff 75 0c             	pushl  0xc(%ebp)
    4101:	ff 75 08             	pushl  0x8(%ebp)
    4104:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4107:	50                   	push   %eax
    4108:	e8 97 f9 ff ff       	call   3aa4 <LodePNGBitReader_init>
    410d:	83 c4 0c             	add    $0xc,%esp
    4110:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    4113:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    4117:	74 0a                	je     4123 <lode_png_test_bitreader+0x2c>
    4119:	b8 00 00 00 00       	mov    $0x0,%eax
    411e:	e9 c3 00 00 00       	jmp    41e6 <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    4123:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    412a:	e9 a6 00 00 00       	jmp    41d5 <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    412f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4132:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4139:	8b 45 14             	mov    0x14(%ebp),%eax
    413c:	01 d0                	add    %edx,%eax
    413e:	8b 00                	mov    (%eax),%eax
    4140:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    4143:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    4147:	7e 14                	jle    415d <lode_png_test_bitreader+0x66>
    4149:	ff 75 ec             	pushl  -0x14(%ebp)
    414c:	8d 45 d8             	lea    -0x28(%ebp),%eax
    414f:	50                   	push   %eax
    4150:	e8 41 fd ff ff       	call   3e96 <ensureBits32>
    4155:	83 c4 08             	add    $0x8,%esp
    4158:	89 45 f4             	mov    %eax,-0xc(%ebp)
    415b:	eb 46                	jmp    41a3 <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    415d:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    4161:	7e 14                	jle    4177 <lode_png_test_bitreader+0x80>
    4163:	ff 75 ec             	pushl  -0x14(%ebp)
    4166:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4169:	50                   	push   %eax
    416a:	e8 ae fb ff ff       	call   3d1d <ensureBits25>
    416f:	83 c4 08             	add    $0x8,%esp
    4172:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4175:	eb 2c                	jmp    41a3 <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    4177:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    417b:	7e 14                	jle    4191 <lode_png_test_bitreader+0x9a>
    417d:	ff 75 ec             	pushl  -0x14(%ebp)
    4180:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4183:	50                   	push   %eax
    4184:	e8 68 fa ff ff       	call   3bf1 <ensureBits17>
    4189:	83 c4 08             	add    $0x8,%esp
    418c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    418f:	eb 12                	jmp    41a3 <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    4191:	ff 75 ec             	pushl  -0x14(%ebp)
    4194:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4197:	50                   	push   %eax
    4198:	e8 78 f9 ff ff       	call   3b15 <ensureBits9>
    419d:	83 c4 08             	add    $0x8,%esp
    41a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    41a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    41a7:	75 07                	jne    41b0 <lode_png_test_bitreader+0xb9>
    41a9:	b8 00 00 00 00       	mov    $0x0,%eax
    41ae:	eb 36                	jmp    41e6 <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    41b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    41b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    41ba:	8b 45 18             	mov    0x18(%ebp),%eax
    41bd:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    41c0:	ff 75 ec             	pushl  -0x14(%ebp)
    41c3:	8d 45 d8             	lea    -0x28(%ebp),%eax
    41c6:	50                   	push   %eax
    41c7:	e8 01 ff ff ff       	call   40cd <readBits>
    41cc:	83 c4 08             	add    $0x8,%esp
    41cf:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    41d1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    41d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    41d8:	3b 45 10             	cmp    0x10(%ebp),%eax
    41db:	0f 8c 4e ff ff ff    	jl     412f <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    41e1:	b8 01 00 00 00       	mov    $0x1,%eax
}
    41e6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    41e9:	c9                   	leave  
    41ea:	c3                   	ret    

000041eb <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    41eb:	55                   	push   %ebp
    41ec:	89 e5                	mov    %esp,%ebp
    41ee:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    41f1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    41f8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    41ff:	eb 27                	jmp    4228 <reverseBits+0x3d>
    4201:	8b 45 0c             	mov    0xc(%ebp),%eax
    4204:	2b 45 fc             	sub    -0x4(%ebp),%eax
    4207:	83 e8 01             	sub    $0x1,%eax
    420a:	8b 55 08             	mov    0x8(%ebp),%edx
    420d:	89 c1                	mov    %eax,%ecx
    420f:	d3 ea                	shr    %cl,%edx
    4211:	89 d0                	mov    %edx,%eax
    4213:	83 e0 01             	and    $0x1,%eax
    4216:	89 c2                	mov    %eax,%edx
    4218:	8b 45 fc             	mov    -0x4(%ebp),%eax
    421b:	89 c1                	mov    %eax,%ecx
    421d:	d3 e2                	shl    %cl,%edx
    421f:	89 d0                	mov    %edx,%eax
    4221:	09 45 f8             	or     %eax,-0x8(%ebp)
    4224:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    4228:	8b 45 fc             	mov    -0x4(%ebp),%eax
    422b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    422e:	72 d1                	jb     4201 <reverseBits+0x16>
  return result;
    4230:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    4233:	c9                   	leave  
    4234:	c3                   	ret    

00004235 <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    4235:	55                   	push   %ebp
    4236:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    4238:	8b 45 08             	mov    0x8(%ebp),%eax
    423b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    4241:	8b 45 08             	mov    0x8(%ebp),%eax
    4244:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    424b:	8b 45 08             	mov    0x8(%ebp),%eax
    424e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    4255:	8b 45 08             	mov    0x8(%ebp),%eax
    4258:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    425f:	90                   	nop
    4260:	5d                   	pop    %ebp
    4261:	c3                   	ret    

00004262 <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    4262:	55                   	push   %ebp
    4263:	89 e5                	mov    %esp,%ebp
    4265:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    4268:	8b 45 08             	mov    0x8(%ebp),%eax
    426b:	8b 00                	mov    (%eax),%eax
    426d:	83 ec 0c             	sub    $0xc,%esp
    4270:	50                   	push   %eax
    4271:	e8 ec f0 ff ff       	call   3362 <lodepng_free>
    4276:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    4279:	8b 45 08             	mov    0x8(%ebp),%eax
    427c:	8b 40 04             	mov    0x4(%eax),%eax
    427f:	83 ec 0c             	sub    $0xc,%esp
    4282:	50                   	push   %eax
    4283:	e8 da f0 ff ff       	call   3362 <lodepng_free>
    4288:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    428b:	8b 45 08             	mov    0x8(%ebp),%eax
    428e:	8b 40 10             	mov    0x10(%eax),%eax
    4291:	83 ec 0c             	sub    $0xc,%esp
    4294:	50                   	push   %eax
    4295:	e8 c8 f0 ff ff       	call   3362 <lodepng_free>
    429a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    429d:	8b 45 08             	mov    0x8(%ebp),%eax
    42a0:	8b 40 14             	mov    0x14(%eax),%eax
    42a3:	83 ec 0c             	sub    $0xc,%esp
    42a6:	50                   	push   %eax
    42a7:	e8 b6 f0 ff ff       	call   3362 <lodepng_free>
    42ac:	83 c4 10             	add    $0x10,%esp
}
    42af:	90                   	nop
    42b0:	c9                   	leave  
    42b1:	c3                   	ret    

000042b2 <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    42b2:	55                   	push   %ebp
    42b3:	89 e5                	mov    %esp,%ebp
    42b5:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    42b8:	a1 e8 b5 01 00       	mov    0x1b5e8,%eax
    42bd:	c1 e0 02             	shl    $0x2,%eax
    42c0:	83 ec 0c             	sub    $0xc,%esp
    42c3:	50                   	push   %eax
    42c4:	e8 78 f0 ff ff       	call   3341 <lodepng_malloc>
    42c9:	83 c4 10             	add    $0x10,%esp
    42cc:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    42cf:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    42d3:	75 0a                	jne    42df <HuffmanTree_makeTable+0x2d>
    42d5:	b8 53 00 00 00       	mov    $0x53,%eax
    42da:	e9 61 04 00 00       	jmp    4740 <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    42df:	a1 e8 b5 01 00       	mov    0x1b5e8,%eax
    42e4:	c1 e0 02             	shl    $0x2,%eax
    42e7:	83 ec 04             	sub    $0x4,%esp
    42ea:	50                   	push   %eax
    42eb:	6a 00                	push   $0x0
    42ed:	ff 75 dc             	pushl  -0x24(%ebp)
    42f0:	e8 bd f0 ff ff       	call   33b2 <lodepng_memset>
    42f5:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    42f8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    42ff:	eb 7d                	jmp    437e <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    4301:	8b 45 08             	mov    0x8(%ebp),%eax
    4304:	8b 00                	mov    (%eax),%eax
    4306:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4309:	c1 e2 02             	shl    $0x2,%edx
    430c:	01 d0                	add    %edx,%eax
    430e:	8b 00                	mov    (%eax),%eax
    4310:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    4313:	8b 45 08             	mov    0x8(%ebp),%eax
    4316:	8b 40 04             	mov    0x4(%eax),%eax
    4319:	8b 55 f4             	mov    -0xc(%ebp),%edx
    431c:	c1 e2 02             	shl    $0x2,%edx
    431f:	01 d0                	add    %edx,%eax
    4321:	8b 00                	mov    (%eax),%eax
    4323:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    4326:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    432a:	76 4d                	jbe    4379 <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    432c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    432f:	83 e8 09             	sub    $0x9,%eax
    4332:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4335:	89 c1                	mov    %eax,%ecx
    4337:	d3 ea                	shr    %cl,%edx
    4339:	89 d0                	mov    %edx,%eax
    433b:	83 ec 08             	sub    $0x8,%esp
    433e:	6a 09                	push   $0x9
    4340:	50                   	push   %eax
    4341:	e8 a5 fe ff ff       	call   41eb <reverseBits>
    4346:	83 c4 10             	add    $0x10,%esp
    4349:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    434c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    434f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4356:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4359:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    435c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    435f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4366:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4369:	01 d0                	add    %edx,%eax
    436b:	8b 10                	mov    (%eax),%edx
    436d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4370:	39 c2                	cmp    %eax,%edx
    4372:	0f 43 c2             	cmovae %edx,%eax
    4375:	89 01                	mov    %eax,(%ecx)
    4377:	eb 01                	jmp    437a <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    4379:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    437a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    437e:	8b 45 08             	mov    0x8(%ebp),%eax
    4381:	8b 50 0c             	mov    0xc(%eax),%edx
    4384:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4387:	39 c2                	cmp    %eax,%edx
    4389:	0f 87 72 ff ff ff    	ja     4301 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    438f:	a1 e8 b5 01 00       	mov    0x1b5e8,%eax
    4394:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    4397:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    439e:	eb 35                	jmp    43d5 <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    43a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    43a3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    43aa:	8b 45 dc             	mov    -0x24(%ebp),%eax
    43ad:	01 d0                	add    %edx,%eax
    43af:	8b 00                	mov    (%eax),%eax
    43b1:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    43b4:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    43b8:	76 17                	jbe    43d1 <HuffmanTree_makeTable+0x11f>
    43ba:	8b 45 cc             	mov    -0x34(%ebp),%eax
    43bd:	83 e8 09             	sub    $0x9,%eax
    43c0:	ba 01 00 00 00       	mov    $0x1,%edx
    43c5:	89 c1                	mov    %eax,%ecx
    43c7:	d3 e2                	shl    %cl,%edx
    43c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    43cc:	01 d0                	add    %edx,%eax
    43ce:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    43d1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    43d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    43d8:	a1 e8 b5 01 00       	mov    0x1b5e8,%eax
    43dd:	39 c2                	cmp    %eax,%edx
    43df:	72 bf                	jb     43a0 <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    43e1:	83 ec 0c             	sub    $0xc,%esp
    43e4:	ff 75 e8             	pushl  -0x18(%ebp)
    43e7:	e8 55 ef ff ff       	call   3341 <lodepng_malloc>
    43ec:	83 c4 10             	add    $0x10,%esp
    43ef:	89 c2                	mov    %eax,%edx
    43f1:	8b 45 08             	mov    0x8(%ebp),%eax
    43f4:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    43f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    43fa:	01 c0                	add    %eax,%eax
    43fc:	83 ec 0c             	sub    $0xc,%esp
    43ff:	50                   	push   %eax
    4400:	e8 3c ef ff ff       	call   3341 <lodepng_malloc>
    4405:	83 c4 10             	add    $0x10,%esp
    4408:	89 c2                	mov    %eax,%edx
    440a:	8b 45 08             	mov    0x8(%ebp),%eax
    440d:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    4410:	8b 45 08             	mov    0x8(%ebp),%eax
    4413:	8b 40 10             	mov    0x10(%eax),%eax
    4416:	85 c0                	test   %eax,%eax
    4418:	74 0a                	je     4424 <HuffmanTree_makeTable+0x172>
    441a:	8b 45 08             	mov    0x8(%ebp),%eax
    441d:	8b 40 14             	mov    0x14(%eax),%eax
    4420:	85 c0                	test   %eax,%eax
    4422:	75 18                	jne    443c <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    4424:	83 ec 0c             	sub    $0xc,%esp
    4427:	ff 75 dc             	pushl  -0x24(%ebp)
    442a:	e8 33 ef ff ff       	call   3362 <lodepng_free>
    442f:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    4432:	b8 53 00 00 00       	mov    $0x53,%eax
    4437:	e9 04 03 00 00       	jmp    4740 <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    443c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4443:	eb 12                	jmp    4457 <HuffmanTree_makeTable+0x1a5>
    4445:	8b 45 08             	mov    0x8(%ebp),%eax
    4448:	8b 50 10             	mov    0x10(%eax),%edx
    444b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    444e:	01 d0                	add    %edx,%eax
    4450:	c6 00 10             	movb   $0x10,(%eax)
    4453:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4457:	8b 45 f4             	mov    -0xc(%ebp),%eax
    445a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    445d:	7c e6                	jl     4445 <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    445f:	a1 e8 b5 01 00       	mov    0x1b5e8,%eax
    4464:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    4467:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    446e:	eb 5b                	jmp    44cb <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    4470:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4473:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    447a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    447d:	01 d0                	add    %edx,%eax
    447f:	8b 00                	mov    (%eax),%eax
    4481:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    4484:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    4488:	76 3c                	jbe    44c6 <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    448a:	8b 45 08             	mov    0x8(%ebp),%eax
    448d:	8b 50 10             	mov    0x10(%eax),%edx
    4490:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4493:	01 d0                	add    %edx,%eax
    4495:	8b 55 c8             	mov    -0x38(%ebp),%edx
    4498:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    449a:	8b 45 08             	mov    0x8(%ebp),%eax
    449d:	8b 40 14             	mov    0x14(%eax),%eax
    44a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    44a3:	01 d2                	add    %edx,%edx
    44a5:	01 d0                	add    %edx,%eax
    44a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    44aa:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    44ad:	8b 45 c8             	mov    -0x38(%ebp),%eax
    44b0:	83 e8 09             	sub    $0x9,%eax
    44b3:	ba 01 00 00 00       	mov    $0x1,%edx
    44b8:	89 c1                	mov    %eax,%ecx
    44ba:	d3 e2                	shl    %cl,%edx
    44bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    44bf:	01 d0                	add    %edx,%eax
    44c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    44c4:	eb 01                	jmp    44c7 <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    44c6:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    44c7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    44cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    44ce:	a1 e8 b5 01 00       	mov    0x1b5e8,%eax
    44d3:	39 c2                	cmp    %eax,%edx
    44d5:	72 99                	jb     4470 <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    44d7:	83 ec 0c             	sub    $0xc,%esp
    44da:	ff 75 dc             	pushl  -0x24(%ebp)
    44dd:	e8 80 ee ff ff       	call   3362 <lodepng_free>
    44e2:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    44e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    44ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    44f3:	e9 9d 01 00 00       	jmp    4695 <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    44f8:	8b 45 08             	mov    0x8(%ebp),%eax
    44fb:	8b 40 04             	mov    0x4(%eax),%eax
    44fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4501:	c1 e2 02             	shl    $0x2,%edx
    4504:	01 d0                	add    %edx,%eax
    4506:	8b 00                	mov    (%eax),%eax
    4508:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    450b:	8b 45 08             	mov    0x8(%ebp),%eax
    450e:	8b 00                	mov    (%eax),%eax
    4510:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4513:	c1 e2 02             	shl    $0x2,%edx
    4516:	01 d0                	add    %edx,%eax
    4518:	8b 00                	mov    (%eax),%eax
    451a:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    451d:	83 ec 08             	sub    $0x8,%esp
    4520:	ff 75 c4             	pushl  -0x3c(%ebp)
    4523:	ff 75 c0             	pushl  -0x40(%ebp)
    4526:	e8 c0 fc ff ff       	call   41eb <reverseBits>
    452b:	83 c4 10             	add    $0x10,%esp
    452e:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    4531:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    4535:	0f 84 55 01 00 00    	je     4690 <HuffmanTree_makeTable+0x3de>
    numpresent++;
    453b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    453f:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    4543:	0f 87 81 00 00 00    	ja     45ca <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    4549:	b8 09 00 00 00       	mov    $0x9,%eax
    454e:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    4551:	ba 01 00 00 00       	mov    $0x1,%edx
    4556:	89 c1                	mov    %eax,%ecx
    4558:	d3 e2                	shl    %cl,%edx
    455a:	89 d0                	mov    %edx,%eax
    455c:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    455f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    4566:	eb 55                	jmp    45bd <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    4568:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    456b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    456e:	89 c1                	mov    %eax,%ecx
    4570:	d3 e2                	shl    %cl,%edx
    4572:	89 d0                	mov    %edx,%eax
    4574:	0b 45 bc             	or     -0x44(%ebp),%eax
    4577:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    457a:	8b 45 08             	mov    0x8(%ebp),%eax
    457d:	8b 50 10             	mov    0x10(%eax),%edx
    4580:	8b 45 98             	mov    -0x68(%ebp),%eax
    4583:	01 d0                	add    %edx,%eax
    4585:	0f b6 00             	movzbl (%eax),%eax
    4588:	3c 10                	cmp    $0x10,%al
    458a:	74 0a                	je     4596 <HuffmanTree_makeTable+0x2e4>
    458c:	b8 37 00 00 00       	mov    $0x37,%eax
    4591:	e9 aa 01 00 00       	jmp    4740 <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    4596:	8b 45 08             	mov    0x8(%ebp),%eax
    4599:	8b 50 10             	mov    0x10(%eax),%edx
    459c:	8b 45 98             	mov    -0x68(%ebp),%eax
    459f:	01 d0                	add    %edx,%eax
    45a1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    45a4:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    45a6:	8b 45 08             	mov    0x8(%ebp),%eax
    45a9:	8b 40 14             	mov    0x14(%eax),%eax
    45ac:	8b 55 98             	mov    -0x68(%ebp),%edx
    45af:	01 d2                	add    %edx,%edx
    45b1:	01 d0                	add    %edx,%eax
    45b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    45b6:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    45b9:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    45bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    45c0:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    45c3:	72 a3                	jb     4568 <HuffmanTree_makeTable+0x2b6>
    45c5:	e9 c7 00 00 00       	jmp    4691 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    45ca:	a1 ec b5 01 00       	mov    0x1b5ec,%eax
    45cf:	23 45 bc             	and    -0x44(%ebp),%eax
    45d2:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    45d5:	8b 45 08             	mov    0x8(%ebp),%eax
    45d8:	8b 50 10             	mov    0x10(%eax),%edx
    45db:	8b 45 b8             	mov    -0x48(%ebp),%eax
    45de:	01 d0                	add    %edx,%eax
    45e0:	0f b6 00             	movzbl (%eax),%eax
    45e3:	0f b6 c0             	movzbl %al,%eax
    45e6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    45e9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    45ec:	83 e8 09             	sub    $0x9,%eax
    45ef:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    45f2:	8b 45 08             	mov    0x8(%ebp),%eax
    45f5:	8b 40 14             	mov    0x14(%eax),%eax
    45f8:	8b 55 b8             	mov    -0x48(%ebp),%edx
    45fb:	01 d2                	add    %edx,%edx
    45fd:	01 d0                	add    %edx,%eax
    45ff:	0f b7 00             	movzwl (%eax),%eax
    4602:	0f b7 c0             	movzwl %ax,%eax
    4605:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    4608:	8b 45 b0             	mov    -0x50(%ebp),%eax
    460b:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    460e:	83 c0 09             	add    $0x9,%eax
    4611:	ba 01 00 00 00       	mov    $0x1,%edx
    4616:	89 c1                	mov    %eax,%ecx
    4618:	d3 e2                	shl    %cl,%edx
    461a:	89 d0                	mov    %edx,%eax
    461c:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    461f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    4622:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    4625:	73 0a                	jae    4631 <HuffmanTree_makeTable+0x37f>
    4627:	b8 37 00 00 00       	mov    $0x37,%eax
    462c:	e9 0f 01 00 00       	jmp    4740 <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    4631:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    4638:	eb 4c                	jmp    4686 <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    463a:	8b 45 bc             	mov    -0x44(%ebp),%eax
    463d:	c1 e8 09             	shr    $0x9,%eax
    4640:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    4643:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4646:	83 e8 09             	sub    $0x9,%eax
    4649:	8b 55 e0             	mov    -0x20(%ebp),%edx
    464c:	89 c1                	mov    %eax,%ecx
    464e:	d3 e2                	shl    %cl,%edx
    4650:	89 d0                	mov    %edx,%eax
    4652:	0b 45 a4             	or     -0x5c(%ebp),%eax
    4655:	89 c2                	mov    %eax,%edx
    4657:	8b 45 ac             	mov    -0x54(%ebp),%eax
    465a:	01 d0                	add    %edx,%eax
    465c:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    465f:	8b 45 08             	mov    0x8(%ebp),%eax
    4662:	8b 50 10             	mov    0x10(%eax),%edx
    4665:	8b 45 a0             	mov    -0x60(%ebp),%eax
    4668:	01 d0                	add    %edx,%eax
    466a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    466d:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    466f:	8b 45 08             	mov    0x8(%ebp),%eax
    4672:	8b 40 14             	mov    0x14(%eax),%eax
    4675:	8b 55 a0             	mov    -0x60(%ebp),%edx
    4678:	01 d2                	add    %edx,%edx
    467a:	01 d0                	add    %edx,%eax
    467c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    467f:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    4682:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4686:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4689:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    468c:	72 ac                	jb     463a <HuffmanTree_makeTable+0x388>
    468e:	eb 01                	jmp    4691 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    4690:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    4691:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4695:	8b 45 08             	mov    0x8(%ebp),%eax
    4698:	8b 50 0c             	mov    0xc(%eax),%edx
    469b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    469e:	39 c2                	cmp    %eax,%edx
    46a0:	0f 87 52 fe ff ff    	ja     44f8 <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    46a6:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    46aa:	7f 61                	jg     470d <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    46ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    46b3:	eb 4e                	jmp    4703 <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    46b5:	8b 45 08             	mov    0x8(%ebp),%eax
    46b8:	8b 50 10             	mov    0x10(%eax),%edx
    46bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46be:	01 d0                	add    %edx,%eax
    46c0:	0f b6 00             	movzbl (%eax),%eax
    46c3:	3c 10                	cmp    $0x10,%al
    46c5:	75 38                	jne    46ff <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    46c7:	8b 45 08             	mov    0x8(%ebp),%eax
    46ca:	8b 50 10             	mov    0x10(%eax),%edx
    46cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46d0:	01 d0                	add    %edx,%eax
    46d2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    46d5:	8b 15 e8 b5 01 00    	mov    0x1b5e8,%edx
    46db:	39 d1                	cmp    %edx,%ecx
    46dd:	73 07                	jae    46e6 <HuffmanTree_makeTable+0x434>
    46df:	ba 01 00 00 00       	mov    $0x1,%edx
    46e4:	eb 05                	jmp    46eb <HuffmanTree_makeTable+0x439>
    46e6:	ba 0a 00 00 00       	mov    $0xa,%edx
    46eb:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    46ed:	8b 45 08             	mov    0x8(%ebp),%eax
    46f0:	8b 40 14             	mov    0x14(%eax),%eax
    46f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    46f6:	01 d2                	add    %edx,%edx
    46f8:	01 d0                	add    %edx,%eax
    46fa:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    46ff:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4703:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4706:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4709:	7c aa                	jl     46b5 <HuffmanTree_makeTable+0x403>
    470b:	eb 2e                	jmp    473b <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    470d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4714:	eb 1d                	jmp    4733 <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    4716:	8b 45 08             	mov    0x8(%ebp),%eax
    4719:	8b 50 10             	mov    0x10(%eax),%edx
    471c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    471f:	01 d0                	add    %edx,%eax
    4721:	0f b6 00             	movzbl (%eax),%eax
    4724:	3c 10                	cmp    $0x10,%al
    4726:	75 07                	jne    472f <HuffmanTree_makeTable+0x47d>
    4728:	b8 37 00 00 00       	mov    $0x37,%eax
    472d:	eb 11                	jmp    4740 <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    472f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4733:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4736:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4739:	7c db                	jl     4716 <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    473b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4740:	c9                   	leave  
    4741:	c3                   	ret    

00004742 <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    4742:	55                   	push   %ebp
    4743:	89 e5                	mov    %esp,%ebp
    4745:	56                   	push   %esi
    4746:	53                   	push   %ebx
    4747:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    474a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    4751:	8b 45 08             	mov    0x8(%ebp),%eax
    4754:	8b 40 0c             	mov    0xc(%eax),%eax
    4757:	c1 e0 02             	shl    $0x2,%eax
    475a:	83 ec 0c             	sub    $0xc,%esp
    475d:	50                   	push   %eax
    475e:	e8 de eb ff ff       	call   3341 <lodepng_malloc>
    4763:	83 c4 10             	add    $0x10,%esp
    4766:	89 c2                	mov    %eax,%edx
    4768:	8b 45 08             	mov    0x8(%ebp),%eax
    476b:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    476d:	8b 45 08             	mov    0x8(%ebp),%eax
    4770:	8b 40 08             	mov    0x8(%eax),%eax
    4773:	83 c0 01             	add    $0x1,%eax
    4776:	c1 e0 02             	shl    $0x2,%eax
    4779:	83 ec 0c             	sub    $0xc,%esp
    477c:	50                   	push   %eax
    477d:	e8 bf eb ff ff       	call   3341 <lodepng_malloc>
    4782:	83 c4 10             	add    $0x10,%esp
    4785:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4788:	8b 45 08             	mov    0x8(%ebp),%eax
    478b:	8b 40 08             	mov    0x8(%eax),%eax
    478e:	83 c0 01             	add    $0x1,%eax
    4791:	c1 e0 02             	shl    $0x2,%eax
    4794:	83 ec 0c             	sub    $0xc,%esp
    4797:	50                   	push   %eax
    4798:	e8 a4 eb ff ff       	call   3341 <lodepng_malloc>
    479d:	83 c4 10             	add    $0x10,%esp
    47a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    47a3:	8b 45 08             	mov    0x8(%ebp),%eax
    47a6:	8b 00                	mov    (%eax),%eax
    47a8:	85 c0                	test   %eax,%eax
    47aa:	74 0c                	je     47b8 <HuffmanTree_makeFromLengths2+0x76>
    47ac:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    47b0:	74 06                	je     47b8 <HuffmanTree_makeFromLengths2+0x76>
    47b2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    47b6:	75 07                	jne    47bf <HuffmanTree_makeFromLengths2+0x7d>
    47b8:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    47bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    47c3:	0f 85 7d 01 00 00    	jne    4946 <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    47c9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    47d0:	eb 2c                	jmp    47fe <HuffmanTree_makeFromLengths2+0xbc>
    47d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    47d5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    47dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    47df:	01 c2                	add    %eax,%edx
    47e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    47e4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    47eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    47ee:	01 c8                	add    %ecx,%eax
    47f0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    47f6:	8b 00                	mov    (%eax),%eax
    47f8:	89 02                	mov    %eax,(%edx)
    47fa:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    47fe:	8b 45 08             	mov    0x8(%ebp),%eax
    4801:	8b 40 08             	mov    0x8(%eax),%eax
    4804:	83 c0 01             	add    $0x1,%eax
    4807:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    480a:	75 c6                	jne    47d2 <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    480c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4813:	eb 27                	jmp    483c <HuffmanTree_makeFromLengths2+0xfa>
    4815:	8b 45 08             	mov    0x8(%ebp),%eax
    4818:	8b 40 04             	mov    0x4(%eax),%eax
    481b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    481e:	c1 e2 02             	shl    $0x2,%edx
    4821:	01 d0                	add    %edx,%eax
    4823:	8b 00                	mov    (%eax),%eax
    4825:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    482c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    482f:	01 d0                	add    %edx,%eax
    4831:	8b 10                	mov    (%eax),%edx
    4833:	83 c2 01             	add    $0x1,%edx
    4836:	89 10                	mov    %edx,(%eax)
    4838:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    483c:	8b 45 08             	mov    0x8(%ebp),%eax
    483f:	8b 40 0c             	mov    0xc(%eax),%eax
    4842:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4845:	75 ce                	jne    4815 <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4847:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    484e:	eb 47                	jmp    4897 <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    4850:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4853:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    485a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    485d:	01 d0                	add    %edx,%eax
    485f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4862:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4868:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    486f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4872:	01 ca                	add    %ecx,%edx
    4874:	8b 0a                	mov    (%edx),%ecx
    4876:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4879:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    487f:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    4886:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4889:	01 da                	add    %ebx,%edx
    488b:	8b 12                	mov    (%edx),%edx
    488d:	01 ca                	add    %ecx,%edx
    488f:	01 d2                	add    %edx,%edx
    4891:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4893:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4897:	8b 45 08             	mov    0x8(%ebp),%eax
    489a:	8b 40 08             	mov    0x8(%eax),%eax
    489d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    48a0:	73 ae                	jae    4850 <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    48a2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    48a9:	e9 89 00 00 00       	jmp    4937 <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    48ae:	8b 45 08             	mov    0x8(%ebp),%eax
    48b1:	8b 40 04             	mov    0x4(%eax),%eax
    48b4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    48b7:	c1 e2 02             	shl    $0x2,%edx
    48ba:	01 d0                	add    %edx,%eax
    48bc:	8b 00                	mov    (%eax),%eax
    48be:	85 c0                	test   %eax,%eax
    48c0:	74 71                	je     4933 <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    48c2:	8b 45 08             	mov    0x8(%ebp),%eax
    48c5:	8b 00                	mov    (%eax),%eax
    48c7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    48ca:	c1 e2 02             	shl    $0x2,%edx
    48cd:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    48d0:	8b 45 08             	mov    0x8(%ebp),%eax
    48d3:	8b 40 04             	mov    0x4(%eax),%eax
    48d6:	8b 55 ec             	mov    -0x14(%ebp),%edx
    48d9:	c1 e2 02             	shl    $0x2,%edx
    48dc:	01 d0                	add    %edx,%eax
    48de:	8b 00                	mov    (%eax),%eax
    48e0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    48e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    48ea:	01 c2                	add    %eax,%edx
    48ec:	8b 02                	mov    (%edx),%eax
    48ee:	8d 48 01             	lea    0x1(%eax),%ecx
    48f1:	89 0a                	mov    %ecx,(%edx)
    48f3:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    48f5:	8b 45 08             	mov    0x8(%ebp),%eax
    48f8:	8b 00                	mov    (%eax),%eax
    48fa:	8b 55 ec             	mov    -0x14(%ebp),%edx
    48fd:	c1 e2 02             	shl    $0x2,%edx
    4900:	01 c2                	add    %eax,%edx
    4902:	8b 45 08             	mov    0x8(%ebp),%eax
    4905:	8b 00                	mov    (%eax),%eax
    4907:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    490a:	c1 e1 02             	shl    $0x2,%ecx
    490d:	01 c8                	add    %ecx,%eax
    490f:	8b 18                	mov    (%eax),%ebx
    4911:	8b 45 08             	mov    0x8(%ebp),%eax
    4914:	8b 40 04             	mov    0x4(%eax),%eax
    4917:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    491a:	c1 e1 02             	shl    $0x2,%ecx
    491d:	01 c8                	add    %ecx,%eax
    491f:	8b 00                	mov    (%eax),%eax
    4921:	be 01 00 00 00       	mov    $0x1,%esi
    4926:	89 c1                	mov    %eax,%ecx
    4928:	d3 e6                	shl    %cl,%esi
    492a:	89 f0                	mov    %esi,%eax
    492c:	83 e8 01             	sub    $0x1,%eax
    492f:	21 d8                	and    %ebx,%eax
    4931:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4933:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    4937:	8b 45 08             	mov    0x8(%ebp),%eax
    493a:	8b 40 0c             	mov    0xc(%eax),%eax
    493d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4940:	0f 85 68 ff ff ff    	jne    48ae <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    4946:	83 ec 0c             	sub    $0xc,%esp
    4949:	ff 75 e8             	pushl  -0x18(%ebp)
    494c:	e8 11 ea ff ff       	call   3362 <lodepng_free>
    4951:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    4954:	83 ec 0c             	sub    $0xc,%esp
    4957:	ff 75 e4             	pushl  -0x1c(%ebp)
    495a:	e8 03 ea ff ff       	call   3362 <lodepng_free>
    495f:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    4962:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4966:	75 11                	jne    4979 <HuffmanTree_makeFromLengths2+0x237>
    4968:	83 ec 0c             	sub    $0xc,%esp
    496b:	ff 75 08             	pushl  0x8(%ebp)
    496e:	e8 3f f9 ff ff       	call   42b2 <HuffmanTree_makeTable>
    4973:	83 c4 10             	add    $0x10,%esp
    4976:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    4979:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    497c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    497f:	5b                   	pop    %ebx
    4980:	5e                   	pop    %esi
    4981:	5d                   	pop    %ebp
    4982:	c3                   	ret    

00004983 <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    4983:	55                   	push   %ebp
    4984:	89 e5                	mov    %esp,%ebp
    4986:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    4989:	8b 45 10             	mov    0x10(%ebp),%eax
    498c:	c1 e0 02             	shl    $0x2,%eax
    498f:	83 ec 0c             	sub    $0xc,%esp
    4992:	50                   	push   %eax
    4993:	e8 a9 e9 ff ff       	call   3341 <lodepng_malloc>
    4998:	83 c4 10             	add    $0x10,%esp
    499b:	89 c2                	mov    %eax,%edx
    499d:	8b 45 08             	mov    0x8(%ebp),%eax
    49a0:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    49a3:	8b 45 08             	mov    0x8(%ebp),%eax
    49a6:	8b 40 04             	mov    0x4(%eax),%eax
    49a9:	85 c0                	test   %eax,%eax
    49ab:	75 07                	jne    49b4 <HuffmanTree_makeFromLengths+0x31>
    49ad:	b8 53 00 00 00       	mov    $0x53,%eax
    49b2:	eb 56                	jmp    4a0a <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    49b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    49bb:	eb 25                	jmp    49e2 <HuffmanTree_makeFromLengths+0x5f>
    49bd:	8b 45 08             	mov    0x8(%ebp),%eax
    49c0:	8b 40 04             	mov    0x4(%eax),%eax
    49c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    49c6:	c1 e2 02             	shl    $0x2,%edx
    49c9:	01 c2                	add    %eax,%edx
    49cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49ce:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    49d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    49d8:	01 c8                	add    %ecx,%eax
    49da:	8b 00                	mov    (%eax),%eax
    49dc:	89 02                	mov    %eax,(%edx)
    49de:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    49e2:	8b 45 10             	mov    0x10(%ebp),%eax
    49e5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    49e8:	75 d3                	jne    49bd <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    49ea:	8b 55 10             	mov    0x10(%ebp),%edx
    49ed:	8b 45 08             	mov    0x8(%ebp),%eax
    49f0:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    49f3:	8b 45 08             	mov    0x8(%ebp),%eax
    49f6:	8b 55 14             	mov    0x14(%ebp),%edx
    49f9:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    49fc:	83 ec 0c             	sub    $0xc,%esp
    49ff:	ff 75 08             	pushl  0x8(%ebp)
    4a02:	e8 3b fd ff ff       	call   4742 <HuffmanTree_makeFromLengths2>
    4a07:	83 c4 10             	add    $0x10,%esp
}
    4a0a:	c9                   	leave  
    4a0b:	c3                   	ret    

00004a0c <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    4a0c:	55                   	push   %ebp
    4a0d:	89 e5                	mov    %esp,%ebp
    4a0f:	53                   	push   %ebx
    4a10:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    4a13:	8b 45 08             	mov    0x8(%ebp),%eax
    4a16:	8b 50 0c             	mov    0xc(%eax),%edx
    4a19:	8b 45 08             	mov    0x8(%ebp),%eax
    4a1c:	8b 40 08             	mov    0x8(%eax),%eax
    4a1f:	39 c2                	cmp    %eax,%edx
    4a21:	0f 82 0b 01 00 00    	jb     4b32 <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    4a27:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4a2e:	eb 19                	jmp    4a49 <bpmnode_create+0x3d>
    4a30:	8b 45 08             	mov    0x8(%ebp),%eax
    4a33:	8b 40 04             	mov    0x4(%eax),%eax
    4a36:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a39:	c1 e2 04             	shl    $0x4,%edx
    4a3c:	01 d0                	add    %edx,%eax
    4a3e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    4a45:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4a49:	8b 45 08             	mov    0x8(%ebp),%eax
    4a4c:	8b 00                	mov    (%eax),%eax
    4a4e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4a51:	75 dd                	jne    4a30 <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    4a53:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4a5a:	eb 60                	jmp    4abc <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    4a5c:	8b 45 08             	mov    0x8(%ebp),%eax
    4a5f:	8b 40 18             	mov    0x18(%eax),%eax
    4a62:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a65:	c1 e2 02             	shl    $0x2,%edx
    4a68:	01 d0                	add    %edx,%eax
    4a6a:	8b 00                	mov    (%eax),%eax
    4a6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a6f:	eb 13                	jmp    4a84 <bpmnode_create+0x78>
    4a71:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a74:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4a7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a7e:	8b 40 08             	mov    0x8(%eax),%eax
    4a81:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a88:	75 e7                	jne    4a71 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    4a8a:	8b 45 08             	mov    0x8(%ebp),%eax
    4a8d:	8b 40 1c             	mov    0x1c(%eax),%eax
    4a90:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a93:	c1 e2 02             	shl    $0x2,%edx
    4a96:	01 d0                	add    %edx,%eax
    4a98:	8b 00                	mov    (%eax),%eax
    4a9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a9d:	eb 13                	jmp    4ab2 <bpmnode_create+0xa6>
    4a9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4aa2:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4aa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4aac:	8b 40 08             	mov    0x8(%eax),%eax
    4aaf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4ab2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4ab6:	75 e7                	jne    4a9f <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    4ab8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4abc:	8b 45 08             	mov    0x8(%ebp),%eax
    4abf:	8b 40 14             	mov    0x14(%eax),%eax
    4ac2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4ac5:	75 95                	jne    4a5c <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    4ac7:	8b 45 08             	mov    0x8(%ebp),%eax
    4aca:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    4ad1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4ad8:	eb 44                	jmp    4b1e <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    4ada:	8b 45 08             	mov    0x8(%ebp),%eax
    4add:	8b 40 04             	mov    0x4(%eax),%eax
    4ae0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4ae3:	c1 e2 04             	shl    $0x4,%edx
    4ae6:	01 d0                	add    %edx,%eax
    4ae8:	8b 40 0c             	mov    0xc(%eax),%eax
    4aeb:	85 c0                	test   %eax,%eax
    4aed:	75 2b                	jne    4b1a <bpmnode_create+0x10e>
    4aef:	8b 45 08             	mov    0x8(%ebp),%eax
    4af2:	8b 58 10             	mov    0x10(%eax),%ebx
    4af5:	8b 45 08             	mov    0x8(%ebp),%eax
    4af8:	8b 40 08             	mov    0x8(%eax),%eax
    4afb:	8d 48 01             	lea    0x1(%eax),%ecx
    4afe:	8b 55 08             	mov    0x8(%ebp),%edx
    4b01:	89 4a 08             	mov    %ecx,0x8(%edx)
    4b04:	c1 e0 02             	shl    $0x2,%eax
    4b07:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4b0a:	8b 45 08             	mov    0x8(%ebp),%eax
    4b0d:	8b 40 04             	mov    0x4(%eax),%eax
    4b10:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4b13:	c1 e1 04             	shl    $0x4,%ecx
    4b16:	01 c8                	add    %ecx,%eax
    4b18:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    4b1a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4b1e:	8b 45 08             	mov    0x8(%ebp),%eax
    4b21:	8b 00                	mov    (%eax),%eax
    4b23:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4b26:	75 b2                	jne    4ada <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    4b28:	8b 45 08             	mov    0x8(%ebp),%eax
    4b2b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    4b32:	8b 45 08             	mov    0x8(%ebp),%eax
    4b35:	8b 58 10             	mov    0x10(%eax),%ebx
    4b38:	8b 45 08             	mov    0x8(%ebp),%eax
    4b3b:	8b 40 0c             	mov    0xc(%eax),%eax
    4b3e:	8d 48 01             	lea    0x1(%eax),%ecx
    4b41:	8b 55 08             	mov    0x8(%ebp),%edx
    4b44:	89 4a 0c             	mov    %ecx,0xc(%edx)
    4b47:	c1 e0 02             	shl    $0x2,%eax
    4b4a:	01 d8                	add    %ebx,%eax
    4b4c:	8b 00                	mov    (%eax),%eax
    4b4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    4b51:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b54:	8b 55 0c             	mov    0xc(%ebp),%edx
    4b57:	89 10                	mov    %edx,(%eax)
  result->index = index;
    4b59:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b5c:	8b 55 10             	mov    0x10(%ebp),%edx
    4b5f:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    4b62:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b65:	8b 55 14             	mov    0x14(%ebp),%edx
    4b68:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    4b6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    4b6e:	83 c4 10             	add    $0x10,%esp
    4b71:	5b                   	pop    %ebx
    4b72:	5d                   	pop    %ebp
    4b73:	c3                   	ret    

00004b74 <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    4b74:	55                   	push   %ebp
    4b75:	89 e5                	mov    %esp,%ebp
    4b77:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    4b7a:	8b 45 0c             	mov    0xc(%ebp),%eax
    4b7d:	c1 e0 04             	shl    $0x4,%eax
    4b80:	83 ec 0c             	sub    $0xc,%esp
    4b83:	50                   	push   %eax
    4b84:	e8 b8 e7 ff ff       	call   3341 <lodepng_malloc>
    4b89:	83 c4 10             	add    $0x10,%esp
    4b8c:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    4b8f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    4b96:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    4b9d:	e9 41 01 00 00       	jmp    4ce3 <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    4ba2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4ba5:	83 e0 01             	and    $0x1,%eax
    4ba8:	85 c0                	test   %eax,%eax
    4baa:	74 05                	je     4bb1 <bpmnode_sort+0x3d>
    4bac:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4baf:	eb 03                	jmp    4bb4 <bpmnode_sort+0x40>
    4bb1:	8b 45 08             	mov    0x8(%ebp),%eax
    4bb4:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    4bb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4bba:	83 e0 01             	and    $0x1,%eax
    4bbd:	85 c0                	test   %eax,%eax
    4bbf:	74 05                	je     4bc6 <bpmnode_sort+0x52>
    4bc1:	8b 45 08             	mov    0x8(%ebp),%eax
    4bc4:	eb 03                	jmp    4bc9 <bpmnode_sort+0x55>
    4bc6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4bc9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4bcc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4bd3:	e9 f8 00 00 00       	jmp    4cd0 <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    4bd8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4bdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4bde:	01 c2                	add    %eax,%edx
    4be0:	8b 45 0c             	mov    0xc(%ebp),%eax
    4be3:	39 c2                	cmp    %eax,%edx
    4be5:	0f 4e c2             	cmovle %edx,%eax
    4be8:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    4beb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4bee:	8d 14 00             	lea    (%eax,%eax,1),%edx
    4bf1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4bf4:	01 c2                	add    %eax,%edx
    4bf6:	8b 45 0c             	mov    0xc(%ebp),%eax
    4bf9:	39 c2                	cmp    %eax,%edx
    4bfb:	0f 4e c2             	cmovle %edx,%eax
    4bfe:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    4c01:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4c04:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4c07:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4c0a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    4c0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4c10:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4c13:	e9 a4 00 00 00       	jmp    4cbc <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    4c18:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4c1b:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    4c1e:	7d 62                	jge    4c82 <bpmnode_sort+0x10e>
    4c20:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c23:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4c26:	7d 22                	jge    4c4a <bpmnode_sort+0xd6>
    4c28:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4c2b:	c1 e0 04             	shl    $0x4,%eax
    4c2e:	89 c2                	mov    %eax,%edx
    4c30:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4c33:	01 d0                	add    %edx,%eax
    4c35:	8b 10                	mov    (%eax),%edx
    4c37:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c3a:	c1 e0 04             	shl    $0x4,%eax
    4c3d:	89 c1                	mov    %eax,%ecx
    4c3f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4c42:	01 c8                	add    %ecx,%eax
    4c44:	8b 00                	mov    (%eax),%eax
    4c46:	39 c2                	cmp    %eax,%edx
    4c48:	7f 38                	jg     4c82 <bpmnode_sort+0x10e>
    4c4a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4c4d:	c1 e0 04             	shl    $0x4,%eax
    4c50:	89 c2                	mov    %eax,%edx
    4c52:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4c55:	01 d0                	add    %edx,%eax
    4c57:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4c5a:	8d 4a 01             	lea    0x1(%edx),%ecx
    4c5d:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    4c60:	89 d1                	mov    %edx,%ecx
    4c62:	c1 e1 04             	shl    $0x4,%ecx
    4c65:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4c68:	01 ca                	add    %ecx,%edx
    4c6a:	8b 0a                	mov    (%edx),%ecx
    4c6c:	89 08                	mov    %ecx,(%eax)
    4c6e:	8b 4a 04             	mov    0x4(%edx),%ecx
    4c71:	89 48 04             	mov    %ecx,0x4(%eax)
    4c74:	8b 4a 08             	mov    0x8(%edx),%ecx
    4c77:	89 48 08             	mov    %ecx,0x8(%eax)
    4c7a:	8b 52 0c             	mov    0xc(%edx),%edx
    4c7d:	89 50 0c             	mov    %edx,0xc(%eax)
    4c80:	eb 36                	jmp    4cb8 <bpmnode_sort+0x144>
        else b[k] = a[j++];
    4c82:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4c85:	c1 e0 04             	shl    $0x4,%eax
    4c88:	89 c2                	mov    %eax,%edx
    4c8a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4c8d:	01 d0                	add    %edx,%eax
    4c8f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4c92:	8d 4a 01             	lea    0x1(%edx),%ecx
    4c95:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    4c98:	89 d1                	mov    %edx,%ecx
    4c9a:	c1 e1 04             	shl    $0x4,%ecx
    4c9d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4ca0:	01 ca                	add    %ecx,%edx
    4ca2:	8b 0a                	mov    (%edx),%ecx
    4ca4:	89 08                	mov    %ecx,(%eax)
    4ca6:	8b 4a 04             	mov    0x4(%edx),%ecx
    4ca9:	89 48 04             	mov    %ecx,0x4(%eax)
    4cac:	8b 4a 08             	mov    0x8(%edx),%ecx
    4caf:	89 48 08             	mov    %ecx,0x8(%eax)
    4cb2:	8b 52 0c             	mov    0xc(%edx),%edx
    4cb5:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    4cb8:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4cbc:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4cbf:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4cc2:	0f 8c 50 ff ff ff    	jl     4c18 <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4cc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4ccb:	01 c0                	add    %eax,%eax
    4ccd:	01 45 ec             	add    %eax,-0x14(%ebp)
    4cd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4cd3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4cd6:	0f 8c fc fe ff ff    	jl     4bd8 <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    4cdc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    4ce0:	d1 65 f4             	shll   -0xc(%ebp)
    4ce3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4ce6:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4ce9:	0f 8c b3 fe ff ff    	jl     4ba2 <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    4cef:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4cf2:	83 e0 01             	and    $0x1,%eax
    4cf5:	85 c0                	test   %eax,%eax
    4cf7:	74 18                	je     4d11 <bpmnode_sort+0x19d>
    4cf9:	8b 45 0c             	mov    0xc(%ebp),%eax
    4cfc:	c1 e0 04             	shl    $0x4,%eax
    4cff:	83 ec 04             	sub    $0x4,%esp
    4d02:	50                   	push   %eax
    4d03:	ff 75 dc             	pushl  -0x24(%ebp)
    4d06:	ff 75 08             	pushl  0x8(%ebp)
    4d09:	e8 71 e6 ff ff       	call   337f <lodepng_memcpy>
    4d0e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    4d11:	83 ec 0c             	sub    $0xc,%esp
    4d14:	ff 75 dc             	pushl  -0x24(%ebp)
    4d17:	e8 46 e6 ff ff       	call   3362 <lodepng_free>
    4d1c:	83 c4 10             	add    $0x10,%esp
}
    4d1f:	90                   	nop
    4d20:	c9                   	leave  
    4d21:	c3                   	ret    

00004d22 <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    4d22:	55                   	push   %ebp
    4d23:	89 e5                	mov    %esp,%ebp
    4d25:	56                   	push   %esi
    4d26:	53                   	push   %ebx
    4d27:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    4d2a:	8b 45 08             	mov    0x8(%ebp),%eax
    4d2d:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d30:	8b 55 14             	mov    0x14(%ebp),%edx
    4d33:	c1 e2 02             	shl    $0x2,%edx
    4d36:	01 d0                	add    %edx,%eax
    4d38:	8b 00                	mov    (%eax),%eax
    4d3a:	8b 40 04             	mov    0x4(%eax),%eax
    4d3d:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    4d40:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    4d44:	75 66                	jne    4dac <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    4d46:	8b 45 10             	mov    0x10(%ebp),%eax
    4d49:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4d4c:	0f 83 a0 01 00 00    	jae    4ef2 <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    4d52:	8b 45 08             	mov    0x8(%ebp),%eax
    4d55:	8b 40 18             	mov    0x18(%eax),%eax
    4d58:	8b 55 14             	mov    0x14(%ebp),%edx
    4d5b:	c1 e2 02             	shl    $0x2,%edx
    4d5e:	01 c2                	add    %eax,%edx
    4d60:	8b 45 08             	mov    0x8(%ebp),%eax
    4d63:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d66:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4d69:	c1 e1 02             	shl    $0x2,%ecx
    4d6c:	01 c8                	add    %ecx,%eax
    4d6e:	8b 00                	mov    (%eax),%eax
    4d70:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    4d72:	8b 45 08             	mov    0x8(%ebp),%eax
    4d75:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d78:	8b 55 14             	mov    0x14(%ebp),%edx
    4d7b:	c1 e2 02             	shl    $0x2,%edx
    4d7e:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4d81:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d84:	8d 50 01             	lea    0x1(%eax),%edx
    4d87:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d8a:	c1 e0 04             	shl    $0x4,%eax
    4d8d:	89 c1                	mov    %eax,%ecx
    4d8f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d92:	01 c8                	add    %ecx,%eax
    4d94:	8b 00                	mov    (%eax),%eax
    4d96:	6a 00                	push   $0x0
    4d98:	52                   	push   %edx
    4d99:	50                   	push   %eax
    4d9a:	ff 75 08             	pushl  0x8(%ebp)
    4d9d:	e8 6a fc ff ff       	call   4a0c <bpmnode_create>
    4da2:	83 c4 10             	add    $0x10,%esp
    4da5:	89 03                	mov    %eax,(%ebx)
    4da7:	e9 47 01 00 00       	jmp    4ef3 <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    4dac:	8b 45 08             	mov    0x8(%ebp),%eax
    4daf:	8b 40 18             	mov    0x18(%eax),%eax
    4db2:	8b 55 14             	mov    0x14(%ebp),%edx
    4db5:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4dbb:	c1 e2 02             	shl    $0x2,%edx
    4dbe:	01 d0                	add    %edx,%eax
    4dc0:	8b 00                	mov    (%eax),%eax
    4dc2:	8b 10                	mov    (%eax),%edx
    4dc4:	8b 45 08             	mov    0x8(%ebp),%eax
    4dc7:	8b 40 1c             	mov    0x1c(%eax),%eax
    4dca:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4dcd:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    4dd3:	c1 e1 02             	shl    $0x2,%ecx
    4dd6:	01 c8                	add    %ecx,%eax
    4dd8:	8b 00                	mov    (%eax),%eax
    4dda:	8b 00                	mov    (%eax),%eax
    4ddc:	01 d0                	add    %edx,%eax
    4dde:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    4de1:	8b 45 08             	mov    0x8(%ebp),%eax
    4de4:	8b 40 18             	mov    0x18(%eax),%eax
    4de7:	8b 55 14             	mov    0x14(%ebp),%edx
    4dea:	c1 e2 02             	shl    $0x2,%edx
    4ded:	01 c2                	add    %eax,%edx
    4def:	8b 45 08             	mov    0x8(%ebp),%eax
    4df2:	8b 40 1c             	mov    0x1c(%eax),%eax
    4df5:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4df8:	c1 e1 02             	shl    $0x2,%ecx
    4dfb:	01 c8                	add    %ecx,%eax
    4dfd:	8b 00                	mov    (%eax),%eax
    4dff:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    4e01:	8b 45 10             	mov    0x10(%ebp),%eax
    4e04:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4e07:	73 60                	jae    4e69 <boundaryPM+0x147>
    4e09:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e0c:	c1 e0 04             	shl    $0x4,%eax
    4e0f:	89 c2                	mov    %eax,%edx
    4e11:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e14:	01 d0                	add    %edx,%eax
    4e16:	8b 00                	mov    (%eax),%eax
    4e18:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4e1b:	7d 4c                	jge    4e69 <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    4e1d:	8b 45 08             	mov    0x8(%ebp),%eax
    4e20:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e23:	8b 55 14             	mov    0x14(%ebp),%edx
    4e26:	c1 e2 02             	shl    $0x2,%edx
    4e29:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4e2c:	8b 45 08             	mov    0x8(%ebp),%eax
    4e2f:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e32:	8b 55 14             	mov    0x14(%ebp),%edx
    4e35:	c1 e2 02             	shl    $0x2,%edx
    4e38:	01 d0                	add    %edx,%eax
    4e3a:	8b 00                	mov    (%eax),%eax
    4e3c:	8b 50 08             	mov    0x8(%eax),%edx
    4e3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e42:	8d 48 01             	lea    0x1(%eax),%ecx
    4e45:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e48:	c1 e0 04             	shl    $0x4,%eax
    4e4b:	89 c6                	mov    %eax,%esi
    4e4d:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e50:	01 f0                	add    %esi,%eax
    4e52:	8b 00                	mov    (%eax),%eax
    4e54:	52                   	push   %edx
    4e55:	51                   	push   %ecx
    4e56:	50                   	push   %eax
    4e57:	ff 75 08             	pushl  0x8(%ebp)
    4e5a:	e8 ad fb ff ff       	call   4a0c <bpmnode_create>
    4e5f:	83 c4 10             	add    $0x10,%esp
    4e62:	89 03                	mov    %eax,(%ebx)
      return;
    4e64:	e9 8a 00 00 00       	jmp    4ef3 <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    4e69:	8b 45 08             	mov    0x8(%ebp),%eax
    4e6c:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e6f:	8b 55 14             	mov    0x14(%ebp),%edx
    4e72:	c1 e2 02             	shl    $0x2,%edx
    4e75:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4e78:	8b 45 08             	mov    0x8(%ebp),%eax
    4e7b:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e7e:	8b 55 14             	mov    0x14(%ebp),%edx
    4e81:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4e87:	c1 e2 02             	shl    $0x2,%edx
    4e8a:	01 d0                	add    %edx,%eax
    4e8c:	8b 00                	mov    (%eax),%eax
    4e8e:	50                   	push   %eax
    4e8f:	ff 75 f4             	pushl  -0xc(%ebp)
    4e92:	ff 75 f0             	pushl  -0x10(%ebp)
    4e95:	ff 75 08             	pushl  0x8(%ebp)
    4e98:	e8 6f fb ff ff       	call   4a0c <bpmnode_create>
    4e9d:	83 c4 10             	add    $0x10,%esp
    4ea0:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    4ea2:	8b 45 18             	mov    0x18(%ebp),%eax
    4ea5:	8d 50 01             	lea    0x1(%eax),%edx
    4ea8:	8b 45 10             	mov    0x10(%ebp),%eax
    4eab:	83 e8 01             	sub    $0x1,%eax
    4eae:	01 c0                	add    %eax,%eax
    4eb0:	39 c2                	cmp    %eax,%edx
    4eb2:	7d 3f                	jge    4ef3 <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4eb4:	8b 45 14             	mov    0x14(%ebp),%eax
    4eb7:	83 e8 01             	sub    $0x1,%eax
    4eba:	83 ec 0c             	sub    $0xc,%esp
    4ebd:	ff 75 18             	pushl  0x18(%ebp)
    4ec0:	50                   	push   %eax
    4ec1:	ff 75 10             	pushl  0x10(%ebp)
    4ec4:	ff 75 0c             	pushl  0xc(%ebp)
    4ec7:	ff 75 08             	pushl  0x8(%ebp)
    4eca:	e8 53 fe ff ff       	call   4d22 <boundaryPM>
    4ecf:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4ed2:	8b 45 14             	mov    0x14(%ebp),%eax
    4ed5:	83 e8 01             	sub    $0x1,%eax
    4ed8:	83 ec 0c             	sub    $0xc,%esp
    4edb:	ff 75 18             	pushl  0x18(%ebp)
    4ede:	50                   	push   %eax
    4edf:	ff 75 10             	pushl  0x10(%ebp)
    4ee2:	ff 75 0c             	pushl  0xc(%ebp)
    4ee5:	ff 75 08             	pushl  0x8(%ebp)
    4ee8:	e8 35 fe ff ff       	call   4d22 <boundaryPM>
    4eed:	83 c4 20             	add    $0x20,%esp
    4ef0:	eb 01                	jmp    4ef3 <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    4ef2:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    4ef3:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4ef6:	5b                   	pop    %ebx
    4ef7:	5e                   	pop    %esi
    4ef8:	5d                   	pop    %ebp
    4ef9:	c3                   	ret    

00004efa <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    4efa:	55                   	push   %ebp
    4efb:	89 e5                	mov    %esp,%ebp
    4efd:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    4f00:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    4f07:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    4f0e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    4f12:	75 0a                	jne    4f1e <lodepng_huffman_code_lengths+0x24>
    4f14:	b8 50 00 00 00       	mov    $0x50,%eax
    4f19:	e9 4d 03 00 00       	jmp    526b <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    4f1e:	8b 45 14             	mov    0x14(%ebp),%eax
    4f21:	ba 01 00 00 00       	mov    $0x1,%edx
    4f26:	89 c1                	mov    %eax,%ecx
    4f28:	d3 e2                	shl    %cl,%edx
    4f2a:	8b 45 10             	mov    0x10(%ebp),%eax
    4f2d:	39 c2                	cmp    %eax,%edx
    4f2f:	73 0a                	jae    4f3b <lodepng_huffman_code_lengths+0x41>
    4f31:	b8 50 00 00 00       	mov    $0x50,%eax
    4f36:	e9 30 03 00 00       	jmp    526b <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    4f3b:	8b 45 10             	mov    0x10(%ebp),%eax
    4f3e:	c1 e0 04             	shl    $0x4,%eax
    4f41:	83 ec 0c             	sub    $0xc,%esp
    4f44:	50                   	push   %eax
    4f45:	e8 f7 e3 ff ff       	call   3341 <lodepng_malloc>
    4f4a:	83 c4 10             	add    $0x10,%esp
    4f4d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    4f50:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4f54:	75 0a                	jne    4f60 <lodepng_huffman_code_lengths+0x66>
    4f56:	b8 53 00 00 00       	mov    $0x53,%eax
    4f5b:	e9 0b 03 00 00       	jmp    526b <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    4f60:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4f67:	eb 50                	jmp    4fb9 <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    4f69:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f6c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4f73:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f76:	01 d0                	add    %edx,%eax
    4f78:	8b 00                	mov    (%eax),%eax
    4f7a:	85 c0                	test   %eax,%eax
    4f7c:	74 37                	je     4fb5 <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    4f7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f81:	c1 e0 04             	shl    $0x4,%eax
    4f84:	89 c2                	mov    %eax,%edx
    4f86:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4f89:	01 d0                	add    %edx,%eax
    4f8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4f8e:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4f95:	8b 55 0c             	mov    0xc(%ebp),%edx
    4f98:	01 ca                	add    %ecx,%edx
    4f9a:	8b 12                	mov    (%edx),%edx
    4f9c:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    4f9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4fa1:	c1 e0 04             	shl    $0x4,%eax
    4fa4:	89 c2                	mov    %eax,%edx
    4fa6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4fa9:	01 c2                	add    %eax,%edx
    4fab:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4fae:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    4fb1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    4fb5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4fb9:	8b 45 10             	mov    0x10(%ebp),%eax
    4fbc:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    4fbf:	75 a8                	jne    4f69 <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    4fc1:	8b 45 10             	mov    0x10(%ebp),%eax
    4fc4:	c1 e0 02             	shl    $0x2,%eax
    4fc7:	83 ec 04             	sub    $0x4,%esp
    4fca:	50                   	push   %eax
    4fcb:	6a 00                	push   $0x0
    4fcd:	ff 75 08             	pushl  0x8(%ebp)
    4fd0:	e8 dd e3 ff ff       	call   33b2 <lodepng_memset>
    4fd5:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    4fd8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    4fdc:	75 18                	jne    4ff6 <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    4fde:	8b 45 08             	mov    0x8(%ebp),%eax
    4fe1:	83 c0 04             	add    $0x4,%eax
    4fe4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    4fea:	8b 10                	mov    (%eax),%edx
    4fec:	8b 45 08             	mov    0x8(%ebp),%eax
    4fef:	89 10                	mov    %edx,(%eax)
    4ff1:	e9 64 02 00 00       	jmp    525a <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    4ff6:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    4ffa:	75 3e                	jne    503a <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    4ffc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4fff:	8b 40 04             	mov    0x4(%eax),%eax
    5002:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5009:	8b 45 08             	mov    0x8(%ebp),%eax
    500c:	01 d0                	add    %edx,%eax
    500e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    5014:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5017:	8b 40 04             	mov    0x4(%eax),%eax
    501a:	85 c0                	test   %eax,%eax
    501c:	75 07                	jne    5025 <lodepng_huffman_code_lengths+0x12b>
    501e:	ba 04 00 00 00       	mov    $0x4,%edx
    5023:	eb 05                	jmp    502a <lodepng_huffman_code_lengths+0x130>
    5025:	ba 00 00 00 00       	mov    $0x0,%edx
    502a:	8b 45 08             	mov    0x8(%ebp),%eax
    502d:	01 d0                	add    %edx,%eax
    502f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    5035:	e9 20 02 00 00       	jmp    525a <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    503a:	83 ec 08             	sub    $0x8,%esp
    503d:	ff 75 ec             	pushl  -0x14(%ebp)
    5040:	ff 75 e4             	pushl  -0x1c(%ebp)
    5043:	e8 2c fb ff ff       	call   4b74 <bpmnode_sort>
    5048:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    504b:	8b 45 14             	mov    0x14(%ebp),%eax
    504e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    5051:	8b 45 14             	mov    0x14(%ebp),%eax
    5054:	83 c0 01             	add    $0x1,%eax
    5057:	0f af 45 14          	imul   0x14(%ebp),%eax
    505b:	01 c0                	add    %eax,%eax
    505d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    5060:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    5067:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    506a:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    506d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5070:	c1 e0 04             	shl    $0x4,%eax
    5073:	83 ec 0c             	sub    $0xc,%esp
    5076:	50                   	push   %eax
    5077:	e8 c5 e2 ff ff       	call   3341 <lodepng_malloc>
    507c:	83 c4 10             	add    $0x10,%esp
    507f:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    5082:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5085:	c1 e0 02             	shl    $0x2,%eax
    5088:	83 ec 0c             	sub    $0xc,%esp
    508b:	50                   	push   %eax
    508c:	e8 b0 e2 ff ff       	call   3341 <lodepng_malloc>
    5091:	83 c4 10             	add    $0x10,%esp
    5094:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5097:	8b 45 d8             	mov    -0x28(%ebp),%eax
    509a:	c1 e0 02             	shl    $0x2,%eax
    509d:	83 ec 0c             	sub    $0xc,%esp
    50a0:	50                   	push   %eax
    50a1:	e8 9b e2 ff ff       	call   3341 <lodepng_malloc>
    50a6:	83 c4 10             	add    $0x10,%esp
    50a9:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    50ac:	8b 45 d8             	mov    -0x28(%ebp),%eax
    50af:	c1 e0 02             	shl    $0x2,%eax
    50b2:	83 ec 0c             	sub    $0xc,%esp
    50b5:	50                   	push   %eax
    50b6:	e8 86 e2 ff ff       	call   3341 <lodepng_malloc>
    50bb:	83 c4 10             	add    $0x10,%esp
    50be:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    50c1:	8b 45 c8             	mov    -0x38(%ebp),%eax
    50c4:	85 c0                	test   %eax,%eax
    50c6:	74 15                	je     50dd <lodepng_huffman_code_lengths+0x1e3>
    50c8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    50cb:	85 c0                	test   %eax,%eax
    50cd:	74 0e                	je     50dd <lodepng_huffman_code_lengths+0x1e3>
    50cf:	8b 45 dc             	mov    -0x24(%ebp),%eax
    50d2:	85 c0                	test   %eax,%eax
    50d4:	74 07                	je     50dd <lodepng_huffman_code_lengths+0x1e3>
    50d6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    50d9:	85 c0                	test   %eax,%eax
    50db:	75 07                	jne    50e4 <lodepng_huffman_code_lengths+0x1ea>
    50dd:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    50e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    50e8:	0f 85 30 01 00 00    	jne    521e <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    50ee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    50f5:	eb 1c                	jmp    5113 <lodepng_huffman_code_lengths+0x219>
    50f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    50fa:	8b 55 f0             	mov    -0x10(%ebp),%edx
    50fd:	c1 e2 02             	shl    $0x2,%edx
    5100:	01 d0                	add    %edx,%eax
    5102:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5105:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5108:	c1 e1 04             	shl    $0x4,%ecx
    510b:	01 ca                	add    %ecx,%edx
    510d:	89 10                	mov    %edx,(%eax)
    510f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5113:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5116:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5119:	75 dc                	jne    50f7 <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    511b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    511e:	8b 00                	mov    (%eax),%eax
    5120:	6a 00                	push   $0x0
    5122:	6a 01                	push   $0x1
    5124:	50                   	push   %eax
    5125:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5128:	50                   	push   %eax
    5129:	e8 de f8 ff ff       	call   4a0c <bpmnode_create>
    512e:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    5131:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5134:	83 c0 10             	add    $0x10,%eax
    5137:	8b 00                	mov    (%eax),%eax
    5139:	6a 00                	push   $0x0
    513b:	6a 02                	push   $0x2
    513d:	50                   	push   %eax
    513e:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5141:	50                   	push   %eax
    5142:	e8 c5 f8 ff ff       	call   4a0c <bpmnode_create>
    5147:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    514a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5151:	eb 27                	jmp    517a <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    5153:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5156:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5159:	c1 e2 02             	shl    $0x2,%edx
    515c:	01 c2                	add    %eax,%edx
    515e:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5161:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    5163:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5166:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5169:	c1 e2 02             	shl    $0x2,%edx
    516c:	01 d0                	add    %edx,%eax
    516e:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5171:	83 c2 10             	add    $0x10,%edx
    5174:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    5176:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    517a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    517d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5180:	75 d1                	jne    5153 <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    5182:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    5189:	eb 24                	jmp    51af <lodepng_huffman_code_lengths+0x2b5>
    518b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    518e:	8b 55 14             	mov    0x14(%ebp),%edx
    5191:	83 ea 01             	sub    $0x1,%edx
    5194:	83 ec 0c             	sub    $0xc,%esp
    5197:	50                   	push   %eax
    5198:	52                   	push   %edx
    5199:	ff 75 ec             	pushl  -0x14(%ebp)
    519c:	ff 75 e4             	pushl  -0x1c(%ebp)
    519f:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    51a2:	50                   	push   %eax
    51a3:	e8 7a fb ff ff       	call   4d22 <boundaryPM>
    51a8:	83 c4 20             	add    $0x20,%esp
    51ab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    51af:	8b 45 ec             	mov    -0x14(%ebp),%eax
    51b2:	83 e8 01             	sub    $0x1,%eax
    51b5:	01 c0                	add    %eax,%eax
    51b7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    51ba:	75 cf                	jne    518b <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    51bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
    51bf:	8b 55 14             	mov    0x14(%ebp),%edx
    51c2:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    51c8:	c1 e2 02             	shl    $0x2,%edx
    51cb:	01 d0                	add    %edx,%eax
    51cd:	8b 00                	mov    (%eax),%eax
    51cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
    51d2:	eb 44                	jmp    5218 <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    51d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    51db:	eb 27                	jmp    5204 <lodepng_huffman_code_lengths+0x30a>
    51dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    51e0:	c1 e0 04             	shl    $0x4,%eax
    51e3:	89 c2                	mov    %eax,%edx
    51e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    51e8:	01 d0                	add    %edx,%eax
    51ea:	8b 40 04             	mov    0x4(%eax),%eax
    51ed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    51f4:	8b 45 08             	mov    0x8(%ebp),%eax
    51f7:	01 d0                	add    %edx,%eax
    51f9:	8b 10                	mov    (%eax),%edx
    51fb:	83 c2 01             	add    $0x1,%edx
    51fe:	89 10                	mov    %edx,(%eax)
    5200:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5204:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5207:	8b 40 04             	mov    0x4(%eax),%eax
    520a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    520d:	75 ce                	jne    51dd <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    520f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5212:	8b 40 08             	mov    0x8(%eax),%eax
    5215:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5218:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    521c:	75 b6                	jne    51d4 <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    521e:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5221:	83 ec 0c             	sub    $0xc,%esp
    5224:	50                   	push   %eax
    5225:	e8 38 e1 ff ff       	call   3362 <lodepng_free>
    522a:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    522d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5230:	83 ec 0c             	sub    $0xc,%esp
    5233:	50                   	push   %eax
    5234:	e8 29 e1 ff ff       	call   3362 <lodepng_free>
    5239:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    523c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    523f:	83 ec 0c             	sub    $0xc,%esp
    5242:	50                   	push   %eax
    5243:	e8 1a e1 ff ff       	call   3362 <lodepng_free>
    5248:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    524b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    524e:	83 ec 0c             	sub    $0xc,%esp
    5251:	50                   	push   %eax
    5252:	e8 0b e1 ff ff       	call   3362 <lodepng_free>
    5257:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    525a:	83 ec 0c             	sub    $0xc,%esp
    525d:	ff 75 e4             	pushl  -0x1c(%ebp)
    5260:	e8 fd e0 ff ff       	call   3362 <lodepng_free>
    5265:	83 c4 10             	add    $0x10,%esp
  return error;
    5268:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    526b:	c9                   	leave  
    526c:	c3                   	ret    

0000526d <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    526d:	55                   	push   %ebp
    526e:	89 e5                	mov    %esp,%ebp
    5270:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    5273:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    527a:	eb 04                	jmp    5280 <HuffmanTree_makeFromFrequencies+0x13>
    527c:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    5280:	8b 45 14             	mov    0x14(%ebp),%eax
    5283:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5288:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    528f:	8b 45 0c             	mov    0xc(%ebp),%eax
    5292:	01 d0                	add    %edx,%eax
    5294:	8b 00                	mov    (%eax),%eax
    5296:	85 c0                	test   %eax,%eax
    5298:	75 08                	jne    52a2 <HuffmanTree_makeFromFrequencies+0x35>
    529a:	8b 45 14             	mov    0x14(%ebp),%eax
    529d:	3b 45 10             	cmp    0x10(%ebp),%eax
    52a0:	7f da                	jg     527c <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    52a2:	8b 45 14             	mov    0x14(%ebp),%eax
    52a5:	c1 e0 02             	shl    $0x2,%eax
    52a8:	83 ec 0c             	sub    $0xc,%esp
    52ab:	50                   	push   %eax
    52ac:	e8 90 e0 ff ff       	call   3341 <lodepng_malloc>
    52b1:	83 c4 10             	add    $0x10,%esp
    52b4:	89 c2                	mov    %eax,%edx
    52b6:	8b 45 08             	mov    0x8(%ebp),%eax
    52b9:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    52bc:	8b 45 08             	mov    0x8(%ebp),%eax
    52bf:	8b 40 04             	mov    0x4(%eax),%eax
    52c2:	85 c0                	test   %eax,%eax
    52c4:	75 07                	jne    52cd <HuffmanTree_makeFromFrequencies+0x60>
    52c6:	b8 53 00 00 00       	mov    $0x53,%eax
    52cb:	eb 47                	jmp    5314 <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    52cd:	8b 45 08             	mov    0x8(%ebp),%eax
    52d0:	8b 55 18             	mov    0x18(%ebp),%edx
    52d3:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    52d6:	8b 55 14             	mov    0x14(%ebp),%edx
    52d9:	8b 45 08             	mov    0x8(%ebp),%eax
    52dc:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    52df:	8b 45 08             	mov    0x8(%ebp),%eax
    52e2:	8b 40 04             	mov    0x4(%eax),%eax
    52e5:	ff 75 18             	pushl  0x18(%ebp)
    52e8:	ff 75 14             	pushl  0x14(%ebp)
    52eb:	ff 75 0c             	pushl  0xc(%ebp)
    52ee:	50                   	push   %eax
    52ef:	e8 06 fc ff ff       	call   4efa <lodepng_huffman_code_lengths>
    52f4:	83 c4 10             	add    $0x10,%esp
    52f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    52fa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    52fe:	75 11                	jne    5311 <HuffmanTree_makeFromFrequencies+0xa4>
    5300:	83 ec 0c             	sub    $0xc,%esp
    5303:	ff 75 08             	pushl  0x8(%ebp)
    5306:	e8 37 f4 ff ff       	call   4742 <HuffmanTree_makeFromLengths2>
    530b:	83 c4 10             	add    $0x10,%esp
    530e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    5311:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5314:	c9                   	leave  
    5315:	c3                   	ret    

00005316 <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    5316:	55                   	push   %ebp
    5317:	89 e5                	mov    %esp,%ebp
    5319:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    531c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    5323:	83 ec 0c             	sub    $0xc,%esp
    5326:	68 80 04 00 00       	push   $0x480
    532b:	e8 11 e0 ff ff       	call   3341 <lodepng_malloc>
    5330:	83 c4 10             	add    $0x10,%esp
    5333:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    5336:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    533a:	75 0a                	jne    5346 <generateFixedLitLenTree+0x30>
    533c:	b8 53 00 00 00       	mov    $0x53,%eax
    5341:	e9 d5 00 00 00       	jmp    541b <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    5346:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    534d:	eb 19                	jmp    5368 <generateFixedLitLenTree+0x52>
    534f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5352:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5359:	8b 45 ec             	mov    -0x14(%ebp),%eax
    535c:	01 d0                	add    %edx,%eax
    535e:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5364:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5368:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    536f:	76 de                	jbe    534f <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    5371:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    5378:	eb 19                	jmp    5393 <generateFixedLitLenTree+0x7d>
    537a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    537d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5384:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5387:	01 d0                	add    %edx,%eax
    5389:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    538f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5393:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    539a:	76 de                	jbe    537a <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    539c:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    53a3:	eb 19                	jmp    53be <generateFixedLitLenTree+0xa8>
    53a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    53af:	8b 45 ec             	mov    -0x14(%ebp),%eax
    53b2:	01 d0                	add    %edx,%eax
    53b4:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    53ba:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    53be:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    53c5:	76 de                	jbe    53a5 <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    53c7:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    53ce:	eb 19                	jmp    53e9 <generateFixedLitLenTree+0xd3>
    53d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53d3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    53da:	8b 45 ec             	mov    -0x14(%ebp),%eax
    53dd:	01 d0                	add    %edx,%eax
    53df:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    53e5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    53e9:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    53f0:	76 de                	jbe    53d0 <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    53f2:	6a 0f                	push   $0xf
    53f4:	68 20 01 00 00       	push   $0x120
    53f9:	ff 75 ec             	pushl  -0x14(%ebp)
    53fc:	ff 75 08             	pushl  0x8(%ebp)
    53ff:	e8 7f f5 ff ff       	call   4983 <HuffmanTree_makeFromLengths>
    5404:	83 c4 10             	add    $0x10,%esp
    5407:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    540a:	83 ec 0c             	sub    $0xc,%esp
    540d:	ff 75 ec             	pushl  -0x14(%ebp)
    5410:	e8 4d df ff ff       	call   3362 <lodepng_free>
    5415:	83 c4 10             	add    $0x10,%esp
  return error;
    5418:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    541b:	c9                   	leave  
    541c:	c3                   	ret    

0000541d <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    541d:	55                   	push   %ebp
    541e:	89 e5                	mov    %esp,%ebp
    5420:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    5423:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    542a:	83 ec 0c             	sub    $0xc,%esp
    542d:	68 80 00 00 00       	push   $0x80
    5432:	e8 0a df ff ff       	call   3341 <lodepng_malloc>
    5437:	83 c4 10             	add    $0x10,%esp
    543a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    543d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5441:	75 07                	jne    544a <generateFixedDistanceTree+0x2d>
    5443:	b8 53 00 00 00       	mov    $0x53,%eax
    5448:	eb 4e                	jmp    5498 <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    544a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5451:	eb 19                	jmp    546c <generateFixedDistanceTree+0x4f>
    5453:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5456:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    545d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5460:	01 d0                	add    %edx,%eax
    5462:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    5468:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    546c:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    5470:	75 e1                	jne    5453 <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    5472:	6a 0f                	push   $0xf
    5474:	6a 20                	push   $0x20
    5476:	ff 75 ec             	pushl  -0x14(%ebp)
    5479:	ff 75 08             	pushl  0x8(%ebp)
    547c:	e8 02 f5 ff ff       	call   4983 <HuffmanTree_makeFromLengths>
    5481:	83 c4 10             	add    $0x10,%esp
    5484:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    5487:	83 ec 0c             	sub    $0xc,%esp
    548a:	ff 75 ec             	pushl  -0x14(%ebp)
    548d:	e8 d0 de ff ff       	call   3362 <lodepng_free>
    5492:	83 c4 10             	add    $0x10,%esp
  return error;
    5495:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    5498:	c9                   	leave  
    5499:	c3                   	ret    

0000549a <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    549a:	55                   	push   %ebp
    549b:	89 e5                	mov    %esp,%ebp
    549d:	53                   	push   %ebx
    549e:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    54a1:	6a 09                	push   $0x9
    54a3:	ff 75 08             	pushl  0x8(%ebp)
    54a6:	e8 d8 eb ff ff       	call   4083 <peekBits>
    54ab:	83 c4 08             	add    $0x8,%esp
    54ae:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    54b2:	8b 45 0c             	mov    0xc(%ebp),%eax
    54b5:	8b 50 10             	mov    0x10(%eax),%edx
    54b8:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    54bc:	01 d0                	add    %edx,%eax
    54be:	0f b6 00             	movzbl (%eax),%eax
    54c1:	0f b6 c0             	movzbl %al,%eax
    54c4:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    54c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    54cb:	8b 40 14             	mov    0x14(%eax),%eax
    54ce:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    54d2:	01 d2                	add    %edx,%edx
    54d4:	01 d0                	add    %edx,%eax
    54d6:	0f b7 00             	movzwl (%eax),%eax
    54d9:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    54dd:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    54e2:	77 16                	ja     54fa <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    54e4:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    54e8:	50                   	push   %eax
    54e9:	ff 75 08             	pushl  0x8(%ebp)
    54ec:	e8 b2 eb ff ff       	call   40a3 <advanceBits>
    54f1:	83 c4 08             	add    $0x8,%esp
    return value;
    54f4:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    54f8:	eb 5c                	jmp    5556 <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    54fa:	6a 09                	push   $0x9
    54fc:	ff 75 08             	pushl  0x8(%ebp)
    54ff:	e8 9f eb ff ff       	call   40a3 <advanceBits>
    5504:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    5507:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    550b:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    550f:	83 e8 09             	sub    $0x9,%eax
    5512:	50                   	push   %eax
    5513:	ff 75 08             	pushl  0x8(%ebp)
    5516:	e8 68 eb ff ff       	call   4083 <peekBits>
    551b:	83 c4 08             	add    $0x8,%esp
    551e:	01 d8                	add    %ebx,%eax
    5520:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    5523:	8b 45 0c             	mov    0xc(%ebp),%eax
    5526:	8b 50 10             	mov    0x10(%eax),%edx
    5529:	8b 45 f0             	mov    -0x10(%ebp),%eax
    552c:	01 d0                	add    %edx,%eax
    552e:	0f b6 00             	movzbl (%eax),%eax
    5531:	0f b6 c0             	movzbl %al,%eax
    5534:	83 e8 09             	sub    $0x9,%eax
    5537:	50                   	push   %eax
    5538:	ff 75 08             	pushl  0x8(%ebp)
    553b:	e8 63 eb ff ff       	call   40a3 <advanceBits>
    5540:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    5543:	8b 45 0c             	mov    0xc(%ebp),%eax
    5546:	8b 40 14             	mov    0x14(%eax),%eax
    5549:	8b 55 f0             	mov    -0x10(%ebp),%edx
    554c:	01 d2                	add    %edx,%edx
    554e:	01 d0                	add    %edx,%eax
    5550:	0f b7 00             	movzwl (%eax),%eax
    5553:	0f b7 c0             	movzwl %ax,%eax
  }
}
    5556:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5559:	c9                   	leave  
    555a:	c3                   	ret    

0000555b <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    555b:	55                   	push   %ebp
    555c:	89 e5                	mov    %esp,%ebp
    555e:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    5561:	83 ec 0c             	sub    $0xc,%esp
    5564:	ff 75 08             	pushl  0x8(%ebp)
    5567:	e8 aa fd ff ff       	call   5316 <generateFixedLitLenTree>
    556c:	83 c4 10             	add    $0x10,%esp
    556f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    5572:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5576:	74 05                	je     557d <getTreeInflateFixed+0x22>
    5578:	8b 45 f4             	mov    -0xc(%ebp),%eax
    557b:	eb 0e                	jmp    558b <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    557d:	83 ec 0c             	sub    $0xc,%esp
    5580:	ff 75 0c             	pushl  0xc(%ebp)
    5583:	e8 95 fe ff ff       	call   541d <generateFixedDistanceTree>
    5588:	83 c4 10             	add    $0x10,%esp
}
    558b:	c9                   	leave  
    558c:	c3                   	ret    

0000558d <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    558d:	55                   	push   %ebp
    558e:	89 e5                	mov    %esp,%ebp
    5590:	53                   	push   %ebx
    5591:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    5594:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    559b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    55a2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    55a9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    55b0:	6a 0e                	push   $0xe
    55b2:	ff 75 10             	pushl  0x10(%ebp)
    55b5:	e8 37 e6 ff ff       	call   3bf1 <ensureBits17>
    55ba:	83 c4 08             	add    $0x8,%esp
    55bd:	85 c0                	test   %eax,%eax
    55bf:	75 0a                	jne    55cb <getTreeInflateDynamic+0x3e>
    55c1:	b8 31 00 00 00       	mov    $0x31,%eax
    55c6:	e9 ec 04 00 00       	jmp    5ab7 <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    55cb:	6a 05                	push   $0x5
    55cd:	ff 75 10             	pushl  0x10(%ebp)
    55d0:	e8 f8 ea ff ff       	call   40cd <readBits>
    55d5:	83 c4 08             	add    $0x8,%esp
    55d8:	05 01 01 00 00       	add    $0x101,%eax
    55dd:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    55e0:	6a 05                	push   $0x5
    55e2:	ff 75 10             	pushl  0x10(%ebp)
    55e5:	e8 e3 ea ff ff       	call   40cd <readBits>
    55ea:	83 c4 08             	add    $0x8,%esp
    55ed:	83 c0 01             	add    $0x1,%eax
    55f0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    55f3:	6a 04                	push   $0x4
    55f5:	ff 75 10             	pushl  0x10(%ebp)
    55f8:	e8 d0 ea ff ff       	call   40cd <readBits>
    55fd:	83 c4 08             	add    $0x8,%esp
    5600:	83 c0 04             	add    $0x4,%eax
    5603:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    5606:	83 ec 0c             	sub    $0xc,%esp
    5609:	6a 4c                	push   $0x4c
    560b:	e8 31 dd ff ff       	call   3341 <lodepng_malloc>
    5610:	83 c4 10             	add    $0x10,%esp
    5613:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    5616:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    561a:	75 0a                	jne    5626 <getTreeInflateDynamic+0x99>
    561c:	b8 53 00 00 00       	mov    $0x53,%eax
    5621:	e9 91 04 00 00       	jmp    5ab7 <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    5626:	83 ec 0c             	sub    $0xc,%esp
    5629:	8d 45 a8             	lea    -0x58(%ebp),%eax
    562c:	50                   	push   %eax
    562d:	e8 03 ec ff ff       	call   4235 <HuffmanTree_init>
    5632:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    5635:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5639:	0f 85 3c 04 00 00    	jne    5a7b <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    563f:	8b 45 10             	mov    0x10(%ebp),%eax
    5642:	8b 48 08             	mov    0x8(%eax),%ecx
    5645:	8b 55 d0             	mov    -0x30(%ebp),%edx
    5648:	89 d0                	mov    %edx,%eax
    564a:	01 c0                	add    %eax,%eax
    564c:	01 d0                	add    %edx,%eax
    564e:	89 c2                	mov    %eax,%edx
    5650:	8b 45 10             	mov    0x10(%ebp),%eax
    5653:	8b 40 0c             	mov    0xc(%eax),%eax
    5656:	83 ec 04             	sub    $0x4,%esp
    5659:	51                   	push   %ecx
    565a:	52                   	push   %edx
    565b:	50                   	push   %eax
    565c:	e8 f7 dd ff ff       	call   3458 <lodepng_gtofl>
    5661:	83 c4 10             	add    $0x10,%esp
    5664:	85 c0                	test   %eax,%eax
    5666:	74 0c                	je     5674 <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    5668:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    566f:	e9 07 04 00 00       	jmp    5a7b <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    5674:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    567b:	eb 3d                	jmp    56ba <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    567d:	83 ec 08             	sub    $0x8,%esp
    5680:	6a 03                	push   $0x3
    5682:	ff 75 10             	pushl  0x10(%ebp)
    5685:	e8 8b e4 ff ff       	call   3b15 <ensureBits9>
    568a:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    568d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5690:	8b 04 85 60 9f 01 00 	mov    0x19f60(,%eax,4),%eax
    5697:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    569e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    56a1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    56a4:	83 ec 08             	sub    $0x8,%esp
    56a7:	6a 03                	push   $0x3
    56a9:	ff 75 10             	pushl  0x10(%ebp)
    56ac:	e8 1c ea ff ff       	call   40cd <readBits>
    56b1:	83 c4 10             	add    $0x10,%esp
    56b4:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    56b6:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    56ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    56bd:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    56c0:	75 bb                	jne    567d <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    56c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
    56c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    56c8:	eb 20                	jmp    56ea <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    56ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
    56cd:	8b 04 85 60 9f 01 00 	mov    0x19f60(,%eax,4),%eax
    56d4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    56db:	8b 45 dc             	mov    -0x24(%ebp),%eax
    56de:	01 d0                	add    %edx,%eax
    56e0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    56e6:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    56ea:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    56ee:	75 da                	jne    56ca <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    56f0:	6a 07                	push   $0x7
    56f2:	6a 13                	push   $0x13
    56f4:	ff 75 dc             	pushl  -0x24(%ebp)
    56f7:	8d 45 a8             	lea    -0x58(%ebp),%eax
    56fa:	50                   	push   %eax
    56fb:	e8 83 f2 ff ff       	call   4983 <HuffmanTree_makeFromLengths>
    5700:	83 c4 10             	add    $0x10,%esp
    5703:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5706:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    570a:	0f 85 64 03 00 00    	jne    5a74 <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    5710:	83 ec 0c             	sub    $0xc,%esp
    5713:	68 80 04 00 00       	push   $0x480
    5718:	e8 24 dc ff ff       	call   3341 <lodepng_malloc>
    571d:	83 c4 10             	add    $0x10,%esp
    5720:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    5723:	83 ec 0c             	sub    $0xc,%esp
    5726:	68 80 00 00 00       	push   $0x80
    572b:	e8 11 dc ff ff       	call   3341 <lodepng_malloc>
    5730:	83 c4 10             	add    $0x10,%esp
    5733:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    5736:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    573a:	74 06                	je     5742 <getTreeInflateDynamic+0x1b5>
    573c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5740:	75 0c                	jne    574e <getTreeInflateDynamic+0x1c1>
    5742:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5749:	e9 2d 03 00 00       	jmp    5a7b <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    574e:	83 ec 04             	sub    $0x4,%esp
    5751:	68 80 04 00 00       	push   $0x480
    5756:	6a 00                	push   $0x0
    5758:	ff 75 e8             	pushl  -0x18(%ebp)
    575b:	e8 52 dc ff ff       	call   33b2 <lodepng_memset>
    5760:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    5763:	83 ec 04             	sub    $0x4,%esp
    5766:	68 80 00 00 00       	push   $0x80
    576b:	6a 00                	push   $0x0
    576d:	ff 75 e4             	pushl  -0x1c(%ebp)
    5770:	e8 3d dc ff ff       	call   33b2 <lodepng_memset>
    5775:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    5778:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    577f:	e9 8d 02 00 00       	jmp    5a11 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    5784:	83 ec 08             	sub    $0x8,%esp
    5787:	6a 16                	push   $0x16
    5789:	ff 75 10             	pushl  0x10(%ebp)
    578c:	e8 8c e5 ff ff       	call   3d1d <ensureBits25>
    5791:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    5794:	83 ec 08             	sub    $0x8,%esp
    5797:	8d 45 a8             	lea    -0x58(%ebp),%eax
    579a:	50                   	push   %eax
    579b:	ff 75 10             	pushl  0x10(%ebp)
    579e:	e8 f7 fc ff ff       	call   549a <huffmanDecodeSymbol>
    57a3:	83 c4 10             	add    $0x10,%esp
    57a6:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    57a9:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    57ad:	77 3e                	ja     57ed <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    57af:	8b 45 ec             	mov    -0x14(%ebp),%eax
    57b2:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    57b5:	73 16                	jae    57cd <getTreeInflateDynamic+0x240>
    57b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    57ba:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    57c4:	01 c2                	add    %eax,%edx
    57c6:	8b 45 cc             	mov    -0x34(%ebp),%eax
    57c9:	89 02                	mov    %eax,(%edx)
    57cb:	eb 17                	jmp    57e4 <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    57cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    57d0:	2b 45 d8             	sub    -0x28(%ebp),%eax
    57d3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    57dd:	01 c2                	add    %eax,%edx
    57df:	8b 45 cc             	mov    -0x34(%ebp),%eax
    57e2:	89 02                	mov    %eax,(%edx)
        ++i;
    57e4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    57e8:	e9 0b 02 00 00       	jmp    59f8 <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    57ed:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    57f1:	0f 85 da 00 00 00    	jne    58d1 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    57f7:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    57fe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5802:	75 0c                	jne    5810 <getTreeInflateDynamic+0x283>
    5804:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    580b:	e9 12 02 00 00       	jmp    5a22 <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    5810:	83 ec 08             	sub    $0x8,%esp
    5813:	6a 02                	push   $0x2
    5815:	ff 75 10             	pushl  0x10(%ebp)
    5818:	e8 b0 e8 ff ff       	call   40cd <readBits>
    581d:	83 c4 10             	add    $0x10,%esp
    5820:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    5823:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5826:	83 c0 01             	add    $0x1,%eax
    5829:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    582c:	76 1b                	jbe    5849 <getTreeInflateDynamic+0x2bc>
    582e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5831:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5836:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    583d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5840:	01 d0                	add    %edx,%eax
    5842:	8b 00                	mov    (%eax),%eax
    5844:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5847:	eb 1c                	jmp    5865 <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    5849:	8b 45 ec             	mov    -0x14(%ebp),%eax
    584c:	2b 45 d8             	sub    -0x28(%ebp),%eax
    584f:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5854:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    585b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    585e:	01 d0                	add    %edx,%eax
    5860:	8b 00                	mov    (%eax),%eax
    5862:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5865:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    586c:	eb 56                	jmp    58c4 <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    586e:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5871:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5874:	01 d0                	add    %edx,%eax
    5876:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5879:	77 0c                	ja     5887 <getTreeInflateDynamic+0x2fa>
    587b:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    5882:	e9 71 01 00 00       	jmp    59f8 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    5887:	8b 45 ec             	mov    -0x14(%ebp),%eax
    588a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    588d:	73 16                	jae    58a5 <getTreeInflateDynamic+0x318>
    588f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5892:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5899:	8b 45 e8             	mov    -0x18(%ebp),%eax
    589c:	01 c2                	add    %eax,%edx
    589e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    58a1:	89 02                	mov    %eax,(%edx)
    58a3:	eb 17                	jmp    58bc <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    58a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58a8:	2b 45 d8             	sub    -0x28(%ebp),%eax
    58ab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    58b5:	01 c2                	add    %eax,%edx
    58b7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    58ba:	89 02                	mov    %eax,(%edx)
          ++i;
    58bc:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    58c0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    58c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    58c7:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    58ca:	72 a2                	jb     586e <getTreeInflateDynamic+0x2e1>
    58cc:	e9 27 01 00 00       	jmp    59f8 <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    58d1:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    58d5:	0f 85 88 00 00 00    	jne    5963 <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    58db:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    58e2:	83 ec 08             	sub    $0x8,%esp
    58e5:	6a 03                	push   $0x3
    58e7:	ff 75 10             	pushl  0x10(%ebp)
    58ea:	e8 de e7 ff ff       	call   40cd <readBits>
    58ef:	83 c4 10             	add    $0x10,%esp
    58f2:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    58f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    58fc:	eb 58                	jmp    5956 <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    58fe:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5901:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5904:	01 d0                	add    %edx,%eax
    5906:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5909:	77 0c                	ja     5917 <getTreeInflateDynamic+0x38a>
    590b:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    5912:	e9 e1 00 00 00       	jmp    59f8 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5917:	8b 45 ec             	mov    -0x14(%ebp),%eax
    591a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    591d:	73 17                	jae    5936 <getTreeInflateDynamic+0x3a9>
    591f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5922:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5929:	8b 45 e8             	mov    -0x18(%ebp),%eax
    592c:	01 d0                	add    %edx,%eax
    592e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5934:	eb 18                	jmp    594e <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    5936:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5939:	2b 45 d8             	sub    -0x28(%ebp),%eax
    593c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5943:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5946:	01 d0                	add    %edx,%eax
    5948:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    594e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5952:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5956:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5959:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    595c:	72 a0                	jb     58fe <getTreeInflateDynamic+0x371>
    595e:	e9 95 00 00 00       	jmp    59f8 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    5963:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    5967:	0f 85 82 00 00 00    	jne    59ef <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    596d:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    5974:	83 ec 08             	sub    $0x8,%esp
    5977:	6a 07                	push   $0x7
    5979:	ff 75 10             	pushl  0x10(%ebp)
    597c:	e8 4c e7 ff ff       	call   40cd <readBits>
    5981:	83 c4 10             	add    $0x10,%esp
    5984:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5987:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    598e:	eb 55                	jmp    59e5 <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    5990:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5993:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5996:	01 d0                	add    %edx,%eax
    5998:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    599b:	77 09                	ja     59a6 <getTreeInflateDynamic+0x419>
    599d:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    59a4:	eb 52                	jmp    59f8 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    59a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59a9:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    59ac:	73 17                	jae    59c5 <getTreeInflateDynamic+0x438>
    59ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59b1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    59b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    59bb:	01 d0                	add    %edx,%eax
    59bd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    59c3:	eb 18                	jmp    59dd <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    59c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59c8:	2b 45 d8             	sub    -0x28(%ebp),%eax
    59cb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    59d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    59d5:	01 d0                	add    %edx,%eax
    59d7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    59dd:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    59e1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    59e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    59e8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    59eb:	72 a3                	jb     5990 <getTreeInflateDynamic+0x403>
    59ed:	eb 09                	jmp    59f8 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    59ef:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    59f6:	eb 2a                	jmp    5a22 <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    59f8:	8b 45 10             	mov    0x10(%ebp),%eax
    59fb:	8b 50 0c             	mov    0xc(%eax),%edx
    59fe:	8b 45 10             	mov    0x10(%ebp),%eax
    5a01:	8b 40 08             	mov    0x8(%eax),%eax
    5a04:	39 c2                	cmp    %eax,%edx
    5a06:	7e 09                	jle    5a11 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    5a08:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5a0f:	eb 11                	jmp    5a22 <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    5a11:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5a14:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5a17:	01 d0                	add    %edx,%eax
    5a19:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5a1c:	0f 87 62 fd ff ff    	ja     5784 <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5a22:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5a26:	75 4f                	jne    5a77 <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    5a28:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5a2b:	05 00 04 00 00       	add    $0x400,%eax
    5a30:	8b 00                	mov    (%eax),%eax
    5a32:	85 c0                	test   %eax,%eax
    5a34:	75 09                	jne    5a3f <getTreeInflateDynamic+0x4b2>
    5a36:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    5a3d:	eb 3c                	jmp    5a7b <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5a3f:	6a 0f                	push   $0xf
    5a41:	68 20 01 00 00       	push   $0x120
    5a46:	ff 75 e8             	pushl  -0x18(%ebp)
    5a49:	ff 75 08             	pushl  0x8(%ebp)
    5a4c:	e8 32 ef ff ff       	call   4983 <HuffmanTree_makeFromLengths>
    5a51:	83 c4 10             	add    $0x10,%esp
    5a54:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5a57:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5a5b:	75 1d                	jne    5a7a <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    5a5d:	6a 0f                	push   $0xf
    5a5f:	6a 20                	push   $0x20
    5a61:	ff 75 e4             	pushl  -0x1c(%ebp)
    5a64:	ff 75 0c             	pushl  0xc(%ebp)
    5a67:	e8 17 ef ff ff       	call   4983 <HuffmanTree_makeFromLengths>
    5a6c:	83 c4 10             	add    $0x10,%esp
    5a6f:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    5a72:	eb 07                	jmp    5a7b <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    5a74:	90                   	nop
    5a75:	eb 04                	jmp    5a7b <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5a77:	90                   	nop
    5a78:	eb 01                	jmp    5a7b <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    5a7a:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    5a7b:	83 ec 0c             	sub    $0xc,%esp
    5a7e:	ff 75 dc             	pushl  -0x24(%ebp)
    5a81:	e8 dc d8 ff ff       	call   3362 <lodepng_free>
    5a86:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    5a89:	83 ec 0c             	sub    $0xc,%esp
    5a8c:	ff 75 e8             	pushl  -0x18(%ebp)
    5a8f:	e8 ce d8 ff ff       	call   3362 <lodepng_free>
    5a94:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    5a97:	83 ec 0c             	sub    $0xc,%esp
    5a9a:	ff 75 e4             	pushl  -0x1c(%ebp)
    5a9d:	e8 c0 d8 ff ff       	call   3362 <lodepng_free>
    5aa2:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    5aa5:	83 ec 0c             	sub    $0xc,%esp
    5aa8:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5aab:	50                   	push   %eax
    5aac:	e8 b1 e7 ff ff       	call   4262 <HuffmanTree_cleanup>
    5ab1:	83 c4 10             	add    $0x10,%esp

  return error;
    5ab4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5ab7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5aba:	c9                   	leave  
    5abb:	c3                   	ret    

00005abc <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    5abc:	55                   	push   %ebp
    5abd:	89 e5                	mov    %esp,%ebp
    5abf:	53                   	push   %ebx
    5ac0:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    5ac3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    5aca:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5acd:	50                   	push   %eax
    5ace:	e8 62 e7 ff ff       	call   4235 <HuffmanTree_init>
    5ad3:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    5ad6:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5ad9:	50                   	push   %eax
    5ada:	e8 56 e7 ff ff       	call   4235 <HuffmanTree_init>
    5adf:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    5ae2:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    5ae6:	75 1b                	jne    5b03 <inflateHuffmanBlock+0x47>
    5ae8:	83 ec 08             	sub    $0x8,%esp
    5aeb:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5aee:	50                   	push   %eax
    5aef:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5af2:	50                   	push   %eax
    5af3:	e8 63 fa ff ff       	call   555b <getTreeInflateFixed>
    5af8:	83 c4 10             	add    $0x10,%esp
    5afb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5afe:	e9 9a 02 00 00       	jmp    5d9d <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    5b03:	83 ec 04             	sub    $0x4,%esp
    5b06:	ff 75 0c             	pushl  0xc(%ebp)
    5b09:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5b0c:	50                   	push   %eax
    5b0d:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5b10:	50                   	push   %eax
    5b11:	e8 77 fa ff ff       	call   558d <getTreeInflateDynamic>
    5b16:	83 c4 10             	add    $0x10,%esp
    5b19:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5b1c:	e9 7c 02 00 00       	jmp    5d9d <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    5b21:	83 ec 08             	sub    $0x8,%esp
    5b24:	6a 14                	push   $0x14
    5b26:	ff 75 0c             	pushl  0xc(%ebp)
    5b29:	e8 ef e1 ff ff       	call   3d1d <ensureBits25>
    5b2e:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    5b31:	83 ec 08             	sub    $0x8,%esp
    5b34:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5b37:	50                   	push   %eax
    5b38:	ff 75 0c             	pushl  0xc(%ebp)
    5b3b:	e8 5a f9 ff ff       	call   549a <huffmanDecodeSymbol>
    5b40:	83 c4 10             	add    $0x10,%esp
    5b43:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    5b46:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    5b4d:	77 42                	ja     5b91 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    5b4f:	8b 45 08             	mov    0x8(%ebp),%eax
    5b52:	8b 40 04             	mov    0x4(%eax),%eax
    5b55:	83 c0 01             	add    $0x1,%eax
    5b58:	83 ec 08             	sub    $0x8,%esp
    5b5b:	50                   	push   %eax
    5b5c:	ff 75 08             	pushl  0x8(%ebp)
    5b5f:	e8 37 da ff ff       	call   359b <ucvector_resize>
    5b64:	83 c4 10             	add    $0x10,%esp
    5b67:	85 c0                	test   %eax,%eax
    5b69:	75 0c                	jne    5b77 <inflateHuffmanBlock+0xbb>
    5b6b:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5b72:	e9 33 02 00 00       	jmp    5daa <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    5b77:	8b 45 08             	mov    0x8(%ebp),%eax
    5b7a:	8b 10                	mov    (%eax),%edx
    5b7c:	8b 45 08             	mov    0x8(%ebp),%eax
    5b7f:	8b 40 04             	mov    0x4(%eax),%eax
    5b82:	83 e8 01             	sub    $0x1,%eax
    5b85:	01 d0                	add    %edx,%eax
    5b87:	8b 55 dc             	mov    -0x24(%ebp),%edx
    5b8a:	88 10                	mov    %dl,(%eax)
    5b8c:	e9 d9 01 00 00       	jmp    5d6a <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5b91:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5b98:	0f 86 ba 01 00 00    	jbe    5d58 <inflateHuffmanBlock+0x29c>
    5b9e:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    5ba5:	0f 87 ad 01 00 00    	ja     5d58 <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    5bab:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5bae:	2d 01 01 00 00       	sub    $0x101,%eax
    5bb3:	8b 04 85 60 9d 01 00 	mov    0x19d60(,%eax,4),%eax
    5bba:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    5bbd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5bc0:	2d 01 01 00 00       	sub    $0x101,%eax
    5bc5:	8b 04 85 e0 9d 01 00 	mov    0x19de0(,%eax,4),%eax
    5bcc:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    5bcf:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    5bd3:	74 1c                	je     5bf1 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    5bd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5bd8:	83 ec 08             	sub    $0x8,%esp
    5bdb:	50                   	push   %eax
    5bdc:	ff 75 0c             	pushl  0xc(%ebp)
    5bdf:	e8 e9 e4 ff ff       	call   40cd <readBits>
    5be4:	83 c4 10             	add    $0x10,%esp
    5be7:	89 c2                	mov    %eax,%edx
    5be9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5bec:	01 d0                	add    %edx,%eax
    5bee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    5bf1:	83 ec 08             	sub    $0x8,%esp
    5bf4:	6a 1c                	push   $0x1c
    5bf6:	ff 75 0c             	pushl  0xc(%ebp)
    5bf9:	e8 98 e2 ff ff       	call   3e96 <ensureBits32>
    5bfe:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    5c01:	83 ec 08             	sub    $0x8,%esp
    5c04:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5c07:	50                   	push   %eax
    5c08:	ff 75 0c             	pushl  0xc(%ebp)
    5c0b:	e8 8a f8 ff ff       	call   549a <huffmanDecodeSymbol>
    5c10:	83 c4 10             	add    $0x10,%esp
    5c13:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    5c16:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    5c1a:	76 1e                	jbe    5c3a <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    5c1c:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    5c20:	77 0c                	ja     5c2e <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    5c22:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    5c29:	e9 7c 01 00 00       	jmp    5daa <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5c2e:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5c35:	e9 70 01 00 00       	jmp    5daa <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    5c3a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c3d:	8b 04 85 60 9e 01 00 	mov    0x19e60(,%eax,4),%eax
    5c44:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    5c47:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c4a:	8b 04 85 e0 9e 01 00 	mov    0x19ee0(,%eax,4),%eax
    5c51:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    5c54:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    5c58:	74 15                	je     5c6f <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    5c5a:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5c5d:	83 ec 08             	sub    $0x8,%esp
    5c60:	50                   	push   %eax
    5c61:	ff 75 0c             	pushl  0xc(%ebp)
    5c64:	e8 64 e4 ff ff       	call   40cd <readBits>
    5c69:	83 c4 10             	add    $0x10,%esp
    5c6c:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    5c6f:	8b 45 08             	mov    0x8(%ebp),%eax
    5c72:	8b 40 04             	mov    0x4(%eax),%eax
    5c75:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    5c78:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c7b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5c7e:	76 0c                	jbe    5c8c <inflateHuffmanBlock+0x1d0>
    5c80:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    5c87:	e9 1e 01 00 00       	jmp    5daa <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    5c8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c8f:	2b 45 f0             	sub    -0x10(%ebp),%eax
    5c92:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    5c95:	8b 45 08             	mov    0x8(%ebp),%eax
    5c98:	8b 50 04             	mov    0x4(%eax),%edx
    5c9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c9e:	01 d0                	add    %edx,%eax
    5ca0:	83 ec 08             	sub    $0x8,%esp
    5ca3:	50                   	push   %eax
    5ca4:	ff 75 08             	pushl  0x8(%ebp)
    5ca7:	e8 ef d8 ff ff       	call   359b <ucvector_resize>
    5cac:	83 c4 10             	add    $0x10,%esp
    5caf:	85 c0                	test   %eax,%eax
    5cb1:	75 0c                	jne    5cbf <inflateHuffmanBlock+0x203>
    5cb3:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5cba:	e9 eb 00 00 00       	jmp    5daa <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    5cbf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5cc2:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5cc5:	73 6b                	jae    5d32 <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    5cc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5cca:	8b 55 08             	mov    0x8(%ebp),%edx
    5ccd:	8b 0a                	mov    (%edx),%ecx
    5ccf:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5cd2:	01 d1                	add    %edx,%ecx
    5cd4:	8b 55 08             	mov    0x8(%ebp),%edx
    5cd7:	8b 1a                	mov    (%edx),%ebx
    5cd9:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5cdc:	01 da                	add    %ebx,%edx
    5cde:	83 ec 04             	sub    $0x4,%esp
    5ce1:	50                   	push   %eax
    5ce2:	51                   	push   %ecx
    5ce3:	52                   	push   %edx
    5ce4:	e8 96 d6 ff ff       	call   337f <lodepng_memcpy>
    5ce9:	83 c4 10             	add    $0x10,%esp
        start += distance;
    5cec:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5cef:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5cf2:	01 d0                	add    %edx,%eax
    5cf4:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    5cf7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5cfa:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5cfd:	eb 29                	jmp    5d28 <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    5cff:	8b 45 08             	mov    0x8(%ebp),%eax
    5d02:	8b 08                	mov    (%eax),%ecx
    5d04:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d07:	8d 50 01             	lea    0x1(%eax),%edx
    5d0a:	89 55 ec             	mov    %edx,-0x14(%ebp)
    5d0d:	01 c1                	add    %eax,%ecx
    5d0f:	8b 45 08             	mov    0x8(%ebp),%eax
    5d12:	8b 18                	mov    (%eax),%ebx
    5d14:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5d17:	8d 50 01             	lea    0x1(%eax),%edx
    5d1a:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5d1d:	01 d8                	add    %ebx,%eax
    5d1f:	0f b6 00             	movzbl (%eax),%eax
    5d22:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    5d24:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5d28:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5d2b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    5d2e:	7c cf                	jl     5cff <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5d30:	eb 38                	jmp    5d6a <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    5d32:	8b 45 08             	mov    0x8(%ebp),%eax
    5d35:	8b 10                	mov    (%eax),%edx
    5d37:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5d3a:	01 c2                	add    %eax,%edx
    5d3c:	8b 45 08             	mov    0x8(%ebp),%eax
    5d3f:	8b 08                	mov    (%eax),%ecx
    5d41:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d44:	01 c8                	add    %ecx,%eax
    5d46:	83 ec 04             	sub    $0x4,%esp
    5d49:	ff 75 e4             	pushl  -0x1c(%ebp)
    5d4c:	52                   	push   %edx
    5d4d:	50                   	push   %eax
    5d4e:	e8 2c d6 ff ff       	call   337f <lodepng_memcpy>
    5d53:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5d56:	eb 12                	jmp    5d6a <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    5d58:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5d5f:	74 48                	je     5da9 <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5d61:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5d68:	eb 40                	jmp    5daa <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    5d6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    5d6d:	8b 50 0c             	mov    0xc(%eax),%edx
    5d70:	8b 45 0c             	mov    0xc(%ebp),%eax
    5d73:	8b 40 08             	mov    0x8(%eax),%eax
    5d76:	39 c2                	cmp    %eax,%edx
    5d78:	7e 09                	jle    5d83 <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    5d7a:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    5d81:	eb 27                	jmp    5daa <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    5d83:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    5d87:	74 14                	je     5d9d <inflateHuffmanBlock+0x2e1>
    5d89:	8b 45 08             	mov    0x8(%ebp),%eax
    5d8c:	8b 40 04             	mov    0x4(%eax),%eax
    5d8f:	3b 45 14             	cmp    0x14(%ebp),%eax
    5d92:	7e 09                	jle    5d9d <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    5d94:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    5d9b:	eb 0d                	jmp    5daa <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5d9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5da1:	0f 84 7a fd ff ff    	je     5b21 <inflateHuffmanBlock+0x65>
    5da7:	eb 01                	jmp    5daa <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    5da9:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    5daa:	83 ec 0c             	sub    $0xc,%esp
    5dad:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5db0:	50                   	push   %eax
    5db1:	e8 ac e4 ff ff       	call   4262 <HuffmanTree_cleanup>
    5db6:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    5db9:	83 ec 0c             	sub    $0xc,%esp
    5dbc:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5dbf:	50                   	push   %eax
    5dc0:	e8 9d e4 ff ff       	call   4262 <HuffmanTree_cleanup>
    5dc5:	83 c4 10             	add    $0x10,%esp

  return error;
    5dc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5dcb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5dce:	c9                   	leave  
    5dcf:	c3                   	ret    

00005dd0 <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    5dd0:	55                   	push   %ebp
    5dd1:	89 e5                	mov    %esp,%ebp
    5dd3:	53                   	push   %ebx
    5dd4:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    5dd7:	8b 45 0c             	mov    0xc(%ebp),%eax
    5dda:	8b 40 04             	mov    0x4(%eax),%eax
    5ddd:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    5de0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    5de7:	8b 45 0c             	mov    0xc(%ebp),%eax
    5dea:	8b 40 0c             	mov    0xc(%eax),%eax
    5ded:	83 c0 07             	add    $0x7,%eax
    5df0:	c1 e8 03             	shr    $0x3,%eax
    5df3:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    5df6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5df9:	83 c0 04             	add    $0x4,%eax
    5dfc:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5dff:	7c 0a                	jl     5e0b <inflateNoCompression+0x3b>
    5e01:	b8 34 00 00 00       	mov    $0x34,%eax
    5e06:	e9 01 01 00 00       	jmp    5f0c <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5e0b:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e0e:	8b 10                	mov    (%eax),%edx
    5e10:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e13:	01 d0                	add    %edx,%eax
    5e15:	0f b6 00             	movzbl (%eax),%eax
    5e18:	0f b6 d0             	movzbl %al,%edx
    5e1b:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e1e:	8b 00                	mov    (%eax),%eax
    5e20:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5e23:	83 c1 01             	add    $0x1,%ecx
    5e26:	01 c8                	add    %ecx,%eax
    5e28:	0f b6 00             	movzbl (%eax),%eax
    5e2b:	0f b6 c0             	movzbl %al,%eax
    5e2e:	c1 e0 08             	shl    $0x8,%eax
    5e31:	01 d0                	add    %edx,%eax
    5e33:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5e36:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5e3a:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e3d:	8b 10                	mov    (%eax),%edx
    5e3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e42:	01 d0                	add    %edx,%eax
    5e44:	0f b6 00             	movzbl (%eax),%eax
    5e47:	0f b6 d0             	movzbl %al,%edx
    5e4a:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e4d:	8b 00                	mov    (%eax),%eax
    5e4f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5e52:	83 c1 01             	add    $0x1,%ecx
    5e55:	01 c8                	add    %ecx,%eax
    5e57:	0f b6 00             	movzbl (%eax),%eax
    5e5a:	0f b6 c0             	movzbl %al,%eax
    5e5d:	c1 e0 08             	shl    $0x8,%eax
    5e60:	01 d0                	add    %edx,%eax
    5e62:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5e65:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    5e69:	8b 45 10             	mov    0x10(%ebp),%eax
    5e6c:	8b 40 04             	mov    0x4(%eax),%eax
    5e6f:	85 c0                	test   %eax,%eax
    5e71:	75 19                	jne    5e8c <inflateNoCompression+0xbc>
    5e73:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5e76:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5e79:	01 d0                	add    %edx,%eax
    5e7b:	3d ff ff 00 00       	cmp    $0xffff,%eax
    5e80:	74 0a                	je     5e8c <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    5e82:	b8 15 00 00 00       	mov    $0x15,%eax
    5e87:	e9 80 00 00 00       	jmp    5f0c <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    5e8c:	8b 45 08             	mov    0x8(%ebp),%eax
    5e8f:	8b 40 04             	mov    0x4(%eax),%eax
    5e92:	89 c2                	mov    %eax,%edx
    5e94:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e97:	01 d0                	add    %edx,%eax
    5e99:	50                   	push   %eax
    5e9a:	ff 75 08             	pushl  0x8(%ebp)
    5e9d:	e8 f9 d6 ff ff       	call   359b <ucvector_resize>
    5ea2:	83 c4 08             	add    $0x8,%esp
    5ea5:	85 c0                	test   %eax,%eax
    5ea7:	75 07                	jne    5eb0 <inflateNoCompression+0xe0>
    5ea9:	b8 53 00 00 00       	mov    $0x53,%eax
    5eae:	eb 5c                	jmp    5f0c <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    5eb0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5eb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5eb6:	01 c2                	add    %eax,%edx
    5eb8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5ebb:	39 c2                	cmp    %eax,%edx
    5ebd:	76 07                	jbe    5ec6 <inflateNoCompression+0xf6>
    5ebf:	b8 17 00 00 00       	mov    $0x17,%eax
    5ec4:	eb 46                	jmp    5f0c <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    5ec6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ec9:	8b 55 0c             	mov    0xc(%ebp),%edx
    5ecc:	8b 0a                	mov    (%edx),%ecx
    5ece:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5ed1:	01 d1                	add    %edx,%ecx
    5ed3:	8b 55 08             	mov    0x8(%ebp),%edx
    5ed6:	8b 1a                	mov    (%edx),%ebx
    5ed8:	8b 55 08             	mov    0x8(%ebp),%edx
    5edb:	8b 52 04             	mov    0x4(%edx),%edx
    5ede:	2b 55 ec             	sub    -0x14(%ebp),%edx
    5ee1:	01 da                	add    %ebx,%edx
    5ee3:	50                   	push   %eax
    5ee4:	51                   	push   %ecx
    5ee5:	52                   	push   %edx
    5ee6:	e8 94 d4 ff ff       	call   337f <lodepng_memcpy>
    5eeb:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    5eee:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5ef1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ef4:	01 d0                	add    %edx,%eax
    5ef6:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    5ef9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5efc:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    5f03:	8b 45 0c             	mov    0xc(%ebp),%eax
    5f06:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    5f09:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5f0c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5f0f:	c9                   	leave  
    5f10:	c3                   	ret    

00005f11 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    5f11:	55                   	push   %ebp
    5f12:	89 e5                	mov    %esp,%ebp
    5f14:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    5f17:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    5f1e:	ff 75 10             	pushl  0x10(%ebp)
    5f21:	ff 75 0c             	pushl  0xc(%ebp)
    5f24:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f27:	50                   	push   %eax
    5f28:	e8 77 db ff ff       	call   3aa4 <LodePNGBitReader_init>
    5f2d:	83 c4 0c             	add    $0xc,%esp
    5f30:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    5f33:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5f37:	0f 84 b9 00 00 00    	je     5ff6 <lodepng_inflatev+0xe5>
    5f3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f40:	e9 c1 00 00 00       	jmp    6006 <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    5f45:	6a 03                	push   $0x3
    5f47:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f4a:	50                   	push   %eax
    5f4b:	e8 c5 db ff ff       	call   3b15 <ensureBits9>
    5f50:	83 c4 08             	add    $0x8,%esp
    5f53:	85 c0                	test   %eax,%eax
    5f55:	75 0a                	jne    5f61 <lodepng_inflatev+0x50>
    5f57:	b8 34 00 00 00       	mov    $0x34,%eax
    5f5c:	e9 a5 00 00 00       	jmp    6006 <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    5f61:	6a 01                	push   $0x1
    5f63:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f66:	50                   	push   %eax
    5f67:	e8 61 e1 ff ff       	call   40cd <readBits>
    5f6c:	83 c4 08             	add    $0x8,%esp
    5f6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    5f72:	6a 02                	push   $0x2
    5f74:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f77:	50                   	push   %eax
    5f78:	e8 50 e1 ff ff       	call   40cd <readBits>
    5f7d:	83 c4 08             	add    $0x8,%esp
    5f80:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    5f83:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    5f87:	75 07                	jne    5f90 <lodepng_inflatev+0x7f>
    5f89:	b8 14 00 00 00       	mov    $0x14,%eax
    5f8e:	eb 76                	jmp    6006 <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    5f90:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5f94:	75 17                	jne    5fad <lodepng_inflatev+0x9c>
    5f96:	ff 75 14             	pushl  0x14(%ebp)
    5f99:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f9c:	50                   	push   %eax
    5f9d:	ff 75 08             	pushl  0x8(%ebp)
    5fa0:	e8 2b fe ff ff       	call   5dd0 <inflateNoCompression>
    5fa5:	83 c4 0c             	add    $0xc,%esp
    5fa8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    5fab:	eb 1c                	jmp    5fc9 <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    5fad:	8b 45 14             	mov    0x14(%ebp),%eax
    5fb0:	8b 40 08             	mov    0x8(%eax),%eax
    5fb3:	50                   	push   %eax
    5fb4:	ff 75 ec             	pushl  -0x14(%ebp)
    5fb7:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5fba:	50                   	push   %eax
    5fbb:	ff 75 08             	pushl  0x8(%ebp)
    5fbe:	e8 f9 fa ff ff       	call   5abc <inflateHuffmanBlock>
    5fc3:	83 c4 10             	add    $0x10,%esp
    5fc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    5fc9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5fcd:	75 21                	jne    5ff0 <lodepng_inflatev+0xdf>
    5fcf:	8b 45 14             	mov    0x14(%ebp),%eax
    5fd2:	8b 40 08             	mov    0x8(%eax),%eax
    5fd5:	85 c0                	test   %eax,%eax
    5fd7:	74 17                	je     5ff0 <lodepng_inflatev+0xdf>
    5fd9:	8b 45 08             	mov    0x8(%ebp),%eax
    5fdc:	8b 50 04             	mov    0x4(%eax),%edx
    5fdf:	8b 45 14             	mov    0x14(%ebp),%eax
    5fe2:	8b 40 08             	mov    0x8(%eax),%eax
    5fe5:	39 c2                	cmp    %eax,%edx
    5fe7:	7e 07                	jle    5ff0 <lodepng_inflatev+0xdf>
    5fe9:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    5ff0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5ff4:	75 0c                	jne    6002 <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    5ff6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5ffa:	0f 84 45 ff ff ff    	je     5f45 <lodepng_inflatev+0x34>
    6000:	eb 01                	jmp    6003 <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    6002:	90                   	nop
  }

  return error;
    6003:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    6006:	c9                   	leave  
    6007:	c3                   	ret    

00006008 <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    6008:	55                   	push   %ebp
    6009:	89 e5                	mov    %esp,%ebp
    600b:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    600e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6011:	8b 08                	mov    (%eax),%ecx
    6013:	8b 45 08             	mov    0x8(%ebp),%eax
    6016:	8b 10                	mov    (%eax),%edx
    6018:	8d 45 e8             	lea    -0x18(%ebp),%eax
    601b:	51                   	push   %ecx
    601c:	52                   	push   %edx
    601d:	50                   	push   %eax
    601e:	e8 df d5 ff ff       	call   3602 <ucvector_init>
    6023:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    6026:	ff 75 18             	pushl  0x18(%ebp)
    6029:	ff 75 14             	pushl  0x14(%ebp)
    602c:	ff 75 10             	pushl  0x10(%ebp)
    602f:	8d 45 e8             	lea    -0x18(%ebp),%eax
    6032:	50                   	push   %eax
    6033:	e8 d9 fe ff ff       	call   5f11 <lodepng_inflatev>
    6038:	83 c4 10             	add    $0x10,%esp
    603b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    603e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6041:	8b 45 08             	mov    0x8(%ebp),%eax
    6044:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    6046:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6049:	8b 45 0c             	mov    0xc(%ebp),%eax
    604c:	89 10                	mov    %edx,(%eax)
  return error;
    604e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6051:	c9                   	leave  
    6052:	c3                   	ret    

00006053 <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    6053:	55                   	push   %ebp
    6054:	89 e5                	mov    %esp,%ebp
    6056:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    6059:	8b 45 14             	mov    0x14(%ebp),%eax
    605c:	8b 40 10             	mov    0x10(%eax),%eax
    605f:	85 c0                	test   %eax,%eax
    6061:	74 64                	je     60c7 <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    6063:	8b 45 14             	mov    0x14(%ebp),%eax
    6066:	8b 40 10             	mov    0x10(%eax),%eax
    6069:	8b 55 08             	mov    0x8(%ebp),%edx
    606c:	8d 4a 04             	lea    0x4(%edx),%ecx
    606f:	8b 55 08             	mov    0x8(%ebp),%edx
    6072:	83 ec 0c             	sub    $0xc,%esp
    6075:	ff 75 14             	pushl  0x14(%ebp)
    6078:	ff 75 10             	pushl  0x10(%ebp)
    607b:	ff 75 0c             	pushl  0xc(%ebp)
    607e:	51                   	push   %ecx
    607f:	52                   	push   %edx
    6080:	ff d0                	call   *%eax
    6082:	83 c4 20             	add    $0x20,%esp
    6085:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    6088:	8b 45 08             	mov    0x8(%ebp),%eax
    608b:	8b 50 04             	mov    0x4(%eax),%edx
    608e:	8b 45 08             	mov    0x8(%ebp),%eax
    6091:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    6094:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6098:	74 28                	je     60c2 <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    609a:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    60a1:	8b 45 14             	mov    0x14(%ebp),%eax
    60a4:	8b 40 08             	mov    0x8(%eax),%eax
    60a7:	85 c0                	test   %eax,%eax
    60a9:	74 17                	je     60c2 <inflatev+0x6f>
    60ab:	8b 45 08             	mov    0x8(%ebp),%eax
    60ae:	8b 50 04             	mov    0x4(%eax),%edx
    60b1:	8b 45 14             	mov    0x14(%ebp),%eax
    60b4:	8b 40 08             	mov    0x8(%eax),%eax
    60b7:	39 c2                	cmp    %eax,%edx
    60b9:	7e 07                	jle    60c2 <inflatev+0x6f>
    60bb:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    60c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60c5:	eb 14                	jmp    60db <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    60c7:	ff 75 14             	pushl  0x14(%ebp)
    60ca:	ff 75 10             	pushl  0x10(%ebp)
    60cd:	ff 75 0c             	pushl  0xc(%ebp)
    60d0:	ff 75 08             	pushl  0x8(%ebp)
    60d3:	e8 39 fe ff ff       	call   5f11 <lodepng_inflatev>
    60d8:	83 c4 10             	add    $0x10,%esp
  }
}
    60db:	c9                   	leave  
    60dc:	c3                   	ret    

000060dd <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    60dd:	55                   	push   %ebp
    60de:	89 e5                	mov    %esp,%ebp
    60e0:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    60e3:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    60ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    60ed:	83 e8 01             	sub    $0x1,%eax
    60f0:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    60f3:	eb 39                	jmp    612e <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    60f5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    60f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    60fb:	01 d0                	add    %edx,%eax
    60fd:	d1 f8                	sar    %eax
    60ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    6102:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6105:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    610c:	8b 45 08             	mov    0x8(%ebp),%eax
    610f:	01 d0                	add    %edx,%eax
    6111:	8b 10                	mov    (%eax),%edx
    6113:	8b 45 10             	mov    0x10(%ebp),%eax
    6116:	39 c2                	cmp    %eax,%edx
    6118:	72 0b                	jb     6125 <searchCodeIndex+0x48>
    611a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    611d:	83 e8 01             	sub    $0x1,%eax
    6120:	89 45 f8             	mov    %eax,-0x8(%ebp)
    6123:	eb 09                	jmp    612e <searchCodeIndex+0x51>
    else left = mid + 1;
    6125:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6128:	83 c0 01             	add    $0x1,%eax
    612b:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    612e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6131:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6134:	7e bf                	jle    60f5 <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    6136:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6139:	3b 45 0c             	cmp    0xc(%ebp),%eax
    613c:	7d 18                	jge    6156 <searchCodeIndex+0x79>
    613e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6141:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6148:	8b 45 08             	mov    0x8(%ebp),%eax
    614b:	01 d0                	add    %edx,%eax
    614d:	8b 10                	mov    (%eax),%edx
    614f:	8b 45 10             	mov    0x10(%ebp),%eax
    6152:	39 c2                	cmp    %eax,%edx
    6154:	76 04                	jbe    615a <searchCodeIndex+0x7d>
    6156:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    615a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    615d:	c9                   	leave  
    615e:	c3                   	ret    

0000615f <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    615f:	55                   	push   %ebp
    6160:	89 e5                	mov    %esp,%ebp
    6162:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    6165:	ff 75 0c             	pushl  0xc(%ebp)
    6168:	6a 1d                	push   $0x1d
    616a:	68 60 9d 01 00       	push   $0x19d60
    616f:	e8 69 ff ff ff       	call   60dd <searchCodeIndex>
    6174:	83 c4 0c             	add    $0xc,%esp
    6177:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    617a:	8b 55 0c             	mov    0xc(%ebp),%edx
    617d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6180:	8b 04 85 60 9d 01 00 	mov    0x19d60(,%eax,4),%eax
    6187:	29 c2                	sub    %eax,%edx
    6189:	89 d0                	mov    %edx,%eax
    618b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    618e:	ff 75 10             	pushl  0x10(%ebp)
    6191:	6a 1e                	push   $0x1e
    6193:	68 60 9e 01 00       	push   $0x19e60
    6198:	e8 40 ff ff ff       	call   60dd <searchCodeIndex>
    619d:	83 c4 0c             	add    $0xc,%esp
    61a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    61a3:	8b 55 10             	mov    0x10(%ebp),%edx
    61a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    61a9:	8b 04 85 60 9e 01 00 	mov    0x19e60(,%eax,4),%eax
    61b0:	29 c2                	sub    %eax,%edx
    61b2:	89 d0                	mov    %edx,%eax
    61b4:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    61b7:	8b 45 08             	mov    0x8(%ebp),%eax
    61ba:	8b 40 04             	mov    0x4(%eax),%eax
    61bd:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    61c0:	8b 45 08             	mov    0x8(%ebp),%eax
    61c3:	8b 40 04             	mov    0x4(%eax),%eax
    61c6:	83 c0 04             	add    $0x4,%eax
    61c9:	50                   	push   %eax
    61ca:	ff 75 08             	pushl  0x8(%ebp)
    61cd:	e8 f0 d2 ff ff       	call   34c2 <uivector_resize>
    61d2:	83 c4 08             	add    $0x8,%esp
    61d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    61d8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    61dc:	74 57                	je     6235 <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    61de:	8b 45 08             	mov    0x8(%ebp),%eax
    61e1:	8b 00                	mov    (%eax),%eax
    61e3:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61e6:	c1 e2 02             	shl    $0x2,%edx
    61e9:	01 d0                	add    %edx,%eax
    61eb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    61ee:	81 c2 01 01 00 00    	add    $0x101,%edx
    61f4:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    61f6:	8b 45 08             	mov    0x8(%ebp),%eax
    61f9:	8b 00                	mov    (%eax),%eax
    61fb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61fe:	83 c2 01             	add    $0x1,%edx
    6201:	c1 e2 02             	shl    $0x2,%edx
    6204:	01 c2                	add    %eax,%edx
    6206:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6209:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    620b:	8b 45 08             	mov    0x8(%ebp),%eax
    620e:	8b 00                	mov    (%eax),%eax
    6210:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6213:	83 c2 02             	add    $0x2,%edx
    6216:	c1 e2 02             	shl    $0x2,%edx
    6219:	01 c2                	add    %eax,%edx
    621b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    621e:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    6220:	8b 45 08             	mov    0x8(%ebp),%eax
    6223:	8b 00                	mov    (%eax),%eax
    6225:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6228:	83 c2 03             	add    $0x3,%edx
    622b:	c1 e2 02             	shl    $0x2,%edx
    622e:	01 c2                	add    %eax,%edx
    6230:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6233:	89 02                	mov    %eax,(%edx)
  }
}
    6235:	90                   	nop
    6236:	c9                   	leave  
    6237:	c3                   	ret    

00006238 <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    6238:	55                   	push   %ebp
    6239:	89 e5                	mov    %esp,%ebp
    623b:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    623e:	b8 00 00 01 00       	mov    $0x10000,%eax
    6243:	c1 e0 02             	shl    $0x2,%eax
    6246:	83 ec 0c             	sub    $0xc,%esp
    6249:	50                   	push   %eax
    624a:	e8 f2 d0 ff ff       	call   3341 <lodepng_malloc>
    624f:	83 c4 10             	add    $0x10,%esp
    6252:	89 c2                	mov    %eax,%edx
    6254:	8b 45 08             	mov    0x8(%ebp),%eax
    6257:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    6259:	8b 45 0c             	mov    0xc(%ebp),%eax
    625c:	c1 e0 02             	shl    $0x2,%eax
    625f:	83 ec 0c             	sub    $0xc,%esp
    6262:	50                   	push   %eax
    6263:	e8 d9 d0 ff ff       	call   3341 <lodepng_malloc>
    6268:	83 c4 10             	add    $0x10,%esp
    626b:	89 c2                	mov    %eax,%edx
    626d:	8b 45 08             	mov    0x8(%ebp),%eax
    6270:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6273:	8b 45 0c             	mov    0xc(%ebp),%eax
    6276:	01 c0                	add    %eax,%eax
    6278:	83 ec 0c             	sub    $0xc,%esp
    627b:	50                   	push   %eax
    627c:	e8 c0 d0 ff ff       	call   3341 <lodepng_malloc>
    6281:	83 c4 10             	add    $0x10,%esp
    6284:	89 c2                	mov    %eax,%edx
    6286:	8b 45 08             	mov    0x8(%ebp),%eax
    6289:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    628c:	8b 45 0c             	mov    0xc(%ebp),%eax
    628f:	01 c0                	add    %eax,%eax
    6291:	83 ec 0c             	sub    $0xc,%esp
    6294:	50                   	push   %eax
    6295:	e8 a7 d0 ff ff       	call   3341 <lodepng_malloc>
    629a:	83 c4 10             	add    $0x10,%esp
    629d:	89 c2                	mov    %eax,%edx
    629f:	8b 45 08             	mov    0x8(%ebp),%eax
    62a2:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    62a5:	b8 02 01 00 00       	mov    $0x102,%eax
    62aa:	83 c0 01             	add    $0x1,%eax
    62ad:	c1 e0 02             	shl    $0x2,%eax
    62b0:	83 ec 0c             	sub    $0xc,%esp
    62b3:	50                   	push   %eax
    62b4:	e8 88 d0 ff ff       	call   3341 <lodepng_malloc>
    62b9:	83 c4 10             	add    $0x10,%esp
    62bc:	89 c2                	mov    %eax,%edx
    62be:	8b 45 08             	mov    0x8(%ebp),%eax
    62c1:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    62c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    62c7:	01 c0                	add    %eax,%eax
    62c9:	83 ec 0c             	sub    $0xc,%esp
    62cc:	50                   	push   %eax
    62cd:	e8 6f d0 ff ff       	call   3341 <lodepng_malloc>
    62d2:	83 c4 10             	add    $0x10,%esp
    62d5:	89 c2                	mov    %eax,%edx
    62d7:	8b 45 08             	mov    0x8(%ebp),%eax
    62da:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    62dd:	8b 45 08             	mov    0x8(%ebp),%eax
    62e0:	8b 00                	mov    (%eax),%eax
    62e2:	85 c0                	test   %eax,%eax
    62e4:	74 32                	je     6318 <hash_init+0xe0>
    62e6:	8b 45 08             	mov    0x8(%ebp),%eax
    62e9:	8b 40 04             	mov    0x4(%eax),%eax
    62ec:	85 c0                	test   %eax,%eax
    62ee:	74 28                	je     6318 <hash_init+0xe0>
    62f0:	8b 45 08             	mov    0x8(%ebp),%eax
    62f3:	8b 40 08             	mov    0x8(%eax),%eax
    62f6:	85 c0                	test   %eax,%eax
    62f8:	74 1e                	je     6318 <hash_init+0xe0>
    62fa:	8b 45 08             	mov    0x8(%ebp),%eax
    62fd:	8b 40 0c             	mov    0xc(%eax),%eax
    6300:	85 c0                	test   %eax,%eax
    6302:	74 14                	je     6318 <hash_init+0xe0>
    6304:	8b 45 08             	mov    0x8(%ebp),%eax
    6307:	8b 40 10             	mov    0x10(%eax),%eax
    630a:	85 c0                	test   %eax,%eax
    630c:	74 0a                	je     6318 <hash_init+0xe0>
    630e:	8b 45 08             	mov    0x8(%ebp),%eax
    6311:	8b 40 14             	mov    0x14(%eax),%eax
    6314:	85 c0                	test   %eax,%eax
    6316:	75 0a                	jne    6322 <hash_init+0xea>
    return 83; /*alloc fail*/
    6318:	b8 53 00 00 00       	mov    $0x53,%eax
    631d:	e9 d3 00 00 00       	jmp    63f5 <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    6322:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6329:	eb 17                	jmp    6342 <hash_init+0x10a>
    632b:	8b 45 08             	mov    0x8(%ebp),%eax
    632e:	8b 00                	mov    (%eax),%eax
    6330:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6333:	c1 e2 02             	shl    $0x2,%edx
    6336:	01 d0                	add    %edx,%eax
    6338:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    633e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6342:	b8 00 00 01 00       	mov    $0x10000,%eax
    6347:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    634a:	75 df                	jne    632b <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    634c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6353:	eb 18                	jmp    636d <hash_init+0x135>
    6355:	8b 45 08             	mov    0x8(%ebp),%eax
    6358:	8b 40 08             	mov    0x8(%eax),%eax
    635b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    635e:	c1 e2 02             	shl    $0x2,%edx
    6361:	01 d0                	add    %edx,%eax
    6363:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6369:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    636d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6370:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6373:	75 e0                	jne    6355 <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    6375:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    637c:	eb 17                	jmp    6395 <hash_init+0x15d>
    637e:	8b 45 08             	mov    0x8(%ebp),%eax
    6381:	8b 40 04             	mov    0x4(%eax),%eax
    6384:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6387:	01 d2                	add    %edx,%edx
    6389:	01 d0                	add    %edx,%eax
    638b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    638e:	66 89 10             	mov    %dx,(%eax)
    6391:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6395:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6398:	3b 45 0c             	cmp    0xc(%ebp),%eax
    639b:	75 e1                	jne    637e <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    639d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    63a4:	eb 18                	jmp    63be <hash_init+0x186>
    63a6:	8b 45 08             	mov    0x8(%ebp),%eax
    63a9:	8b 40 0c             	mov    0xc(%eax),%eax
    63ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63af:	c1 e2 02             	shl    $0x2,%edx
    63b2:	01 d0                	add    %edx,%eax
    63b4:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    63ba:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    63be:	b8 02 01 00 00       	mov    $0x102,%eax
    63c3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    63c6:	76 de                	jbe    63a6 <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    63c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    63cf:	eb 17                	jmp    63e8 <hash_init+0x1b0>
    63d1:	8b 45 08             	mov    0x8(%ebp),%eax
    63d4:	8b 40 10             	mov    0x10(%eax),%eax
    63d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63da:	01 d2                	add    %edx,%edx
    63dc:	01 d0                	add    %edx,%eax
    63de:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63e1:	66 89 10             	mov    %dx,(%eax)
    63e4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    63e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63eb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    63ee:	75 e1                	jne    63d1 <hash_init+0x199>

  return 0;
    63f0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    63f5:	c9                   	leave  
    63f6:	c3                   	ret    

000063f7 <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    63f7:	55                   	push   %ebp
    63f8:	89 e5                	mov    %esp,%ebp
    63fa:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    63fd:	8b 45 08             	mov    0x8(%ebp),%eax
    6400:	8b 00                	mov    (%eax),%eax
    6402:	83 ec 0c             	sub    $0xc,%esp
    6405:	50                   	push   %eax
    6406:	e8 57 cf ff ff       	call   3362 <lodepng_free>
    640b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    640e:	8b 45 08             	mov    0x8(%ebp),%eax
    6411:	8b 40 08             	mov    0x8(%eax),%eax
    6414:	83 ec 0c             	sub    $0xc,%esp
    6417:	50                   	push   %eax
    6418:	e8 45 cf ff ff       	call   3362 <lodepng_free>
    641d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    6420:	8b 45 08             	mov    0x8(%ebp),%eax
    6423:	8b 40 04             	mov    0x4(%eax),%eax
    6426:	83 ec 0c             	sub    $0xc,%esp
    6429:	50                   	push   %eax
    642a:	e8 33 cf ff ff       	call   3362 <lodepng_free>
    642f:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    6432:	8b 45 08             	mov    0x8(%ebp),%eax
    6435:	8b 40 14             	mov    0x14(%eax),%eax
    6438:	83 ec 0c             	sub    $0xc,%esp
    643b:	50                   	push   %eax
    643c:	e8 21 cf ff ff       	call   3362 <lodepng_free>
    6441:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    6444:	8b 45 08             	mov    0x8(%ebp),%eax
    6447:	8b 40 0c             	mov    0xc(%eax),%eax
    644a:	83 ec 0c             	sub    $0xc,%esp
    644d:	50                   	push   %eax
    644e:	e8 0f cf ff ff       	call   3362 <lodepng_free>
    6453:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    6456:	8b 45 08             	mov    0x8(%ebp),%eax
    6459:	8b 40 10             	mov    0x10(%eax),%eax
    645c:	83 ec 0c             	sub    $0xc,%esp
    645f:	50                   	push   %eax
    6460:	e8 fd ce ff ff       	call   3362 <lodepng_free>
    6465:	83 c4 10             	add    $0x10,%esp
}
    6468:	90                   	nop
    6469:	c9                   	leave  
    646a:	c3                   	ret    

0000646b <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    646b:	55                   	push   %ebp
    646c:	89 e5                	mov    %esp,%ebp
    646e:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    6471:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    6478:	8b 45 10             	mov    0x10(%ebp),%eax
    647b:	83 c0 02             	add    $0x2,%eax
    647e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6481:	7d 41                	jge    64c4 <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    6483:	8b 55 10             	mov    0x10(%ebp),%edx
    6486:	8b 45 08             	mov    0x8(%ebp),%eax
    6489:	01 d0                	add    %edx,%eax
    648b:	0f b6 00             	movzbl (%eax),%eax
    648e:	0f b6 c0             	movzbl %al,%eax
    6491:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    6494:	8b 45 10             	mov    0x10(%ebp),%eax
    6497:	8d 50 01             	lea    0x1(%eax),%edx
    649a:	8b 45 08             	mov    0x8(%ebp),%eax
    649d:	01 d0                	add    %edx,%eax
    649f:	0f b6 00             	movzbl (%eax),%eax
    64a2:	0f b6 c0             	movzbl %al,%eax
    64a5:	c1 e0 04             	shl    $0x4,%eax
    64a8:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    64ab:	8b 45 10             	mov    0x10(%ebp),%eax
    64ae:	8d 50 02             	lea    0x2(%eax),%edx
    64b1:	8b 45 08             	mov    0x8(%ebp),%eax
    64b4:	01 d0                	add    %edx,%eax
    64b6:	0f b6 00             	movzbl (%eax),%eax
    64b9:	0f b6 c0             	movzbl %al,%eax
    64bc:	c1 e0 08             	shl    $0x8,%eax
    64bf:	31 45 fc             	xor    %eax,-0x4(%ebp)
    64c2:	eb 51                	jmp    6515 <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    64c4:	8b 45 10             	mov    0x10(%ebp),%eax
    64c7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    64ca:	7c 07                	jl     64d3 <getHash+0x68>
    64cc:	b8 00 00 00 00       	mov    $0x0,%eax
    64d1:	eb 4a                	jmp    651d <getHash+0xb2>
    amount = size - pos;
    64d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    64d6:	2b 45 10             	sub    0x10(%ebp),%eax
    64d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    64dc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    64e3:	eb 28                	jmp    650d <getHash+0xa2>
    64e5:	8b 55 10             	mov    0x10(%ebp),%edx
    64e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64eb:	01 d0                	add    %edx,%eax
    64ed:	89 c2                	mov    %eax,%edx
    64ef:	8b 45 08             	mov    0x8(%ebp),%eax
    64f2:	01 d0                	add    %edx,%eax
    64f4:	0f b6 00             	movzbl (%eax),%eax
    64f7:	0f b6 d0             	movzbl %al,%edx
    64fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64fd:	c1 e0 03             	shl    $0x3,%eax
    6500:	89 c1                	mov    %eax,%ecx
    6502:	d3 e2                	shl    %cl,%edx
    6504:	89 d0                	mov    %edx,%eax
    6506:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6509:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    650d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6510:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    6513:	75 d0                	jne    64e5 <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    6515:	b8 ff ff 00 00       	mov    $0xffff,%eax
    651a:	23 45 fc             	and    -0x4(%ebp),%eax
}
    651d:	c9                   	leave  
    651e:	c3                   	ret    

0000651f <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    651f:	55                   	push   %ebp
    6520:	89 e5                	mov    %esp,%ebp
    6522:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    6525:	8b 55 10             	mov    0x10(%ebp),%edx
    6528:	8b 45 08             	mov    0x8(%ebp),%eax
    652b:	01 d0                	add    %edx,%eax
    652d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    6530:	b8 02 01 00 00       	mov    $0x102,%eax
    6535:	89 c2                	mov    %eax,%edx
    6537:	8b 45 f8             	mov    -0x8(%ebp),%eax
    653a:	01 d0                	add    %edx,%eax
    653c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    653f:	8b 55 0c             	mov    0xc(%ebp),%edx
    6542:	8b 45 08             	mov    0x8(%ebp),%eax
    6545:	01 d0                	add    %edx,%eax
    6547:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    654a:	73 0b                	jae    6557 <countZeros+0x38>
    654c:	8b 55 0c             	mov    0xc(%ebp),%edx
    654f:	8b 45 08             	mov    0x8(%ebp),%eax
    6552:	01 d0                	add    %edx,%eax
    6554:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    6557:	8b 45 f8             	mov    -0x8(%ebp),%eax
    655a:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    655d:	eb 04                	jmp    6563 <countZeros+0x44>
    655f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    6563:	8b 45 08             	mov    0x8(%ebp),%eax
    6566:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6569:	74 0a                	je     6575 <countZeros+0x56>
    656b:	8b 45 08             	mov    0x8(%ebp),%eax
    656e:	0f b6 00             	movzbl (%eax),%eax
    6571:	84 c0                	test   %al,%al
    6573:	74 ea                	je     655f <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    6575:	8b 55 08             	mov    0x8(%ebp),%edx
    6578:	8b 45 f8             	mov    -0x8(%ebp),%eax
    657b:	29 c2                	sub    %eax,%edx
    657d:	89 d0                	mov    %edx,%eax
}
    657f:	c9                   	leave  
    6580:	c3                   	ret    

00006581 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    6581:	55                   	push   %ebp
    6582:	89 e5                	mov    %esp,%ebp
    6584:	83 ec 04             	sub    $0x4,%esp
    6587:	8b 45 14             	mov    0x14(%ebp),%eax
    658a:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    658e:	8b 45 08             	mov    0x8(%ebp),%eax
    6591:	8b 40 08             	mov    0x8(%eax),%eax
    6594:	8b 55 0c             	mov    0xc(%ebp),%edx
    6597:	c1 e2 02             	shl    $0x2,%edx
    659a:	01 c2                	add    %eax,%edx
    659c:	8b 45 10             	mov    0x10(%ebp),%eax
    659f:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    65a1:	8b 45 08             	mov    0x8(%ebp),%eax
    65a4:	8b 00                	mov    (%eax),%eax
    65a6:	8b 55 10             	mov    0x10(%ebp),%edx
    65a9:	c1 e2 02             	shl    $0x2,%edx
    65ac:	01 d0                	add    %edx,%eax
    65ae:	8b 00                	mov    (%eax),%eax
    65b0:	83 f8 ff             	cmp    $0xffffffff,%eax
    65b3:	74 1f                	je     65d4 <updateHashChain+0x53>
    65b5:	8b 45 08             	mov    0x8(%ebp),%eax
    65b8:	8b 40 04             	mov    0x4(%eax),%eax
    65bb:	8b 55 0c             	mov    0xc(%ebp),%edx
    65be:	01 d2                	add    %edx,%edx
    65c0:	01 c2                	add    %eax,%edx
    65c2:	8b 45 08             	mov    0x8(%ebp),%eax
    65c5:	8b 00                	mov    (%eax),%eax
    65c7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    65ca:	c1 e1 02             	shl    $0x2,%ecx
    65cd:	01 c8                	add    %ecx,%eax
    65cf:	8b 00                	mov    (%eax),%eax
    65d1:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    65d4:	8b 45 08             	mov    0x8(%ebp),%eax
    65d7:	8b 00                	mov    (%eax),%eax
    65d9:	8b 55 10             	mov    0x10(%ebp),%edx
    65dc:	c1 e2 02             	shl    $0x2,%edx
    65df:	01 c2                	add    %eax,%edx
    65e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    65e4:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    65e6:	8b 45 08             	mov    0x8(%ebp),%eax
    65e9:	8b 40 14             	mov    0x14(%eax),%eax
    65ec:	8b 55 0c             	mov    0xc(%ebp),%edx
    65ef:	01 d2                	add    %edx,%edx
    65f1:	01 c2                	add    %eax,%edx
    65f3:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    65f7:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    65fa:	8b 45 08             	mov    0x8(%ebp),%eax
    65fd:	8b 40 0c             	mov    0xc(%eax),%eax
    6600:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    6604:	c1 e2 02             	shl    $0x2,%edx
    6607:	01 d0                	add    %edx,%eax
    6609:	8b 00                	mov    (%eax),%eax
    660b:	83 f8 ff             	cmp    $0xffffffff,%eax
    660e:	74 21                	je     6631 <updateHashChain+0xb0>
    6610:	8b 45 08             	mov    0x8(%ebp),%eax
    6613:	8b 40 10             	mov    0x10(%eax),%eax
    6616:	8b 55 0c             	mov    0xc(%ebp),%edx
    6619:	01 d2                	add    %edx,%edx
    661b:	01 c2                	add    %eax,%edx
    661d:	8b 45 08             	mov    0x8(%ebp),%eax
    6620:	8b 40 0c             	mov    0xc(%eax),%eax
    6623:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    6627:	c1 e1 02             	shl    $0x2,%ecx
    662a:	01 c8                	add    %ecx,%eax
    662c:	8b 00                	mov    (%eax),%eax
    662e:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    6631:	8b 45 08             	mov    0x8(%ebp),%eax
    6634:	8b 40 0c             	mov    0xc(%eax),%eax
    6637:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    663b:	c1 e2 02             	shl    $0x2,%edx
    663e:	01 c2                	add    %eax,%edx
    6640:	8b 45 0c             	mov    0xc(%ebp),%eax
    6643:	89 02                	mov    %eax,(%edx)
}
    6645:	90                   	nop
    6646:	c9                   	leave  
    6647:	c3                   	ret    

00006648 <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    6648:	55                   	push   %ebp
    6649:	89 e5                	mov    %esp,%ebp
    664b:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    664e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    6655:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    665c:	77 08                	ja     6666 <encodeLZ77+0x1e>
    665e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6661:	c1 e8 03             	shr    $0x3,%eax
    6664:	eb 03                	jmp    6669 <encodeLZ77+0x21>
    6666:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6669:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    666c:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6673:	76 07                	jbe    667c <encodeLZ77+0x34>
    6675:	b8 02 01 00 00       	mov    $0x102,%eax
    667a:	eb 05                	jmp    6681 <encodeLZ77+0x39>
    667c:	b8 40 00 00 00       	mov    $0x40,%eax
    6681:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    6684:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    668b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    6692:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    6699:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    66a0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    66a7:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    66ab:	74 09                	je     66b6 <encodeLZ77+0x6e>
    66ad:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    66b4:	76 0a                	jbe    66c0 <encodeLZ77+0x78>
    66b6:	b8 3c 00 00 00       	mov    $0x3c,%eax
    66bb:	e9 e3 04 00 00       	jmp    6ba3 <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    66c0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    66c3:	83 e8 01             	sub    $0x1,%eax
    66c6:	23 45 1c             	and    0x1c(%ebp),%eax
    66c9:	85 c0                	test   %eax,%eax
    66cb:	74 0a                	je     66d7 <encodeLZ77+0x8f>
    66cd:	b8 5a 00 00 00       	mov    $0x5a,%eax
    66d2:	e9 cc 04 00 00       	jmp    6ba3 <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    66d7:	b8 02 01 00 00       	mov    $0x102,%eax
    66dc:	39 45 24             	cmp    %eax,0x24(%ebp)
    66df:	76 08                	jbe    66e9 <encodeLZ77+0xa1>
    66e1:	b8 02 01 00 00       	mov    $0x102,%eax
    66e6:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    66e9:	8b 45 14             	mov    0x14(%ebp),%eax
    66ec:	89 45 fc             	mov    %eax,-0x4(%ebp)
    66ef:	e9 a0 04 00 00       	jmp    6b94 <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    66f4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    66f7:	8d 50 ff             	lea    -0x1(%eax),%edx
    66fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    66fd:	21 d0                	and    %edx,%eax
    66ff:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    6702:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    6709:	ff 75 fc             	pushl  -0x4(%ebp)
    670c:	ff 75 18             	pushl  0x18(%ebp)
    670f:	ff 75 10             	pushl  0x10(%ebp)
    6712:	e8 54 fd ff ff       	call   646b <getHash>
    6717:	83 c4 0c             	add    $0xc,%esp
    671a:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    671d:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6721:	74 4e                	je     6771 <encodeLZ77+0x129>
    6723:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6727:	75 48                	jne    6771 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6729:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    672d:	75 16                	jne    6745 <encodeLZ77+0xfd>
    672f:	ff 75 fc             	pushl  -0x4(%ebp)
    6732:	ff 75 18             	pushl  0x18(%ebp)
    6735:	ff 75 10             	pushl  0x10(%ebp)
    6738:	e8 e2 fd ff ff       	call   651f <countZeros>
    673d:	83 c4 0c             	add    $0xc,%esp
    6740:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6743:	eb 35                	jmp    677a <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6745:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6748:	8b 45 f0             	mov    -0x10(%ebp),%eax
    674b:	01 c2                	add    %eax,%edx
    674d:	8b 45 18             	mov    0x18(%ebp),%eax
    6750:	39 c2                	cmp    %eax,%edx
    6752:	77 17                	ja     676b <encodeLZ77+0x123>
    6754:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6757:	8b 45 f0             	mov    -0x10(%ebp),%eax
    675a:	01 d0                	add    %edx,%eax
    675c:	8d 50 ff             	lea    -0x1(%eax),%edx
    675f:	8b 45 10             	mov    0x10(%ebp),%eax
    6762:	01 d0                	add    %edx,%eax
    6764:	0f b6 00             	movzbl (%eax),%eax
    6767:	84 c0                	test   %al,%al
    6769:	74 0f                	je     677a <encodeLZ77+0x132>
    676b:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    676f:	eb 09                	jmp    677a <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    6771:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6778:	eb 01                	jmp    677b <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    677a:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    677b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    677e:	0f b7 c0             	movzwl %ax,%eax
    6781:	50                   	push   %eax
    6782:	ff 75 b0             	pushl  -0x50(%ebp)
    6785:	ff 75 b4             	pushl  -0x4c(%ebp)
    6788:	ff 75 0c             	pushl  0xc(%ebp)
    678b:	e8 f1 fd ff ff       	call   6581 <updateHashChain>
    6790:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    6793:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    679a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    67a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    67a4:	8b 40 04             	mov    0x4(%eax),%eax
    67a7:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    67aa:	01 d2                	add    %edx,%edx
    67ac:	01 d0                	add    %edx,%eax
    67ae:	0f b7 00             	movzwl (%eax),%eax
    67b1:	0f b7 c0             	movzwl %ax,%eax
    67b4:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    67b7:	ba 02 01 00 00       	mov    $0x102,%edx
    67bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    67bf:	01 c2                	add    %eax,%edx
    67c1:	8b 45 18             	mov    0x18(%ebp),%eax
    67c4:	39 c2                	cmp    %eax,%edx
    67c6:	0f 4e c2             	cmovle %edx,%eax
    67c9:	89 c2                	mov    %eax,%edx
    67cb:	8b 45 10             	mov    0x10(%ebp),%eax
    67ce:	01 d0                	add    %edx,%eax
    67d0:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    67d3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    67da:	8b 45 c8             	mov    -0x38(%ebp),%eax
    67dd:	8d 50 01             	lea    0x1(%eax),%edx
    67e0:	89 55 c8             	mov    %edx,-0x38(%ebp)
    67e3:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    67e6:	0f 83 67 01 00 00    	jae    6953 <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    67ec:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    67ef:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    67f2:	77 08                	ja     67fc <encodeLZ77+0x1b4>
    67f4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    67f7:	2b 45 cc             	sub    -0x34(%ebp),%eax
    67fa:	eb 0d                	jmp    6809 <encodeLZ77+0x1c1>
    67fc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    67ff:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6802:	89 c2                	mov    %eax,%edx
    6804:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6807:	01 d0                	add    %edx,%eax
    6809:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    680c:	8b 45 a8             	mov    -0x58(%ebp),%eax
    680f:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6812:	0f 82 3e 01 00 00    	jb     6956 <encodeLZ77+0x30e>
      prev_offset = current_offset;
    6818:	8b 45 a8             	mov    -0x58(%ebp),%eax
    681b:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    681e:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    6822:	0f 84 a3 00 00 00    	je     68cb <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    6828:	8b 55 fc             	mov    -0x4(%ebp),%edx
    682b:	8b 45 10             	mov    0x10(%ebp),%eax
    682e:	01 d0                	add    %edx,%eax
    6830:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    6833:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6836:	2b 45 a8             	sub    -0x58(%ebp),%eax
    6839:	89 c2                	mov    %eax,%edx
    683b:	8b 45 10             	mov    0x10(%ebp),%eax
    683e:	01 d0                	add    %edx,%eax
    6840:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    6843:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6847:	76 3a                	jbe    6883 <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    6849:	8b 45 0c             	mov    0xc(%ebp),%eax
    684c:	8b 40 14             	mov    0x14(%eax),%eax
    684f:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6852:	01 d2                	add    %edx,%edx
    6854:	01 d0                	add    %edx,%eax
    6856:	0f b7 00             	movzwl (%eax),%eax
    6859:	0f b7 c0             	movzwl %ax,%eax
    685c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    685f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6862:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6865:	76 06                	jbe    686d <encodeLZ77+0x225>
    6867:	8b 45 f0             	mov    -0x10(%ebp),%eax
    686a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    686d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6870:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    6873:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6876:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6879:	eb 08                	jmp    6883 <encodeLZ77+0x23b>
          ++backptr;
    687b:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    687f:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6883:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6886:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    6889:	74 10                	je     689b <encodeLZ77+0x253>
    688b:	8b 45 d0             	mov    -0x30(%ebp),%eax
    688e:	0f b6 10             	movzbl (%eax),%edx
    6891:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6894:	0f b6 00             	movzbl (%eax),%eax
    6897:	38 c2                	cmp    %al,%dl
    6899:	74 e0                	je     687b <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    689b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    689e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    68a1:	8b 55 10             	mov    0x10(%ebp),%edx
    68a4:	01 ca                	add    %ecx,%edx
    68a6:	29 d0                	sub    %edx,%eax
    68a8:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    68ab:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    68ae:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    68b1:	76 18                	jbe    68cb <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    68b3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    68b6:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    68b9:	8b 45 a8             	mov    -0x58(%ebp),%eax
    68bc:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    68bf:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    68c2:	3b 45 24             	cmp    0x24(%ebp),%eax
    68c5:	0f 83 8e 00 00 00    	jae    6959 <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    68cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    68ce:	8b 40 04             	mov    0x4(%eax),%eax
    68d1:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68d4:	01 d2                	add    %edx,%edx
    68d6:	01 d0                	add    %edx,%eax
    68d8:	0f b7 00             	movzwl (%eax),%eax
    68db:	0f b7 c0             	movzwl %ax,%eax
    68de:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    68e1:	74 79                	je     695c <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    68e3:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    68e7:	76 38                	jbe    6921 <encodeLZ77+0x2d9>
    68e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    68ec:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    68ef:	76 30                	jbe    6921 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    68f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    68f4:	8b 40 10             	mov    0x10(%eax),%eax
    68f7:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68fa:	01 d2                	add    %edx,%edx
    68fc:	01 d0                	add    %edx,%eax
    68fe:	0f b7 00             	movzwl (%eax),%eax
    6901:	0f b7 c0             	movzwl %ax,%eax
    6904:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    6907:	8b 45 0c             	mov    0xc(%ebp),%eax
    690a:	8b 40 14             	mov    0x14(%eax),%eax
    690d:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6910:	01 d2                	add    %edx,%edx
    6912:	01 d0                	add    %edx,%eax
    6914:	0f b7 00             	movzwl (%eax),%eax
    6917:	0f b7 c0             	movzwl %ax,%eax
    691a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    691d:	74 2f                	je     694e <encodeLZ77+0x306>
    691f:	eb 3f                	jmp    6960 <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    6921:	8b 45 0c             	mov    0xc(%ebp),%eax
    6924:	8b 40 04             	mov    0x4(%eax),%eax
    6927:	8b 55 cc             	mov    -0x34(%ebp),%edx
    692a:	01 d2                	add    %edx,%edx
    692c:	01 d0                	add    %edx,%eax
    692e:	0f b7 00             	movzwl (%eax),%eax
    6931:	0f b7 c0             	movzwl %ax,%eax
    6934:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6937:	8b 45 0c             	mov    0xc(%ebp),%eax
    693a:	8b 40 08             	mov    0x8(%eax),%eax
    693d:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6940:	c1 e2 02             	shl    $0x2,%edx
    6943:	01 d0                	add    %edx,%eax
    6945:	8b 10                	mov    (%eax),%edx
    6947:	8b 45 b0             	mov    -0x50(%ebp),%eax
    694a:	39 c2                	cmp    %eax,%edx
    694c:	75 11                	jne    695f <encodeLZ77+0x317>
      }
    }
    694e:	e9 87 fe ff ff       	jmp    67da <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6953:	90                   	nop
    6954:	eb 0a                	jmp    6960 <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6956:	90                   	nop
    6957:	eb 07                	jmp    6960 <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6959:	90                   	nop
    695a:	eb 04                	jmp    6960 <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    695c:	90                   	nop
    695d:	eb 01                	jmp    6960 <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    695f:	90                   	nop
      }
    }

    if(lazymatching) {
    6960:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    6964:	0f 84 c8 00 00 00    	je     6a32 <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    696a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    696e:	75 30                	jne    69a0 <encodeLZ77+0x358>
    6970:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6974:	76 2a                	jbe    69a0 <encodeLZ77+0x358>
    6976:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6979:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    697c:	77 22                	ja     69a0 <encodeLZ77+0x358>
    697e:	b8 02 01 00 00       	mov    $0x102,%eax
    6983:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6986:	73 18                	jae    69a0 <encodeLZ77+0x358>
        lazy = 1;
    6988:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    698f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6992:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    6995:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6998:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    699b:	e9 f0 01 00 00       	jmp    6b90 <encodeLZ77+0x548>
      }
      if(lazy) {
    69a0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    69a4:	0f 84 88 00 00 00    	je     6a32 <encodeLZ77+0x3ea>
        lazy = 0;
    69aa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    69b1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    69b5:	75 0c                	jne    69c3 <encodeLZ77+0x37b>
    69b7:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    69be:	e9 dd 01 00 00       	jmp    6ba0 <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    69c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    69c6:	83 c0 01             	add    $0x1,%eax
    69c9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    69cc:	73 2d                	jae    69fb <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    69ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
    69d1:	8d 50 ff             	lea    -0x1(%eax),%edx
    69d4:	8b 45 10             	mov    0x10(%ebp),%eax
    69d7:	01 d0                	add    %edx,%eax
    69d9:	0f b6 00             	movzbl (%eax),%eax
    69dc:	0f b6 c0             	movzbl %al,%eax
    69df:	50                   	push   %eax
    69e0:	ff 75 08             	pushl  0x8(%ebp)
    69e3:	e8 6f cb ff ff       	call   3557 <uivector_push_back>
    69e8:	83 c4 08             	add    $0x8,%esp
    69eb:	85 c0                	test   %eax,%eax
    69ed:	75 43                	jne    6a32 <encodeLZ77+0x3ea>
    69ef:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    69f6:	e9 a5 01 00 00       	jmp    6ba0 <encodeLZ77+0x558>
        } else {
          length = lazylength;
    69fb:	8b 45 e0             	mov    -0x20(%ebp),%eax
    69fe:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    6a01:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6a04:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    6a07:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a0a:	8b 00                	mov    (%eax),%eax
    6a0c:	8b 55 b0             	mov    -0x50(%ebp),%edx
    6a0f:	c1 e2 02             	shl    $0x2,%edx
    6a12:	01 d0                	add    %edx,%eax
    6a14:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    6a1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a1d:	8b 40 0c             	mov    0xc(%eax),%eax
    6a20:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6a23:	c1 e2 02             	shl    $0x2,%edx
    6a26:	01 d0                	add    %edx,%eax
    6a28:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    6a2e:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    6a32:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6a36:	76 14                	jbe    6a4c <encodeLZ77+0x404>
    6a38:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a3b:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    6a3e:	76 0c                	jbe    6a4c <encodeLZ77+0x404>
    6a40:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    6a47:	e9 54 01 00 00       	jmp    6ba0 <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    6a4c:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6a50:	77 2e                	ja     6a80 <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6a52:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6a55:	8b 45 10             	mov    0x10(%ebp),%eax
    6a58:	01 d0                	add    %edx,%eax
    6a5a:	0f b6 00             	movzbl (%eax),%eax
    6a5d:	0f b6 c0             	movzbl %al,%eax
    6a60:	50                   	push   %eax
    6a61:	ff 75 08             	pushl  0x8(%ebp)
    6a64:	e8 ee ca ff ff       	call   3557 <uivector_push_back>
    6a69:	83 c4 08             	add    $0x8,%esp
    6a6c:	85 c0                	test   %eax,%eax
    6a6e:	0f 85 1c 01 00 00    	jne    6b90 <encodeLZ77+0x548>
    6a74:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6a7b:	e9 20 01 00 00       	jmp    6ba0 <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    6a80:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6a83:	3b 45 20             	cmp    0x20(%ebp),%eax
    6a86:	72 0f                	jb     6a97 <encodeLZ77+0x44f>
    6a88:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    6a8c:	75 37                	jne    6ac5 <encodeLZ77+0x47d>
    6a8e:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    6a95:	76 2e                	jbe    6ac5 <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6a97:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6a9a:	8b 45 10             	mov    0x10(%ebp),%eax
    6a9d:	01 d0                	add    %edx,%eax
    6a9f:	0f b6 00             	movzbl (%eax),%eax
    6aa2:	0f b6 c0             	movzbl %al,%eax
    6aa5:	50                   	push   %eax
    6aa6:	ff 75 08             	pushl  0x8(%ebp)
    6aa9:	e8 a9 ca ff ff       	call   3557 <uivector_push_back>
    6aae:	83 c4 08             	add    $0x8,%esp
    6ab1:	85 c0                	test   %eax,%eax
    6ab3:	0f 85 d7 00 00 00    	jne    6b90 <encodeLZ77+0x548>
    6ab9:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6ac0:	e9 db 00 00 00       	jmp    6ba0 <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    6ac5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6ac8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6acb:	52                   	push   %edx
    6acc:	50                   	push   %eax
    6acd:	ff 75 08             	pushl  0x8(%ebp)
    6ad0:	e8 8a f6 ff ff       	call   615f <addLengthDistance>
    6ad5:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    6ad8:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    6adf:	e9 a0 00 00 00       	jmp    6b84 <encodeLZ77+0x53c>
        ++pos;
    6ae4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    6ae8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6aeb:	8d 50 ff             	lea    -0x1(%eax),%edx
    6aee:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6af1:	21 d0                	and    %edx,%eax
    6af3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    6af6:	ff 75 fc             	pushl  -0x4(%ebp)
    6af9:	ff 75 18             	pushl  0x18(%ebp)
    6afc:	ff 75 10             	pushl  0x10(%ebp)
    6aff:	e8 67 f9 ff ff       	call   646b <getHash>
    6b04:	83 c4 0c             	add    $0xc,%esp
    6b07:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    6b0a:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6b0e:	74 4e                	je     6b5e <encodeLZ77+0x516>
    6b10:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6b14:	75 48                	jne    6b5e <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b16:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6b1a:	75 16                	jne    6b32 <encodeLZ77+0x4ea>
    6b1c:	ff 75 fc             	pushl  -0x4(%ebp)
    6b1f:	ff 75 18             	pushl  0x18(%ebp)
    6b22:	ff 75 10             	pushl  0x10(%ebp)
    6b25:	e8 f5 f9 ff ff       	call   651f <countZeros>
    6b2a:	83 c4 0c             	add    $0xc,%esp
    6b2d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6b30:	eb 35                	jmp    6b67 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6b32:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6b35:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b38:	01 c2                	add    %eax,%edx
    6b3a:	8b 45 18             	mov    0x18(%ebp),%eax
    6b3d:	39 c2                	cmp    %eax,%edx
    6b3f:	77 17                	ja     6b58 <encodeLZ77+0x510>
    6b41:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6b44:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b47:	01 d0                	add    %edx,%eax
    6b49:	8d 50 ff             	lea    -0x1(%eax),%edx
    6b4c:	8b 45 10             	mov    0x10(%ebp),%eax
    6b4f:	01 d0                	add    %edx,%eax
    6b51:	0f b6 00             	movzbl (%eax),%eax
    6b54:	84 c0                	test   %al,%al
    6b56:	74 0f                	je     6b67 <encodeLZ77+0x51f>
    6b58:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b5c:	eb 09                	jmp    6b67 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    6b5e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6b65:	eb 01                	jmp    6b68 <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b67:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    6b68:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b6b:	0f b7 c0             	movzwl %ax,%eax
    6b6e:	50                   	push   %eax
    6b6f:	ff 75 b0             	pushl  -0x50(%ebp)
    6b72:	ff 75 b4             	pushl  -0x4c(%ebp)
    6b75:	ff 75 0c             	pushl  0xc(%ebp)
    6b78:	e8 04 fa ff ff       	call   6581 <updateHashChain>
    6b7d:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    6b80:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6b84:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6b87:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6b8a:	0f 82 54 ff ff ff    	jb     6ae4 <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    6b90:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6b94:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6b97:	3b 45 18             	cmp    0x18(%ebp),%eax
    6b9a:	0f 8c 54 fb ff ff    	jl     66f4 <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    6ba0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6ba3:	c9                   	leave  
    6ba4:	c3                   	ret    

00006ba5 <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    6ba5:	55                   	push   %ebp
    6ba6:	89 e5                	mov    %esp,%ebp
    6ba8:	53                   	push   %ebx
    6ba9:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    6bac:	8b 45 10             	mov    0x10(%ebp),%eax
    6baf:	05 fe ff 00 00       	add    $0xfffe,%eax
    6bb4:	ba 01 80 00 80       	mov    $0x80008001,%edx
    6bb9:	f7 e2                	mul    %edx
    6bbb:	89 d0                	mov    %edx,%eax
    6bbd:	c1 e8 0f             	shr    $0xf,%eax
    6bc0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    6bc3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    6bca:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6bd1:	e9 1b 01 00 00       	jmp    6cf1 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    6bd6:	8b 45 08             	mov    0x8(%ebp),%eax
    6bd9:	8b 40 04             	mov    0x4(%eax),%eax
    6bdc:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    6bdf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6be2:	83 e8 01             	sub    $0x1,%eax
    6be5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6be8:	0f 94 c0             	sete   %al
    6beb:	0f b6 c0             	movzbl %al,%eax
    6bee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    6bf1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    6bf8:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    6bff:	8b 45 10             	mov    0x10(%ebp),%eax
    6c02:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6c05:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    6c0a:	77 09                	ja     6c15 <deflateNoCompression+0x70>
    6c0c:	8b 45 10             	mov    0x10(%ebp),%eax
    6c0f:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6c12:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    6c15:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6c1a:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6c1d:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    6c20:	8b 45 08             	mov    0x8(%ebp),%eax
    6c23:	8b 40 04             	mov    0x4(%eax),%eax
    6c26:	89 c2                	mov    %eax,%edx
    6c28:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c2b:	01 d0                	add    %edx,%eax
    6c2d:	83 c0 05             	add    $0x5,%eax
    6c30:	50                   	push   %eax
    6c31:	ff 75 08             	pushl  0x8(%ebp)
    6c34:	e8 62 c9 ff ff       	call   359b <ucvector_resize>
    6c39:	83 c4 08             	add    $0x8,%esp
    6c3c:	85 c0                	test   %eax,%eax
    6c3e:	75 0a                	jne    6c4a <deflateNoCompression+0xa5>
    6c40:	b8 53 00 00 00       	mov    $0x53,%eax
    6c45:	e9 b8 00 00 00       	jmp    6d02 <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    6c4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6c4d:	89 c2                	mov    %eax,%edx
    6c4f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6c52:	83 e0 01             	and    $0x1,%eax
    6c55:	01 c0                	add    %eax,%eax
    6c57:	01 c2                	add    %eax,%edx
    6c59:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6c5c:	83 e0 02             	and    $0x2,%eax
    6c5f:	01 c0                	add    %eax,%eax
    6c61:	01 d0                	add    %edx,%eax
    6c63:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    6c66:	8b 45 08             	mov    0x8(%ebp),%eax
    6c69:	8b 10                	mov    (%eax),%edx
    6c6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6c6e:	01 c2                	add    %eax,%edx
    6c70:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    6c74:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    6c76:	8b 45 08             	mov    0x8(%ebp),%eax
    6c79:	8b 00                	mov    (%eax),%eax
    6c7b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c7e:	83 c2 01             	add    $0x1,%edx
    6c81:	01 d0                	add    %edx,%eax
    6c83:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6c86:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    6c88:	8b 45 08             	mov    0x8(%ebp),%eax
    6c8b:	8b 00                	mov    (%eax),%eax
    6c8d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c90:	83 c2 02             	add    $0x2,%edx
    6c93:	01 d0                	add    %edx,%eax
    6c95:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6c98:	c1 ea 08             	shr    $0x8,%edx
    6c9b:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    6c9d:	8b 45 08             	mov    0x8(%ebp),%eax
    6ca0:	8b 00                	mov    (%eax),%eax
    6ca2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6ca5:	83 c2 03             	add    $0x3,%edx
    6ca8:	01 d0                	add    %edx,%eax
    6caa:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6cad:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    6caf:	8b 45 08             	mov    0x8(%ebp),%eax
    6cb2:	8b 00                	mov    (%eax),%eax
    6cb4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6cb7:	83 c2 04             	add    $0x4,%edx
    6cba:	01 d0                	add    %edx,%eax
    6cbc:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6cbf:	c1 ea 08             	shr    $0x8,%edx
    6cc2:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    6cc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6cc7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    6cca:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6ccd:	01 d1                	add    %edx,%ecx
    6ccf:	8b 55 08             	mov    0x8(%ebp),%edx
    6cd2:	8b 12                	mov    (%edx),%edx
    6cd4:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6cd7:	83 c3 05             	add    $0x5,%ebx
    6cda:	01 da                	add    %ebx,%edx
    6cdc:	50                   	push   %eax
    6cdd:	51                   	push   %ecx
    6cde:	52                   	push   %edx
    6cdf:	e8 9b c6 ff ff       	call   337f <lodepng_memcpy>
    6ce4:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    6ce7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6cea:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    6ced:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6cf1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6cf4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6cf7:	0f 85 d9 fe ff ff    	jne    6bd6 <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    6cfd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6d02:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6d05:	c9                   	leave  
    6d06:	c3                   	ret    

00006d07 <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    6d07:	55                   	push   %ebp
    6d08:	89 e5                	mov    %esp,%ebp
    6d0a:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    6d0d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    6d14:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6d1b:	e9 10 01 00 00       	jmp    6e30 <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    6d20:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d23:	8b 00                	mov    (%eax),%eax
    6d25:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d28:	c1 e2 02             	shl    $0x2,%edx
    6d2b:	01 d0                	add    %edx,%eax
    6d2d:	8b 00                	mov    (%eax),%eax
    6d2f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    6d32:	8b 45 10             	mov    0x10(%ebp),%eax
    6d35:	8b 40 04             	mov    0x4(%eax),%eax
    6d38:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6d3b:	c1 e2 02             	shl    $0x2,%edx
    6d3e:	01 d0                	add    %edx,%eax
    6d40:	8b 00                	mov    (%eax),%eax
    6d42:	89 c1                	mov    %eax,%ecx
    6d44:	8b 45 10             	mov    0x10(%ebp),%eax
    6d47:	8b 00                	mov    (%eax),%eax
    6d49:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6d4c:	c1 e2 02             	shl    $0x2,%edx
    6d4f:	01 d0                	add    %edx,%eax
    6d51:	8b 00                	mov    (%eax),%eax
    6d53:	51                   	push   %ecx
    6d54:	50                   	push   %eax
    6d55:	ff 75 08             	pushl  0x8(%ebp)
    6d58:	e8 60 cc ff ff       	call   39bd <writeBitsReversed>
    6d5d:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    6d60:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    6d67:	0f 86 bf 00 00 00    	jbe    6e2c <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    6d6d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6d70:	2d 01 01 00 00       	sub    $0x101,%eax
    6d75:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    6d78:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6d7b:	8b 04 85 e0 9d 01 00 	mov    0x19de0(,%eax,4),%eax
    6d82:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    6d85:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d88:	8b 00                	mov    (%eax),%eax
    6d8a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6d8e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d91:	c1 e2 02             	shl    $0x2,%edx
    6d94:	01 d0                	add    %edx,%eax
    6d96:	8b 00                	mov    (%eax),%eax
    6d98:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    6d9b:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d9e:	8b 00                	mov    (%eax),%eax
    6da0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6da4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6da7:	c1 e2 02             	shl    $0x2,%edx
    6daa:	01 d0                	add    %edx,%eax
    6dac:	8b 00                	mov    (%eax),%eax
    6dae:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    6db1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6db4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    6db7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6dba:	8b 04 85 e0 9e 01 00 	mov    0x19ee0(,%eax,4),%eax
    6dc1:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    6dc4:	8b 45 0c             	mov    0xc(%ebp),%eax
    6dc7:	8b 00                	mov    (%eax),%eax
    6dc9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6dcd:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6dd0:	c1 e2 02             	shl    $0x2,%edx
    6dd3:	01 d0                	add    %edx,%eax
    6dd5:	8b 00                	mov    (%eax),%eax
    6dd7:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    6dda:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ddd:	50                   	push   %eax
    6dde:	ff 75 ec             	pushl  -0x14(%ebp)
    6de1:	ff 75 08             	pushl  0x8(%ebp)
    6de4:	e8 40 ca ff ff       	call   3829 <writeBits>
    6de9:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    6dec:	8b 45 14             	mov    0x14(%ebp),%eax
    6def:	8b 40 04             	mov    0x4(%eax),%eax
    6df2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6df5:	c1 e2 02             	shl    $0x2,%edx
    6df8:	01 d0                	add    %edx,%eax
    6dfa:	8b 00                	mov    (%eax),%eax
    6dfc:	89 c1                	mov    %eax,%ecx
    6dfe:	8b 45 14             	mov    0x14(%ebp),%eax
    6e01:	8b 00                	mov    (%eax),%eax
    6e03:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6e06:	c1 e2 02             	shl    $0x2,%edx
    6e09:	01 d0                	add    %edx,%eax
    6e0b:	8b 00                	mov    (%eax),%eax
    6e0d:	51                   	push   %ecx
    6e0e:	50                   	push   %eax
    6e0f:	ff 75 08             	pushl  0x8(%ebp)
    6e12:	e8 a6 cb ff ff       	call   39bd <writeBitsReversed>
    6e17:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    6e1a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6e1d:	50                   	push   %eax
    6e1e:	ff 75 dc             	pushl  -0x24(%ebp)
    6e21:	ff 75 08             	pushl  0x8(%ebp)
    6e24:	e8 00 ca ff ff       	call   3829 <writeBits>
    6e29:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    6e2c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e30:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e33:	8b 40 04             	mov    0x4(%eax),%eax
    6e36:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6e39:	0f 85 e1 fe ff ff    	jne    6d20 <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    6e3f:	90                   	nop
    6e40:	c9                   	leave  
    6e41:	c3                   	ret    

00006e42 <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    6e42:	55                   	push   %ebp
    6e43:	89 e5                	mov    %esp,%ebp
    6e45:	53                   	push   %ebx
    6e46:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    6e4c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    6e53:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    6e5a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    6e61:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    6e68:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    6e6f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    6e76:	8b 45 18             	mov    0x18(%ebp),%eax
    6e79:	2b 45 14             	sub    0x14(%ebp),%eax
    6e7c:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    6e7f:	8b 45 20             	mov    0x20(%ebp),%eax
    6e82:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    6e85:	8d 45 90             	lea    -0x70(%ebp),%eax
    6e88:	50                   	push   %eax
    6e89:	e8 a4 c6 ff ff       	call   3532 <uivector_init>
    6e8e:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    6e91:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    6e97:	50                   	push   %eax
    6e98:	e8 98 d3 ff ff       	call   4235 <HuffmanTree_init>
    6e9d:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    6ea0:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    6ea6:	50                   	push   %eax
    6ea7:	e8 89 d3 ff ff       	call   4235 <HuffmanTree_init>
    6eac:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    6eaf:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    6eb5:	50                   	push   %eax
    6eb6:	e8 7a d3 ff ff       	call   4235 <HuffmanTree_init>
    6ebb:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    6ebe:	83 ec 0c             	sub    $0xc,%esp
    6ec1:	68 78 04 00 00       	push   $0x478
    6ec6:	e8 76 c4 ff ff       	call   3341 <lodepng_malloc>
    6ecb:	83 c4 10             	add    $0x10,%esp
    6ece:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    6ed1:	83 ec 0c             	sub    $0xc,%esp
    6ed4:	6a 78                	push   $0x78
    6ed6:	e8 66 c4 ff ff       	call   3341 <lodepng_malloc>
    6edb:	83 c4 10             	add    $0x10,%esp
    6ede:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6ee1:	83 ec 0c             	sub    $0xc,%esp
    6ee4:	6a 4c                	push   $0x4c
    6ee6:	e8 56 c4 ff ff       	call   3341 <lodepng_malloc>
    6eeb:	83 c4 10             	add    $0x10,%esp
    6eee:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    6ef1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    6ef5:	74 0c                	je     6f03 <deflateDynamic+0xc1>
    6ef7:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    6efb:	74 06                	je     6f03 <deflateDynamic+0xc1>
    6efd:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    6f01:	75 07                	jne    6f0a <deflateDynamic+0xc8>
    6f03:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    6f0a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6f0e:	0f 85 f6 07 00 00    	jne    770a <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    6f14:	83 ec 04             	sub    $0x4,%esp
    6f17:	68 78 04 00 00       	push   $0x478
    6f1c:	6a 00                	push   $0x0
    6f1e:	ff 75 d4             	pushl  -0x2c(%ebp)
    6f21:	e8 8c c4 ff ff       	call   33b2 <lodepng_memset>
    6f26:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    6f29:	83 ec 04             	sub    $0x4,%esp
    6f2c:	6a 78                	push   $0x78
    6f2e:	6a 00                	push   $0x0
    6f30:	ff 75 d0             	pushl  -0x30(%ebp)
    6f33:	e8 7a c4 ff ff       	call   33b2 <lodepng_memset>
    6f38:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6f3b:	83 ec 04             	sub    $0x4,%esp
    6f3e:	6a 4c                	push   $0x4c
    6f40:	6a 00                	push   $0x0
    6f42:	ff 75 cc             	pushl  -0x34(%ebp)
    6f45:	e8 68 c4 ff ff       	call   33b2 <lodepng_memset>
    6f4a:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    6f4d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f50:	8b 40 04             	mov    0x4(%eax),%eax
    6f53:	85 c0                	test   %eax,%eax
    6f55:	74 45                	je     6f9c <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    6f57:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f5a:	8b 58 14             	mov    0x14(%eax),%ebx
    6f5d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f60:	8b 48 10             	mov    0x10(%eax),%ecx
    6f63:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f66:	8b 50 0c             	mov    0xc(%eax),%edx
    6f69:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f6c:	8b 40 08             	mov    0x8(%eax),%eax
    6f6f:	83 ec 0c             	sub    $0xc,%esp
    6f72:	53                   	push   %ebx
    6f73:	51                   	push   %ecx
    6f74:	52                   	push   %edx
    6f75:	50                   	push   %eax
    6f76:	ff 75 18             	pushl  0x18(%ebp)
    6f79:	ff 75 14             	pushl  0x14(%ebp)
    6f7c:	ff 75 10             	pushl  0x10(%ebp)
    6f7f:	ff 75 0c             	pushl  0xc(%ebp)
    6f82:	8d 45 90             	lea    -0x70(%ebp),%eax
    6f85:	50                   	push   %eax
    6f86:	e8 bd f6 ff ff       	call   6648 <encodeLZ77>
    6f8b:	83 c4 30             	add    $0x30,%esp
    6f8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    6f91:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6f95:	74 59                	je     6ff0 <deflateDynamic+0x1ae>
    6f97:	e9 6e 07 00 00       	jmp    770a <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    6f9c:	83 ec 08             	sub    $0x8,%esp
    6f9f:	ff 75 c8             	pushl  -0x38(%ebp)
    6fa2:	8d 45 90             	lea    -0x70(%ebp),%eax
    6fa5:	50                   	push   %eax
    6fa6:	e8 17 c5 ff ff       	call   34c2 <uivector_resize>
    6fab:	83 c4 10             	add    $0x10,%esp
    6fae:	85 c0                	test   %eax,%eax
    6fb0:	75 0c                	jne    6fbe <deflateDynamic+0x17c>
    6fb2:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6fb9:	e9 4c 07 00 00       	jmp    770a <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    6fbe:	8b 45 14             	mov    0x14(%ebp),%eax
    6fc1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    6fc4:	eb 22                	jmp    6fe8 <deflateDynamic+0x1a6>
    6fc6:	8b 55 90             	mov    -0x70(%ebp),%edx
    6fc9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6fcc:	2b 45 14             	sub    0x14(%ebp),%eax
    6fcf:	c1 e0 02             	shl    $0x2,%eax
    6fd2:	01 c2                	add    %eax,%edx
    6fd4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    6fd7:	8b 45 10             	mov    0x10(%ebp),%eax
    6fda:	01 c8                	add    %ecx,%eax
    6fdc:	0f b6 00             	movzbl (%eax),%eax
    6fdf:	0f b6 c0             	movzbl %al,%eax
    6fe2:	89 02                	mov    %eax,(%edx)
    6fe4:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    6fe8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6feb:	3b 45 18             	cmp    0x18(%ebp),%eax
    6fee:	7c d6                	jl     6fc6 <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    6ff0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    6ff7:	eb 60                	jmp    7059 <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    6ff9:	8b 45 90             	mov    -0x70(%ebp),%eax
    6ffc:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6fff:	c1 e2 02             	shl    $0x2,%edx
    7002:	01 d0                	add    %edx,%eax
    7004:	8b 00                	mov    (%eax),%eax
    7006:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    7009:	8b 45 c0             	mov    -0x40(%ebp),%eax
    700c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7013:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7016:	01 d0                	add    %edx,%eax
    7018:	8b 10                	mov    (%eax),%edx
    701a:	83 c2 01             	add    $0x1,%edx
    701d:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    701f:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    7026:	76 2d                	jbe    7055 <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    7028:	8b 45 90             	mov    -0x70(%ebp),%eax
    702b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    702e:	83 c2 02             	add    $0x2,%edx
    7031:	c1 e2 02             	shl    $0x2,%edx
    7034:	01 d0                	add    %edx,%eax
    7036:	8b 00                	mov    (%eax),%eax
    7038:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    703b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    703e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7045:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7048:	01 d0                	add    %edx,%eax
    704a:	8b 10                	mov    (%eax),%edx
    704c:	83 c2 01             	add    $0x1,%edx
    704f:	89 10                	mov    %edx,(%eax)
        i += 3;
    7051:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    7055:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7059:	8b 45 94             	mov    -0x6c(%ebp),%eax
    705c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    705f:	75 98                	jne    6ff9 <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    7061:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7064:	05 00 04 00 00       	add    $0x400,%eax
    7069:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    706f:	83 ec 0c             	sub    $0xc,%esp
    7072:	6a 0f                	push   $0xf
    7074:	68 1e 01 00 00       	push   $0x11e
    7079:	68 01 01 00 00       	push   $0x101
    707e:	ff 75 d4             	pushl  -0x2c(%ebp)
    7081:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7087:	50                   	push   %eax
    7088:	e8 e0 e1 ff ff       	call   526d <HuffmanTree_makeFromFrequencies>
    708d:	83 c4 20             	add    $0x20,%esp
    7090:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7093:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7097:	0f 85 66 06 00 00    	jne    7703 <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    709d:	83 ec 0c             	sub    $0xc,%esp
    70a0:	6a 0f                	push   $0xf
    70a2:	6a 1e                	push   $0x1e
    70a4:	6a 02                	push   $0x2
    70a6:	ff 75 d0             	pushl  -0x30(%ebp)
    70a9:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    70af:	50                   	push   %eax
    70b0:	e8 b8 e1 ff ff       	call   526d <HuffmanTree_makeFromFrequencies>
    70b5:	83 c4 20             	add    $0x20,%esp
    70b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    70bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    70bf:	0f 85 41 06 00 00    	jne    7706 <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    70c5:	8b 45 84             	mov    -0x7c(%ebp),%eax
    70c8:	ba 1e 01 00 00       	mov    $0x11e,%edx
    70cd:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    70d2:	0f 47 c2             	cmova  %edx,%eax
    70d5:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    70d8:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    70de:	ba 1e 00 00 00       	mov    $0x1e,%edx
    70e3:	83 f8 1e             	cmp    $0x1e,%eax
    70e6:	0f 47 c2             	cmova  %edx,%eax
    70e9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    70ec:	8b 55 b8             	mov    -0x48(%ebp),%edx
    70ef:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    70f2:	01 d0                	add    %edx,%eax
    70f4:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    70f7:	8b 45 b0             	mov    -0x50(%ebp),%eax
    70fa:	c1 e0 02             	shl    $0x2,%eax
    70fd:	83 ec 0c             	sub    $0xc,%esp
    7100:	50                   	push   %eax
    7101:	e8 3b c2 ff ff       	call   3341 <lodepng_malloc>
    7106:	83 c4 10             	add    $0x10,%esp
    7109:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    710c:	8b 45 b0             	mov    -0x50(%ebp),%eax
    710f:	c1 e0 02             	shl    $0x2,%eax
    7112:	83 ec 0c             	sub    $0xc,%esp
    7115:	50                   	push   %eax
    7116:	e8 26 c2 ff ff       	call   3341 <lodepng_malloc>
    711b:	83 c4 10             	add    $0x10,%esp
    711e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    7121:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7125:	74 06                	je     712d <deflateDynamic+0x2eb>
    7127:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    712b:	75 0c                	jne    7139 <deflateDynamic+0x2f7>
    712d:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7134:	e9 d1 05 00 00       	jmp    770a <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    7139:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    7140:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7147:	eb 25                	jmp    716e <deflateDynamic+0x32c>
    7149:	8b 45 e8             	mov    -0x18(%ebp),%eax
    714c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7153:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7156:	01 c2                	add    %eax,%edx
    7158:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    715e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7161:	c1 e1 02             	shl    $0x2,%ecx
    7164:	01 c8                	add    %ecx,%eax
    7166:	8b 00                	mov    (%eax),%eax
    7168:	89 02                	mov    %eax,(%edx)
    716a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    716e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7171:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    7174:	75 d3                	jne    7149 <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    7176:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    717d:	eb 2a                	jmp    71a9 <deflateDynamic+0x367>
    717f:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7182:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7185:	01 d0                	add    %edx,%eax
    7187:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    718e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7191:	01 c2                	add    %eax,%edx
    7193:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    7199:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    719c:	c1 e1 02             	shl    $0x2,%ecx
    719f:	01 c8                	add    %ecx,%eax
    71a1:	8b 00                	mov    (%eax),%eax
    71a3:	89 02                	mov    %eax,(%edx)
    71a5:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    71a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71ac:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    71af:	75 ce                	jne    717f <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    71b1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    71b8:	e9 3b 02 00 00       	jmp    73f8 <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    71bd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    71c4:	eb 04                	jmp    71ca <deflateDynamic+0x388>
    71c6:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    71ca:	8b 55 e8             	mov    -0x18(%ebp),%edx
    71cd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    71d0:	01 d0                	add    %edx,%eax
    71d2:	8d 50 01             	lea    0x1(%eax),%edx
    71d5:	8b 45 b0             	mov    -0x50(%ebp),%eax
    71d8:	39 c2                	cmp    %eax,%edx
    71da:	73 2e                	jae    720a <deflateDynamic+0x3c8>
    71dc:	8b 55 e8             	mov    -0x18(%ebp),%edx
    71df:	8b 45 dc             	mov    -0x24(%ebp),%eax
    71e2:	01 d0                	add    %edx,%eax
    71e4:	83 c0 01             	add    $0x1,%eax
    71e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71f1:	01 d0                	add    %edx,%eax
    71f3:	8b 10                	mov    (%eax),%edx
    71f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71f8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    71ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7202:	01 c8                	add    %ecx,%eax
    7204:	8b 00                	mov    (%eax),%eax
    7206:	39 c2                	cmp    %eax,%edx
    7208:	74 bc                	je     71c6 <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    720a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    720d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7214:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7217:	01 d0                	add    %edx,%eax
    7219:	8b 00                	mov    (%eax),%eax
    721b:	85 c0                	test   %eax,%eax
    721d:	0f 85 a9 00 00 00    	jne    72cc <deflateDynamic+0x48a>
    7223:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    7227:	0f 86 9f 00 00 00    	jbe    72cc <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    722d:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    7231:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    7235:	77 3a                	ja     7271 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    7237:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    723a:	8d 50 01             	lea    0x1(%eax),%edx
    723d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7240:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7247:	8b 45 ec             	mov    -0x14(%ebp),%eax
    724a:	01 d0                	add    %edx,%eax
    724c:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    7252:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7255:	8d 50 01             	lea    0x1(%eax),%edx
    7258:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    725b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7262:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7265:	01 d0                	add    %edx,%eax
    7267:	8b 55 dc             	mov    -0x24(%ebp),%edx
    726a:	83 ea 03             	sub    $0x3,%edx
    726d:	89 10                	mov    %edx,(%eax)
    726f:	eb 48                	jmp    72b9 <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    7271:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    7278:	76 07                	jbe    7281 <deflateDynamic+0x43f>
    727a:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    7281:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7284:	8d 50 01             	lea    0x1(%eax),%edx
    7287:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    728a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7291:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7294:	01 d0                	add    %edx,%eax
    7296:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    729c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    729f:	8d 50 01             	lea    0x1(%eax),%edx
    72a2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    72a5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
    72af:	01 d0                	add    %edx,%eax
    72b1:	8b 55 dc             	mov    -0x24(%ebp),%edx
    72b4:	83 ea 0b             	sub    $0xb,%edx
    72b7:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    72b9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    72bc:	8b 45 dc             	mov    -0x24(%ebp),%eax
    72bf:	01 d0                	add    %edx,%eax
    72c1:	83 e8 01             	sub    $0x1,%eax
    72c4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    72c7:	e9 28 01 00 00       	jmp    73f4 <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    72cc:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    72d0:	0f 86 f6 00 00 00    	jbe    73cc <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    72d6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    72d9:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    72de:	f7 e2                	mul    %edx
    72e0:	89 d0                	mov    %edx,%eax
    72e2:	c1 e8 02             	shr    $0x2,%eax
    72e5:	89 45 ac             	mov    %eax,-0x54(%ebp)
    72e8:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    72eb:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    72f0:	89 c8                	mov    %ecx,%eax
    72f2:	f7 e2                	mul    %edx
    72f4:	c1 ea 02             	shr    $0x2,%edx
    72f7:	89 d0                	mov    %edx,%eax
    72f9:	01 c0                	add    %eax,%eax
    72fb:	01 d0                	add    %edx,%eax
    72fd:	01 c0                	add    %eax,%eax
    72ff:	29 c1                	sub    %eax,%ecx
    7301:	89 c8                	mov    %ecx,%eax
    7303:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    7306:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7309:	8d 50 01             	lea    0x1(%eax),%edx
    730c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    730f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7316:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7319:	01 c2                	add    %eax,%edx
    731b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    731e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7325:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7328:	01 c8                	add    %ecx,%eax
    732a:	8b 00                	mov    (%eax),%eax
    732c:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    732e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    7335:	eb 3a                	jmp    7371 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7337:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    733a:	8d 50 01             	lea    0x1(%eax),%edx
    733d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7340:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7347:	8b 45 ec             	mov    -0x14(%ebp),%eax
    734a:	01 d0                	add    %edx,%eax
    734c:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    7352:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7355:	8d 50 01             	lea    0x1(%eax),%edx
    7358:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    735b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7362:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7365:	01 d0                	add    %edx,%eax
    7367:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    736d:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    7371:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7374:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    7377:	72 be                	jb     7337 <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    7379:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    737d:	76 3a                	jbe    73b9 <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    737f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7382:	8d 50 01             	lea    0x1(%eax),%edx
    7385:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7388:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    738f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7392:	01 d0                	add    %edx,%eax
    7394:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    739a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    739d:	8d 50 01             	lea    0x1(%eax),%edx
    73a0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    73a3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73ad:	01 d0                	add    %edx,%eax
    73af:	8b 55 a8             	mov    -0x58(%ebp),%edx
    73b2:	83 ea 03             	sub    $0x3,%edx
    73b5:	89 10                	mov    %edx,(%eax)
    73b7:	eb 06                	jmp    73bf <deflateDynamic+0x57d>
        }
        else j -= rest;
    73b9:	8b 45 a8             	mov    -0x58(%ebp),%eax
    73bc:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    73bf:	8b 55 e8             	mov    -0x18(%ebp),%edx
    73c2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    73c5:	01 d0                	add    %edx,%eax
    73c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    73ca:	eb 28                	jmp    73f4 <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    73cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73cf:	8d 50 01             	lea    0x1(%eax),%edx
    73d2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    73d5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73df:	01 c2                	add    %eax,%edx
    73e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73e4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    73eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    73ee:	01 c8                	add    %ecx,%eax
    73f0:	8b 00                	mov    (%eax),%eax
    73f2:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    73f4:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    73f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73fb:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    73fe:	0f 85 b9 fd ff ff    	jne    71bd <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7404:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    740b:	eb 42                	jmp    744f <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    740d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7410:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7417:	8b 45 ec             	mov    -0x14(%ebp),%eax
    741a:	01 d0                	add    %edx,%eax
    741c:	8b 00                	mov    (%eax),%eax
    741e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7425:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7428:	01 d0                	add    %edx,%eax
    742a:	8b 10                	mov    (%eax),%edx
    742c:	83 c2 01             	add    $0x1,%edx
    742f:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    7431:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7434:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    743b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    743e:	01 d0                	add    %edx,%eax
    7440:	8b 00                	mov    (%eax),%eax
    7442:	83 f8 0f             	cmp    $0xf,%eax
    7445:	76 04                	jbe    744b <deflateDynamic+0x609>
    7447:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    744b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    744f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7452:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7455:	75 b6                	jne    740d <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    7457:	83 ec 0c             	sub    $0xc,%esp
    745a:	6a 07                	push   $0x7
    745c:	6a 13                	push   $0x13
    745e:	6a 13                	push   $0x13
    7460:	ff 75 cc             	pushl  -0x34(%ebp)
    7463:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7469:	50                   	push   %eax
    746a:	e8 fe dd ff ff       	call   526d <HuffmanTree_makeFromFrequencies>
    746f:	83 c4 20             	add    $0x20,%esp
    7472:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    7475:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7479:	0f 85 8a 02 00 00    	jne    7709 <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    747f:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7486:	eb 04                	jmp    748c <deflateDynamic+0x64a>
      numcodes_cl--;
    7488:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    748c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    748f:	83 f8 04             	cmp    $0x4,%eax
    7492:	76 1e                	jbe    74b2 <deflateDynamic+0x670>
    7494:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    749a:	8b 55 e0             	mov    -0x20(%ebp),%edx
    749d:	83 ea 01             	sub    $0x1,%edx
    74a0:	8b 14 95 60 9f 01 00 	mov    0x19f60(,%edx,4),%edx
    74a7:	c1 e2 02             	shl    $0x2,%edx
    74aa:	01 d0                	add    %edx,%eax
    74ac:	8b 00                	mov    (%eax),%eax
    74ae:	85 c0                	test   %eax,%eax
    74b0:	74 d6                	je     7488 <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    74b2:	83 ec 04             	sub    $0x4,%esp
    74b5:	6a 01                	push   $0x1
    74b7:	ff 75 c4             	pushl  -0x3c(%ebp)
    74ba:	ff 75 08             	pushl  0x8(%ebp)
    74bd:	e8 67 c3 ff ff       	call   3829 <writeBits>
    74c2:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    74c5:	83 ec 04             	sub    $0x4,%esp
    74c8:	6a 01                	push   $0x1
    74ca:	6a 00                	push   $0x0
    74cc:	ff 75 08             	pushl  0x8(%ebp)
    74cf:	e8 55 c3 ff ff       	call   3829 <writeBits>
    74d4:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    74d7:	83 ec 04             	sub    $0x4,%esp
    74da:	6a 01                	push   $0x1
    74dc:	6a 01                	push   $0x1
    74de:	ff 75 08             	pushl  0x8(%ebp)
    74e1:	e8 43 c3 ff ff       	call   3829 <writeBits>
    74e6:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    74e9:	8b 45 b8             	mov    -0x48(%ebp),%eax
    74ec:	2d 01 01 00 00       	sub    $0x101,%eax
    74f1:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    74f4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    74f7:	83 e8 01             	sub    $0x1,%eax
    74fa:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    74fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7500:	83 e8 04             	sub    $0x4,%eax
    7503:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    7506:	83 ec 04             	sub    $0x4,%esp
    7509:	6a 05                	push   $0x5
    750b:	ff 75 a4             	pushl  -0x5c(%ebp)
    750e:	ff 75 08             	pushl  0x8(%ebp)
    7511:	e8 13 c3 ff ff       	call   3829 <writeBits>
    7516:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    7519:	83 ec 04             	sub    $0x4,%esp
    751c:	6a 05                	push   $0x5
    751e:	ff 75 a0             	pushl  -0x60(%ebp)
    7521:	ff 75 08             	pushl  0x8(%ebp)
    7524:	e8 00 c3 ff ff       	call   3829 <writeBits>
    7529:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    752c:	83 ec 04             	sub    $0x4,%esp
    752f:	6a 04                	push   $0x4
    7531:	ff 75 9c             	pushl  -0x64(%ebp)
    7534:	ff 75 08             	pushl  0x8(%ebp)
    7537:	e8 ed c2 ff ff       	call   3829 <writeBits>
    753c:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    753f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7546:	eb 2c                	jmp    7574 <deflateDynamic+0x732>
    7548:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    754e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7551:	8b 04 85 60 9f 01 00 	mov    0x19f60(,%eax,4),%eax
    7558:	c1 e0 02             	shl    $0x2,%eax
    755b:	01 d0                	add    %edx,%eax
    755d:	8b 00                	mov    (%eax),%eax
    755f:	83 ec 04             	sub    $0x4,%esp
    7562:	6a 03                	push   $0x3
    7564:	50                   	push   %eax
    7565:	ff 75 08             	pushl  0x8(%ebp)
    7568:	e8 bc c2 ff ff       	call   3829 <writeBits>
    756d:	83 c4 10             	add    $0x10,%esp
    7570:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7574:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7577:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    757a:	75 cc                	jne    7548 <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    757c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7583:	e9 0a 01 00 00       	jmp    7692 <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    7588:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    758e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7591:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    7598:	8b 55 ec             	mov    -0x14(%ebp),%edx
    759b:	01 ca                	add    %ecx,%edx
    759d:	8b 12                	mov    (%edx),%edx
    759f:	c1 e2 02             	shl    $0x2,%edx
    75a2:	01 d0                	add    %edx,%eax
    75a4:	8b 00                	mov    (%eax),%eax
    75a6:	89 c3                	mov    %eax,%ebx
    75a8:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    75ae:	8b 55 e8             	mov    -0x18(%ebp),%edx
    75b1:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    75b8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    75bb:	01 ca                	add    %ecx,%edx
    75bd:	8b 12                	mov    (%edx),%edx
    75bf:	c1 e2 02             	shl    $0x2,%edx
    75c2:	01 d0                	add    %edx,%eax
    75c4:	8b 00                	mov    (%eax),%eax
    75c6:	83 ec 04             	sub    $0x4,%esp
    75c9:	53                   	push   %ebx
    75ca:	50                   	push   %eax
    75cb:	ff 75 08             	pushl  0x8(%ebp)
    75ce:	e8 ea c3 ff ff       	call   39bd <writeBitsReversed>
    75d3:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    75d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75d9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75e3:	01 d0                	add    %edx,%eax
    75e5:	8b 00                	mov    (%eax),%eax
    75e7:	83 f8 10             	cmp    $0x10,%eax
    75ea:	75 28                	jne    7614 <deflateDynamic+0x7d2>
    75ec:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    75f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75f3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75fd:	01 d0                	add    %edx,%eax
    75ff:	8b 00                	mov    (%eax),%eax
    7601:	83 ec 04             	sub    $0x4,%esp
    7604:	6a 02                	push   $0x2
    7606:	50                   	push   %eax
    7607:	ff 75 08             	pushl  0x8(%ebp)
    760a:	e8 1a c2 ff ff       	call   3829 <writeBits>
    760f:	83 c4 10             	add    $0x10,%esp
    7612:	eb 7a                	jmp    768e <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    7614:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7617:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    761e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7621:	01 d0                	add    %edx,%eax
    7623:	8b 00                	mov    (%eax),%eax
    7625:	83 f8 11             	cmp    $0x11,%eax
    7628:	75 28                	jne    7652 <deflateDynamic+0x810>
    762a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    762e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7631:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7638:	8b 45 ec             	mov    -0x14(%ebp),%eax
    763b:	01 d0                	add    %edx,%eax
    763d:	8b 00                	mov    (%eax),%eax
    763f:	83 ec 04             	sub    $0x4,%esp
    7642:	6a 03                	push   $0x3
    7644:	50                   	push   %eax
    7645:	ff 75 08             	pushl  0x8(%ebp)
    7648:	e8 dc c1 ff ff       	call   3829 <writeBits>
    764d:	83 c4 10             	add    $0x10,%esp
    7650:	eb 3c                	jmp    768e <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    7652:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7655:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    765c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    765f:	01 d0                	add    %edx,%eax
    7661:	8b 00                	mov    (%eax),%eax
    7663:	83 f8 12             	cmp    $0x12,%eax
    7666:	75 26                	jne    768e <deflateDynamic+0x84c>
    7668:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    766c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    766f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7676:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7679:	01 d0                	add    %edx,%eax
    767b:	8b 00                	mov    (%eax),%eax
    767d:	83 ec 04             	sub    $0x4,%esp
    7680:	6a 07                	push   $0x7
    7682:	50                   	push   %eax
    7683:	ff 75 08             	pushl  0x8(%ebp)
    7686:	e8 9e c1 ff ff       	call   3829 <writeBits>
    768b:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    768e:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7692:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7695:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7698:	0f 85 ea fe ff ff    	jne    7588 <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    769e:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    76a4:	50                   	push   %eax
    76a5:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    76ab:	50                   	push   %eax
    76ac:	8d 45 90             	lea    -0x70(%ebp),%eax
    76af:	50                   	push   %eax
    76b0:	ff 75 08             	pushl  0x8(%ebp)
    76b3:	e8 4f f6 ff ff       	call   6d07 <writeLZ77data>
    76b8:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    76bb:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    76c1:	05 00 04 00 00       	add    $0x400,%eax
    76c6:	8b 00                	mov    (%eax),%eax
    76c8:	85 c0                	test   %eax,%eax
    76ca:	75 09                	jne    76d5 <deflateDynamic+0x893>
    76cc:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    76d3:	eb 35                	jmp    770a <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    76d5:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    76db:	05 00 04 00 00       	add    $0x400,%eax
    76e0:	8b 00                	mov    (%eax),%eax
    76e2:	89 c2                	mov    %eax,%edx
    76e4:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    76ea:	05 00 04 00 00       	add    $0x400,%eax
    76ef:	8b 00                	mov    (%eax),%eax
    76f1:	83 ec 04             	sub    $0x4,%esp
    76f4:	52                   	push   %edx
    76f5:	50                   	push   %eax
    76f6:	ff 75 08             	pushl  0x8(%ebp)
    76f9:	e8 bf c2 ff ff       	call   39bd <writeBitsReversed>
    76fe:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    7701:	eb 07                	jmp    770a <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    7703:	90                   	nop
    7704:	eb 04                	jmp    770a <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    7706:	90                   	nop
    7707:	eb 01                	jmp    770a <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    7709:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    770a:	83 ec 0c             	sub    $0xc,%esp
    770d:	8d 45 90             	lea    -0x70(%ebp),%eax
    7710:	50                   	push   %eax
    7711:	e8 73 bd ff ff       	call   3489 <uivector_cleanup>
    7716:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    7719:	83 ec 0c             	sub    $0xc,%esp
    771c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7722:	50                   	push   %eax
    7723:	e8 3a cb ff ff       	call   4262 <HuffmanTree_cleanup>
    7728:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    772b:	83 ec 0c             	sub    $0xc,%esp
    772e:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7734:	50                   	push   %eax
    7735:	e8 28 cb ff ff       	call   4262 <HuffmanTree_cleanup>
    773a:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    773d:	83 ec 0c             	sub    $0xc,%esp
    7740:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7746:	50                   	push   %eax
    7747:	e8 16 cb ff ff       	call   4262 <HuffmanTree_cleanup>
    774c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    774f:	83 ec 0c             	sub    $0xc,%esp
    7752:	ff 75 d4             	pushl  -0x2c(%ebp)
    7755:	e8 08 bc ff ff       	call   3362 <lodepng_free>
    775a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    775d:	83 ec 0c             	sub    $0xc,%esp
    7760:	ff 75 d0             	pushl  -0x30(%ebp)
    7763:	e8 fa bb ff ff       	call   3362 <lodepng_free>
    7768:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    776b:	83 ec 0c             	sub    $0xc,%esp
    776e:	ff 75 cc             	pushl  -0x34(%ebp)
    7771:	e8 ec bb ff ff       	call   3362 <lodepng_free>
    7776:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    7779:	83 ec 0c             	sub    $0xc,%esp
    777c:	ff 75 f0             	pushl  -0x10(%ebp)
    777f:	e8 de bb ff ff       	call   3362 <lodepng_free>
    7784:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    7787:	83 ec 0c             	sub    $0xc,%esp
    778a:	ff 75 ec             	pushl  -0x14(%ebp)
    778d:	e8 d0 bb ff ff       	call   3362 <lodepng_free>
    7792:	83 c4 10             	add    $0x10,%esp

  return error;
    7795:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7798:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    779b:	c9                   	leave  
    779c:	c3                   	ret    

0000779d <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    779d:	55                   	push   %ebp
    779e:	89 e5                	mov    %esp,%ebp
    77a0:	53                   	push   %ebx
    77a1:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    77a4:	8b 45 20             	mov    0x20(%ebp),%eax
    77a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    77aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    77b1:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    77b4:	50                   	push   %eax
    77b5:	e8 7b ca ff ff       	call   4235 <HuffmanTree_init>
    77ba:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    77bd:	8d 45 bc             	lea    -0x44(%ebp),%eax
    77c0:	50                   	push   %eax
    77c1:	e8 6f ca ff ff       	call   4235 <HuffmanTree_init>
    77c6:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    77c9:	83 ec 0c             	sub    $0xc,%esp
    77cc:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    77cf:	50                   	push   %eax
    77d0:	e8 41 db ff ff       	call   5316 <generateFixedLitLenTree>
    77d5:	83 c4 10             	add    $0x10,%esp
    77d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    77db:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    77df:	75 12                	jne    77f3 <deflateFixed+0x56>
    77e1:	83 ec 0c             	sub    $0xc,%esp
    77e4:	8d 45 bc             	lea    -0x44(%ebp),%eax
    77e7:	50                   	push   %eax
    77e8:	e8 30 dc ff ff       	call   541d <generateFixedDistanceTree>
    77ed:	83 c4 10             	add    $0x10,%esp
    77f0:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    77f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    77f7:	0f 85 3a 01 00 00    	jne    7937 <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    77fd:	83 ec 04             	sub    $0x4,%esp
    7800:	6a 01                	push   $0x1
    7802:	ff 75 ec             	pushl  -0x14(%ebp)
    7805:	ff 75 08             	pushl  0x8(%ebp)
    7808:	e8 1c c0 ff ff       	call   3829 <writeBits>
    780d:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    7810:	83 ec 04             	sub    $0x4,%esp
    7813:	6a 01                	push   $0x1
    7815:	6a 01                	push   $0x1
    7817:	ff 75 08             	pushl  0x8(%ebp)
    781a:	e8 0a c0 ff ff       	call   3829 <writeBits>
    781f:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    7822:	83 ec 04             	sub    $0x4,%esp
    7825:	6a 01                	push   $0x1
    7827:	6a 00                	push   $0x0
    7829:	ff 75 08             	pushl  0x8(%ebp)
    782c:	e8 f8 bf ff ff       	call   3829 <writeBits>
    7831:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    7834:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7837:	8b 40 04             	mov    0x4(%eax),%eax
    783a:	85 c0                	test   %eax,%eax
    783c:	74 77                	je     78b5 <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    783e:	83 ec 0c             	sub    $0xc,%esp
    7841:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7844:	50                   	push   %eax
    7845:	e8 e8 bc ff ff       	call   3532 <uivector_init>
    784a:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    784d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7850:	8b 58 14             	mov    0x14(%eax),%ebx
    7853:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7856:	8b 48 10             	mov    0x10(%eax),%ecx
    7859:	8b 45 1c             	mov    0x1c(%ebp),%eax
    785c:	8b 50 0c             	mov    0xc(%eax),%edx
    785f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7862:	8b 40 08             	mov    0x8(%eax),%eax
    7865:	83 ec 0c             	sub    $0xc,%esp
    7868:	53                   	push   %ebx
    7869:	51                   	push   %ecx
    786a:	52                   	push   %edx
    786b:	50                   	push   %eax
    786c:	ff 75 18             	pushl  0x18(%ebp)
    786f:	ff 75 14             	pushl  0x14(%ebp)
    7872:	ff 75 10             	pushl  0x10(%ebp)
    7875:	ff 75 0c             	pushl  0xc(%ebp)
    7878:	8d 45 b0             	lea    -0x50(%ebp),%eax
    787b:	50                   	push   %eax
    787c:	e8 c7 ed ff ff       	call   6648 <encodeLZ77>
    7881:	83 c4 30             	add    $0x30,%esp
    7884:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7887:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    788b:	75 17                	jne    78a4 <deflateFixed+0x107>
    788d:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7890:	50                   	push   %eax
    7891:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7894:	50                   	push   %eax
    7895:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7898:	50                   	push   %eax
    7899:	ff 75 08             	pushl  0x8(%ebp)
    789c:	e8 66 f4 ff ff       	call   6d07 <writeLZ77data>
    78a1:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    78a4:	83 ec 0c             	sub    $0xc,%esp
    78a7:	8d 45 b0             	lea    -0x50(%ebp),%eax
    78aa:	50                   	push   %eax
    78ab:	e8 d9 bb ff ff       	call   3489 <uivector_cleanup>
    78b0:	83 c4 10             	add    $0x10,%esp
    78b3:	eb 56                	jmp    790b <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    78b5:	8b 45 14             	mov    0x14(%ebp),%eax
    78b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    78bb:	eb 46                	jmp    7903 <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    78bd:	8b 45 d8             	mov    -0x28(%ebp),%eax
    78c0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    78c3:	8b 55 10             	mov    0x10(%ebp),%edx
    78c6:	01 ca                	add    %ecx,%edx
    78c8:	0f b6 12             	movzbl (%edx),%edx
    78cb:	0f b6 d2             	movzbl %dl,%edx
    78ce:	c1 e2 02             	shl    $0x2,%edx
    78d1:	01 d0                	add    %edx,%eax
    78d3:	8b 00                	mov    (%eax),%eax
    78d5:	89 c3                	mov    %eax,%ebx
    78d7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    78da:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    78dd:	8b 55 10             	mov    0x10(%ebp),%edx
    78e0:	01 ca                	add    %ecx,%edx
    78e2:	0f b6 12             	movzbl (%edx),%edx
    78e5:	0f b6 d2             	movzbl %dl,%edx
    78e8:	c1 e2 02             	shl    $0x2,%edx
    78eb:	01 d0                	add    %edx,%eax
    78ed:	8b 00                	mov    (%eax),%eax
    78ef:	83 ec 04             	sub    $0x4,%esp
    78f2:	53                   	push   %ebx
    78f3:	50                   	push   %eax
    78f4:	ff 75 08             	pushl  0x8(%ebp)
    78f7:	e8 c1 c0 ff ff       	call   39bd <writeBitsReversed>
    78fc:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    78ff:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7903:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7906:	3b 45 18             	cmp    0x18(%ebp),%eax
    7909:	7c b2                	jl     78bd <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    790b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    790f:	75 26                	jne    7937 <deflateFixed+0x19a>
    7911:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7914:	05 00 04 00 00       	add    $0x400,%eax
    7919:	8b 00                	mov    (%eax),%eax
    791b:	89 c2                	mov    %eax,%edx
    791d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7920:	05 00 04 00 00       	add    $0x400,%eax
    7925:	8b 00                	mov    (%eax),%eax
    7927:	83 ec 04             	sub    $0x4,%esp
    792a:	52                   	push   %edx
    792b:	50                   	push   %eax
    792c:	ff 75 08             	pushl  0x8(%ebp)
    792f:	e8 89 c0 ff ff       	call   39bd <writeBitsReversed>
    7934:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    7937:	83 ec 0c             	sub    $0xc,%esp
    793a:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    793d:	50                   	push   %eax
    793e:	e8 1f c9 ff ff       	call   4262 <HuffmanTree_cleanup>
    7943:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7946:	83 ec 0c             	sub    $0xc,%esp
    7949:	8d 45 bc             	lea    -0x44(%ebp),%eax
    794c:	50                   	push   %eax
    794d:	e8 10 c9 ff ff       	call   4262 <HuffmanTree_cleanup>
    7952:	83 c4 10             	add    $0x10,%esp

  return error;
    7955:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7958:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    795b:	c9                   	leave  
    795c:	c3                   	ret    

0000795d <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    795d:	55                   	push   %ebp
    795e:	89 e5                	mov    %esp,%ebp
    7960:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    7963:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    796a:	ff 75 08             	pushl  0x8(%ebp)
    796d:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7970:	50                   	push   %eax
    7971:	e8 9e be ff ff       	call   3814 <LodePNGBitWriter_init>
    7976:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    7979:	8b 45 14             	mov    0x14(%ebp),%eax
    797c:	8b 00                	mov    (%eax),%eax
    797e:	83 f8 02             	cmp    $0x2,%eax
    7981:	76 0a                	jbe    798d <lodepng_deflatev+0x30>
    7983:	b8 3d 00 00 00       	mov    $0x3d,%eax
    7988:	e9 68 01 00 00       	jmp    7af5 <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    798d:	8b 45 14             	mov    0x14(%ebp),%eax
    7990:	8b 00                	mov    (%eax),%eax
    7992:	85 c0                	test   %eax,%eax
    7994:	75 16                	jne    79ac <lodepng_deflatev+0x4f>
    7996:	ff 75 10             	pushl  0x10(%ebp)
    7999:	ff 75 0c             	pushl  0xc(%ebp)
    799c:	ff 75 08             	pushl  0x8(%ebp)
    799f:	e8 01 f2 ff ff       	call   6ba5 <deflateNoCompression>
    79a4:	83 c4 0c             	add    $0xc,%esp
    79a7:	e9 49 01 00 00       	jmp    7af5 <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    79ac:	8b 45 14             	mov    0x14(%ebp),%eax
    79af:	8b 00                	mov    (%eax),%eax
    79b1:	83 f8 01             	cmp    $0x1,%eax
    79b4:	75 08                	jne    79be <lodepng_deflatev+0x61>
    79b6:	8b 45 10             	mov    0x10(%ebp),%eax
    79b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    79bc:	eb 2c                	jmp    79ea <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    79be:	8b 45 10             	mov    0x10(%ebp),%eax
    79c1:	c1 e8 03             	shr    $0x3,%eax
    79c4:	83 c0 08             	add    $0x8,%eax
    79c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    79ca:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    79d1:	7f 07                	jg     79da <lodepng_deflatev+0x7d>
    79d3:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    79da:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    79e1:	7e 07                	jle    79ea <lodepng_deflatev+0x8d>
    79e3:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    79ea:	8b 55 10             	mov    0x10(%ebp),%edx
    79ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
    79f0:	01 d0                	add    %edx,%eax
    79f2:	83 e8 01             	sub    $0x1,%eax
    79f5:	99                   	cltd   
    79f6:	f7 7d ec             	idivl  -0x14(%ebp)
    79f9:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    79fc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7a00:	75 07                	jne    7a09 <lodepng_deflatev+0xac>
    7a02:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    7a09:	8b 45 14             	mov    0x14(%ebp),%eax
    7a0c:	8b 40 08             	mov    0x8(%eax),%eax
    7a0f:	83 ec 08             	sub    $0x8,%esp
    7a12:	50                   	push   %eax
    7a13:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7a16:	50                   	push   %eax
    7a17:	e8 1c e8 ff ff       	call   6238 <hash_init>
    7a1c:	83 c4 10             	add    $0x10,%esp
    7a1f:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7a22:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7a26:	0f 85 b7 00 00 00    	jne    7ae3 <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7a2c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7a33:	e9 99 00 00 00       	jmp    7ad1 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    7a38:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7a3b:	83 e8 01             	sub    $0x1,%eax
    7a3e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7a41:	0f 94 c0             	sete   %al
    7a44:	0f b6 c0             	movzbl %al,%eax
    7a47:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    7a4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7a4d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    7a51:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    7a54:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7a57:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7a5a:	01 d0                	add    %edx,%eax
    7a5c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    7a5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7a62:	3b 45 10             	cmp    0x10(%ebp),%eax
    7a65:	7e 06                	jle    7a6d <lodepng_deflatev+0x110>
    7a67:	8b 45 10             	mov    0x10(%ebp),%eax
    7a6a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    7a6d:	8b 45 14             	mov    0x14(%ebp),%eax
    7a70:	8b 00                	mov    (%eax),%eax
    7a72:	83 f8 01             	cmp    $0x1,%eax
    7a75:	75 27                	jne    7a9e <lodepng_deflatev+0x141>
    7a77:	83 ec 04             	sub    $0x4,%esp
    7a7a:	ff 75 e0             	pushl  -0x20(%ebp)
    7a7d:	ff 75 14             	pushl  0x14(%ebp)
    7a80:	ff 75 e4             	pushl  -0x1c(%ebp)
    7a83:	ff 75 dc             	pushl  -0x24(%ebp)
    7a86:	ff 75 0c             	pushl  0xc(%ebp)
    7a89:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7a8c:	50                   	push   %eax
    7a8d:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a90:	50                   	push   %eax
    7a91:	e8 07 fd ff ff       	call   779d <deflateFixed>
    7a96:	83 c4 20             	add    $0x20,%esp
    7a99:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7a9c:	eb 2f                	jmp    7acd <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    7a9e:	8b 45 14             	mov    0x14(%ebp),%eax
    7aa1:	8b 00                	mov    (%eax),%eax
    7aa3:	83 f8 02             	cmp    $0x2,%eax
    7aa6:	75 25                	jne    7acd <lodepng_deflatev+0x170>
    7aa8:	83 ec 04             	sub    $0x4,%esp
    7aab:	ff 75 e0             	pushl  -0x20(%ebp)
    7aae:	ff 75 14             	pushl  0x14(%ebp)
    7ab1:	ff 75 e4             	pushl  -0x1c(%ebp)
    7ab4:	ff 75 dc             	pushl  -0x24(%ebp)
    7ab7:	ff 75 0c             	pushl  0xc(%ebp)
    7aba:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7abd:	50                   	push   %eax
    7abe:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7ac1:	50                   	push   %eax
    7ac2:	e8 7b f3 ff ff       	call   6e42 <deflateDynamic>
    7ac7:	83 c4 20             	add    $0x20,%esp
    7aca:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7acd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7ad1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7ad4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7ad7:	74 0a                	je     7ae3 <lodepng_deflatev+0x186>
    7ad9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7add:	0f 84 55 ff ff ff    	je     7a38 <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    7ae3:	83 ec 0c             	sub    $0xc,%esp
    7ae6:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7ae9:	50                   	push   %eax
    7aea:	e8 08 e9 ff ff       	call   63f7 <hash_cleanup>
    7aef:	83 c4 10             	add    $0x10,%esp

  return error;
    7af2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7af5:	c9                   	leave  
    7af6:	c3                   	ret    

00007af7 <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    7af7:	55                   	push   %ebp
    7af8:	89 e5                	mov    %esp,%ebp
    7afa:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7afd:	8b 45 0c             	mov    0xc(%ebp),%eax
    7b00:	8b 08                	mov    (%eax),%ecx
    7b02:	8b 45 08             	mov    0x8(%ebp),%eax
    7b05:	8b 10                	mov    (%eax),%edx
    7b07:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7b0a:	51                   	push   %ecx
    7b0b:	52                   	push   %edx
    7b0c:	50                   	push   %eax
    7b0d:	e8 f0 ba ff ff       	call   3602 <ucvector_init>
    7b12:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    7b15:	ff 75 18             	pushl  0x18(%ebp)
    7b18:	ff 75 14             	pushl  0x14(%ebp)
    7b1b:	ff 75 10             	pushl  0x10(%ebp)
    7b1e:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7b21:	50                   	push   %eax
    7b22:	e8 36 fe ff ff       	call   795d <lodepng_deflatev>
    7b27:	83 c4 10             	add    $0x10,%esp
    7b2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7b2d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7b30:	8b 45 08             	mov    0x8(%ebp),%eax
    7b33:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7b35:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7b38:	8b 45 0c             	mov    0xc(%ebp),%eax
    7b3b:	89 10                	mov    %edx,(%eax)
  return error;
    7b3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7b40:	c9                   	leave  
    7b41:	c3                   	ret    

00007b42 <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    7b42:	55                   	push   %ebp
    7b43:	89 e5                	mov    %esp,%ebp
    7b45:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    7b48:	8b 45 18             	mov    0x18(%ebp),%eax
    7b4b:	8b 40 1c             	mov    0x1c(%eax),%eax
    7b4e:	85 c0                	test   %eax,%eax
    7b50:	74 34                	je     7b86 <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    7b52:	8b 45 18             	mov    0x18(%ebp),%eax
    7b55:	8b 40 1c             	mov    0x1c(%eax),%eax
    7b58:	83 ec 0c             	sub    $0xc,%esp
    7b5b:	ff 75 18             	pushl  0x18(%ebp)
    7b5e:	ff 75 14             	pushl  0x14(%ebp)
    7b61:	ff 75 10             	pushl  0x10(%ebp)
    7b64:	ff 75 0c             	pushl  0xc(%ebp)
    7b67:	ff 75 08             	pushl  0x8(%ebp)
    7b6a:	ff d0                	call   *%eax
    7b6c:	83 c4 20             	add    $0x20,%esp
    7b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    7b72:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b76:	74 07                	je     7b7f <deflate+0x3d>
    7b78:	b8 6f 00 00 00       	mov    $0x6f,%eax
    7b7d:	eb 21                	jmp    7ba0 <deflate+0x5e>
    7b7f:	b8 00 00 00 00       	mov    $0x0,%eax
    7b84:	eb 1a                	jmp    7ba0 <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    7b86:	83 ec 0c             	sub    $0xc,%esp
    7b89:	ff 75 18             	pushl  0x18(%ebp)
    7b8c:	ff 75 14             	pushl  0x14(%ebp)
    7b8f:	ff 75 10             	pushl  0x10(%ebp)
    7b92:	ff 75 0c             	pushl  0xc(%ebp)
    7b95:	ff 75 08             	pushl  0x8(%ebp)
    7b98:	e8 5a ff ff ff       	call   7af7 <lodepng_deflate>
    7b9d:	83 c4 20             	add    $0x20,%esp
  }
}
    7ba0:	c9                   	leave  
    7ba1:	c3                   	ret    

00007ba2 <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    7ba2:	55                   	push   %ebp
    7ba3:	89 e5                	mov    %esp,%ebp
    7ba5:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    7ba8:	8b 45 08             	mov    0x8(%ebp),%eax
    7bab:	0f b7 c0             	movzwl %ax,%eax
    7bae:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    7bb1:	8b 45 08             	mov    0x8(%ebp),%eax
    7bb4:	c1 e8 10             	shr    $0x10,%eax
    7bb7:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    7bba:	e9 82 00 00 00       	jmp    7c41 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    7bbf:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    7bc4:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    7bcb:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    7bcf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    7bd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7bd5:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    7bd8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7bdf:	eb 1c                	jmp    7bfd <update_adler32+0x5b>
      s1 += (*data++);
    7be1:	8b 45 0c             	mov    0xc(%ebp),%eax
    7be4:	8d 50 01             	lea    0x1(%eax),%edx
    7be7:	89 55 0c             	mov    %edx,0xc(%ebp)
    7bea:	0f b6 00             	movzbl (%eax),%eax
    7bed:	0f b6 c0             	movzbl %al,%eax
    7bf0:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    7bf3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7bf6:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    7bf9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7bfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7c00:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7c03:	75 dc                	jne    7be1 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    7c05:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7c08:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7c0d:	89 c8                	mov    %ecx,%eax
    7c0f:	f7 e2                	mul    %edx
    7c11:	89 d0                	mov    %edx,%eax
    7c13:	c1 e8 0f             	shr    $0xf,%eax
    7c16:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7c1c:	29 c1                	sub    %eax,%ecx
    7c1e:	89 c8                	mov    %ecx,%eax
    7c20:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    7c23:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7c26:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7c2b:	89 c8                	mov    %ecx,%eax
    7c2d:	f7 e2                	mul    %edx
    7c2f:	89 d0                	mov    %edx,%eax
    7c31:	c1 e8 0f             	shr    $0xf,%eax
    7c34:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7c3a:	29 c1                	sub    %eax,%ecx
    7c3c:	89 c8                	mov    %ecx,%eax
    7c3e:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    7c41:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7c45:	0f 85 74 ff ff ff    	jne    7bbf <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    7c4b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7c4e:	c1 e0 10             	shl    $0x10,%eax
    7c51:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    7c54:	c9                   	leave  
    7c55:	c3                   	ret    

00007c56 <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    7c56:	55                   	push   %ebp
    7c57:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    7c59:	ff 75 0c             	pushl  0xc(%ebp)
    7c5c:	ff 75 08             	pushl  0x8(%ebp)
    7c5f:	6a 01                	push   $0x1
    7c61:	e8 3c ff ff ff       	call   7ba2 <update_adler32>
    7c66:	83 c4 0c             	add    $0xc,%esp
}
    7c69:	c9                   	leave  
    7c6a:	c3                   	ret    

00007c6b <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    7c6b:	55                   	push   %ebp
    7c6c:	89 e5                	mov    %esp,%ebp
    7c6e:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    7c71:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    7c78:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    7c7c:	7f 0a                	jg     7c88 <lodepng_zlib_decompressv+0x1d>
    7c7e:	b8 35 00 00 00       	mov    $0x35,%eax
    7c83:	e9 27 01 00 00       	jmp    7daf <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    7c88:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c8b:	0f b6 00             	movzbl (%eax),%eax
    7c8e:	0f b6 c0             	movzbl %al,%eax
    7c91:	c1 e0 08             	shl    $0x8,%eax
    7c94:	89 c2                	mov    %eax,%edx
    7c96:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c99:	83 c0 01             	add    $0x1,%eax
    7c9c:	0f b6 00             	movzbl (%eax),%eax
    7c9f:	0f b6 c0             	movzbl %al,%eax
    7ca2:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    7ca5:	ba 43 08 21 84       	mov    $0x84210843,%edx
    7caa:	89 c8                	mov    %ecx,%eax
    7cac:	f7 ea                	imul   %edx
    7cae:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    7cb1:	c1 f8 04             	sar    $0x4,%eax
    7cb4:	89 c2                	mov    %eax,%edx
    7cb6:	89 c8                	mov    %ecx,%eax
    7cb8:	c1 f8 1f             	sar    $0x1f,%eax
    7cbb:	29 c2                	sub    %eax,%edx
    7cbd:	89 d0                	mov    %edx,%eax
    7cbf:	89 c2                	mov    %eax,%edx
    7cc1:	c1 e2 05             	shl    $0x5,%edx
    7cc4:	29 c2                	sub    %eax,%edx
    7cc6:	89 c8                	mov    %ecx,%eax
    7cc8:	29 d0                	sub    %edx,%eax
    7cca:	85 c0                	test   %eax,%eax
    7ccc:	74 0a                	je     7cd8 <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    7cce:	b8 18 00 00 00       	mov    $0x18,%eax
    7cd3:	e9 d7 00 00 00       	jmp    7daf <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    7cd8:	8b 45 0c             	mov    0xc(%ebp),%eax
    7cdb:	0f b6 00             	movzbl (%eax),%eax
    7cde:	0f b6 c0             	movzbl %al,%eax
    7ce1:	83 e0 0f             	and    $0xf,%eax
    7ce4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    7ce7:	8b 45 0c             	mov    0xc(%ebp),%eax
    7cea:	0f b6 00             	movzbl (%eax),%eax
    7ced:	c0 e8 04             	shr    $0x4,%al
    7cf0:	0f b6 c0             	movzbl %al,%eax
    7cf3:	83 e0 0f             	and    $0xf,%eax
    7cf6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    7cf9:	8b 45 0c             	mov    0xc(%ebp),%eax
    7cfc:	83 c0 01             	add    $0x1,%eax
    7cff:	0f b6 00             	movzbl (%eax),%eax
    7d02:	c0 e8 05             	shr    $0x5,%al
    7d05:	0f b6 c0             	movzbl %al,%eax
    7d08:	83 e0 01             	and    $0x1,%eax
    7d0b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    7d0e:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    7d12:	75 06                	jne    7d1a <lodepng_zlib_decompressv+0xaf>
    7d14:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    7d18:	76 0a                	jbe    7d24 <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    7d1a:	b8 19 00 00 00       	mov    $0x19,%eax
    7d1f:	e9 8b 00 00 00       	jmp    7daf <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    7d24:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7d28:	74 07                	je     7d31 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    7d2a:	b8 1a 00 00 00       	mov    $0x1a,%eax
    7d2f:	eb 7e                	jmp    7daf <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    7d31:	8b 45 10             	mov    0x10(%ebp),%eax
    7d34:	8d 50 fe             	lea    -0x2(%eax),%edx
    7d37:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d3a:	83 c0 02             	add    $0x2,%eax
    7d3d:	ff 75 14             	pushl  0x14(%ebp)
    7d40:	52                   	push   %edx
    7d41:	50                   	push   %eax
    7d42:	ff 75 08             	pushl  0x8(%ebp)
    7d45:	e8 09 e3 ff ff       	call   6053 <inflatev>
    7d4a:	83 c4 10             	add    $0x10,%esp
    7d4d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    7d50:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7d54:	74 05                	je     7d5b <lodepng_zlib_decompressv+0xf0>
    7d56:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7d59:	eb 54                	jmp    7daf <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    7d5b:	8b 45 14             	mov    0x14(%ebp),%eax
    7d5e:	8b 00                	mov    (%eax),%eax
    7d60:	85 c0                	test   %eax,%eax
    7d62:	75 46                	jne    7daa <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    7d64:	8b 45 10             	mov    0x10(%ebp),%eax
    7d67:	8d 50 fc             	lea    -0x4(%eax),%edx
    7d6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d6d:	01 d0                	add    %edx,%eax
    7d6f:	83 ec 0c             	sub    $0xc,%esp
    7d72:	50                   	push   %eax
    7d73:	e8 47 b9 ff ff       	call   36bf <lodepng_read32bitInt>
    7d78:	83 c4 10             	add    $0x10,%esp
    7d7b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    7d7e:	8b 45 08             	mov    0x8(%ebp),%eax
    7d81:	8b 40 04             	mov    0x4(%eax),%eax
    7d84:	89 c2                	mov    %eax,%edx
    7d86:	8b 45 08             	mov    0x8(%ebp),%eax
    7d89:	8b 00                	mov    (%eax),%eax
    7d8b:	83 ec 08             	sub    $0x8,%esp
    7d8e:	52                   	push   %edx
    7d8f:	50                   	push   %eax
    7d90:	e8 c1 fe ff ff       	call   7c56 <adler32>
    7d95:	83 c4 10             	add    $0x10,%esp
    7d98:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    7d9b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7d9e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7da1:	74 07                	je     7daa <lodepng_zlib_decompressv+0x13f>
    7da3:	b8 3a 00 00 00       	mov    $0x3a,%eax
    7da8:	eb 05                	jmp    7daf <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    7daa:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7daf:	c9                   	leave  
    7db0:	c3                   	ret    

00007db1 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    7db1:	55                   	push   %ebp
    7db2:	89 e5                	mov    %esp,%ebp
    7db4:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7db7:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dba:	8b 08                	mov    (%eax),%ecx
    7dbc:	8b 45 08             	mov    0x8(%ebp),%eax
    7dbf:	8b 10                	mov    (%eax),%edx
    7dc1:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7dc4:	51                   	push   %ecx
    7dc5:	52                   	push   %edx
    7dc6:	50                   	push   %eax
    7dc7:	e8 36 b8 ff ff       	call   3602 <ucvector_init>
    7dcc:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7dcf:	ff 75 18             	pushl  0x18(%ebp)
    7dd2:	ff 75 14             	pushl  0x14(%ebp)
    7dd5:	ff 75 10             	pushl  0x10(%ebp)
    7dd8:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7ddb:	50                   	push   %eax
    7ddc:	e8 8a fe ff ff       	call   7c6b <lodepng_zlib_decompressv>
    7de1:	83 c4 10             	add    $0x10,%esp
    7de4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7de7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7dea:	8b 45 08             	mov    0x8(%ebp),%eax
    7ded:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7def:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7df2:	8b 45 0c             	mov    0xc(%ebp),%eax
    7df5:	89 10                	mov    %edx,(%eax)
  return error;
    7df7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7dfa:	c9                   	leave  
    7dfb:	c3                   	ret    

00007dfc <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    7dfc:	55                   	push   %ebp
    7dfd:	89 e5                	mov    %esp,%ebp
    7dff:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    7e02:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e05:	8b 40 0c             	mov    0xc(%eax),%eax
    7e08:	85 c0                	test   %eax,%eax
    7e0a:	74 57                	je     7e63 <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    7e0c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e0f:	8b 40 0c             	mov    0xc(%eax),%eax
    7e12:	83 ec 0c             	sub    $0xc,%esp
    7e15:	ff 75 1c             	pushl  0x1c(%ebp)
    7e18:	ff 75 18             	pushl  0x18(%ebp)
    7e1b:	ff 75 14             	pushl  0x14(%ebp)
    7e1e:	ff 75 0c             	pushl  0xc(%ebp)
    7e21:	ff 75 08             	pushl  0x8(%ebp)
    7e24:	ff d0                	call   *%eax
    7e26:	83 c4 20             	add    $0x20,%esp
    7e29:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    7e2c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7e30:	0f 84 98 00 00 00    	je     7ece <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    7e36:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    7e3d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e40:	8b 40 08             	mov    0x8(%eax),%eax
    7e43:	85 c0                	test   %eax,%eax
    7e45:	0f 84 83 00 00 00    	je     7ece <zlib_decompress+0xd2>
    7e4b:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e4e:	8b 10                	mov    (%eax),%edx
    7e50:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e53:	8b 40 08             	mov    0x8(%eax),%eax
    7e56:	39 c2                	cmp    %eax,%edx
    7e58:	7e 74                	jle    7ece <zlib_decompress+0xd2>
    7e5a:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    7e61:	eb 6b                	jmp    7ece <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    7e63:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e66:	8b 08                	mov    (%eax),%ecx
    7e68:	8b 45 08             	mov    0x8(%ebp),%eax
    7e6b:	8b 10                	mov    (%eax),%edx
    7e6d:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e70:	83 ec 04             	sub    $0x4,%esp
    7e73:	51                   	push   %ecx
    7e74:	52                   	push   %edx
    7e75:	50                   	push   %eax
    7e76:	e8 87 b7 ff ff       	call   3602 <ucvector_init>
    7e7b:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    7e7e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7e82:	74 22                	je     7ea6 <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    7e84:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e87:	8b 10                	mov    (%eax),%edx
    7e89:	8b 45 10             	mov    0x10(%ebp),%eax
    7e8c:	01 d0                	add    %edx,%eax
    7e8e:	83 ec 08             	sub    $0x8,%esp
    7e91:	50                   	push   %eax
    7e92:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e95:	50                   	push   %eax
    7e96:	e8 00 b7 ff ff       	call   359b <ucvector_resize>
    7e9b:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    7e9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ea1:	8b 00                	mov    (%eax),%eax
    7ea3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7ea6:	ff 75 1c             	pushl  0x1c(%ebp)
    7ea9:	ff 75 18             	pushl  0x18(%ebp)
    7eac:	ff 75 14             	pushl  0x14(%ebp)
    7eaf:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7eb2:	50                   	push   %eax
    7eb3:	e8 b3 fd ff ff       	call   7c6b <lodepng_zlib_decompressv>
    7eb8:	83 c4 10             	add    $0x10,%esp
    7ebb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    7ebe:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7ec1:	8b 45 08             	mov    0x8(%ebp),%eax
    7ec4:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    7ec6:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7ec9:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ecc:	89 10                	mov    %edx,(%eax)
  }
  return error;
    7ece:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7ed1:	c9                   	leave  
    7ed2:	c3                   	ret    

00007ed3 <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    7ed3:	55                   	push   %ebp
    7ed4:	89 e5                	mov    %esp,%ebp
    7ed6:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    7ed9:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    7ee0:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    7ee7:	83 ec 0c             	sub    $0xc,%esp
    7eea:	ff 75 18             	pushl  0x18(%ebp)
    7eed:	ff 75 14             	pushl  0x14(%ebp)
    7ef0:	ff 75 10             	pushl  0x10(%ebp)
    7ef3:	8d 45 d0             	lea    -0x30(%ebp),%eax
    7ef6:	50                   	push   %eax
    7ef7:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7efa:	50                   	push   %eax
    7efb:	e8 42 fc ff ff       	call   7b42 <deflate>
    7f00:	83 c4 20             	add    $0x20,%esp
    7f03:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    7f06:	8b 45 08             	mov    0x8(%ebp),%eax
    7f09:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    7f0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f12:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    7f18:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7f1c:	75 33                	jne    7f51 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    7f1e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7f21:	8d 50 06             	lea    0x6(%eax),%edx
    7f24:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f27:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    7f29:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f2c:	8b 00                	mov    (%eax),%eax
    7f2e:	83 ec 0c             	sub    $0xc,%esp
    7f31:	50                   	push   %eax
    7f32:	e8 0a b4 ff ff       	call   3341 <lodepng_malloc>
    7f37:	83 c4 10             	add    $0x10,%esp
    7f3a:	89 c2                	mov    %eax,%edx
    7f3c:	8b 45 08             	mov    0x8(%ebp),%eax
    7f3f:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    7f41:	8b 45 08             	mov    0x8(%ebp),%eax
    7f44:	8b 00                	mov    (%eax),%eax
    7f46:	85 c0                	test   %eax,%eax
    7f48:	75 07                	jne    7f51 <lodepng_zlib_compress+0x7e>
    7f4a:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    7f51:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7f55:	0f 85 e2 00 00 00    	jne    803d <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    7f5b:	8b 45 14             	mov    0x14(%ebp),%eax
    7f5e:	83 ec 08             	sub    $0x8,%esp
    7f61:	50                   	push   %eax
    7f62:	ff 75 10             	pushl  0x10(%ebp)
    7f65:	e8 ec fc ff ff       	call   7c56 <adler32>
    7f6a:	83 c4 10             	add    $0x10,%esp
    7f6d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    7f70:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    7f77:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    7f7e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    7f85:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7f88:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7f8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7f92:	01 d0                	add    %edx,%eax
    7f94:	8d 14 00             	lea    (%eax,%eax,1),%edx
    7f97:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7f9a:	01 d0                	add    %edx,%eax
    7f9c:	c1 e0 05             	shl    $0x5,%eax
    7f9f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    7fa2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7fa5:	ba 85 10 42 08       	mov    $0x8421085,%edx
    7faa:	89 c8                	mov    %ecx,%eax
    7fac:	f7 e2                	mul    %edx
    7fae:	89 c8                	mov    %ecx,%eax
    7fb0:	29 d0                	sub    %edx,%eax
    7fb2:	d1 e8                	shr    %eax
    7fb4:	01 d0                	add    %edx,%eax
    7fb6:	c1 e8 04             	shr    $0x4,%eax
    7fb9:	89 c2                	mov    %eax,%edx
    7fbb:	c1 e2 05             	shl    $0x5,%edx
    7fbe:	29 c2                	sub    %eax,%edx
    7fc0:	89 c8                	mov    %ecx,%eax
    7fc2:	29 d0                	sub    %edx,%eax
    7fc4:	ba 1f 00 00 00       	mov    $0x1f,%edx
    7fc9:	29 c2                	sub    %eax,%edx
    7fcb:	89 d0                	mov    %edx,%eax
    7fcd:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    7fd0:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7fd3:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    7fd6:	8b 45 08             	mov    0x8(%ebp),%eax
    7fd9:	8b 00                	mov    (%eax),%eax
    7fdb:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7fde:	c1 ea 08             	shr    $0x8,%edx
    7fe1:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    7fe3:	8b 45 08             	mov    0x8(%ebp),%eax
    7fe6:	8b 00                	mov    (%eax),%eax
    7fe8:	83 c0 01             	add    $0x1,%eax
    7feb:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7fee:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    7ff0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7ff7:	eb 1e                	jmp    8017 <lodepng_zlib_compress+0x144>
    7ff9:	8b 45 08             	mov    0x8(%ebp),%eax
    7ffc:	8b 00                	mov    (%eax),%eax
    7ffe:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8001:	83 c2 02             	add    $0x2,%edx
    8004:	01 c2                	add    %eax,%edx
    8006:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    8009:	8b 45 f4             	mov    -0xc(%ebp),%eax
    800c:	01 c8                	add    %ecx,%eax
    800e:	0f b6 00             	movzbl (%eax),%eax
    8011:	88 02                	mov    %al,(%edx)
    8013:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8017:	8b 45 d0             	mov    -0x30(%ebp),%eax
    801a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    801d:	75 da                	jne    7ff9 <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    801f:	8b 45 08             	mov    0x8(%ebp),%eax
    8022:	8b 10                	mov    (%eax),%edx
    8024:	8b 45 0c             	mov    0xc(%ebp),%eax
    8027:	8b 00                	mov    (%eax),%eax
    8029:	83 e8 04             	sub    $0x4,%eax
    802c:	01 d0                	add    %edx,%eax
    802e:	83 ec 08             	sub    $0x8,%esp
    8031:	ff 75 ec             	pushl  -0x14(%ebp)
    8034:	50                   	push   %eax
    8035:	e8 c8 b6 ff ff       	call   3702 <lodepng_set32bitInt>
    803a:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    803d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8040:	83 ec 0c             	sub    $0xc,%esp
    8043:	50                   	push   %eax
    8044:	e8 19 b3 ff ff       	call   3362 <lodepng_free>
    8049:	83 c4 10             	add    $0x10,%esp
  return error;
    804c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    804f:	c9                   	leave  
    8050:	c3                   	ret    

00008051 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    8051:	55                   	push   %ebp
    8052:	89 e5                	mov    %esp,%ebp
    8054:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    8057:	8b 45 18             	mov    0x18(%ebp),%eax
    805a:	8b 40 18             	mov    0x18(%eax),%eax
    805d:	85 c0                	test   %eax,%eax
    805f:	74 34                	je     8095 <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    8061:	8b 45 18             	mov    0x18(%ebp),%eax
    8064:	8b 40 18             	mov    0x18(%eax),%eax
    8067:	83 ec 0c             	sub    $0xc,%esp
    806a:	ff 75 18             	pushl  0x18(%ebp)
    806d:	ff 75 14             	pushl  0x14(%ebp)
    8070:	ff 75 10             	pushl  0x10(%ebp)
    8073:	ff 75 0c             	pushl  0xc(%ebp)
    8076:	ff 75 08             	pushl  0x8(%ebp)
    8079:	ff d0                	call   *%eax
    807b:	83 c4 20             	add    $0x20,%esp
    807e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    8081:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8085:	74 07                	je     808e <zlib_compress+0x3d>
    8087:	b8 6f 00 00 00       	mov    $0x6f,%eax
    808c:	eb 21                	jmp    80af <zlib_compress+0x5e>
    808e:	b8 00 00 00 00       	mov    $0x0,%eax
    8093:	eb 1a                	jmp    80af <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    8095:	83 ec 0c             	sub    $0xc,%esp
    8098:	ff 75 18             	pushl  0x18(%ebp)
    809b:	ff 75 14             	pushl  0x14(%ebp)
    809e:	ff 75 10             	pushl  0x10(%ebp)
    80a1:	ff 75 0c             	pushl  0xc(%ebp)
    80a4:	ff 75 08             	pushl  0x8(%ebp)
    80a7:	e8 27 fe ff ff       	call   7ed3 <lodepng_zlib_compress>
    80ac:	83 c4 20             	add    $0x20,%esp
  }
}
    80af:	c9                   	leave  
    80b0:	c3                   	ret    

000080b1 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    80b1:	55                   	push   %ebp
    80b2:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    80b4:	8b 45 08             	mov    0x8(%ebp),%eax
    80b7:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    80bd:	8b 45 08             	mov    0x8(%ebp),%eax
    80c0:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    80c7:	8b 45 08             	mov    0x8(%ebp),%eax
    80ca:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    80d1:	8b 45 08             	mov    0x8(%ebp),%eax
    80d4:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    80db:	8b 45 08             	mov    0x8(%ebp),%eax
    80de:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    80e5:	8b 45 08             	mov    0x8(%ebp),%eax
    80e8:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    80ef:	8b 45 08             	mov    0x8(%ebp),%eax
    80f2:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    80f9:	8b 45 08             	mov    0x8(%ebp),%eax
    80fc:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    8103:	8b 45 08             	mov    0x8(%ebp),%eax
    8106:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    810d:	90                   	nop
    810e:	5d                   	pop    %ebp
    810f:	c3                   	ret    

00008110 <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    8110:	55                   	push   %ebp
    8111:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    8113:	8b 45 08             	mov    0x8(%ebp),%eax
    8116:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    811c:	8b 45 08             	mov    0x8(%ebp),%eax
    811f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    8126:	8b 45 08             	mov    0x8(%ebp),%eax
    8129:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    8130:	8b 45 08             	mov    0x8(%ebp),%eax
    8133:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    813a:	8b 45 08             	mov    0x8(%ebp),%eax
    813d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    8144:	8b 45 08             	mov    0x8(%ebp),%eax
    8147:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    814e:	90                   	nop
    814f:	5d                   	pop    %ebp
    8150:	c3                   	ret    

00008151 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    8151:	55                   	push   %ebp
    8152:	89 e5                	mov    %esp,%ebp
    8154:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    8157:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    815e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8165:	eb 2a                	jmp    8191 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    8167:	8b 55 f8             	mov    -0x8(%ebp),%edx
    816a:	8b 45 08             	mov    0x8(%ebp),%eax
    816d:	01 d0                	add    %edx,%eax
    816f:	0f b6 00             	movzbl (%eax),%eax
    8172:	0f b6 c0             	movzbl %al,%eax
    8175:	33 45 fc             	xor    -0x4(%ebp),%eax
    8178:	0f b6 c0             	movzbl %al,%eax
    817b:	8b 04 85 40 e1 01 00 	mov    0x1e140(,%eax,4),%eax
    8182:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8185:	c1 ea 08             	shr    $0x8,%edx
    8188:	31 d0                	xor    %edx,%eax
    818a:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    818d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8191:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8194:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8197:	7c ce                	jl     8167 <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    8199:	8b 45 fc             	mov    -0x4(%ebp),%eax
    819c:	f7 d0                	not    %eax
}
    819e:	c9                   	leave  
    819f:	c3                   	ret    

000081a0 <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    81a0:	55                   	push   %ebp
    81a1:	89 e5                	mov    %esp,%ebp
    81a3:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    81a6:	8b 45 08             	mov    0x8(%ebp),%eax
    81a9:	8b 00                	mov    (%eax),%eax
    81ab:	c1 f8 03             	sar    $0x3,%eax
    81ae:	89 c2                	mov    %eax,%edx
    81b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    81b3:	01 d0                	add    %edx,%eax
    81b5:	0f b6 00             	movzbl (%eax),%eax
    81b8:	0f b6 d0             	movzbl %al,%edx
    81bb:	8b 45 08             	mov    0x8(%ebp),%eax
    81be:	8b 00                	mov    (%eax),%eax
    81c0:	f7 d0                	not    %eax
    81c2:	83 e0 07             	and    $0x7,%eax
    81c5:	89 c1                	mov    %eax,%ecx
    81c7:	d3 fa                	sar    %cl,%edx
    81c9:	89 d0                	mov    %edx,%eax
    81cb:	83 e0 01             	and    $0x1,%eax
    81ce:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    81d1:	8b 45 08             	mov    0x8(%ebp),%eax
    81d4:	8b 00                	mov    (%eax),%eax
    81d6:	8d 50 01             	lea    0x1(%eax),%edx
    81d9:	8b 45 08             	mov    0x8(%ebp),%eax
    81dc:	89 10                	mov    %edx,(%eax)
  return result;
    81de:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    81e2:	c9                   	leave  
    81e3:	c3                   	ret    

000081e4 <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    81e4:	55                   	push   %ebp
    81e5:	89 e5                	mov    %esp,%ebp
    81e7:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    81ea:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    81f1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    81f8:	eb 1b                	jmp    8215 <readBitsFromReversedStream+0x31>
    result <<= 1u;
    81fa:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    81fd:	ff 75 0c             	pushl  0xc(%ebp)
    8200:	ff 75 08             	pushl  0x8(%ebp)
    8203:	e8 98 ff ff ff       	call   81a0 <readBitFromReversedStream>
    8208:	83 c4 08             	add    $0x8,%esp
    820b:	0f b6 c0             	movzbl %al,%eax
    820e:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    8211:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8215:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8218:	3b 45 10             	cmp    0x10(%ebp),%eax
    821b:	7c dd                	jl     81fa <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    821d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    8220:	c9                   	leave  
    8221:	c3                   	ret    

00008222 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    8222:	55                   	push   %ebp
    8223:	89 e5                	mov    %esp,%ebp
    8225:	56                   	push   %esi
    8226:	53                   	push   %ebx
    8227:	83 ec 04             	sub    $0x4,%esp
    822a:	8b 45 10             	mov    0x10(%ebp),%eax
    822d:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    8230:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    8234:	75 3e                	jne    8274 <setBitOfReversedStream+0x52>
    8236:	8b 45 08             	mov    0x8(%ebp),%eax
    8239:	8b 00                	mov    (%eax),%eax
    823b:	c1 f8 03             	sar    $0x3,%eax
    823e:	89 c2                	mov    %eax,%edx
    8240:	8b 45 0c             	mov    0xc(%ebp),%eax
    8243:	01 c2                	add    %eax,%edx
    8245:	8b 45 08             	mov    0x8(%ebp),%eax
    8248:	8b 00                	mov    (%eax),%eax
    824a:	c1 f8 03             	sar    $0x3,%eax
    824d:	89 c1                	mov    %eax,%ecx
    824f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8252:	01 c8                	add    %ecx,%eax
    8254:	0f b6 18             	movzbl (%eax),%ebx
    8257:	8b 45 08             	mov    0x8(%ebp),%eax
    825a:	8b 00                	mov    (%eax),%eax
    825c:	f7 d0                	not    %eax
    825e:	83 e0 07             	and    $0x7,%eax
    8261:	be 01 00 00 00       	mov    $0x1,%esi
    8266:	89 c1                	mov    %eax,%ecx
    8268:	d3 e6                	shl    %cl,%esi
    826a:	89 f0                	mov    %esi,%eax
    826c:	f7 d0                	not    %eax
    826e:	21 d8                	and    %ebx,%eax
    8270:	88 02                	mov    %al,(%edx)
    8272:	eb 3a                	jmp    82ae <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    8274:	8b 45 08             	mov    0x8(%ebp),%eax
    8277:	8b 00                	mov    (%eax),%eax
    8279:	c1 f8 03             	sar    $0x3,%eax
    827c:	89 c2                	mov    %eax,%edx
    827e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8281:	01 c2                	add    %eax,%edx
    8283:	8b 45 08             	mov    0x8(%ebp),%eax
    8286:	8b 00                	mov    (%eax),%eax
    8288:	c1 f8 03             	sar    $0x3,%eax
    828b:	89 c1                	mov    %eax,%ecx
    828d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8290:	01 c8                	add    %ecx,%eax
    8292:	0f b6 18             	movzbl (%eax),%ebx
    8295:	8b 45 08             	mov    0x8(%ebp),%eax
    8298:	8b 00                	mov    (%eax),%eax
    829a:	f7 d0                	not    %eax
    829c:	83 e0 07             	and    $0x7,%eax
    829f:	be 01 00 00 00       	mov    $0x1,%esi
    82a4:	89 c1                	mov    %eax,%ecx
    82a6:	d3 e6                	shl    %cl,%esi
    82a8:	89 f0                	mov    %esi,%eax
    82aa:	09 d8                	or     %ebx,%eax
    82ac:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    82ae:	8b 45 08             	mov    0x8(%ebp),%eax
    82b1:	8b 00                	mov    (%eax),%eax
    82b3:	8d 50 01             	lea    0x1(%eax),%edx
    82b6:	8b 45 08             	mov    0x8(%ebp),%eax
    82b9:	89 10                	mov    %edx,(%eax)
}
    82bb:	90                   	nop
    82bc:	83 c4 04             	add    $0x4,%esp
    82bf:	5b                   	pop    %ebx
    82c0:	5e                   	pop    %esi
    82c1:	5d                   	pop    %ebp
    82c2:	c3                   	ret    

000082c3 <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    82c3:	55                   	push   %ebp
    82c4:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    82c6:	ff 75 08             	pushl  0x8(%ebp)
    82c9:	e8 f1 b3 ff ff       	call   36bf <lodepng_read32bitInt>
    82ce:	83 c4 04             	add    $0x4,%esp
}
    82d1:	c9                   	leave  
    82d2:	c3                   	ret    

000082d3 <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    82d3:	55                   	push   %ebp
    82d4:	89 e5                	mov    %esp,%ebp
    82d6:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    82d9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    82e0:	eb 1c                	jmp    82fe <lodepng_chunk_type+0x2b>
    82e2:	8b 55 08             	mov    0x8(%ebp),%edx
    82e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    82e8:	01 d0                	add    %edx,%eax
    82ea:	8b 55 fc             	mov    -0x4(%ebp),%edx
    82ed:	8d 4a 04             	lea    0x4(%edx),%ecx
    82f0:	8b 55 0c             	mov    0xc(%ebp),%edx
    82f3:	01 ca                	add    %ecx,%edx
    82f5:	0f b6 12             	movzbl (%edx),%edx
    82f8:	88 10                	mov    %dl,(%eax)
    82fa:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    82fe:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    8302:	75 de                	jne    82e2 <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    8304:	8b 45 08             	mov    0x8(%ebp),%eax
    8307:	83 c0 04             	add    $0x4,%eax
    830a:	c6 00 00             	movb   $0x0,(%eax)
}
    830d:	90                   	nop
    830e:	c9                   	leave  
    830f:	c3                   	ret    

00008310 <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    8310:	55                   	push   %ebp
    8311:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    8313:	ff 75 0c             	pushl  0xc(%ebp)
    8316:	e8 c2 b0 ff ff       	call   33dd <lodepng_strlen>
    831b:	83 c4 04             	add    $0x4,%esp
    831e:	83 f8 04             	cmp    $0x4,%eax
    8321:	74 07                	je     832a <lodepng_chunk_type_equals+0x1a>
    8323:	b8 00 00 00 00       	mov    $0x0,%eax
    8328:	eb 79                	jmp    83a3 <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    832a:	8b 45 08             	mov    0x8(%ebp),%eax
    832d:	83 c0 04             	add    $0x4,%eax
    8330:	0f b6 00             	movzbl (%eax),%eax
    8333:	0f b6 d0             	movzbl %al,%edx
    8336:	8b 45 0c             	mov    0xc(%ebp),%eax
    8339:	0f b6 00             	movzbl (%eax),%eax
    833c:	0f be c0             	movsbl %al,%eax
    833f:	39 c2                	cmp    %eax,%edx
    8341:	75 5b                	jne    839e <lodepng_chunk_type_equals+0x8e>
    8343:	8b 45 08             	mov    0x8(%ebp),%eax
    8346:	83 c0 05             	add    $0x5,%eax
    8349:	0f b6 00             	movzbl (%eax),%eax
    834c:	0f b6 d0             	movzbl %al,%edx
    834f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8352:	83 c0 01             	add    $0x1,%eax
    8355:	0f b6 00             	movzbl (%eax),%eax
    8358:	0f be c0             	movsbl %al,%eax
    835b:	39 c2                	cmp    %eax,%edx
    835d:	75 3f                	jne    839e <lodepng_chunk_type_equals+0x8e>
    835f:	8b 45 08             	mov    0x8(%ebp),%eax
    8362:	83 c0 06             	add    $0x6,%eax
    8365:	0f b6 00             	movzbl (%eax),%eax
    8368:	0f b6 d0             	movzbl %al,%edx
    836b:	8b 45 0c             	mov    0xc(%ebp),%eax
    836e:	83 c0 02             	add    $0x2,%eax
    8371:	0f b6 00             	movzbl (%eax),%eax
    8374:	0f be c0             	movsbl %al,%eax
    8377:	39 c2                	cmp    %eax,%edx
    8379:	75 23                	jne    839e <lodepng_chunk_type_equals+0x8e>
    837b:	8b 45 08             	mov    0x8(%ebp),%eax
    837e:	83 c0 07             	add    $0x7,%eax
    8381:	0f b6 00             	movzbl (%eax),%eax
    8384:	0f b6 d0             	movzbl %al,%edx
    8387:	8b 45 0c             	mov    0xc(%ebp),%eax
    838a:	83 c0 03             	add    $0x3,%eax
    838d:	0f b6 00             	movzbl (%eax),%eax
    8390:	0f be c0             	movsbl %al,%eax
    8393:	39 c2                	cmp    %eax,%edx
    8395:	75 07                	jne    839e <lodepng_chunk_type_equals+0x8e>
    8397:	b8 01 00 00 00       	mov    $0x1,%eax
    839c:	eb 05                	jmp    83a3 <lodepng_chunk_type_equals+0x93>
    839e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    83a3:	c9                   	leave  
    83a4:	c3                   	ret    

000083a5 <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    83a5:	55                   	push   %ebp
    83a6:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    83a8:	8b 45 08             	mov    0x8(%ebp),%eax
    83ab:	83 c0 04             	add    $0x4,%eax
    83ae:	0f b6 00             	movzbl (%eax),%eax
    83b1:	0f b6 c0             	movzbl %al,%eax
    83b4:	83 e0 20             	and    $0x20,%eax
    83b7:	85 c0                	test   %eax,%eax
    83b9:	0f 95 c0             	setne  %al
}
    83bc:	5d                   	pop    %ebp
    83bd:	c3                   	ret    

000083be <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    83be:	55                   	push   %ebp
    83bf:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    83c1:	8b 45 08             	mov    0x8(%ebp),%eax
    83c4:	83 c0 06             	add    $0x6,%eax
    83c7:	0f b6 00             	movzbl (%eax),%eax
    83ca:	0f b6 c0             	movzbl %al,%eax
    83cd:	83 e0 20             	and    $0x20,%eax
    83d0:	85 c0                	test   %eax,%eax
    83d2:	0f 95 c0             	setne  %al
}
    83d5:	5d                   	pop    %ebp
    83d6:	c3                   	ret    

000083d7 <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    83d7:	55                   	push   %ebp
    83d8:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    83da:	8b 45 08             	mov    0x8(%ebp),%eax
    83dd:	83 c0 07             	add    $0x7,%eax
    83e0:	0f b6 00             	movzbl (%eax),%eax
    83e3:	0f b6 c0             	movzbl %al,%eax
    83e6:	83 e0 20             	and    $0x20,%eax
    83e9:	85 c0                	test   %eax,%eax
    83eb:	0f 95 c0             	setne  %al
}
    83ee:	5d                   	pop    %ebp
    83ef:	c3                   	ret    

000083f0 <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    83f0:	55                   	push   %ebp
    83f1:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    83f3:	8b 45 08             	mov    0x8(%ebp),%eax
    83f6:	83 c0 08             	add    $0x8,%eax
}
    83f9:	5d                   	pop    %ebp
    83fa:	c3                   	ret    

000083fb <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    83fb:	55                   	push   %ebp
    83fc:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    83fe:	8b 45 08             	mov    0x8(%ebp),%eax
    8401:	83 c0 08             	add    $0x8,%eax
}
    8404:	5d                   	pop    %ebp
    8405:	c3                   	ret    

00008406 <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    8406:	55                   	push   %ebp
    8407:	89 e5                	mov    %esp,%ebp
    8409:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    840c:	ff 75 08             	pushl  0x8(%ebp)
    840f:	e8 af fe ff ff       	call   82c3 <lodepng_chunk_length>
    8414:	83 c4 04             	add    $0x4,%esp
    8417:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    841a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    841d:	8d 50 08             	lea    0x8(%eax),%edx
    8420:	8b 45 08             	mov    0x8(%ebp),%eax
    8423:	01 d0                	add    %edx,%eax
    8425:	50                   	push   %eax
    8426:	e8 94 b2 ff ff       	call   36bf <lodepng_read32bitInt>
    842b:	83 c4 04             	add    $0x4,%esp
    842e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    8431:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8434:	83 c0 04             	add    $0x4,%eax
    8437:	89 c2                	mov    %eax,%edx
    8439:	8b 45 08             	mov    0x8(%ebp),%eax
    843c:	83 c0 04             	add    $0x4,%eax
    843f:	52                   	push   %edx
    8440:	50                   	push   %eax
    8441:	e8 0b fd ff ff       	call   8151 <lodepng_crc32>
    8446:	83 c4 08             	add    $0x8,%esp
    8449:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    844c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    844f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    8452:	74 07                	je     845b <lodepng_chunk_check_crc+0x55>
    8454:	b8 01 00 00 00       	mov    $0x1,%eax
    8459:	eb 05                	jmp    8460 <lodepng_chunk_check_crc+0x5a>
  else return 0;
    845b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8460:	c9                   	leave  
    8461:	c3                   	ret    

00008462 <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    8462:	55                   	push   %ebp
    8463:	89 e5                	mov    %esp,%ebp
    8465:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    8468:	ff 75 08             	pushl  0x8(%ebp)
    846b:	e8 53 fe ff ff       	call   82c3 <lodepng_chunk_length>
    8470:	83 c4 04             	add    $0x4,%esp
    8473:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    8476:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8479:	83 c0 04             	add    $0x4,%eax
    847c:	89 c2                	mov    %eax,%edx
    847e:	8b 45 08             	mov    0x8(%ebp),%eax
    8481:	83 c0 04             	add    $0x4,%eax
    8484:	52                   	push   %edx
    8485:	50                   	push   %eax
    8486:	e8 c6 fc ff ff       	call   8151 <lodepng_crc32>
    848b:	83 c4 08             	add    $0x8,%esp
    848e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    8491:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8494:	8d 50 08             	lea    0x8(%eax),%edx
    8497:	8b 45 08             	mov    0x8(%ebp),%eax
    849a:	01 d0                	add    %edx,%eax
    849c:	ff 75 f8             	pushl  -0x8(%ebp)
    849f:	50                   	push   %eax
    84a0:	e8 5d b2 ff ff       	call   3702 <lodepng_set32bitInt>
    84a5:	83 c4 08             	add    $0x8,%esp
}
    84a8:	90                   	nop
    84a9:	c9                   	leave  
    84aa:	c3                   	ret    

000084ab <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    84ab:	55                   	push   %ebp
    84ac:	89 e5                	mov    %esp,%ebp
    84ae:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    84b1:	8b 45 08             	mov    0x8(%ebp),%eax
    84b4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    84b7:	73 0f                	jae    84c8 <lodepng_chunk_next+0x1d>
    84b9:	8b 55 0c             	mov    0xc(%ebp),%edx
    84bc:	8b 45 08             	mov    0x8(%ebp),%eax
    84bf:	29 c2                	sub    %eax,%edx
    84c1:	89 d0                	mov    %edx,%eax
    84c3:	83 f8 0b             	cmp    $0xb,%eax
    84c6:	7f 08                	jg     84d0 <lodepng_chunk_next+0x25>
    84c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    84cb:	e9 af 00 00 00       	jmp    857f <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    84d0:	8b 45 08             	mov    0x8(%ebp),%eax
    84d3:	0f b6 00             	movzbl (%eax),%eax
    84d6:	3c 89                	cmp    $0x89,%al
    84d8:	75 63                	jne    853d <lodepng_chunk_next+0x92>
    84da:	8b 45 08             	mov    0x8(%ebp),%eax
    84dd:	83 c0 01             	add    $0x1,%eax
    84e0:	0f b6 00             	movzbl (%eax),%eax
    84e3:	3c 50                	cmp    $0x50,%al
    84e5:	75 56                	jne    853d <lodepng_chunk_next+0x92>
    84e7:	8b 45 08             	mov    0x8(%ebp),%eax
    84ea:	83 c0 02             	add    $0x2,%eax
    84ed:	0f b6 00             	movzbl (%eax),%eax
    84f0:	3c 4e                	cmp    $0x4e,%al
    84f2:	75 49                	jne    853d <lodepng_chunk_next+0x92>
    84f4:	8b 45 08             	mov    0x8(%ebp),%eax
    84f7:	83 c0 03             	add    $0x3,%eax
    84fa:	0f b6 00             	movzbl (%eax),%eax
    84fd:	3c 47                	cmp    $0x47,%al
    84ff:	75 3c                	jne    853d <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    8501:	8b 45 08             	mov    0x8(%ebp),%eax
    8504:	83 c0 04             	add    $0x4,%eax
    8507:	0f b6 00             	movzbl (%eax),%eax
    850a:	3c 0d                	cmp    $0xd,%al
    850c:	75 2f                	jne    853d <lodepng_chunk_next+0x92>
    850e:	8b 45 08             	mov    0x8(%ebp),%eax
    8511:	83 c0 05             	add    $0x5,%eax
    8514:	0f b6 00             	movzbl (%eax),%eax
    8517:	3c 0a                	cmp    $0xa,%al
    8519:	75 22                	jne    853d <lodepng_chunk_next+0x92>
    851b:	8b 45 08             	mov    0x8(%ebp),%eax
    851e:	83 c0 06             	add    $0x6,%eax
    8521:	0f b6 00             	movzbl (%eax),%eax
    8524:	3c 1a                	cmp    $0x1a,%al
    8526:	75 15                	jne    853d <lodepng_chunk_next+0x92>
    8528:	8b 45 08             	mov    0x8(%ebp),%eax
    852b:	83 c0 07             	add    $0x7,%eax
    852e:	0f b6 00             	movzbl (%eax),%eax
    8531:	3c 0a                	cmp    $0xa,%al
    8533:	75 08                	jne    853d <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    8535:	8b 45 08             	mov    0x8(%ebp),%eax
    8538:	83 c0 08             	add    $0x8,%eax
    853b:	eb 42                	jmp    857f <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    853d:	ff 75 08             	pushl  0x8(%ebp)
    8540:	e8 7e fd ff ff       	call   82c3 <lodepng_chunk_length>
    8545:	83 c4 04             	add    $0x4,%esp
    8548:	89 c2                	mov    %eax,%edx
    854a:	8d 45 f8             	lea    -0x8(%ebp),%eax
    854d:	50                   	push   %eax
    854e:	6a 0c                	push   $0xc
    8550:	52                   	push   %edx
    8551:	e8 af ae ff ff       	call   3405 <lodepng_addofl>
    8556:	83 c4 0c             	add    $0xc,%esp
    8559:	85 c0                	test   %eax,%eax
    855b:	74 05                	je     8562 <lodepng_chunk_next+0xb7>
    855d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8560:	eb 1d                	jmp    857f <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    8562:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8565:	89 c2                	mov    %eax,%edx
    8567:	8b 45 08             	mov    0x8(%ebp),%eax
    856a:	01 d0                	add    %edx,%eax
    856c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    856f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8572:	3b 45 08             	cmp    0x8(%ebp),%eax
    8575:	73 05                	jae    857c <lodepng_chunk_next+0xd1>
    8577:	8b 45 0c             	mov    0xc(%ebp),%eax
    857a:	eb 03                	jmp    857f <lodepng_chunk_next+0xd4>
    return result;
    857c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    857f:	c9                   	leave  
    8580:	c3                   	ret    

00008581 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    8581:	55                   	push   %ebp
    8582:	89 e5                	mov    %esp,%ebp
    8584:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8587:	8b 45 08             	mov    0x8(%ebp),%eax
    858a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    858d:	73 0f                	jae    859e <lodepng_chunk_next_const+0x1d>
    858f:	8b 55 0c             	mov    0xc(%ebp),%edx
    8592:	8b 45 08             	mov    0x8(%ebp),%eax
    8595:	29 c2                	sub    %eax,%edx
    8597:	89 d0                	mov    %edx,%eax
    8599:	83 f8 0b             	cmp    $0xb,%eax
    859c:	7f 08                	jg     85a6 <lodepng_chunk_next_const+0x25>
    859e:	8b 45 0c             	mov    0xc(%ebp),%eax
    85a1:	e9 af 00 00 00       	jmp    8655 <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    85a6:	8b 45 08             	mov    0x8(%ebp),%eax
    85a9:	0f b6 00             	movzbl (%eax),%eax
    85ac:	3c 89                	cmp    $0x89,%al
    85ae:	75 63                	jne    8613 <lodepng_chunk_next_const+0x92>
    85b0:	8b 45 08             	mov    0x8(%ebp),%eax
    85b3:	83 c0 01             	add    $0x1,%eax
    85b6:	0f b6 00             	movzbl (%eax),%eax
    85b9:	3c 50                	cmp    $0x50,%al
    85bb:	75 56                	jne    8613 <lodepng_chunk_next_const+0x92>
    85bd:	8b 45 08             	mov    0x8(%ebp),%eax
    85c0:	83 c0 02             	add    $0x2,%eax
    85c3:	0f b6 00             	movzbl (%eax),%eax
    85c6:	3c 4e                	cmp    $0x4e,%al
    85c8:	75 49                	jne    8613 <lodepng_chunk_next_const+0x92>
    85ca:	8b 45 08             	mov    0x8(%ebp),%eax
    85cd:	83 c0 03             	add    $0x3,%eax
    85d0:	0f b6 00             	movzbl (%eax),%eax
    85d3:	3c 47                	cmp    $0x47,%al
    85d5:	75 3c                	jne    8613 <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    85d7:	8b 45 08             	mov    0x8(%ebp),%eax
    85da:	83 c0 04             	add    $0x4,%eax
    85dd:	0f b6 00             	movzbl (%eax),%eax
    85e0:	3c 0d                	cmp    $0xd,%al
    85e2:	75 2f                	jne    8613 <lodepng_chunk_next_const+0x92>
    85e4:	8b 45 08             	mov    0x8(%ebp),%eax
    85e7:	83 c0 05             	add    $0x5,%eax
    85ea:	0f b6 00             	movzbl (%eax),%eax
    85ed:	3c 0a                	cmp    $0xa,%al
    85ef:	75 22                	jne    8613 <lodepng_chunk_next_const+0x92>
    85f1:	8b 45 08             	mov    0x8(%ebp),%eax
    85f4:	83 c0 06             	add    $0x6,%eax
    85f7:	0f b6 00             	movzbl (%eax),%eax
    85fa:	3c 1a                	cmp    $0x1a,%al
    85fc:	75 15                	jne    8613 <lodepng_chunk_next_const+0x92>
    85fe:	8b 45 08             	mov    0x8(%ebp),%eax
    8601:	83 c0 07             	add    $0x7,%eax
    8604:	0f b6 00             	movzbl (%eax),%eax
    8607:	3c 0a                	cmp    $0xa,%al
    8609:	75 08                	jne    8613 <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    860b:	8b 45 08             	mov    0x8(%ebp),%eax
    860e:	83 c0 08             	add    $0x8,%eax
    8611:	eb 42                	jmp    8655 <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    8613:	ff 75 08             	pushl  0x8(%ebp)
    8616:	e8 a8 fc ff ff       	call   82c3 <lodepng_chunk_length>
    861b:	83 c4 04             	add    $0x4,%esp
    861e:	89 c2                	mov    %eax,%edx
    8620:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8623:	50                   	push   %eax
    8624:	6a 0c                	push   $0xc
    8626:	52                   	push   %edx
    8627:	e8 d9 ad ff ff       	call   3405 <lodepng_addofl>
    862c:	83 c4 0c             	add    $0xc,%esp
    862f:	85 c0                	test   %eax,%eax
    8631:	74 05                	je     8638 <lodepng_chunk_next_const+0xb7>
    8633:	8b 45 0c             	mov    0xc(%ebp),%eax
    8636:	eb 1d                	jmp    8655 <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    8638:	8b 45 f8             	mov    -0x8(%ebp),%eax
    863b:	89 c2                	mov    %eax,%edx
    863d:	8b 45 08             	mov    0x8(%ebp),%eax
    8640:	01 d0                	add    %edx,%eax
    8642:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8645:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8648:	3b 45 08             	cmp    0x8(%ebp),%eax
    864b:	73 05                	jae    8652 <lodepng_chunk_next_const+0xd1>
    864d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8650:	eb 03                	jmp    8655 <lodepng_chunk_next_const+0xd4>
    return result;
    8652:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8655:	c9                   	leave  
    8656:	c3                   	ret    

00008657 <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    8657:	55                   	push   %ebp
    8658:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    865a:	8b 45 08             	mov    0x8(%ebp),%eax
    865d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8660:	73 0f                	jae    8671 <lodepng_chunk_find+0x1a>
    8662:	8b 55 0c             	mov    0xc(%ebp),%edx
    8665:	8b 45 08             	mov    0x8(%ebp),%eax
    8668:	29 c2                	sub    %eax,%edx
    866a:	89 d0                	mov    %edx,%eax
    866c:	83 f8 0b             	cmp    $0xb,%eax
    866f:	7f 07                	jg     8678 <lodepng_chunk_find+0x21>
    8671:	b8 00 00 00 00       	mov    $0x0,%eax
    8676:	eb 2a                	jmp    86a2 <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    8678:	ff 75 10             	pushl  0x10(%ebp)
    867b:	ff 75 08             	pushl  0x8(%ebp)
    867e:	e8 8d fc ff ff       	call   8310 <lodepng_chunk_type_equals>
    8683:	83 c4 08             	add    $0x8,%esp
    8686:	84 c0                	test   %al,%al
    8688:	74 05                	je     868f <lodepng_chunk_find+0x38>
    868a:	8b 45 08             	mov    0x8(%ebp),%eax
    868d:	eb 13                	jmp    86a2 <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    868f:	ff 75 0c             	pushl  0xc(%ebp)
    8692:	ff 75 08             	pushl  0x8(%ebp)
    8695:	e8 11 fe ff ff       	call   84ab <lodepng_chunk_next>
    869a:	83 c4 08             	add    $0x8,%esp
    869d:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    86a0:	eb b8                	jmp    865a <lodepng_chunk_find+0x3>
}
    86a2:	c9                   	leave  
    86a3:	c3                   	ret    

000086a4 <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    86a4:	55                   	push   %ebp
    86a5:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    86a7:	8b 45 08             	mov    0x8(%ebp),%eax
    86aa:	3b 45 0c             	cmp    0xc(%ebp),%eax
    86ad:	73 0f                	jae    86be <lodepng_chunk_find_const+0x1a>
    86af:	8b 55 0c             	mov    0xc(%ebp),%edx
    86b2:	8b 45 08             	mov    0x8(%ebp),%eax
    86b5:	29 c2                	sub    %eax,%edx
    86b7:	89 d0                	mov    %edx,%eax
    86b9:	83 f8 0b             	cmp    $0xb,%eax
    86bc:	7f 07                	jg     86c5 <lodepng_chunk_find_const+0x21>
    86be:	b8 00 00 00 00       	mov    $0x0,%eax
    86c3:	eb 2a                	jmp    86ef <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    86c5:	ff 75 10             	pushl  0x10(%ebp)
    86c8:	ff 75 08             	pushl  0x8(%ebp)
    86cb:	e8 40 fc ff ff       	call   8310 <lodepng_chunk_type_equals>
    86d0:	83 c4 08             	add    $0x8,%esp
    86d3:	84 c0                	test   %al,%al
    86d5:	74 05                	je     86dc <lodepng_chunk_find_const+0x38>
    86d7:	8b 45 08             	mov    0x8(%ebp),%eax
    86da:	eb 13                	jmp    86ef <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    86dc:	ff 75 0c             	pushl  0xc(%ebp)
    86df:	ff 75 08             	pushl  0x8(%ebp)
    86e2:	e8 9a fe ff ff       	call   8581 <lodepng_chunk_next_const>
    86e7:	83 c4 08             	add    $0x8,%esp
    86ea:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    86ed:	eb b8                	jmp    86a7 <lodepng_chunk_find_const+0x3>
}
    86ef:	c9                   	leave  
    86f0:	c3                   	ret    

000086f1 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    86f1:	55                   	push   %ebp
    86f2:	89 e5                	mov    %esp,%ebp
    86f4:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    86f7:	ff 75 10             	pushl  0x10(%ebp)
    86fa:	e8 c4 fb ff ff       	call   82c3 <lodepng_chunk_length>
    86ff:	83 c4 04             	add    $0x4,%esp
    8702:	89 c2                	mov    %eax,%edx
    8704:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8707:	50                   	push   %eax
    8708:	6a 0c                	push   $0xc
    870a:	52                   	push   %edx
    870b:	e8 f5 ac ff ff       	call   3405 <lodepng_addofl>
    8710:	83 c4 0c             	add    $0xc,%esp
    8713:	85 c0                	test   %eax,%eax
    8715:	74 0a                	je     8721 <lodepng_chunk_append+0x30>
    8717:	b8 4d 00 00 00       	mov    $0x4d,%eax
    871c:	e9 96 00 00 00       	jmp    87b7 <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    8721:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8724:	8b 45 0c             	mov    0xc(%ebp),%eax
    8727:	8b 00                	mov    (%eax),%eax
    8729:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    872c:	51                   	push   %ecx
    872d:	52                   	push   %edx
    872e:	50                   	push   %eax
    872f:	e8 d1 ac ff ff       	call   3405 <lodepng_addofl>
    8734:	83 c4 0c             	add    $0xc,%esp
    8737:	85 c0                	test   %eax,%eax
    8739:	74 07                	je     8742 <lodepng_chunk_append+0x51>
    873b:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8740:	eb 75                	jmp    87b7 <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    8742:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8745:	8b 45 08             	mov    0x8(%ebp),%eax
    8748:	8b 00                	mov    (%eax),%eax
    874a:	52                   	push   %edx
    874b:	50                   	push   %eax
    874c:	e8 07 ac ff ff       	call   3358 <lodepng_realloc>
    8751:	83 c4 08             	add    $0x8,%esp
    8754:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    8757:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    875b:	75 07                	jne    8764 <lodepng_chunk_append+0x73>
    875d:	b8 53 00 00 00       	mov    $0x53,%eax
    8762:	eb 53                	jmp    87b7 <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    8764:	8b 45 08             	mov    0x8(%ebp),%eax
    8767:	8b 55 f8             	mov    -0x8(%ebp),%edx
    876a:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    876c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    876f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8772:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    8774:	8b 45 08             	mov    0x8(%ebp),%eax
    8777:	8b 00                	mov    (%eax),%eax
    8779:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    877c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    877f:	29 d1                	sub    %edx,%ecx
    8781:	89 ca                	mov    %ecx,%edx
    8783:	01 d0                	add    %edx,%eax
    8785:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    8788:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    878f:	eb 19                	jmp    87aa <lodepng_chunk_append+0xb9>
    8791:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8794:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8797:	01 c2                	add    %eax,%edx
    8799:	8b 4d 10             	mov    0x10(%ebp),%ecx
    879c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    879f:	01 c8                	add    %ecx,%eax
    87a1:	0f b6 00             	movzbl (%eax),%eax
    87a4:	88 02                	mov    %al,(%edx)
    87a6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    87aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
    87ad:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    87b0:	75 df                	jne    8791 <lodepng_chunk_append+0xa0>

  return 0;
    87b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    87b7:	c9                   	leave  
    87b8:	c3                   	ret    

000087b9 <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    87b9:	55                   	push   %ebp
    87ba:	89 e5                	mov    %esp,%ebp
    87bc:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    87bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    87c2:	8b 40 04             	mov    0x4(%eax),%eax
    87c5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    87c8:	8b 55 10             	mov    0x10(%ebp),%edx
    87cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87ce:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    87d1:	51                   	push   %ecx
    87d2:	52                   	push   %edx
    87d3:	50                   	push   %eax
    87d4:	e8 2c ac ff ff       	call   3405 <lodepng_addofl>
    87d9:	83 c4 0c             	add    $0xc,%esp
    87dc:	85 c0                	test   %eax,%eax
    87de:	74 07                	je     87e7 <lodepng_chunk_init+0x2e>
    87e0:	b8 4d 00 00 00       	mov    $0x4d,%eax
    87e5:	eb 78                	jmp    885f <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    87e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87ea:	8d 55 fc             	lea    -0x4(%ebp),%edx
    87ed:	52                   	push   %edx
    87ee:	6a 0c                	push   $0xc
    87f0:	50                   	push   %eax
    87f1:	e8 0f ac ff ff       	call   3405 <lodepng_addofl>
    87f6:	83 c4 0c             	add    $0xc,%esp
    87f9:	85 c0                	test   %eax,%eax
    87fb:	74 07                	je     8804 <lodepng_chunk_init+0x4b>
    87fd:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8802:	eb 5b                	jmp    885f <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    8804:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8807:	50                   	push   %eax
    8808:	ff 75 0c             	pushl  0xc(%ebp)
    880b:	e8 8b ad ff ff       	call   359b <ucvector_resize>
    8810:	83 c4 08             	add    $0x8,%esp
    8813:	85 c0                	test   %eax,%eax
    8815:	75 07                	jne    881e <lodepng_chunk_init+0x65>
    8817:	b8 53 00 00 00       	mov    $0x53,%eax
    881c:	eb 41                	jmp    885f <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    881e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8821:	8b 00                	mov    (%eax),%eax
    8823:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8826:	2b 55 10             	sub    0x10(%ebp),%edx
    8829:	83 ea 0c             	sub    $0xc,%edx
    882c:	01 c2                	add    %eax,%edx
    882e:	8b 45 08             	mov    0x8(%ebp),%eax
    8831:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    8833:	8b 45 08             	mov    0x8(%ebp),%eax
    8836:	8b 00                	mov    (%eax),%eax
    8838:	ff 75 10             	pushl  0x10(%ebp)
    883b:	50                   	push   %eax
    883c:	e8 c1 ae ff ff       	call   3702 <lodepng_set32bitInt>
    8841:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    8844:	8b 45 08             	mov    0x8(%ebp),%eax
    8847:	8b 00                	mov    (%eax),%eax
    8849:	83 c0 04             	add    $0x4,%eax
    884c:	6a 04                	push   $0x4
    884e:	ff 75 14             	pushl  0x14(%ebp)
    8851:	50                   	push   %eax
    8852:	e8 28 ab ff ff       	call   337f <lodepng_memcpy>
    8857:	83 c4 0c             	add    $0xc,%esp

  return 0;
    885a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    885f:	c9                   	leave  
    8860:	c3                   	ret    

00008861 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    8861:	55                   	push   %ebp
    8862:	89 e5                	mov    %esp,%ebp
    8864:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    8867:	ff 75 10             	pushl  0x10(%ebp)
    886a:	ff 75 0c             	pushl  0xc(%ebp)
    886d:	ff 75 08             	pushl  0x8(%ebp)
    8870:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8873:	50                   	push   %eax
    8874:	e8 40 ff ff ff       	call   87b9 <lodepng_chunk_init>
    8879:	83 c4 10             	add    $0x10,%esp
    887c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    887f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    8883:	74 05                	je     888a <lodepng_chunk_createv+0x29>
    8885:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8888:	eb 27                	jmp    88b1 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    888a:	8b 45 0c             	mov    0xc(%ebp),%eax
    888d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8890:	83 c2 08             	add    $0x8,%edx
    8893:	50                   	push   %eax
    8894:	ff 75 14             	pushl  0x14(%ebp)
    8897:	52                   	push   %edx
    8898:	e8 e2 aa ff ff       	call   337f <lodepng_memcpy>
    889d:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    88a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    88a3:	50                   	push   %eax
    88a4:	e8 b9 fb ff ff       	call   8462 <lodepng_chunk_generate_crc>
    88a9:	83 c4 04             	add    $0x4,%esp

  return 0;
    88ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
    88b1:	c9                   	leave  
    88b2:	c3                   	ret    

000088b3 <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    88b3:	55                   	push   %ebp
    88b4:	89 e5                	mov    %esp,%ebp
    88b6:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    88b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    88bc:	8b 08                	mov    (%eax),%ecx
    88be:	8b 45 08             	mov    0x8(%ebp),%eax
    88c1:	8b 10                	mov    (%eax),%edx
    88c3:	8d 45 f0             	lea    -0x10(%ebp),%eax
    88c6:	51                   	push   %ecx
    88c7:	52                   	push   %edx
    88c8:	50                   	push   %eax
    88c9:	e8 34 ad ff ff       	call   3602 <ucvector_init>
    88ce:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    88d1:	ff 75 18             	pushl  0x18(%ebp)
    88d4:	ff 75 14             	pushl  0x14(%ebp)
    88d7:	ff 75 10             	pushl  0x10(%ebp)
    88da:	8d 45 f0             	lea    -0x10(%ebp),%eax
    88dd:	50                   	push   %eax
    88de:	e8 7e ff ff ff       	call   8861 <lodepng_chunk_createv>
    88e3:	83 c4 10             	add    $0x10,%esp
    88e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    88e9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    88ec:	8b 45 08             	mov    0x8(%ebp),%eax
    88ef:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    88f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    88f4:	8b 45 0c             	mov    0xc(%ebp),%eax
    88f7:	89 10                	mov    %edx,(%eax)
  return error;
    88f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    88fc:	c9                   	leave  
    88fd:	c3                   	ret    

000088fe <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    88fe:	55                   	push   %ebp
    88ff:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8901:	8b 45 08             	mov    0x8(%ebp),%eax
    8904:	83 f8 03             	cmp    $0x3,%eax
    8907:	74 6d                	je     8976 <checkColorValidity+0x78>
    8909:	83 f8 03             	cmp    $0x3,%eax
    890c:	77 0e                	ja     891c <checkColorValidity+0x1e>
    890e:	85 c0                	test   %eax,%eax
    8910:	74 28                	je     893a <checkColorValidity+0x3c>
    8912:	83 f8 02             	cmp    $0x2,%eax
    8915:	74 4c                	je     8963 <checkColorValidity+0x65>
    8917:	e9 a6 00 00 00       	jmp    89c2 <checkColorValidity+0xc4>
    891c:	83 f8 06             	cmp    $0x6,%eax
    891f:	0f 84 83 00 00 00    	je     89a8 <checkColorValidity+0xaa>
    8925:	3d ff 00 00 00       	cmp    $0xff,%eax
    892a:	0f 84 8b 00 00 00    	je     89bb <checkColorValidity+0xbd>
    8930:	83 f8 04             	cmp    $0x4,%eax
    8933:	74 60                	je     8995 <checkColorValidity+0x97>
    8935:	e9 88 00 00 00       	jmp    89c2 <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    893a:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    893e:	0f 84 85 00 00 00    	je     89c9 <checkColorValidity+0xcb>
    8944:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8948:	74 7f                	je     89c9 <checkColorValidity+0xcb>
    894a:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    894e:	74 79                	je     89c9 <checkColorValidity+0xcb>
    8950:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8954:	74 73                	je     89c9 <checkColorValidity+0xcb>
    8956:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    895a:	74 6d                	je     89c9 <checkColorValidity+0xcb>
    895c:	b8 25 00 00 00       	mov    $0x25,%eax
    8961:	eb 78                	jmp    89db <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8963:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8967:	74 63                	je     89cc <checkColorValidity+0xce>
    8969:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    896d:	74 5d                	je     89cc <checkColorValidity+0xce>
    896f:	b8 25 00 00 00       	mov    $0x25,%eax
    8974:	eb 65                	jmp    89db <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8976:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    897a:	74 53                	je     89cf <checkColorValidity+0xd1>
    897c:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8980:	74 4d                	je     89cf <checkColorValidity+0xd1>
    8982:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8986:	74 47                	je     89cf <checkColorValidity+0xd1>
    8988:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    898c:	74 41                	je     89cf <checkColorValidity+0xd1>
    898e:	b8 25 00 00 00       	mov    $0x25,%eax
    8993:	eb 46                	jmp    89db <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8995:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8999:	74 37                	je     89d2 <checkColorValidity+0xd4>
    899b:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    899f:	74 31                	je     89d2 <checkColorValidity+0xd4>
    89a1:	b8 25 00 00 00       	mov    $0x25,%eax
    89a6:	eb 33                	jmp    89db <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89a8:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    89ac:	74 27                	je     89d5 <checkColorValidity+0xd7>
    89ae:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    89b2:	74 21                	je     89d5 <checkColorValidity+0xd7>
    89b4:	b8 25 00 00 00       	mov    $0x25,%eax
    89b9:	eb 20                	jmp    89db <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    89bb:	b8 1f 00 00 00       	mov    $0x1f,%eax
    89c0:	eb 19                	jmp    89db <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    89c2:	b8 1f 00 00 00       	mov    $0x1f,%eax
    89c7:	eb 12                	jmp    89db <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    89c9:	90                   	nop
    89ca:	eb 0a                	jmp    89d6 <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89cc:	90                   	nop
    89cd:	eb 07                	jmp    89d6 <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    89cf:	90                   	nop
    89d0:	eb 04                	jmp    89d6 <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89d2:	90                   	nop
    89d3:	eb 01                	jmp    89d6 <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89d5:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    89d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    89db:	5d                   	pop    %ebp
    89dc:	c3                   	ret    

000089dd <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    89dd:	55                   	push   %ebp
    89de:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    89e0:	8b 45 08             	mov    0x8(%ebp),%eax
    89e3:	83 f8 03             	cmp    $0x3,%eax
    89e6:	74 31                	je     8a19 <getNumColorChannels+0x3c>
    89e8:	83 f8 03             	cmp    $0x3,%eax
    89eb:	77 0b                	ja     89f8 <getNumColorChannels+0x1b>
    89ed:	85 c0                	test   %eax,%eax
    89ef:	74 1a                	je     8a0b <getNumColorChannels+0x2e>
    89f1:	83 f8 02             	cmp    $0x2,%eax
    89f4:	74 1c                	je     8a12 <getNumColorChannels+0x35>
    89f6:	eb 3d                	jmp    8a35 <getNumColorChannels+0x58>
    89f8:	83 f8 06             	cmp    $0x6,%eax
    89fb:	74 2a                	je     8a27 <getNumColorChannels+0x4a>
    89fd:	3d ff 00 00 00       	cmp    $0xff,%eax
    8a02:	74 2a                	je     8a2e <getNumColorChannels+0x51>
    8a04:	83 f8 04             	cmp    $0x4,%eax
    8a07:	74 17                	je     8a20 <getNumColorChannels+0x43>
    8a09:	eb 2a                	jmp    8a35 <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    8a0b:	b8 01 00 00 00       	mov    $0x1,%eax
    8a10:	eb 28                	jmp    8a3a <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    8a12:	b8 03 00 00 00       	mov    $0x3,%eax
    8a17:	eb 21                	jmp    8a3a <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    8a19:	b8 01 00 00 00       	mov    $0x1,%eax
    8a1e:	eb 1a                	jmp    8a3a <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    8a20:	b8 02 00 00 00       	mov    $0x2,%eax
    8a25:	eb 13                	jmp    8a3a <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    8a27:	b8 04 00 00 00       	mov    $0x4,%eax
    8a2c:	eb 0c                	jmp    8a3a <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    8a2e:	b8 00 00 00 00       	mov    $0x0,%eax
    8a33:	eb 05                	jmp    8a3a <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    8a35:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    8a3a:	5d                   	pop    %ebp
    8a3b:	c3                   	ret    

00008a3c <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    8a3c:	55                   	push   %ebp
    8a3d:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    8a3f:	ff 75 08             	pushl  0x8(%ebp)
    8a42:	e8 96 ff ff ff       	call   89dd <getNumColorChannels>
    8a47:	83 c4 04             	add    $0x4,%esp
    8a4a:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    8a4e:	c9                   	leave  
    8a4f:	c3                   	ret    

00008a50 <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    8a50:	55                   	push   %ebp
    8a51:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    8a53:	8b 45 08             	mov    0x8(%ebp),%eax
    8a56:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    8a5d:	8b 45 08             	mov    0x8(%ebp),%eax
    8a60:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    8a67:	8b 45 08             	mov    0x8(%ebp),%eax
    8a6a:	8b 50 1c             	mov    0x1c(%eax),%edx
    8a6d:	8b 45 08             	mov    0x8(%ebp),%eax
    8a70:	89 50 18             	mov    %edx,0x18(%eax)
    8a73:	8b 45 08             	mov    0x8(%ebp),%eax
    8a76:	8b 50 18             	mov    0x18(%eax),%edx
    8a79:	8b 45 08             	mov    0x8(%ebp),%eax
    8a7c:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    8a7f:	8b 45 08             	mov    0x8(%ebp),%eax
    8a82:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    8a88:	8b 45 08             	mov    0x8(%ebp),%eax
    8a8b:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    8a92:	8b 45 08             	mov    0x8(%ebp),%eax
    8a95:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8a9c:	8b 45 08             	mov    0x8(%ebp),%eax
    8a9f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8aa6:	90                   	nop
    8aa7:	5d                   	pop    %ebp
    8aa8:	c3                   	ret    

00008aa9 <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    8aa9:	55                   	push   %ebp
    8aaa:	89 e5                	mov    %esp,%ebp
    8aac:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    8aaf:	8b 45 08             	mov    0x8(%ebp),%eax
    8ab2:	8b 40 08             	mov    0x8(%eax),%eax
    8ab5:	85 c0                	test   %eax,%eax
    8ab7:	75 18                	jne    8ad1 <lodepng_color_mode_alloc_palette+0x28>
    8ab9:	83 ec 0c             	sub    $0xc,%esp
    8abc:	68 00 04 00 00       	push   $0x400
    8ac1:	e8 7b a8 ff ff       	call   3341 <lodepng_malloc>
    8ac6:	83 c4 10             	add    $0x10,%esp
    8ac9:	89 c2                	mov    %eax,%edx
    8acb:	8b 45 08             	mov    0x8(%ebp),%eax
    8ace:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    8ad1:	8b 45 08             	mov    0x8(%ebp),%eax
    8ad4:	8b 40 08             	mov    0x8(%eax),%eax
    8ad7:	85 c0                	test   %eax,%eax
    8ad9:	74 65                	je     8b40 <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    8adb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8ae2:	eb 51                	jmp    8b35 <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    8ae4:	8b 45 08             	mov    0x8(%ebp),%eax
    8ae7:	8b 40 08             	mov    0x8(%eax),%eax
    8aea:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8aed:	c1 e2 02             	shl    $0x2,%edx
    8af0:	01 d0                	add    %edx,%eax
    8af2:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    8af5:	8b 45 08             	mov    0x8(%ebp),%eax
    8af8:	8b 40 08             	mov    0x8(%eax),%eax
    8afb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8afe:	c1 e2 02             	shl    $0x2,%edx
    8b01:	83 c2 01             	add    $0x1,%edx
    8b04:	01 d0                	add    %edx,%eax
    8b06:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    8b09:	8b 45 08             	mov    0x8(%ebp),%eax
    8b0c:	8b 40 08             	mov    0x8(%eax),%eax
    8b0f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b12:	c1 e2 02             	shl    $0x2,%edx
    8b15:	83 c2 02             	add    $0x2,%edx
    8b18:	01 d0                	add    %edx,%eax
    8b1a:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    8b1d:	8b 45 08             	mov    0x8(%ebp),%eax
    8b20:	8b 40 08             	mov    0x8(%eax),%eax
    8b23:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b26:	c1 e2 02             	shl    $0x2,%edx
    8b29:	83 c2 03             	add    $0x3,%edx
    8b2c:	01 d0                	add    %edx,%eax
    8b2e:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    8b31:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8b35:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    8b3c:	75 a6                	jne    8ae4 <lodepng_color_mode_alloc_palette+0x3b>
    8b3e:	eb 01                	jmp    8b41 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    8b40:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    8b41:	c9                   	leave  
    8b42:	c3                   	ret    

00008b43 <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    8b43:	55                   	push   %ebp
    8b44:	89 e5                	mov    %esp,%ebp
    8b46:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    8b49:	83 ec 0c             	sub    $0xc,%esp
    8b4c:	ff 75 08             	pushl  0x8(%ebp)
    8b4f:	e8 f3 01 00 00       	call   8d47 <lodepng_palette_clear>
    8b54:	83 c4 10             	add    $0x10,%esp
}
    8b57:	90                   	nop
    8b58:	c9                   	leave  
    8b59:	c3                   	ret    

00008b5a <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    8b5a:	55                   	push   %ebp
    8b5b:	89 e5                	mov    %esp,%ebp
    8b5d:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    8b60:	83 ec 0c             	sub    $0xc,%esp
    8b63:	ff 75 08             	pushl  0x8(%ebp)
    8b66:	e8 d8 ff ff ff       	call   8b43 <lodepng_color_mode_cleanup>
    8b6b:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    8b6e:	83 ec 04             	sub    $0x4,%esp
    8b71:	6a 20                	push   $0x20
    8b73:	ff 75 0c             	pushl  0xc(%ebp)
    8b76:	ff 75 08             	pushl  0x8(%ebp)
    8b79:	e8 01 a8 ff ff       	call   337f <lodepng_memcpy>
    8b7e:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    8b81:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b84:	8b 40 08             	mov    0x8(%eax),%eax
    8b87:	85 c0                	test   %eax,%eax
    8b89:	74 5a                	je     8be5 <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    8b8b:	83 ec 0c             	sub    $0xc,%esp
    8b8e:	68 00 04 00 00       	push   $0x400
    8b93:	e8 a9 a7 ff ff       	call   3341 <lodepng_malloc>
    8b98:	83 c4 10             	add    $0x10,%esp
    8b9b:	89 c2                	mov    %eax,%edx
    8b9d:	8b 45 08             	mov    0x8(%ebp),%eax
    8ba0:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    8ba3:	8b 45 08             	mov    0x8(%ebp),%eax
    8ba6:	8b 40 08             	mov    0x8(%eax),%eax
    8ba9:	85 c0                	test   %eax,%eax
    8bab:	75 11                	jne    8bbe <lodepng_color_mode_copy+0x64>
    8bad:	8b 45 0c             	mov    0xc(%ebp),%eax
    8bb0:	8b 40 0c             	mov    0xc(%eax),%eax
    8bb3:	85 c0                	test   %eax,%eax
    8bb5:	74 07                	je     8bbe <lodepng_color_mode_copy+0x64>
    8bb7:	b8 53 00 00 00       	mov    $0x53,%eax
    8bbc:	eb 2c                	jmp    8bea <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    8bbe:	8b 45 0c             	mov    0xc(%ebp),%eax
    8bc1:	8b 40 0c             	mov    0xc(%eax),%eax
    8bc4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    8bcb:	8b 45 0c             	mov    0xc(%ebp),%eax
    8bce:	8b 50 08             	mov    0x8(%eax),%edx
    8bd1:	8b 45 08             	mov    0x8(%ebp),%eax
    8bd4:	8b 40 08             	mov    0x8(%eax),%eax
    8bd7:	83 ec 04             	sub    $0x4,%esp
    8bda:	51                   	push   %ecx
    8bdb:	52                   	push   %edx
    8bdc:	50                   	push   %eax
    8bdd:	e8 9d a7 ff ff       	call   337f <lodepng_memcpy>
    8be2:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    8be5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8bea:	c9                   	leave  
    8beb:	c3                   	ret    

00008bec <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    8bec:	55                   	push   %ebp
    8bed:	89 e5                	mov    %esp,%ebp
    8bef:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    8bf2:	8d 45 e0             	lea    -0x20(%ebp),%eax
    8bf5:	50                   	push   %eax
    8bf6:	e8 55 fe ff ff       	call   8a50 <lodepng_color_mode_init>
    8bfb:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    8bfe:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c01:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    8c04:	8b 45 10             	mov    0x10(%ebp),%eax
    8c07:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    8c0a:	8b 45 08             	mov    0x8(%ebp),%eax
    8c0d:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8c10:	89 10                	mov    %edx,(%eax)
    8c12:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8c15:	89 50 04             	mov    %edx,0x4(%eax)
    8c18:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8c1b:	89 50 08             	mov    %edx,0x8(%eax)
    8c1e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8c21:	89 50 0c             	mov    %edx,0xc(%eax)
    8c24:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8c27:	89 50 10             	mov    %edx,0x10(%eax)
    8c2a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8c2d:	89 50 14             	mov    %edx,0x14(%eax)
    8c30:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8c33:	89 50 18             	mov    %edx,0x18(%eax)
    8c36:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8c39:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    8c3c:	8b 45 08             	mov    0x8(%ebp),%eax
    8c3f:	c9                   	leave  
    8c40:	c2 04 00             	ret    $0x4

00008c43 <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    8c43:	55                   	push   %ebp
    8c44:	89 e5                	mov    %esp,%ebp
    8c46:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    8c49:	8b 45 08             	mov    0x8(%ebp),%eax
    8c4c:	8b 10                	mov    (%eax),%edx
    8c4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c51:	8b 00                	mov    (%eax),%eax
    8c53:	39 c2                	cmp    %eax,%edx
    8c55:	74 0a                	je     8c61 <lodepng_color_mode_equal+0x1e>
    8c57:	b8 00 00 00 00       	mov    $0x0,%eax
    8c5c:	e9 e4 00 00 00       	jmp    8d45 <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    8c61:	8b 45 08             	mov    0x8(%ebp),%eax
    8c64:	8b 50 04             	mov    0x4(%eax),%edx
    8c67:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c6a:	8b 40 04             	mov    0x4(%eax),%eax
    8c6d:	39 c2                	cmp    %eax,%edx
    8c6f:	74 0a                	je     8c7b <lodepng_color_mode_equal+0x38>
    8c71:	b8 00 00 00 00       	mov    $0x0,%eax
    8c76:	e9 ca 00 00 00       	jmp    8d45 <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    8c7b:	8b 45 08             	mov    0x8(%ebp),%eax
    8c7e:	8b 50 10             	mov    0x10(%eax),%edx
    8c81:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c84:	8b 40 10             	mov    0x10(%eax),%eax
    8c87:	39 c2                	cmp    %eax,%edx
    8c89:	74 0a                	je     8c95 <lodepng_color_mode_equal+0x52>
    8c8b:	b8 00 00 00 00       	mov    $0x0,%eax
    8c90:	e9 b0 00 00 00       	jmp    8d45 <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    8c95:	8b 45 08             	mov    0x8(%ebp),%eax
    8c98:	8b 40 10             	mov    0x10(%eax),%eax
    8c9b:	85 c0                	test   %eax,%eax
    8c9d:	74 48                	je     8ce7 <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    8c9f:	8b 45 08             	mov    0x8(%ebp),%eax
    8ca2:	8b 50 14             	mov    0x14(%eax),%edx
    8ca5:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ca8:	8b 40 14             	mov    0x14(%eax),%eax
    8cab:	39 c2                	cmp    %eax,%edx
    8cad:	74 0a                	je     8cb9 <lodepng_color_mode_equal+0x76>
    8caf:	b8 00 00 00 00       	mov    $0x0,%eax
    8cb4:	e9 8c 00 00 00       	jmp    8d45 <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    8cb9:	8b 45 08             	mov    0x8(%ebp),%eax
    8cbc:	8b 50 18             	mov    0x18(%eax),%edx
    8cbf:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cc2:	8b 40 18             	mov    0x18(%eax),%eax
    8cc5:	39 c2                	cmp    %eax,%edx
    8cc7:	74 07                	je     8cd0 <lodepng_color_mode_equal+0x8d>
    8cc9:	b8 00 00 00 00       	mov    $0x0,%eax
    8cce:	eb 75                	jmp    8d45 <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    8cd0:	8b 45 08             	mov    0x8(%ebp),%eax
    8cd3:	8b 50 1c             	mov    0x1c(%eax),%edx
    8cd6:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cd9:	8b 40 1c             	mov    0x1c(%eax),%eax
    8cdc:	39 c2                	cmp    %eax,%edx
    8cde:	74 07                	je     8ce7 <lodepng_color_mode_equal+0xa4>
    8ce0:	b8 00 00 00 00       	mov    $0x0,%eax
    8ce5:	eb 5e                	jmp    8d45 <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    8ce7:	8b 45 08             	mov    0x8(%ebp),%eax
    8cea:	8b 50 0c             	mov    0xc(%eax),%edx
    8ced:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cf0:	8b 40 0c             	mov    0xc(%eax),%eax
    8cf3:	39 c2                	cmp    %eax,%edx
    8cf5:	74 07                	je     8cfe <lodepng_color_mode_equal+0xbb>
    8cf7:	b8 00 00 00 00       	mov    $0x0,%eax
    8cfc:	eb 47                	jmp    8d45 <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    8cfe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8d05:	eb 2b                	jmp    8d32 <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    8d07:	8b 45 08             	mov    0x8(%ebp),%eax
    8d0a:	8b 50 08             	mov    0x8(%eax),%edx
    8d0d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d10:	01 d0                	add    %edx,%eax
    8d12:	0f b6 10             	movzbl (%eax),%edx
    8d15:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d18:	8b 48 08             	mov    0x8(%eax),%ecx
    8d1b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d1e:	01 c8                	add    %ecx,%eax
    8d20:	0f b6 00             	movzbl (%eax),%eax
    8d23:	38 c2                	cmp    %al,%dl
    8d25:	74 07                	je     8d2e <lodepng_color_mode_equal+0xeb>
    8d27:	b8 00 00 00 00       	mov    $0x0,%eax
    8d2c:	eb 17                	jmp    8d45 <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    8d2e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8d32:	8b 45 08             	mov    0x8(%ebp),%eax
    8d35:	8b 40 0c             	mov    0xc(%eax),%eax
    8d38:	c1 e0 02             	shl    $0x2,%eax
    8d3b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8d3e:	75 c7                	jne    8d07 <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    8d40:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8d45:	c9                   	leave  
    8d46:	c3                   	ret    

00008d47 <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    8d47:	55                   	push   %ebp
    8d48:	89 e5                	mov    %esp,%ebp
    8d4a:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    8d4d:	8b 45 08             	mov    0x8(%ebp),%eax
    8d50:	8b 40 08             	mov    0x8(%eax),%eax
    8d53:	85 c0                	test   %eax,%eax
    8d55:	74 12                	je     8d69 <lodepng_palette_clear+0x22>
    8d57:	8b 45 08             	mov    0x8(%ebp),%eax
    8d5a:	8b 40 08             	mov    0x8(%eax),%eax
    8d5d:	83 ec 0c             	sub    $0xc,%esp
    8d60:	50                   	push   %eax
    8d61:	e8 fc a5 ff ff       	call   3362 <lodepng_free>
    8d66:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    8d69:	8b 45 08             	mov    0x8(%ebp),%eax
    8d6c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8d73:	8b 45 08             	mov    0x8(%ebp),%eax
    8d76:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8d7d:	90                   	nop
    8d7e:	c9                   	leave  
    8d7f:	c3                   	ret    

00008d80 <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    8d80:	55                   	push   %ebp
    8d81:	89 e5                	mov    %esp,%ebp
    8d83:	53                   	push   %ebx
    8d84:	83 ec 14             	sub    $0x14,%esp
    8d87:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    8d8a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8d8d:	8b 55 14             	mov    0x14(%ebp),%edx
    8d90:	8b 45 18             	mov    0x18(%ebp),%eax
    8d93:	88 5d f4             	mov    %bl,-0xc(%ebp)
    8d96:	88 4d f0             	mov    %cl,-0x10(%ebp)
    8d99:	88 55 ec             	mov    %dl,-0x14(%ebp)
    8d9c:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    8d9f:	8b 45 08             	mov    0x8(%ebp),%eax
    8da2:	8b 40 08             	mov    0x8(%eax),%eax
    8da5:	85 c0                	test   %eax,%eax
    8da7:	75 22                	jne    8dcb <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    8da9:	83 ec 0c             	sub    $0xc,%esp
    8dac:	ff 75 08             	pushl  0x8(%ebp)
    8daf:	e8 f5 fc ff ff       	call   8aa9 <lodepng_color_mode_alloc_palette>
    8db4:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    8db7:	8b 45 08             	mov    0x8(%ebp),%eax
    8dba:	8b 40 08             	mov    0x8(%eax),%eax
    8dbd:	85 c0                	test   %eax,%eax
    8dbf:	75 0a                	jne    8dcb <lodepng_palette_add+0x4b>
    8dc1:	b8 53 00 00 00       	mov    $0x53,%eax
    8dc6:	e9 8d 00 00 00       	jmp    8e58 <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    8dcb:	8b 45 08             	mov    0x8(%ebp),%eax
    8dce:	8b 40 0c             	mov    0xc(%eax),%eax
    8dd1:	3d ff 00 00 00       	cmp    $0xff,%eax
    8dd6:	7e 07                	jle    8ddf <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    8dd8:	b8 6c 00 00 00       	mov    $0x6c,%eax
    8ddd:	eb 79                	jmp    8e58 <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    8ddf:	8b 45 08             	mov    0x8(%ebp),%eax
    8de2:	8b 50 08             	mov    0x8(%eax),%edx
    8de5:	8b 45 08             	mov    0x8(%ebp),%eax
    8de8:	8b 40 0c             	mov    0xc(%eax),%eax
    8deb:	c1 e0 02             	shl    $0x2,%eax
    8dee:	01 c2                	add    %eax,%edx
    8df0:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    8df4:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    8df6:	8b 45 08             	mov    0x8(%ebp),%eax
    8df9:	8b 50 08             	mov    0x8(%eax),%edx
    8dfc:	8b 45 08             	mov    0x8(%ebp),%eax
    8dff:	8b 40 0c             	mov    0xc(%eax),%eax
    8e02:	c1 e0 02             	shl    $0x2,%eax
    8e05:	83 c0 01             	add    $0x1,%eax
    8e08:	01 c2                	add    %eax,%edx
    8e0a:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    8e0e:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    8e10:	8b 45 08             	mov    0x8(%ebp),%eax
    8e13:	8b 50 08             	mov    0x8(%eax),%edx
    8e16:	8b 45 08             	mov    0x8(%ebp),%eax
    8e19:	8b 40 0c             	mov    0xc(%eax),%eax
    8e1c:	c1 e0 02             	shl    $0x2,%eax
    8e1f:	83 c0 02             	add    $0x2,%eax
    8e22:	01 c2                	add    %eax,%edx
    8e24:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    8e28:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    8e2a:	8b 45 08             	mov    0x8(%ebp),%eax
    8e2d:	8b 50 08             	mov    0x8(%eax),%edx
    8e30:	8b 45 08             	mov    0x8(%ebp),%eax
    8e33:	8b 40 0c             	mov    0xc(%eax),%eax
    8e36:	c1 e0 02             	shl    $0x2,%eax
    8e39:	83 c0 03             	add    $0x3,%eax
    8e3c:	01 c2                	add    %eax,%edx
    8e3e:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    8e42:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    8e44:	8b 45 08             	mov    0x8(%ebp),%eax
    8e47:	8b 40 0c             	mov    0xc(%eax),%eax
    8e4a:	8d 50 01             	lea    0x1(%eax),%edx
    8e4d:	8b 45 08             	mov    0x8(%ebp),%eax
    8e50:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    8e53:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8e58:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8e5b:	c9                   	leave  
    8e5c:	c3                   	ret    

00008e5d <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    8e5d:	55                   	push   %ebp
    8e5e:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    8e60:	8b 45 08             	mov    0x8(%ebp),%eax
    8e63:	8b 50 04             	mov    0x4(%eax),%edx
    8e66:	8b 45 08             	mov    0x8(%ebp),%eax
    8e69:	8b 00                	mov    (%eax),%eax
    8e6b:	52                   	push   %edx
    8e6c:	50                   	push   %eax
    8e6d:	e8 ca fb ff ff       	call   8a3c <lodepng_get_bpp_lct>
    8e72:	83 c4 08             	add    $0x8,%esp
}
    8e75:	c9                   	leave  
    8e76:	c3                   	ret    

00008e77 <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    8e77:	55                   	push   %ebp
    8e78:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    8e7a:	8b 45 08             	mov    0x8(%ebp),%eax
    8e7d:	8b 00                	mov    (%eax),%eax
    8e7f:	50                   	push   %eax
    8e80:	e8 58 fb ff ff       	call   89dd <getNumColorChannels>
    8e85:	83 c4 04             	add    $0x4,%esp
}
    8e88:	c9                   	leave  
    8e89:	c3                   	ret    

00008e8a <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    8e8a:	55                   	push   %ebp
    8e8b:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    8e8d:	8b 45 08             	mov    0x8(%ebp),%eax
    8e90:	8b 00                	mov    (%eax),%eax
    8e92:	85 c0                	test   %eax,%eax
    8e94:	74 0a                	je     8ea0 <lodepng_is_greyscale_type+0x16>
    8e96:	8b 45 08             	mov    0x8(%ebp),%eax
    8e99:	8b 00                	mov    (%eax),%eax
    8e9b:	83 f8 04             	cmp    $0x4,%eax
    8e9e:	75 07                	jne    8ea7 <lodepng_is_greyscale_type+0x1d>
    8ea0:	b8 01 00 00 00       	mov    $0x1,%eax
    8ea5:	eb 05                	jmp    8eac <lodepng_is_greyscale_type+0x22>
    8ea7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8eac:	5d                   	pop    %ebp
    8ead:	c3                   	ret    

00008eae <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    8eae:	55                   	push   %ebp
    8eaf:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    8eb1:	8b 45 08             	mov    0x8(%ebp),%eax
    8eb4:	8b 00                	mov    (%eax),%eax
    8eb6:	83 e0 04             	and    $0x4,%eax
    8eb9:	85 c0                	test   %eax,%eax
    8ebb:	0f 95 c0             	setne  %al
    8ebe:	0f b6 c0             	movzbl %al,%eax
}
    8ec1:	5d                   	pop    %ebp
    8ec2:	c3                   	ret    

00008ec3 <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    8ec3:	55                   	push   %ebp
    8ec4:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    8ec6:	8b 45 08             	mov    0x8(%ebp),%eax
    8ec9:	8b 00                	mov    (%eax),%eax
    8ecb:	83 f8 03             	cmp    $0x3,%eax
    8ece:	0f 94 c0             	sete   %al
    8ed1:	0f b6 c0             	movzbl %al,%eax
}
    8ed4:	5d                   	pop    %ebp
    8ed5:	c3                   	ret    

00008ed6 <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    8ed6:	55                   	push   %ebp
    8ed7:	89 e5                	mov    %esp,%ebp
    8ed9:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8edc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8ee3:	eb 23                	jmp    8f08 <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    8ee5:	8b 45 08             	mov    0x8(%ebp),%eax
    8ee8:	8b 40 08             	mov    0x8(%eax),%eax
    8eeb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8eee:	c1 e2 02             	shl    $0x2,%edx
    8ef1:	83 c2 03             	add    $0x3,%edx
    8ef4:	01 d0                	add    %edx,%eax
    8ef6:	0f b6 00             	movzbl (%eax),%eax
    8ef9:	3c ff                	cmp    $0xff,%al
    8efb:	74 07                	je     8f04 <lodepng_has_palette_alpha+0x2e>
    8efd:	b8 01 00 00 00       	mov    $0x1,%eax
    8f02:	eb 14                	jmp    8f18 <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8f04:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8f08:	8b 45 08             	mov    0x8(%ebp),%eax
    8f0b:	8b 40 0c             	mov    0xc(%eax),%eax
    8f0e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8f11:	75 d2                	jne    8ee5 <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    8f13:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f18:	c9                   	leave  
    8f19:	c3                   	ret    

00008f1a <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    8f1a:	55                   	push   %ebp
    8f1b:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    8f1d:	8b 45 08             	mov    0x8(%ebp),%eax
    8f20:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    8f23:	85 c0                	test   %eax,%eax
    8f25:	75 1e                	jne    8f45 <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    8f27:	ff 75 08             	pushl  0x8(%ebp)
    8f2a:	e8 7f ff ff ff       	call   8eae <lodepng_is_alpha_type>
    8f2f:	83 c4 04             	add    $0x4,%esp
    8f32:	85 c0                	test   %eax,%eax
    8f34:	75 0f                	jne    8f45 <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    8f36:	ff 75 08             	pushl  0x8(%ebp)
    8f39:	e8 98 ff ff ff       	call   8ed6 <lodepng_has_palette_alpha>
    8f3e:	83 c4 04             	add    $0x4,%esp
    8f41:	85 c0                	test   %eax,%eax
    8f43:	74 07                	je     8f4c <lodepng_can_have_alpha+0x32>
    8f45:	b8 01 00 00 00       	mov    $0x1,%eax
    8f4a:	eb 05                	jmp    8f51 <lodepng_can_have_alpha+0x37>
    8f4c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f51:	c9                   	leave  
    8f52:	c3                   	ret    

00008f53 <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    8f53:	55                   	push   %ebp
    8f54:	89 e5                	mov    %esp,%ebp
    8f56:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    8f59:	ff 75 14             	pushl  0x14(%ebp)
    8f5c:	ff 75 10             	pushl  0x10(%ebp)
    8f5f:	e8 d8 fa ff ff       	call   8a3c <lodepng_get_bpp_lct>
    8f64:	83 c4 08             	add    $0x8,%esp
    8f67:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    8f6a:	8b 55 08             	mov    0x8(%ebp),%edx
    8f6d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f70:	0f af c2             	imul   %edx,%eax
    8f73:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    8f76:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8f79:	c1 e8 03             	shr    $0x3,%eax
    8f7c:	89 c2                	mov    %eax,%edx
    8f7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8f81:	0f af c2             	imul   %edx,%eax
    8f84:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8f87:	89 d1                	mov    %edx,%ecx
    8f89:	83 e1 07             	and    $0x7,%ecx
    8f8c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8f8f:	0f af d1             	imul   %ecx,%edx
    8f92:	83 c2 07             	add    $0x7,%edx
    8f95:	c1 ea 03             	shr    $0x3,%edx
    8f98:	01 d0                	add    %edx,%eax
}
    8f9a:	c9                   	leave  
    8f9b:	c3                   	ret    

00008f9c <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    8f9c:	55                   	push   %ebp
    8f9d:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    8f9f:	8b 45 10             	mov    0x10(%ebp),%eax
    8fa2:	8b 50 04             	mov    0x4(%eax),%edx
    8fa5:	8b 45 10             	mov    0x10(%ebp),%eax
    8fa8:	8b 00                	mov    (%eax),%eax
    8faa:	52                   	push   %edx
    8fab:	50                   	push   %eax
    8fac:	ff 75 0c             	pushl  0xc(%ebp)
    8faf:	ff 75 08             	pushl  0x8(%ebp)
    8fb2:	e8 9c ff ff ff       	call   8f53 <lodepng_get_raw_size_lct>
    8fb7:	83 c4 10             	add    $0x10,%esp
}
    8fba:	c9                   	leave  
    8fbb:	c3                   	ret    

00008fbc <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    8fbc:	55                   	push   %ebp
    8fbd:	89 e5                	mov    %esp,%ebp
    8fbf:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    8fc2:	8b 45 08             	mov    0x8(%ebp),%eax
    8fc5:	c1 e8 03             	shr    $0x3,%eax
    8fc8:	0f af 45 10          	imul   0x10(%ebp),%eax
    8fcc:	8b 55 08             	mov    0x8(%ebp),%edx
    8fcf:	83 e2 07             	and    $0x7,%edx
    8fd2:	0f af 55 10          	imul   0x10(%ebp),%edx
    8fd6:	83 c2 07             	add    $0x7,%edx
    8fd9:	c1 ea 03             	shr    $0x3,%edx
    8fdc:	01 d0                	add    %edx,%eax
    8fde:	83 c0 01             	add    $0x1,%eax
    8fe1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    8fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fe7:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    8feb:	c9                   	leave  
    8fec:	c3                   	ret    

00008fed <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    8fed:	55                   	push   %ebp
    8fee:	89 e5                	mov    %esp,%ebp
    8ff0:	53                   	push   %ebx
    8ff1:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    8ff4:	ff 75 10             	pushl  0x10(%ebp)
    8ff7:	e8 61 fe ff ff       	call   8e5d <lodepng_get_bpp>
    8ffc:	83 c4 04             	add    $0x4,%esp
    8fff:	89 c3                	mov    %eax,%ebx
    9001:	ff 75 14             	pushl  0x14(%ebp)
    9004:	e8 54 fe ff ff       	call   8e5d <lodepng_get_bpp>
    9009:	83 c4 04             	add    $0x4,%esp
    900c:	39 c3                	cmp    %eax,%ebx
    900e:	76 0d                	jbe    901d <lodepng_pixel_overflow+0x30>
    9010:	ff 75 10             	pushl  0x10(%ebp)
    9013:	e8 45 fe ff ff       	call   8e5d <lodepng_get_bpp>
    9018:	83 c4 04             	add    $0x4,%esp
    901b:	eb 0b                	jmp    9028 <lodepng_pixel_overflow+0x3b>
    901d:	ff 75 14             	pushl  0x14(%ebp)
    9020:	e8 38 fe ff ff       	call   8e5d <lodepng_get_bpp>
    9025:	83 c4 04             	add    $0x4,%esp
    9028:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    902b:	8b 55 0c             	mov    0xc(%ebp),%edx
    902e:	8b 45 08             	mov    0x8(%ebp),%eax
    9031:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    9034:	51                   	push   %ecx
    9035:	52                   	push   %edx
    9036:	50                   	push   %eax
    9037:	e8 e9 a3 ff ff       	call   3425 <lodepng_mulofl>
    903c:	83 c4 0c             	add    $0xc,%esp
    903f:	85 c0                	test   %eax,%eax
    9041:	74 0a                	je     904d <lodepng_pixel_overflow+0x60>
    9043:	b8 01 00 00 00       	mov    $0x1,%eax
    9048:	e9 b6 00 00 00       	jmp    9103 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    904d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9050:	8d 55 f0             	lea    -0x10(%ebp),%edx
    9053:	52                   	push   %edx
    9054:	6a 08                	push   $0x8
    9056:	50                   	push   %eax
    9057:	e8 c9 a3 ff ff       	call   3425 <lodepng_mulofl>
    905c:	83 c4 0c             	add    $0xc,%esp
    905f:	85 c0                	test   %eax,%eax
    9061:	74 0a                	je     906d <lodepng_pixel_overflow+0x80>
    9063:	b8 01 00 00 00       	mov    $0x1,%eax
    9068:	e9 96 00 00 00       	jmp    9103 <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    906d:	8b 45 08             	mov    0x8(%ebp),%eax
    9070:	c1 e8 03             	shr    $0x3,%eax
    9073:	89 c2                	mov    %eax,%edx
    9075:	8d 45 ec             	lea    -0x14(%ebp),%eax
    9078:	50                   	push   %eax
    9079:	ff 75 f8             	pushl  -0x8(%ebp)
    907c:	52                   	push   %edx
    907d:	e8 a3 a3 ff ff       	call   3425 <lodepng_mulofl>
    9082:	83 c4 0c             	add    $0xc,%esp
    9085:	85 c0                	test   %eax,%eax
    9087:	74 07                	je     9090 <lodepng_pixel_overflow+0xa3>
    9089:	b8 01 00 00 00       	mov    $0x1,%eax
    908e:	eb 73                	jmp    9103 <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    9090:	8b 45 08             	mov    0x8(%ebp),%eax
    9093:	83 e0 07             	and    $0x7,%eax
    9096:	89 c2                	mov    %eax,%edx
    9098:	8b 45 f8             	mov    -0x8(%ebp),%eax
    909b:	0f af c2             	imul   %edx,%eax
    909e:	83 c0 07             	add    $0x7,%eax
    90a1:	c1 e8 03             	shr    $0x3,%eax
    90a4:	89 c1                	mov    %eax,%ecx
    90a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    90a9:	8d 55 ec             	lea    -0x14(%ebp),%edx
    90ac:	52                   	push   %edx
    90ad:	51                   	push   %ecx
    90ae:	50                   	push   %eax
    90af:	e8 51 a3 ff ff       	call   3405 <lodepng_addofl>
    90b4:	83 c4 0c             	add    $0xc,%esp
    90b7:	85 c0                	test   %eax,%eax
    90b9:	74 07                	je     90c2 <lodepng_pixel_overflow+0xd5>
    90bb:	b8 01 00 00 00       	mov    $0x1,%eax
    90c0:	eb 41                	jmp    9103 <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    90c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    90c5:	8d 55 ec             	lea    -0x14(%ebp),%edx
    90c8:	52                   	push   %edx
    90c9:	6a 05                	push   $0x5
    90cb:	50                   	push   %eax
    90cc:	e8 34 a3 ff ff       	call   3405 <lodepng_addofl>
    90d1:	83 c4 0c             	add    $0xc,%esp
    90d4:	85 c0                	test   %eax,%eax
    90d6:	74 07                	je     90df <lodepng_pixel_overflow+0xf2>
    90d8:	b8 01 00 00 00       	mov    $0x1,%eax
    90dd:	eb 24                	jmp    9103 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    90df:	8b 55 0c             	mov    0xc(%ebp),%edx
    90e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    90e5:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    90e8:	51                   	push   %ecx
    90e9:	52                   	push   %edx
    90ea:	50                   	push   %eax
    90eb:	e8 35 a3 ff ff       	call   3425 <lodepng_mulofl>
    90f0:	83 c4 0c             	add    $0xc,%esp
    90f3:	85 c0                	test   %eax,%eax
    90f5:	74 07                	je     90fe <lodepng_pixel_overflow+0x111>
    90f7:	b8 01 00 00 00       	mov    $0x1,%eax
    90fc:	eb 05                	jmp    9103 <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    90fe:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9103:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9106:	c9                   	leave  
    9107:	c3                   	ret    

00009108 <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    9108:	55                   	push   %ebp
    9109:	89 e5                	mov    %esp,%ebp
    910b:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    910e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9115:	eb 15                	jmp    912c <LodePNGUnknownChunks_init+0x24>
    9117:	8b 45 08             	mov    0x8(%ebp),%eax
    911a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    911d:	83 c2 30             	add    $0x30,%edx
    9120:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    9127:	00 
    9128:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    912c:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9130:	75 e5                	jne    9117 <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    9132:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9139:	eb 15                	jmp    9150 <LodePNGUnknownChunks_init+0x48>
    913b:	8b 45 08             	mov    0x8(%ebp),%eax
    913e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9141:	83 c2 34             	add    $0x34,%edx
    9144:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    914b:	00 
    914c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9150:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9154:	75 e5                	jne    913b <LodePNGUnknownChunks_init+0x33>
}
    9156:	90                   	nop
    9157:	c9                   	leave  
    9158:	c3                   	ret    

00009159 <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    9159:	55                   	push   %ebp
    915a:	89 e5                	mov    %esp,%ebp
    915c:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    915f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9166:	eb 1d                	jmp    9185 <LodePNGUnknownChunks_cleanup+0x2c>
    9168:	8b 45 08             	mov    0x8(%ebp),%eax
    916b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    916e:	83 c2 30             	add    $0x30,%edx
    9171:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    9175:	83 ec 0c             	sub    $0xc,%esp
    9178:	50                   	push   %eax
    9179:	e8 e4 a1 ff ff       	call   3362 <lodepng_free>
    917e:	83 c4 10             	add    $0x10,%esp
    9181:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9185:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    9189:	75 dd                	jne    9168 <LodePNGUnknownChunks_cleanup+0xf>
}
    918b:	90                   	nop
    918c:	c9                   	leave  
    918d:	c3                   	ret    

0000918e <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    918e:	55                   	push   %ebp
    918f:	89 e5                	mov    %esp,%ebp
    9191:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    9194:	83 ec 0c             	sub    $0xc,%esp
    9197:	ff 75 08             	pushl  0x8(%ebp)
    919a:	e8 ba ff ff ff       	call   9159 <LodePNGUnknownChunks_cleanup>
    919f:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    91a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    91a9:	e9 b7 00 00 00       	jmp    9265 <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    91ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    91b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91b4:	83 c2 34             	add    $0x34,%edx
    91b7:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    91bb:	8b 45 08             	mov    0x8(%ebp),%eax
    91be:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    91c1:	83 c1 34             	add    $0x34,%ecx
    91c4:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    91c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    91cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91ce:	83 c2 34             	add    $0x34,%edx
    91d1:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    91d5:	83 ec 0c             	sub    $0xc,%esp
    91d8:	50                   	push   %eax
    91d9:	e8 63 a1 ff ff       	call   3341 <lodepng_malloc>
    91de:	83 c4 10             	add    $0x10,%esp
    91e1:	89 c1                	mov    %eax,%ecx
    91e3:	8b 45 08             	mov    0x8(%ebp),%eax
    91e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91e9:	83 c2 30             	add    $0x30,%edx
    91ec:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    91f0:	8b 45 08             	mov    0x8(%ebp),%eax
    91f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91f6:	83 c2 30             	add    $0x30,%edx
    91f9:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    91fd:	85 c0                	test   %eax,%eax
    91ff:	75 18                	jne    9219 <LodePNGUnknownChunks_copy+0x8b>
    9201:	8b 45 08             	mov    0x8(%ebp),%eax
    9204:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9207:	83 c2 34             	add    $0x34,%edx
    920a:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    920e:	85 c0                	test   %eax,%eax
    9210:	74 07                	je     9219 <LodePNGUnknownChunks_copy+0x8b>
    9212:	b8 53 00 00 00       	mov    $0x53,%eax
    9217:	eb 5b                	jmp    9274 <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    9219:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    9220:	eb 2d                	jmp    924f <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    9222:	8b 45 08             	mov    0x8(%ebp),%eax
    9225:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9228:	83 c2 30             	add    $0x30,%edx
    922b:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    922f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9232:	01 c2                	add    %eax,%edx
    9234:	8b 45 0c             	mov    0xc(%ebp),%eax
    9237:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    923a:	83 c1 30             	add    $0x30,%ecx
    923d:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    9241:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9244:	01 c8                	add    %ecx,%eax
    9246:	0f b6 00             	movzbl (%eax),%eax
    9249:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    924b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    924f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9252:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9255:	83 c2 34             	add    $0x34,%edx
    9258:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    925c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    925f:	7f c1                	jg     9222 <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    9261:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9265:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    9269:	0f 85 3f ff ff ff    	jne    91ae <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    926f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9274:	c9                   	leave  
    9275:	c3                   	ret    

00009276 <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    9276:	55                   	push   %ebp
    9277:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    9279:	8b 45 08             	mov    0x8(%ebp),%eax
    927c:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    9283:	8b 45 08             	mov    0x8(%ebp),%eax
    9286:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    928d:	8b 45 08             	mov    0x8(%ebp),%eax
    9290:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    9297:	90                   	nop
    9298:	5d                   	pop    %ebp
    9299:	c3                   	ret    

0000929a <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    929a:	55                   	push   %ebp
    929b:	89 e5                	mov    %esp,%ebp
    929d:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    92a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    92a7:	eb 38                	jmp    92e1 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    92a9:	8b 45 08             	mov    0x8(%ebp),%eax
    92ac:	8b 40 40             	mov    0x40(%eax),%eax
    92af:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92b2:	c1 e2 02             	shl    $0x2,%edx
    92b5:	01 d0                	add    %edx,%eax
    92b7:	83 ec 0c             	sub    $0xc,%esp
    92ba:	50                   	push   %eax
    92bb:	e8 75 a3 ff ff       	call   3635 <string_cleanup>
    92c0:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    92c3:	8b 45 08             	mov    0x8(%ebp),%eax
    92c6:	8b 40 44             	mov    0x44(%eax),%eax
    92c9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92cc:	c1 e2 02             	shl    $0x2,%edx
    92cf:	01 d0                	add    %edx,%eax
    92d1:	83 ec 0c             	sub    $0xc,%esp
    92d4:	50                   	push   %eax
    92d5:	e8 5b a3 ff ff       	call   3635 <string_cleanup>
    92da:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    92dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    92e1:	8b 45 08             	mov    0x8(%ebp),%eax
    92e4:	8b 40 3c             	mov    0x3c(%eax),%eax
    92e7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    92ea:	75 bd                	jne    92a9 <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    92ec:	8b 45 08             	mov    0x8(%ebp),%eax
    92ef:	8b 40 40             	mov    0x40(%eax),%eax
    92f2:	83 ec 0c             	sub    $0xc,%esp
    92f5:	50                   	push   %eax
    92f6:	e8 67 a0 ff ff       	call   3362 <lodepng_free>
    92fb:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    92fe:	8b 45 08             	mov    0x8(%ebp),%eax
    9301:	8b 40 44             	mov    0x44(%eax),%eax
    9304:	83 ec 0c             	sub    $0xc,%esp
    9307:	50                   	push   %eax
    9308:	e8 55 a0 ff ff       	call   3362 <lodepng_free>
    930d:	83 c4 10             	add    $0x10,%esp
}
    9310:	90                   	nop
    9311:	c9                   	leave  
    9312:	c3                   	ret    

00009313 <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9313:	55                   	push   %ebp
    9314:	89 e5                	mov    %esp,%ebp
    9316:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    9319:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    9320:	8b 45 08             	mov    0x8(%ebp),%eax
    9323:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    932a:	8b 45 08             	mov    0x8(%ebp),%eax
    932d:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    9334:	8b 45 08             	mov    0x8(%ebp),%eax
    9337:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    933e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9345:	eb 42                	jmp    9389 <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    9347:	8b 45 0c             	mov    0xc(%ebp),%eax
    934a:	8b 40 44             	mov    0x44(%eax),%eax
    934d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9350:	c1 e2 02             	shl    $0x2,%edx
    9353:	01 d0                	add    %edx,%eax
    9355:	8b 10                	mov    (%eax),%edx
    9357:	8b 45 0c             	mov    0xc(%ebp),%eax
    935a:	8b 40 40             	mov    0x40(%eax),%eax
    935d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9360:	c1 e1 02             	shl    $0x2,%ecx
    9363:	01 c8                	add    %ecx,%eax
    9365:	8b 00                	mov    (%eax),%eax
    9367:	83 ec 04             	sub    $0x4,%esp
    936a:	52                   	push   %edx
    936b:	50                   	push   %eax
    936c:	ff 75 08             	pushl  0x8(%ebp)
    936f:	e8 4d 01 00 00       	call   94c1 <lodepng_add_text>
    9374:	83 c4 10             	add    $0x10,%esp
    9377:	89 45 f0             	mov    %eax,-0x10(%ebp)
    937a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    937e:	74 05                	je     9385 <LodePNGText_copy+0x72>
    9380:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9383:	eb 14                	jmp    9399 <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    9385:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9389:	8b 45 0c             	mov    0xc(%ebp),%eax
    938c:	8b 40 3c             	mov    0x3c(%eax),%eax
    938f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9392:	75 b3                	jne    9347 <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    9394:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9399:	c9                   	leave  
    939a:	c3                   	ret    

0000939b <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    939b:	55                   	push   %ebp
    939c:	89 e5                	mov    %esp,%ebp
    939e:	53                   	push   %ebx
    939f:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    93a2:	8b 45 08             	mov    0x8(%ebp),%eax
    93a5:	8b 40 3c             	mov    0x3c(%eax),%eax
    93a8:	83 c0 01             	add    $0x1,%eax
    93ab:	c1 e0 02             	shl    $0x2,%eax
    93ae:	89 c2                	mov    %eax,%edx
    93b0:	8b 45 08             	mov    0x8(%ebp),%eax
    93b3:	8b 40 40             	mov    0x40(%eax),%eax
    93b6:	52                   	push   %edx
    93b7:	50                   	push   %eax
    93b8:	e8 9b 9f ff ff       	call   3358 <lodepng_realloc>
    93bd:	83 c4 08             	add    $0x8,%esp
    93c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    93c3:	8b 45 08             	mov    0x8(%ebp),%eax
    93c6:	8b 40 3c             	mov    0x3c(%eax),%eax
    93c9:	83 c0 01             	add    $0x1,%eax
    93cc:	c1 e0 02             	shl    $0x2,%eax
    93cf:	89 c2                	mov    %eax,%edx
    93d1:	8b 45 08             	mov    0x8(%ebp),%eax
    93d4:	8b 40 44             	mov    0x44(%eax),%eax
    93d7:	52                   	push   %edx
    93d8:	50                   	push   %eax
    93d9:	e8 7a 9f ff ff       	call   3358 <lodepng_realloc>
    93de:	83 c4 08             	add    $0x8,%esp
    93e1:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    93e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    93e8:	74 09                	je     93f3 <lodepng_add_text_sized+0x58>
    93ea:	8b 45 08             	mov    0x8(%ebp),%eax
    93ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
    93f0:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    93f3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    93f7:	74 09                	je     9402 <lodepng_add_text_sized+0x67>
    93f9:	8b 45 08             	mov    0x8(%ebp),%eax
    93fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    93ff:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    9402:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9406:	74 06                	je     940e <lodepng_add_text_sized+0x73>
    9408:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    940c:	75 0a                	jne    9418 <lodepng_add_text_sized+0x7d>
    940e:	b8 53 00 00 00       	mov    $0x53,%eax
    9413:	e9 a4 00 00 00       	jmp    94bc <lodepng_add_text_sized+0x121>

  ++info->text_num;
    9418:	8b 45 08             	mov    0x8(%ebp),%eax
    941b:	8b 40 3c             	mov    0x3c(%eax),%eax
    941e:	8d 50 01             	lea    0x1(%eax),%edx
    9421:	8b 45 08             	mov    0x8(%ebp),%eax
    9424:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    9427:	8b 45 08             	mov    0x8(%ebp),%eax
    942a:	8b 50 40             	mov    0x40(%eax),%edx
    942d:	8b 45 08             	mov    0x8(%ebp),%eax
    9430:	8b 40 3c             	mov    0x3c(%eax),%eax
    9433:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9438:	c1 e0 02             	shl    $0x2,%eax
    943b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    943e:	83 ec 0c             	sub    $0xc,%esp
    9441:	ff 75 0c             	pushl  0xc(%ebp)
    9444:	e8 54 a2 ff ff       	call   369d <alloc_string>
    9449:	83 c4 10             	add    $0x10,%esp
    944c:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    944e:	8b 45 08             	mov    0x8(%ebp),%eax
    9451:	8b 50 44             	mov    0x44(%eax),%edx
    9454:	8b 45 08             	mov    0x8(%ebp),%eax
    9457:	8b 40 3c             	mov    0x3c(%eax),%eax
    945a:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    945f:	c1 e0 02             	shl    $0x2,%eax
    9462:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9465:	83 ec 08             	sub    $0x8,%esp
    9468:	ff 75 14             	pushl  0x14(%ebp)
    946b:	ff 75 10             	pushl  0x10(%ebp)
    946e:	e8 e5 a1 ff ff       	call   3658 <alloc_string_sized>
    9473:	83 c4 10             	add    $0x10,%esp
    9476:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    9478:	8b 45 08             	mov    0x8(%ebp),%eax
    947b:	8b 50 40             	mov    0x40(%eax),%edx
    947e:	8b 45 08             	mov    0x8(%ebp),%eax
    9481:	8b 40 3c             	mov    0x3c(%eax),%eax
    9484:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9489:	c1 e0 02             	shl    $0x2,%eax
    948c:	01 d0                	add    %edx,%eax
    948e:	8b 00                	mov    (%eax),%eax
    9490:	85 c0                	test   %eax,%eax
    9492:	74 1c                	je     94b0 <lodepng_add_text_sized+0x115>
    9494:	8b 45 08             	mov    0x8(%ebp),%eax
    9497:	8b 50 44             	mov    0x44(%eax),%edx
    949a:	8b 45 08             	mov    0x8(%ebp),%eax
    949d:	8b 40 3c             	mov    0x3c(%eax),%eax
    94a0:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    94a5:	c1 e0 02             	shl    $0x2,%eax
    94a8:	01 d0                	add    %edx,%eax
    94aa:	8b 00                	mov    (%eax),%eax
    94ac:	85 c0                	test   %eax,%eax
    94ae:	75 07                	jne    94b7 <lodepng_add_text_sized+0x11c>
    94b0:	b8 53 00 00 00       	mov    $0x53,%eax
    94b5:	eb 05                	jmp    94bc <lodepng_add_text_sized+0x121>

  return 0;
    94b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    94bc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    94bf:	c9                   	leave  
    94c0:	c3                   	ret    

000094c1 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    94c1:	55                   	push   %ebp
    94c2:	89 e5                	mov    %esp,%ebp
    94c4:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    94c7:	ff 75 10             	pushl  0x10(%ebp)
    94ca:	e8 0e 9f ff ff       	call   33dd <lodepng_strlen>
    94cf:	83 c4 04             	add    $0x4,%esp
    94d2:	50                   	push   %eax
    94d3:	ff 75 10             	pushl  0x10(%ebp)
    94d6:	ff 75 0c             	pushl  0xc(%ebp)
    94d9:	ff 75 08             	pushl  0x8(%ebp)
    94dc:	e8 ba fe ff ff       	call   939b <lodepng_add_text_sized>
    94e1:	83 c4 10             	add    $0x10,%esp
}
    94e4:	c9                   	leave  
    94e5:	c3                   	ret    

000094e6 <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    94e6:	55                   	push   %ebp
    94e7:	89 e5                	mov    %esp,%ebp
    94e9:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    94ec:	83 ec 0c             	sub    $0xc,%esp
    94ef:	ff 75 08             	pushl  0x8(%ebp)
    94f2:	e8 a3 fd ff ff       	call   929a <LodePNGText_cleanup>
    94f7:	83 c4 10             	add    $0x10,%esp
}
    94fa:	90                   	nop
    94fb:	c9                   	leave  
    94fc:	c3                   	ret    

000094fd <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    94fd:	55                   	push   %ebp
    94fe:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    9500:	8b 45 08             	mov    0x8(%ebp),%eax
    9503:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    950a:	8b 45 08             	mov    0x8(%ebp),%eax
    950d:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    9514:	8b 45 08             	mov    0x8(%ebp),%eax
    9517:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    951e:	8b 45 08             	mov    0x8(%ebp),%eax
    9521:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    9528:	8b 45 08             	mov    0x8(%ebp),%eax
    952b:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    9532:	90                   	nop
    9533:	5d                   	pop    %ebp
    9534:	c3                   	ret    

00009535 <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    9535:	55                   	push   %ebp
    9536:	89 e5                	mov    %esp,%ebp
    9538:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    953b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9542:	eb 6c                	jmp    95b0 <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    9544:	8b 45 08             	mov    0x8(%ebp),%eax
    9547:	8b 40 4c             	mov    0x4c(%eax),%eax
    954a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    954d:	c1 e2 02             	shl    $0x2,%edx
    9550:	01 d0                	add    %edx,%eax
    9552:	83 ec 0c             	sub    $0xc,%esp
    9555:	50                   	push   %eax
    9556:	e8 da a0 ff ff       	call   3635 <string_cleanup>
    955b:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    955e:	8b 45 08             	mov    0x8(%ebp),%eax
    9561:	8b 40 50             	mov    0x50(%eax),%eax
    9564:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9567:	c1 e2 02             	shl    $0x2,%edx
    956a:	01 d0                	add    %edx,%eax
    956c:	83 ec 0c             	sub    $0xc,%esp
    956f:	50                   	push   %eax
    9570:	e8 c0 a0 ff ff       	call   3635 <string_cleanup>
    9575:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    9578:	8b 45 08             	mov    0x8(%ebp),%eax
    957b:	8b 40 54             	mov    0x54(%eax),%eax
    957e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9581:	c1 e2 02             	shl    $0x2,%edx
    9584:	01 d0                	add    %edx,%eax
    9586:	83 ec 0c             	sub    $0xc,%esp
    9589:	50                   	push   %eax
    958a:	e8 a6 a0 ff ff       	call   3635 <string_cleanup>
    958f:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    9592:	8b 45 08             	mov    0x8(%ebp),%eax
    9595:	8b 40 58             	mov    0x58(%eax),%eax
    9598:	8b 55 f4             	mov    -0xc(%ebp),%edx
    959b:	c1 e2 02             	shl    $0x2,%edx
    959e:	01 d0                	add    %edx,%eax
    95a0:	83 ec 0c             	sub    $0xc,%esp
    95a3:	50                   	push   %eax
    95a4:	e8 8c a0 ff ff       	call   3635 <string_cleanup>
    95a9:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    95ac:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    95b0:	8b 45 08             	mov    0x8(%ebp),%eax
    95b3:	8b 40 48             	mov    0x48(%eax),%eax
    95b6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    95b9:	75 89                	jne    9544 <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    95bb:	8b 45 08             	mov    0x8(%ebp),%eax
    95be:	8b 40 4c             	mov    0x4c(%eax),%eax
    95c1:	83 ec 0c             	sub    $0xc,%esp
    95c4:	50                   	push   %eax
    95c5:	e8 98 9d ff ff       	call   3362 <lodepng_free>
    95ca:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    95cd:	8b 45 08             	mov    0x8(%ebp),%eax
    95d0:	8b 40 50             	mov    0x50(%eax),%eax
    95d3:	83 ec 0c             	sub    $0xc,%esp
    95d6:	50                   	push   %eax
    95d7:	e8 86 9d ff ff       	call   3362 <lodepng_free>
    95dc:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    95df:	8b 45 08             	mov    0x8(%ebp),%eax
    95e2:	8b 40 54             	mov    0x54(%eax),%eax
    95e5:	83 ec 0c             	sub    $0xc,%esp
    95e8:	50                   	push   %eax
    95e9:	e8 74 9d ff ff       	call   3362 <lodepng_free>
    95ee:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    95f1:	8b 45 08             	mov    0x8(%ebp),%eax
    95f4:	8b 40 58             	mov    0x58(%eax),%eax
    95f7:	83 ec 0c             	sub    $0xc,%esp
    95fa:	50                   	push   %eax
    95fb:	e8 62 9d ff ff       	call   3362 <lodepng_free>
    9600:	83 c4 10             	add    $0x10,%esp
}
    9603:	90                   	nop
    9604:	c9                   	leave  
    9605:	c3                   	ret    

00009606 <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9606:	55                   	push   %ebp
    9607:	89 e5                	mov    %esp,%ebp
    9609:	56                   	push   %esi
    960a:	53                   	push   %ebx
    960b:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    960e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    9615:	8b 45 08             	mov    0x8(%ebp),%eax
    9618:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    961f:	8b 45 08             	mov    0x8(%ebp),%eax
    9622:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    9629:	8b 45 08             	mov    0x8(%ebp),%eax
    962c:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    9633:	8b 45 08             	mov    0x8(%ebp),%eax
    9636:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    963d:	8b 45 08             	mov    0x8(%ebp),%eax
    9640:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    9647:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    964e:	eb 64                	jmp    96b4 <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    9650:	8b 45 0c             	mov    0xc(%ebp),%eax
    9653:	8b 40 58             	mov    0x58(%eax),%eax
    9656:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9659:	c1 e2 02             	shl    $0x2,%edx
    965c:	01 d0                	add    %edx,%eax
    965e:	8b 18                	mov    (%eax),%ebx
    9660:	8b 45 0c             	mov    0xc(%ebp),%eax
    9663:	8b 40 54             	mov    0x54(%eax),%eax
    9666:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9669:	c1 e2 02             	shl    $0x2,%edx
    966c:	01 d0                	add    %edx,%eax
    966e:	8b 08                	mov    (%eax),%ecx
    9670:	8b 45 0c             	mov    0xc(%ebp),%eax
    9673:	8b 40 50             	mov    0x50(%eax),%eax
    9676:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9679:	c1 e2 02             	shl    $0x2,%edx
    967c:	01 d0                	add    %edx,%eax
    967e:	8b 10                	mov    (%eax),%edx
    9680:	8b 45 0c             	mov    0xc(%ebp),%eax
    9683:	8b 40 4c             	mov    0x4c(%eax),%eax
    9686:	8b 75 f4             	mov    -0xc(%ebp),%esi
    9689:	c1 e6 02             	shl    $0x2,%esi
    968c:	01 f0                	add    %esi,%eax
    968e:	8b 00                	mov    (%eax),%eax
    9690:	83 ec 0c             	sub    $0xc,%esp
    9693:	53                   	push   %ebx
    9694:	51                   	push   %ecx
    9695:	52                   	push   %edx
    9696:	50                   	push   %eax
    9697:	ff 75 08             	pushl  0x8(%ebp)
    969a:	e8 e4 01 00 00       	call   9883 <lodepng_add_itext>
    969f:	83 c4 20             	add    $0x20,%esp
    96a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    96a5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    96a9:	74 05                	je     96b0 <LodePNGIText_copy+0xaa>
    96ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
    96ae:	eb 14                	jmp    96c4 <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    96b0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    96b4:	8b 45 0c             	mov    0xc(%ebp),%eax
    96b7:	8b 40 48             	mov    0x48(%eax),%eax
    96ba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    96bd:	75 91                	jne    9650 <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    96bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
    96c4:	8d 65 f8             	lea    -0x8(%ebp),%esp
    96c7:	5b                   	pop    %ebx
    96c8:	5e                   	pop    %esi
    96c9:	5d                   	pop    %ebp
    96ca:	c3                   	ret    

000096cb <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    96cb:	55                   	push   %ebp
    96cc:	89 e5                	mov    %esp,%ebp
    96ce:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    96d1:	83 ec 0c             	sub    $0xc,%esp
    96d4:	ff 75 08             	pushl  0x8(%ebp)
    96d7:	e8 59 fe ff ff       	call   9535 <LodePNGIText_cleanup>
    96dc:	83 c4 10             	add    $0x10,%esp
}
    96df:	90                   	nop
    96e0:	c9                   	leave  
    96e1:	c3                   	ret    

000096e2 <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    96e2:	55                   	push   %ebp
    96e3:	89 e5                	mov    %esp,%ebp
    96e5:	53                   	push   %ebx
    96e6:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    96e9:	8b 45 08             	mov    0x8(%ebp),%eax
    96ec:	8b 40 48             	mov    0x48(%eax),%eax
    96ef:	83 c0 01             	add    $0x1,%eax
    96f2:	c1 e0 02             	shl    $0x2,%eax
    96f5:	89 c2                	mov    %eax,%edx
    96f7:	8b 45 08             	mov    0x8(%ebp),%eax
    96fa:	8b 40 4c             	mov    0x4c(%eax),%eax
    96fd:	52                   	push   %edx
    96fe:	50                   	push   %eax
    96ff:	e8 54 9c ff ff       	call   3358 <lodepng_realloc>
    9704:	83 c4 08             	add    $0x8,%esp
    9707:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    970a:	8b 45 08             	mov    0x8(%ebp),%eax
    970d:	8b 40 48             	mov    0x48(%eax),%eax
    9710:	83 c0 01             	add    $0x1,%eax
    9713:	c1 e0 02             	shl    $0x2,%eax
    9716:	89 c2                	mov    %eax,%edx
    9718:	8b 45 08             	mov    0x8(%ebp),%eax
    971b:	8b 40 50             	mov    0x50(%eax),%eax
    971e:	52                   	push   %edx
    971f:	50                   	push   %eax
    9720:	e8 33 9c ff ff       	call   3358 <lodepng_realloc>
    9725:	83 c4 08             	add    $0x8,%esp
    9728:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    972b:	8b 45 08             	mov    0x8(%ebp),%eax
    972e:	8b 40 48             	mov    0x48(%eax),%eax
    9731:	83 c0 01             	add    $0x1,%eax
    9734:	c1 e0 02             	shl    $0x2,%eax
    9737:	89 c2                	mov    %eax,%edx
    9739:	8b 45 08             	mov    0x8(%ebp),%eax
    973c:	8b 40 54             	mov    0x54(%eax),%eax
    973f:	52                   	push   %edx
    9740:	50                   	push   %eax
    9741:	e8 12 9c ff ff       	call   3358 <lodepng_realloc>
    9746:	83 c4 08             	add    $0x8,%esp
    9749:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    974c:	8b 45 08             	mov    0x8(%ebp),%eax
    974f:	8b 40 48             	mov    0x48(%eax),%eax
    9752:	83 c0 01             	add    $0x1,%eax
    9755:	c1 e0 02             	shl    $0x2,%eax
    9758:	89 c2                	mov    %eax,%edx
    975a:	8b 45 08             	mov    0x8(%ebp),%eax
    975d:	8b 40 58             	mov    0x58(%eax),%eax
    9760:	52                   	push   %edx
    9761:	50                   	push   %eax
    9762:	e8 f1 9b ff ff       	call   3358 <lodepng_realloc>
    9767:	83 c4 08             	add    $0x8,%esp
    976a:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    976d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9771:	74 09                	je     977c <lodepng_add_itext_sized+0x9a>
    9773:	8b 45 08             	mov    0x8(%ebp),%eax
    9776:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9779:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    977c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9780:	74 09                	je     978b <lodepng_add_itext_sized+0xa9>
    9782:	8b 45 08             	mov    0x8(%ebp),%eax
    9785:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9788:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    978b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    978f:	74 09                	je     979a <lodepng_add_itext_sized+0xb8>
    9791:	8b 45 08             	mov    0x8(%ebp),%eax
    9794:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9797:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    979a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    979e:	74 09                	je     97a9 <lodepng_add_itext_sized+0xc7>
    97a0:	8b 45 08             	mov    0x8(%ebp),%eax
    97a3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    97a6:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    97a9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    97ad:	74 12                	je     97c1 <lodepng_add_itext_sized+0xdf>
    97af:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    97b3:	74 0c                	je     97c1 <lodepng_add_itext_sized+0xdf>
    97b5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    97b9:	74 06                	je     97c1 <lodepng_add_itext_sized+0xdf>
    97bb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    97bf:	75 0a                	jne    97cb <lodepng_add_itext_sized+0xe9>
    97c1:	b8 53 00 00 00       	mov    $0x53,%eax
    97c6:	e9 b3 00 00 00       	jmp    987e <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    97cb:	8b 45 08             	mov    0x8(%ebp),%eax
    97ce:	8b 40 48             	mov    0x48(%eax),%eax
    97d1:	8d 50 01             	lea    0x1(%eax),%edx
    97d4:	8b 45 08             	mov    0x8(%ebp),%eax
    97d7:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    97da:	8b 45 08             	mov    0x8(%ebp),%eax
    97dd:	8b 50 4c             	mov    0x4c(%eax),%edx
    97e0:	8b 45 08             	mov    0x8(%ebp),%eax
    97e3:	8b 40 48             	mov    0x48(%eax),%eax
    97e6:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    97eb:	c1 e0 02             	shl    $0x2,%eax
    97ee:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    97f1:	83 ec 0c             	sub    $0xc,%esp
    97f4:	ff 75 0c             	pushl  0xc(%ebp)
    97f7:	e8 a1 9e ff ff       	call   369d <alloc_string>
    97fc:	83 c4 10             	add    $0x10,%esp
    97ff:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    9801:	8b 45 08             	mov    0x8(%ebp),%eax
    9804:	8b 50 50             	mov    0x50(%eax),%edx
    9807:	8b 45 08             	mov    0x8(%ebp),%eax
    980a:	8b 40 48             	mov    0x48(%eax),%eax
    980d:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9812:	c1 e0 02             	shl    $0x2,%eax
    9815:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9818:	83 ec 0c             	sub    $0xc,%esp
    981b:	ff 75 10             	pushl  0x10(%ebp)
    981e:	e8 7a 9e ff ff       	call   369d <alloc_string>
    9823:	83 c4 10             	add    $0x10,%esp
    9826:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    9828:	8b 45 08             	mov    0x8(%ebp),%eax
    982b:	8b 50 54             	mov    0x54(%eax),%edx
    982e:	8b 45 08             	mov    0x8(%ebp),%eax
    9831:	8b 40 48             	mov    0x48(%eax),%eax
    9834:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9839:	c1 e0 02             	shl    $0x2,%eax
    983c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    983f:	83 ec 0c             	sub    $0xc,%esp
    9842:	ff 75 14             	pushl  0x14(%ebp)
    9845:	e8 53 9e ff ff       	call   369d <alloc_string>
    984a:	83 c4 10             	add    $0x10,%esp
    984d:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    984f:	8b 45 08             	mov    0x8(%ebp),%eax
    9852:	8b 50 58             	mov    0x58(%eax),%edx
    9855:	8b 45 08             	mov    0x8(%ebp),%eax
    9858:	8b 40 48             	mov    0x48(%eax),%eax
    985b:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9860:	c1 e0 02             	shl    $0x2,%eax
    9863:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9866:	83 ec 08             	sub    $0x8,%esp
    9869:	ff 75 1c             	pushl  0x1c(%ebp)
    986c:	ff 75 18             	pushl  0x18(%ebp)
    986f:	e8 e4 9d ff ff       	call   3658 <alloc_string_sized>
    9874:	83 c4 10             	add    $0x10,%esp
    9877:	89 03                	mov    %eax,(%ebx)

  return 0;
    9879:	b8 00 00 00 00       	mov    $0x0,%eax
}
    987e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9881:	c9                   	leave  
    9882:	c3                   	ret    

00009883 <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    9883:	55                   	push   %ebp
    9884:	89 e5                	mov    %esp,%ebp
    9886:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    9889:	ff 75 18             	pushl  0x18(%ebp)
    988c:	e8 4c 9b ff ff       	call   33dd <lodepng_strlen>
    9891:	83 c4 04             	add    $0x4,%esp
    9894:	83 ec 08             	sub    $0x8,%esp
    9897:	50                   	push   %eax
    9898:	ff 75 18             	pushl  0x18(%ebp)
    989b:	ff 75 14             	pushl  0x14(%ebp)
    989e:	ff 75 10             	pushl  0x10(%ebp)
    98a1:	ff 75 0c             	pushl  0xc(%ebp)
    98a4:	ff 75 08             	pushl  0x8(%ebp)
    98a7:	e8 36 fe ff ff       	call   96e2 <lodepng_add_itext_sized>
    98ac:	83 c4 20             	add    $0x20,%esp
}
    98af:	c9                   	leave  
    98b0:	c3                   	ret    

000098b1 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    98b1:	55                   	push   %ebp
    98b2:	89 e5                	mov    %esp,%ebp
    98b4:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    98b7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    98bb:	75 0a                	jne    98c7 <lodepng_assign_icc+0x16>
    98bd:	b8 64 00 00 00       	mov    $0x64,%eax
    98c2:	e9 81 00 00 00       	jmp    9948 <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    98c7:	83 ec 0c             	sub    $0xc,%esp
    98ca:	ff 75 0c             	pushl  0xc(%ebp)
    98cd:	e8 cb 9d ff ff       	call   369d <alloc_string>
    98d2:	83 c4 10             	add    $0x10,%esp
    98d5:	89 c2                	mov    %eax,%edx
    98d7:	8b 45 08             	mov    0x8(%ebp),%eax
    98da:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    98e0:	8b 45 14             	mov    0x14(%ebp),%eax
    98e3:	83 ec 0c             	sub    $0xc,%esp
    98e6:	50                   	push   %eax
    98e7:	e8 55 9a ff ff       	call   3341 <lodepng_malloc>
    98ec:	83 c4 10             	add    $0x10,%esp
    98ef:	89 c2                	mov    %eax,%edx
    98f1:	8b 45 08             	mov    0x8(%ebp),%eax
    98f4:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    98fa:	8b 45 08             	mov    0x8(%ebp),%eax
    98fd:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9903:	85 c0                	test   %eax,%eax
    9905:	74 0d                	je     9914 <lodepng_assign_icc+0x63>
    9907:	8b 45 08             	mov    0x8(%ebp),%eax
    990a:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9910:	85 c0                	test   %eax,%eax
    9912:	75 07                	jne    991b <lodepng_assign_icc+0x6a>
    9914:	b8 53 00 00 00       	mov    $0x53,%eax
    9919:	eb 2d                	jmp    9948 <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    991b:	8b 55 14             	mov    0x14(%ebp),%edx
    991e:	8b 45 08             	mov    0x8(%ebp),%eax
    9921:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9927:	83 ec 04             	sub    $0x4,%esp
    992a:	52                   	push   %edx
    992b:	ff 75 10             	pushl  0x10(%ebp)
    992e:	50                   	push   %eax
    992f:	e8 4b 9a ff ff       	call   337f <lodepng_memcpy>
    9934:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    9937:	8b 45 08             	mov    0x8(%ebp),%eax
    993a:	8b 55 14             	mov    0x14(%ebp),%edx
    993d:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    9943:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9948:	c9                   	leave  
    9949:	c3                   	ret    

0000994a <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    994a:	55                   	push   %ebp
    994b:	89 e5                	mov    %esp,%ebp
    994d:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    9950:	8b 45 08             	mov    0x8(%ebp),%eax
    9953:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9959:	85 c0                	test   %eax,%eax
    995b:	74 0e                	je     996b <lodepng_set_icc+0x21>
    995d:	83 ec 0c             	sub    $0xc,%esp
    9960:	ff 75 08             	pushl  0x8(%ebp)
    9963:	e8 26 00 00 00       	call   998e <lodepng_clear_icc>
    9968:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    996b:	8b 45 08             	mov    0x8(%ebp),%eax
    996e:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    9975:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    9978:	ff 75 14             	pushl  0x14(%ebp)
    997b:	ff 75 10             	pushl  0x10(%ebp)
    997e:	ff 75 0c             	pushl  0xc(%ebp)
    9981:	ff 75 08             	pushl  0x8(%ebp)
    9984:	e8 28 ff ff ff       	call   98b1 <lodepng_assign_icc>
    9989:	83 c4 10             	add    $0x10,%esp
}
    998c:	c9                   	leave  
    998d:	c3                   	ret    

0000998e <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    998e:	55                   	push   %ebp
    998f:	89 e5                	mov    %esp,%ebp
    9991:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    9994:	8b 45 08             	mov    0x8(%ebp),%eax
    9997:	05 c0 00 00 00       	add    $0xc0,%eax
    999c:	83 ec 0c             	sub    $0xc,%esp
    999f:	50                   	push   %eax
    99a0:	e8 90 9c ff ff       	call   3635 <string_cleanup>
    99a5:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    99a8:	8b 45 08             	mov    0x8(%ebp),%eax
    99ab:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    99b1:	83 ec 0c             	sub    $0xc,%esp
    99b4:	50                   	push   %eax
    99b5:	e8 a8 99 ff ff       	call   3362 <lodepng_free>
    99ba:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    99bd:	8b 45 08             	mov    0x8(%ebp),%eax
    99c0:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    99c7:	00 00 00 
  info->iccp_profile_size = 0;
    99ca:	8b 45 08             	mov    0x8(%ebp),%eax
    99cd:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    99d4:	00 00 00 
  info->iccp_defined = 0;
    99d7:	8b 45 08             	mov    0x8(%ebp),%eax
    99da:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    99e1:	00 00 00 
}
    99e4:	90                   	nop
    99e5:	c9                   	leave  
    99e6:	c3                   	ret    

000099e7 <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    99e7:	55                   	push   %ebp
    99e8:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    99ea:	8b 45 08             	mov    0x8(%ebp),%eax
    99ed:	83 c0 0c             	add    $0xc,%eax
    99f0:	50                   	push   %eax
    99f1:	e8 5a f0 ff ff       	call   8a50 <lodepng_color_mode_init>
    99f6:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    99f9:	8b 45 08             	mov    0x8(%ebp),%eax
    99fc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    9a03:	8b 45 08             	mov    0x8(%ebp),%eax
    9a06:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    9a0c:	8b 45 08             	mov    0x8(%ebp),%eax
    9a0f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    9a16:	8b 45 08             	mov    0x8(%ebp),%eax
    9a19:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    9a20:	8b 45 08             	mov    0x8(%ebp),%eax
    9a23:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    9a2a:	8b 45 08             	mov    0x8(%ebp),%eax
    9a2d:	8b 50 38             	mov    0x38(%eax),%edx
    9a30:	8b 45 08             	mov    0x8(%ebp),%eax
    9a33:	89 50 34             	mov    %edx,0x34(%eax)
    9a36:	8b 45 08             	mov    0x8(%ebp),%eax
    9a39:	8b 50 34             	mov    0x34(%eax),%edx
    9a3c:	8b 45 08             	mov    0x8(%ebp),%eax
    9a3f:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    9a42:	ff 75 08             	pushl  0x8(%ebp)
    9a45:	e8 2c f8 ff ff       	call   9276 <LodePNGText_init>
    9a4a:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    9a4d:	ff 75 08             	pushl  0x8(%ebp)
    9a50:	e8 a8 fa ff ff       	call   94fd <LodePNGIText_init>
    9a55:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    9a58:	8b 45 08             	mov    0x8(%ebp),%eax
    9a5b:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    9a62:	8b 45 08             	mov    0x8(%ebp),%eax
    9a65:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    9a6c:	8b 45 08             	mov    0x8(%ebp),%eax
    9a6f:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    9a76:	00 00 00 
  info->chrm_defined = 0;
    9a79:	8b 45 08             	mov    0x8(%ebp),%eax
    9a7c:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    9a83:	00 00 00 
  info->srgb_defined = 0;
    9a86:	8b 45 08             	mov    0x8(%ebp),%eax
    9a89:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    9a90:	00 00 00 
  info->iccp_defined = 0;
    9a93:	8b 45 08             	mov    0x8(%ebp),%eax
    9a96:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9a9d:	00 00 00 
  info->iccp_name = NULL;
    9aa0:	8b 45 08             	mov    0x8(%ebp),%eax
    9aa3:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    9aaa:	00 00 00 
  info->iccp_profile = NULL;
    9aad:	8b 45 08             	mov    0x8(%ebp),%eax
    9ab0:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9ab7:	00 00 00 

  LodePNGUnknownChunks_init(info);
    9aba:	ff 75 08             	pushl  0x8(%ebp)
    9abd:	e8 46 f6 ff ff       	call   9108 <LodePNGUnknownChunks_init>
    9ac2:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9ac5:	90                   	nop
    9ac6:	c9                   	leave  
    9ac7:	c3                   	ret    

00009ac8 <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    9ac8:	55                   	push   %ebp
    9ac9:	89 e5                	mov    %esp,%ebp
    9acb:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    9ace:	8b 45 08             	mov    0x8(%ebp),%eax
    9ad1:	83 c0 0c             	add    $0xc,%eax
    9ad4:	83 ec 0c             	sub    $0xc,%esp
    9ad7:	50                   	push   %eax
    9ad8:	e8 66 f0 ff ff       	call   8b43 <lodepng_color_mode_cleanup>
    9add:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    9ae0:	83 ec 0c             	sub    $0xc,%esp
    9ae3:	ff 75 08             	pushl  0x8(%ebp)
    9ae6:	e8 af f7 ff ff       	call   929a <LodePNGText_cleanup>
    9aeb:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    9aee:	83 ec 0c             	sub    $0xc,%esp
    9af1:	ff 75 08             	pushl  0x8(%ebp)
    9af4:	e8 3c fa ff ff       	call   9535 <LodePNGIText_cleanup>
    9af9:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    9afc:	83 ec 0c             	sub    $0xc,%esp
    9aff:	ff 75 08             	pushl  0x8(%ebp)
    9b02:	e8 87 fe ff ff       	call   998e <lodepng_clear_icc>
    9b07:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    9b0a:	83 ec 0c             	sub    $0xc,%esp
    9b0d:	ff 75 08             	pushl  0x8(%ebp)
    9b10:	e8 44 f6 ff ff       	call   9159 <LodePNGUnknownChunks_cleanup>
    9b15:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9b18:	90                   	nop
    9b19:	c9                   	leave  
    9b1a:	c3                   	ret    

00009b1b <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9b1b:	55                   	push   %ebp
    9b1c:	89 e5                	mov    %esp,%ebp
    9b1e:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    9b21:	83 ec 0c             	sub    $0xc,%esp
    9b24:	ff 75 08             	pushl  0x8(%ebp)
    9b27:	e8 9c ff ff ff       	call   9ac8 <lodepng_info_cleanup>
    9b2c:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    9b2f:	83 ec 04             	sub    $0x4,%esp
    9b32:	68 e4 00 00 00       	push   $0xe4
    9b37:	ff 75 0c             	pushl  0xc(%ebp)
    9b3a:	ff 75 08             	pushl  0x8(%ebp)
    9b3d:	e8 3d 98 ff ff       	call   337f <lodepng_memcpy>
    9b42:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    9b45:	8b 45 08             	mov    0x8(%ebp),%eax
    9b48:	83 c0 0c             	add    $0xc,%eax
    9b4b:	83 ec 0c             	sub    $0xc,%esp
    9b4e:	50                   	push   %eax
    9b4f:	e8 fc ee ff ff       	call   8a50 <lodepng_color_mode_init>
    9b54:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    9b57:	8b 45 0c             	mov    0xc(%ebp),%eax
    9b5a:	8d 50 0c             	lea    0xc(%eax),%edx
    9b5d:	8b 45 08             	mov    0x8(%ebp),%eax
    9b60:	83 c0 0c             	add    $0xc,%eax
    9b63:	83 ec 08             	sub    $0x8,%esp
    9b66:	52                   	push   %edx
    9b67:	50                   	push   %eax
    9b68:	e8 ed ef ff ff       	call   8b5a <lodepng_color_mode_copy>
    9b6d:	83 c4 10             	add    $0x10,%esp
    9b70:	89 45 f4             	mov    %eax,-0xc(%ebp)
    9b73:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9b77:	74 08                	je     9b81 <lodepng_info_copy+0x66>
    9b79:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9b7c:	e9 b7 00 00 00       	jmp    9c38 <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    9b81:	83 ec 08             	sub    $0x8,%esp
    9b84:	ff 75 0c             	pushl  0xc(%ebp)
    9b87:	ff 75 08             	pushl  0x8(%ebp)
    9b8a:	e8 84 f7 ff ff       	call   9313 <LodePNGText_copy>
    9b8f:	83 c4 10             	add    $0x10,%esp
    9b92:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9b95:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9b99:	74 08                	je     9ba3 <lodepng_info_copy+0x88>
    9b9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9b9e:	e9 95 00 00 00       	jmp    9c38 <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    9ba3:	83 ec 08             	sub    $0x8,%esp
    9ba6:	ff 75 0c             	pushl  0xc(%ebp)
    9ba9:	ff 75 08             	pushl  0x8(%ebp)
    9bac:	e8 55 fa ff ff       	call   9606 <LodePNGIText_copy>
    9bb1:	83 c4 10             	add    $0x10,%esp
    9bb4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9bb7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9bbb:	74 05                	je     9bc2 <lodepng_info_copy+0xa7>
    9bbd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9bc0:	eb 76                	jmp    9c38 <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    9bc2:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bc5:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    9bcb:	85 c0                	test   %eax,%eax
    9bcd:	74 37                	je     9c06 <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    9bcf:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bd2:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    9bd8:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bdb:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    9be1:	8b 45 0c             	mov    0xc(%ebp),%eax
    9be4:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9bea:	51                   	push   %ecx
    9beb:	52                   	push   %edx
    9bec:	50                   	push   %eax
    9bed:	ff 75 08             	pushl  0x8(%ebp)
    9bf0:	e8 bc fc ff ff       	call   98b1 <lodepng_assign_icc>
    9bf5:	83 c4 10             	add    $0x10,%esp
    9bf8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9bfb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9bff:	74 05                	je     9c06 <lodepng_info_copy+0xeb>
    9c01:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9c04:	eb 32                	jmp    9c38 <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    9c06:	83 ec 0c             	sub    $0xc,%esp
    9c09:	ff 75 08             	pushl  0x8(%ebp)
    9c0c:	e8 f7 f4 ff ff       	call   9108 <LodePNGUnknownChunks_init>
    9c11:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    9c14:	83 ec 08             	sub    $0x8,%esp
    9c17:	ff 75 0c             	pushl  0xc(%ebp)
    9c1a:	ff 75 08             	pushl  0x8(%ebp)
    9c1d:	e8 6c f5 ff ff       	call   918e <LodePNGUnknownChunks_copy>
    9c22:	83 c4 10             	add    $0x10,%esp
    9c25:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9c28:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    9c2c:	74 05                	je     9c33 <lodepng_info_copy+0x118>
    9c2e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9c31:	eb 05                	jmp    9c38 <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    9c33:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9c38:	c9                   	leave  
    9c39:	c3                   	ret    

00009c3a <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    9c3a:	55                   	push   %ebp
    9c3b:	89 e5                	mov    %esp,%ebp
    9c3d:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    9c40:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    9c44:	74 14                	je     9c5a <addColorBits+0x20>
    9c46:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    9c4a:	75 07                	jne    9c53 <addColorBits+0x19>
    9c4c:	b8 03 00 00 00       	mov    $0x3,%eax
    9c51:	eb 0c                	jmp    9c5f <addColorBits+0x25>
    9c53:	b8 01 00 00 00       	mov    $0x1,%eax
    9c58:	eb 05                	jmp    9c5f <addColorBits+0x25>
    9c5a:	b8 07 00 00 00       	mov    $0x7,%eax
    9c5f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    9c62:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c65:	23 45 fc             	and    -0x4(%ebp),%eax
    9c68:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    9c6b:	8b 45 10             	mov    0x10(%ebp),%eax
    9c6e:	ba 01 00 00 00       	mov    $0x1,%edx
    9c73:	89 c1                	mov    %eax,%ecx
    9c75:	d3 e2                	shl    %cl,%edx
    9c77:	89 d0                	mov    %edx,%eax
    9c79:	83 e8 01             	sub    $0x1,%eax
    9c7c:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    9c7f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9c82:	2b 45 f8             	sub    -0x8(%ebp),%eax
    9c85:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c89:	89 c1                	mov    %eax,%ecx
    9c8b:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    9c8e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    9c92:	75 18                	jne    9cac <addColorBits+0x72>
    9c94:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c97:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c9b:	c1 e8 03             	shr    $0x3,%eax
    9c9e:	89 c2                	mov    %eax,%edx
    9ca0:	8b 45 08             	mov    0x8(%ebp),%eax
    9ca3:	01 d0                	add    %edx,%eax
    9ca5:	8b 55 14             	mov    0x14(%ebp),%edx
    9ca8:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    9caa:	eb 1e                	jmp    9cca <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    9cac:	8b 45 0c             	mov    0xc(%ebp),%eax
    9caf:	0f af 45 10          	imul   0x10(%ebp),%eax
    9cb3:	c1 e8 03             	shr    $0x3,%eax
    9cb6:	8b 55 08             	mov    0x8(%ebp),%edx
    9cb9:	01 c2                	add    %eax,%edx
    9cbb:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9cbe:	01 c8                	add    %ecx,%eax
    9cc0:	0f b6 08             	movzbl (%eax),%ecx
    9cc3:	8b 45 14             	mov    0x14(%ebp),%eax
    9cc6:	09 c8                	or     %ecx,%eax
    9cc8:	88 02                	mov    %al,(%edx)
}
    9cca:	90                   	nop
    9ccb:	c9                   	leave  
    9ccc:	c3                   	ret    

00009ccd <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    9ccd:	55                   	push   %ebp
    9cce:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    9cd0:	8b 45 08             	mov    0x8(%ebp),%eax
    9cd3:	6a 40                	push   $0x40
    9cd5:	6a 00                	push   $0x0
    9cd7:	50                   	push   %eax
    9cd8:	e8 d5 96 ff ff       	call   33b2 <lodepng_memset>
    9cdd:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    9ce0:	8b 45 08             	mov    0x8(%ebp),%eax
    9ce3:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    9cea:	90                   	nop
    9ceb:	c9                   	leave  
    9cec:	c3                   	ret    

00009ced <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    9ced:	55                   	push   %ebp
    9cee:	89 e5                	mov    %esp,%ebp
    9cf0:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    9cf3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9cfa:	eb 3b                	jmp    9d37 <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    9cfc:	8b 45 08             	mov    0x8(%ebp),%eax
    9cff:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d02:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9d05:	85 c0                	test   %eax,%eax
    9d07:	74 2a                	je     9d33 <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    9d09:	8b 45 08             	mov    0x8(%ebp),%eax
    9d0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d0f:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9d12:	83 ec 0c             	sub    $0xc,%esp
    9d15:	50                   	push   %eax
    9d16:	e8 d2 ff ff ff       	call   9ced <color_tree_cleanup>
    9d1b:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    9d1e:	8b 45 08             	mov    0x8(%ebp),%eax
    9d21:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d24:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9d27:	83 ec 0c             	sub    $0xc,%esp
    9d2a:	50                   	push   %eax
    9d2b:	e8 32 96 ff ff       	call   3362 <lodepng_free>
    9d30:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    9d33:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9d37:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    9d3b:	75 bf                	jne    9cfc <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    9d3d:	90                   	nop
    9d3e:	c9                   	leave  
    9d3f:	c3                   	ret    

00009d40 <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9d40:	55                   	push   %ebp
    9d41:	89 e5                	mov    %esp,%ebp
    9d43:	53                   	push   %ebx
    9d44:	83 ec 20             	sub    $0x20,%esp
    9d47:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9d4a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9d4d:	8b 55 14             	mov    0x14(%ebp),%edx
    9d50:	8b 45 18             	mov    0x18(%ebp),%eax
    9d53:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9d56:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9d59:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9d5c:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    9d5f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    9d66:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    9d6d:	eb 76                	jmp    9de5 <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9d6f:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    9d73:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d76:	89 c1                	mov    %eax,%ecx
    9d78:	d3 fa                	sar    %cl,%edx
    9d7a:	89 d0                	mov    %edx,%eax
    9d7c:	83 e0 01             	and    $0x1,%eax
    9d7f:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d82:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9d86:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d89:	89 c1                	mov    %eax,%ecx
    9d8b:	d3 fa                	sar    %cl,%edx
    9d8d:	89 d0                	mov    %edx,%eax
    9d8f:	83 e0 01             	and    $0x1,%eax
    9d92:	01 d8                	add    %ebx,%eax
    9d94:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d97:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9d9b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d9e:	89 c1                	mov    %eax,%ecx
    9da0:	d3 fa                	sar    %cl,%edx
    9da2:	89 d0                	mov    %edx,%eax
    9da4:	83 e0 01             	and    $0x1,%eax
    9da7:	01 d8                	add    %ebx,%eax
    9da9:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9dac:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9db0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9db3:	89 c1                	mov    %eax,%ecx
    9db5:	d3 fa                	sar    %cl,%edx
    9db7:	89 d0                	mov    %edx,%eax
    9db9:	83 e0 01             	and    $0x1,%eax
    9dbc:	01 d8                	add    %ebx,%eax
    9dbe:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    9dc1:	8b 45 08             	mov    0x8(%ebp),%eax
    9dc4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9dc7:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9dca:	85 c0                	test   %eax,%eax
    9dcc:	75 07                	jne    9dd5 <color_tree_get+0x95>
    9dce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9dd3:	eb 2a                	jmp    9dff <color_tree_get+0xbf>
    else tree = tree->children[i];
    9dd5:	8b 45 08             	mov    0x8(%ebp),%eax
    9dd8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9ddb:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9dde:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    9de1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    9de5:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    9de9:	7e 84                	jle    9d6f <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    9deb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    9def:	74 08                	je     9df9 <color_tree_get+0xb9>
    9df1:	8b 45 08             	mov    0x8(%ebp),%eax
    9df4:	8b 40 40             	mov    0x40(%eax),%eax
    9df7:	eb 05                	jmp    9dfe <color_tree_get+0xbe>
    9df9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9dfe:	90                   	nop
}
    9dff:	83 c4 20             	add    $0x20,%esp
    9e02:	5b                   	pop    %ebx
    9e03:	5d                   	pop    %ebp
    9e04:	c3                   	ret    

00009e05 <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9e05:	55                   	push   %ebp
    9e06:	89 e5                	mov    %esp,%ebp
    9e08:	53                   	push   %ebx
    9e09:	83 ec 10             	sub    $0x10,%esp
    9e0c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9e0f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9e12:	8b 55 14             	mov    0x14(%ebp),%edx
    9e15:	8b 45 18             	mov    0x18(%ebp),%eax
    9e18:	88 5d f8             	mov    %bl,-0x8(%ebp)
    9e1b:	88 4d f4             	mov    %cl,-0xc(%ebp)
    9e1e:	88 55 f0             	mov    %dl,-0x10(%ebp)
    9e21:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    9e24:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    9e28:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    9e2c:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    9e30:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    9e34:	53                   	push   %ebx
    9e35:	51                   	push   %ecx
    9e36:	52                   	push   %edx
    9e37:	50                   	push   %eax
    9e38:	ff 75 08             	pushl  0x8(%ebp)
    9e3b:	e8 00 ff ff ff       	call   9d40 <color_tree_get>
    9e40:	83 c4 14             	add    $0x14,%esp
    9e43:	f7 d0                	not    %eax
    9e45:	c1 e8 1f             	shr    $0x1f,%eax
    9e48:	0f b6 c0             	movzbl %al,%eax
}
    9e4b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9e4e:	c9                   	leave  
    9e4f:	c3                   	ret    

00009e50 <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    9e50:	55                   	push   %ebp
    9e51:	89 e5                	mov    %esp,%ebp
    9e53:	53                   	push   %ebx
    9e54:	83 ec 24             	sub    $0x24,%esp
    9e57:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9e5a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9e5d:	8b 55 14             	mov    0x14(%ebp),%edx
    9e60:	8b 45 18             	mov    0x18(%ebp),%eax
    9e63:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    9e66:	88 4d e0             	mov    %cl,-0x20(%ebp)
    9e69:	88 55 dc             	mov    %dl,-0x24(%ebp)
    9e6c:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9e6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9e76:	e9 b0 00 00 00       	jmp    9f2b <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9e7b:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9e7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e82:	89 c1                	mov    %eax,%ecx
    9e84:	d3 fa                	sar    %cl,%edx
    9e86:	89 d0                	mov    %edx,%eax
    9e88:	83 e0 01             	and    $0x1,%eax
    9e8b:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e8e:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9e92:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e95:	89 c1                	mov    %eax,%ecx
    9e97:	d3 fa                	sar    %cl,%edx
    9e99:	89 d0                	mov    %edx,%eax
    9e9b:	83 e0 01             	and    $0x1,%eax
    9e9e:	01 d8                	add    %ebx,%eax
    9ea0:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9ea3:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9ea7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9eaa:	89 c1                	mov    %eax,%ecx
    9eac:	d3 fa                	sar    %cl,%edx
    9eae:	89 d0                	mov    %edx,%eax
    9eb0:	83 e0 01             	and    $0x1,%eax
    9eb3:	01 d8                	add    %ebx,%eax
    9eb5:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9eb8:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    9ebc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9ebf:	89 c1                	mov    %eax,%ecx
    9ec1:	d3 fa                	sar    %cl,%edx
    9ec3:	89 d0                	mov    %edx,%eax
    9ec5:	83 e0 01             	and    $0x1,%eax
    9ec8:	01 d8                	add    %ebx,%eax
    9eca:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    9ecd:	8b 45 08             	mov    0x8(%ebp),%eax
    9ed0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ed3:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9ed6:	85 c0                	test   %eax,%eax
    9ed8:	75 41                	jne    9f1b <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    9eda:	83 ec 0c             	sub    $0xc,%esp
    9edd:	6a 44                	push   $0x44
    9edf:	e8 5d 94 ff ff       	call   3341 <lodepng_malloc>
    9ee4:	83 c4 10             	add    $0x10,%esp
    9ee7:	89 c1                	mov    %eax,%ecx
    9ee9:	8b 45 08             	mov    0x8(%ebp),%eax
    9eec:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9eef:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    9ef2:	8b 45 08             	mov    0x8(%ebp),%eax
    9ef5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ef8:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9efb:	85 c0                	test   %eax,%eax
    9efd:	75 07                	jne    9f06 <color_tree_add+0xb6>
    9eff:	b8 53 00 00 00       	mov    $0x53,%eax
    9f04:	eb 3d                	jmp    9f43 <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    9f06:	8b 45 08             	mov    0x8(%ebp),%eax
    9f09:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f0c:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9f0f:	83 ec 0c             	sub    $0xc,%esp
    9f12:	50                   	push   %eax
    9f13:	e8 b5 fd ff ff       	call   9ccd <color_tree_init>
    9f18:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    9f1b:	8b 45 08             	mov    0x8(%ebp),%eax
    9f1e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f21:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9f24:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9f27:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9f2b:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    9f2f:	0f 8e 46 ff ff ff    	jle    9e7b <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    9f35:	8b 55 1c             	mov    0x1c(%ebp),%edx
    9f38:	8b 45 08             	mov    0x8(%ebp),%eax
    9f3b:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    9f3e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9f43:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9f46:	c9                   	leave  
    9f47:	c3                   	ret    

00009f48 <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9f48:	55                   	push   %ebp
    9f49:	89 e5                	mov    %esp,%ebp
    9f4b:	53                   	push   %ebx
    9f4c:	83 ec 20             	sub    $0x20,%esp
    9f4f:	8b 5d 18             	mov    0x18(%ebp),%ebx
    9f52:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    9f55:	8b 55 20             	mov    0x20(%ebp),%edx
    9f58:	8b 45 24             	mov    0x24(%ebp),%eax
    9f5b:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9f5e:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9f61:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9f64:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    9f67:	8b 45 10             	mov    0x10(%ebp),%eax
    9f6a:	8b 00                	mov    (%eax),%eax
    9f6c:	85 c0                	test   %eax,%eax
    9f6e:	0f 85 ad 00 00 00    	jne    a021 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    9f74:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    9f78:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    9f7b:	8b 45 10             	mov    0x10(%ebp),%eax
    9f7e:	8b 40 04             	mov    0x4(%eax),%eax
    9f81:	83 f8 08             	cmp    $0x8,%eax
    9f84:	75 13                	jne    9f99 <rgba8ToPixel+0x51>
    9f86:	8b 55 0c             	mov    0xc(%ebp),%edx
    9f89:	8b 45 08             	mov    0x8(%ebp),%eax
    9f8c:	01 c2                	add    %eax,%edx
    9f8e:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    9f92:	88 02                	mov    %al,(%edx)
    9f94:	e9 b4 03 00 00       	jmp    a34d <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    9f99:	8b 45 10             	mov    0x10(%ebp),%eax
    9f9c:	8b 40 04             	mov    0x4(%eax),%eax
    9f9f:	83 f8 10             	cmp    $0x10,%eax
    9fa2:	75 2a                	jne    9fce <rgba8ToPixel+0x86>
    9fa4:	8b 45 0c             	mov    0xc(%ebp),%eax
    9fa7:	01 c0                	add    %eax,%eax
    9fa9:	89 c2                	mov    %eax,%edx
    9fab:	8b 45 08             	mov    0x8(%ebp),%eax
    9fae:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    9fb1:	8b 45 0c             	mov    0xc(%ebp),%eax
    9fb4:	01 c0                	add    %eax,%eax
    9fb6:	8d 50 01             	lea    0x1(%eax),%edx
    9fb9:	8b 45 08             	mov    0x8(%ebp),%eax
    9fbc:	01 d0                	add    %edx,%eax
    9fbe:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9fc2:	88 10                	mov    %dl,(%eax)
    9fc4:	0f b6 00             	movzbl (%eax),%eax
    9fc7:	88 01                	mov    %al,(%ecx)
    9fc9:	e9 7f 03 00 00       	jmp    a34d <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    9fce:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9fd2:	8b 45 10             	mov    0x10(%ebp),%eax
    9fd5:	8b 40 04             	mov    0x4(%eax),%eax
    9fd8:	b9 08 00 00 00       	mov    $0x8,%ecx
    9fdd:	29 c1                	sub    %eax,%ecx
    9fdf:	89 c8                	mov    %ecx,%eax
    9fe1:	89 c1                	mov    %eax,%ecx
    9fe3:	d3 ea                	shr    %cl,%edx
    9fe5:	89 d0                	mov    %edx,%eax
    9fe7:	89 c2                	mov    %eax,%edx
    9fe9:	8b 45 10             	mov    0x10(%ebp),%eax
    9fec:	8b 40 04             	mov    0x4(%eax),%eax
    9fef:	bb 01 00 00 00       	mov    $0x1,%ebx
    9ff4:	89 c1                	mov    %eax,%ecx
    9ff6:	d3 e3                	shl    %cl,%ebx
    9ff8:	89 d8                	mov    %ebx,%eax
    9ffa:	83 e8 01             	sub    $0x1,%eax
    9ffd:	21 d0                	and    %edx,%eax
    9fff:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    a002:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a006:	8b 45 10             	mov    0x10(%ebp),%eax
    a009:	8b 40 04             	mov    0x4(%eax),%eax
    a00c:	52                   	push   %edx
    a00d:	50                   	push   %eax
    a00e:	ff 75 0c             	pushl  0xc(%ebp)
    a011:	ff 75 08             	pushl  0x8(%ebp)
    a014:	e8 21 fc ff ff       	call   9c3a <addColorBits>
    a019:	83 c4 10             	add    $0x10,%esp
    a01c:	e9 2c 03 00 00       	jmp    a34d <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    a021:	8b 45 10             	mov    0x10(%ebp),%eax
    a024:	8b 00                	mov    (%eax),%eax
    a026:	83 f8 02             	cmp    $0x2,%eax
    a029:	0f 85 ee 00 00 00    	jne    a11d <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    a02f:	8b 45 10             	mov    0x10(%ebp),%eax
    a032:	8b 40 04             	mov    0x4(%eax),%eax
    a035:	83 f8 08             	cmp    $0x8,%eax
    a038:	75 49                	jne    a083 <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    a03a:	8b 55 0c             	mov    0xc(%ebp),%edx
    a03d:	89 d0                	mov    %edx,%eax
    a03f:	01 c0                	add    %eax,%eax
    a041:	01 d0                	add    %edx,%eax
    a043:	89 c2                	mov    %eax,%edx
    a045:	8b 45 08             	mov    0x8(%ebp),%eax
    a048:	01 c2                	add    %eax,%edx
    a04a:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a04e:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    a050:	8b 55 0c             	mov    0xc(%ebp),%edx
    a053:	89 d0                	mov    %edx,%eax
    a055:	01 c0                	add    %eax,%eax
    a057:	01 d0                	add    %edx,%eax
    a059:	8d 50 01             	lea    0x1(%eax),%edx
    a05c:	8b 45 08             	mov    0x8(%ebp),%eax
    a05f:	01 c2                	add    %eax,%edx
    a061:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a065:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a067:	8b 55 0c             	mov    0xc(%ebp),%edx
    a06a:	89 d0                	mov    %edx,%eax
    a06c:	01 c0                	add    %eax,%eax
    a06e:	01 d0                	add    %edx,%eax
    a070:	8d 50 02             	lea    0x2(%eax),%edx
    a073:	8b 45 08             	mov    0x8(%ebp),%eax
    a076:	01 c2                	add    %eax,%edx
    a078:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a07c:	88 02                	mov    %al,(%edx)
    a07e:	e9 ca 02 00 00       	jmp    a34d <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a083:	8b 55 0c             	mov    0xc(%ebp),%edx
    a086:	89 d0                	mov    %edx,%eax
    a088:	01 c0                	add    %eax,%eax
    a08a:	01 d0                	add    %edx,%eax
    a08c:	01 c0                	add    %eax,%eax
    a08e:	89 c2                	mov    %eax,%edx
    a090:	8b 45 08             	mov    0x8(%ebp),%eax
    a093:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a096:	8b 55 0c             	mov    0xc(%ebp),%edx
    a099:	89 d0                	mov    %edx,%eax
    a09b:	01 c0                	add    %eax,%eax
    a09d:	01 d0                	add    %edx,%eax
    a09f:	01 c0                	add    %eax,%eax
    a0a1:	8d 50 01             	lea    0x1(%eax),%edx
    a0a4:	8b 45 08             	mov    0x8(%ebp),%eax
    a0a7:	01 d0                	add    %edx,%eax
    a0a9:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a0ad:	88 10                	mov    %dl,(%eax)
    a0af:	0f b6 00             	movzbl (%eax),%eax
    a0b2:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a0b4:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0b7:	89 d0                	mov    %edx,%eax
    a0b9:	01 c0                	add    %eax,%eax
    a0bb:	01 d0                	add    %edx,%eax
    a0bd:	01 c0                	add    %eax,%eax
    a0bf:	8d 50 02             	lea    0x2(%eax),%edx
    a0c2:	8b 45 08             	mov    0x8(%ebp),%eax
    a0c5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a0c8:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0cb:	89 d0                	mov    %edx,%eax
    a0cd:	01 c0                	add    %eax,%eax
    a0cf:	01 d0                	add    %edx,%eax
    a0d1:	01 c0                	add    %eax,%eax
    a0d3:	8d 50 03             	lea    0x3(%eax),%edx
    a0d6:	8b 45 08             	mov    0x8(%ebp),%eax
    a0d9:	01 d0                	add    %edx,%eax
    a0db:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a0df:	88 10                	mov    %dl,(%eax)
    a0e1:	0f b6 00             	movzbl (%eax),%eax
    a0e4:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a0e6:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0e9:	89 d0                	mov    %edx,%eax
    a0eb:	01 c0                	add    %eax,%eax
    a0ed:	01 d0                	add    %edx,%eax
    a0ef:	01 c0                	add    %eax,%eax
    a0f1:	8d 50 04             	lea    0x4(%eax),%edx
    a0f4:	8b 45 08             	mov    0x8(%ebp),%eax
    a0f7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a0fa:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0fd:	89 d0                	mov    %edx,%eax
    a0ff:	01 c0                	add    %eax,%eax
    a101:	01 d0                	add    %edx,%eax
    a103:	01 c0                	add    %eax,%eax
    a105:	8d 50 05             	lea    0x5(%eax),%edx
    a108:	8b 45 08             	mov    0x8(%ebp),%eax
    a10b:	01 d0                	add    %edx,%eax
    a10d:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a111:	88 10                	mov    %dl,(%eax)
    a113:	0f b6 00             	movzbl (%eax),%eax
    a116:	88 01                	mov    %al,(%ecx)
    a118:	e9 30 02 00 00       	jmp    a34d <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a11d:	8b 45 10             	mov    0x10(%ebp),%eax
    a120:	8b 00                	mov    (%eax),%eax
    a122:	83 f8 03             	cmp    $0x3,%eax
    a125:	75 6d                	jne    a194 <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a127:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a12b:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a12f:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a133:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a137:	53                   	push   %ebx
    a138:	51                   	push   %ecx
    a139:	52                   	push   %edx
    a13a:	50                   	push   %eax
    a13b:	ff 75 14             	pushl  0x14(%ebp)
    a13e:	e8 fd fb ff ff       	call   9d40 <color_tree_get>
    a143:	83 c4 14             	add    $0x14,%esp
    a146:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a149:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a14d:	79 0a                	jns    a159 <rgba8ToPixel+0x211>
    a14f:	b8 52 00 00 00       	mov    $0x52,%eax
    a154:	e9 f9 01 00 00       	jmp    a352 <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a159:	8b 45 10             	mov    0x10(%ebp),%eax
    a15c:	8b 40 04             	mov    0x4(%eax),%eax
    a15f:	83 f8 08             	cmp    $0x8,%eax
    a162:	75 12                	jne    a176 <rgba8ToPixel+0x22e>
    a164:	8b 55 0c             	mov    0xc(%ebp),%edx
    a167:	8b 45 08             	mov    0x8(%ebp),%eax
    a16a:	01 d0                	add    %edx,%eax
    a16c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a16f:	88 10                	mov    %dl,(%eax)
    a171:	e9 d7 01 00 00       	jmp    a34d <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a176:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a179:	8b 45 10             	mov    0x10(%ebp),%eax
    a17c:	8b 40 04             	mov    0x4(%eax),%eax
    a17f:	52                   	push   %edx
    a180:	50                   	push   %eax
    a181:	ff 75 0c             	pushl  0xc(%ebp)
    a184:	ff 75 08             	pushl  0x8(%ebp)
    a187:	e8 ae fa ff ff       	call   9c3a <addColorBits>
    a18c:	83 c4 10             	add    $0x10,%esp
    a18f:	e9 b9 01 00 00       	jmp    a34d <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a194:	8b 45 10             	mov    0x10(%ebp),%eax
    a197:	8b 00                	mov    (%eax),%eax
    a199:	83 f8 04             	cmp    $0x4,%eax
    a19c:	0f 85 9f 00 00 00    	jne    a241 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a1a2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a1a6:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a1a9:	8b 45 10             	mov    0x10(%ebp),%eax
    a1ac:	8b 40 04             	mov    0x4(%eax),%eax
    a1af:	83 f8 08             	cmp    $0x8,%eax
    a1b2:	75 2a                	jne    a1de <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a1b4:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1b7:	01 c0                	add    %eax,%eax
    a1b9:	89 c2                	mov    %eax,%edx
    a1bb:	8b 45 08             	mov    0x8(%ebp),%eax
    a1be:	01 c2                	add    %eax,%edx
    a1c0:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a1c4:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a1c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1c9:	01 c0                	add    %eax,%eax
    a1cb:	8d 50 01             	lea    0x1(%eax),%edx
    a1ce:	8b 45 08             	mov    0x8(%ebp),%eax
    a1d1:	01 c2                	add    %eax,%edx
    a1d3:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a1d7:	88 02                	mov    %al,(%edx)
    a1d9:	e9 6f 01 00 00       	jmp    a34d <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a1de:	8b 45 10             	mov    0x10(%ebp),%eax
    a1e1:	8b 40 04             	mov    0x4(%eax),%eax
    a1e4:	83 f8 10             	cmp    $0x10,%eax
    a1e7:	0f 85 60 01 00 00    	jne    a34d <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a1ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1f0:	c1 e0 02             	shl    $0x2,%eax
    a1f3:	89 c2                	mov    %eax,%edx
    a1f5:	8b 45 08             	mov    0x8(%ebp),%eax
    a1f8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a1fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1fe:	c1 e0 02             	shl    $0x2,%eax
    a201:	8d 50 01             	lea    0x1(%eax),%edx
    a204:	8b 45 08             	mov    0x8(%ebp),%eax
    a207:	01 d0                	add    %edx,%eax
    a209:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a20d:	88 10                	mov    %dl,(%eax)
    a20f:	0f b6 00             	movzbl (%eax),%eax
    a212:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a214:	8b 45 0c             	mov    0xc(%ebp),%eax
    a217:	c1 e0 02             	shl    $0x2,%eax
    a21a:	8d 50 02             	lea    0x2(%eax),%edx
    a21d:	8b 45 08             	mov    0x8(%ebp),%eax
    a220:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a223:	8b 45 0c             	mov    0xc(%ebp),%eax
    a226:	c1 e0 02             	shl    $0x2,%eax
    a229:	8d 50 03             	lea    0x3(%eax),%edx
    a22c:	8b 45 08             	mov    0x8(%ebp),%eax
    a22f:	01 d0                	add    %edx,%eax
    a231:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a235:	88 10                	mov    %dl,(%eax)
    a237:	0f b6 00             	movzbl (%eax),%eax
    a23a:	88 01                	mov    %al,(%ecx)
    a23c:	e9 0c 01 00 00       	jmp    a34d <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a241:	8b 45 10             	mov    0x10(%ebp),%eax
    a244:	8b 00                	mov    (%eax),%eax
    a246:	83 f8 06             	cmp    $0x6,%eax
    a249:	0f 85 fe 00 00 00    	jne    a34d <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a24f:	8b 45 10             	mov    0x10(%ebp),%eax
    a252:	8b 40 04             	mov    0x4(%eax),%eax
    a255:	83 f8 08             	cmp    $0x8,%eax
    a258:	75 54                	jne    a2ae <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a25a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a25d:	c1 e0 02             	shl    $0x2,%eax
    a260:	89 c2                	mov    %eax,%edx
    a262:	8b 45 08             	mov    0x8(%ebp),%eax
    a265:	01 c2                	add    %eax,%edx
    a267:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a26b:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a26d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a270:	c1 e0 02             	shl    $0x2,%eax
    a273:	8d 50 01             	lea    0x1(%eax),%edx
    a276:	8b 45 08             	mov    0x8(%ebp),%eax
    a279:	01 c2                	add    %eax,%edx
    a27b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a27f:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a281:	8b 45 0c             	mov    0xc(%ebp),%eax
    a284:	c1 e0 02             	shl    $0x2,%eax
    a287:	8d 50 02             	lea    0x2(%eax),%edx
    a28a:	8b 45 08             	mov    0x8(%ebp),%eax
    a28d:	01 c2                	add    %eax,%edx
    a28f:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a293:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a295:	8b 45 0c             	mov    0xc(%ebp),%eax
    a298:	c1 e0 02             	shl    $0x2,%eax
    a29b:	8d 50 03             	lea    0x3(%eax),%edx
    a29e:	8b 45 08             	mov    0x8(%ebp),%eax
    a2a1:	01 c2                	add    %eax,%edx
    a2a3:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a2a7:	88 02                	mov    %al,(%edx)
    a2a9:	e9 9f 00 00 00       	jmp    a34d <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a2ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2b1:	c1 e0 03             	shl    $0x3,%eax
    a2b4:	89 c2                	mov    %eax,%edx
    a2b6:	8b 45 08             	mov    0x8(%ebp),%eax
    a2b9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2bf:	c1 e0 03             	shl    $0x3,%eax
    a2c2:	8d 50 01             	lea    0x1(%eax),%edx
    a2c5:	8b 45 08             	mov    0x8(%ebp),%eax
    a2c8:	01 d0                	add    %edx,%eax
    a2ca:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a2ce:	88 10                	mov    %dl,(%eax)
    a2d0:	0f b6 00             	movzbl (%eax),%eax
    a2d3:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a2d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2d8:	c1 e0 03             	shl    $0x3,%eax
    a2db:	8d 50 02             	lea    0x2(%eax),%edx
    a2de:	8b 45 08             	mov    0x8(%ebp),%eax
    a2e1:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2e7:	c1 e0 03             	shl    $0x3,%eax
    a2ea:	8d 50 03             	lea    0x3(%eax),%edx
    a2ed:	8b 45 08             	mov    0x8(%ebp),%eax
    a2f0:	01 d0                	add    %edx,%eax
    a2f2:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a2f6:	88 10                	mov    %dl,(%eax)
    a2f8:	0f b6 00             	movzbl (%eax),%eax
    a2fb:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a2fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    a300:	c1 e0 03             	shl    $0x3,%eax
    a303:	8d 50 04             	lea    0x4(%eax),%edx
    a306:	8b 45 08             	mov    0x8(%ebp),%eax
    a309:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a30c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a30f:	c1 e0 03             	shl    $0x3,%eax
    a312:	8d 50 05             	lea    0x5(%eax),%edx
    a315:	8b 45 08             	mov    0x8(%ebp),%eax
    a318:	01 d0                	add    %edx,%eax
    a31a:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a31e:	88 10                	mov    %dl,(%eax)
    a320:	0f b6 00             	movzbl (%eax),%eax
    a323:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    a325:	8b 45 0c             	mov    0xc(%ebp),%eax
    a328:	c1 e0 03             	shl    $0x3,%eax
    a32b:	8d 50 06             	lea    0x6(%eax),%edx
    a32e:	8b 45 08             	mov    0x8(%ebp),%eax
    a331:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a334:	8b 45 0c             	mov    0xc(%ebp),%eax
    a337:	c1 e0 03             	shl    $0x3,%eax
    a33a:	8d 50 07             	lea    0x7(%eax),%edx
    a33d:	8b 45 08             	mov    0x8(%ebp),%eax
    a340:	01 d0                	add    %edx,%eax
    a342:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a346:	88 10                	mov    %dl,(%eax)
    a348:	0f b6 00             	movzbl (%eax),%eax
    a34b:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    a34d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a352:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a355:	c9                   	leave  
    a356:	c3                   	ret    

0000a357 <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    a357:	55                   	push   %ebp
    a358:	89 e5                	mov    %esp,%ebp
    a35a:	53                   	push   %ebx
    a35b:	83 ec 20             	sub    $0x20,%esp
    a35e:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a361:	8b 4d 18             	mov    0x18(%ebp),%ecx
    a364:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a367:	8b 45 20             	mov    0x20(%ebp),%eax
    a36a:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    a36e:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    a372:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    a376:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a37a:	8b 45 10             	mov    0x10(%ebp),%eax
    a37d:	8b 00                	mov    (%eax),%eax
    a37f:	85 c0                	test   %eax,%eax
    a381:	75 36                	jne    a3b9 <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a383:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a387:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    a38b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a38e:	01 c0                	add    %eax,%eax
    a390:	89 c2                	mov    %eax,%edx
    a392:	8b 45 08             	mov    0x8(%ebp),%eax
    a395:	01 d0                	add    %edx,%eax
    a397:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a39b:	66 c1 ea 08          	shr    $0x8,%dx
    a39f:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    a3a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3a4:	01 c0                	add    %eax,%eax
    a3a6:	8d 50 01             	lea    0x1(%eax),%edx
    a3a9:	8b 45 08             	mov    0x8(%ebp),%eax
    a3ac:	01 d0                	add    %edx,%eax
    a3ae:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a3b2:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a3b4:	e9 df 01 00 00       	jmp    a598 <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    a3b9:	8b 45 10             	mov    0x10(%ebp),%eax
    a3bc:	8b 00                	mov    (%eax),%eax
    a3be:	83 f8 02             	cmp    $0x2,%eax
    a3c1:	0f 85 a6 00 00 00    	jne    a46d <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    a3c7:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3ca:	89 d0                	mov    %edx,%eax
    a3cc:	01 c0                	add    %eax,%eax
    a3ce:	01 d0                	add    %edx,%eax
    a3d0:	01 c0                	add    %eax,%eax
    a3d2:	89 c2                	mov    %eax,%edx
    a3d4:	8b 45 08             	mov    0x8(%ebp),%eax
    a3d7:	01 d0                	add    %edx,%eax
    a3d9:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a3dd:	66 c1 ea 08          	shr    $0x8,%dx
    a3e1:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    a3e3:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3e6:	89 d0                	mov    %edx,%eax
    a3e8:	01 c0                	add    %eax,%eax
    a3ea:	01 d0                	add    %edx,%eax
    a3ec:	01 c0                	add    %eax,%eax
    a3ee:	8d 50 01             	lea    0x1(%eax),%edx
    a3f1:	8b 45 08             	mov    0x8(%ebp),%eax
    a3f4:	01 d0                	add    %edx,%eax
    a3f6:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a3fa:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    a3fc:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3ff:	89 d0                	mov    %edx,%eax
    a401:	01 c0                	add    %eax,%eax
    a403:	01 d0                	add    %edx,%eax
    a405:	01 c0                	add    %eax,%eax
    a407:	8d 50 02             	lea    0x2(%eax),%edx
    a40a:	8b 45 08             	mov    0x8(%ebp),%eax
    a40d:	01 d0                	add    %edx,%eax
    a40f:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a413:	66 c1 ea 08          	shr    $0x8,%dx
    a417:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    a419:	8b 55 0c             	mov    0xc(%ebp),%edx
    a41c:	89 d0                	mov    %edx,%eax
    a41e:	01 c0                	add    %eax,%eax
    a420:	01 d0                	add    %edx,%eax
    a422:	01 c0                	add    %eax,%eax
    a424:	8d 50 03             	lea    0x3(%eax),%edx
    a427:	8b 45 08             	mov    0x8(%ebp),%eax
    a42a:	01 d0                	add    %edx,%eax
    a42c:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a430:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    a432:	8b 55 0c             	mov    0xc(%ebp),%edx
    a435:	89 d0                	mov    %edx,%eax
    a437:	01 c0                	add    %eax,%eax
    a439:	01 d0                	add    %edx,%eax
    a43b:	01 c0                	add    %eax,%eax
    a43d:	8d 50 04             	lea    0x4(%eax),%edx
    a440:	8b 45 08             	mov    0x8(%ebp),%eax
    a443:	01 d0                	add    %edx,%eax
    a445:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a449:	66 c1 ea 08          	shr    $0x8,%dx
    a44d:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    a44f:	8b 55 0c             	mov    0xc(%ebp),%edx
    a452:	89 d0                	mov    %edx,%eax
    a454:	01 c0                	add    %eax,%eax
    a456:	01 d0                	add    %edx,%eax
    a458:	01 c0                	add    %eax,%eax
    a45a:	8d 50 05             	lea    0x5(%eax),%edx
    a45d:	8b 45 08             	mov    0x8(%ebp),%eax
    a460:	01 d0                	add    %edx,%eax
    a462:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a466:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a468:	e9 2b 01 00 00       	jmp    a598 <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a46d:	8b 45 10             	mov    0x10(%ebp),%eax
    a470:	8b 00                	mov    (%eax),%eax
    a472:	83 f8 04             	cmp    $0x4,%eax
    a475:	75 64                	jne    a4db <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a477:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a47b:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    a47f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a482:	c1 e0 02             	shl    $0x2,%eax
    a485:	89 c2                	mov    %eax,%edx
    a487:	8b 45 08             	mov    0x8(%ebp),%eax
    a48a:	01 d0                	add    %edx,%eax
    a48c:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a490:	66 c1 ea 08          	shr    $0x8,%dx
    a494:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    a496:	8b 45 0c             	mov    0xc(%ebp),%eax
    a499:	c1 e0 02             	shl    $0x2,%eax
    a49c:	8d 50 01             	lea    0x1(%eax),%edx
    a49f:	8b 45 08             	mov    0x8(%ebp),%eax
    a4a2:	01 d0                	add    %edx,%eax
    a4a4:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a4a8:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    a4aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4ad:	c1 e0 02             	shl    $0x2,%eax
    a4b0:	8d 50 02             	lea    0x2(%eax),%edx
    a4b3:	8b 45 08             	mov    0x8(%ebp),%eax
    a4b6:	01 d0                	add    %edx,%eax
    a4b8:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a4bc:	66 c1 ea 08          	shr    $0x8,%dx
    a4c0:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    a4c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4c5:	c1 e0 02             	shl    $0x2,%eax
    a4c8:	8d 50 03             	lea    0x3(%eax),%edx
    a4cb:	8b 45 08             	mov    0x8(%ebp),%eax
    a4ce:	01 d0                	add    %edx,%eax
    a4d0:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a4d4:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a4d6:	e9 bd 00 00 00       	jmp    a598 <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    a4db:	8b 45 10             	mov    0x10(%ebp),%eax
    a4de:	8b 00                	mov    (%eax),%eax
    a4e0:	83 f8 06             	cmp    $0x6,%eax
    a4e3:	0f 85 af 00 00 00    	jne    a598 <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    a4e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4ec:	c1 e0 03             	shl    $0x3,%eax
    a4ef:	89 c2                	mov    %eax,%edx
    a4f1:	8b 45 08             	mov    0x8(%ebp),%eax
    a4f4:	01 d0                	add    %edx,%eax
    a4f6:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a4fa:	66 c1 ea 08          	shr    $0x8,%dx
    a4fe:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    a500:	8b 45 0c             	mov    0xc(%ebp),%eax
    a503:	c1 e0 03             	shl    $0x3,%eax
    a506:	8d 50 01             	lea    0x1(%eax),%edx
    a509:	8b 45 08             	mov    0x8(%ebp),%eax
    a50c:	01 d0                	add    %edx,%eax
    a50e:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a512:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    a514:	8b 45 0c             	mov    0xc(%ebp),%eax
    a517:	c1 e0 03             	shl    $0x3,%eax
    a51a:	8d 50 02             	lea    0x2(%eax),%edx
    a51d:	8b 45 08             	mov    0x8(%ebp),%eax
    a520:	01 d0                	add    %edx,%eax
    a522:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a526:	66 c1 ea 08          	shr    $0x8,%dx
    a52a:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    a52c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a52f:	c1 e0 03             	shl    $0x3,%eax
    a532:	8d 50 03             	lea    0x3(%eax),%edx
    a535:	8b 45 08             	mov    0x8(%ebp),%eax
    a538:	01 d0                	add    %edx,%eax
    a53a:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a53e:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    a540:	8b 45 0c             	mov    0xc(%ebp),%eax
    a543:	c1 e0 03             	shl    $0x3,%eax
    a546:	8d 50 04             	lea    0x4(%eax),%edx
    a549:	8b 45 08             	mov    0x8(%ebp),%eax
    a54c:	01 d0                	add    %edx,%eax
    a54e:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a552:	66 c1 ea 08          	shr    $0x8,%dx
    a556:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    a558:	8b 45 0c             	mov    0xc(%ebp),%eax
    a55b:	c1 e0 03             	shl    $0x3,%eax
    a55e:	8d 50 05             	lea    0x5(%eax),%edx
    a561:	8b 45 08             	mov    0x8(%ebp),%eax
    a564:	01 d0                	add    %edx,%eax
    a566:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a56a:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    a56c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a56f:	c1 e0 03             	shl    $0x3,%eax
    a572:	8d 50 06             	lea    0x6(%eax),%edx
    a575:	8b 45 08             	mov    0x8(%ebp),%eax
    a578:	01 d0                	add    %edx,%eax
    a57a:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a57e:	66 c1 ea 08          	shr    $0x8,%dx
    a582:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    a584:	8b 45 0c             	mov    0xc(%ebp),%eax
    a587:	c1 e0 03             	shl    $0x3,%eax
    a58a:	8d 50 07             	lea    0x7(%eax),%edx
    a58d:	8b 45 08             	mov    0x8(%ebp),%eax
    a590:	01 d0                	add    %edx,%eax
    a592:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a596:	88 10                	mov    %dl,(%eax)
  }
}
    a598:	90                   	nop
    a599:	83 c4 20             	add    $0x20,%esp
    a59c:	5b                   	pop    %ebx
    a59d:	5d                   	pop    %ebp
    a59e:	c3                   	ret    

0000a59f <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    a59f:	55                   	push   %ebp
    a5a0:	89 e5                	mov    %esp,%ebp
    a5a2:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    a5a5:	8b 45 20             	mov    0x20(%ebp),%eax
    a5a8:	8b 00                	mov    (%eax),%eax
    a5aa:	85 c0                	test   %eax,%eax
    a5ac:	0f 85 8c 01 00 00    	jne    a73e <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    a5b2:	8b 45 20             	mov    0x20(%ebp),%eax
    a5b5:	8b 40 04             	mov    0x4(%eax),%eax
    a5b8:	83 f8 08             	cmp    $0x8,%eax
    a5bb:	75 59                	jne    a616 <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    a5bd:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a5c0:	8b 45 18             	mov    0x18(%ebp),%eax
    a5c3:	01 d0                	add    %edx,%eax
    a5c5:	0f b6 10             	movzbl (%eax),%edx
    a5c8:	8b 45 10             	mov    0x10(%ebp),%eax
    a5cb:	88 10                	mov    %dl,(%eax)
    a5cd:	8b 45 10             	mov    0x10(%ebp),%eax
    a5d0:	0f b6 10             	movzbl (%eax),%edx
    a5d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5d6:	88 10                	mov    %dl,(%eax)
    a5d8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5db:	0f b6 10             	movzbl (%eax),%edx
    a5de:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e1:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    a5e3:	8b 45 20             	mov    0x20(%ebp),%eax
    a5e6:	8b 40 10             	mov    0x10(%eax),%eax
    a5e9:	85 c0                	test   %eax,%eax
    a5eb:	74 1e                	je     a60b <getPixelColorRGBA8+0x6c>
    a5ed:	8b 45 08             	mov    0x8(%ebp),%eax
    a5f0:	0f b6 00             	movzbl (%eax),%eax
    a5f3:	0f b6 d0             	movzbl %al,%edx
    a5f6:	8b 45 20             	mov    0x20(%ebp),%eax
    a5f9:	8b 40 14             	mov    0x14(%eax),%eax
    a5fc:	39 c2                	cmp    %eax,%edx
    a5fe:	75 0b                	jne    a60b <getPixelColorRGBA8+0x6c>
    a600:	8b 45 14             	mov    0x14(%ebp),%eax
    a603:	c6 00 00             	movb   $0x0,(%eax)
    a606:	e9 5e 05 00 00       	jmp    ab69 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a60b:	8b 45 14             	mov    0x14(%ebp),%eax
    a60e:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a611:	e9 53 05 00 00       	jmp    ab69 <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    a616:	8b 45 20             	mov    0x20(%ebp),%eax
    a619:	8b 40 04             	mov    0x4(%eax),%eax
    a61c:	83 f8 10             	cmp    $0x10,%eax
    a61f:	0f 85 80 00 00 00    	jne    a6a5 <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    a625:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a628:	01 c0                	add    %eax,%eax
    a62a:	89 c2                	mov    %eax,%edx
    a62c:	8b 45 18             	mov    0x18(%ebp),%eax
    a62f:	01 d0                	add    %edx,%eax
    a631:	0f b6 10             	movzbl (%eax),%edx
    a634:	8b 45 10             	mov    0x10(%ebp),%eax
    a637:	88 10                	mov    %dl,(%eax)
    a639:	8b 45 10             	mov    0x10(%ebp),%eax
    a63c:	0f b6 10             	movzbl (%eax),%edx
    a63f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a642:	88 10                	mov    %dl,(%eax)
    a644:	8b 45 0c             	mov    0xc(%ebp),%eax
    a647:	0f b6 10             	movzbl (%eax),%edx
    a64a:	8b 45 08             	mov    0x8(%ebp),%eax
    a64d:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    a64f:	8b 45 20             	mov    0x20(%ebp),%eax
    a652:	8b 40 10             	mov    0x10(%eax),%eax
    a655:	85 c0                	test   %eax,%eax
    a657:	74 41                	je     a69a <getPixelColorRGBA8+0xfb>
    a659:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a65c:	01 c0                	add    %eax,%eax
    a65e:	89 c2                	mov    %eax,%edx
    a660:	8b 45 18             	mov    0x18(%ebp),%eax
    a663:	01 d0                	add    %edx,%eax
    a665:	0f b6 00             	movzbl (%eax),%eax
    a668:	0f b6 c0             	movzbl %al,%eax
    a66b:	c1 e0 08             	shl    $0x8,%eax
    a66e:	89 c2                	mov    %eax,%edx
    a670:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a673:	01 c0                	add    %eax,%eax
    a675:	8d 48 01             	lea    0x1(%eax),%ecx
    a678:	8b 45 18             	mov    0x18(%ebp),%eax
    a67b:	01 c8                	add    %ecx,%eax
    a67d:	0f b6 00             	movzbl (%eax),%eax
    a680:	0f b6 c0             	movzbl %al,%eax
    a683:	01 c2                	add    %eax,%edx
    a685:	8b 45 20             	mov    0x20(%ebp),%eax
    a688:	8b 40 14             	mov    0x14(%eax),%eax
    a68b:	39 c2                	cmp    %eax,%edx
    a68d:	75 0b                	jne    a69a <getPixelColorRGBA8+0xfb>
    a68f:	8b 45 14             	mov    0x14(%ebp),%eax
    a692:	c6 00 00             	movb   $0x0,(%eax)
    a695:	e9 cf 04 00 00       	jmp    ab69 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a69a:	8b 45 14             	mov    0x14(%ebp),%eax
    a69d:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a6a0:	e9 c4 04 00 00       	jmp    ab69 <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    a6a5:	8b 45 20             	mov    0x20(%ebp),%eax
    a6a8:	8b 40 04             	mov    0x4(%eax),%eax
    a6ab:	ba 01 00 00 00       	mov    $0x1,%edx
    a6b0:	89 c1                	mov    %eax,%ecx
    a6b2:	d3 e2                	shl    %cl,%edx
    a6b4:	89 d0                	mov    %edx,%eax
    a6b6:	83 e8 01             	sub    $0x1,%eax
    a6b9:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    a6bc:	8b 45 20             	mov    0x20(%ebp),%eax
    a6bf:	8b 50 04             	mov    0x4(%eax),%edx
    a6c2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a6c5:	0f af c2             	imul   %edx,%eax
    a6c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a6cb:	8b 45 20             	mov    0x20(%ebp),%eax
    a6ce:	8b 40 04             	mov    0x4(%eax),%eax
    a6d1:	50                   	push   %eax
    a6d2:	ff 75 18             	pushl  0x18(%ebp)
    a6d5:	8d 45 f0             	lea    -0x10(%ebp),%eax
    a6d8:	50                   	push   %eax
    a6d9:	e8 06 db ff ff       	call   81e4 <readBitsFromReversedStream>
    a6de:	83 c4 0c             	add    $0xc,%esp
    a6e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    a6e4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a6e7:	89 d0                	mov    %edx,%eax
    a6e9:	c1 e0 08             	shl    $0x8,%eax
    a6ec:	29 d0                	sub    %edx,%eax
    a6ee:	ba 00 00 00 00       	mov    $0x0,%edx
    a6f3:	f7 75 f8             	divl   -0x8(%ebp)
    a6f6:	89 c2                	mov    %eax,%edx
    a6f8:	8b 45 10             	mov    0x10(%ebp),%eax
    a6fb:	88 10                	mov    %dl,(%eax)
    a6fd:	8b 45 10             	mov    0x10(%ebp),%eax
    a700:	0f b6 10             	movzbl (%eax),%edx
    a703:	8b 45 0c             	mov    0xc(%ebp),%eax
    a706:	88 10                	mov    %dl,(%eax)
    a708:	8b 45 0c             	mov    0xc(%ebp),%eax
    a70b:	0f b6 10             	movzbl (%eax),%edx
    a70e:	8b 45 08             	mov    0x8(%ebp),%eax
    a711:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    a713:	8b 45 20             	mov    0x20(%ebp),%eax
    a716:	8b 40 10             	mov    0x10(%eax),%eax
    a719:	85 c0                	test   %eax,%eax
    a71b:	74 16                	je     a733 <getPixelColorRGBA8+0x194>
    a71d:	8b 45 20             	mov    0x20(%ebp),%eax
    a720:	8b 40 14             	mov    0x14(%eax),%eax
    a723:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a726:	75 0b                	jne    a733 <getPixelColorRGBA8+0x194>
    a728:	8b 45 14             	mov    0x14(%ebp),%eax
    a72b:	c6 00 00             	movb   $0x0,(%eax)
    a72e:	e9 36 04 00 00       	jmp    ab69 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a733:	8b 45 14             	mov    0x14(%ebp),%eax
    a736:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a739:	e9 2b 04 00 00       	jmp    ab69 <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    a73e:	8b 45 20             	mov    0x20(%ebp),%eax
    a741:	8b 00                	mov    (%eax),%eax
    a743:	83 f8 02             	cmp    $0x2,%eax
    a746:	0f 85 f5 01 00 00    	jne    a941 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    a74c:	8b 45 20             	mov    0x20(%ebp),%eax
    a74f:	8b 40 04             	mov    0x4(%eax),%eax
    a752:	83 f8 08             	cmp    $0x8,%eax
    a755:	0f 85 a3 00 00 00    	jne    a7fe <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    a75b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a75e:	89 d0                	mov    %edx,%eax
    a760:	01 c0                	add    %eax,%eax
    a762:	01 d0                	add    %edx,%eax
    a764:	89 c2                	mov    %eax,%edx
    a766:	8b 45 18             	mov    0x18(%ebp),%eax
    a769:	01 d0                	add    %edx,%eax
    a76b:	0f b6 10             	movzbl (%eax),%edx
    a76e:	8b 45 08             	mov    0x8(%ebp),%eax
    a771:	88 10                	mov    %dl,(%eax)
    a773:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a776:	89 d0                	mov    %edx,%eax
    a778:	01 c0                	add    %eax,%eax
    a77a:	01 d0                	add    %edx,%eax
    a77c:	8d 50 01             	lea    0x1(%eax),%edx
    a77f:	8b 45 18             	mov    0x18(%ebp),%eax
    a782:	01 d0                	add    %edx,%eax
    a784:	0f b6 10             	movzbl (%eax),%edx
    a787:	8b 45 0c             	mov    0xc(%ebp),%eax
    a78a:	88 10                	mov    %dl,(%eax)
    a78c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a78f:	89 d0                	mov    %edx,%eax
    a791:	01 c0                	add    %eax,%eax
    a793:	01 d0                	add    %edx,%eax
    a795:	8d 50 02             	lea    0x2(%eax),%edx
    a798:	8b 45 18             	mov    0x18(%ebp),%eax
    a79b:	01 d0                	add    %edx,%eax
    a79d:	0f b6 10             	movzbl (%eax),%edx
    a7a0:	8b 45 10             	mov    0x10(%ebp),%eax
    a7a3:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    a7a5:	8b 45 20             	mov    0x20(%ebp),%eax
    a7a8:	8b 40 10             	mov    0x10(%eax),%eax
    a7ab:	85 c0                	test   %eax,%eax
    a7ad:	74 44                	je     a7f3 <getPixelColorRGBA8+0x254>
    a7af:	8b 45 08             	mov    0x8(%ebp),%eax
    a7b2:	0f b6 00             	movzbl (%eax),%eax
    a7b5:	0f b6 d0             	movzbl %al,%edx
    a7b8:	8b 45 20             	mov    0x20(%ebp),%eax
    a7bb:	8b 40 14             	mov    0x14(%eax),%eax
    a7be:	39 c2                	cmp    %eax,%edx
    a7c0:	75 31                	jne    a7f3 <getPixelColorRGBA8+0x254>
    a7c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7c5:	0f b6 00             	movzbl (%eax),%eax
    a7c8:	0f b6 d0             	movzbl %al,%edx
    a7cb:	8b 45 20             	mov    0x20(%ebp),%eax
    a7ce:	8b 40 18             	mov    0x18(%eax),%eax
    a7d1:	39 c2                	cmp    %eax,%edx
    a7d3:	75 1e                	jne    a7f3 <getPixelColorRGBA8+0x254>
    a7d5:	8b 45 10             	mov    0x10(%ebp),%eax
    a7d8:	0f b6 00             	movzbl (%eax),%eax
    a7db:	0f b6 d0             	movzbl %al,%edx
    a7de:	8b 45 20             	mov    0x20(%ebp),%eax
    a7e1:	8b 40 1c             	mov    0x1c(%eax),%eax
    a7e4:	39 c2                	cmp    %eax,%edx
    a7e6:	75 0b                	jne    a7f3 <getPixelColorRGBA8+0x254>
    a7e8:	8b 45 14             	mov    0x14(%ebp),%eax
    a7eb:	c6 00 00             	movb   $0x0,(%eax)
    a7ee:	e9 76 03 00 00       	jmp    ab69 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a7f3:	8b 45 14             	mov    0x14(%ebp),%eax
    a7f6:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a7f9:	e9 6b 03 00 00       	jmp    ab69 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    a7fe:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a801:	89 d0                	mov    %edx,%eax
    a803:	01 c0                	add    %eax,%eax
    a805:	01 d0                	add    %edx,%eax
    a807:	01 c0                	add    %eax,%eax
    a809:	89 c2                	mov    %eax,%edx
    a80b:	8b 45 18             	mov    0x18(%ebp),%eax
    a80e:	01 d0                	add    %edx,%eax
    a810:	0f b6 10             	movzbl (%eax),%edx
    a813:	8b 45 08             	mov    0x8(%ebp),%eax
    a816:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    a818:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a81b:	89 d0                	mov    %edx,%eax
    a81d:	01 c0                	add    %eax,%eax
    a81f:	01 d0                	add    %edx,%eax
    a821:	01 c0                	add    %eax,%eax
    a823:	8d 50 02             	lea    0x2(%eax),%edx
    a826:	8b 45 18             	mov    0x18(%ebp),%eax
    a829:	01 d0                	add    %edx,%eax
    a82b:	0f b6 10             	movzbl (%eax),%edx
    a82e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a831:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    a833:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a836:	89 d0                	mov    %edx,%eax
    a838:	01 c0                	add    %eax,%eax
    a83a:	01 d0                	add    %edx,%eax
    a83c:	01 c0                	add    %eax,%eax
    a83e:	8d 50 04             	lea    0x4(%eax),%edx
    a841:	8b 45 18             	mov    0x18(%ebp),%eax
    a844:	01 d0                	add    %edx,%eax
    a846:	0f b6 10             	movzbl (%eax),%edx
    a849:	8b 45 10             	mov    0x10(%ebp),%eax
    a84c:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    a84e:	8b 45 20             	mov    0x20(%ebp),%eax
    a851:	8b 40 10             	mov    0x10(%eax),%eax
    a854:	85 c0                	test   %eax,%eax
    a856:	0f 84 da 00 00 00    	je     a936 <getPixelColorRGBA8+0x397>
    a85c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a85f:	89 d0                	mov    %edx,%eax
    a861:	01 c0                	add    %eax,%eax
    a863:	01 d0                	add    %edx,%eax
    a865:	01 c0                	add    %eax,%eax
    a867:	89 c2                	mov    %eax,%edx
    a869:	8b 45 18             	mov    0x18(%ebp),%eax
    a86c:	01 d0                	add    %edx,%eax
    a86e:	0f b6 00             	movzbl (%eax),%eax
    a871:	0f b6 c0             	movzbl %al,%eax
    a874:	c1 e0 08             	shl    $0x8,%eax
    a877:	89 c1                	mov    %eax,%ecx
    a879:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a87c:	89 d0                	mov    %edx,%eax
    a87e:	01 c0                	add    %eax,%eax
    a880:	01 d0                	add    %edx,%eax
    a882:	01 c0                	add    %eax,%eax
    a884:	8d 50 01             	lea    0x1(%eax),%edx
    a887:	8b 45 18             	mov    0x18(%ebp),%eax
    a88a:	01 d0                	add    %edx,%eax
    a88c:	0f b6 00             	movzbl (%eax),%eax
    a88f:	0f b6 c0             	movzbl %al,%eax
    a892:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a895:	8b 45 20             	mov    0x20(%ebp),%eax
    a898:	8b 40 14             	mov    0x14(%eax),%eax
    a89b:	39 c2                	cmp    %eax,%edx
    a89d:	0f 85 93 00 00 00    	jne    a936 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    a8a3:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8a6:	89 d0                	mov    %edx,%eax
    a8a8:	01 c0                	add    %eax,%eax
    a8aa:	01 d0                	add    %edx,%eax
    a8ac:	01 c0                	add    %eax,%eax
    a8ae:	8d 50 02             	lea    0x2(%eax),%edx
    a8b1:	8b 45 18             	mov    0x18(%ebp),%eax
    a8b4:	01 d0                	add    %edx,%eax
    a8b6:	0f b6 00             	movzbl (%eax),%eax
    a8b9:	0f b6 c0             	movzbl %al,%eax
    a8bc:	c1 e0 08             	shl    $0x8,%eax
    a8bf:	89 c1                	mov    %eax,%ecx
    a8c1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8c4:	89 d0                	mov    %edx,%eax
    a8c6:	01 c0                	add    %eax,%eax
    a8c8:	01 d0                	add    %edx,%eax
    a8ca:	01 c0                	add    %eax,%eax
    a8cc:	8d 50 03             	lea    0x3(%eax),%edx
    a8cf:	8b 45 18             	mov    0x18(%ebp),%eax
    a8d2:	01 d0                	add    %edx,%eax
    a8d4:	0f b6 00             	movzbl (%eax),%eax
    a8d7:	0f b6 c0             	movzbl %al,%eax
    a8da:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a8dd:	8b 45 20             	mov    0x20(%ebp),%eax
    a8e0:	8b 40 18             	mov    0x18(%eax),%eax
    a8e3:	39 c2                	cmp    %eax,%edx
    a8e5:	75 4f                	jne    a936 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    a8e7:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8ea:	89 d0                	mov    %edx,%eax
    a8ec:	01 c0                	add    %eax,%eax
    a8ee:	01 d0                	add    %edx,%eax
    a8f0:	01 c0                	add    %eax,%eax
    a8f2:	8d 50 04             	lea    0x4(%eax),%edx
    a8f5:	8b 45 18             	mov    0x18(%ebp),%eax
    a8f8:	01 d0                	add    %edx,%eax
    a8fa:	0f b6 00             	movzbl (%eax),%eax
    a8fd:	0f b6 c0             	movzbl %al,%eax
    a900:	c1 e0 08             	shl    $0x8,%eax
    a903:	89 c1                	mov    %eax,%ecx
    a905:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a908:	89 d0                	mov    %edx,%eax
    a90a:	01 c0                	add    %eax,%eax
    a90c:	01 d0                	add    %edx,%eax
    a90e:	01 c0                	add    %eax,%eax
    a910:	8d 50 05             	lea    0x5(%eax),%edx
    a913:	8b 45 18             	mov    0x18(%ebp),%eax
    a916:	01 d0                	add    %edx,%eax
    a918:	0f b6 00             	movzbl (%eax),%eax
    a91b:	0f b6 c0             	movzbl %al,%eax
    a91e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a921:	8b 45 20             	mov    0x20(%ebp),%eax
    a924:	8b 40 1c             	mov    0x1c(%eax),%eax
    a927:	39 c2                	cmp    %eax,%edx
    a929:	75 0b                	jne    a936 <getPixelColorRGBA8+0x397>
    a92b:	8b 45 14             	mov    0x14(%ebp),%eax
    a92e:	c6 00 00             	movb   $0x0,(%eax)
    a931:	e9 33 02 00 00       	jmp    ab69 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a936:	8b 45 14             	mov    0x14(%ebp),%eax
    a939:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a93c:	e9 28 02 00 00       	jmp    ab69 <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a941:	8b 45 20             	mov    0x20(%ebp),%eax
    a944:	8b 00                	mov    (%eax),%eax
    a946:	83 f8 03             	cmp    $0x3,%eax
    a949:	0f 85 ac 00 00 00    	jne    a9fb <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    a94f:	8b 45 20             	mov    0x20(%ebp),%eax
    a952:	8b 40 04             	mov    0x4(%eax),%eax
    a955:	83 f8 08             	cmp    $0x8,%eax
    a958:	75 13                	jne    a96d <getPixelColorRGBA8+0x3ce>
    a95a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a95d:	8b 45 18             	mov    0x18(%ebp),%eax
    a960:	01 d0                	add    %edx,%eax
    a962:	0f b6 00             	movzbl (%eax),%eax
    a965:	0f b6 c0             	movzbl %al,%eax
    a968:	89 45 fc             	mov    %eax,-0x4(%ebp)
    a96b:	eb 28                	jmp    a995 <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    a96d:	8b 45 20             	mov    0x20(%ebp),%eax
    a970:	8b 50 04             	mov    0x4(%eax),%edx
    a973:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a976:	0f af c2             	imul   %edx,%eax
    a979:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a97c:	8b 45 20             	mov    0x20(%ebp),%eax
    a97f:	8b 40 04             	mov    0x4(%eax),%eax
    a982:	50                   	push   %eax
    a983:	ff 75 18             	pushl  0x18(%ebp)
    a986:	8d 45 ec             	lea    -0x14(%ebp),%eax
    a989:	50                   	push   %eax
    a98a:	e8 55 d8 ff ff       	call   81e4 <readBitsFromReversedStream>
    a98f:	83 c4 0c             	add    $0xc,%esp
    a992:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    a995:	8b 45 20             	mov    0x20(%ebp),%eax
    a998:	8b 40 08             	mov    0x8(%eax),%eax
    a99b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a99e:	c1 e2 02             	shl    $0x2,%edx
    a9a1:	01 d0                	add    %edx,%eax
    a9a3:	0f b6 10             	movzbl (%eax),%edx
    a9a6:	8b 45 08             	mov    0x8(%ebp),%eax
    a9a9:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    a9ab:	8b 45 20             	mov    0x20(%ebp),%eax
    a9ae:	8b 40 08             	mov    0x8(%eax),%eax
    a9b1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a9b4:	c1 e2 02             	shl    $0x2,%edx
    a9b7:	83 c2 01             	add    $0x1,%edx
    a9ba:	01 d0                	add    %edx,%eax
    a9bc:	0f b6 10             	movzbl (%eax),%edx
    a9bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9c2:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    a9c4:	8b 45 20             	mov    0x20(%ebp),%eax
    a9c7:	8b 40 08             	mov    0x8(%eax),%eax
    a9ca:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a9cd:	c1 e2 02             	shl    $0x2,%edx
    a9d0:	83 c2 02             	add    $0x2,%edx
    a9d3:	01 d0                	add    %edx,%eax
    a9d5:	0f b6 10             	movzbl (%eax),%edx
    a9d8:	8b 45 10             	mov    0x10(%ebp),%eax
    a9db:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    a9dd:	8b 45 20             	mov    0x20(%ebp),%eax
    a9e0:	8b 40 08             	mov    0x8(%eax),%eax
    a9e3:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a9e6:	c1 e2 02             	shl    $0x2,%edx
    a9e9:	83 c2 03             	add    $0x3,%edx
    a9ec:	01 d0                	add    %edx,%eax
    a9ee:	0f b6 10             	movzbl (%eax),%edx
    a9f1:	8b 45 14             	mov    0x14(%ebp),%eax
    a9f4:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a9f6:	e9 6e 01 00 00       	jmp    ab69 <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a9fb:	8b 45 20             	mov    0x20(%ebp),%eax
    a9fe:	8b 00                	mov    (%eax),%eax
    aa00:	83 f8 04             	cmp    $0x4,%eax
    aa03:	0f 85 95 00 00 00    	jne    aa9e <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    aa09:	8b 45 20             	mov    0x20(%ebp),%eax
    aa0c:	8b 40 04             	mov    0x4(%eax),%eax
    aa0f:	83 f8 08             	cmp    $0x8,%eax
    aa12:	75 44                	jne    aa58 <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    aa14:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa17:	01 c0                	add    %eax,%eax
    aa19:	89 c2                	mov    %eax,%edx
    aa1b:	8b 45 18             	mov    0x18(%ebp),%eax
    aa1e:	01 d0                	add    %edx,%eax
    aa20:	0f b6 10             	movzbl (%eax),%edx
    aa23:	8b 45 10             	mov    0x10(%ebp),%eax
    aa26:	88 10                	mov    %dl,(%eax)
    aa28:	8b 45 10             	mov    0x10(%ebp),%eax
    aa2b:	0f b6 10             	movzbl (%eax),%edx
    aa2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa31:	88 10                	mov    %dl,(%eax)
    aa33:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa36:	0f b6 10             	movzbl (%eax),%edx
    aa39:	8b 45 08             	mov    0x8(%ebp),%eax
    aa3c:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    aa3e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa41:	01 c0                	add    %eax,%eax
    aa43:	8d 50 01             	lea    0x1(%eax),%edx
    aa46:	8b 45 18             	mov    0x18(%ebp),%eax
    aa49:	01 d0                	add    %edx,%eax
    aa4b:	0f b6 10             	movzbl (%eax),%edx
    aa4e:	8b 45 14             	mov    0x14(%ebp),%eax
    aa51:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa53:	e9 11 01 00 00       	jmp    ab69 <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    aa58:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa5b:	c1 e0 02             	shl    $0x2,%eax
    aa5e:	89 c2                	mov    %eax,%edx
    aa60:	8b 45 18             	mov    0x18(%ebp),%eax
    aa63:	01 d0                	add    %edx,%eax
    aa65:	0f b6 10             	movzbl (%eax),%edx
    aa68:	8b 45 10             	mov    0x10(%ebp),%eax
    aa6b:	88 10                	mov    %dl,(%eax)
    aa6d:	8b 45 10             	mov    0x10(%ebp),%eax
    aa70:	0f b6 10             	movzbl (%eax),%edx
    aa73:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa76:	88 10                	mov    %dl,(%eax)
    aa78:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa7b:	0f b6 10             	movzbl (%eax),%edx
    aa7e:	8b 45 08             	mov    0x8(%ebp),%eax
    aa81:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    aa83:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa86:	c1 e0 02             	shl    $0x2,%eax
    aa89:	8d 50 02             	lea    0x2(%eax),%edx
    aa8c:	8b 45 18             	mov    0x18(%ebp),%eax
    aa8f:	01 d0                	add    %edx,%eax
    aa91:	0f b6 10             	movzbl (%eax),%edx
    aa94:	8b 45 14             	mov    0x14(%ebp),%eax
    aa97:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa99:	e9 cb 00 00 00       	jmp    ab69 <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    aa9e:	8b 45 20             	mov    0x20(%ebp),%eax
    aaa1:	8b 00                	mov    (%eax),%eax
    aaa3:	83 f8 06             	cmp    $0x6,%eax
    aaa6:	0f 85 bd 00 00 00    	jne    ab69 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    aaac:	8b 45 20             	mov    0x20(%ebp),%eax
    aaaf:	8b 40 04             	mov    0x4(%eax),%eax
    aab2:	83 f8 08             	cmp    $0x8,%eax
    aab5:	75 59                	jne    ab10 <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    aab7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aaba:	c1 e0 02             	shl    $0x2,%eax
    aabd:	89 c2                	mov    %eax,%edx
    aabf:	8b 45 18             	mov    0x18(%ebp),%eax
    aac2:	01 d0                	add    %edx,%eax
    aac4:	0f b6 10             	movzbl (%eax),%edx
    aac7:	8b 45 08             	mov    0x8(%ebp),%eax
    aaca:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    aacc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aacf:	c1 e0 02             	shl    $0x2,%eax
    aad2:	8d 50 01             	lea    0x1(%eax),%edx
    aad5:	8b 45 18             	mov    0x18(%ebp),%eax
    aad8:	01 d0                	add    %edx,%eax
    aada:	0f b6 10             	movzbl (%eax),%edx
    aadd:	8b 45 0c             	mov    0xc(%ebp),%eax
    aae0:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    aae2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aae5:	c1 e0 02             	shl    $0x2,%eax
    aae8:	8d 50 02             	lea    0x2(%eax),%edx
    aaeb:	8b 45 18             	mov    0x18(%ebp),%eax
    aaee:	01 d0                	add    %edx,%eax
    aaf0:	0f b6 10             	movzbl (%eax),%edx
    aaf3:	8b 45 10             	mov    0x10(%ebp),%eax
    aaf6:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    aaf8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aafb:	c1 e0 02             	shl    $0x2,%eax
    aafe:	8d 50 03             	lea    0x3(%eax),%edx
    ab01:	8b 45 18             	mov    0x18(%ebp),%eax
    ab04:	01 d0                	add    %edx,%eax
    ab06:	0f b6 10             	movzbl (%eax),%edx
    ab09:	8b 45 14             	mov    0x14(%ebp),%eax
    ab0c:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ab0e:	eb 59                	jmp    ab69 <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    ab10:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab13:	c1 e0 03             	shl    $0x3,%eax
    ab16:	89 c2                	mov    %eax,%edx
    ab18:	8b 45 18             	mov    0x18(%ebp),%eax
    ab1b:	01 d0                	add    %edx,%eax
    ab1d:	0f b6 10             	movzbl (%eax),%edx
    ab20:	8b 45 08             	mov    0x8(%ebp),%eax
    ab23:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    ab25:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab28:	c1 e0 03             	shl    $0x3,%eax
    ab2b:	8d 50 02             	lea    0x2(%eax),%edx
    ab2e:	8b 45 18             	mov    0x18(%ebp),%eax
    ab31:	01 d0                	add    %edx,%eax
    ab33:	0f b6 10             	movzbl (%eax),%edx
    ab36:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab39:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    ab3b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab3e:	c1 e0 03             	shl    $0x3,%eax
    ab41:	8d 50 04             	lea    0x4(%eax),%edx
    ab44:	8b 45 18             	mov    0x18(%ebp),%eax
    ab47:	01 d0                	add    %edx,%eax
    ab49:	0f b6 10             	movzbl (%eax),%edx
    ab4c:	8b 45 10             	mov    0x10(%ebp),%eax
    ab4f:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    ab51:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab54:	c1 e0 03             	shl    $0x3,%eax
    ab57:	8d 50 06             	lea    0x6(%eax),%edx
    ab5a:	8b 45 18             	mov    0x18(%ebp),%eax
    ab5d:	01 d0                	add    %edx,%eax
    ab5f:	0f b6 10             	movzbl (%eax),%edx
    ab62:	8b 45 14             	mov    0x14(%ebp),%eax
    ab65:	88 10                	mov    %dl,(%eax)
    }
  }
}
    ab67:	eb 00                	jmp    ab69 <getPixelColorRGBA8+0x5ca>
    ab69:	90                   	nop
    ab6a:	c9                   	leave  
    ab6b:	c3                   	ret    

0000ab6c <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    ab6c:	55                   	push   %ebp
    ab6d:	89 e5                	mov    %esp,%ebp
    ab6f:	53                   	push   %ebx
    ab70:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    ab73:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    ab7a:	8b 45 14             	mov    0x14(%ebp),%eax
    ab7d:	8b 00                	mov    (%eax),%eax
    ab7f:	85 c0                	test   %eax,%eax
    ab81:	0f 85 14 02 00 00    	jne    ad9b <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    ab87:	8b 45 14             	mov    0x14(%ebp),%eax
    ab8a:	8b 40 04             	mov    0x4(%eax),%eax
    ab8d:	83 f8 08             	cmp    $0x8,%eax
    ab90:	0f 85 a0 00 00 00    	jne    ac36 <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ab96:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ab9d:	eb 39                	jmp    abd8 <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    ab9f:	8b 45 08             	mov    0x8(%ebp),%eax
    aba2:	83 c0 01             	add    $0x1,%eax
    aba5:	8b 55 08             	mov    0x8(%ebp),%edx
    aba8:	83 c2 02             	add    $0x2,%edx
    abab:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    abae:	8b 4d 10             	mov    0x10(%ebp),%ecx
    abb1:	01 d9                	add    %ebx,%ecx
    abb3:	0f b6 09             	movzbl (%ecx),%ecx
    abb6:	88 0a                	mov    %cl,(%edx)
    abb8:	0f b6 12             	movzbl (%edx),%edx
    abbb:	88 10                	mov    %dl,(%eax)
    abbd:	0f b6 10             	movzbl (%eax),%edx
    abc0:	8b 45 08             	mov    0x8(%ebp),%eax
    abc3:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    abc5:	8b 45 08             	mov    0x8(%ebp),%eax
    abc8:	83 c0 03             	add    $0x3,%eax
    abcb:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    abce:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    abd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    abd5:	01 45 08             	add    %eax,0x8(%ebp)
    abd8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    abdb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    abde:	75 bf                	jne    ab9f <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    abe0:	8b 45 14             	mov    0x14(%ebp),%eax
    abe3:	8b 40 10             	mov    0x10(%eax),%eax
    abe6:	85 c0                	test   %eax,%eax
    abe8:	0f 84 48 06 00 00    	je     b236 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    abee:	8b 45 0c             	mov    0xc(%ebp),%eax
    abf1:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    abf5:	f7 d8                	neg    %eax
    abf7:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    abfa:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ac01:	eb 26                	jmp    ac29 <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    ac03:	8b 45 08             	mov    0x8(%ebp),%eax
    ac06:	0f b6 00             	movzbl (%eax),%eax
    ac09:	0f b6 d0             	movzbl %al,%edx
    ac0c:	8b 45 14             	mov    0x14(%ebp),%eax
    ac0f:	8b 40 14             	mov    0x14(%eax),%eax
    ac12:	39 c2                	cmp    %eax,%edx
    ac14:	75 09                	jne    ac1f <getPixelColorsRGBA8+0xb3>
    ac16:	8b 45 08             	mov    0x8(%ebp),%eax
    ac19:	83 c0 03             	add    $0x3,%eax
    ac1c:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac1f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ac23:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ac26:	01 45 08             	add    %eax,0x8(%ebp)
    ac29:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac2c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ac2f:	75 d2                	jne    ac03 <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ac31:	e9 00 06 00 00       	jmp    b236 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    ac36:	8b 45 14             	mov    0x14(%ebp),%eax
    ac39:	8b 40 04             	mov    0x4(%eax),%eax
    ac3c:	83 f8 10             	cmp    $0x10,%eax
    ac3f:	0f 85 a5 00 00 00    	jne    acea <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac45:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ac4c:	e9 88 00 00 00       	jmp    acd9 <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    ac51:	8b 45 08             	mov    0x8(%ebp),%eax
    ac54:	83 c0 01             	add    $0x1,%eax
    ac57:	8b 55 08             	mov    0x8(%ebp),%edx
    ac5a:	83 c2 02             	add    $0x2,%edx
    ac5d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    ac60:	01 c9                	add    %ecx,%ecx
    ac62:	89 cb                	mov    %ecx,%ebx
    ac64:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ac67:	01 d9                	add    %ebx,%ecx
    ac69:	0f b6 09             	movzbl (%ecx),%ecx
    ac6c:	88 0a                	mov    %cl,(%edx)
    ac6e:	0f b6 12             	movzbl (%edx),%edx
    ac71:	88 10                	mov    %dl,(%eax)
    ac73:	0f b6 10             	movzbl (%eax),%edx
    ac76:	8b 45 08             	mov    0x8(%ebp),%eax
    ac79:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    ac7b:	8b 45 08             	mov    0x8(%ebp),%eax
    ac7e:	8d 50 03             	lea    0x3(%eax),%edx
    ac81:	8b 45 14             	mov    0x14(%ebp),%eax
    ac84:	8b 40 10             	mov    0x10(%eax),%eax
    ac87:	85 c0                	test   %eax,%eax
    ac89:	74 3d                	je     acc8 <getPixelColorsRGBA8+0x15c>
    ac8b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac8e:	01 c0                	add    %eax,%eax
    ac90:	89 c1                	mov    %eax,%ecx
    ac92:	8b 45 10             	mov    0x10(%ebp),%eax
    ac95:	01 c8                	add    %ecx,%eax
    ac97:	0f b6 00             	movzbl (%eax),%eax
    ac9a:	0f b6 c0             	movzbl %al,%eax
    ac9d:	c1 e0 08             	shl    $0x8,%eax
    aca0:	89 c1                	mov    %eax,%ecx
    aca2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    aca5:	01 c0                	add    %eax,%eax
    aca7:	8d 58 01             	lea    0x1(%eax),%ebx
    acaa:	8b 45 10             	mov    0x10(%ebp),%eax
    acad:	01 d8                	add    %ebx,%eax
    acaf:	0f b6 00             	movzbl (%eax),%eax
    acb2:	0f b6 c0             	movzbl %al,%eax
    acb5:	01 c1                	add    %eax,%ecx
    acb7:	8b 45 14             	mov    0x14(%ebp),%eax
    acba:	8b 40 14             	mov    0x14(%eax),%eax
    acbd:	39 c1                	cmp    %eax,%ecx
    acbf:	75 07                	jne    acc8 <getPixelColorsRGBA8+0x15c>
    acc1:	b8 00 00 00 00       	mov    $0x0,%eax
    acc6:	eb 05                	jmp    accd <getPixelColorsRGBA8+0x161>
    acc8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    accd:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    accf:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    acd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    acd6:	01 45 08             	add    %eax,0x8(%ebp)
    acd9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    acdc:	3b 45 0c             	cmp    0xc(%ebp),%eax
    acdf:	0f 85 6c ff ff ff    	jne    ac51 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ace5:	e9 4c 05 00 00       	jmp    b236 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    acea:	8b 45 14             	mov    0x14(%ebp),%eax
    aced:	8b 40 04             	mov    0x4(%eax),%eax
    acf0:	ba 01 00 00 00       	mov    $0x1,%edx
    acf5:	89 c1                	mov    %eax,%ecx
    acf7:	d3 e2                	shl    %cl,%edx
    acf9:	89 d0                	mov    %edx,%eax
    acfb:	83 e8 01             	sub    $0x1,%eax
    acfe:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    ad01:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad08:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ad0f:	eb 79                	jmp    ad8a <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ad11:	8b 45 14             	mov    0x14(%ebp),%eax
    ad14:	8b 40 04             	mov    0x4(%eax),%eax
    ad17:	50                   	push   %eax
    ad18:	ff 75 10             	pushl  0x10(%ebp)
    ad1b:	8d 45 e0             	lea    -0x20(%ebp),%eax
    ad1e:	50                   	push   %eax
    ad1f:	e8 c0 d4 ff ff       	call   81e4 <readBitsFromReversedStream>
    ad24:	83 c4 0c             	add    $0xc,%esp
    ad27:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    ad2a:	8b 45 08             	mov    0x8(%ebp),%eax
    ad2d:	8d 48 01             	lea    0x1(%eax),%ecx
    ad30:	8b 45 08             	mov    0x8(%ebp),%eax
    ad33:	8d 58 02             	lea    0x2(%eax),%ebx
    ad36:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ad39:	89 d0                	mov    %edx,%eax
    ad3b:	c1 e0 08             	shl    $0x8,%eax
    ad3e:	29 d0                	sub    %edx,%eax
    ad40:	ba 00 00 00 00       	mov    $0x0,%edx
    ad45:	f7 75 f0             	divl   -0x10(%ebp)
    ad48:	88 03                	mov    %al,(%ebx)
    ad4a:	0f b6 03             	movzbl (%ebx),%eax
    ad4d:	88 01                	mov    %al,(%ecx)
    ad4f:	0f b6 11             	movzbl (%ecx),%edx
    ad52:	8b 45 08             	mov    0x8(%ebp),%eax
    ad55:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    ad57:	8b 45 08             	mov    0x8(%ebp),%eax
    ad5a:	8d 50 03             	lea    0x3(%eax),%edx
    ad5d:	8b 45 14             	mov    0x14(%ebp),%eax
    ad60:	8b 40 10             	mov    0x10(%eax),%eax
    ad63:	85 c0                	test   %eax,%eax
    ad65:	74 12                	je     ad79 <getPixelColorsRGBA8+0x20d>
    ad67:	8b 45 14             	mov    0x14(%ebp),%eax
    ad6a:	8b 40 14             	mov    0x14(%eax),%eax
    ad6d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    ad70:	75 07                	jne    ad79 <getPixelColorsRGBA8+0x20d>
    ad72:	b8 00 00 00 00       	mov    $0x0,%eax
    ad77:	eb 05                	jmp    ad7e <getPixelColorsRGBA8+0x212>
    ad79:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    ad7e:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad80:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ad84:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ad87:	01 45 08             	add    %eax,0x8(%ebp)
    ad8a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad8d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ad90:	0f 85 7b ff ff ff    	jne    ad11 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ad96:	e9 9b 04 00 00       	jmp    b236 <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    ad9b:	8b 45 14             	mov    0x14(%ebp),%eax
    ad9e:	8b 00                	mov    (%eax),%eax
    ada0:	83 f8 02             	cmp    $0x2,%eax
    ada3:	0f 85 41 02 00 00    	jne    afea <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    ada9:	8b 45 14             	mov    0x14(%ebp),%eax
    adac:	8b 40 04             	mov    0x4(%eax),%eax
    adaf:	83 f8 08             	cmp    $0x8,%eax
    adb2:	0f 85 c4 00 00 00    	jne    ae7c <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    adb8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    adbf:	eb 31                	jmp    adf2 <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    adc1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    adc4:	89 d0                	mov    %edx,%eax
    adc6:	01 c0                	add    %eax,%eax
    adc8:	01 d0                	add    %edx,%eax
    adca:	89 c2                	mov    %eax,%edx
    adcc:	8b 45 10             	mov    0x10(%ebp),%eax
    adcf:	01 d0                	add    %edx,%eax
    add1:	6a 03                	push   $0x3
    add3:	50                   	push   %eax
    add4:	ff 75 08             	pushl  0x8(%ebp)
    add7:	e8 a3 85 ff ff       	call   337f <lodepng_memcpy>
    addc:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    addf:	8b 45 08             	mov    0x8(%ebp),%eax
    ade2:	83 c0 03             	add    $0x3,%eax
    ade5:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ade8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    adec:	8b 45 f4             	mov    -0xc(%ebp),%eax
    adef:	01 45 08             	add    %eax,0x8(%ebp)
    adf2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    adf5:	3b 45 0c             	cmp    0xc(%ebp),%eax
    adf8:	75 c7                	jne    adc1 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    adfa:	8b 45 14             	mov    0x14(%ebp),%eax
    adfd:	8b 40 10             	mov    0x10(%eax),%eax
    ae00:	85 c0                	test   %eax,%eax
    ae02:	0f 84 2e 04 00 00    	je     b236 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    ae08:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae0b:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    ae0f:	f7 d8                	neg    %eax
    ae11:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae14:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae1b:	eb 52                	jmp    ae6f <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    ae1d:	8b 45 08             	mov    0x8(%ebp),%eax
    ae20:	0f b6 00             	movzbl (%eax),%eax
    ae23:	0f b6 d0             	movzbl %al,%edx
    ae26:	8b 45 14             	mov    0x14(%ebp),%eax
    ae29:	8b 40 14             	mov    0x14(%eax),%eax
    ae2c:	39 c2                	cmp    %eax,%edx
    ae2e:	75 35                	jne    ae65 <getPixelColorsRGBA8+0x2f9>
    ae30:	8b 45 08             	mov    0x8(%ebp),%eax
    ae33:	83 c0 01             	add    $0x1,%eax
    ae36:	0f b6 00             	movzbl (%eax),%eax
    ae39:	0f b6 d0             	movzbl %al,%edx
    ae3c:	8b 45 14             	mov    0x14(%ebp),%eax
    ae3f:	8b 40 18             	mov    0x18(%eax),%eax
    ae42:	39 c2                	cmp    %eax,%edx
    ae44:	75 1f                	jne    ae65 <getPixelColorsRGBA8+0x2f9>
    ae46:	8b 45 08             	mov    0x8(%ebp),%eax
    ae49:	83 c0 02             	add    $0x2,%eax
    ae4c:	0f b6 00             	movzbl (%eax),%eax
    ae4f:	0f b6 d0             	movzbl %al,%edx
    ae52:	8b 45 14             	mov    0x14(%ebp),%eax
    ae55:	8b 40 1c             	mov    0x1c(%eax),%eax
    ae58:	39 c2                	cmp    %eax,%edx
    ae5a:	75 09                	jne    ae65 <getPixelColorsRGBA8+0x2f9>
    ae5c:	8b 45 08             	mov    0x8(%ebp),%eax
    ae5f:	83 c0 03             	add    $0x3,%eax
    ae62:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae65:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ae69:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ae6c:	01 45 08             	add    %eax,0x8(%ebp)
    ae6f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae72:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ae75:	75 a6                	jne    ae1d <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ae77:	e9 ba 03 00 00       	jmp    b236 <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae7c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae83:	e9 51 01 00 00       	jmp    afd9 <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    ae88:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae8b:	89 d0                	mov    %edx,%eax
    ae8d:	01 c0                	add    %eax,%eax
    ae8f:	01 d0                	add    %edx,%eax
    ae91:	01 c0                	add    %eax,%eax
    ae93:	89 c2                	mov    %eax,%edx
    ae95:	8b 45 10             	mov    0x10(%ebp),%eax
    ae98:	01 d0                	add    %edx,%eax
    ae9a:	0f b6 10             	movzbl (%eax),%edx
    ae9d:	8b 45 08             	mov    0x8(%ebp),%eax
    aea0:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    aea2:	8b 45 08             	mov    0x8(%ebp),%eax
    aea5:	8d 48 01             	lea    0x1(%eax),%ecx
    aea8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aeab:	89 d0                	mov    %edx,%eax
    aead:	01 c0                	add    %eax,%eax
    aeaf:	01 d0                	add    %edx,%eax
    aeb1:	01 c0                	add    %eax,%eax
    aeb3:	8d 50 02             	lea    0x2(%eax),%edx
    aeb6:	8b 45 10             	mov    0x10(%ebp),%eax
    aeb9:	01 d0                	add    %edx,%eax
    aebb:	0f b6 00             	movzbl (%eax),%eax
    aebe:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    aec0:	8b 45 08             	mov    0x8(%ebp),%eax
    aec3:	8d 48 02             	lea    0x2(%eax),%ecx
    aec6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aec9:	89 d0                	mov    %edx,%eax
    aecb:	01 c0                	add    %eax,%eax
    aecd:	01 d0                	add    %edx,%eax
    aecf:	01 c0                	add    %eax,%eax
    aed1:	8d 50 04             	lea    0x4(%eax),%edx
    aed4:	8b 45 10             	mov    0x10(%ebp),%eax
    aed7:	01 d0                	add    %edx,%eax
    aed9:	0f b6 00             	movzbl (%eax),%eax
    aedc:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    aede:	8b 45 08             	mov    0x8(%ebp),%eax
    aee1:	8d 48 03             	lea    0x3(%eax),%ecx
    aee4:	8b 45 14             	mov    0x14(%ebp),%eax
    aee7:	8b 40 10             	mov    0x10(%eax),%eax
    aeea:	85 c0                	test   %eax,%eax
    aeec:	0f 84 d6 00 00 00    	je     afc8 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    aef2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aef5:	89 d0                	mov    %edx,%eax
    aef7:	01 c0                	add    %eax,%eax
    aef9:	01 d0                	add    %edx,%eax
    aefb:	01 c0                	add    %eax,%eax
    aefd:	89 c2                	mov    %eax,%edx
    aeff:	8b 45 10             	mov    0x10(%ebp),%eax
    af02:	01 d0                	add    %edx,%eax
    af04:	0f b6 00             	movzbl (%eax),%eax
    af07:	0f b6 c0             	movzbl %al,%eax
    af0a:	c1 e0 08             	shl    $0x8,%eax
    af0d:	89 c3                	mov    %eax,%ebx
    af0f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af12:	89 d0                	mov    %edx,%eax
    af14:	01 c0                	add    %eax,%eax
    af16:	01 d0                	add    %edx,%eax
    af18:	01 c0                	add    %eax,%eax
    af1a:	8d 50 01             	lea    0x1(%eax),%edx
    af1d:	8b 45 10             	mov    0x10(%ebp),%eax
    af20:	01 d0                	add    %edx,%eax
    af22:	0f b6 00             	movzbl (%eax),%eax
    af25:	0f b6 c0             	movzbl %al,%eax
    af28:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af2b:	8b 45 14             	mov    0x14(%ebp),%eax
    af2e:	8b 40 14             	mov    0x14(%eax),%eax
    af31:	39 c2                	cmp    %eax,%edx
    af33:	0f 85 8f 00 00 00    	jne    afc8 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    af39:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af3c:	89 d0                	mov    %edx,%eax
    af3e:	01 c0                	add    %eax,%eax
    af40:	01 d0                	add    %edx,%eax
    af42:	01 c0                	add    %eax,%eax
    af44:	8d 50 02             	lea    0x2(%eax),%edx
    af47:	8b 45 10             	mov    0x10(%ebp),%eax
    af4a:	01 d0                	add    %edx,%eax
    af4c:	0f b6 00             	movzbl (%eax),%eax
    af4f:	0f b6 c0             	movzbl %al,%eax
    af52:	c1 e0 08             	shl    $0x8,%eax
    af55:	89 c3                	mov    %eax,%ebx
    af57:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af5a:	89 d0                	mov    %edx,%eax
    af5c:	01 c0                	add    %eax,%eax
    af5e:	01 d0                	add    %edx,%eax
    af60:	01 c0                	add    %eax,%eax
    af62:	8d 50 03             	lea    0x3(%eax),%edx
    af65:	8b 45 10             	mov    0x10(%ebp),%eax
    af68:	01 d0                	add    %edx,%eax
    af6a:	0f b6 00             	movzbl (%eax),%eax
    af6d:	0f b6 c0             	movzbl %al,%eax
    af70:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af73:	8b 45 14             	mov    0x14(%ebp),%eax
    af76:	8b 40 18             	mov    0x18(%eax),%eax
    af79:	39 c2                	cmp    %eax,%edx
    af7b:	75 4b                	jne    afc8 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    af7d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af80:	89 d0                	mov    %edx,%eax
    af82:	01 c0                	add    %eax,%eax
    af84:	01 d0                	add    %edx,%eax
    af86:	01 c0                	add    %eax,%eax
    af88:	8d 50 04             	lea    0x4(%eax),%edx
    af8b:	8b 45 10             	mov    0x10(%ebp),%eax
    af8e:	01 d0                	add    %edx,%eax
    af90:	0f b6 00             	movzbl (%eax),%eax
    af93:	0f b6 c0             	movzbl %al,%eax
    af96:	c1 e0 08             	shl    $0x8,%eax
    af99:	89 c3                	mov    %eax,%ebx
    af9b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af9e:	89 d0                	mov    %edx,%eax
    afa0:	01 c0                	add    %eax,%eax
    afa2:	01 d0                	add    %edx,%eax
    afa4:	01 c0                	add    %eax,%eax
    afa6:	8d 50 05             	lea    0x5(%eax),%edx
    afa9:	8b 45 10             	mov    0x10(%ebp),%eax
    afac:	01 d0                	add    %edx,%eax
    afae:	0f b6 00             	movzbl (%eax),%eax
    afb1:	0f b6 c0             	movzbl %al,%eax
    afb4:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    afb7:	8b 45 14             	mov    0x14(%ebp),%eax
    afba:	8b 40 1c             	mov    0x1c(%eax),%eax
    afbd:	39 c2                	cmp    %eax,%edx
    afbf:	75 07                	jne    afc8 <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    afc1:	b8 00 00 00 00       	mov    $0x0,%eax
    afc6:	eb 05                	jmp    afcd <getPixelColorsRGBA8+0x461>
    afc8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    afcd:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    afcf:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    afd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    afd6:	01 45 08             	add    %eax,0x8(%ebp)
    afd9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    afdc:	3b 45 0c             	cmp    0xc(%ebp),%eax
    afdf:	0f 85 a3 fe ff ff    	jne    ae88 <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    afe5:	e9 4c 02 00 00       	jmp    b236 <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    afea:	8b 45 14             	mov    0x14(%ebp),%eax
    afed:	8b 00                	mov    (%eax),%eax
    afef:	83 f8 03             	cmp    $0x3,%eax
    aff2:	0f 85 b4 00 00 00    	jne    b0ac <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    aff8:	8b 45 14             	mov    0x14(%ebp),%eax
    affb:	8b 40 04             	mov    0x4(%eax),%eax
    affe:	83 f8 08             	cmp    $0x8,%eax
    b001:	75 4d                	jne    b050 <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b003:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b00a:	eb 37                	jmp    b043 <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    b00c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b00f:	8b 45 10             	mov    0x10(%ebp),%eax
    b012:	01 d0                	add    %edx,%eax
    b014:	0f b6 00             	movzbl (%eax),%eax
    b017:	0f b6 c0             	movzbl %al,%eax
    b01a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b01d:	8b 45 14             	mov    0x14(%ebp),%eax
    b020:	8b 40 08             	mov    0x8(%eax),%eax
    b023:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b026:	c1 e2 02             	shl    $0x2,%edx
    b029:	01 d0                	add    %edx,%eax
    b02b:	6a 04                	push   $0x4
    b02d:	50                   	push   %eax
    b02e:	ff 75 08             	pushl  0x8(%ebp)
    b031:	e8 49 83 ff ff       	call   337f <lodepng_memcpy>
    b036:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b039:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b03d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b040:	01 45 08             	add    %eax,0x8(%ebp)
    b043:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b046:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b049:	75 c1                	jne    b00c <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b04b:	e9 e6 01 00 00       	jmp    b236 <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    b050:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b057:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b05e:	eb 3f                	jmp    b09f <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b060:	8b 45 14             	mov    0x14(%ebp),%eax
    b063:	8b 40 04             	mov    0x4(%eax),%eax
    b066:	50                   	push   %eax
    b067:	ff 75 10             	pushl  0x10(%ebp)
    b06a:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b06d:	50                   	push   %eax
    b06e:	e8 71 d1 ff ff       	call   81e4 <readBitsFromReversedStream>
    b073:	83 c4 0c             	add    $0xc,%esp
    b076:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b079:	8b 45 14             	mov    0x14(%ebp),%eax
    b07c:	8b 40 08             	mov    0x8(%eax),%eax
    b07f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b082:	c1 e2 02             	shl    $0x2,%edx
    b085:	01 d0                	add    %edx,%eax
    b087:	6a 04                	push   $0x4
    b089:	50                   	push   %eax
    b08a:	ff 75 08             	pushl  0x8(%ebp)
    b08d:	e8 ed 82 ff ff       	call   337f <lodepng_memcpy>
    b092:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b095:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b099:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b09c:	01 45 08             	add    %eax,0x8(%ebp)
    b09f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b0a2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b0a5:	75 b9                	jne    b060 <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b0a7:	e9 8a 01 00 00       	jmp    b236 <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b0ac:	8b 45 14             	mov    0x14(%ebp),%eax
    b0af:	8b 00                	mov    (%eax),%eax
    b0b1:	83 f8 04             	cmp    $0x4,%eax
    b0b4:	0f 85 d1 00 00 00    	jne    b18b <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b0ba:	8b 45 14             	mov    0x14(%ebp),%eax
    b0bd:	8b 40 04             	mov    0x4(%eax),%eax
    b0c0:	83 f8 08             	cmp    $0x8,%eax
    b0c3:	75 62                	jne    b127 <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0c5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b0cc:	eb 4c                	jmp    b11a <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b0ce:	8b 45 08             	mov    0x8(%ebp),%eax
    b0d1:	83 c0 01             	add    $0x1,%eax
    b0d4:	8b 55 08             	mov    0x8(%ebp),%edx
    b0d7:	83 c2 02             	add    $0x2,%edx
    b0da:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b0dd:	01 c9                	add    %ecx,%ecx
    b0df:	89 cb                	mov    %ecx,%ebx
    b0e1:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b0e4:	01 d9                	add    %ebx,%ecx
    b0e6:	0f b6 09             	movzbl (%ecx),%ecx
    b0e9:	88 0a                	mov    %cl,(%edx)
    b0eb:	0f b6 12             	movzbl (%edx),%edx
    b0ee:	88 10                	mov    %dl,(%eax)
    b0f0:	0f b6 10             	movzbl (%eax),%edx
    b0f3:	8b 45 08             	mov    0x8(%ebp),%eax
    b0f6:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b0f8:	8b 45 08             	mov    0x8(%ebp),%eax
    b0fb:	8d 50 03             	lea    0x3(%eax),%edx
    b0fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b101:	01 c0                	add    %eax,%eax
    b103:	8d 48 01             	lea    0x1(%eax),%ecx
    b106:	8b 45 10             	mov    0x10(%ebp),%eax
    b109:	01 c8                	add    %ecx,%eax
    b10b:	0f b6 00             	movzbl (%eax),%eax
    b10e:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b110:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b114:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b117:	01 45 08             	add    %eax,0x8(%ebp)
    b11a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b11d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b120:	75 ac                	jne    b0ce <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b122:	e9 0f 01 00 00       	jmp    b236 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b127:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b12e:	eb 4e                	jmp    b17e <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b130:	8b 45 08             	mov    0x8(%ebp),%eax
    b133:	83 c0 01             	add    $0x1,%eax
    b136:	8b 55 08             	mov    0x8(%ebp),%edx
    b139:	83 c2 02             	add    $0x2,%edx
    b13c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b13f:	c1 e1 02             	shl    $0x2,%ecx
    b142:	89 cb                	mov    %ecx,%ebx
    b144:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b147:	01 d9                	add    %ebx,%ecx
    b149:	0f b6 09             	movzbl (%ecx),%ecx
    b14c:	88 0a                	mov    %cl,(%edx)
    b14e:	0f b6 12             	movzbl (%edx),%edx
    b151:	88 10                	mov    %dl,(%eax)
    b153:	0f b6 10             	movzbl (%eax),%edx
    b156:	8b 45 08             	mov    0x8(%ebp),%eax
    b159:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b15b:	8b 45 08             	mov    0x8(%ebp),%eax
    b15e:	8d 50 03             	lea    0x3(%eax),%edx
    b161:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b164:	c1 e0 02             	shl    $0x2,%eax
    b167:	8d 48 02             	lea    0x2(%eax),%ecx
    b16a:	8b 45 10             	mov    0x10(%ebp),%eax
    b16d:	01 c8                	add    %ecx,%eax
    b16f:	0f b6 00             	movzbl (%eax),%eax
    b172:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b174:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b178:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b17b:	01 45 08             	add    %eax,0x8(%ebp)
    b17e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b181:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b184:	75 aa                	jne    b130 <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b186:	e9 ab 00 00 00       	jmp    b236 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b18b:	8b 45 14             	mov    0x14(%ebp),%eax
    b18e:	8b 00                	mov    (%eax),%eax
    b190:	83 f8 06             	cmp    $0x6,%eax
    b193:	0f 85 9d 00 00 00    	jne    b236 <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b199:	8b 45 14             	mov    0x14(%ebp),%eax
    b19c:	8b 40 04             	mov    0x4(%eax),%eax
    b19f:	83 f8 08             	cmp    $0x8,%eax
    b1a2:	75 17                	jne    b1bb <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b1a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    b1a7:	c1 e0 02             	shl    $0x2,%eax
    b1aa:	50                   	push   %eax
    b1ab:	ff 75 10             	pushl  0x10(%ebp)
    b1ae:	ff 75 08             	pushl  0x8(%ebp)
    b1b1:	e8 c9 81 ff ff       	call   337f <lodepng_memcpy>
    b1b6:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b1b9:	eb 7b                	jmp    b236 <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1bb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b1c2:	eb 6a                	jmp    b22e <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b1c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1c7:	c1 e0 03             	shl    $0x3,%eax
    b1ca:	89 c2                	mov    %eax,%edx
    b1cc:	8b 45 10             	mov    0x10(%ebp),%eax
    b1cf:	01 d0                	add    %edx,%eax
    b1d1:	0f b6 10             	movzbl (%eax),%edx
    b1d4:	8b 45 08             	mov    0x8(%ebp),%eax
    b1d7:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b1d9:	8b 45 08             	mov    0x8(%ebp),%eax
    b1dc:	8d 50 01             	lea    0x1(%eax),%edx
    b1df:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1e2:	c1 e0 03             	shl    $0x3,%eax
    b1e5:	8d 48 02             	lea    0x2(%eax),%ecx
    b1e8:	8b 45 10             	mov    0x10(%ebp),%eax
    b1eb:	01 c8                	add    %ecx,%eax
    b1ed:	0f b6 00             	movzbl (%eax),%eax
    b1f0:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b1f2:	8b 45 08             	mov    0x8(%ebp),%eax
    b1f5:	8d 50 02             	lea    0x2(%eax),%edx
    b1f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1fb:	c1 e0 03             	shl    $0x3,%eax
    b1fe:	8d 48 04             	lea    0x4(%eax),%ecx
    b201:	8b 45 10             	mov    0x10(%ebp),%eax
    b204:	01 c8                	add    %ecx,%eax
    b206:	0f b6 00             	movzbl (%eax),%eax
    b209:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b20b:	8b 45 08             	mov    0x8(%ebp),%eax
    b20e:	8d 50 03             	lea    0x3(%eax),%edx
    b211:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b214:	c1 e0 03             	shl    $0x3,%eax
    b217:	8d 48 06             	lea    0x6(%eax),%ecx
    b21a:	8b 45 10             	mov    0x10(%ebp),%eax
    b21d:	01 c8                	add    %ecx,%eax
    b21f:	0f b6 00             	movzbl (%eax),%eax
    b222:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b224:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b228:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b22b:	01 45 08             	add    %eax,0x8(%ebp)
    b22e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b231:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b234:	75 8e                	jne    b1c4 <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b236:	90                   	nop
    b237:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b23a:	c9                   	leave  
    b23b:	c3                   	ret    

0000b23c <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b23c:	55                   	push   %ebp
    b23d:	89 e5                	mov    %esp,%ebp
    b23f:	53                   	push   %ebx
    b240:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b243:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b24a:	8b 45 14             	mov    0x14(%ebp),%eax
    b24d:	8b 00                	mov    (%eax),%eax
    b24f:	85 c0                	test   %eax,%eax
    b251:	0f 85 2a 01 00 00    	jne    b381 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b257:	8b 45 14             	mov    0x14(%ebp),%eax
    b25a:	8b 40 04             	mov    0x4(%eax),%eax
    b25d:	83 f8 08             	cmp    $0x8,%eax
    b260:	75 46                	jne    b2a8 <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b262:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b269:	eb 30                	jmp    b29b <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b26b:	8b 45 08             	mov    0x8(%ebp),%eax
    b26e:	83 c0 01             	add    $0x1,%eax
    b271:	8b 55 08             	mov    0x8(%ebp),%edx
    b274:	83 c2 02             	add    $0x2,%edx
    b277:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b27a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b27d:	01 d9                	add    %ebx,%ecx
    b27f:	0f b6 09             	movzbl (%ecx),%ecx
    b282:	88 0a                	mov    %cl,(%edx)
    b284:	0f b6 12             	movzbl (%edx),%edx
    b287:	88 10                	mov    %dl,(%eax)
    b289:	0f b6 10             	movzbl (%eax),%edx
    b28c:	8b 45 08             	mov    0x8(%ebp),%eax
    b28f:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b291:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b295:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b298:	01 45 08             	add    %eax,0x8(%ebp)
    b29b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b29e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b2a1:	75 c8                	jne    b26b <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b2a3:	e9 a8 03 00 00       	jmp    b650 <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b2a8:	8b 45 14             	mov    0x14(%ebp),%eax
    b2ab:	8b 40 04             	mov    0x4(%eax),%eax
    b2ae:	83 f8 10             	cmp    $0x10,%eax
    b2b1:	75 4a                	jne    b2fd <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2b3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b2ba:	eb 34                	jmp    b2f0 <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b2bc:	8b 45 08             	mov    0x8(%ebp),%eax
    b2bf:	83 c0 01             	add    $0x1,%eax
    b2c2:	8b 55 08             	mov    0x8(%ebp),%edx
    b2c5:	83 c2 02             	add    $0x2,%edx
    b2c8:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b2cb:	01 c9                	add    %ecx,%ecx
    b2cd:	89 cb                	mov    %ecx,%ebx
    b2cf:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b2d2:	01 d9                	add    %ebx,%ecx
    b2d4:	0f b6 09             	movzbl (%ecx),%ecx
    b2d7:	88 0a                	mov    %cl,(%edx)
    b2d9:	0f b6 12             	movzbl (%edx),%edx
    b2dc:	88 10                	mov    %dl,(%eax)
    b2de:	0f b6 10             	movzbl (%eax),%edx
    b2e1:	8b 45 08             	mov    0x8(%ebp),%eax
    b2e4:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2e6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b2ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b2ed:	01 45 08             	add    %eax,0x8(%ebp)
    b2f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2f3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b2f6:	75 c4                	jne    b2bc <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b2f8:	e9 53 03 00 00       	jmp    b650 <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b2fd:	8b 45 14             	mov    0x14(%ebp),%eax
    b300:	8b 40 04             	mov    0x4(%eax),%eax
    b303:	ba 01 00 00 00       	mov    $0x1,%edx
    b308:	89 c1                	mov    %eax,%ecx
    b30a:	d3 e2                	shl    %cl,%edx
    b30c:	89 d0                	mov    %edx,%eax
    b30e:	83 e8 01             	sub    $0x1,%eax
    b311:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b314:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b31b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b322:	eb 50                	jmp    b374 <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b324:	8b 45 14             	mov    0x14(%ebp),%eax
    b327:	8b 40 04             	mov    0x4(%eax),%eax
    b32a:	50                   	push   %eax
    b32b:	ff 75 10             	pushl  0x10(%ebp)
    b32e:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b331:	50                   	push   %eax
    b332:	e8 ad ce ff ff       	call   81e4 <readBitsFromReversedStream>
    b337:	83 c4 0c             	add    $0xc,%esp
    b33a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b33d:	8b 45 08             	mov    0x8(%ebp),%eax
    b340:	8d 48 01             	lea    0x1(%eax),%ecx
    b343:	8b 45 08             	mov    0x8(%ebp),%eax
    b346:	8d 58 02             	lea    0x2(%eax),%ebx
    b349:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b34c:	89 d0                	mov    %edx,%eax
    b34e:	c1 e0 08             	shl    $0x8,%eax
    b351:	29 d0                	sub    %edx,%eax
    b353:	ba 00 00 00 00       	mov    $0x0,%edx
    b358:	f7 75 f0             	divl   -0x10(%ebp)
    b35b:	88 03                	mov    %al,(%ebx)
    b35d:	0f b6 03             	movzbl (%ebx),%eax
    b360:	88 01                	mov    %al,(%ecx)
    b362:	0f b6 11             	movzbl (%ecx),%edx
    b365:	8b 45 08             	mov    0x8(%ebp),%eax
    b368:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b36a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b36e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b371:	01 45 08             	add    %eax,0x8(%ebp)
    b374:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b377:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b37a:	75 a8                	jne    b324 <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b37c:	e9 cf 02 00 00       	jmp    b650 <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b381:	8b 45 14             	mov    0x14(%ebp),%eax
    b384:	8b 00                	mov    (%eax),%eax
    b386:	83 f8 02             	cmp    $0x2,%eax
    b389:	0f 85 9e 00 00 00    	jne    b42d <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    b38f:	8b 45 14             	mov    0x14(%ebp),%eax
    b392:	8b 40 04             	mov    0x4(%eax),%eax
    b395:	83 f8 08             	cmp    $0x8,%eax
    b398:	75 1d                	jne    b3b7 <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    b39a:	8b 55 0c             	mov    0xc(%ebp),%edx
    b39d:	89 d0                	mov    %edx,%eax
    b39f:	01 c0                	add    %eax,%eax
    b3a1:	01 d0                	add    %edx,%eax
    b3a3:	50                   	push   %eax
    b3a4:	ff 75 10             	pushl  0x10(%ebp)
    b3a7:	ff 75 08             	pushl  0x8(%ebp)
    b3aa:	e8 d0 7f ff ff       	call   337f <lodepng_memcpy>
    b3af:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b3b2:	e9 99 02 00 00       	jmp    b650 <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3b7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b3be:	eb 60                	jmp    b420 <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    b3c0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3c3:	89 d0                	mov    %edx,%eax
    b3c5:	01 c0                	add    %eax,%eax
    b3c7:	01 d0                	add    %edx,%eax
    b3c9:	01 c0                	add    %eax,%eax
    b3cb:	89 c2                	mov    %eax,%edx
    b3cd:	8b 45 10             	mov    0x10(%ebp),%eax
    b3d0:	01 d0                	add    %edx,%eax
    b3d2:	0f b6 10             	movzbl (%eax),%edx
    b3d5:	8b 45 08             	mov    0x8(%ebp),%eax
    b3d8:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b3da:	8b 45 08             	mov    0x8(%ebp),%eax
    b3dd:	8d 48 01             	lea    0x1(%eax),%ecx
    b3e0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3e3:	89 d0                	mov    %edx,%eax
    b3e5:	01 c0                	add    %eax,%eax
    b3e7:	01 d0                	add    %edx,%eax
    b3e9:	01 c0                	add    %eax,%eax
    b3eb:	8d 50 02             	lea    0x2(%eax),%edx
    b3ee:	8b 45 10             	mov    0x10(%ebp),%eax
    b3f1:	01 d0                	add    %edx,%eax
    b3f3:	0f b6 00             	movzbl (%eax),%eax
    b3f6:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b3f8:	8b 45 08             	mov    0x8(%ebp),%eax
    b3fb:	8d 48 02             	lea    0x2(%eax),%ecx
    b3fe:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b401:	89 d0                	mov    %edx,%eax
    b403:	01 c0                	add    %eax,%eax
    b405:	01 d0                	add    %edx,%eax
    b407:	01 c0                	add    %eax,%eax
    b409:	8d 50 04             	lea    0x4(%eax),%edx
    b40c:	8b 45 10             	mov    0x10(%ebp),%eax
    b40f:	01 d0                	add    %edx,%eax
    b411:	0f b6 00             	movzbl (%eax),%eax
    b414:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b416:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b41a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b41d:	01 45 08             	add    %eax,0x8(%ebp)
    b420:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b423:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b426:	75 98                	jne    b3c0 <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b428:	e9 23 02 00 00       	jmp    b650 <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b42d:	8b 45 14             	mov    0x14(%ebp),%eax
    b430:	8b 00                	mov    (%eax),%eax
    b432:	83 f8 03             	cmp    $0x3,%eax
    b435:	0f 85 b4 00 00 00    	jne    b4ef <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    b43b:	8b 45 14             	mov    0x14(%ebp),%eax
    b43e:	8b 40 04             	mov    0x4(%eax),%eax
    b441:	83 f8 08             	cmp    $0x8,%eax
    b444:	75 4d                	jne    b493 <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b446:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b44d:	eb 37                	jmp    b486 <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    b44f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b452:	8b 45 10             	mov    0x10(%ebp),%eax
    b455:	01 d0                	add    %edx,%eax
    b457:	0f b6 00             	movzbl (%eax),%eax
    b45a:	0f b6 c0             	movzbl %al,%eax
    b45d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b460:	8b 45 14             	mov    0x14(%ebp),%eax
    b463:	8b 40 08             	mov    0x8(%eax),%eax
    b466:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b469:	c1 e2 02             	shl    $0x2,%edx
    b46c:	01 d0                	add    %edx,%eax
    b46e:	6a 03                	push   $0x3
    b470:	50                   	push   %eax
    b471:	ff 75 08             	pushl  0x8(%ebp)
    b474:	e8 06 7f ff ff       	call   337f <lodepng_memcpy>
    b479:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b47c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b480:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b483:	01 45 08             	add    %eax,0x8(%ebp)
    b486:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b489:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b48c:	75 c1                	jne    b44f <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b48e:	e9 bd 01 00 00       	jmp    b650 <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    b493:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b49a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b4a1:	eb 3f                	jmp    b4e2 <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b4a3:	8b 45 14             	mov    0x14(%ebp),%eax
    b4a6:	8b 40 04             	mov    0x4(%eax),%eax
    b4a9:	50                   	push   %eax
    b4aa:	ff 75 10             	pushl  0x10(%ebp)
    b4ad:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b4b0:	50                   	push   %eax
    b4b1:	e8 2e cd ff ff       	call   81e4 <readBitsFromReversedStream>
    b4b6:	83 c4 0c             	add    $0xc,%esp
    b4b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b4bc:	8b 45 14             	mov    0x14(%ebp),%eax
    b4bf:	8b 40 08             	mov    0x8(%eax),%eax
    b4c2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b4c5:	c1 e2 02             	shl    $0x2,%edx
    b4c8:	01 d0                	add    %edx,%eax
    b4ca:	6a 03                	push   $0x3
    b4cc:	50                   	push   %eax
    b4cd:	ff 75 08             	pushl  0x8(%ebp)
    b4d0:	e8 aa 7e ff ff       	call   337f <lodepng_memcpy>
    b4d5:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4d8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b4dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b4df:	01 45 08             	add    %eax,0x8(%ebp)
    b4e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4e5:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b4e8:	75 b9                	jne    b4a3 <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b4ea:	e9 61 01 00 00       	jmp    b650 <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b4ef:	8b 45 14             	mov    0x14(%ebp),%eax
    b4f2:	8b 00                	mov    (%eax),%eax
    b4f4:	83 f8 04             	cmp    $0x4,%eax
    b4f7:	0f 85 a0 00 00 00    	jne    b59d <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    b4fd:	8b 45 14             	mov    0x14(%ebp),%eax
    b500:	8b 40 04             	mov    0x4(%eax),%eax
    b503:	83 f8 08             	cmp    $0x8,%eax
    b506:	75 4a                	jne    b552 <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b508:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b50f:	eb 34                	jmp    b545 <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b511:	8b 45 08             	mov    0x8(%ebp),%eax
    b514:	83 c0 01             	add    $0x1,%eax
    b517:	8b 55 08             	mov    0x8(%ebp),%edx
    b51a:	83 c2 02             	add    $0x2,%edx
    b51d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b520:	01 c9                	add    %ecx,%ecx
    b522:	89 cb                	mov    %ecx,%ebx
    b524:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b527:	01 d9                	add    %ebx,%ecx
    b529:	0f b6 09             	movzbl (%ecx),%ecx
    b52c:	88 0a                	mov    %cl,(%edx)
    b52e:	0f b6 12             	movzbl (%edx),%edx
    b531:	88 10                	mov    %dl,(%eax)
    b533:	0f b6 10             	movzbl (%eax),%edx
    b536:	8b 45 08             	mov    0x8(%ebp),%eax
    b539:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b53b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b53f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b542:	01 45 08             	add    %eax,0x8(%ebp)
    b545:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b548:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b54b:	75 c4                	jne    b511 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b54d:	e9 fe 00 00 00       	jmp    b650 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b552:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b559:	eb 35                	jmp    b590 <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b55b:	8b 45 08             	mov    0x8(%ebp),%eax
    b55e:	83 c0 01             	add    $0x1,%eax
    b561:	8b 55 08             	mov    0x8(%ebp),%edx
    b564:	83 c2 02             	add    $0x2,%edx
    b567:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b56a:	c1 e1 02             	shl    $0x2,%ecx
    b56d:	89 cb                	mov    %ecx,%ebx
    b56f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b572:	01 d9                	add    %ebx,%ecx
    b574:	0f b6 09             	movzbl (%ecx),%ecx
    b577:	88 0a                	mov    %cl,(%edx)
    b579:	0f b6 12             	movzbl (%edx),%edx
    b57c:	88 10                	mov    %dl,(%eax)
    b57e:	0f b6 10             	movzbl (%eax),%edx
    b581:	8b 45 08             	mov    0x8(%ebp),%eax
    b584:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b586:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b58a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b58d:	01 45 08             	add    %eax,0x8(%ebp)
    b590:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b593:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b596:	75 c3                	jne    b55b <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b598:	e9 b3 00 00 00       	jmp    b650 <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b59d:	8b 45 14             	mov    0x14(%ebp),%eax
    b5a0:	8b 00                	mov    (%eax),%eax
    b5a2:	83 f8 06             	cmp    $0x6,%eax
    b5a5:	0f 85 a5 00 00 00    	jne    b650 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    b5ab:	8b 45 14             	mov    0x14(%ebp),%eax
    b5ae:	8b 40 04             	mov    0x4(%eax),%eax
    b5b1:	83 f8 08             	cmp    $0x8,%eax
    b5b4:	75 38                	jne    b5ee <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5b6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b5bd:	eb 25                	jmp    b5e4 <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    b5bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5c2:	c1 e0 02             	shl    $0x2,%eax
    b5c5:	89 c2                	mov    %eax,%edx
    b5c7:	8b 45 10             	mov    0x10(%ebp),%eax
    b5ca:	01 d0                	add    %edx,%eax
    b5cc:	6a 03                	push   $0x3
    b5ce:	50                   	push   %eax
    b5cf:	ff 75 08             	pushl  0x8(%ebp)
    b5d2:	e8 a8 7d ff ff       	call   337f <lodepng_memcpy>
    b5d7:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5da:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b5de:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5e1:	01 45 08             	add    %eax,0x8(%ebp)
    b5e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5e7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b5ea:	75 d3                	jne    b5bf <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b5ec:	eb 62                	jmp    b650 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5ee:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b5f5:	eb 51                	jmp    b648 <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    b5f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5fa:	c1 e0 03             	shl    $0x3,%eax
    b5fd:	89 c2                	mov    %eax,%edx
    b5ff:	8b 45 10             	mov    0x10(%ebp),%eax
    b602:	01 d0                	add    %edx,%eax
    b604:	0f b6 10             	movzbl (%eax),%edx
    b607:	8b 45 08             	mov    0x8(%ebp),%eax
    b60a:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b60c:	8b 45 08             	mov    0x8(%ebp),%eax
    b60f:	8d 50 01             	lea    0x1(%eax),%edx
    b612:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b615:	c1 e0 03             	shl    $0x3,%eax
    b618:	8d 48 02             	lea    0x2(%eax),%ecx
    b61b:	8b 45 10             	mov    0x10(%ebp),%eax
    b61e:	01 c8                	add    %ecx,%eax
    b620:	0f b6 00             	movzbl (%eax),%eax
    b623:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b625:	8b 45 08             	mov    0x8(%ebp),%eax
    b628:	8d 50 02             	lea    0x2(%eax),%edx
    b62b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b62e:	c1 e0 03             	shl    $0x3,%eax
    b631:	8d 48 04             	lea    0x4(%eax),%ecx
    b634:	8b 45 10             	mov    0x10(%ebp),%eax
    b637:	01 c8                	add    %ecx,%eax
    b639:	0f b6 00             	movzbl (%eax),%eax
    b63c:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b63e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b642:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b645:	01 45 08             	add    %eax,0x8(%ebp)
    b648:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b64b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b64e:	75 a7                	jne    b5f7 <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b650:	90                   	nop
    b651:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b654:	c9                   	leave  
    b655:	c3                   	ret    

0000b656 <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    b656:	55                   	push   %ebp
    b657:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    b659:	8b 45 20             	mov    0x20(%ebp),%eax
    b65c:	8b 00                	mov    (%eax),%eax
    b65e:	85 c0                	test   %eax,%eax
    b660:	0f 85 a4 00 00 00    	jne    b70a <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    b666:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b669:	01 c0                	add    %eax,%eax
    b66b:	89 c2                	mov    %eax,%edx
    b66d:	8b 45 18             	mov    0x18(%ebp),%eax
    b670:	01 d0                	add    %edx,%eax
    b672:	0f b6 00             	movzbl (%eax),%eax
    b675:	0f b6 c0             	movzbl %al,%eax
    b678:	c1 e0 08             	shl    $0x8,%eax
    b67b:	89 c2                	mov    %eax,%edx
    b67d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b680:	01 c0                	add    %eax,%eax
    b682:	8d 48 01             	lea    0x1(%eax),%ecx
    b685:	8b 45 18             	mov    0x18(%ebp),%eax
    b688:	01 c8                	add    %ecx,%eax
    b68a:	0f b6 00             	movzbl (%eax),%eax
    b68d:	0f b6 c0             	movzbl %al,%eax
    b690:	01 c2                	add    %eax,%edx
    b692:	8b 45 10             	mov    0x10(%ebp),%eax
    b695:	66 89 10             	mov    %dx,(%eax)
    b698:	8b 45 10             	mov    0x10(%ebp),%eax
    b69b:	0f b7 10             	movzwl (%eax),%edx
    b69e:	8b 45 0c             	mov    0xc(%ebp),%eax
    b6a1:	66 89 10             	mov    %dx,(%eax)
    b6a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    b6a7:	0f b7 10             	movzwl (%eax),%edx
    b6aa:	8b 45 08             	mov    0x8(%ebp),%eax
    b6ad:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    b6b0:	8b 45 20             	mov    0x20(%ebp),%eax
    b6b3:	8b 40 10             	mov    0x10(%eax),%eax
    b6b6:	85 c0                	test   %eax,%eax
    b6b8:	74 43                	je     b6fd <getPixelColorRGBA16+0xa7>
    b6ba:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b6bd:	01 c0                	add    %eax,%eax
    b6bf:	89 c2                	mov    %eax,%edx
    b6c1:	8b 45 18             	mov    0x18(%ebp),%eax
    b6c4:	01 d0                	add    %edx,%eax
    b6c6:	0f b6 00             	movzbl (%eax),%eax
    b6c9:	0f b6 c0             	movzbl %al,%eax
    b6cc:	c1 e0 08             	shl    $0x8,%eax
    b6cf:	89 c2                	mov    %eax,%edx
    b6d1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b6d4:	01 c0                	add    %eax,%eax
    b6d6:	8d 48 01             	lea    0x1(%eax),%ecx
    b6d9:	8b 45 18             	mov    0x18(%ebp),%eax
    b6dc:	01 c8                	add    %ecx,%eax
    b6de:	0f b6 00             	movzbl (%eax),%eax
    b6e1:	0f b6 c0             	movzbl %al,%eax
    b6e4:	01 c2                	add    %eax,%edx
    b6e6:	8b 45 20             	mov    0x20(%ebp),%eax
    b6e9:	8b 40 14             	mov    0x14(%eax),%eax
    b6ec:	39 c2                	cmp    %eax,%edx
    b6ee:	75 0d                	jne    b6fd <getPixelColorRGBA16+0xa7>
    b6f0:	8b 45 14             	mov    0x14(%ebp),%eax
    b6f3:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b6f8:	e9 48 03 00 00       	jmp    ba45 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b6fd:	8b 45 14             	mov    0x14(%ebp),%eax
    b700:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b705:	e9 3b 03 00 00       	jmp    ba45 <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    b70a:	8b 45 20             	mov    0x20(%ebp),%eax
    b70d:	8b 00                	mov    (%eax),%eax
    b70f:	83 f8 02             	cmp    $0x2,%eax
    b712:	0f 85 b6 01 00 00    	jne    b8ce <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    b718:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b71b:	89 d0                	mov    %edx,%eax
    b71d:	01 c0                	add    %eax,%eax
    b71f:	01 d0                	add    %edx,%eax
    b721:	01 c0                	add    %eax,%eax
    b723:	89 c2                	mov    %eax,%edx
    b725:	8b 45 18             	mov    0x18(%ebp),%eax
    b728:	01 d0                	add    %edx,%eax
    b72a:	0f b6 00             	movzbl (%eax),%eax
    b72d:	0f b6 c0             	movzbl %al,%eax
    b730:	c1 e0 08             	shl    $0x8,%eax
    b733:	89 c1                	mov    %eax,%ecx
    b735:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b738:	89 d0                	mov    %edx,%eax
    b73a:	01 c0                	add    %eax,%eax
    b73c:	01 d0                	add    %edx,%eax
    b73e:	01 c0                	add    %eax,%eax
    b740:	8d 50 01             	lea    0x1(%eax),%edx
    b743:	8b 45 18             	mov    0x18(%ebp),%eax
    b746:	01 d0                	add    %edx,%eax
    b748:	0f b6 00             	movzbl (%eax),%eax
    b74b:	0f b6 c0             	movzbl %al,%eax
    b74e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b751:	8b 45 08             	mov    0x8(%ebp),%eax
    b754:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    b757:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b75a:	89 d0                	mov    %edx,%eax
    b75c:	01 c0                	add    %eax,%eax
    b75e:	01 d0                	add    %edx,%eax
    b760:	01 c0                	add    %eax,%eax
    b762:	8d 50 02             	lea    0x2(%eax),%edx
    b765:	8b 45 18             	mov    0x18(%ebp),%eax
    b768:	01 d0                	add    %edx,%eax
    b76a:	0f b6 00             	movzbl (%eax),%eax
    b76d:	0f b6 c0             	movzbl %al,%eax
    b770:	c1 e0 08             	shl    $0x8,%eax
    b773:	89 c1                	mov    %eax,%ecx
    b775:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b778:	89 d0                	mov    %edx,%eax
    b77a:	01 c0                	add    %eax,%eax
    b77c:	01 d0                	add    %edx,%eax
    b77e:	01 c0                	add    %eax,%eax
    b780:	8d 50 03             	lea    0x3(%eax),%edx
    b783:	8b 45 18             	mov    0x18(%ebp),%eax
    b786:	01 d0                	add    %edx,%eax
    b788:	0f b6 00             	movzbl (%eax),%eax
    b78b:	0f b6 c0             	movzbl %al,%eax
    b78e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b791:	8b 45 0c             	mov    0xc(%ebp),%eax
    b794:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    b797:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b79a:	89 d0                	mov    %edx,%eax
    b79c:	01 c0                	add    %eax,%eax
    b79e:	01 d0                	add    %edx,%eax
    b7a0:	01 c0                	add    %eax,%eax
    b7a2:	8d 50 04             	lea    0x4(%eax),%edx
    b7a5:	8b 45 18             	mov    0x18(%ebp),%eax
    b7a8:	01 d0                	add    %edx,%eax
    b7aa:	0f b6 00             	movzbl (%eax),%eax
    b7ad:	0f b6 c0             	movzbl %al,%eax
    b7b0:	c1 e0 08             	shl    $0x8,%eax
    b7b3:	89 c1                	mov    %eax,%ecx
    b7b5:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7b8:	89 d0                	mov    %edx,%eax
    b7ba:	01 c0                	add    %eax,%eax
    b7bc:	01 d0                	add    %edx,%eax
    b7be:	01 c0                	add    %eax,%eax
    b7c0:	8d 50 05             	lea    0x5(%eax),%edx
    b7c3:	8b 45 18             	mov    0x18(%ebp),%eax
    b7c6:	01 d0                	add    %edx,%eax
    b7c8:	0f b6 00             	movzbl (%eax),%eax
    b7cb:	0f b6 c0             	movzbl %al,%eax
    b7ce:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b7d1:	8b 45 10             	mov    0x10(%ebp),%eax
    b7d4:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    b7d7:	8b 45 20             	mov    0x20(%ebp),%eax
    b7da:	8b 40 10             	mov    0x10(%eax),%eax
    b7dd:	85 c0                	test   %eax,%eax
    b7df:	0f 84 dc 00 00 00    	je     b8c1 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b7e5:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7e8:	89 d0                	mov    %edx,%eax
    b7ea:	01 c0                	add    %eax,%eax
    b7ec:	01 d0                	add    %edx,%eax
    b7ee:	01 c0                	add    %eax,%eax
    b7f0:	89 c2                	mov    %eax,%edx
    b7f2:	8b 45 18             	mov    0x18(%ebp),%eax
    b7f5:	01 d0                	add    %edx,%eax
    b7f7:	0f b6 00             	movzbl (%eax),%eax
    b7fa:	0f b6 c0             	movzbl %al,%eax
    b7fd:	c1 e0 08             	shl    $0x8,%eax
    b800:	89 c1                	mov    %eax,%ecx
    b802:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b805:	89 d0                	mov    %edx,%eax
    b807:	01 c0                	add    %eax,%eax
    b809:	01 d0                	add    %edx,%eax
    b80b:	01 c0                	add    %eax,%eax
    b80d:	8d 50 01             	lea    0x1(%eax),%edx
    b810:	8b 45 18             	mov    0x18(%ebp),%eax
    b813:	01 d0                	add    %edx,%eax
    b815:	0f b6 00             	movzbl (%eax),%eax
    b818:	0f b6 c0             	movzbl %al,%eax
    b81b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b81e:	8b 45 20             	mov    0x20(%ebp),%eax
    b821:	8b 40 14             	mov    0x14(%eax),%eax
    b824:	39 c2                	cmp    %eax,%edx
    b826:	0f 85 95 00 00 00    	jne    b8c1 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b82c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b82f:	89 d0                	mov    %edx,%eax
    b831:	01 c0                	add    %eax,%eax
    b833:	01 d0                	add    %edx,%eax
    b835:	01 c0                	add    %eax,%eax
    b837:	8d 50 02             	lea    0x2(%eax),%edx
    b83a:	8b 45 18             	mov    0x18(%ebp),%eax
    b83d:	01 d0                	add    %edx,%eax
    b83f:	0f b6 00             	movzbl (%eax),%eax
    b842:	0f b6 c0             	movzbl %al,%eax
    b845:	c1 e0 08             	shl    $0x8,%eax
    b848:	89 c1                	mov    %eax,%ecx
    b84a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b84d:	89 d0                	mov    %edx,%eax
    b84f:	01 c0                	add    %eax,%eax
    b851:	01 d0                	add    %edx,%eax
    b853:	01 c0                	add    %eax,%eax
    b855:	8d 50 03             	lea    0x3(%eax),%edx
    b858:	8b 45 18             	mov    0x18(%ebp),%eax
    b85b:	01 d0                	add    %edx,%eax
    b85d:	0f b6 00             	movzbl (%eax),%eax
    b860:	0f b6 c0             	movzbl %al,%eax
    b863:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b866:	8b 45 20             	mov    0x20(%ebp),%eax
    b869:	8b 40 18             	mov    0x18(%eax),%eax
    b86c:	39 c2                	cmp    %eax,%edx
    b86e:	75 51                	jne    b8c1 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    b870:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b873:	89 d0                	mov    %edx,%eax
    b875:	01 c0                	add    %eax,%eax
    b877:	01 d0                	add    %edx,%eax
    b879:	01 c0                	add    %eax,%eax
    b87b:	8d 50 04             	lea    0x4(%eax),%edx
    b87e:	8b 45 18             	mov    0x18(%ebp),%eax
    b881:	01 d0                	add    %edx,%eax
    b883:	0f b6 00             	movzbl (%eax),%eax
    b886:	0f b6 c0             	movzbl %al,%eax
    b889:	c1 e0 08             	shl    $0x8,%eax
    b88c:	89 c1                	mov    %eax,%ecx
    b88e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b891:	89 d0                	mov    %edx,%eax
    b893:	01 c0                	add    %eax,%eax
    b895:	01 d0                	add    %edx,%eax
    b897:	01 c0                	add    %eax,%eax
    b899:	8d 50 05             	lea    0x5(%eax),%edx
    b89c:	8b 45 18             	mov    0x18(%ebp),%eax
    b89f:	01 d0                	add    %edx,%eax
    b8a1:	0f b6 00             	movzbl (%eax),%eax
    b8a4:	0f b6 c0             	movzbl %al,%eax
    b8a7:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b8aa:	8b 45 20             	mov    0x20(%ebp),%eax
    b8ad:	8b 40 1c             	mov    0x1c(%eax),%eax
    b8b0:	39 c2                	cmp    %eax,%edx
    b8b2:	75 0d                	jne    b8c1 <getPixelColorRGBA16+0x26b>
    b8b4:	8b 45 14             	mov    0x14(%ebp),%eax
    b8b7:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b8bc:	e9 84 01 00 00       	jmp    ba45 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b8c1:	8b 45 14             	mov    0x14(%ebp),%eax
    b8c4:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b8c9:	e9 77 01 00 00       	jmp    ba45 <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b8ce:	8b 45 20             	mov    0x20(%ebp),%eax
    b8d1:	8b 00                	mov    (%eax),%eax
    b8d3:	83 f8 04             	cmp    $0x4,%eax
    b8d6:	0f 85 86 00 00 00    	jne    b962 <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    b8dc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b8df:	c1 e0 02             	shl    $0x2,%eax
    b8e2:	89 c2                	mov    %eax,%edx
    b8e4:	8b 45 18             	mov    0x18(%ebp),%eax
    b8e7:	01 d0                	add    %edx,%eax
    b8e9:	0f b6 00             	movzbl (%eax),%eax
    b8ec:	0f b6 c0             	movzbl %al,%eax
    b8ef:	c1 e0 08             	shl    $0x8,%eax
    b8f2:	89 c2                	mov    %eax,%edx
    b8f4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b8f7:	c1 e0 02             	shl    $0x2,%eax
    b8fa:	8d 48 01             	lea    0x1(%eax),%ecx
    b8fd:	8b 45 18             	mov    0x18(%ebp),%eax
    b900:	01 c8                	add    %ecx,%eax
    b902:	0f b6 00             	movzbl (%eax),%eax
    b905:	0f b6 c0             	movzbl %al,%eax
    b908:	01 c2                	add    %eax,%edx
    b90a:	8b 45 10             	mov    0x10(%ebp),%eax
    b90d:	66 89 10             	mov    %dx,(%eax)
    b910:	8b 45 10             	mov    0x10(%ebp),%eax
    b913:	0f b7 10             	movzwl (%eax),%edx
    b916:	8b 45 0c             	mov    0xc(%ebp),%eax
    b919:	66 89 10             	mov    %dx,(%eax)
    b91c:	8b 45 0c             	mov    0xc(%ebp),%eax
    b91f:	0f b7 10             	movzwl (%eax),%edx
    b922:	8b 45 08             	mov    0x8(%ebp),%eax
    b925:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    b928:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b92b:	c1 e0 02             	shl    $0x2,%eax
    b92e:	8d 50 02             	lea    0x2(%eax),%edx
    b931:	8b 45 18             	mov    0x18(%ebp),%eax
    b934:	01 d0                	add    %edx,%eax
    b936:	0f b6 00             	movzbl (%eax),%eax
    b939:	0f b6 c0             	movzbl %al,%eax
    b93c:	c1 e0 08             	shl    $0x8,%eax
    b93f:	89 c2                	mov    %eax,%edx
    b941:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b944:	c1 e0 02             	shl    $0x2,%eax
    b947:	8d 48 03             	lea    0x3(%eax),%ecx
    b94a:	8b 45 18             	mov    0x18(%ebp),%eax
    b94d:	01 c8                	add    %ecx,%eax
    b94f:	0f b6 00             	movzbl (%eax),%eax
    b952:	0f b6 c0             	movzbl %al,%eax
    b955:	01 c2                	add    %eax,%edx
    b957:	8b 45 14             	mov    0x14(%ebp),%eax
    b95a:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b95d:	e9 e3 00 00 00       	jmp    ba45 <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    b962:	8b 45 20             	mov    0x20(%ebp),%eax
    b965:	8b 00                	mov    (%eax),%eax
    b967:	83 f8 06             	cmp    $0x6,%eax
    b96a:	0f 85 d5 00 00 00    	jne    ba45 <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    b970:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b973:	c1 e0 03             	shl    $0x3,%eax
    b976:	89 c2                	mov    %eax,%edx
    b978:	8b 45 18             	mov    0x18(%ebp),%eax
    b97b:	01 d0                	add    %edx,%eax
    b97d:	0f b6 00             	movzbl (%eax),%eax
    b980:	0f b6 c0             	movzbl %al,%eax
    b983:	c1 e0 08             	shl    $0x8,%eax
    b986:	89 c2                	mov    %eax,%edx
    b988:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b98b:	c1 e0 03             	shl    $0x3,%eax
    b98e:	8d 48 01             	lea    0x1(%eax),%ecx
    b991:	8b 45 18             	mov    0x18(%ebp),%eax
    b994:	01 c8                	add    %ecx,%eax
    b996:	0f b6 00             	movzbl (%eax),%eax
    b999:	0f b6 c0             	movzbl %al,%eax
    b99c:	01 c2                	add    %eax,%edx
    b99e:	8b 45 08             	mov    0x8(%ebp),%eax
    b9a1:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    b9a4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9a7:	c1 e0 03             	shl    $0x3,%eax
    b9aa:	8d 50 02             	lea    0x2(%eax),%edx
    b9ad:	8b 45 18             	mov    0x18(%ebp),%eax
    b9b0:	01 d0                	add    %edx,%eax
    b9b2:	0f b6 00             	movzbl (%eax),%eax
    b9b5:	0f b6 c0             	movzbl %al,%eax
    b9b8:	c1 e0 08             	shl    $0x8,%eax
    b9bb:	89 c2                	mov    %eax,%edx
    b9bd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9c0:	c1 e0 03             	shl    $0x3,%eax
    b9c3:	8d 48 03             	lea    0x3(%eax),%ecx
    b9c6:	8b 45 18             	mov    0x18(%ebp),%eax
    b9c9:	01 c8                	add    %ecx,%eax
    b9cb:	0f b6 00             	movzbl (%eax),%eax
    b9ce:	0f b6 c0             	movzbl %al,%eax
    b9d1:	01 c2                	add    %eax,%edx
    b9d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9d6:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    b9d9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9dc:	c1 e0 03             	shl    $0x3,%eax
    b9df:	8d 50 04             	lea    0x4(%eax),%edx
    b9e2:	8b 45 18             	mov    0x18(%ebp),%eax
    b9e5:	01 d0                	add    %edx,%eax
    b9e7:	0f b6 00             	movzbl (%eax),%eax
    b9ea:	0f b6 c0             	movzbl %al,%eax
    b9ed:	c1 e0 08             	shl    $0x8,%eax
    b9f0:	89 c2                	mov    %eax,%edx
    b9f2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9f5:	c1 e0 03             	shl    $0x3,%eax
    b9f8:	8d 48 05             	lea    0x5(%eax),%ecx
    b9fb:	8b 45 18             	mov    0x18(%ebp),%eax
    b9fe:	01 c8                	add    %ecx,%eax
    ba00:	0f b6 00             	movzbl (%eax),%eax
    ba03:	0f b6 c0             	movzbl %al,%eax
    ba06:	01 c2                	add    %eax,%edx
    ba08:	8b 45 10             	mov    0x10(%ebp),%eax
    ba0b:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    ba0e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba11:	c1 e0 03             	shl    $0x3,%eax
    ba14:	8d 50 06             	lea    0x6(%eax),%edx
    ba17:	8b 45 18             	mov    0x18(%ebp),%eax
    ba1a:	01 d0                	add    %edx,%eax
    ba1c:	0f b6 00             	movzbl (%eax),%eax
    ba1f:	0f b6 c0             	movzbl %al,%eax
    ba22:	c1 e0 08             	shl    $0x8,%eax
    ba25:	89 c2                	mov    %eax,%edx
    ba27:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba2a:	c1 e0 03             	shl    $0x3,%eax
    ba2d:	8d 48 07             	lea    0x7(%eax),%ecx
    ba30:	8b 45 18             	mov    0x18(%ebp),%eax
    ba33:	01 c8                	add    %ecx,%eax
    ba35:	0f b6 00             	movzbl (%eax),%eax
    ba38:	0f b6 c0             	movzbl %al,%eax
    ba3b:	01 c2                	add    %eax,%edx
    ba3d:	8b 45 14             	mov    0x14(%ebp),%eax
    ba40:	66 89 10             	mov    %dx,(%eax)
  }
}
    ba43:	eb 00                	jmp    ba45 <getPixelColorRGBA16+0x3ef>
    ba45:	90                   	nop
    ba46:	5d                   	pop    %ebp
    ba47:	c3                   	ret    

0000ba48 <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    ba48:	55                   	push   %ebp
    ba49:	89 e5                	mov    %esp,%ebp
    ba4b:	56                   	push   %esi
    ba4c:	53                   	push   %ebx
    ba4d:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    ba50:	8b 55 18             	mov    0x18(%ebp),%edx
    ba53:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba56:	0f af c2             	imul   %edx,%eax
    ba59:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    ba5c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    ba63:	8b 45 14             	mov    0x14(%ebp),%eax
    ba66:	8b 00                	mov    (%eax),%eax
    ba68:	83 f8 03             	cmp    $0x3,%eax
    ba6b:	75 14                	jne    ba81 <lodepng_convert+0x39>
    ba6d:	8b 45 14             	mov    0x14(%ebp),%eax
    ba70:	8b 40 08             	mov    0x8(%eax),%eax
    ba73:	85 c0                	test   %eax,%eax
    ba75:	75 0a                	jne    ba81 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    ba77:	b8 6b 00 00 00       	mov    $0x6b,%eax
    ba7c:	e9 19 03 00 00       	jmp    bd9a <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    ba81:	ff 75 14             	pushl  0x14(%ebp)
    ba84:	ff 75 10             	pushl  0x10(%ebp)
    ba87:	e8 b7 d1 ff ff       	call   8c43 <lodepng_color_mode_equal>
    ba8c:	83 c4 08             	add    $0x8,%esp
    ba8f:	85 c0                	test   %eax,%eax
    ba91:	74 2f                	je     bac2 <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    ba93:	ff 75 14             	pushl  0x14(%ebp)
    ba96:	ff 75 1c             	pushl  0x1c(%ebp)
    ba99:	ff 75 18             	pushl  0x18(%ebp)
    ba9c:	e8 fb d4 ff ff       	call   8f9c <lodepng_get_raw_size>
    baa1:	83 c4 0c             	add    $0xc,%esp
    baa4:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    baa7:	ff 75 dc             	pushl  -0x24(%ebp)
    baaa:	ff 75 0c             	pushl  0xc(%ebp)
    baad:	ff 75 08             	pushl  0x8(%ebp)
    bab0:	e8 ca 78 ff ff       	call   337f <lodepng_memcpy>
    bab5:	83 c4 0c             	add    $0xc,%esp
    return 0;
    bab8:	b8 00 00 00 00       	mov    $0x0,%eax
    babd:	e9 d8 02 00 00       	jmp    bd9a <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bac2:	8b 45 10             	mov    0x10(%ebp),%eax
    bac5:	8b 00                	mov    (%eax),%eax
    bac7:	83 f8 03             	cmp    $0x3,%eax
    baca:	0f 85 16 01 00 00    	jne    bbe6 <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    bad0:	8b 45 10             	mov    0x10(%ebp),%eax
    bad3:	8b 40 0c             	mov    0xc(%eax),%eax
    bad6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    bad9:	8b 45 10             	mov    0x10(%ebp),%eax
    badc:	8b 40 08             	mov    0x8(%eax),%eax
    badf:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    bae2:	8b 45 10             	mov    0x10(%ebp),%eax
    bae5:	8b 40 04             	mov    0x4(%eax),%eax
    bae8:	ba 01 00 00 00       	mov    $0x1,%edx
    baed:	89 c1                	mov    %eax,%ecx
    baef:	d3 e2                	shl    %cl,%edx
    baf1:	89 d0                	mov    %edx,%eax
    baf3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    baf6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    bafa:	75 5b                	jne    bb57 <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    bafc:	8b 45 14             	mov    0x14(%ebp),%eax
    baff:	8b 40 0c             	mov    0xc(%eax),%eax
    bb02:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    bb05:	8b 45 14             	mov    0x14(%ebp),%eax
    bb08:	8b 40 08             	mov    0x8(%eax),%eax
    bb0b:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    bb0e:	8b 45 14             	mov    0x14(%ebp),%eax
    bb11:	8b 00                	mov    (%eax),%eax
    bb13:	83 f8 03             	cmp    $0x3,%eax
    bb16:	75 3f                	jne    bb57 <lodepng_convert+0x10f>
    bb18:	8b 45 14             	mov    0x14(%ebp),%eax
    bb1b:	8b 50 04             	mov    0x4(%eax),%edx
    bb1e:	8b 45 10             	mov    0x10(%ebp),%eax
    bb21:	8b 40 04             	mov    0x4(%eax),%eax
    bb24:	39 c2                	cmp    %eax,%edx
    bb26:	75 2f                	jne    bb57 <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bb28:	ff 75 14             	pushl  0x14(%ebp)
    bb2b:	ff 75 1c             	pushl  0x1c(%ebp)
    bb2e:	ff 75 18             	pushl  0x18(%ebp)
    bb31:	e8 66 d4 ff ff       	call   8f9c <lodepng_get_raw_size>
    bb36:	83 c4 0c             	add    $0xc,%esp
    bb39:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    bb3c:	ff 75 d8             	pushl  -0x28(%ebp)
    bb3f:	ff 75 0c             	pushl  0xc(%ebp)
    bb42:	ff 75 08             	pushl  0x8(%ebp)
    bb45:	e8 35 78 ff ff       	call   337f <lodepng_memcpy>
    bb4a:	83 c4 0c             	add    $0xc,%esp
        return 0;
    bb4d:	b8 00 00 00 00       	mov    $0x0,%eax
    bb52:	e9 43 02 00 00       	jmp    bd9a <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    bb57:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bb5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bb5d:	7d 06                	jge    bb65 <lodepng_convert+0x11d>
    bb5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bb62:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    bb65:	8d 45 90             	lea    -0x70(%ebp),%eax
    bb68:	50                   	push   %eax
    bb69:	e8 5f e1 ff ff       	call   9ccd <color_tree_init>
    bb6e:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    bb71:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bb78:	eb 61                	jmp    bbdb <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    bb7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bb7d:	c1 e0 02             	shl    $0x2,%eax
    bb80:	89 c2                	mov    %eax,%edx
    bb82:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bb85:	01 d0                	add    %edx,%eax
    bb87:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    bb8a:	8b 75 f4             	mov    -0xc(%ebp),%esi
    bb8d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb90:	83 c0 03             	add    $0x3,%eax
    bb93:	0f b6 00             	movzbl (%eax),%eax
    bb96:	0f b6 d8             	movzbl %al,%ebx
    bb99:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb9c:	83 c0 02             	add    $0x2,%eax
    bb9f:	0f b6 00             	movzbl (%eax),%eax
    bba2:	0f b6 c8             	movzbl %al,%ecx
    bba5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bba8:	83 c0 01             	add    $0x1,%eax
    bbab:	0f b6 00             	movzbl (%eax),%eax
    bbae:	0f b6 d0             	movzbl %al,%edx
    bbb1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bbb4:	0f b6 00             	movzbl (%eax),%eax
    bbb7:	0f b6 c0             	movzbl %al,%eax
    bbba:	83 ec 08             	sub    $0x8,%esp
    bbbd:	56                   	push   %esi
    bbbe:	53                   	push   %ebx
    bbbf:	51                   	push   %ecx
    bbc0:	52                   	push   %edx
    bbc1:	50                   	push   %eax
    bbc2:	8d 45 90             	lea    -0x70(%ebp),%eax
    bbc5:	50                   	push   %eax
    bbc6:	e8 85 e2 ff ff       	call   9e50 <color_tree_add>
    bbcb:	83 c4 20             	add    $0x20,%esp
    bbce:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    bbd1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bbd5:	75 0e                	jne    bbe5 <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    bbd7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bbdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bbde:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bbe1:	75 97                	jne    bb7a <lodepng_convert+0x132>
    bbe3:	eb 01                	jmp    bbe6 <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    bbe5:	90                   	nop
    }
  }

  if(!error) {
    bbe6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bbea:	0f 85 8e 01 00 00    	jne    bd7e <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bbf0:	8b 45 14             	mov    0x14(%ebp),%eax
    bbf3:	8b 40 04             	mov    0x4(%eax),%eax
    bbf6:	83 f8 10             	cmp    $0x10,%eax
    bbf9:	0f 85 99 00 00 00    	jne    bc98 <lodepng_convert+0x250>
    bbff:	8b 45 10             	mov    0x10(%ebp),%eax
    bc02:	8b 40 04             	mov    0x4(%eax),%eax
    bc05:	83 f8 10             	cmp    $0x10,%eax
    bc08:	0f 85 8a 00 00 00    	jne    bc98 <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    bc0e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bc15:	eb 74                	jmp    bc8b <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    bc17:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    bc1d:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    bc23:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    bc29:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    bc2f:	83 ec 04             	sub    $0x4,%esp
    bc32:	ff 75 14             	pushl  0x14(%ebp)
    bc35:	ff 75 f4             	pushl  -0xc(%ebp)
    bc38:	ff 75 0c             	pushl  0xc(%ebp)
    bc3b:	8d 45 88             	lea    -0x78(%ebp),%eax
    bc3e:	50                   	push   %eax
    bc3f:	8d 45 8a             	lea    -0x76(%ebp),%eax
    bc42:	50                   	push   %eax
    bc43:	8d 45 8c             	lea    -0x74(%ebp),%eax
    bc46:	50                   	push   %eax
    bc47:	8d 45 8e             	lea    -0x72(%ebp),%eax
    bc4a:	50                   	push   %eax
    bc4b:	e8 06 fa ff ff       	call   b656 <getPixelColorRGBA16>
    bc50:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    bc53:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    bc57:	0f b7 d8             	movzwl %ax,%ebx
    bc5a:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    bc5e:	0f b7 c8             	movzwl %ax,%ecx
    bc61:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    bc65:	0f b7 d0             	movzwl %ax,%edx
    bc68:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    bc6c:	0f b7 c0             	movzwl %ax,%eax
    bc6f:	83 ec 04             	sub    $0x4,%esp
    bc72:	53                   	push   %ebx
    bc73:	51                   	push   %ecx
    bc74:	52                   	push   %edx
    bc75:	50                   	push   %eax
    bc76:	ff 75 10             	pushl  0x10(%ebp)
    bc79:	ff 75 f4             	pushl  -0xc(%ebp)
    bc7c:	ff 75 08             	pushl  0x8(%ebp)
    bc7f:	e8 d3 e6 ff ff       	call   a357 <rgba16ToPixel>
    bc84:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    bc87:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bc8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bc8e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bc91:	75 84                	jne    bc17 <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bc93:	e9 e6 00 00 00       	jmp    bd7e <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    bc98:	8b 45 10             	mov    0x10(%ebp),%eax
    bc9b:	8b 40 04             	mov    0x4(%eax),%eax
    bc9e:	83 f8 08             	cmp    $0x8,%eax
    bca1:	75 23                	jne    bcc6 <lodepng_convert+0x27e>
    bca3:	8b 45 10             	mov    0x10(%ebp),%eax
    bca6:	8b 00                	mov    (%eax),%eax
    bca8:	83 f8 06             	cmp    $0x6,%eax
    bcab:	75 19                	jne    bcc6 <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    bcad:	ff 75 14             	pushl  0x14(%ebp)
    bcb0:	ff 75 0c             	pushl  0xc(%ebp)
    bcb3:	ff 75 e0             	pushl  -0x20(%ebp)
    bcb6:	ff 75 08             	pushl  0x8(%ebp)
    bcb9:	e8 ae ee ff ff       	call   ab6c <getPixelColorsRGBA8>
    bcbe:	83 c4 10             	add    $0x10,%esp
    bcc1:	e9 b8 00 00 00       	jmp    bd7e <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    bcc6:	8b 45 10             	mov    0x10(%ebp),%eax
    bcc9:	8b 40 04             	mov    0x4(%eax),%eax
    bccc:	83 f8 08             	cmp    $0x8,%eax
    bccf:	75 23                	jne    bcf4 <lodepng_convert+0x2ac>
    bcd1:	8b 45 10             	mov    0x10(%ebp),%eax
    bcd4:	8b 00                	mov    (%eax),%eax
    bcd6:	83 f8 02             	cmp    $0x2,%eax
    bcd9:	75 19                	jne    bcf4 <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    bcdb:	ff 75 14             	pushl  0x14(%ebp)
    bcde:	ff 75 0c             	pushl  0xc(%ebp)
    bce1:	ff 75 e0             	pushl  -0x20(%ebp)
    bce4:	ff 75 08             	pushl  0x8(%ebp)
    bce7:	e8 50 f5 ff ff       	call   b23c <getPixelColorsRGB8>
    bcec:	83 c4 10             	add    $0x10,%esp
    bcef:	e9 8a 00 00 00       	jmp    bd7e <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    bcf4:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    bcf8:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    bcfc:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    bd00:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    bd04:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bd0b:	eb 66                	jmp    bd73 <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    bd0d:	83 ec 04             	sub    $0x4,%esp
    bd10:	ff 75 14             	pushl  0x14(%ebp)
    bd13:	ff 75 f4             	pushl  -0xc(%ebp)
    bd16:	ff 75 0c             	pushl  0xc(%ebp)
    bd19:	8d 45 84             	lea    -0x7c(%ebp),%eax
    bd1c:	50                   	push   %eax
    bd1d:	8d 45 85             	lea    -0x7b(%ebp),%eax
    bd20:	50                   	push   %eax
    bd21:	8d 45 86             	lea    -0x7a(%ebp),%eax
    bd24:	50                   	push   %eax
    bd25:	8d 45 87             	lea    -0x79(%ebp),%eax
    bd28:	50                   	push   %eax
    bd29:	e8 71 e8 ff ff       	call   a59f <getPixelColorRGBA8>
    bd2e:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    bd31:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    bd35:	0f b6 d8             	movzbl %al,%ebx
    bd38:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    bd3c:	0f b6 c8             	movzbl %al,%ecx
    bd3f:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    bd43:	0f b6 d0             	movzbl %al,%edx
    bd46:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    bd4a:	0f b6 c0             	movzbl %al,%eax
    bd4d:	53                   	push   %ebx
    bd4e:	51                   	push   %ecx
    bd4f:	52                   	push   %edx
    bd50:	50                   	push   %eax
    bd51:	8d 45 90             	lea    -0x70(%ebp),%eax
    bd54:	50                   	push   %eax
    bd55:	ff 75 10             	pushl  0x10(%ebp)
    bd58:	ff 75 f4             	pushl  -0xc(%ebp)
    bd5b:	ff 75 08             	pushl  0x8(%ebp)
    bd5e:	e8 e5 e1 ff ff       	call   9f48 <rgba8ToPixel>
    bd63:	83 c4 20             	add    $0x20,%esp
    bd66:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    bd69:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bd6d:	75 0e                	jne    bd7d <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    bd6f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bd73:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bd76:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bd79:	75 92                	jne    bd0d <lodepng_convert+0x2c5>
    bd7b:	eb 01                	jmp    bd7e <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    bd7d:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bd7e:	8b 45 10             	mov    0x10(%ebp),%eax
    bd81:	8b 00                	mov    (%eax),%eax
    bd83:	83 f8 03             	cmp    $0x3,%eax
    bd86:	75 0f                	jne    bd97 <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    bd88:	83 ec 0c             	sub    $0xc,%esp
    bd8b:	8d 45 90             	lea    -0x70(%ebp),%eax
    bd8e:	50                   	push   %eax
    bd8f:	e8 59 df ff ff       	call   9ced <color_tree_cleanup>
    bd94:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    bd97:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    bd9a:	8d 65 f8             	lea    -0x8(%ebp),%esp
    bd9d:	5b                   	pop    %ebx
    bd9e:	5e                   	pop    %esi
    bd9f:	5d                   	pop    %ebp
    bda0:	c3                   	ret    

0000bda1 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    bda1:	55                   	push   %ebp
    bda2:	89 e5                	mov    %esp,%ebp
    bda4:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    bda7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    bdae:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bdb5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    bdbc:	8b 45 24             	mov    0x24(%ebp),%eax
    bdbf:	8b 40 04             	mov    0x4(%eax),%eax
    bdc2:	ba 01 00 00 00       	mov    $0x1,%edx
    bdc7:	89 c1                	mov    %eax,%ecx
    bdc9:	d3 e2                	shl    %cl,%edx
    bdcb:	89 d0                	mov    %edx,%eax
    bdcd:	8d 48 ff             	lea    -0x1(%eax),%ecx
    bdd0:	b8 ff ff 00 00       	mov    $0xffff,%eax
    bdd5:	ba 00 00 00 00       	mov    $0x0,%edx
    bdda:	f7 f1                	div    %ecx
    bddc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    bddf:	8b 45 20             	mov    0x20(%ebp),%eax
    bde2:	8b 40 04             	mov    0x4(%eax),%eax
    bde5:	ba 10 00 00 00       	mov    $0x10,%edx
    bdea:	29 c2                	sub    %eax,%edx
    bdec:	89 d0                	mov    %edx,%eax
    bdee:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    bdf1:	8b 45 24             	mov    0x24(%ebp),%eax
    bdf4:	8b 00                	mov    (%eax),%eax
    bdf6:	85 c0                	test   %eax,%eax
    bdf8:	74 0a                	je     be04 <lodepng_convert_rgb+0x63>
    bdfa:	8b 45 24             	mov    0x24(%ebp),%eax
    bdfd:	8b 00                	mov    (%eax),%eax
    bdff:	83 f8 04             	cmp    $0x4,%eax
    be02:	75 1b                	jne    be1f <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    be04:	8b 45 14             	mov    0x14(%ebp),%eax
    be07:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    be0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    be11:	89 45 f8             	mov    %eax,-0x8(%ebp)
    be14:	8b 45 f8             	mov    -0x8(%ebp),%eax
    be17:	89 45 fc             	mov    %eax,-0x4(%ebp)
    be1a:	e9 c2 00 00 00       	jmp    bee1 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    be1f:	8b 45 24             	mov    0x24(%ebp),%eax
    be22:	8b 00                	mov    (%eax),%eax
    be24:	83 f8 02             	cmp    $0x2,%eax
    be27:	74 0a                	je     be33 <lodepng_convert_rgb+0x92>
    be29:	8b 45 24             	mov    0x24(%ebp),%eax
    be2c:	8b 00                	mov    (%eax),%eax
    be2e:	83 f8 06             	cmp    $0x6,%eax
    be31:	75 23                	jne    be56 <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    be33:	8b 45 14             	mov    0x14(%ebp),%eax
    be36:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be3a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    be3d:	8b 45 18             	mov    0x18(%ebp),%eax
    be40:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be44:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    be47:	8b 45 1c             	mov    0x1c(%ebp),%eax
    be4a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    be51:	e9 8b 00 00 00       	jmp    bee1 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    be56:	8b 45 24             	mov    0x24(%ebp),%eax
    be59:	8b 00                	mov    (%eax),%eax
    be5b:	83 f8 03             	cmp    $0x3,%eax
    be5e:	75 77                	jne    bed7 <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    be60:	8b 45 24             	mov    0x24(%ebp),%eax
    be63:	8b 40 0c             	mov    0xc(%eax),%eax
    be66:	3b 45 14             	cmp    0x14(%ebp),%eax
    be69:	77 0a                	ja     be75 <lodepng_convert_rgb+0xd4>
    be6b:	b8 52 00 00 00       	mov    $0x52,%eax
    be70:	e9 cb 01 00 00       	jmp    c040 <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    be75:	8b 45 24             	mov    0x24(%ebp),%eax
    be78:	8b 40 08             	mov    0x8(%eax),%eax
    be7b:	8b 55 14             	mov    0x14(%ebp),%edx
    be7e:	c1 e2 02             	shl    $0x2,%edx
    be81:	01 d0                	add    %edx,%eax
    be83:	0f b6 00             	movzbl (%eax),%eax
    be86:	0f b6 d0             	movzbl %al,%edx
    be89:	89 d0                	mov    %edx,%eax
    be8b:	c1 e0 08             	shl    $0x8,%eax
    be8e:	01 d0                	add    %edx,%eax
    be90:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    be93:	8b 45 24             	mov    0x24(%ebp),%eax
    be96:	8b 40 08             	mov    0x8(%eax),%eax
    be99:	8b 55 14             	mov    0x14(%ebp),%edx
    be9c:	c1 e2 02             	shl    $0x2,%edx
    be9f:	83 c2 01             	add    $0x1,%edx
    bea2:	01 d0                	add    %edx,%eax
    bea4:	0f b6 00             	movzbl (%eax),%eax
    bea7:	0f b6 d0             	movzbl %al,%edx
    beaa:	89 d0                	mov    %edx,%eax
    beac:	c1 e0 08             	shl    $0x8,%eax
    beaf:	01 d0                	add    %edx,%eax
    beb1:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    beb4:	8b 45 24             	mov    0x24(%ebp),%eax
    beb7:	8b 40 08             	mov    0x8(%eax),%eax
    beba:	8b 55 14             	mov    0x14(%ebp),%edx
    bebd:	c1 e2 02             	shl    $0x2,%edx
    bec0:	83 c2 02             	add    $0x2,%edx
    bec3:	01 d0                	add    %edx,%eax
    bec5:	0f b6 00             	movzbl (%eax),%eax
    bec8:	0f b6 d0             	movzbl %al,%edx
    becb:	89 d0                	mov    %edx,%eax
    becd:	c1 e0 08             	shl    $0x8,%eax
    bed0:	01 d0                	add    %edx,%eax
    bed2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bed5:	eb 0a                	jmp    bee1 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    bed7:	b8 1f 00 00 00       	mov    $0x1f,%eax
    bedc:	e9 5f 01 00 00       	jmp    c040 <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    bee1:	8b 45 20             	mov    0x20(%ebp),%eax
    bee4:	8b 00                	mov    (%eax),%eax
    bee6:	85 c0                	test   %eax,%eax
    bee8:	74 0a                	je     bef4 <lodepng_convert_rgb+0x153>
    beea:	8b 45 20             	mov    0x20(%ebp),%eax
    beed:	8b 00                	mov    (%eax),%eax
    beef:	83 f8 04             	cmp    $0x4,%eax
    bef2:	75 14                	jne    bf08 <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    bef4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bef7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    befa:	89 c1                	mov    %eax,%ecx
    befc:	d3 ea                	shr    %cl,%edx
    befe:	8b 45 08             	mov    0x8(%ebp),%eax
    bf01:	89 10                	mov    %edx,(%eax)
    bf03:	e9 33 01 00 00       	jmp    c03b <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    bf08:	8b 45 20             	mov    0x20(%ebp),%eax
    bf0b:	8b 00                	mov    (%eax),%eax
    bf0d:	83 f8 02             	cmp    $0x2,%eax
    bf10:	74 0a                	je     bf1c <lodepng_convert_rgb+0x17b>
    bf12:	8b 45 20             	mov    0x20(%ebp),%eax
    bf15:	8b 00                	mov    (%eax),%eax
    bf17:	83 f8 06             	cmp    $0x6,%eax
    bf1a:	75 32                	jne    bf4e <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    bf1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf1f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bf22:	89 c1                	mov    %eax,%ecx
    bf24:	d3 ea                	shr    %cl,%edx
    bf26:	8b 45 08             	mov    0x8(%ebp),%eax
    bf29:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    bf2b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf2e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bf31:	89 c1                	mov    %eax,%ecx
    bf33:	d3 ea                	shr    %cl,%edx
    bf35:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf38:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    bf3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf3d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    bf40:	89 c1                	mov    %eax,%ecx
    bf42:	d3 ea                	shr    %cl,%edx
    bf44:	8b 45 10             	mov    0x10(%ebp),%eax
    bf47:	89 10                	mov    %edx,(%eax)
    bf49:	e9 ed 00 00 00       	jmp    c03b <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    bf4e:	8b 45 20             	mov    0x20(%ebp),%eax
    bf51:	8b 00                	mov    (%eax),%eax
    bf53:	83 f8 03             	cmp    $0x3,%eax
    bf56:	0f 85 d8 00 00 00    	jne    c034 <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    bf5c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bf5f:	c1 e8 08             	shr    $0x8,%eax
    bf62:	89 c2                	mov    %eax,%edx
    bf64:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bf67:	0f b6 c0             	movzbl %al,%eax
    bf6a:	39 c2                	cmp    %eax,%edx
    bf6c:	75 24                	jne    bf92 <lodepng_convert_rgb+0x1f1>
    bf6e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf71:	c1 e8 08             	shr    $0x8,%eax
    bf74:	89 c2                	mov    %eax,%edx
    bf76:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf79:	0f b6 c0             	movzbl %al,%eax
    bf7c:	39 c2                	cmp    %eax,%edx
    bf7e:	75 12                	jne    bf92 <lodepng_convert_rgb+0x1f1>
    bf80:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf83:	c1 e8 08             	shr    $0x8,%eax
    bf86:	89 c2                	mov    %eax,%edx
    bf88:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf8b:	0f b6 c0             	movzbl %al,%eax
    bf8e:	39 c2                	cmp    %eax,%edx
    bf90:	74 0a                	je     bf9c <lodepng_convert_rgb+0x1fb>
    bf92:	b8 52 00 00 00       	mov    $0x52,%eax
    bf97:	e9 a4 00 00 00       	jmp    c040 <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    bf9c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    bfa3:	eb 79                	jmp    c01e <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    bfa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    bfa8:	c1 e0 02             	shl    $0x2,%eax
    bfab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    bfae:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bfb1:	c1 e8 08             	shr    $0x8,%eax
    bfb4:	89 c1                	mov    %eax,%ecx
    bfb6:	8b 45 20             	mov    0x20(%ebp),%eax
    bfb9:	8b 50 08             	mov    0x8(%eax),%edx
    bfbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    bfbf:	01 d0                	add    %edx,%eax
    bfc1:	0f b6 00             	movzbl (%eax),%eax
    bfc4:	0f b6 c0             	movzbl %al,%eax
    bfc7:	39 c1                	cmp    %eax,%ecx
    bfc9:	75 4f                	jne    c01a <lodepng_convert_rgb+0x279>
    bfcb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bfce:	c1 e8 08             	shr    $0x8,%eax
    bfd1:	89 c1                	mov    %eax,%ecx
    bfd3:	8b 45 20             	mov    0x20(%ebp),%eax
    bfd6:	8b 40 08             	mov    0x8(%eax),%eax
    bfd9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bfdc:	83 c2 01             	add    $0x1,%edx
    bfdf:	01 d0                	add    %edx,%eax
    bfe1:	0f b6 00             	movzbl (%eax),%eax
    bfe4:	0f b6 c0             	movzbl %al,%eax
    bfe7:	39 c1                	cmp    %eax,%ecx
    bfe9:	75 2f                	jne    c01a <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    bfeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bfee:	c1 e8 08             	shr    $0x8,%eax
    bff1:	89 c1                	mov    %eax,%ecx
    bff3:	8b 45 20             	mov    0x20(%ebp),%eax
    bff6:	8b 40 08             	mov    0x8(%eax),%eax
    bff9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bffc:	83 c2 02             	add    $0x2,%edx
    bfff:	01 d0                	add    %edx,%eax
    c001:	0f b6 00             	movzbl (%eax),%eax
    c004:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c007:	39 c1                	cmp    %eax,%ecx
    c009:	75 0f                	jne    c01a <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    c00b:	8b 45 08             	mov    0x8(%ebp),%eax
    c00e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c011:	89 10                	mov    %edx,(%eax)
        return 0;
    c013:	b8 00 00 00 00       	mov    $0x0,%eax
    c018:	eb 26                	jmp    c040 <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    c01a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c01e:	8b 45 20             	mov    0x20(%ebp),%eax
    c021:	8b 40 0c             	mov    0xc(%eax),%eax
    c024:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    c027:	0f 87 78 ff ff ff    	ja     bfa5 <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    c02d:	b8 52 00 00 00       	mov    $0x52,%eax
    c032:	eb 0c                	jmp    c040 <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    c034:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c039:	eb 05                	jmp    c040 <lodepng_convert_rgb+0x29f>
  }

  return 0;
    c03b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c040:	c9                   	leave  
    c041:	c3                   	ret    

0000c042 <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    c042:	55                   	push   %ebp
    c043:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    c045:	8b 45 08             	mov    0x8(%ebp),%eax
    c048:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    c04e:	8b 45 08             	mov    0x8(%ebp),%eax
    c051:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    c058:	8b 45 08             	mov    0x8(%ebp),%eax
    c05b:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    c061:	8b 45 08             	mov    0x8(%ebp),%eax
    c064:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c068:	8b 45 08             	mov    0x8(%ebp),%eax
    c06b:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c06f:	8b 45 08             	mov    0x8(%ebp),%eax
    c072:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c076:	8b 45 08             	mov    0x8(%ebp),%eax
    c079:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c07d:	8b 45 08             	mov    0x8(%ebp),%eax
    c080:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c087:	8b 45 08             	mov    0x8(%ebp),%eax
    c08a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c091:	8b 45 08             	mov    0x8(%ebp),%eax
    c094:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c09b:	00 00 00 
  stats->numpixels = 0;
    c09e:	8b 45 08             	mov    0x8(%ebp),%eax
    c0a1:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c0a8:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c0ab:	8b 45 08             	mov    0x8(%ebp),%eax
    c0ae:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c0b5:	00 00 00 
  stats->allow_greyscale = 1;
    c0b8:	8b 45 08             	mov    0x8(%ebp),%eax
    c0bb:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c0c2:	00 00 00 
}
    c0c5:	90                   	nop
    c0c6:	5d                   	pop    %ebp
    c0c7:	c3                   	ret    

0000c0c8 <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c0c8:	55                   	push   %ebp
    c0c9:	89 e5                	mov    %esp,%ebp
    c0cb:	53                   	push   %ebx
    c0cc:	83 ec 04             	sub    $0x4,%esp
    c0cf:	8b 45 08             	mov    0x8(%ebp),%eax
    c0d2:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c0d5:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c0d9:	74 06                	je     c0e1 <getValueRequiredBits+0x19>
    c0db:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c0df:	75 07                	jne    c0e8 <getValueRequiredBits+0x20>
    c0e1:	b8 01 00 00 00       	mov    $0x1,%eax
    c0e6:	eb 6b                	jmp    c153 <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c0e8:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c0ec:	0f b6 d9             	movzbl %cl,%ebx
    c0ef:	89 da                	mov    %ebx,%edx
    c0f1:	89 d0                	mov    %edx,%eax
    c0f3:	c1 e0 04             	shl    $0x4,%eax
    c0f6:	89 c2                	mov    %eax,%edx
    c0f8:	89 d0                	mov    %edx,%eax
    c0fa:	c1 e0 04             	shl    $0x4,%eax
    c0fd:	29 d0                	sub    %edx,%eax
    c0ff:	01 d8                	add    %ebx,%eax
    c101:	66 c1 e8 08          	shr    $0x8,%ax
    c105:	c0 e8 04             	shr    $0x4,%al
    c108:	89 c2                	mov    %eax,%edx
    c10a:	c1 e2 04             	shl    $0x4,%edx
    c10d:	01 c2                	add    %eax,%edx
    c10f:	89 c8                	mov    %ecx,%eax
    c111:	29 d0                	sub    %edx,%eax
    c113:	84 c0                	test   %al,%al
    c115:	75 37                	jne    c14e <getValueRequiredBits+0x86>
    c117:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c11b:	0f b6 d1             	movzbl %cl,%edx
    c11e:	89 d0                	mov    %edx,%eax
    c120:	01 c0                	add    %eax,%eax
    c122:	01 d0                	add    %edx,%eax
    c124:	c1 e0 06             	shl    $0x6,%eax
    c127:	01 d0                	add    %edx,%eax
    c129:	66 c1 e8 08          	shr    $0x8,%ax
    c12d:	c0 e8 06             	shr    $0x6,%al
    c130:	ba 55 00 00 00       	mov    $0x55,%edx
    c135:	0f af c2             	imul   %edx,%eax
    c138:	29 c1                	sub    %eax,%ecx
    c13a:	89 c8                	mov    %ecx,%eax
    c13c:	84 c0                	test   %al,%al
    c13e:	75 07                	jne    c147 <getValueRequiredBits+0x7f>
    c140:	b8 02 00 00 00       	mov    $0x2,%eax
    c145:	eb 0c                	jmp    c153 <getValueRequiredBits+0x8b>
    c147:	b8 04 00 00 00       	mov    $0x4,%eax
    c14c:	eb 05                	jmp    c153 <getValueRequiredBits+0x8b>
  return 8;
    c14e:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c153:	83 c4 04             	add    $0x4,%esp
    c156:	5b                   	pop    %ebx
    c157:	5d                   	pop    %ebp
    c158:	c3                   	ret    

0000c159 <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c159:	55                   	push   %ebp
    c15a:	89 e5                	mov    %esp,%ebp
    c15c:	56                   	push   %esi
    c15d:	53                   	push   %ebx
    c15e:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c164:	8b 55 10             	mov    0x10(%ebp),%edx
    c167:	8b 45 14             	mov    0x14(%ebp),%eax
    c16a:	0f af c2             	imul   %edx,%eax
    c16d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c170:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c177:	ff 75 18             	pushl  0x18(%ebp)
    c17a:	e8 0b cd ff ff       	call   8e8a <lodepng_is_greyscale_type>
    c17f:	83 c4 04             	add    $0x4,%esp
    c182:	85 c0                	test   %eax,%eax
    c184:	0f 95 c0             	setne  %al
    c187:	0f b6 c0             	movzbl %al,%eax
    c18a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c18d:	ff 75 18             	pushl  0x18(%ebp)
    c190:	e8 85 cd ff ff       	call   8f1a <lodepng_can_have_alpha>
    c195:	83 c4 04             	add    $0x4,%esp
    c198:	85 c0                	test   %eax,%eax
    c19a:	0f 94 c0             	sete   %al
    c19d:	0f b6 c0             	movzbl %al,%eax
    c1a0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c1a3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c1aa:	ff 75 18             	pushl  0x18(%ebp)
    c1ad:	e8 ab cc ff ff       	call   8e5d <lodepng_get_bpp>
    c1b2:	83 c4 04             	add    $0x4,%esp
    c1b5:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c1b8:	8b 45 08             	mov    0x8(%ebp),%eax
    c1bb:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c1c1:	83 f8 01             	cmp    $0x1,%eax
    c1c4:	75 0d                	jne    c1d3 <lodepng_compute_color_stats+0x7a>
    c1c6:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c1ca:	75 07                	jne    c1d3 <lodepng_compute_color_stats+0x7a>
    c1cc:	b8 01 00 00 00       	mov    $0x1,%eax
    c1d1:	eb 05                	jmp    c1d8 <lodepng_compute_color_stats+0x7f>
    c1d3:	b8 00 00 00 00       	mov    $0x0,%eax
    c1d8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c1db:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c1e2:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c1e9:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c1ed:	77 26                	ja     c215 <lodepng_compute_color_stats+0xbc>
    c1ef:	8b 45 08             	mov    0x8(%ebp),%eax
    c1f2:	8b 50 14             	mov    0x14(%eax),%edx
    c1f5:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c1f8:	bb 01 00 00 00       	mov    $0x1,%ebx
    c1fd:	89 c1                	mov    %eax,%ecx
    c1ff:	d3 e3                	shl    %cl,%ebx
    c201:	89 d8                	mov    %ebx,%eax
    c203:	01 d0                	add    %edx,%eax
    c205:	ba 01 01 00 00       	mov    $0x101,%edx
    c20a:	3d 01 01 00 00       	cmp    $0x101,%eax
    c20f:	0f 47 c2             	cmova  %edx,%eax
    c212:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c215:	8b 45 08             	mov    0x8(%ebp),%eax
    c218:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c21e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c221:	01 c2                	add    %eax,%edx
    c223:	8b 45 08             	mov    0x8(%ebp),%eax
    c226:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c22c:	8b 45 08             	mov    0x8(%ebp),%eax
    c22f:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c235:	85 c0                	test   %eax,%eax
    c237:	75 07                	jne    c240 <lodepng_compute_color_stats+0xe7>
    c239:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c240:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c246:	50                   	push   %eax
    c247:	e8 81 da ff ff       	call   9ccd <color_tree_init>
    c24c:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c24f:	8b 45 08             	mov    0x8(%ebp),%eax
    c252:	8b 40 10             	mov    0x10(%eax),%eax
    c255:	85 c0                	test   %eax,%eax
    c257:	74 07                	je     c260 <lodepng_compute_color_stats+0x107>
    c259:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c260:	8b 45 08             	mov    0x8(%ebp),%eax
    c263:	8b 00                	mov    (%eax),%eax
    c265:	85 c0                	test   %eax,%eax
    c267:	74 07                	je     c270 <lodepng_compute_color_stats+0x117>
    c269:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c270:	8b 45 08             	mov    0x8(%ebp),%eax
    c273:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c279:	83 f8 10             	cmp    $0x10,%eax
    c27c:	75 07                	jne    c285 <lodepng_compute_color_stats+0x12c>
    c27e:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c285:	8b 45 08             	mov    0x8(%ebp),%eax
    c288:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c28e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c291:	72 07                	jb     c29a <lodepng_compute_color_stats+0x141>
    c293:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c29a:	8b 45 08             	mov    0x8(%ebp),%eax
    c29d:	8b 40 14             	mov    0x14(%eax),%eax
    c2a0:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c2a3:	72 07                	jb     c2ac <lodepng_compute_color_stats+0x153>
    c2a5:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c2ac:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c2b0:	0f 85 82 00 00 00    	jne    c338 <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c2b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c2bd:	eb 6c                	jmp    c32b <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c2bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c2c2:	c1 e0 02             	shl    $0x2,%eax
    c2c5:	8d 50 10             	lea    0x10(%eax),%edx
    c2c8:	8b 45 08             	mov    0x8(%ebp),%eax
    c2cb:	01 d0                	add    %edx,%eax
    c2cd:	83 c0 08             	add    $0x8,%eax
    c2d0:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c2d3:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c2d6:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2d9:	83 c0 03             	add    $0x3,%eax
    c2dc:	0f b6 00             	movzbl (%eax),%eax
    c2df:	0f b6 d8             	movzbl %al,%ebx
    c2e2:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2e5:	83 c0 02             	add    $0x2,%eax
    c2e8:	0f b6 00             	movzbl (%eax),%eax
    c2eb:	0f b6 c8             	movzbl %al,%ecx
    c2ee:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2f1:	83 c0 01             	add    $0x1,%eax
    c2f4:	0f b6 00             	movzbl (%eax),%eax
    c2f7:	0f b6 d0             	movzbl %al,%edx
    c2fa:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2fd:	0f b6 00             	movzbl (%eax),%eax
    c300:	0f b6 c0             	movzbl %al,%eax
    c303:	83 ec 08             	sub    $0x8,%esp
    c306:	56                   	push   %esi
    c307:	53                   	push   %ebx
    c308:	51                   	push   %ecx
    c309:	52                   	push   %edx
    c30a:	50                   	push   %eax
    c30b:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c311:	50                   	push   %eax
    c312:	e8 39 db ff ff       	call   9e50 <color_tree_add>
    c317:	83 c4 20             	add    $0x20,%esp
    c31a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    c31d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c321:	0f 85 22 09 00 00    	jne    cc49 <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    c327:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c32b:	8b 45 08             	mov    0x8(%ebp),%eax
    c32e:	8b 50 14             	mov    0x14(%eax),%edx
    c331:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c334:	39 c2                	cmp    %eax,%edx
    c336:	77 87                	ja     c2bf <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    c338:	8b 45 18             	mov    0x18(%ebp),%eax
    c33b:	8b 40 04             	mov    0x4(%eax),%eax
    c33e:	83 f8 10             	cmp    $0x10,%eax
    c341:	0f 85 1e 01 00 00    	jne    c465 <lodepng_compute_color_stats+0x30c>
    c347:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c34b:	0f 85 14 01 00 00    	jne    c465 <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c351:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    c358:	00 00 
    c35a:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    c361:	00 00 
    c363:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    c36a:	00 00 
    c36c:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    c373:	00 00 
    for(i = 0; i != numpixels; ++i) {
    c375:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c37c:	e9 d8 00 00 00       	jmp    c459 <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c381:	83 ec 04             	sub    $0x4,%esp
    c384:	ff 75 18             	pushl  0x18(%ebp)
    c387:	ff 75 f4             	pushl  -0xc(%ebp)
    c38a:	ff 75 0c             	pushl  0xc(%ebp)
    c38d:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    c393:	50                   	push   %eax
    c394:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    c39a:	50                   	push   %eax
    c39b:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    c3a1:	50                   	push   %eax
    c3a2:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    c3a8:	50                   	push   %eax
    c3a9:	e8 a8 f2 ff ff       	call   b656 <getPixelColorRGBA16>
    c3ae:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c3b1:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c3b8:	66 c1 e8 08          	shr    $0x8,%ax
    c3bc:	89 c2                	mov    %eax,%edx
    c3be:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c3c5:	31 d0                	xor    %edx,%eax
    c3c7:	0f b7 c0             	movzwl %ax,%eax
    c3ca:	0f b6 c0             	movzbl %al,%eax
    c3cd:	85 c0                	test   %eax,%eax
    c3cf:	75 60                	jne    c431 <lodepng_compute_color_stats+0x2d8>
    c3d1:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c3d8:	66 c1 e8 08          	shr    $0x8,%ax
    c3dc:	89 c2                	mov    %eax,%edx
    c3de:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c3e5:	31 d0                	xor    %edx,%eax
    c3e7:	0f b7 c0             	movzwl %ax,%eax
    c3ea:	0f b6 c0             	movzbl %al,%eax
    c3ed:	85 c0                	test   %eax,%eax
    c3ef:	75 40                	jne    c431 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c3f1:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c3f8:	66 c1 e8 08          	shr    $0x8,%ax
    c3fc:	89 c2                	mov    %eax,%edx
    c3fe:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c405:	31 d0                	xor    %edx,%eax
    c407:	0f b7 c0             	movzwl %ax,%eax
    c40a:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c40d:	85 c0                	test   %eax,%eax
    c40f:	75 20                	jne    c431 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c411:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c418:	66 c1 e8 08          	shr    $0x8,%ax
    c41c:	89 c2                	mov    %eax,%edx
    c41e:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c425:	31 d0                	xor    %edx,%eax
    c427:	0f b7 c0             	movzwl %ax,%eax
    c42a:	0f b6 c0             	movzbl %al,%eax
    c42d:	85 c0                	test   %eax,%eax
    c42f:	74 24                	je     c455 <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    c431:	8b 45 08             	mov    0x8(%ebp),%eax
    c434:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    c43b:	00 00 00 
        sixteen = 1;
    c43e:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    c445:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    c44c:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    c453:	eb 10                	jmp    c465 <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    c455:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c459:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c45c:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c45f:	0f 85 1c ff ff ff    	jne    c381 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    c465:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c469:	0f 84 bd 02 00 00    	je     c72c <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c46f:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    c476:	00 00 
    c478:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    c47f:	00 00 
    c481:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    c488:	00 00 
    c48a:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    c491:	00 00 

    for(i = 0; i != numpixels; ++i) {
    c493:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c49a:	e9 b1 01 00 00       	jmp    c650 <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c49f:	83 ec 04             	sub    $0x4,%esp
    c4a2:	ff 75 18             	pushl  0x18(%ebp)
    c4a5:	ff 75 f4             	pushl  -0xc(%ebp)
    c4a8:	ff 75 0c             	pushl  0xc(%ebp)
    c4ab:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c4b1:	50                   	push   %eax
    c4b2:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c4b8:	50                   	push   %eax
    c4b9:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c4bf:	50                   	push   %eax
    c4c0:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c4c6:	50                   	push   %eax
    c4c7:	e8 8a f1 ff ff       	call   b656 <getPixelColorRGBA16>
    c4cc:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    c4cf:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c4d3:	75 36                	jne    c50b <lodepng_compute_color_stats+0x3b2>
    c4d5:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c4dc:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c4e3:	66 39 c2             	cmp    %ax,%dx
    c4e6:	75 13                	jne    c4fb <lodepng_compute_color_stats+0x3a2>
    c4e8:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c4ef:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c4f6:	66 39 c2             	cmp    %ax,%dx
    c4f9:	74 10                	je     c50b <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    c4fb:	8b 45 08             	mov    0x8(%ebp),%eax
    c4fe:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c504:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    c50b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c50f:	0f 85 1f 01 00 00    	jne    c634 <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c515:	8b 45 08             	mov    0x8(%ebp),%eax
    c518:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c51c:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c523:	66 39 c2             	cmp    %ax,%dx
    c526:	75 2d                	jne    c555 <lodepng_compute_color_stats+0x3fc>
    c528:	8b 45 08             	mov    0x8(%ebp),%eax
    c52b:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c52f:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c536:	66 39 c2             	cmp    %ax,%dx
    c539:	75 1a                	jne    c555 <lodepng_compute_color_stats+0x3fc>
    c53b:	8b 45 08             	mov    0x8(%ebp),%eax
    c53e:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c542:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c549:	66 39 c2             	cmp    %ax,%dx
    c54c:	75 07                	jne    c555 <lodepng_compute_color_stats+0x3fc>
    c54e:	b8 01 00 00 00       	mov    $0x1,%eax
    c553:	eb 05                	jmp    c55a <lodepng_compute_color_stats+0x401>
    c555:	b8 00 00 00 00       	mov    $0x0,%eax
    c55a:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    c55d:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c564:	66 83 f8 ff          	cmp    $0xffff,%ax
    c568:	74 3c                	je     c5a6 <lodepng_compute_color_stats+0x44d>
    c56a:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c571:	66 85 c0             	test   %ax,%ax
    c574:	75 10                	jne    c586 <lodepng_compute_color_stats+0x42d>
    c576:	8b 45 08             	mov    0x8(%ebp),%eax
    c579:	8b 40 04             	mov    0x4(%eax),%eax
    c57c:	85 c0                	test   %eax,%eax
    c57e:	74 26                	je     c5a6 <lodepng_compute_color_stats+0x44d>
    c580:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c584:	75 20                	jne    c5a6 <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    c586:	8b 45 08             	mov    0x8(%ebp),%eax
    c589:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c590:	8b 45 08             	mov    0x8(%ebp),%eax
    c593:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c59a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    c5a1:	e9 8e 00 00 00       	jmp    c634 <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c5a6:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c5ad:	66 85 c0             	test   %ax,%ax
    c5b0:	75 4a                	jne    c5fc <lodepng_compute_color_stats+0x4a3>
    c5b2:	8b 45 08             	mov    0x8(%ebp),%eax
    c5b5:	8b 40 10             	mov    0x10(%eax),%eax
    c5b8:	85 c0                	test   %eax,%eax
    c5ba:	75 40                	jne    c5fc <lodepng_compute_color_stats+0x4a3>
    c5bc:	8b 45 08             	mov    0x8(%ebp),%eax
    c5bf:	8b 40 04             	mov    0x4(%eax),%eax
    c5c2:	85 c0                	test   %eax,%eax
    c5c4:	75 36                	jne    c5fc <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    c5c6:	8b 45 08             	mov    0x8(%ebp),%eax
    c5c9:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c5d0:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c5d7:	8b 45 08             	mov    0x8(%ebp),%eax
    c5da:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c5de:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    c5e5:	8b 45 08             	mov    0x8(%ebp),%eax
    c5e8:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c5ec:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    c5f3:	8b 45 08             	mov    0x8(%ebp),%eax
    c5f6:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c5fa:	eb 38                	jmp    c634 <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    c5fc:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c603:	66 83 f8 ff          	cmp    $0xffff,%ax
    c607:	75 2b                	jne    c634 <lodepng_compute_color_stats+0x4db>
    c609:	8b 45 08             	mov    0x8(%ebp),%eax
    c60c:	8b 40 04             	mov    0x4(%eax),%eax
    c60f:	85 c0                	test   %eax,%eax
    c611:	74 21                	je     c634 <lodepng_compute_color_stats+0x4db>
    c613:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c617:	74 1b                	je     c634 <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c619:	8b 45 08             	mov    0x8(%ebp),%eax
    c61c:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c623:	8b 45 08             	mov    0x8(%ebp),%eax
    c626:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c62d:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c634:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c638:	74 12                	je     c64c <lodepng_compute_color_stats+0x4f3>
    c63a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c63e:	74 0c                	je     c64c <lodepng_compute_color_stats+0x4f3>
    c640:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c644:	74 06                	je     c64c <lodepng_compute_color_stats+0x4f3>
    c646:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c64a:	75 12                	jne    c65e <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    c64c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c650:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c653:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c656:	0f 85 43 fe ff ff    	jne    c49f <lodepng_compute_color_stats+0x346>
    c65c:	eb 01                	jmp    c65f <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c65e:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    c65f:	8b 45 08             	mov    0x8(%ebp),%eax
    c662:	8b 40 04             	mov    0x4(%eax),%eax
    c665:	85 c0                	test   %eax,%eax
    c667:	0f 84 e0 05 00 00    	je     cc4d <lodepng_compute_color_stats+0xaf4>
    c66d:	8b 45 08             	mov    0x8(%ebp),%eax
    c670:	8b 40 10             	mov    0x10(%eax),%eax
    c673:	85 c0                	test   %eax,%eax
    c675:	0f 85 d2 05 00 00    	jne    cc4d <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    c67b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c682:	e9 94 00 00 00       	jmp    c71b <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c687:	83 ec 04             	sub    $0x4,%esp
    c68a:	ff 75 18             	pushl  0x18(%ebp)
    c68d:	ff 75 f4             	pushl  -0xc(%ebp)
    c690:	ff 75 0c             	pushl  0xc(%ebp)
    c693:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c699:	50                   	push   %eax
    c69a:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c6a0:	50                   	push   %eax
    c6a1:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c6a7:	50                   	push   %eax
    c6a8:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c6ae:	50                   	push   %eax
    c6af:	e8 a2 ef ff ff       	call   b656 <getPixelColorRGBA16>
    c6b4:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    c6b7:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c6be:	66 85 c0             	test   %ax,%ax
    c6c1:	74 54                	je     c717 <lodepng_compute_color_stats+0x5be>
    c6c3:	8b 45 08             	mov    0x8(%ebp),%eax
    c6c6:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c6ca:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c6d1:	66 39 c2             	cmp    %ax,%dx
    c6d4:	75 41                	jne    c717 <lodepng_compute_color_stats+0x5be>
    c6d6:	8b 45 08             	mov    0x8(%ebp),%eax
    c6d9:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c6dd:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c6e4:	66 39 c2             	cmp    %ax,%dx
    c6e7:	75 2e                	jne    c717 <lodepng_compute_color_stats+0x5be>
    c6e9:	8b 45 08             	mov    0x8(%ebp),%eax
    c6ec:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c6f0:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c6f7:	66 39 c2             	cmp    %ax,%dx
    c6fa:	75 1b                	jne    c717 <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c6fc:	8b 45 08             	mov    0x8(%ebp),%eax
    c6ff:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c706:	8b 45 08             	mov    0x8(%ebp),%eax
    c709:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c710:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    c717:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c71b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c71e:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c721:	0f 85 60 ff ff ff    	jne    c687 <lodepng_compute_color_stats+0x52e>
    c727:	e9 21 05 00 00       	jmp    cc4d <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    c72c:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    c733:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    c73a:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    c741:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    c748:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c74f:	e9 ab 03 00 00       	jmp    caff <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c754:	83 ec 04             	sub    $0x4,%esp
    c757:	ff 75 18             	pushl  0x18(%ebp)
    c75a:	ff 75 f4             	pushl  -0xc(%ebp)
    c75d:	ff 75 0c             	pushl  0xc(%ebp)
    c760:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    c766:	50                   	push   %eax
    c767:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    c76d:	50                   	push   %eax
    c76e:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    c774:	50                   	push   %eax
    c775:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    c77b:	50                   	push   %eax
    c77c:	e8 1e de ff ff       	call   a59f <getPixelColorRGBA8>
    c781:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    c784:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c788:	75 41                	jne    c7cb <lodepng_compute_color_stats+0x672>
    c78a:	8b 45 08             	mov    0x8(%ebp),%eax
    c78d:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c793:	83 f8 07             	cmp    $0x7,%eax
    c796:	77 33                	ja     c7cb <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    c798:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c79f:	0f b6 c0             	movzbl %al,%eax
    c7a2:	83 ec 0c             	sub    $0xc,%esp
    c7a5:	50                   	push   %eax
    c7a6:	e8 1d f9 ff ff       	call   c0c8 <getValueRequiredBits>
    c7ab:	83 c4 10             	add    $0x10,%esp
    c7ae:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    c7b1:	8b 45 08             	mov    0x8(%ebp),%eax
    c7b4:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c7ba:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    c7bd:	73 0c                	jae    c7cb <lodepng_compute_color_stats+0x672>
    c7bf:	8b 45 08             	mov    0x8(%ebp),%eax
    c7c2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    c7c5:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    c7cb:	8b 45 08             	mov    0x8(%ebp),%eax
    c7ce:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c7d4:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c7d7:	0f 93 c0             	setae  %al
    c7da:	0f b6 c0             	movzbl %al,%eax
    c7dd:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    c7e0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c7e4:	75 4f                	jne    c835 <lodepng_compute_color_stats+0x6dc>
    c7e6:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c7ed:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c7f4:	38 c2                	cmp    %al,%dl
    c7f6:	75 12                	jne    c80a <lodepng_compute_color_stats+0x6b1>
    c7f8:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c7ff:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c806:	38 c2                	cmp    %al,%dl
    c808:	74 2b                	je     c835 <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    c80a:	8b 45 08             	mov    0x8(%ebp),%eax
    c80d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c813:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    c81a:	8b 45 08             	mov    0x8(%ebp),%eax
    c81d:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c823:	83 f8 07             	cmp    $0x7,%eax
    c826:	77 0d                	ja     c835 <lodepng_compute_color_stats+0x6dc>
    c828:	8b 45 08             	mov    0x8(%ebp),%eax
    c82b:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c832:	00 00 00 
      }

      if(!alpha_done) {
    c835:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c839:	0f 85 65 01 00 00    	jne    c9a4 <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c83f:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c846:	0f b6 d0             	movzbl %al,%edx
    c849:	8b 45 08             	mov    0x8(%ebp),%eax
    c84c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c850:	66 39 c2             	cmp    %ax,%dx
    c853:	75 33                	jne    c888 <lodepng_compute_color_stats+0x72f>
    c855:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c85c:	0f b6 d0             	movzbl %al,%edx
    c85f:	8b 45 08             	mov    0x8(%ebp),%eax
    c862:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    c866:	66 39 c2             	cmp    %ax,%dx
    c869:	75 1d                	jne    c888 <lodepng_compute_color_stats+0x72f>
    c86b:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c872:	0f b6 d0             	movzbl %al,%edx
    c875:	8b 45 08             	mov    0x8(%ebp),%eax
    c878:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    c87c:	66 39 c2             	cmp    %ax,%dx
    c87f:	75 07                	jne    c888 <lodepng_compute_color_stats+0x72f>
    c881:	b8 01 00 00 00       	mov    $0x1,%eax
    c886:	eb 05                	jmp    c88d <lodepng_compute_color_stats+0x734>
    c888:	b8 00 00 00 00       	mov    $0x0,%eax
    c88d:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    c890:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c897:	3c ff                	cmp    $0xff,%al
    c899:	74 5a                	je     c8f5 <lodepng_compute_color_stats+0x79c>
    c89b:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c8a2:	84 c0                	test   %al,%al
    c8a4:	75 10                	jne    c8b6 <lodepng_compute_color_stats+0x75d>
    c8a6:	8b 45 08             	mov    0x8(%ebp),%eax
    c8a9:	8b 40 04             	mov    0x4(%eax),%eax
    c8ac:	85 c0                	test   %eax,%eax
    c8ae:	74 45                	je     c8f5 <lodepng_compute_color_stats+0x79c>
    c8b0:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c8b4:	75 3f                	jne    c8f5 <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    c8b6:	8b 45 08             	mov    0x8(%ebp),%eax
    c8b9:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c8c0:	8b 45 08             	mov    0x8(%ebp),%eax
    c8c3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c8ca:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c8d1:	8b 45 08             	mov    0x8(%ebp),%eax
    c8d4:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c8da:	83 f8 07             	cmp    $0x7,%eax
    c8dd:	0f 87 c1 00 00 00    	ja     c9a4 <lodepng_compute_color_stats+0x84b>
    c8e3:	8b 45 08             	mov    0x8(%ebp),%eax
    c8e6:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c8ed:	00 00 00 
    c8f0:	e9 af 00 00 00       	jmp    c9a4 <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c8f5:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c8fc:	84 c0                	test   %al,%al
    c8fe:	75 53                	jne    c953 <lodepng_compute_color_stats+0x7fa>
    c900:	8b 45 08             	mov    0x8(%ebp),%eax
    c903:	8b 40 10             	mov    0x10(%eax),%eax
    c906:	85 c0                	test   %eax,%eax
    c908:	75 49                	jne    c953 <lodepng_compute_color_stats+0x7fa>
    c90a:	8b 45 08             	mov    0x8(%ebp),%eax
    c90d:	8b 40 04             	mov    0x4(%eax),%eax
    c910:	85 c0                	test   %eax,%eax
    c912:	75 3f                	jne    c953 <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    c914:	8b 45 08             	mov    0x8(%ebp),%eax
    c917:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c91e:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c925:	0f b6 d0             	movzbl %al,%edx
    c928:	8b 45 08             	mov    0x8(%ebp),%eax
    c92b:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c92f:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c936:	0f b6 d0             	movzbl %al,%edx
    c939:	8b 45 08             	mov    0x8(%ebp),%eax
    c93c:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c940:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c947:	0f b6 d0             	movzbl %al,%edx
    c94a:	8b 45 08             	mov    0x8(%ebp),%eax
    c94d:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c951:	eb 51                	jmp    c9a4 <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    c953:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c95a:	3c ff                	cmp    $0xff,%al
    c95c:	75 46                	jne    c9a4 <lodepng_compute_color_stats+0x84b>
    c95e:	8b 45 08             	mov    0x8(%ebp),%eax
    c961:	8b 40 04             	mov    0x4(%eax),%eax
    c964:	85 c0                	test   %eax,%eax
    c966:	74 3c                	je     c9a4 <lodepng_compute_color_stats+0x84b>
    c968:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c96c:	74 36                	je     c9a4 <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c96e:	8b 45 08             	mov    0x8(%ebp),%eax
    c971:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c978:	8b 45 08             	mov    0x8(%ebp),%eax
    c97b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c982:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c989:	8b 45 08             	mov    0x8(%ebp),%eax
    c98c:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c992:	83 f8 07             	cmp    $0x7,%eax
    c995:	77 0d                	ja     c9a4 <lodepng_compute_color_stats+0x84b>
    c997:	8b 45 08             	mov    0x8(%ebp),%eax
    c99a:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c9a1:	00 00 00 
        }
      }

      if(!numcolors_done) {
    c9a4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c9a8:	0f 85 35 01 00 00    	jne    cae3 <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    c9ae:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c9b5:	0f b6 d8             	movzbl %al,%ebx
    c9b8:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c9bf:	0f b6 c8             	movzbl %al,%ecx
    c9c2:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c9c9:	0f b6 d0             	movzbl %al,%edx
    c9cc:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c9d3:	0f b6 c0             	movzbl %al,%eax
    c9d6:	83 ec 0c             	sub    $0xc,%esp
    c9d9:	53                   	push   %ebx
    c9da:	51                   	push   %ecx
    c9db:	52                   	push   %edx
    c9dc:	50                   	push   %eax
    c9dd:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c9e3:	50                   	push   %eax
    c9e4:	e8 1c d4 ff ff       	call   9e05 <color_tree_has>
    c9e9:	83 c4 20             	add    $0x20,%esp
    c9ec:	85 c0                	test   %eax,%eax
    c9ee:	0f 85 ef 00 00 00    	jne    cae3 <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    c9f4:	8b 45 08             	mov    0x8(%ebp),%eax
    c9f7:	8b 70 14             	mov    0x14(%eax),%esi
    c9fa:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ca01:	0f b6 d8             	movzbl %al,%ebx
    ca04:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ca0b:	0f b6 c8             	movzbl %al,%ecx
    ca0e:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ca15:	0f b6 d0             	movzbl %al,%edx
    ca18:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca1f:	0f b6 c0             	movzbl %al,%eax
    ca22:	83 ec 08             	sub    $0x8,%esp
    ca25:	56                   	push   %esi
    ca26:	53                   	push   %ebx
    ca27:	51                   	push   %ecx
    ca28:	52                   	push   %edx
    ca29:	50                   	push   %eax
    ca2a:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    ca30:	50                   	push   %eax
    ca31:	e8 1a d4 ff ff       	call   9e50 <color_tree_add>
    ca36:	83 c4 20             	add    $0x20,%esp
    ca39:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    ca3c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ca40:	0f 85 06 02 00 00    	jne    cc4c <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    ca46:	8b 45 08             	mov    0x8(%ebp),%eax
    ca49:	8b 40 14             	mov    0x14(%eax),%eax
    ca4c:	3d ff 00 00 00       	cmp    $0xff,%eax
    ca51:	77 6f                	ja     cac2 <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    ca53:	8b 45 08             	mov    0x8(%ebp),%eax
    ca56:	83 c0 18             	add    $0x18,%eax
    ca59:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    ca5c:	8b 45 08             	mov    0x8(%ebp),%eax
    ca5f:	8b 40 14             	mov    0x14(%eax),%eax
    ca62:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    ca65:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca68:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ca6f:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca72:	01 c2                	add    %eax,%edx
    ca74:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca7b:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    ca7d:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca80:	c1 e0 02             	shl    $0x2,%eax
    ca83:	8d 50 01             	lea    0x1(%eax),%edx
    ca86:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca89:	01 c2                	add    %eax,%edx
    ca8b:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ca92:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    ca94:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca97:	c1 e0 02             	shl    $0x2,%eax
    ca9a:	8d 50 02             	lea    0x2(%eax),%edx
    ca9d:	8b 45 bc             	mov    -0x44(%ebp),%eax
    caa0:	01 c2                	add    %eax,%edx
    caa2:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    caa9:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    caab:	8b 45 b8             	mov    -0x48(%ebp),%eax
    caae:	c1 e0 02             	shl    $0x2,%eax
    cab1:	8d 50 03             	lea    0x3(%eax),%edx
    cab4:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cab7:	01 c2                	add    %eax,%edx
    cab9:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cac0:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    cac2:	8b 45 08             	mov    0x8(%ebp),%eax
    cac5:	8b 40 14             	mov    0x14(%eax),%eax
    cac8:	8d 50 01             	lea    0x1(%eax),%edx
    cacb:	8b 45 08             	mov    0x8(%ebp),%eax
    cace:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    cad1:	8b 45 08             	mov    0x8(%ebp),%eax
    cad4:	8b 40 14             	mov    0x14(%eax),%eax
    cad7:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cada:	0f 93 c0             	setae  %al
    cadd:	0f b6 c0             	movzbl %al,%eax
    cae0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cae3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cae7:	74 12                	je     cafb <lodepng_compute_color_stats+0x9a2>
    cae9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    caed:	74 0c                	je     cafb <lodepng_compute_color_stats+0x9a2>
    caef:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    caf3:	74 06                	je     cafb <lodepng_compute_color_stats+0x9a2>
    caf5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    caf9:	75 12                	jne    cb0d <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    cafb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    caff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cb02:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cb05:	0f 85 49 fc ff ff    	jne    c754 <lodepng_compute_color_stats+0x5fb>
    cb0b:	eb 01                	jmp    cb0e <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cb0d:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    cb0e:	8b 45 08             	mov    0x8(%ebp),%eax
    cb11:	8b 40 04             	mov    0x4(%eax),%eax
    cb14:	85 c0                	test   %eax,%eax
    cb16:	0f 84 dd 00 00 00    	je     cbf9 <lodepng_compute_color_stats+0xaa0>
    cb1c:	8b 45 08             	mov    0x8(%ebp),%eax
    cb1f:	8b 40 10             	mov    0x10(%eax),%eax
    cb22:	85 c0                	test   %eax,%eax
    cb24:	0f 85 cf 00 00 00    	jne    cbf9 <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    cb2a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cb31:	e9 b7 00 00 00       	jmp    cbed <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    cb36:	83 ec 04             	sub    $0x4,%esp
    cb39:	ff 75 18             	pushl  0x18(%ebp)
    cb3c:	ff 75 f4             	pushl  -0xc(%ebp)
    cb3f:	ff 75 0c             	pushl  0xc(%ebp)
    cb42:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    cb48:	50                   	push   %eax
    cb49:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    cb4f:	50                   	push   %eax
    cb50:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    cb56:	50                   	push   %eax
    cb57:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    cb5d:	50                   	push   %eax
    cb5e:	e8 3c da ff ff       	call   a59f <getPixelColorRGBA8>
    cb63:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    cb66:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cb6d:	84 c0                	test   %al,%al
    cb6f:	74 78                	je     cbe9 <lodepng_compute_color_stats+0xa90>
    cb71:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cb78:	0f b6 d0             	movzbl %al,%edx
    cb7b:	8b 45 08             	mov    0x8(%ebp),%eax
    cb7e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cb82:	66 39 c2             	cmp    %ax,%dx
    cb85:	75 62                	jne    cbe9 <lodepng_compute_color_stats+0xa90>
    cb87:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cb8e:	0f b6 d0             	movzbl %al,%edx
    cb91:	8b 45 08             	mov    0x8(%ebp),%eax
    cb94:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cb98:	66 39 c2             	cmp    %ax,%dx
    cb9b:	75 4c                	jne    cbe9 <lodepng_compute_color_stats+0xa90>
    cb9d:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cba4:	0f b6 d0             	movzbl %al,%edx
    cba7:	8b 45 08             	mov    0x8(%ebp),%eax
    cbaa:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cbae:	66 39 c2             	cmp    %ax,%dx
    cbb1:	75 36                	jne    cbe9 <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cbb3:	8b 45 08             	mov    0x8(%ebp),%eax
    cbb6:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cbbd:	8b 45 08             	mov    0x8(%ebp),%eax
    cbc0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cbc7:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cbce:	8b 45 08             	mov    0x8(%ebp),%eax
    cbd1:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cbd7:	83 f8 07             	cmp    $0x7,%eax
    cbda:	77 0d                	ja     cbe9 <lodepng_compute_color_stats+0xa90>
    cbdc:	8b 45 08             	mov    0x8(%ebp),%eax
    cbdf:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cbe6:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    cbe9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cbed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cbf0:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cbf3:	0f 85 3d ff ff ff    	jne    cb36 <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    cbf9:	8b 45 08             	mov    0x8(%ebp),%eax
    cbfc:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    cc00:	8b 45 08             	mov    0x8(%ebp),%eax
    cc03:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cc07:	c1 e0 08             	shl    $0x8,%eax
    cc0a:	01 c2                	add    %eax,%edx
    cc0c:	8b 45 08             	mov    0x8(%ebp),%eax
    cc0f:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    cc13:	8b 45 08             	mov    0x8(%ebp),%eax
    cc16:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cc1a:	8b 45 08             	mov    0x8(%ebp),%eax
    cc1d:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cc21:	c1 e0 08             	shl    $0x8,%eax
    cc24:	01 c2                	add    %eax,%edx
    cc26:	8b 45 08             	mov    0x8(%ebp),%eax
    cc29:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    cc2d:	8b 45 08             	mov    0x8(%ebp),%eax
    cc30:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    cc34:	8b 45 08             	mov    0x8(%ebp),%eax
    cc37:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cc3b:	c1 e0 08             	shl    $0x8,%eax
    cc3e:	01 c2                	add    %eax,%edx
    cc40:	8b 45 08             	mov    0x8(%ebp),%eax
    cc43:	66 89 50 0c          	mov    %dx,0xc(%eax)
    cc47:	eb 04                	jmp    cc4d <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    cc49:	90                   	nop
    cc4a:	eb 01                	jmp    cc4d <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    cc4c:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    cc4d:	83 ec 0c             	sub    $0xc,%esp
    cc50:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cc56:	50                   	push   %eax
    cc57:	e8 91 d0 ff ff       	call   9ced <color_tree_cleanup>
    cc5c:	83 c4 10             	add    $0x10,%esp
  return error;
    cc5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    cc62:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cc65:	5b                   	pop    %ebx
    cc66:	5e                   	pop    %esi
    cc67:	5d                   	pop    %ebp
    cc68:	c3                   	ret    

0000cc69 <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    cc69:	55                   	push   %ebp
    cc6a:	89 e5                	mov    %esp,%ebp
    cc6c:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    cc6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    cc76:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cc79:	50                   	push   %eax
    cc7a:	e8 d1 bd ff ff       	call   8a50 <lodepng_color_mode_init>
    cc7f:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    cc82:	8b 45 0c             	mov    0xc(%ebp),%eax
    cc85:	c1 e8 08             	shr    $0x8,%eax
    cc88:	88 45 ec             	mov    %al,-0x14(%ebp)
    cc8b:	8b 45 0c             	mov    0xc(%ebp),%eax
    cc8e:	88 45 ed             	mov    %al,-0x13(%ebp)
    cc91:	8b 45 10             	mov    0x10(%ebp),%eax
    cc94:	c1 e8 08             	shr    $0x8,%eax
    cc97:	88 45 ee             	mov    %al,-0x12(%ebp)
    cc9a:	8b 45 10             	mov    0x10(%ebp),%eax
    cc9d:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    cca0:	8b 45 14             	mov    0x14(%ebp),%eax
    cca3:	c1 e8 08             	shr    $0x8,%eax
    cca6:	88 45 f0             	mov    %al,-0x10(%ebp)
    cca9:	8b 45 14             	mov    0x14(%ebp),%eax
    ccac:	88 45 f1             	mov    %al,-0xf(%ebp)
    ccaf:	8b 45 18             	mov    0x18(%ebp),%eax
    ccb2:	c1 e8 08             	shr    $0x8,%eax
    ccb5:	88 45 f2             	mov    %al,-0xe(%ebp)
    ccb8:	8b 45 18             	mov    0x18(%ebp),%eax
    ccbb:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    ccbe:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    ccc5:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    cccc:	83 ec 0c             	sub    $0xc,%esp
    cccf:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ccd2:	50                   	push   %eax
    ccd3:	6a 01                	push   $0x1
    ccd5:	6a 01                	push   $0x1
    ccd7:	8d 45 ec             	lea    -0x14(%ebp),%eax
    ccda:	50                   	push   %eax
    ccdb:	ff 75 08             	pushl  0x8(%ebp)
    ccde:	e8 76 f4 ff ff       	call   c159 <lodepng_compute_color_stats>
    cce3:	83 c4 20             	add    $0x20,%esp
    cce6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    cce9:	83 ec 0c             	sub    $0xc,%esp
    ccec:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ccef:	50                   	push   %eax
    ccf0:	e8 4e be ff ff       	call   8b43 <lodepng_color_mode_cleanup>
    ccf5:	83 c4 10             	add    $0x10,%esp
  return error;
    ccf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ccfb:	c9                   	leave  
    ccfc:	c3                   	ret    

0000ccfd <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    ccfd:	55                   	push   %ebp
    ccfe:	89 e5                	mov    %esp,%ebp
    cd00:	56                   	push   %esi
    cd01:	53                   	push   %ebx
    cd02:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    cd05:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    cd0c:	8b 45 10             	mov    0x10(%ebp),%eax
    cd0f:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    cd15:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    cd18:	8b 45 10             	mov    0x10(%ebp),%eax
    cd1b:	8b 40 10             	mov    0x10(%eax),%eax
    cd1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    cd21:	8b 45 10             	mov    0x10(%ebp),%eax
    cd24:	8b 40 04             	mov    0x4(%eax),%eax
    cd27:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    cd2a:	8b 45 10             	mov    0x10(%ebp),%eax
    cd2d:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cd33:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    cd36:	8b 45 08             	mov    0x8(%ebp),%eax
    cd39:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    cd40:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cd44:	74 21                	je     cd67 <auto_choose_color+0x6a>
    cd46:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    cd4a:	7f 1b                	jg     cd67 <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    cd4c:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    cd53:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cd5a:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    cd5e:	77 07                	ja     cd67 <auto_choose_color+0x6a>
    cd60:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    cd67:	8b 45 10             	mov    0x10(%ebp),%eax
    cd6a:	8b 00                	mov    (%eax),%eax
    cd6c:	85 c0                	test   %eax,%eax
    cd6e:	0f 94 c0             	sete   %al
    cd71:	0f b6 c0             	movzbl %al,%eax
    cd74:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    cd77:	8b 45 10             	mov    0x10(%ebp),%eax
    cd7a:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    cd80:	85 c0                	test   %eax,%eax
    cd82:	75 07                	jne    cd8b <auto_choose_color+0x8e>
    cd84:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    cd8b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cd8f:	75 0d                	jne    cd9e <auto_choose_color+0xa1>
    cd91:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    cd95:	77 07                	ja     cd9e <auto_choose_color+0xa1>
    cd97:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    cd9e:	8b 45 10             	mov    0x10(%ebp),%eax
    cda1:	8b 40 14             	mov    0x14(%eax),%eax
    cda4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    cda7:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    cdab:	7e 21                	jle    cdce <auto_choose_color+0xd1>
    cdad:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    cdb1:	7e 14                	jle    cdc7 <auto_choose_color+0xca>
    cdb3:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    cdb7:	7f 07                	jg     cdc0 <auto_choose_color+0xc3>
    cdb9:	b8 04 00 00 00       	mov    $0x4,%eax
    cdbe:	eb 13                	jmp    cdd3 <auto_choose_color+0xd6>
    cdc0:	b8 08 00 00 00       	mov    $0x8,%eax
    cdc5:	eb 0c                	jmp    cdd3 <auto_choose_color+0xd6>
    cdc7:	b8 02 00 00 00       	mov    $0x2,%eax
    cdcc:	eb 05                	jmp    cdd3 <auto_choose_color+0xd6>
    cdce:	b8 01 00 00 00       	mov    $0x1,%eax
    cdd3:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    cdd6:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    cddd:	7f 13                	jg     cdf2 <auto_choose_color+0xf5>
    cddf:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    cde3:	77 0d                	ja     cdf2 <auto_choose_color+0xf5>
    cde5:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    cde9:	74 07                	je     cdf2 <auto_choose_color+0xf5>
    cdeb:	b8 01 00 00 00       	mov    $0x1,%eax
    cdf0:	eb 05                	jmp    cdf7 <auto_choose_color+0xfa>
    cdf2:	b8 00 00 00 00       	mov    $0x0,%eax
    cdf7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    cdfa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cdfd:	01 c0                	add    %eax,%eax
    cdff:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ce02:	7e 07                	jle    ce0b <auto_choose_color+0x10e>
    ce04:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    ce0b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ce0f:	74 15                	je     ce26 <auto_choose_color+0x129>
    ce11:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ce15:	75 0f                	jne    ce26 <auto_choose_color+0x129>
    ce17:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ce1a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    ce1d:	77 07                	ja     ce26 <auto_choose_color+0x129>
    ce1f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    ce26:	8b 45 10             	mov    0x10(%ebp),%eax
    ce29:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    ce2f:	85 c0                	test   %eax,%eax
    ce31:	75 07                	jne    ce3a <auto_choose_color+0x13d>
    ce33:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    ce3a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ce3e:	0f 84 0a 01 00 00    	je     cf4e <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    ce44:	8b 45 10             	mov    0x10(%ebp),%eax
    ce47:	83 c0 18             	add    $0x18,%eax
    ce4a:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    ce4d:	83 ec 0c             	sub    $0xc,%esp
    ce50:	ff 75 08             	pushl  0x8(%ebp)
    ce53:	e8 ef be ff ff       	call   8d47 <lodepng_palette_clear>
    ce58:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    ce5b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ce62:	eb 6e                	jmp    ced2 <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    ce64:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce67:	c1 e0 02             	shl    $0x2,%eax
    ce6a:	8d 50 03             	lea    0x3(%eax),%edx
    ce6d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce70:	01 d0                	add    %edx,%eax
    ce72:	0f b6 00             	movzbl (%eax),%eax
    ce75:	0f b6 d8             	movzbl %al,%ebx
    ce78:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce7b:	c1 e0 02             	shl    $0x2,%eax
    ce7e:	8d 50 02             	lea    0x2(%eax),%edx
    ce81:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce84:	01 d0                	add    %edx,%eax
    ce86:	0f b6 00             	movzbl (%eax),%eax
    ce89:	0f b6 c8             	movzbl %al,%ecx
    ce8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce8f:	c1 e0 02             	shl    $0x2,%eax
    ce92:	8d 50 01             	lea    0x1(%eax),%edx
    ce95:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce98:	01 d0                	add    %edx,%eax
    ce9a:	0f b6 00             	movzbl (%eax),%eax
    ce9d:	0f b6 d0             	movzbl %al,%edx
    cea0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cea3:	c1 e0 02             	shl    $0x2,%eax
    cea6:	89 c6                	mov    %eax,%esi
    cea8:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ceab:	01 f0                	add    %esi,%eax
    cead:	0f b6 00             	movzbl (%eax),%eax
    ceb0:	0f b6 c0             	movzbl %al,%eax
    ceb3:	83 ec 0c             	sub    $0xc,%esp
    ceb6:	53                   	push   %ebx
    ceb7:	51                   	push   %ecx
    ceb8:	52                   	push   %edx
    ceb9:	50                   	push   %eax
    ceba:	ff 75 08             	pushl  0x8(%ebp)
    cebd:	e8 be be ff ff       	call   8d80 <lodepng_palette_add>
    cec2:	83 c4 20             	add    $0x20,%esp
    cec5:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    cec8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    cecc:	75 13                	jne    cee1 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    cece:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ced2:	8b 45 10             	mov    0x10(%ebp),%eax
    ced5:	8b 50 14             	mov    0x14(%eax),%edx
    ced8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cedb:	39 c2                	cmp    %eax,%edx
    cedd:	75 85                	jne    ce64 <auto_choose_color+0x167>
    cedf:	eb 01                	jmp    cee2 <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    cee1:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    cee2:	8b 45 08             	mov    0x8(%ebp),%eax
    cee5:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    ceeb:	8b 45 08             	mov    0x8(%ebp),%eax
    ceee:	8b 55 d0             	mov    -0x30(%ebp),%edx
    cef1:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    cef4:	8b 45 0c             	mov    0xc(%ebp),%eax
    cef7:	8b 00                	mov    (%eax),%eax
    cef9:	83 f8 03             	cmp    $0x3,%eax
    cefc:	0f 85 ec 00 00 00    	jne    cfee <auto_choose_color+0x2f1>
    cf02:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf05:	8b 50 0c             	mov    0xc(%eax),%edx
    cf08:	8b 45 08             	mov    0x8(%ebp),%eax
    cf0b:	8b 40 0c             	mov    0xc(%eax),%eax
    cf0e:	39 c2                	cmp    %eax,%edx
    cf10:	0f 8c d8 00 00 00    	jl     cfee <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    cf16:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf19:	8b 50 04             	mov    0x4(%eax),%edx
    cf1c:	8b 45 08             	mov    0x8(%ebp),%eax
    cf1f:	8b 40 04             	mov    0x4(%eax),%eax
    cf22:	39 c2                	cmp    %eax,%edx
    cf24:	0f 85 c4 00 00 00    	jne    cfee <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    cf2a:	83 ec 0c             	sub    $0xc,%esp
    cf2d:	ff 75 08             	pushl  0x8(%ebp)
    cf30:	e8 0e bc ff ff       	call   8b43 <lodepng_color_mode_cleanup>
    cf35:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    cf38:	83 ec 08             	sub    $0x8,%esp
    cf3b:	ff 75 0c             	pushl  0xc(%ebp)
    cf3e:	ff 75 08             	pushl  0x8(%ebp)
    cf41:	e8 14 bc ff ff       	call   8b5a <lodepng_color_mode_copy>
    cf46:	83 c4 10             	add    $0x10,%esp
    cf49:	e9 a0 00 00 00       	jmp    cfee <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    cf4e:	8b 45 08             	mov    0x8(%ebp),%eax
    cf51:	8b 55 dc             	mov    -0x24(%ebp),%edx
    cf54:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    cf57:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cf5b:	74 14                	je     cf71 <auto_choose_color+0x274>
    cf5d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cf61:	74 07                	je     cf6a <auto_choose_color+0x26d>
    cf63:	b8 04 00 00 00       	mov    $0x4,%eax
    cf68:	eb 19                	jmp    cf83 <auto_choose_color+0x286>
    cf6a:	b8 06 00 00 00       	mov    $0x6,%eax
    cf6f:	eb 12                	jmp    cf83 <auto_choose_color+0x286>
    cf71:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cf75:	74 07                	je     cf7e <auto_choose_color+0x281>
    cf77:	b8 00 00 00 00       	mov    $0x0,%eax
    cf7c:	eb 05                	jmp    cf83 <auto_choose_color+0x286>
    cf7e:	b8 02 00 00 00       	mov    $0x2,%eax
    cf83:	8b 55 08             	mov    0x8(%ebp),%edx
    cf86:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    cf88:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cf8c:	74 60                	je     cfee <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    cf8e:	8b 45 08             	mov    0x8(%ebp),%eax
    cf91:	8b 40 04             	mov    0x4(%eax),%eax
    cf94:	ba 01 00 00 00       	mov    $0x1,%edx
    cf99:	89 c1                	mov    %eax,%ecx
    cf9b:	d3 e2                	shl    %cl,%edx
    cf9d:	89 d0                	mov    %edx,%eax
    cf9f:	83 e8 01             	sub    $0x1,%eax
    cfa2:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    cfa5:	8b 45 10             	mov    0x10(%ebp),%eax
    cfa8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cfac:	0f b7 c0             	movzwl %ax,%eax
    cfaf:	23 45 c8             	and    -0x38(%ebp),%eax
    cfb2:	89 c2                	mov    %eax,%edx
    cfb4:	8b 45 08             	mov    0x8(%ebp),%eax
    cfb7:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    cfba:	8b 45 10             	mov    0x10(%ebp),%eax
    cfbd:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cfc1:	0f b7 c0             	movzwl %ax,%eax
    cfc4:	23 45 c8             	and    -0x38(%ebp),%eax
    cfc7:	89 c2                	mov    %eax,%edx
    cfc9:	8b 45 08             	mov    0x8(%ebp),%eax
    cfcc:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    cfcf:	8b 45 10             	mov    0x10(%ebp),%eax
    cfd2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cfd6:	0f b7 c0             	movzwl %ax,%eax
    cfd9:	23 45 c8             	and    -0x38(%ebp),%eax
    cfdc:	89 c2                	mov    %eax,%edx
    cfde:	8b 45 08             	mov    0x8(%ebp),%eax
    cfe1:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    cfe4:	8b 45 08             	mov    0x8(%ebp),%eax
    cfe7:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    cfee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    cff1:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cff4:	5b                   	pop    %ebx
    cff5:	5e                   	pop    %esi
    cff6:	5d                   	pop    %ebp
    cff7:	c3                   	ret    

0000cff8 <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    cff8:	55                   	push   %ebp
    cff9:	89 e5                	mov    %esp,%ebp
    cffb:	83 ec 1c             	sub    $0x1c,%esp
    cffe:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d001:	8b 55 0c             	mov    0xc(%ebp),%edx
    d004:	8b 45 10             	mov    0x10(%ebp),%eax
    d007:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    d00b:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    d00f:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    d013:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    d017:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d01b:	29 c2                	sub    %eax,%edx
    d01d:	89 d0                	mov    %edx,%eax
    d01f:	99                   	cltd   
    d020:	31 d0                	xor    %edx,%eax
    d022:	29 d0                	sub    %edx,%eax
    d024:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    d028:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d02c:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d030:	29 c2                	sub    %eax,%edx
    d032:	89 d0                	mov    %edx,%eax
    d034:	99                   	cltd   
    d035:	31 d0                	xor    %edx,%eax
    d037:	29 d0                	sub    %edx,%eax
    d039:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    d03d:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d041:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    d045:	01 c2                	add    %eax,%edx
    d047:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d04b:	29 c2                	sub    %eax,%edx
    d04d:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d051:	29 c2                	sub    %eax,%edx
    d053:	89 d0                	mov    %edx,%eax
    d055:	99                   	cltd   
    d056:	31 d0                	xor    %edx,%eax
    d058:	29 d0                	sub    %edx,%eax
    d05a:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    d05e:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d062:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d066:	7d 10                	jge    d078 <paethPredictor+0x80>
    d068:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d06c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d070:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d074:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d078:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d07c:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d080:	7d 06                	jge    d088 <paethPredictor+0x90>
    d082:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d086:	eb 04                	jmp    d08c <paethPredictor+0x94>
    d088:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d08c:	c9                   	leave  
    d08d:	c3                   	ret    

0000d08e <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d08e:	55                   	push   %ebp
    d08f:	89 e5                	mov    %esp,%ebp
    d091:	56                   	push   %esi
    d092:	53                   	push   %ebx
    d093:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d096:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d09d:	e9 e2 00 00 00       	jmp    d184 <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d0a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0a5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d0ac:	8b 45 08             	mov    0x8(%ebp),%eax
    d0af:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d0b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0b5:	8b 14 85 34 a0 01 00 	mov    0x1a034(,%eax,4),%edx
    d0bc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d0bf:	01 c2                	add    %eax,%edx
    d0c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0c4:	8b 04 85 fc 9f 01 00 	mov    0x19ffc(,%eax,4),%eax
    d0cb:	29 c2                	sub    %eax,%edx
    d0cd:	89 d0                	mov    %edx,%eax
    d0cf:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d0d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0d5:	8b 34 85 34 a0 01 00 	mov    0x1a034(,%eax,4),%esi
    d0dc:	89 d8                	mov    %ebx,%eax
    d0de:	ba 00 00 00 00       	mov    $0x0,%edx
    d0e3:	f7 f6                	div    %esi
    d0e5:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d0e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0ea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d0f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    d0f4:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d0f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0fa:	8b 14 85 50 a0 01 00 	mov    0x1a050(,%eax,4),%edx
    d101:	8b 45 20             	mov    0x20(%ebp),%eax
    d104:	01 c2                	add    %eax,%edx
    d106:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d109:	8b 04 85 18 a0 01 00 	mov    0x1a018(,%eax,4),%eax
    d110:	29 c2                	sub    %eax,%edx
    d112:	89 d0                	mov    %edx,%eax
    d114:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d117:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d11a:	8b 34 85 50 a0 01 00 	mov    0x1a050(,%eax,4),%esi
    d121:	89 d8                	mov    %ebx,%eax
    d123:	ba 00 00 00 00       	mov    $0x0,%edx
    d128:	f7 f6                	div    %esi
    d12a:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d12c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d12f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d136:	8b 45 08             	mov    0x8(%ebp),%eax
    d139:	01 d0                	add    %edx,%eax
    d13b:	8b 00                	mov    (%eax),%eax
    d13d:	85 c0                	test   %eax,%eax
    d13f:	75 15                	jne    d156 <Adam7_getpassvalues+0xc8>
    d141:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d144:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d14b:	8b 45 0c             	mov    0xc(%ebp),%eax
    d14e:	01 d0                	add    %edx,%eax
    d150:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d156:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d159:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d160:	8b 45 0c             	mov    0xc(%ebp),%eax
    d163:	01 d0                	add    %edx,%eax
    d165:	8b 00                	mov    (%eax),%eax
    d167:	85 c0                	test   %eax,%eax
    d169:	75 15                	jne    d180 <Adam7_getpassvalues+0xf2>
    d16b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d16e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d175:	8b 45 08             	mov    0x8(%ebp),%eax
    d178:	01 d0                	add    %edx,%eax
    d17a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d180:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d184:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d188:	0f 85 14 ff ff ff    	jne    d0a2 <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d18e:	8b 45 18             	mov    0x18(%ebp),%eax
    d191:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d197:	8b 45 18             	mov    0x18(%ebp),%eax
    d19a:	8b 10                	mov    (%eax),%edx
    d19c:	8b 45 14             	mov    0x14(%ebp),%eax
    d19f:	89 10                	mov    %edx,(%eax)
    d1a1:	8b 45 14             	mov    0x14(%ebp),%eax
    d1a4:	8b 10                	mov    (%eax),%edx
    d1a6:	8b 45 10             	mov    0x10(%ebp),%eax
    d1a9:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d1ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d1b2:	e9 40 01 00 00       	jmp    d2f7 <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d1b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1ba:	83 c0 01             	add    $0x1,%eax
    d1bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1c4:	8b 45 10             	mov    0x10(%ebp),%eax
    d1c7:	01 c2                	add    %eax,%edx
    d1c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1cc:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1d3:	8b 45 10             	mov    0x10(%ebp),%eax
    d1d6:	01 c8                	add    %ecx,%eax
    d1d8:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d1da:	89 c6                	mov    %eax,%esi
    d1dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1df:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1e6:	8b 45 08             	mov    0x8(%ebp),%eax
    d1e9:	01 c8                	add    %ecx,%eax
    d1eb:	8b 00                	mov    (%eax),%eax
    d1ed:	85 c0                	test   %eax,%eax
    d1ef:	74 49                	je     d23a <Adam7_getpassvalues+0x1ac>
    d1f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1f4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1fe:	01 c8                	add    %ecx,%eax
    d200:	8b 00                	mov    (%eax),%eax
    d202:	85 c0                	test   %eax,%eax
    d204:	74 34                	je     d23a <Adam7_getpassvalues+0x1ac>
    d206:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d209:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d210:	8b 45 0c             	mov    0xc(%ebp),%eax
    d213:	01 c8                	add    %ecx,%eax
    d215:	8b 08                	mov    (%eax),%ecx
    d217:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d21a:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d221:	8b 45 08             	mov    0x8(%ebp),%eax
    d224:	01 d8                	add    %ebx,%eax
    d226:	8b 00                	mov    (%eax),%eax
    d228:	0f af 45 24          	imul   0x24(%ebp),%eax
    d22c:	83 c0 07             	add    $0x7,%eax
    d22f:	c1 e8 03             	shr    $0x3,%eax
    d232:	83 c0 01             	add    $0x1,%eax
    d235:	0f af c1             	imul   %ecx,%eax
    d238:	eb 05                	jmp    d23f <Adam7_getpassvalues+0x1b1>
    d23a:	b8 00 00 00 00       	mov    $0x0,%eax
    d23f:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d241:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d243:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d246:	83 c0 01             	add    $0x1,%eax
    d249:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d250:	8b 45 14             	mov    0x14(%ebp),%eax
    d253:	01 c2                	add    %eax,%edx
    d255:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d258:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d25f:	8b 45 14             	mov    0x14(%ebp),%eax
    d262:	01 c8                	add    %ecx,%eax
    d264:	8b 00                	mov    (%eax),%eax
    d266:	89 c6                	mov    %eax,%esi
    d268:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d26b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d272:	8b 45 0c             	mov    0xc(%ebp),%eax
    d275:	01 c8                	add    %ecx,%eax
    d277:	8b 08                	mov    (%eax),%ecx
    d279:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d27c:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d283:	8b 45 08             	mov    0x8(%ebp),%eax
    d286:	01 d8                	add    %ebx,%eax
    d288:	8b 00                	mov    (%eax),%eax
    d28a:	0f af 45 24          	imul   0x24(%ebp),%eax
    d28e:	83 c0 07             	add    $0x7,%eax
    d291:	c1 e8 03             	shr    $0x3,%eax
    d294:	0f af c1             	imul   %ecx,%eax
    d297:	01 f0                	add    %esi,%eax
    d299:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d29b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d29e:	83 c0 01             	add    $0x1,%eax
    d2a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d2a8:	8b 45 18             	mov    0x18(%ebp),%eax
    d2ab:	01 c2                	add    %eax,%edx
    d2ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2b0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d2b7:	8b 45 18             	mov    0x18(%ebp),%eax
    d2ba:	01 c8                	add    %ecx,%eax
    d2bc:	8b 00                	mov    (%eax),%eax
    d2be:	89 c6                	mov    %eax,%esi
    d2c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2c3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d2ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    d2cd:	01 c8                	add    %ecx,%eax
    d2cf:	8b 08                	mov    (%eax),%ecx
    d2d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2d4:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d2db:	8b 45 08             	mov    0x8(%ebp),%eax
    d2de:	01 d8                	add    %ebx,%eax
    d2e0:	8b 00                	mov    (%eax),%eax
    d2e2:	0f af c1             	imul   %ecx,%eax
    d2e5:	0f af 45 24          	imul   0x24(%ebp),%eax
    d2e9:	83 c0 07             	add    $0x7,%eax
    d2ec:	c1 e8 03             	shr    $0x3,%eax
    d2ef:	01 f0                	add    %esi,%eax
    d2f1:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d2f3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d2f7:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d2fb:	0f 85 b6 fe ff ff    	jne    d1b7 <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d301:	90                   	nop
    d302:	83 c4 10             	add    $0x10,%esp
    d305:	5b                   	pop    %ebx
    d306:	5e                   	pop    %esi
    d307:	5d                   	pop    %ebp
    d308:	c3                   	ret    

0000d309 <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    d309:	55                   	push   %ebp
    d30a:	89 e5                	mov    %esp,%ebp
    d30c:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    d30f:	8b 45 10             	mov    0x10(%ebp),%eax
    d312:	05 98 00 00 00       	add    $0x98,%eax
    d317:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    d31a:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    d31e:	74 06                	je     d326 <lodepng_inspect+0x1d>
    d320:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d324:	75 17                	jne    d33d <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    d326:	8b 45 10             	mov    0x10(%ebp),%eax
    d329:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    d330:	00 00 00 
    d333:	b8 30 00 00 00       	mov    $0x30,%eax
    d338:	e9 ce 02 00 00       	jmp    d60b <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    d33d:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    d341:	7f 17                	jg     d35a <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    d343:	8b 45 10             	mov    0x10(%ebp),%eax
    d346:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    d34d:	00 00 00 
    d350:	b8 1b 00 00 00       	mov    $0x1b,%eax
    d355:	e9 b1 02 00 00       	jmp    d60b <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    d35a:	83 ec 0c             	sub    $0xc,%esp
    d35d:	ff 75 f4             	pushl  -0xc(%ebp)
    d360:	e8 63 c7 ff ff       	call   9ac8 <lodepng_info_cleanup>
    d365:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    d368:	83 ec 0c             	sub    $0xc,%esp
    d36b:	ff 75 f4             	pushl  -0xc(%ebp)
    d36e:	e8 74 c6 ff ff       	call   99e7 <lodepng_info_init>
    d373:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    d376:	8b 45 14             	mov    0x14(%ebp),%eax
    d379:	0f b6 00             	movzbl (%eax),%eax
    d37c:	3c 89                	cmp    $0x89,%al
    d37e:	75 5b                	jne    d3db <lodepng_inspect+0xd2>
    d380:	8b 45 14             	mov    0x14(%ebp),%eax
    d383:	83 c0 01             	add    $0x1,%eax
    d386:	0f b6 00             	movzbl (%eax),%eax
    d389:	3c 50                	cmp    $0x50,%al
    d38b:	75 4e                	jne    d3db <lodepng_inspect+0xd2>
    d38d:	8b 45 14             	mov    0x14(%ebp),%eax
    d390:	83 c0 02             	add    $0x2,%eax
    d393:	0f b6 00             	movzbl (%eax),%eax
    d396:	3c 4e                	cmp    $0x4e,%al
    d398:	75 41                	jne    d3db <lodepng_inspect+0xd2>
    d39a:	8b 45 14             	mov    0x14(%ebp),%eax
    d39d:	83 c0 03             	add    $0x3,%eax
    d3a0:	0f b6 00             	movzbl (%eax),%eax
    d3a3:	3c 47                	cmp    $0x47,%al
    d3a5:	75 34                	jne    d3db <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    d3a7:	8b 45 14             	mov    0x14(%ebp),%eax
    d3aa:	83 c0 04             	add    $0x4,%eax
    d3ad:	0f b6 00             	movzbl (%eax),%eax
    d3b0:	3c 0d                	cmp    $0xd,%al
    d3b2:	75 27                	jne    d3db <lodepng_inspect+0xd2>
    d3b4:	8b 45 14             	mov    0x14(%ebp),%eax
    d3b7:	83 c0 05             	add    $0x5,%eax
    d3ba:	0f b6 00             	movzbl (%eax),%eax
    d3bd:	3c 0a                	cmp    $0xa,%al
    d3bf:	75 1a                	jne    d3db <lodepng_inspect+0xd2>
    d3c1:	8b 45 14             	mov    0x14(%ebp),%eax
    d3c4:	83 c0 06             	add    $0x6,%eax
    d3c7:	0f b6 00             	movzbl (%eax),%eax
    d3ca:	3c 1a                	cmp    $0x1a,%al
    d3cc:	75 0d                	jne    d3db <lodepng_inspect+0xd2>
    d3ce:	8b 45 14             	mov    0x14(%ebp),%eax
    d3d1:	83 c0 07             	add    $0x7,%eax
    d3d4:	0f b6 00             	movzbl (%eax),%eax
    d3d7:	3c 0a                	cmp    $0xa,%al
    d3d9:	74 17                	je     d3f2 <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    d3db:	8b 45 10             	mov    0x10(%ebp),%eax
    d3de:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    d3e5:	00 00 00 
    d3e8:	b8 1c 00 00 00       	mov    $0x1c,%eax
    d3ed:	e9 19 02 00 00       	jmp    d60b <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    d3f2:	8b 45 14             	mov    0x14(%ebp),%eax
    d3f5:	83 c0 08             	add    $0x8,%eax
    d3f8:	83 ec 0c             	sub    $0xc,%esp
    d3fb:	50                   	push   %eax
    d3fc:	e8 c2 ae ff ff       	call   82c3 <lodepng_chunk_length>
    d401:	83 c4 10             	add    $0x10,%esp
    d404:	83 f8 0d             	cmp    $0xd,%eax
    d407:	74 17                	je     d420 <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    d409:	8b 45 10             	mov    0x10(%ebp),%eax
    d40c:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    d413:	00 00 00 
    d416:	b8 5e 00 00 00       	mov    $0x5e,%eax
    d41b:	e9 eb 01 00 00       	jmp    d60b <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    d420:	8b 45 14             	mov    0x14(%ebp),%eax
    d423:	83 c0 08             	add    $0x8,%eax
    d426:	83 ec 08             	sub    $0x8,%esp
    d429:	68 6c a0 01 00       	push   $0x1a06c
    d42e:	50                   	push   %eax
    d42f:	e8 dc ae ff ff       	call   8310 <lodepng_chunk_type_equals>
    d434:	83 c4 10             	add    $0x10,%esp
    d437:	84 c0                	test   %al,%al
    d439:	75 17                	jne    d452 <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    d43b:	8b 45 10             	mov    0x10(%ebp),%eax
    d43e:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    d445:	00 00 00 
    d448:	b8 1d 00 00 00       	mov    $0x1d,%eax
    d44d:	e9 b9 01 00 00       	jmp    d60b <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    d452:	8b 45 14             	mov    0x14(%ebp),%eax
    d455:	83 c0 10             	add    $0x10,%eax
    d458:	83 ec 0c             	sub    $0xc,%esp
    d45b:	50                   	push   %eax
    d45c:	e8 5e 62 ff ff       	call   36bf <lodepng_read32bitInt>
    d461:	83 c4 10             	add    $0x10,%esp
    d464:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    d467:	8b 45 14             	mov    0x14(%ebp),%eax
    d46a:	83 c0 14             	add    $0x14,%eax
    d46d:	83 ec 0c             	sub    $0xc,%esp
    d470:	50                   	push   %eax
    d471:	e8 49 62 ff ff       	call   36bf <lodepng_read32bitInt>
    d476:	83 c4 10             	add    $0x10,%esp
    d479:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    d47c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d480:	74 08                	je     d48a <lodepng_inspect+0x181>
    d482:	8b 45 08             	mov    0x8(%ebp),%eax
    d485:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d488:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    d48a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d48e:	74 08                	je     d498 <lodepng_inspect+0x18f>
    d490:	8b 45 0c             	mov    0xc(%ebp),%eax
    d493:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d496:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    d498:	8b 45 14             	mov    0x14(%ebp),%eax
    d49b:	83 c0 18             	add    $0x18,%eax
    d49e:	0f b6 00             	movzbl (%eax),%eax
    d4a1:	0f b6 d0             	movzbl %al,%edx
    d4a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4a7:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    d4aa:	8b 45 14             	mov    0x14(%ebp),%eax
    d4ad:	83 c0 19             	add    $0x19,%eax
    d4b0:	0f b6 00             	movzbl (%eax),%eax
    d4b3:	0f b6 d0             	movzbl %al,%edx
    d4b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4b9:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    d4bc:	8b 45 14             	mov    0x14(%ebp),%eax
    d4bf:	83 c0 1a             	add    $0x1a,%eax
    d4c2:	0f b6 00             	movzbl (%eax),%eax
    d4c5:	0f b6 d0             	movzbl %al,%edx
    d4c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4cb:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    d4cd:	8b 45 14             	mov    0x14(%ebp),%eax
    d4d0:	83 c0 1b             	add    $0x1b,%eax
    d4d3:	0f b6 00             	movzbl (%eax),%eax
    d4d6:	0f b6 d0             	movzbl %al,%edx
    d4d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4dc:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    d4df:	8b 45 14             	mov    0x14(%ebp),%eax
    d4e2:	83 c0 1c             	add    $0x1c,%eax
    d4e5:	0f b6 00             	movzbl (%eax),%eax
    d4e8:	0f b6 d0             	movzbl %al,%edx
    d4eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4ee:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    d4f1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d4f5:	74 06                	je     d4fd <lodepng_inspect+0x1f4>
    d4f7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d4fb:	75 17                	jne    d514 <lodepng_inspect+0x20b>
    d4fd:	8b 45 10             	mov    0x10(%ebp),%eax
    d500:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    d507:	00 00 00 
    d50a:	b8 5d 00 00 00       	mov    $0x5d,%eax
    d50f:	e9 f7 00 00 00       	jmp    d60b <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    d514:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d517:	8b 50 10             	mov    0x10(%eax),%edx
    d51a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d51d:	8b 40 0c             	mov    0xc(%eax),%eax
    d520:	83 ec 08             	sub    $0x8,%esp
    d523:	52                   	push   %edx
    d524:	50                   	push   %eax
    d525:	e8 d4 b3 ff ff       	call   88fe <checkColorValidity>
    d52a:	83 c4 10             	add    $0x10,%esp
    d52d:	89 c2                	mov    %eax,%edx
    d52f:	8b 45 10             	mov    0x10(%ebp),%eax
    d532:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    d538:	8b 45 10             	mov    0x10(%ebp),%eax
    d53b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d541:	85 c0                	test   %eax,%eax
    d543:	74 0e                	je     d553 <lodepng_inspect+0x24a>
    d545:	8b 45 10             	mov    0x10(%ebp),%eax
    d548:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d54e:	e9 b8 00 00 00       	jmp    d60b <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    d553:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d556:	8b 00                	mov    (%eax),%eax
    d558:	85 c0                	test   %eax,%eax
    d55a:	74 17                	je     d573 <lodepng_inspect+0x26a>
    d55c:	8b 45 10             	mov    0x10(%ebp),%eax
    d55f:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    d566:	00 00 00 
    d569:	b8 20 00 00 00       	mov    $0x20,%eax
    d56e:	e9 98 00 00 00       	jmp    d60b <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    d573:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d576:	8b 40 04             	mov    0x4(%eax),%eax
    d579:	85 c0                	test   %eax,%eax
    d57b:	74 14                	je     d591 <lodepng_inspect+0x288>
    d57d:	8b 45 10             	mov    0x10(%ebp),%eax
    d580:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    d587:	00 00 00 
    d58a:	b8 21 00 00 00       	mov    $0x21,%eax
    d58f:	eb 7a                	jmp    d60b <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    d591:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d594:	8b 40 08             	mov    0x8(%eax),%eax
    d597:	83 f8 01             	cmp    $0x1,%eax
    d59a:	76 14                	jbe    d5b0 <lodepng_inspect+0x2a7>
    d59c:	8b 45 10             	mov    0x10(%ebp),%eax
    d59f:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    d5a6:	00 00 00 
    d5a9:	b8 22 00 00 00       	mov    $0x22,%eax
    d5ae:	eb 5b                	jmp    d60b <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    d5b0:	8b 45 10             	mov    0x10(%ebp),%eax
    d5b3:	8b 40 18             	mov    0x18(%eax),%eax
    d5b6:	85 c0                	test   %eax,%eax
    d5b8:	75 48                	jne    d602 <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    d5ba:	8b 45 14             	mov    0x14(%ebp),%eax
    d5bd:	83 c0 1d             	add    $0x1d,%eax
    d5c0:	83 ec 0c             	sub    $0xc,%esp
    d5c3:	50                   	push   %eax
    d5c4:	e8 f6 60 ff ff       	call   36bf <lodepng_read32bitInt>
    d5c9:	83 c4 10             	add    $0x10,%esp
    d5cc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    d5cf:	8b 45 14             	mov    0x14(%ebp),%eax
    d5d2:	83 c0 0c             	add    $0xc,%eax
    d5d5:	83 ec 08             	sub    $0x8,%esp
    d5d8:	6a 11                	push   $0x11
    d5da:	50                   	push   %eax
    d5db:	e8 71 ab ff ff       	call   8151 <lodepng_crc32>
    d5e0:	83 c4 10             	add    $0x10,%esp
    d5e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    d5e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d5e9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d5ec:	74 14                	je     d602 <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    d5ee:	8b 45 10             	mov    0x10(%ebp),%eax
    d5f1:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    d5f8:	00 00 00 
    d5fb:	b8 39 00 00 00       	mov    $0x39,%eax
    d600:	eb 09                	jmp    d60b <lodepng_inspect+0x302>
    }
  }

  return state->error;
    d602:	8b 45 10             	mov    0x10(%ebp),%eax
    d605:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    d60b:	c9                   	leave  
    d60c:	c3                   	ret    

0000d60d <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    d60d:	55                   	push   %ebp
    d60e:	89 e5                	mov    %esp,%ebp
    d610:	56                   	push   %esi
    d611:	53                   	push   %ebx
    d612:	83 ec 44             	sub    $0x44,%esp
    d615:	8b 45 18             	mov    0x18(%ebp),%eax
    d618:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    d61b:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    d61f:	83 f8 04             	cmp    $0x4,%eax
    d622:	0f 87 81 07 00 00    	ja     dda9 <unfilterScanline+0x79c>
    d628:	8b 04 85 74 a0 01 00 	mov    0x1a074(,%eax,4),%eax
    d62f:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d631:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d638:	eb 19                	jmp    d653 <unfilterScanline+0x46>
    d63a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d63d:	8b 45 08             	mov    0x8(%ebp),%eax
    d640:	01 c2                	add    %eax,%edx
    d642:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d645:	8b 45 0c             	mov    0xc(%ebp),%eax
    d648:	01 c8                	add    %ecx,%eax
    d64a:	0f b6 00             	movzbl (%eax),%eax
    d64d:	88 02                	mov    %al,(%edx)
    d64f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d653:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d656:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d659:	75 df                	jne    d63a <unfilterScanline+0x2d>
      break;
    d65b:	e9 50 07 00 00       	jmp    ddb0 <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d660:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d667:	eb 19                	jmp    d682 <unfilterScanline+0x75>
    d669:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d66c:	8b 45 08             	mov    0x8(%ebp),%eax
    d66f:	01 c2                	add    %eax,%edx
    d671:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d674:	8b 45 0c             	mov    0xc(%ebp),%eax
    d677:	01 c8                	add    %ecx,%eax
    d679:	0f b6 00             	movzbl (%eax),%eax
    d67c:	88 02                	mov    %al,(%edx)
    d67e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d682:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d685:	3b 45 14             	cmp    0x14(%ebp),%eax
    d688:	75 df                	jne    d669 <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    d68a:	8b 45 14             	mov    0x14(%ebp),%eax
    d68d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d690:	eb 2b                	jmp    d6bd <unfilterScanline+0xb0>
    d692:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d695:	8b 45 08             	mov    0x8(%ebp),%eax
    d698:	01 c2                	add    %eax,%edx
    d69a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d69d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d6a0:	01 c8                	add    %ecx,%eax
    d6a2:	0f b6 08             	movzbl (%eax),%ecx
    d6a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6a8:	2b 45 14             	sub    0x14(%ebp),%eax
    d6ab:	89 c3                	mov    %eax,%ebx
    d6ad:	8b 45 08             	mov    0x8(%ebp),%eax
    d6b0:	01 d8                	add    %ebx,%eax
    d6b2:	0f b6 00             	movzbl (%eax),%eax
    d6b5:	01 c8                	add    %ecx,%eax
    d6b7:	88 02                	mov    %al,(%edx)
    d6b9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d6bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6c0:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d6c3:	7c cd                	jl     d692 <unfilterScanline+0x85>
      break;
    d6c5:	e9 e6 06 00 00       	jmp    ddb0 <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    d6ca:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d6ce:	74 3c                	je     d70c <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    d6d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6d7:	eb 26                	jmp    d6ff <unfilterScanline+0xf2>
    d6d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6dc:	8b 45 08             	mov    0x8(%ebp),%eax
    d6df:	01 d0                	add    %edx,%eax
    d6e1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d6e4:	8b 55 0c             	mov    0xc(%ebp),%edx
    d6e7:	01 ca                	add    %ecx,%edx
    d6e9:	0f b6 0a             	movzbl (%edx),%ecx
    d6ec:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d6ef:	8b 55 10             	mov    0x10(%ebp),%edx
    d6f2:	01 da                	add    %ebx,%edx
    d6f4:	0f b6 12             	movzbl (%edx),%edx
    d6f7:	01 ca                	add    %ecx,%edx
    d6f9:	88 10                	mov    %dl,(%eax)
    d6fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d6ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d702:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d705:	75 d2                	jne    d6d9 <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    d707:	e9 a4 06 00 00       	jmp    ddb0 <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d70c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d713:	eb 19                	jmp    d72e <unfilterScanline+0x121>
    d715:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d718:	8b 45 08             	mov    0x8(%ebp),%eax
    d71b:	01 c2                	add    %eax,%edx
    d71d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d720:	8b 45 0c             	mov    0xc(%ebp),%eax
    d723:	01 c8                	add    %ecx,%eax
    d725:	0f b6 00             	movzbl (%eax),%eax
    d728:	88 02                	mov    %al,(%edx)
    d72a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d72e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d731:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d734:	75 df                	jne    d715 <unfilterScanline+0x108>
      }
      break;
    d736:	e9 75 06 00 00       	jmp    ddb0 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    d73b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d73f:	0f 84 8e 00 00 00    	je     d7d3 <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    d745:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d74c:	eb 28                	jmp    d776 <unfilterScanline+0x169>
    d74e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d751:	8b 45 08             	mov    0x8(%ebp),%eax
    d754:	01 d0                	add    %edx,%eax
    d756:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d759:	8b 55 0c             	mov    0xc(%ebp),%edx
    d75c:	01 ca                	add    %ecx,%edx
    d75e:	0f b6 12             	movzbl (%edx),%edx
    d761:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d764:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d767:	01 d9                	add    %ebx,%ecx
    d769:	0f b6 09             	movzbl (%ecx),%ecx
    d76c:	d0 e9                	shr    %cl
    d76e:	01 ca                	add    %ecx,%edx
    d770:	88 10                	mov    %dl,(%eax)
    d772:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d776:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d779:	3b 45 14             	cmp    0x14(%ebp),%eax
    d77c:	75 d0                	jne    d74e <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    d77e:	8b 45 14             	mov    0x14(%ebp),%eax
    d781:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d784:	eb 40                	jmp    d7c6 <unfilterScanline+0x1b9>
    d786:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d789:	8b 45 08             	mov    0x8(%ebp),%eax
    d78c:	01 c2                	add    %eax,%edx
    d78e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d791:	8b 45 0c             	mov    0xc(%ebp),%eax
    d794:	01 c8                	add    %ecx,%eax
    d796:	0f b6 08             	movzbl (%eax),%ecx
    d799:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d79c:	2b 45 14             	sub    0x14(%ebp),%eax
    d79f:	89 c3                	mov    %eax,%ebx
    d7a1:	8b 45 08             	mov    0x8(%ebp),%eax
    d7a4:	01 d8                	add    %ebx,%eax
    d7a6:	0f b6 00             	movzbl (%eax),%eax
    d7a9:	0f b6 d8             	movzbl %al,%ebx
    d7ac:	8b 75 f4             	mov    -0xc(%ebp),%esi
    d7af:	8b 45 10             	mov    0x10(%ebp),%eax
    d7b2:	01 f0                	add    %esi,%eax
    d7b4:	0f b6 00             	movzbl (%eax),%eax
    d7b7:	0f b6 c0             	movzbl %al,%eax
    d7ba:	01 d8                	add    %ebx,%eax
    d7bc:	d1 f8                	sar    %eax
    d7be:	01 c8                	add    %ecx,%eax
    d7c0:	88 02                	mov    %al,(%edx)
    d7c2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7c9:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d7cc:	7c b8                	jl     d786 <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    d7ce:	e9 dd 05 00 00       	jmp    ddb0 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d7d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d7da:	eb 19                	jmp    d7f5 <unfilterScanline+0x1e8>
    d7dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7df:	8b 45 08             	mov    0x8(%ebp),%eax
    d7e2:	01 c2                	add    %eax,%edx
    d7e4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7e7:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7ea:	01 c8                	add    %ecx,%eax
    d7ec:	0f b6 00             	movzbl (%eax),%eax
    d7ef:	88 02                	mov    %al,(%edx)
    d7f1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7f8:	3b 45 14             	cmp    0x14(%ebp),%eax
    d7fb:	75 df                	jne    d7dc <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    d7fd:	8b 45 14             	mov    0x14(%ebp),%eax
    d800:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d803:	eb 2d                	jmp    d832 <unfilterScanline+0x225>
    d805:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d808:	8b 45 08             	mov    0x8(%ebp),%eax
    d80b:	01 c2                	add    %eax,%edx
    d80d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d810:	8b 45 0c             	mov    0xc(%ebp),%eax
    d813:	01 c8                	add    %ecx,%eax
    d815:	0f b6 08             	movzbl (%eax),%ecx
    d818:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d81b:	2b 45 14             	sub    0x14(%ebp),%eax
    d81e:	89 c3                	mov    %eax,%ebx
    d820:	8b 45 08             	mov    0x8(%ebp),%eax
    d823:	01 d8                	add    %ebx,%eax
    d825:	0f b6 00             	movzbl (%eax),%eax
    d828:	d0 e8                	shr    %al
    d82a:	01 c8                	add    %ecx,%eax
    d82c:	88 02                	mov    %al,(%edx)
    d82e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d832:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d835:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d838:	7c cb                	jl     d805 <unfilterScanline+0x1f8>
      }
      break;
    d83a:	e9 71 05 00 00       	jmp    ddb0 <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    d83f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d843:	0f 84 f9 04 00 00    	je     dd42 <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    d849:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d850:	eb 26                	jmp    d878 <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    d852:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d855:	8b 45 08             	mov    0x8(%ebp),%eax
    d858:	01 d0                	add    %edx,%eax
    d85a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d85d:	8b 55 0c             	mov    0xc(%ebp),%edx
    d860:	01 ca                	add    %ecx,%edx
    d862:	0f b6 0a             	movzbl (%edx),%ecx
    d865:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d868:	8b 55 10             	mov    0x10(%ebp),%edx
    d86b:	01 da                	add    %ebx,%edx
    d86d:	0f b6 12             	movzbl (%edx),%edx
    d870:	01 ca                	add    %ecx,%edx
    d872:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    d874:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d878:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d87b:	3b 45 14             	cmp    0x14(%ebp),%eax
    d87e:	75 d2                	jne    d852 <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    d880:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    d884:	0f 8e db 01 00 00    	jle    da65 <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    d88a:	e9 c2 01 00 00       	jmp    da51 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    d88f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d892:	2b 45 14             	sub    0x14(%ebp),%eax
    d895:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    d898:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d89b:	8b 45 0c             	mov    0xc(%ebp),%eax
    d89e:	01 d0                	add    %edx,%eax
    d8a0:	0f b6 00             	movzbl (%eax),%eax
    d8a3:	88 45 ef             	mov    %al,-0x11(%ebp)
    d8a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8a9:	8d 50 01             	lea    0x1(%eax),%edx
    d8ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8af:	01 d0                	add    %edx,%eax
    d8b1:	0f b6 00             	movzbl (%eax),%eax
    d8b4:	88 45 ee             	mov    %al,-0x12(%ebp)
    d8b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8ba:	8d 50 02             	lea    0x2(%eax),%edx
    d8bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8c0:	01 d0                	add    %edx,%eax
    d8c2:	0f b6 00             	movzbl (%eax),%eax
    d8c5:	88 45 ed             	mov    %al,-0x13(%ebp)
    d8c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8cb:	8d 50 03             	lea    0x3(%eax),%edx
    d8ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8d1:	01 d0                	add    %edx,%eax
    d8d3:	0f b6 00             	movzbl (%eax),%eax
    d8d6:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    d8d9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d8dc:	8b 45 08             	mov    0x8(%ebp),%eax
    d8df:	01 d0                	add    %edx,%eax
    d8e1:	0f b6 00             	movzbl (%eax),%eax
    d8e4:	88 45 eb             	mov    %al,-0x15(%ebp)
    d8e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d8ea:	8d 50 01             	lea    0x1(%eax),%edx
    d8ed:	8b 45 08             	mov    0x8(%ebp),%eax
    d8f0:	01 d0                	add    %edx,%eax
    d8f2:	0f b6 00             	movzbl (%eax),%eax
    d8f5:	88 45 ea             	mov    %al,-0x16(%ebp)
    d8f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d8fb:	8d 50 02             	lea    0x2(%eax),%edx
    d8fe:	8b 45 08             	mov    0x8(%ebp),%eax
    d901:	01 d0                	add    %edx,%eax
    d903:	0f b6 00             	movzbl (%eax),%eax
    d906:	88 45 e9             	mov    %al,-0x17(%ebp)
    d909:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d90c:	8d 50 03             	lea    0x3(%eax),%edx
    d90f:	8b 45 08             	mov    0x8(%ebp),%eax
    d912:	01 d0                	add    %edx,%eax
    d914:	0f b6 00             	movzbl (%eax),%eax
    d917:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    d91a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d91d:	8b 45 10             	mov    0x10(%ebp),%eax
    d920:	01 d0                	add    %edx,%eax
    d922:	0f b6 00             	movzbl (%eax),%eax
    d925:	88 45 e7             	mov    %al,-0x19(%ebp)
    d928:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d92b:	8d 50 01             	lea    0x1(%eax),%edx
    d92e:	8b 45 10             	mov    0x10(%ebp),%eax
    d931:	01 d0                	add    %edx,%eax
    d933:	0f b6 00             	movzbl (%eax),%eax
    d936:	88 45 e6             	mov    %al,-0x1a(%ebp)
    d939:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d93c:	8d 50 02             	lea    0x2(%eax),%edx
    d93f:	8b 45 10             	mov    0x10(%ebp),%eax
    d942:	01 d0                	add    %edx,%eax
    d944:	0f b6 00             	movzbl (%eax),%eax
    d947:	88 45 e5             	mov    %al,-0x1b(%ebp)
    d94a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d94d:	8d 50 03             	lea    0x3(%eax),%edx
    d950:	8b 45 10             	mov    0x10(%ebp),%eax
    d953:	01 d0                	add    %edx,%eax
    d955:	0f b6 00             	movzbl (%eax),%eax
    d958:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    d95b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d95e:	8b 45 10             	mov    0x10(%ebp),%eax
    d961:	01 d0                	add    %edx,%eax
    d963:	0f b6 00             	movzbl (%eax),%eax
    d966:	88 45 e3             	mov    %al,-0x1d(%ebp)
    d969:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d96c:	8d 50 01             	lea    0x1(%eax),%edx
    d96f:	8b 45 10             	mov    0x10(%ebp),%eax
    d972:	01 d0                	add    %edx,%eax
    d974:	0f b6 00             	movzbl (%eax),%eax
    d977:	88 45 e2             	mov    %al,-0x1e(%ebp)
    d97a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d97d:	8d 50 02             	lea    0x2(%eax),%edx
    d980:	8b 45 10             	mov    0x10(%ebp),%eax
    d983:	01 d0                	add    %edx,%eax
    d985:	0f b6 00             	movzbl (%eax),%eax
    d988:	88 45 e1             	mov    %al,-0x1f(%ebp)
    d98b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d98e:	8d 50 03             	lea    0x3(%eax),%edx
    d991:	8b 45 10             	mov    0x10(%ebp),%eax
    d994:	01 d0                	add    %edx,%eax
    d996:	0f b6 00             	movzbl (%eax),%eax
    d999:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    d99c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d99f:	8b 45 08             	mov    0x8(%ebp),%eax
    d9a2:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d9a5:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    d9a9:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    d9ad:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    d9b1:	51                   	push   %ecx
    d9b2:	52                   	push   %edx
    d9b3:	50                   	push   %eax
    d9b4:	e8 3f f6 ff ff       	call   cff8 <paethPredictor>
    d9b9:	83 c4 0c             	add    $0xc,%esp
    d9bc:	89 c2                	mov    %eax,%edx
    d9be:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    d9c2:	01 d0                	add    %edx,%eax
    d9c4:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    d9c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9c9:	8d 50 01             	lea    0x1(%eax),%edx
    d9cc:	8b 45 08             	mov    0x8(%ebp),%eax
    d9cf:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d9d2:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    d9d6:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    d9da:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    d9de:	51                   	push   %ecx
    d9df:	52                   	push   %edx
    d9e0:	50                   	push   %eax
    d9e1:	e8 12 f6 ff ff       	call   cff8 <paethPredictor>
    d9e6:	83 c4 0c             	add    $0xc,%esp
    d9e9:	89 c2                	mov    %eax,%edx
    d9eb:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    d9ef:	01 d0                	add    %edx,%eax
    d9f1:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    d9f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9f6:	8d 50 02             	lea    0x2(%eax),%edx
    d9f9:	8b 45 08             	mov    0x8(%ebp),%eax
    d9fc:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d9ff:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    da03:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    da07:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    da0b:	51                   	push   %ecx
    da0c:	52                   	push   %edx
    da0d:	50                   	push   %eax
    da0e:	e8 e5 f5 ff ff       	call   cff8 <paethPredictor>
    da13:	83 c4 0c             	add    $0xc,%esp
    da16:	89 c2                	mov    %eax,%edx
    da18:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    da1c:	01 d0                	add    %edx,%eax
    da1e:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    da20:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da23:	8d 50 03             	lea    0x3(%eax),%edx
    da26:	8b 45 08             	mov    0x8(%ebp),%eax
    da29:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    da2c:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    da30:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    da34:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    da38:	51                   	push   %ecx
    da39:	52                   	push   %edx
    da3a:	50                   	push   %eax
    da3b:	e8 b8 f5 ff ff       	call   cff8 <paethPredictor>
    da40:	83 c4 0c             	add    $0xc,%esp
    da43:	89 c2                	mov    %eax,%edx
    da45:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    da49:	01 d0                	add    %edx,%eax
    da4b:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    da4d:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    da51:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da54:	83 c0 03             	add    $0x3,%eax
    da57:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    da5a:	0f 8c 2f fe ff ff    	jl     d88f <unfilterScanline+0x282>
    da60:	e9 d3 02 00 00       	jmp    dd38 <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    da65:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    da69:	0f 8e 6a 01 00 00    	jle    dbd9 <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    da6f:	e9 51 01 00 00       	jmp    dbc5 <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    da74:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da77:	2b 45 14             	sub    0x14(%ebp),%eax
    da7a:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    da7d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da80:	8b 45 0c             	mov    0xc(%ebp),%eax
    da83:	01 d0                	add    %edx,%eax
    da85:	0f b6 00             	movzbl (%eax),%eax
    da88:	88 45 db             	mov    %al,-0x25(%ebp)
    da8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da8e:	8d 50 01             	lea    0x1(%eax),%edx
    da91:	8b 45 0c             	mov    0xc(%ebp),%eax
    da94:	01 d0                	add    %edx,%eax
    da96:	0f b6 00             	movzbl (%eax),%eax
    da99:	88 45 da             	mov    %al,-0x26(%ebp)
    da9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da9f:	8d 50 02             	lea    0x2(%eax),%edx
    daa2:	8b 45 0c             	mov    0xc(%ebp),%eax
    daa5:	01 d0                	add    %edx,%eax
    daa7:	0f b6 00             	movzbl (%eax),%eax
    daaa:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    daad:	8b 55 dc             	mov    -0x24(%ebp),%edx
    dab0:	8b 45 08             	mov    0x8(%ebp),%eax
    dab3:	01 d0                	add    %edx,%eax
    dab5:	0f b6 00             	movzbl (%eax),%eax
    dab8:	88 45 d8             	mov    %al,-0x28(%ebp)
    dabb:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dabe:	8d 50 01             	lea    0x1(%eax),%edx
    dac1:	8b 45 08             	mov    0x8(%ebp),%eax
    dac4:	01 d0                	add    %edx,%eax
    dac6:	0f b6 00             	movzbl (%eax),%eax
    dac9:	88 45 d7             	mov    %al,-0x29(%ebp)
    dacc:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dacf:	8d 50 02             	lea    0x2(%eax),%edx
    dad2:	8b 45 08             	mov    0x8(%ebp),%eax
    dad5:	01 d0                	add    %edx,%eax
    dad7:	0f b6 00             	movzbl (%eax),%eax
    dada:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    dadd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dae0:	8b 45 10             	mov    0x10(%ebp),%eax
    dae3:	01 d0                	add    %edx,%eax
    dae5:	0f b6 00             	movzbl (%eax),%eax
    dae8:	88 45 d5             	mov    %al,-0x2b(%ebp)
    daeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    daee:	8d 50 01             	lea    0x1(%eax),%edx
    daf1:	8b 45 10             	mov    0x10(%ebp),%eax
    daf4:	01 d0                	add    %edx,%eax
    daf6:	0f b6 00             	movzbl (%eax),%eax
    daf9:	88 45 d4             	mov    %al,-0x2c(%ebp)
    dafc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    daff:	8d 50 02             	lea    0x2(%eax),%edx
    db02:	8b 45 10             	mov    0x10(%ebp),%eax
    db05:	01 d0                	add    %edx,%eax
    db07:	0f b6 00             	movzbl (%eax),%eax
    db0a:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    db0d:	8b 55 dc             	mov    -0x24(%ebp),%edx
    db10:	8b 45 10             	mov    0x10(%ebp),%eax
    db13:	01 d0                	add    %edx,%eax
    db15:	0f b6 00             	movzbl (%eax),%eax
    db18:	88 45 d2             	mov    %al,-0x2e(%ebp)
    db1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db1e:	8d 50 01             	lea    0x1(%eax),%edx
    db21:	8b 45 10             	mov    0x10(%ebp),%eax
    db24:	01 d0                	add    %edx,%eax
    db26:	0f b6 00             	movzbl (%eax),%eax
    db29:	88 45 d1             	mov    %al,-0x2f(%ebp)
    db2c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db2f:	8d 50 02             	lea    0x2(%eax),%edx
    db32:	8b 45 10             	mov    0x10(%ebp),%eax
    db35:	01 d0                	add    %edx,%eax
    db37:	0f b6 00             	movzbl (%eax),%eax
    db3a:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    db3d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db40:	8b 45 08             	mov    0x8(%ebp),%eax
    db43:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db46:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    db4a:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    db4e:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    db52:	51                   	push   %ecx
    db53:	52                   	push   %edx
    db54:	50                   	push   %eax
    db55:	e8 9e f4 ff ff       	call   cff8 <paethPredictor>
    db5a:	83 c4 0c             	add    $0xc,%esp
    db5d:	89 c2                	mov    %eax,%edx
    db5f:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    db63:	01 d0                	add    %edx,%eax
    db65:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    db67:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db6a:	8d 50 01             	lea    0x1(%eax),%edx
    db6d:	8b 45 08             	mov    0x8(%ebp),%eax
    db70:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db73:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    db77:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    db7b:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    db7f:	51                   	push   %ecx
    db80:	52                   	push   %edx
    db81:	50                   	push   %eax
    db82:	e8 71 f4 ff ff       	call   cff8 <paethPredictor>
    db87:	83 c4 0c             	add    $0xc,%esp
    db8a:	89 c2                	mov    %eax,%edx
    db8c:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    db90:	01 d0                	add    %edx,%eax
    db92:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    db94:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db97:	8d 50 02             	lea    0x2(%eax),%edx
    db9a:	8b 45 08             	mov    0x8(%ebp),%eax
    db9d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dba0:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    dba4:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    dba8:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    dbac:	51                   	push   %ecx
    dbad:	52                   	push   %edx
    dbae:	50                   	push   %eax
    dbaf:	e8 44 f4 ff ff       	call   cff8 <paethPredictor>
    dbb4:	83 c4 0c             	add    $0xc,%esp
    dbb7:	89 c2                	mov    %eax,%edx
    dbb9:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    dbbd:	01 d0                	add    %edx,%eax
    dbbf:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    dbc1:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    dbc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbc8:	83 c0 02             	add    $0x2,%eax
    dbcb:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dbce:	0f 8c a0 fe ff ff    	jl     da74 <unfilterScanline+0x467>
    dbd4:	e9 5f 01 00 00       	jmp    dd38 <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    dbd9:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    dbdd:	0f 8e 55 01 00 00    	jle    dd38 <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    dbe3:	e9 e0 00 00 00       	jmp    dcc8 <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    dbe8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbeb:	2b 45 14             	sub    0x14(%ebp),%eax
    dbee:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    dbf1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dbf4:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbf7:	01 d0                	add    %edx,%eax
    dbf9:	0f b6 00             	movzbl (%eax),%eax
    dbfc:	88 45 cb             	mov    %al,-0x35(%ebp)
    dbff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc02:	8d 50 01             	lea    0x1(%eax),%edx
    dc05:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc08:	01 d0                	add    %edx,%eax
    dc0a:	0f b6 00             	movzbl (%eax),%eax
    dc0d:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    dc10:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dc13:	8b 45 08             	mov    0x8(%ebp),%eax
    dc16:	01 d0                	add    %edx,%eax
    dc18:	0f b6 00             	movzbl (%eax),%eax
    dc1b:	88 45 c9             	mov    %al,-0x37(%ebp)
    dc1e:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dc21:	8d 50 01             	lea    0x1(%eax),%edx
    dc24:	8b 45 08             	mov    0x8(%ebp),%eax
    dc27:	01 d0                	add    %edx,%eax
    dc29:	0f b6 00             	movzbl (%eax),%eax
    dc2c:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    dc2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc32:	8b 45 10             	mov    0x10(%ebp),%eax
    dc35:	01 d0                	add    %edx,%eax
    dc37:	0f b6 00             	movzbl (%eax),%eax
    dc3a:	88 45 c7             	mov    %al,-0x39(%ebp)
    dc3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc40:	8d 50 01             	lea    0x1(%eax),%edx
    dc43:	8b 45 10             	mov    0x10(%ebp),%eax
    dc46:	01 d0                	add    %edx,%eax
    dc48:	0f b6 00             	movzbl (%eax),%eax
    dc4b:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    dc4e:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dc51:	8b 45 10             	mov    0x10(%ebp),%eax
    dc54:	01 d0                	add    %edx,%eax
    dc56:	0f b6 00             	movzbl (%eax),%eax
    dc59:	88 45 c5             	mov    %al,-0x3b(%ebp)
    dc5c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dc5f:	8d 50 01             	lea    0x1(%eax),%edx
    dc62:	8b 45 10             	mov    0x10(%ebp),%eax
    dc65:	01 d0                	add    %edx,%eax
    dc67:	0f b6 00             	movzbl (%eax),%eax
    dc6a:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dc6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc70:	8b 45 08             	mov    0x8(%ebp),%eax
    dc73:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc76:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    dc7a:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    dc7e:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    dc82:	51                   	push   %ecx
    dc83:	52                   	push   %edx
    dc84:	50                   	push   %eax
    dc85:	e8 6e f3 ff ff       	call   cff8 <paethPredictor>
    dc8a:	83 c4 0c             	add    $0xc,%esp
    dc8d:	89 c2                	mov    %eax,%edx
    dc8f:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    dc93:	01 d0                	add    %edx,%eax
    dc95:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dc97:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc9a:	8d 50 01             	lea    0x1(%eax),%edx
    dc9d:	8b 45 08             	mov    0x8(%ebp),%eax
    dca0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dca3:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    dca7:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    dcab:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    dcaf:	51                   	push   %ecx
    dcb0:	52                   	push   %edx
    dcb1:	50                   	push   %eax
    dcb2:	e8 41 f3 ff ff       	call   cff8 <paethPredictor>
    dcb7:	83 c4 0c             	add    $0xc,%esp
    dcba:	89 c2                	mov    %eax,%edx
    dcbc:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    dcc0:	01 d0                	add    %edx,%eax
    dcc2:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    dcc4:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    dcc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dccb:	83 c0 01             	add    $0x1,%eax
    dcce:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dcd1:	0f 8c 11 ff ff ff    	jl     dbe8 <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dcd7:	eb 5f                	jmp    dd38 <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    dcd9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcdc:	8b 45 08             	mov    0x8(%ebp),%eax
    dcdf:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dce2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dce5:	8b 45 0c             	mov    0xc(%ebp),%eax
    dce8:	01 d0                	add    %edx,%eax
    dcea:	0f b6 00             	movzbl (%eax),%eax
    dced:	88 45 b7             	mov    %al,-0x49(%ebp)
    dcf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcf3:	2b 45 14             	sub    0x14(%ebp),%eax
    dcf6:	89 c2                	mov    %eax,%edx
    dcf8:	8b 45 10             	mov    0x10(%ebp),%eax
    dcfb:	01 d0                	add    %edx,%eax
    dcfd:	0f b6 00             	movzbl (%eax),%eax
    dd00:	0f b6 c8             	movzbl %al,%ecx
    dd03:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd06:	8b 45 10             	mov    0x10(%ebp),%eax
    dd09:	01 d0                	add    %edx,%eax
    dd0b:	0f b6 00             	movzbl (%eax),%eax
    dd0e:	0f b6 d0             	movzbl %al,%edx
    dd11:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd14:	2b 45 14             	sub    0x14(%ebp),%eax
    dd17:	89 c6                	mov    %eax,%esi
    dd19:	8b 45 08             	mov    0x8(%ebp),%eax
    dd1c:	01 f0                	add    %esi,%eax
    dd1e:	0f b6 00             	movzbl (%eax),%eax
    dd21:	0f b6 c0             	movzbl %al,%eax
    dd24:	51                   	push   %ecx
    dd25:	52                   	push   %edx
    dd26:	50                   	push   %eax
    dd27:	e8 cc f2 ff ff       	call   cff8 <paethPredictor>
    dd2c:	83 c4 0c             	add    $0xc,%esp
    dd2f:	02 45 b7             	add    -0x49(%ebp),%al
    dd32:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dd34:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd38:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd3b:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd3e:	75 99                	jne    dcd9 <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    dd40:	eb 6e                	jmp    ddb0 <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    dd42:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dd49:	eb 19                	jmp    dd64 <unfilterScanline+0x757>
          recon[i] = scanline[i];
    dd4b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd4e:	8b 45 08             	mov    0x8(%ebp),%eax
    dd51:	01 c2                	add    %eax,%edx
    dd53:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd56:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd59:	01 c8                	add    %ecx,%eax
    dd5b:	0f b6 00             	movzbl (%eax),%eax
    dd5e:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    dd60:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd64:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd67:	3b 45 14             	cmp    0x14(%ebp),%eax
    dd6a:	75 df                	jne    dd4b <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    dd6c:	8b 45 14             	mov    0x14(%ebp),%eax
    dd6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    dd72:	eb 2b                	jmp    dd9f <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    dd74:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd77:	8b 45 08             	mov    0x8(%ebp),%eax
    dd7a:	01 c2                	add    %eax,%edx
    dd7c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd7f:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd82:	01 c8                	add    %ecx,%eax
    dd84:	0f b6 08             	movzbl (%eax),%ecx
    dd87:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd8a:	2b 45 14             	sub    0x14(%ebp),%eax
    dd8d:	89 c3                	mov    %eax,%ebx
    dd8f:	8b 45 08             	mov    0x8(%ebp),%eax
    dd92:	01 d8                	add    %ebx,%eax
    dd94:	0f b6 00             	movzbl (%eax),%eax
    dd97:	01 c8                	add    %ecx,%eax
    dd99:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    dd9b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dda2:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dda5:	7c cd                	jl     dd74 <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    dda7:	eb 07                	jmp    ddb0 <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    dda9:	b8 24 00 00 00       	mov    $0x24,%eax
    ddae:	eb 05                	jmp    ddb5 <unfilterScanline+0x7a8>
  }
  return 0;
    ddb0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ddb5:	8d 65 f8             	lea    -0x8(%ebp),%esp
    ddb8:	5b                   	pop    %ebx
    ddb9:	5e                   	pop    %esi
    ddba:	5d                   	pop    %ebp
    ddbb:	c3                   	ret    

0000ddbc <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    ddbc:	55                   	push   %ebp
    ddbd:	89 e5                	mov    %esp,%ebp
    ddbf:	53                   	push   %ebx
    ddc0:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    ddc3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    ddca:	8b 45 18             	mov    0x18(%ebp),%eax
    ddcd:	83 c0 07             	add    $0x7,%eax
    ddd0:	c1 e8 03             	shr    $0x3,%eax
    ddd3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    ddd6:	ff 75 18             	pushl  0x18(%ebp)
    ddd9:	6a 01                	push   $0x1
    dddb:	ff 75 10             	pushl  0x10(%ebp)
    ddde:	e8 d9 b1 ff ff       	call   8fbc <lodepng_get_raw_size_idat>
    dde3:	83 c4 0c             	add    $0xc,%esp
    dde6:	83 e8 01             	sub    $0x1,%eax
    dde9:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    ddec:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ddf3:	eb 6d                	jmp    de62 <unfilter+0xa6>
    size_t outindex = linebytes * y;
    ddf5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ddf8:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    ddfc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    ddff:	8b 45 ec             	mov    -0x14(%ebp),%eax
    de02:	83 c0 01             	add    $0x1,%eax
    de05:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    de09:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    de0c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    de0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    de12:	01 d0                	add    %edx,%eax
    de14:	0f b6 00             	movzbl (%eax),%eax
    de17:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    de1a:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    de1e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    de21:	8d 4a 01             	lea    0x1(%edx),%ecx
    de24:	8b 55 0c             	mov    0xc(%ebp),%edx
    de27:	01 d1                	add    %edx,%ecx
    de29:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    de2c:	8b 55 08             	mov    0x8(%ebp),%edx
    de2f:	01 da                	add    %ebx,%edx
    de31:	ff 75 ec             	pushl  -0x14(%ebp)
    de34:	50                   	push   %eax
    de35:	ff 75 f0             	pushl  -0x10(%ebp)
    de38:	ff 75 f4             	pushl  -0xc(%ebp)
    de3b:	51                   	push   %ecx
    de3c:	52                   	push   %edx
    de3d:	e8 cb f7 ff ff       	call   d60d <unfilterScanline>
    de42:	83 c4 18             	add    $0x18,%esp
    de45:	89 45 dc             	mov    %eax,-0x24(%ebp)
    de48:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    de4c:	74 05                	je     de53 <unfilter+0x97>
    de4e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    de51:	eb 1c                	jmp    de6f <unfilter+0xb3>

    prevline = &out[outindex];
    de53:	8b 55 e8             	mov    -0x18(%ebp),%edx
    de56:	8b 45 08             	mov    0x8(%ebp),%eax
    de59:	01 d0                	add    %edx,%eax
    de5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    de5e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    de62:	8b 45 f8             	mov    -0x8(%ebp),%eax
    de65:	3b 45 14             	cmp    0x14(%ebp),%eax
    de68:	72 8b                	jb     ddf5 <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    de6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    de6f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    de72:	c9                   	leave  
    de73:	c3                   	ret    

0000de74 <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    de74:	55                   	push   %ebp
    de75:	89 e5                	mov    %esp,%ebp
    de77:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    de7d:	ff 75 18             	pushl  0x18(%ebp)
    de80:	ff 75 14             	pushl  0x14(%ebp)
    de83:	ff 75 10             	pushl  0x10(%ebp)
    de86:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    de8c:	50                   	push   %eax
    de8d:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    de93:	50                   	push   %eax
    de94:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    de9a:	50                   	push   %eax
    de9b:	8d 45 94             	lea    -0x6c(%ebp),%eax
    de9e:	50                   	push   %eax
    de9f:	8d 45 b0             	lea    -0x50(%ebp),%eax
    dea2:	50                   	push   %eax
    dea3:	e8 e6 f1 ff ff       	call   d08e <Adam7_getpassvalues>
    dea8:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    deab:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    deaf:	0f 86 0a 01 00 00    	jbe    dfbf <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    deb5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    debc:	e9 ef 00 00 00       	jmp    dfb0 <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    dec1:	8b 45 18             	mov    0x18(%ebp),%eax
    dec4:	c1 e8 03             	shr    $0x3,%eax
    dec7:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    deca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ded1:	e9 c6 00 00 00       	jmp    df9c <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    ded6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    dedd:	e9 a6 00 00 00       	jmp    df88 <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    dee2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dee5:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    deec:	89 c1                	mov    %eax,%ecx
    deee:	8b 45 fc             	mov    -0x4(%ebp),%eax
    def1:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    def5:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    def9:	89 c2                	mov    %eax,%edx
    defb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    defe:	01 c2                	add    %eax,%edx
    df00:	8b 45 e0             	mov    -0x20(%ebp),%eax
    df03:	0f af c2             	imul   %edx,%eax
    df06:	01 c8                	add    %ecx,%eax
    df08:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    df0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df0e:	8b 14 85 18 a0 01 00 	mov    0x1a018(,%eax,4),%edx
    df15:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df18:	8b 04 85 50 a0 01 00 	mov    0x1a050(,%eax,4),%eax
    df1f:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    df23:	01 d0                	add    %edx,%eax
    df25:	0f af 45 10          	imul   0x10(%ebp),%eax
    df29:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    df2b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df2e:	8b 04 85 34 a0 01 00 	mov    0x1a034(,%eax,4),%eax
    df35:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    df39:	01 c2                	add    %eax,%edx
    df3b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df3e:	8b 04 85 fc 9f 01 00 	mov    0x19ffc(,%eax,4),%eax
    df45:	01 c2                	add    %eax,%edx
    df47:	8b 45 e0             	mov    -0x20(%ebp),%eax
    df4a:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    df4d:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    df50:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    df57:	eb 23                	jmp    df7c <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    df59:	8b 55 d8             	mov    -0x28(%ebp),%edx
    df5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    df5f:	01 c2                	add    %eax,%edx
    df61:	8b 45 08             	mov    0x8(%ebp),%eax
    df64:	01 c2                	add    %eax,%edx
    df66:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    df69:	8b 45 f0             	mov    -0x10(%ebp),%eax
    df6c:	01 c1                	add    %eax,%ecx
    df6e:	8b 45 0c             	mov    0xc(%ebp),%eax
    df71:	01 c8                	add    %ecx,%eax
    df73:	0f b6 00             	movzbl (%eax),%eax
    df76:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    df78:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    df7c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    df7f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    df82:	72 d5                	jb     df59 <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    df84:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    df88:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df8b:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    df8f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    df92:	0f 87 4a ff ff ff    	ja     dee2 <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    df98:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    df9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df9f:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    dfa3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    dfa6:	0f 87 2a ff ff ff    	ja     ded6 <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    dfac:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    dfb0:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    dfb4:	0f 85 07 ff ff ff    	jne    dec1 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    dfba:	e9 22 01 00 00       	jmp    e0e1 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    dfbf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    dfc6:	e9 0c 01 00 00       	jmp    e0d7 <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    dfcb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfce:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    dfd2:	0f af 45 18          	imul   0x18(%ebp),%eax
    dfd6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    dfd9:	8b 45 18             	mov    0x18(%ebp),%eax
    dfdc:	0f af 45 10          	imul   0x10(%ebp),%eax
    dfe0:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    dfe3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    dfea:	e9 d4 00 00 00       	jmp    e0c3 <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    dfef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    dff6:	e9 b4 00 00 00       	jmp    e0af <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    dffb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dffe:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e005:	c1 e0 03             	shl    $0x3,%eax
    e008:	89 c1                	mov    %eax,%ecx
    e00a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e00d:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    e011:	89 c2                	mov    %eax,%edx
    e013:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e016:	0f af 45 18          	imul   0x18(%ebp),%eax
    e01a:	01 d0                	add    %edx,%eax
    e01c:	01 c8                	add    %ecx,%eax
    e01e:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    e024:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e027:	8b 14 85 18 a0 01 00 	mov    0x1a018(,%eax,4),%edx
    e02e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e031:	8b 04 85 50 a0 01 00 	mov    0x1a050(,%eax,4),%eax
    e038:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    e03c:	01 d0                	add    %edx,%eax
    e03e:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    e042:	89 c2                	mov    %eax,%edx
    e044:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e047:	8b 0c 85 fc 9f 01 00 	mov    0x19ffc(,%eax,4),%ecx
    e04e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e051:	8b 04 85 34 a0 01 00 	mov    0x1a034(,%eax,4),%eax
    e058:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e05c:	01 c8                	add    %ecx,%eax
    e05e:	0f af 45 18          	imul   0x18(%ebp),%eax
    e062:	01 d0                	add    %edx,%eax
    e064:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e06a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e071:	eb 30                	jmp    e0a3 <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e073:	ff 75 0c             	pushl  0xc(%ebp)
    e076:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e07c:	50                   	push   %eax
    e07d:	e8 1e a1 ff ff       	call   81a0 <readBitFromReversedStream>
    e082:	83 c4 08             	add    $0x8,%esp
    e085:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e088:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e08c:	50                   	push   %eax
    e08d:	ff 75 08             	pushl  0x8(%ebp)
    e090:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e096:	50                   	push   %eax
    e097:	e8 86 a1 ff ff       	call   8222 <setBitOfReversedStream>
    e09c:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e09f:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e0a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e0a6:	3b 45 18             	cmp    0x18(%ebp),%eax
    e0a9:	72 c8                	jb     e073 <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e0ab:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e0af:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0b2:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e0b6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e0b9:	0f 87 3c ff ff ff    	ja     dffb <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e0bf:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e0c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0c6:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e0ca:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e0cd:	0f 87 1c ff ff ff    	ja     dfef <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e0d3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e0d7:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e0db:	0f 85 ea fe ff ff    	jne    dfcb <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e0e1:	90                   	nop
    e0e2:	c9                   	leave  
    e0e3:	c3                   	ret    

0000e0e4 <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e0e4:	55                   	push   %ebp
    e0e5:	89 e5                	mov    %esp,%ebp
    e0e7:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e0ea:	8b 45 14             	mov    0x14(%ebp),%eax
    e0ed:	2b 45 10             	sub    0x10(%ebp),%eax
    e0f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e0f3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e0fa:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e101:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e108:	eb 4a                	jmp    e154 <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e10a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e111:	eb 2a                	jmp    e13d <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e113:	ff 75 0c             	pushl  0xc(%ebp)
    e116:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e119:	50                   	push   %eax
    e11a:	e8 81 a0 ff ff       	call   81a0 <readBitFromReversedStream>
    e11f:	83 c4 08             	add    $0x8,%esp
    e122:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e125:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e129:	50                   	push   %eax
    e12a:	ff 75 08             	pushl  0x8(%ebp)
    e12d:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e130:	50                   	push   %eax
    e131:	e8 ec a0 ff ff       	call   8222 <setBitOfReversedStream>
    e136:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e139:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e13d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e140:	3b 45 10             	cmp    0x10(%ebp),%eax
    e143:	7c ce                	jl     e113 <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e145:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e148:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e14b:	01 d0                	add    %edx,%eax
    e14d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e150:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e154:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e157:	3b 45 18             	cmp    0x18(%ebp),%eax
    e15a:	72 ae                	jb     e10a <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e15c:	90                   	nop
    e15d:	c9                   	leave  
    e15e:	c3                   	ret    

0000e15f <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e15f:	55                   	push   %ebp
    e160:	89 e5                	mov    %esp,%ebp
    e162:	57                   	push   %edi
    e163:	56                   	push   %esi
    e164:	53                   	push   %ebx
    e165:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e16b:	8b 45 18             	mov    0x18(%ebp),%eax
    e16e:	83 c0 0c             	add    $0xc,%eax
    e171:	50                   	push   %eax
    e172:	e8 e6 ac ff ff       	call   8e5d <lodepng_get_bpp>
    e177:	83 c4 04             	add    $0x4,%esp
    e17a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e17d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e181:	75 0a                	jne    e18d <postProcessScanlines+0x2e>
    e183:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e188:	e9 c3 01 00 00       	jmp    e350 <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e18d:	8b 45 18             	mov    0x18(%ebp),%eax
    e190:	8b 40 08             	mov    0x8(%eax),%eax
    e193:	85 c0                	test   %eax,%eax
    e195:	0f 85 a8 00 00 00    	jne    e243 <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e19b:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e19f:	77 76                	ja     e217 <postProcessScanlines+0xb8>
    e1a1:	8b 45 10             	mov    0x10(%ebp),%eax
    e1a4:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e1a8:	89 c2                	mov    %eax,%edx
    e1aa:	8b 45 10             	mov    0x10(%ebp),%eax
    e1ad:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e1b1:	83 c0 07             	add    $0x7,%eax
    e1b4:	c1 e8 03             	shr    $0x3,%eax
    e1b7:	c1 e0 03             	shl    $0x3,%eax
    e1ba:	39 c2                	cmp    %eax,%edx
    e1bc:	74 59                	je     e217 <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e1be:	ff 75 ec             	pushl  -0x14(%ebp)
    e1c1:	ff 75 14             	pushl  0x14(%ebp)
    e1c4:	ff 75 10             	pushl  0x10(%ebp)
    e1c7:	ff 75 0c             	pushl  0xc(%ebp)
    e1ca:	ff 75 0c             	pushl  0xc(%ebp)
    e1cd:	e8 ea fb ff ff       	call   ddbc <unfilter>
    e1d2:	83 c4 14             	add    $0x14,%esp
    e1d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e1d8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e1dc:	74 08                	je     e1e6 <postProcessScanlines+0x87>
    e1de:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e1e1:	e9 6a 01 00 00       	jmp    e350 <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e1e6:	8b 45 10             	mov    0x10(%ebp),%eax
    e1e9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e1ed:	83 c0 07             	add    $0x7,%eax
    e1f0:	c1 e8 03             	shr    $0x3,%eax
    e1f3:	c1 e0 03             	shl    $0x3,%eax
    e1f6:	89 c2                	mov    %eax,%edx
    e1f8:	8b 45 10             	mov    0x10(%ebp),%eax
    e1fb:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e1ff:	ff 75 14             	pushl  0x14(%ebp)
    e202:	52                   	push   %edx
    e203:	50                   	push   %eax
    e204:	ff 75 0c             	pushl  0xc(%ebp)
    e207:	ff 75 08             	pushl  0x8(%ebp)
    e20a:	e8 d5 fe ff ff       	call   e0e4 <removePaddingBits>
    e20f:	83 c4 14             	add    $0x14,%esp
    e212:	e9 34 01 00 00       	jmp    e34b <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e217:	ff 75 ec             	pushl  -0x14(%ebp)
    e21a:	ff 75 14             	pushl  0x14(%ebp)
    e21d:	ff 75 10             	pushl  0x10(%ebp)
    e220:	ff 75 0c             	pushl  0xc(%ebp)
    e223:	ff 75 08             	pushl  0x8(%ebp)
    e226:	e8 91 fb ff ff       	call   ddbc <unfilter>
    e22b:	83 c4 14             	add    $0x14,%esp
    e22e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e231:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e235:	0f 84 10 01 00 00    	je     e34b <postProcessScanlines+0x1ec>
    e23b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e23e:	e9 0d 01 00 00       	jmp    e350 <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e243:	ff 75 ec             	pushl  -0x14(%ebp)
    e246:	ff 75 14             	pushl  0x14(%ebp)
    e249:	ff 75 10             	pushl  0x10(%ebp)
    e24c:	8d 45 88             	lea    -0x78(%ebp),%eax
    e24f:	50                   	push   %eax
    e250:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e256:	50                   	push   %eax
    e257:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e25d:	50                   	push   %eax
    e25e:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e261:	50                   	push   %eax
    e262:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e265:	50                   	push   %eax
    e266:	e8 23 ee ff ff       	call   d08e <Adam7_getpassvalues>
    e26b:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e26e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e275:	e9 b0 00 00 00       	jmp    e32a <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e27a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e27d:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e281:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e284:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e288:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e28b:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e292:	89 cb                	mov    %ecx,%ebx
    e294:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e297:	01 cb                	add    %ecx,%ebx
    e299:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e29c:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e2a3:	89 ce                	mov    %ecx,%esi
    e2a5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e2a8:	01 f1                	add    %esi,%ecx
    e2aa:	ff 75 ec             	pushl  -0x14(%ebp)
    e2ad:	52                   	push   %edx
    e2ae:	50                   	push   %eax
    e2af:	53                   	push   %ebx
    e2b0:	51                   	push   %ecx
    e2b1:	e8 06 fb ff ff       	call   ddbc <unfilter>
    e2b6:	83 c4 14             	add    $0x14,%esp
    e2b9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e2bc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e2c0:	74 08                	je     e2ca <postProcessScanlines+0x16b>
    e2c2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e2c5:	e9 86 00 00 00       	jmp    e350 <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e2ca:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e2ce:	77 56                	ja     e326 <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e2d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e2d3:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e2d7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2da:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e2de:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e2e2:	83 c2 07             	add    $0x7,%edx
    e2e5:	c1 ea 03             	shr    $0x3,%edx
    e2e8:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e2eb:	89 d6                	mov    %edx,%esi
    e2ed:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2f0:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e2f4:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e2f8:	89 d3                	mov    %edx,%ebx
    e2fa:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2fd:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    e304:	89 d1                	mov    %edx,%ecx
    e306:	8b 55 0c             	mov    0xc(%ebp),%edx
    e309:	01 d1                	add    %edx,%ecx
    e30b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e30e:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    e312:	89 d7                	mov    %edx,%edi
    e314:	8b 55 0c             	mov    0xc(%ebp),%edx
    e317:	01 fa                	add    %edi,%edx
    e319:	50                   	push   %eax
    e31a:	56                   	push   %esi
    e31b:	53                   	push   %ebx
    e31c:	51                   	push   %ecx
    e31d:	52                   	push   %edx
    e31e:	e8 c1 fd ff ff       	call   e0e4 <removePaddingBits>
    e323:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    e326:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e32a:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    e32e:	0f 85 46 ff ff ff    	jne    e27a <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    e334:	ff 75 ec             	pushl  -0x14(%ebp)
    e337:	ff 75 14             	pushl  0x14(%ebp)
    e33a:	ff 75 10             	pushl  0x10(%ebp)
    e33d:	ff 75 0c             	pushl  0xc(%ebp)
    e340:	ff 75 08             	pushl  0x8(%ebp)
    e343:	e8 2c fb ff ff       	call   de74 <Adam7_deinterlace>
    e348:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    e34b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e350:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e353:	5b                   	pop    %ebx
    e354:	5e                   	pop    %esi
    e355:	5f                   	pop    %edi
    e356:	5d                   	pop    %ebp
    e357:	c3                   	ret    

0000e358 <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e358:	55                   	push   %ebp
    e359:	89 e5                	mov    %esp,%ebp
    e35b:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    e35e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    e365:	8b 45 10             	mov    0x10(%ebp),%eax
    e368:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    e36d:	f7 e2                	mul    %edx
    e36f:	89 d0                	mov    %edx,%eax
    e371:	d1 e8                	shr    %eax
    e373:	89 c2                	mov    %eax,%edx
    e375:	8b 45 08             	mov    0x8(%ebp),%eax
    e378:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    e37b:	8b 45 08             	mov    0x8(%ebp),%eax
    e37e:	8b 40 0c             	mov    0xc(%eax),%eax
    e381:	85 c0                	test   %eax,%eax
    e383:	74 0d                	je     e392 <readChunk_PLTE+0x3a>
    e385:	8b 45 08             	mov    0x8(%ebp),%eax
    e388:	8b 40 0c             	mov    0xc(%eax),%eax
    e38b:	3d 00 01 00 00       	cmp    $0x100,%eax
    e390:	7e 0a                	jle    e39c <readChunk_PLTE+0x44>
    e392:	b8 26 00 00 00       	mov    $0x26,%eax
    e397:	e9 da 00 00 00       	jmp    e476 <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    e39c:	83 ec 0c             	sub    $0xc,%esp
    e39f:	ff 75 08             	pushl  0x8(%ebp)
    e3a2:	e8 02 a7 ff ff       	call   8aa9 <lodepng_color_mode_alloc_palette>
    e3a7:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    e3aa:	8b 45 08             	mov    0x8(%ebp),%eax
    e3ad:	8b 40 08             	mov    0x8(%eax),%eax
    e3b0:	85 c0                	test   %eax,%eax
    e3b2:	75 1e                	jne    e3d2 <readChunk_PLTE+0x7a>
    e3b4:	8b 45 08             	mov    0x8(%ebp),%eax
    e3b7:	8b 40 0c             	mov    0xc(%eax),%eax
    e3ba:	85 c0                	test   %eax,%eax
    e3bc:	74 14                	je     e3d2 <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    e3be:	8b 45 08             	mov    0x8(%ebp),%eax
    e3c1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    e3c8:	b8 53 00 00 00       	mov    $0x53,%eax
    e3cd:	e9 a4 00 00 00       	jmp    e476 <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    e3d2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e3d9:	e9 84 00 00 00       	jmp    e462 <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    e3de:	8b 45 08             	mov    0x8(%ebp),%eax
    e3e1:	8b 40 08             	mov    0x8(%eax),%eax
    e3e4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e3e7:	c1 e2 02             	shl    $0x2,%edx
    e3ea:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e3ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3f0:	8d 50 01             	lea    0x1(%eax),%edx
    e3f3:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e3f6:	8b 55 0c             	mov    0xc(%ebp),%edx
    e3f9:	01 d0                	add    %edx,%eax
    e3fb:	0f b6 00             	movzbl (%eax),%eax
    e3fe:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    e400:	8b 45 08             	mov    0x8(%ebp),%eax
    e403:	8b 40 08             	mov    0x8(%eax),%eax
    e406:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e409:	c1 e2 02             	shl    $0x2,%edx
    e40c:	83 c2 01             	add    $0x1,%edx
    e40f:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e412:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e415:	8d 50 01             	lea    0x1(%eax),%edx
    e418:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e41b:	8b 55 0c             	mov    0xc(%ebp),%edx
    e41e:	01 d0                	add    %edx,%eax
    e420:	0f b6 00             	movzbl (%eax),%eax
    e423:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    e425:	8b 45 08             	mov    0x8(%ebp),%eax
    e428:	8b 40 08             	mov    0x8(%eax),%eax
    e42b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e42e:	c1 e2 02             	shl    $0x2,%edx
    e431:	83 c2 02             	add    $0x2,%edx
    e434:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e437:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e43a:	8d 50 01             	lea    0x1(%eax),%edx
    e43d:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e440:	8b 55 0c             	mov    0xc(%ebp),%edx
    e443:	01 d0                	add    %edx,%eax
    e445:	0f b6 00             	movzbl (%eax),%eax
    e448:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    e44a:	8b 45 08             	mov    0x8(%ebp),%eax
    e44d:	8b 40 08             	mov    0x8(%eax),%eax
    e450:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e453:	c1 e2 02             	shl    $0x2,%edx
    e456:	83 c2 03             	add    $0x3,%edx
    e459:	01 d0                	add    %edx,%eax
    e45b:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    e45e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e462:	8b 45 08             	mov    0x8(%ebp),%eax
    e465:	8b 40 0c             	mov    0xc(%eax),%eax
    e468:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e46b:	0f 85 6d ff ff ff    	jne    e3de <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    e471:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e476:	c9                   	leave  
    e477:	c3                   	ret    

0000e478 <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e478:	55                   	push   %ebp
    e479:	89 e5                	mov    %esp,%ebp
    e47b:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    e47e:	8b 45 08             	mov    0x8(%ebp),%eax
    e481:	8b 00                	mov    (%eax),%eax
    e483:	83 f8 03             	cmp    $0x3,%eax
    e486:	75 4d                	jne    e4d5 <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    e488:	8b 45 08             	mov    0x8(%ebp),%eax
    e48b:	8b 40 0c             	mov    0xc(%eax),%eax
    e48e:	3b 45 10             	cmp    0x10(%ebp),%eax
    e491:	7d 0a                	jge    e49d <readChunk_tRNS+0x25>
    e493:	b8 27 00 00 00       	mov    $0x27,%eax
    e498:	e9 3c 01 00 00       	jmp    e5d9 <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    e49d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e4a4:	eb 22                	jmp    e4c8 <readChunk_tRNS+0x50>
    e4a6:	8b 45 08             	mov    0x8(%ebp),%eax
    e4a9:	8b 40 08             	mov    0x8(%eax),%eax
    e4ac:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e4af:	c1 e2 02             	shl    $0x2,%edx
    e4b2:	83 c2 03             	add    $0x3,%edx
    e4b5:	01 c2                	add    %eax,%edx
    e4b7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e4ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e4bd:	01 c8                	add    %ecx,%eax
    e4bf:	0f b6 00             	movzbl (%eax),%eax
    e4c2:	88 02                	mov    %al,(%edx)
    e4c4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e4c8:	8b 45 10             	mov    0x10(%ebp),%eax
    e4cb:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    e4ce:	75 d6                	jne    e4a6 <readChunk_tRNS+0x2e>
    e4d0:	e9 ff 00 00 00       	jmp    e5d4 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    e4d5:	8b 45 08             	mov    0x8(%ebp),%eax
    e4d8:	8b 00                	mov    (%eax),%eax
    e4da:	85 c0                	test   %eax,%eax
    e4dc:	75 59                	jne    e537 <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    e4de:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e4e2:	74 0a                	je     e4ee <readChunk_tRNS+0x76>
    e4e4:	b8 1e 00 00 00       	mov    $0x1e,%eax
    e4e9:	e9 eb 00 00 00       	jmp    e5d9 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e4ee:	8b 45 08             	mov    0x8(%ebp),%eax
    e4f1:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    e4f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    e4fb:	0f b6 00             	movzbl (%eax),%eax
    e4fe:	0f b6 c0             	movzbl %al,%eax
    e501:	c1 e0 08             	shl    $0x8,%eax
    e504:	89 c2                	mov    %eax,%edx
    e506:	8b 45 0c             	mov    0xc(%ebp),%eax
    e509:	83 c0 01             	add    $0x1,%eax
    e50c:	0f b6 00             	movzbl (%eax),%eax
    e50f:	0f b6 c0             	movzbl %al,%eax
    e512:	01 c2                	add    %eax,%edx
    e514:	8b 45 08             	mov    0x8(%ebp),%eax
    e517:	89 50 1c             	mov    %edx,0x1c(%eax)
    e51a:	8b 45 08             	mov    0x8(%ebp),%eax
    e51d:	8b 50 1c             	mov    0x1c(%eax),%edx
    e520:	8b 45 08             	mov    0x8(%ebp),%eax
    e523:	89 50 18             	mov    %edx,0x18(%eax)
    e526:	8b 45 08             	mov    0x8(%ebp),%eax
    e529:	8b 50 18             	mov    0x18(%eax),%edx
    e52c:	8b 45 08             	mov    0x8(%ebp),%eax
    e52f:	89 50 14             	mov    %edx,0x14(%eax)
    e532:	e9 9d 00 00 00       	jmp    e5d4 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    e537:	8b 45 08             	mov    0x8(%ebp),%eax
    e53a:	8b 00                	mov    (%eax),%eax
    e53c:	83 f8 02             	cmp    $0x2,%eax
    e53f:	0f 85 88 00 00 00    	jne    e5cd <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    e545:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e549:	74 0a                	je     e555 <readChunk_tRNS+0xdd>
    e54b:	b8 29 00 00 00       	mov    $0x29,%eax
    e550:	e9 84 00 00 00       	jmp    e5d9 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e555:	8b 45 08             	mov    0x8(%ebp),%eax
    e558:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    e55f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e562:	0f b6 00             	movzbl (%eax),%eax
    e565:	0f b6 c0             	movzbl %al,%eax
    e568:	c1 e0 08             	shl    $0x8,%eax
    e56b:	89 c2                	mov    %eax,%edx
    e56d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e570:	83 c0 01             	add    $0x1,%eax
    e573:	0f b6 00             	movzbl (%eax),%eax
    e576:	0f b6 c0             	movzbl %al,%eax
    e579:	01 c2                	add    %eax,%edx
    e57b:	8b 45 08             	mov    0x8(%ebp),%eax
    e57e:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    e581:	8b 45 0c             	mov    0xc(%ebp),%eax
    e584:	83 c0 02             	add    $0x2,%eax
    e587:	0f b6 00             	movzbl (%eax),%eax
    e58a:	0f b6 c0             	movzbl %al,%eax
    e58d:	c1 e0 08             	shl    $0x8,%eax
    e590:	89 c2                	mov    %eax,%edx
    e592:	8b 45 0c             	mov    0xc(%ebp),%eax
    e595:	83 c0 03             	add    $0x3,%eax
    e598:	0f b6 00             	movzbl (%eax),%eax
    e59b:	0f b6 c0             	movzbl %al,%eax
    e59e:	01 c2                	add    %eax,%edx
    e5a0:	8b 45 08             	mov    0x8(%ebp),%eax
    e5a3:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    e5a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5a9:	83 c0 04             	add    $0x4,%eax
    e5ac:	0f b6 00             	movzbl (%eax),%eax
    e5af:	0f b6 c0             	movzbl %al,%eax
    e5b2:	c1 e0 08             	shl    $0x8,%eax
    e5b5:	89 c2                	mov    %eax,%edx
    e5b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5ba:	83 c0 05             	add    $0x5,%eax
    e5bd:	0f b6 00             	movzbl (%eax),%eax
    e5c0:	0f b6 c0             	movzbl %al,%eax
    e5c3:	01 c2                	add    %eax,%edx
    e5c5:	8b 45 08             	mov    0x8(%ebp),%eax
    e5c8:	89 50 1c             	mov    %edx,0x1c(%eax)
    e5cb:	eb 07                	jmp    e5d4 <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    e5cd:	b8 2a 00 00 00       	mov    $0x2a,%eax
    e5d2:	eb 05                	jmp    e5d9 <readChunk_tRNS+0x161>

  return 0; /* OK */
    e5d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e5d9:	c9                   	leave  
    e5da:	c3                   	ret    

0000e5db <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e5db:	55                   	push   %ebp
    e5dc:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    e5de:	8b 45 08             	mov    0x8(%ebp),%eax
    e5e1:	8b 40 0c             	mov    0xc(%eax),%eax
    e5e4:	83 f8 03             	cmp    $0x3,%eax
    e5e7:	75 63                	jne    e64c <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    e5e9:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    e5ed:	74 0a                	je     e5f9 <readChunk_bKGD+0x1e>
    e5ef:	b8 2b 00 00 00       	mov    $0x2b,%eax
    e5f4:	e9 63 01 00 00       	jmp    e75c <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    e5f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5fc:	0f b6 00             	movzbl (%eax),%eax
    e5ff:	0f b6 d0             	movzbl %al,%edx
    e602:	8b 45 08             	mov    0x8(%ebp),%eax
    e605:	8b 40 18             	mov    0x18(%eax),%eax
    e608:	39 c2                	cmp    %eax,%edx
    e60a:	7c 0a                	jl     e616 <readChunk_bKGD+0x3b>
    e60c:	b8 67 00 00 00       	mov    $0x67,%eax
    e611:	e9 46 01 00 00       	jmp    e75c <readChunk_bKGD+0x181>

    info->background_defined = 1;
    e616:	8b 45 08             	mov    0x8(%ebp),%eax
    e619:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    e620:	8b 45 0c             	mov    0xc(%ebp),%eax
    e623:	0f b6 00             	movzbl (%eax),%eax
    e626:	0f b6 d0             	movzbl %al,%edx
    e629:	8b 45 08             	mov    0x8(%ebp),%eax
    e62c:	89 50 38             	mov    %edx,0x38(%eax)
    e62f:	8b 45 08             	mov    0x8(%ebp),%eax
    e632:	8b 50 38             	mov    0x38(%eax),%edx
    e635:	8b 45 08             	mov    0x8(%ebp),%eax
    e638:	89 50 34             	mov    %edx,0x34(%eax)
    e63b:	8b 45 08             	mov    0x8(%ebp),%eax
    e63e:	8b 50 34             	mov    0x34(%eax),%edx
    e641:	8b 45 08             	mov    0x8(%ebp),%eax
    e644:	89 50 30             	mov    %edx,0x30(%eax)
    e647:	e9 0b 01 00 00       	jmp    e757 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    e64c:	8b 45 08             	mov    0x8(%ebp),%eax
    e64f:	8b 40 0c             	mov    0xc(%eax),%eax
    e652:	85 c0                	test   %eax,%eax
    e654:	74 0b                	je     e661 <readChunk_bKGD+0x86>
    e656:	8b 45 08             	mov    0x8(%ebp),%eax
    e659:	8b 40 0c             	mov    0xc(%eax),%eax
    e65c:	83 f8 04             	cmp    $0x4,%eax
    e65f:	75 59                	jne    e6ba <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    e661:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e665:	74 0a                	je     e671 <readChunk_bKGD+0x96>
    e667:	b8 2c 00 00 00       	mov    $0x2c,%eax
    e66c:	e9 eb 00 00 00       	jmp    e75c <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e671:	8b 45 08             	mov    0x8(%ebp),%eax
    e674:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    e67b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e67e:	0f b6 00             	movzbl (%eax),%eax
    e681:	0f b6 c0             	movzbl %al,%eax
    e684:	c1 e0 08             	shl    $0x8,%eax
    e687:	89 c2                	mov    %eax,%edx
    e689:	8b 45 0c             	mov    0xc(%ebp),%eax
    e68c:	83 c0 01             	add    $0x1,%eax
    e68f:	0f b6 00             	movzbl (%eax),%eax
    e692:	0f b6 c0             	movzbl %al,%eax
    e695:	01 c2                	add    %eax,%edx
    e697:	8b 45 08             	mov    0x8(%ebp),%eax
    e69a:	89 50 38             	mov    %edx,0x38(%eax)
    e69d:	8b 45 08             	mov    0x8(%ebp),%eax
    e6a0:	8b 50 38             	mov    0x38(%eax),%edx
    e6a3:	8b 45 08             	mov    0x8(%ebp),%eax
    e6a6:	89 50 34             	mov    %edx,0x34(%eax)
    e6a9:	8b 45 08             	mov    0x8(%ebp),%eax
    e6ac:	8b 50 34             	mov    0x34(%eax),%edx
    e6af:	8b 45 08             	mov    0x8(%ebp),%eax
    e6b2:	89 50 30             	mov    %edx,0x30(%eax)
    e6b5:	e9 9d 00 00 00       	jmp    e757 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    e6ba:	8b 45 08             	mov    0x8(%ebp),%eax
    e6bd:	8b 40 0c             	mov    0xc(%eax),%eax
    e6c0:	83 f8 02             	cmp    $0x2,%eax
    e6c3:	74 0f                	je     e6d4 <readChunk_bKGD+0xf9>
    e6c5:	8b 45 08             	mov    0x8(%ebp),%eax
    e6c8:	8b 40 0c             	mov    0xc(%eax),%eax
    e6cb:	83 f8 06             	cmp    $0x6,%eax
    e6ce:	0f 85 83 00 00 00    	jne    e757 <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    e6d4:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e6d8:	74 07                	je     e6e1 <readChunk_bKGD+0x106>
    e6da:	b8 2d 00 00 00       	mov    $0x2d,%eax
    e6df:	eb 7b                	jmp    e75c <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e6e1:	8b 45 08             	mov    0x8(%ebp),%eax
    e6e4:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    e6eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6ee:	0f b6 00             	movzbl (%eax),%eax
    e6f1:	0f b6 c0             	movzbl %al,%eax
    e6f4:	c1 e0 08             	shl    $0x8,%eax
    e6f7:	89 c2                	mov    %eax,%edx
    e6f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6fc:	83 c0 01             	add    $0x1,%eax
    e6ff:	0f b6 00             	movzbl (%eax),%eax
    e702:	0f b6 c0             	movzbl %al,%eax
    e705:	01 c2                	add    %eax,%edx
    e707:	8b 45 08             	mov    0x8(%ebp),%eax
    e70a:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    e70d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e710:	83 c0 02             	add    $0x2,%eax
    e713:	0f b6 00             	movzbl (%eax),%eax
    e716:	0f b6 c0             	movzbl %al,%eax
    e719:	c1 e0 08             	shl    $0x8,%eax
    e71c:	89 c2                	mov    %eax,%edx
    e71e:	8b 45 0c             	mov    0xc(%ebp),%eax
    e721:	83 c0 03             	add    $0x3,%eax
    e724:	0f b6 00             	movzbl (%eax),%eax
    e727:	0f b6 c0             	movzbl %al,%eax
    e72a:	01 c2                	add    %eax,%edx
    e72c:	8b 45 08             	mov    0x8(%ebp),%eax
    e72f:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    e732:	8b 45 0c             	mov    0xc(%ebp),%eax
    e735:	83 c0 04             	add    $0x4,%eax
    e738:	0f b6 00             	movzbl (%eax),%eax
    e73b:	0f b6 c0             	movzbl %al,%eax
    e73e:	c1 e0 08             	shl    $0x8,%eax
    e741:	89 c2                	mov    %eax,%edx
    e743:	8b 45 0c             	mov    0xc(%ebp),%eax
    e746:	83 c0 05             	add    $0x5,%eax
    e749:	0f b6 00             	movzbl (%eax),%eax
    e74c:	0f b6 c0             	movzbl %al,%eax
    e74f:	01 c2                	add    %eax,%edx
    e751:	8b 45 08             	mov    0x8(%ebp),%eax
    e754:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    e757:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e75c:	5d                   	pop    %ebp
    e75d:	c3                   	ret    

0000e75e <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e75e:	55                   	push   %ebp
    e75f:	89 e5                	mov    %esp,%ebp
    e761:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    e764:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    e76b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e772:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e779:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e77d:	0f 85 06 01 00 00    	jne    e889 <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    e783:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    e78a:	eb 04                	jmp    e790 <readChunk_tEXt+0x32>
    e78c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e790:	8b 45 10             	mov    0x10(%ebp),%eax
    e793:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e796:	73 0f                	jae    e7a7 <readChunk_tEXt+0x49>
    e798:	8b 55 0c             	mov    0xc(%ebp),%edx
    e79b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e79e:	01 d0                	add    %edx,%eax
    e7a0:	0f b6 00             	movzbl (%eax),%eax
    e7a3:	84 c0                	test   %al,%al
    e7a5:	75 e5                	jne    e78c <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e7a7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e7ab:	74 06                	je     e7b3 <readChunk_tEXt+0x55>
    e7ad:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    e7b1:	76 0c                	jbe    e7bf <readChunk_tEXt+0x61>
    e7b3:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e7ba:	e9 ca 00 00 00       	jmp    e889 <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    e7bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7c2:	83 c0 01             	add    $0x1,%eax
    e7c5:	83 ec 0c             	sub    $0xc,%esp
    e7c8:	50                   	push   %eax
    e7c9:	e8 73 4b ff ff       	call   3341 <lodepng_malloc>
    e7ce:	83 c4 10             	add    $0x10,%esp
    e7d1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e7d4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e7d8:	75 0c                	jne    e7e6 <readChunk_tEXt+0x88>
    e7da:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e7e1:	e9 a3 00 00 00       	jmp    e889 <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    e7e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7e9:	83 ec 04             	sub    $0x4,%esp
    e7ec:	50                   	push   %eax
    e7ed:	ff 75 0c             	pushl  0xc(%ebp)
    e7f0:	ff 75 f0             	pushl  -0x10(%ebp)
    e7f3:	e8 87 4b ff ff       	call   337f <lodepng_memcpy>
    e7f8:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e7fb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e7fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e801:	01 d0                	add    %edx,%eax
    e803:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    e806:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e809:	83 c0 01             	add    $0x1,%eax
    e80c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    e80f:	8b 45 10             	mov    0x10(%ebp),%eax
    e812:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    e815:	72 08                	jb     e81f <readChunk_tEXt+0xc1>
    e817:	8b 45 10             	mov    0x10(%ebp),%eax
    e81a:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    e81d:	eb 05                	jmp    e824 <readChunk_tEXt+0xc6>
    e81f:	b8 00 00 00 00       	mov    $0x0,%eax
    e824:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    e827:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e82a:	83 c0 01             	add    $0x1,%eax
    e82d:	83 ec 0c             	sub    $0xc,%esp
    e830:	50                   	push   %eax
    e831:	e8 0b 4b ff ff       	call   3341 <lodepng_malloc>
    e836:	83 c4 10             	add    $0x10,%esp
    e839:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    e83c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e840:	75 09                	jne    e84b <readChunk_tEXt+0xed>
    e842:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e849:	eb 3e                	jmp    e889 <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    e84b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e84e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e851:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e854:	01 ca                	add    %ecx,%edx
    e856:	83 ec 04             	sub    $0x4,%esp
    e859:	50                   	push   %eax
    e85a:	52                   	push   %edx
    e85b:	ff 75 ec             	pushl  -0x14(%ebp)
    e85e:	e8 1c 4b ff ff       	call   337f <lodepng_memcpy>
    e863:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    e866:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e869:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e86c:	01 d0                	add    %edx,%eax
    e86e:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    e871:	83 ec 04             	sub    $0x4,%esp
    e874:	ff 75 ec             	pushl  -0x14(%ebp)
    e877:	ff 75 f0             	pushl  -0x10(%ebp)
    e87a:	ff 75 08             	pushl  0x8(%ebp)
    e87d:	e8 3f ac ff ff       	call   94c1 <lodepng_add_text>
    e882:	83 c4 10             	add    $0x10,%esp
    e885:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    e888:	90                   	nop
  }

  lodepng_free(key);
    e889:	83 ec 0c             	sub    $0xc,%esp
    e88c:	ff 75 f0             	pushl  -0x10(%ebp)
    e88f:	e8 ce 4a ff ff       	call   3362 <lodepng_free>
    e894:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    e897:	83 ec 0c             	sub    $0xc,%esp
    e89a:	ff 75 ec             	pushl  -0x14(%ebp)
    e89d:	e8 c0 4a ff ff       	call   3362 <lodepng_free>
    e8a2:	83 c4 10             	add    $0x10,%esp

  return error;
    e8a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e8a8:	c9                   	leave  
    e8a9:	c3                   	ret    

0000e8aa <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    e8aa:	55                   	push   %ebp
    e8ab:	89 e5                	mov    %esp,%ebp
    e8ad:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    e8b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    e8b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    e8ba:	8b 10                	mov    (%eax),%edx
    e8bc:	89 55 d0             	mov    %edx,-0x30(%ebp)
    e8bf:	8b 50 04             	mov    0x4(%eax),%edx
    e8c2:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    e8c5:	8b 50 08             	mov    0x8(%eax),%edx
    e8c8:	89 55 d8             	mov    %edx,-0x28(%ebp)
    e8cb:	8b 50 0c             	mov    0xc(%eax),%edx
    e8ce:	89 55 dc             	mov    %edx,-0x24(%ebp)
    e8d1:	8b 50 10             	mov    0x10(%eax),%edx
    e8d4:	89 55 e0             	mov    %edx,-0x20(%ebp)
    e8d7:	8b 40 14             	mov    0x14(%eax),%eax
    e8da:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    e8dd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    e8e4:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    e8eb:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e8f2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e8f6:	0f 85 48 01 00 00    	jne    ea44 <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    e8fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e903:	eb 04                	jmp    e909 <readChunk_zTXt+0x5f>
    e905:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e909:	8b 45 14             	mov    0x14(%ebp),%eax
    e90c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e90f:	73 0f                	jae    e920 <readChunk_zTXt+0x76>
    e911:	8b 55 10             	mov    0x10(%ebp),%edx
    e914:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e917:	01 d0                	add    %edx,%eax
    e919:	0f b6 00             	movzbl (%eax),%eax
    e91c:	84 c0                	test   %al,%al
    e91e:	75 e5                	jne    e905 <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    e920:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e923:	8d 50 02             	lea    0x2(%eax),%edx
    e926:	8b 45 14             	mov    0x14(%ebp),%eax
    e929:	39 c2                	cmp    %eax,%edx
    e92b:	72 0c                	jb     e939 <readChunk_zTXt+0x8f>
    e92d:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    e934:	e9 0b 01 00 00       	jmp    ea44 <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e939:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e93d:	74 06                	je     e945 <readChunk_zTXt+0x9b>
    e93f:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    e943:	76 0c                	jbe    e951 <readChunk_zTXt+0xa7>
    e945:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e94c:	e9 f3 00 00 00       	jmp    ea44 <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    e951:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e954:	83 c0 01             	add    $0x1,%eax
    e957:	83 ec 0c             	sub    $0xc,%esp
    e95a:	50                   	push   %eax
    e95b:	e8 e1 49 ff ff       	call   3341 <lodepng_malloc>
    e960:	83 c4 10             	add    $0x10,%esp
    e963:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e966:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e96a:	75 0c                	jne    e978 <readChunk_zTXt+0xce>
    e96c:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e973:	e9 cc 00 00 00       	jmp    ea44 <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    e978:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e97b:	83 ec 04             	sub    $0x4,%esp
    e97e:	50                   	push   %eax
    e97f:	ff 75 10             	pushl  0x10(%ebp)
    e982:	ff 75 ec             	pushl  -0x14(%ebp)
    e985:	e8 f5 49 ff ff       	call   337f <lodepng_memcpy>
    e98a:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e98d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e990:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e993:	01 d0                	add    %edx,%eax
    e995:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    e998:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e99b:	8d 50 01             	lea    0x1(%eax),%edx
    e99e:	8b 45 10             	mov    0x10(%ebp),%eax
    e9a1:	01 d0                	add    %edx,%eax
    e9a3:	0f b6 00             	movzbl (%eax),%eax
    e9a6:	84 c0                	test   %al,%al
    e9a8:	74 0c                	je     e9b6 <readChunk_zTXt+0x10c>
    e9aa:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    e9b1:	e9 8e 00 00 00       	jmp    ea44 <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    e9b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9b9:	83 c0 02             	add    $0x2,%eax
    e9bc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    e9bf:	8b 45 14             	mov    0x14(%ebp),%eax
    e9c2:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e9c5:	76 09                	jbe    e9d0 <readChunk_zTXt+0x126>
    e9c7:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    e9ce:	eb 74                	jmp    ea44 <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    e9d0:	8b 45 14             	mov    0x14(%ebp),%eax
    e9d3:	2b 45 e8             	sub    -0x18(%ebp),%eax
    e9d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    e9d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9dc:	8b 40 30             	mov    0x30(%eax),%eax
    e9df:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    e9e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9e5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    e9e8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e9eb:	01 d1                	add    %edx,%ecx
    e9ed:	83 ec 08             	sub    $0x8,%esp
    e9f0:	8d 55 d0             	lea    -0x30(%ebp),%edx
    e9f3:	52                   	push   %edx
    e9f4:	50                   	push   %eax
    e9f5:	51                   	push   %ecx
    e9f6:	6a 00                	push   $0x0
    e9f8:	8d 45 c8             	lea    -0x38(%ebp),%eax
    e9fb:	50                   	push   %eax
    e9fc:	8d 45 cc             	lea    -0x34(%ebp),%eax
    e9ff:	50                   	push   %eax
    ea00:	e8 f7 93 ff ff       	call   7dfc <zlib_decompress>
    ea05:	83 c4 20             	add    $0x20,%esp
    ea08:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    ea0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea0f:	74 11                	je     ea22 <readChunk_zTXt+0x178>
    ea11:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ea14:	8b 45 c8             	mov    -0x38(%ebp),%eax
    ea17:	39 c2                	cmp    %eax,%edx
    ea19:	7d 07                	jge    ea22 <readChunk_zTXt+0x178>
    ea1b:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    ea22:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea26:	75 1b                	jne    ea43 <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    ea28:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ea2b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ea2e:	52                   	push   %edx
    ea2f:	50                   	push   %eax
    ea30:	ff 75 ec             	pushl  -0x14(%ebp)
    ea33:	ff 75 08             	pushl  0x8(%ebp)
    ea36:	e8 60 a9 ff ff       	call   939b <lodepng_add_text_sized>
    ea3b:	83 c4 10             	add    $0x10,%esp
    ea3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    ea41:	eb 01                	jmp    ea44 <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    ea43:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    ea44:	83 ec 0c             	sub    $0xc,%esp
    ea47:	ff 75 ec             	pushl  -0x14(%ebp)
    ea4a:	e8 13 49 ff ff       	call   3362 <lodepng_free>
    ea4f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    ea52:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ea55:	83 ec 0c             	sub    $0xc,%esp
    ea58:	50                   	push   %eax
    ea59:	e8 04 49 ff ff       	call   3362 <lodepng_free>
    ea5e:	83 c4 10             	add    $0x10,%esp

  return error;
    ea61:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ea64:	c9                   	leave  
    ea65:	c3                   	ret    

0000ea66 <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    ea66:	55                   	push   %ebp
    ea67:	89 e5                	mov    %esp,%ebp
    ea69:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    ea6c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    ea73:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea76:	8b 10                	mov    (%eax),%edx
    ea78:	89 55 c0             	mov    %edx,-0x40(%ebp)
    ea7b:	8b 50 04             	mov    0x4(%eax),%edx
    ea7e:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    ea81:	8b 50 08             	mov    0x8(%eax),%edx
    ea84:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ea87:	8b 50 0c             	mov    0xc(%eax),%edx
    ea8a:	89 55 cc             	mov    %edx,-0x34(%ebp)
    ea8d:	8b 50 10             	mov    0x10(%eax),%edx
    ea90:	89 55 d0             	mov    %edx,-0x30(%ebp)
    ea93:	8b 40 14             	mov    0x14(%eax),%eax
    ea96:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    ea99:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    eaa0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    eaa7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    eaae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eab2:	0f 85 d5 02 00 00    	jne    ed8d <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    eab8:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    eabc:	7f 0c                	jg     eaca <readChunk_iTXt+0x64>
    eabe:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    eac5:	e9 c3 02 00 00       	jmp    ed8d <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    eaca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    ead1:	eb 04                	jmp    ead7 <readChunk_iTXt+0x71>
    ead3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ead7:	8b 45 14             	mov    0x14(%ebp),%eax
    eada:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    eadd:	73 0f                	jae    eaee <readChunk_iTXt+0x88>
    eadf:	8b 55 10             	mov    0x10(%ebp),%edx
    eae2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eae5:	01 d0                	add    %edx,%eax
    eae7:	0f b6 00             	movzbl (%eax),%eax
    eaea:	84 c0                	test   %al,%al
    eaec:	75 e5                	jne    ead3 <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    eaee:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eaf1:	8d 50 03             	lea    0x3(%eax),%edx
    eaf4:	8b 45 14             	mov    0x14(%ebp),%eax
    eaf7:	39 c2                	cmp    %eax,%edx
    eaf9:	72 0c                	jb     eb07 <readChunk_iTXt+0xa1>
    eafb:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    eb02:	e9 86 02 00 00       	jmp    ed8d <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    eb07:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    eb0b:	74 06                	je     eb13 <readChunk_iTXt+0xad>
    eb0d:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    eb11:	76 0c                	jbe    eb1f <readChunk_iTXt+0xb9>
    eb13:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    eb1a:	e9 6e 02 00 00       	jmp    ed8d <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    eb1f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb22:	83 c0 01             	add    $0x1,%eax
    eb25:	83 ec 0c             	sub    $0xc,%esp
    eb28:	50                   	push   %eax
    eb29:	e8 13 48 ff ff       	call   3341 <lodepng_malloc>
    eb2e:	83 c4 10             	add    $0x10,%esp
    eb31:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    eb34:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    eb38:	75 0c                	jne    eb46 <readChunk_iTXt+0xe0>
    eb3a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eb41:	e9 47 02 00 00       	jmp    ed8d <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    eb46:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb49:	83 ec 04             	sub    $0x4,%esp
    eb4c:	50                   	push   %eax
    eb4d:	ff 75 10             	pushl  0x10(%ebp)
    eb50:	ff 75 e8             	pushl  -0x18(%ebp)
    eb53:	e8 27 48 ff ff       	call   337f <lodepng_memcpy>
    eb58:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    eb5b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    eb5e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb61:	01 d0                	add    %edx,%eax
    eb63:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    eb66:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb69:	8d 50 01             	lea    0x1(%eax),%edx
    eb6c:	8b 45 10             	mov    0x10(%ebp),%eax
    eb6f:	01 d0                	add    %edx,%eax
    eb71:	0f b6 00             	movzbl (%eax),%eax
    eb74:	0f b6 c0             	movzbl %al,%eax
    eb77:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    eb7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb7d:	8d 50 02             	lea    0x2(%eax),%edx
    eb80:	8b 45 10             	mov    0x10(%ebp),%eax
    eb83:	01 d0                	add    %edx,%eax
    eb85:	0f b6 00             	movzbl (%eax),%eax
    eb88:	84 c0                	test   %al,%al
    eb8a:	74 0c                	je     eb98 <readChunk_iTXt+0x132>
    eb8c:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    eb93:	e9 f5 01 00 00       	jmp    ed8d <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    eb98:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb9b:	83 c0 03             	add    $0x3,%eax
    eb9e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    eba1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    eba8:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ebab:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ebae:	eb 08                	jmp    ebb8 <readChunk_iTXt+0x152>
    ebb0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ebb4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ebb8:	8b 45 14             	mov    0x14(%ebp),%eax
    ebbb:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ebbe:	73 0f                	jae    ebcf <readChunk_iTXt+0x169>
    ebc0:	8b 55 10             	mov    0x10(%ebp),%edx
    ebc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ebc6:	01 d0                	add    %edx,%eax
    ebc8:	0f b6 00             	movzbl (%eax),%eax
    ebcb:	84 c0                	test   %al,%al
    ebcd:	75 e1                	jne    ebb0 <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    ebcf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebd2:	83 c0 01             	add    $0x1,%eax
    ebd5:	83 ec 0c             	sub    $0xc,%esp
    ebd8:	50                   	push   %eax
    ebd9:	e8 63 47 ff ff       	call   3341 <lodepng_malloc>
    ebde:	83 c4 10             	add    $0x10,%esp
    ebe1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    ebe4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ebe8:	75 0c                	jne    ebf6 <readChunk_iTXt+0x190>
    ebea:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ebf1:	e9 97 01 00 00       	jmp    ed8d <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    ebf6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebf9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ebfc:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ebff:	01 ca                	add    %ecx,%edx
    ec01:	83 ec 04             	sub    $0x4,%esp
    ec04:	50                   	push   %eax
    ec05:	52                   	push   %edx
    ec06:	ff 75 e4             	pushl  -0x1c(%ebp)
    ec09:	e8 71 47 ff ff       	call   337f <lodepng_memcpy>
    ec0e:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    ec11:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ec14:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec17:	01 d0                	add    %edx,%eax
    ec19:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    ec1c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec1f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec22:	01 d0                	add    %edx,%eax
    ec24:	83 c0 01             	add    $0x1,%eax
    ec27:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ec2a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ec31:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec34:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ec37:	eb 08                	jmp    ec41 <readChunk_iTXt+0x1db>
    ec39:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ec3d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ec41:	8b 45 14             	mov    0x14(%ebp),%eax
    ec44:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ec47:	73 0f                	jae    ec58 <readChunk_iTXt+0x1f2>
    ec49:	8b 55 10             	mov    0x10(%ebp),%edx
    ec4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec4f:	01 d0                	add    %edx,%eax
    ec51:	0f b6 00             	movzbl (%eax),%eax
    ec54:	84 c0                	test   %al,%al
    ec56:	75 e1                	jne    ec39 <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    ec58:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec5b:	83 c0 01             	add    $0x1,%eax
    ec5e:	83 ec 0c             	sub    $0xc,%esp
    ec61:	50                   	push   %eax
    ec62:	e8 da 46 ff ff       	call   3341 <lodepng_malloc>
    ec67:	83 c4 10             	add    $0x10,%esp
    ec6a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    ec6d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ec71:	75 0c                	jne    ec7f <readChunk_iTXt+0x219>
    ec73:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ec7a:	e9 0e 01 00 00       	jmp    ed8d <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    ec7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec82:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ec85:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ec88:	01 ca                	add    %ecx,%edx
    ec8a:	83 ec 04             	sub    $0x4,%esp
    ec8d:	50                   	push   %eax
    ec8e:	52                   	push   %edx
    ec8f:	ff 75 e0             	pushl  -0x20(%ebp)
    ec92:	e8 e8 46 ff ff       	call   337f <lodepng_memcpy>
    ec97:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    ec9a:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ec9d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eca0:	01 d0                	add    %edx,%eax
    eca2:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    eca5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    eca8:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ecab:	01 d0                	add    %edx,%eax
    ecad:	83 c0 01             	add    $0x1,%eax
    ecb0:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    ecb3:	8b 45 14             	mov    0x14(%ebp),%eax
    ecb6:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ecb9:	72 08                	jb     ecc3 <readChunk_iTXt+0x25d>
    ecbb:	8b 45 14             	mov    0x14(%ebp),%eax
    ecbe:	2b 45 d8             	sub    -0x28(%ebp),%eax
    ecc1:	eb 05                	jmp    ecc8 <readChunk_iTXt+0x262>
    ecc3:	b8 00 00 00 00       	mov    $0x0,%eax
    ecc8:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    eccb:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    eccf:	0f 84 90 00 00 00    	je     ed65 <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    ecd5:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    ecdc:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    ece3:	8b 45 0c             	mov    0xc(%ebp),%eax
    ece6:	8b 40 30             	mov    0x30(%eax),%eax
    ece9:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    ecec:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ecef:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ecf2:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ecf5:	01 d1                	add    %edx,%ecx
    ecf7:	83 ec 08             	sub    $0x8,%esp
    ecfa:	8d 55 c0             	lea    -0x40(%ebp),%edx
    ecfd:	52                   	push   %edx
    ecfe:	50                   	push   %eax
    ecff:	51                   	push   %ecx
    ed00:	6a 00                	push   $0x0
    ed02:	8d 45 b8             	lea    -0x48(%ebp),%eax
    ed05:	50                   	push   %eax
    ed06:	8d 45 bc             	lea    -0x44(%ebp),%eax
    ed09:	50                   	push   %eax
    ed0a:	e8 ed 90 ff ff       	call   7dfc <zlib_decompress>
    ed0f:	83 c4 20             	add    $0x20,%esp
    ed12:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    ed15:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ed19:	74 11                	je     ed2c <readChunk_iTXt+0x2c6>
    ed1b:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ed1e:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ed21:	39 c2                	cmp    %eax,%edx
    ed23:	7d 07                	jge    ed2c <readChunk_iTXt+0x2c6>
    ed25:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    ed2c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ed30:	75 22                	jne    ed54 <readChunk_iTXt+0x2ee>
    ed32:	8b 55 b8             	mov    -0x48(%ebp),%edx
    ed35:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ed38:	83 ec 08             	sub    $0x8,%esp
    ed3b:	52                   	push   %edx
    ed3c:	50                   	push   %eax
    ed3d:	ff 75 e0             	pushl  -0x20(%ebp)
    ed40:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed43:	ff 75 e8             	pushl  -0x18(%ebp)
    ed46:	ff 75 08             	pushl  0x8(%ebp)
    ed49:	e8 94 a9 ff ff       	call   96e2 <lodepng_add_itext_sized>
    ed4e:	83 c4 20             	add    $0x20,%esp
    ed51:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    ed54:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ed57:	83 ec 0c             	sub    $0xc,%esp
    ed5a:	50                   	push   %eax
    ed5b:	e8 02 46 ff ff       	call   3362 <lodepng_free>
    ed60:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    ed63:	eb 27                	jmp    ed8c <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    ed65:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed68:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ed6b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ed6e:	01 ca                	add    %ecx,%edx
    ed70:	83 ec 08             	sub    $0x8,%esp
    ed73:	50                   	push   %eax
    ed74:	52                   	push   %edx
    ed75:	ff 75 e0             	pushl  -0x20(%ebp)
    ed78:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed7b:	ff 75 e8             	pushl  -0x18(%ebp)
    ed7e:	ff 75 08             	pushl  0x8(%ebp)
    ed81:	e8 5c a9 ff ff       	call   96e2 <lodepng_add_itext_sized>
    ed86:	83 c4 20             	add    $0x20,%esp
    ed89:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    ed8c:	90                   	nop
  }

  lodepng_free(key);
    ed8d:	83 ec 0c             	sub    $0xc,%esp
    ed90:	ff 75 e8             	pushl  -0x18(%ebp)
    ed93:	e8 ca 45 ff ff       	call   3362 <lodepng_free>
    ed98:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    ed9b:	83 ec 0c             	sub    $0xc,%esp
    ed9e:	ff 75 e4             	pushl  -0x1c(%ebp)
    eda1:	e8 bc 45 ff ff       	call   3362 <lodepng_free>
    eda6:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    eda9:	83 ec 0c             	sub    $0xc,%esp
    edac:	ff 75 e0             	pushl  -0x20(%ebp)
    edaf:	e8 ae 45 ff ff       	call   3362 <lodepng_free>
    edb4:	83 c4 10             	add    $0x10,%esp

  return error;
    edb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    edba:	c9                   	leave  
    edbb:	c3                   	ret    

0000edbc <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    edbc:	55                   	push   %ebp
    edbd:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    edbf:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    edc3:	74 0a                	je     edcf <readChunk_tIME+0x13>
    edc5:	b8 49 00 00 00       	mov    $0x49,%eax
    edca:	e9 8b 00 00 00       	jmp    ee5a <readChunk_tIME+0x9e>

  info->time_defined = 1;
    edcf:	8b 45 08             	mov    0x8(%ebp),%eax
    edd2:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    edd9:	8b 45 0c             	mov    0xc(%ebp),%eax
    eddc:	0f b6 00             	movzbl (%eax),%eax
    eddf:	0f b6 c0             	movzbl %al,%eax
    ede2:	c1 e0 08             	shl    $0x8,%eax
    ede5:	89 c2                	mov    %eax,%edx
    ede7:	8b 45 0c             	mov    0xc(%ebp),%eax
    edea:	83 c0 01             	add    $0x1,%eax
    eded:	0f b6 00             	movzbl (%eax),%eax
    edf0:	0f b6 c0             	movzbl %al,%eax
    edf3:	01 c2                	add    %eax,%edx
    edf5:	8b 45 08             	mov    0x8(%ebp),%eax
    edf8:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    edfb:	8b 45 0c             	mov    0xc(%ebp),%eax
    edfe:	83 c0 02             	add    $0x2,%eax
    ee01:	0f b6 00             	movzbl (%eax),%eax
    ee04:	0f b6 d0             	movzbl %al,%edx
    ee07:	8b 45 08             	mov    0x8(%ebp),%eax
    ee0a:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    ee0d:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee10:	83 c0 03             	add    $0x3,%eax
    ee13:	0f b6 00             	movzbl (%eax),%eax
    ee16:	0f b6 d0             	movzbl %al,%edx
    ee19:	8b 45 08             	mov    0x8(%ebp),%eax
    ee1c:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    ee1f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee22:	83 c0 04             	add    $0x4,%eax
    ee25:	0f b6 00             	movzbl (%eax),%eax
    ee28:	0f b6 d0             	movzbl %al,%edx
    ee2b:	8b 45 08             	mov    0x8(%ebp),%eax
    ee2e:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    ee31:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee34:	83 c0 05             	add    $0x5,%eax
    ee37:	0f b6 00             	movzbl (%eax),%eax
    ee3a:	0f b6 d0             	movzbl %al,%edx
    ee3d:	8b 45 08             	mov    0x8(%ebp),%eax
    ee40:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    ee43:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee46:	83 c0 06             	add    $0x6,%eax
    ee49:	0f b6 00             	movzbl (%eax),%eax
    ee4c:	0f b6 d0             	movzbl %al,%edx
    ee4f:	8b 45 08             	mov    0x8(%ebp),%eax
    ee52:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    ee55:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ee5a:	5d                   	pop    %ebp
    ee5b:	c3                   	ret    

0000ee5c <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ee5c:	55                   	push   %ebp
    ee5d:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    ee5f:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    ee63:	74 0a                	je     ee6f <readChunk_pHYs+0x13>
    ee65:	b8 4a 00 00 00       	mov    $0x4a,%eax
    ee6a:	e9 ba 00 00 00       	jmp    ef29 <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    ee6f:	8b 45 08             	mov    0x8(%ebp),%eax
    ee72:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    ee79:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee7c:	0f b6 00             	movzbl (%eax),%eax
    ee7f:	0f b6 c0             	movzbl %al,%eax
    ee82:	c1 e0 08             	shl    $0x8,%eax
    ee85:	89 c2                	mov    %eax,%edx
    ee87:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee8a:	83 c0 01             	add    $0x1,%eax
    ee8d:	0f b6 00             	movzbl (%eax),%eax
    ee90:	0f b6 c0             	movzbl %al,%eax
    ee93:	01 d0                	add    %edx,%eax
    ee95:	c1 e0 08             	shl    $0x8,%eax
    ee98:	89 c2                	mov    %eax,%edx
    ee9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee9d:	83 c0 02             	add    $0x2,%eax
    eea0:	0f b6 00             	movzbl (%eax),%eax
    eea3:	0f b6 c0             	movzbl %al,%eax
    eea6:	01 d0                	add    %edx,%eax
    eea8:	c1 e0 08             	shl    $0x8,%eax
    eeab:	89 c2                	mov    %eax,%edx
    eead:	8b 45 0c             	mov    0xc(%ebp),%eax
    eeb0:	83 c0 03             	add    $0x3,%eax
    eeb3:	0f b6 00             	movzbl (%eax),%eax
    eeb6:	0f b6 c0             	movzbl %al,%eax
    eeb9:	01 c2                	add    %eax,%edx
    eebb:	8b 45 08             	mov    0x8(%ebp),%eax
    eebe:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    eec1:	8b 45 0c             	mov    0xc(%ebp),%eax
    eec4:	83 c0 04             	add    $0x4,%eax
    eec7:	0f b6 00             	movzbl (%eax),%eax
    eeca:	0f b6 c0             	movzbl %al,%eax
    eecd:	c1 e0 08             	shl    $0x8,%eax
    eed0:	89 c2                	mov    %eax,%edx
    eed2:	8b 45 0c             	mov    0xc(%ebp),%eax
    eed5:	83 c0 05             	add    $0x5,%eax
    eed8:	0f b6 00             	movzbl (%eax),%eax
    eedb:	0f b6 c0             	movzbl %al,%eax
    eede:	01 d0                	add    %edx,%eax
    eee0:	c1 e0 08             	shl    $0x8,%eax
    eee3:	89 c2                	mov    %eax,%edx
    eee5:	8b 45 0c             	mov    0xc(%ebp),%eax
    eee8:	83 c0 06             	add    $0x6,%eax
    eeeb:	0f b6 00             	movzbl (%eax),%eax
    eeee:	0f b6 c0             	movzbl %al,%eax
    eef1:	01 d0                	add    %edx,%eax
    eef3:	c1 e0 08             	shl    $0x8,%eax
    eef6:	89 c2                	mov    %eax,%edx
    eef8:	8b 45 0c             	mov    0xc(%ebp),%eax
    eefb:	83 c0 07             	add    $0x7,%eax
    eefe:	0f b6 00             	movzbl (%eax),%eax
    ef01:	0f b6 c0             	movzbl %al,%eax
    ef04:	01 c2                	add    %eax,%edx
    ef06:	8b 45 08             	mov    0x8(%ebp),%eax
    ef09:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    ef0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef12:	83 c0 08             	add    $0x8,%eax
    ef15:	0f b6 00             	movzbl (%eax),%eax
    ef18:	0f b6 d0             	movzbl %al,%edx
    ef1b:	8b 45 08             	mov    0x8(%ebp),%eax
    ef1e:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    ef24:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ef29:	5d                   	pop    %ebp
    ef2a:	c3                   	ret    

0000ef2b <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ef2b:	55                   	push   %ebp
    ef2c:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    ef2e:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    ef32:	74 07                	je     ef3b <readChunk_gAMA+0x10>
    ef34:	b8 60 00 00 00       	mov    $0x60,%eax
    ef39:	eb 5d                	jmp    ef98 <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    ef3b:	8b 45 08             	mov    0x8(%ebp),%eax
    ef3e:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    ef45:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    ef48:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef4b:	0f b6 00             	movzbl (%eax),%eax
    ef4e:	0f b6 c0             	movzbl %al,%eax
    ef51:	c1 e0 08             	shl    $0x8,%eax
    ef54:	89 c2                	mov    %eax,%edx
    ef56:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef59:	83 c0 01             	add    $0x1,%eax
    ef5c:	0f b6 00             	movzbl (%eax),%eax
    ef5f:	0f b6 c0             	movzbl %al,%eax
    ef62:	01 d0                	add    %edx,%eax
    ef64:	c1 e0 08             	shl    $0x8,%eax
    ef67:	89 c2                	mov    %eax,%edx
    ef69:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef6c:	83 c0 02             	add    $0x2,%eax
    ef6f:	0f b6 00             	movzbl (%eax),%eax
    ef72:	0f b6 c0             	movzbl %al,%eax
    ef75:	01 d0                	add    %edx,%eax
    ef77:	c1 e0 08             	shl    $0x8,%eax
    ef7a:	89 c2                	mov    %eax,%edx
    ef7c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef7f:	83 c0 03             	add    $0x3,%eax
    ef82:	0f b6 00             	movzbl (%eax),%eax
    ef85:	0f b6 c0             	movzbl %al,%eax
    ef88:	01 c2                	add    %eax,%edx
    ef8a:	8b 45 08             	mov    0x8(%ebp),%eax
    ef8d:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    ef93:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ef98:	5d                   	pop    %ebp
    ef99:	c3                   	ret    

0000ef9a <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ef9a:	55                   	push   %ebp
    ef9b:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    ef9d:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    efa1:	74 0a                	je     efad <readChunk_cHRM+0x13>
    efa3:	b8 61 00 00 00       	mov    $0x61,%eax
    efa8:	e9 7f 02 00 00       	jmp    f22c <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    efad:	8b 45 08             	mov    0x8(%ebp),%eax
    efb0:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    efb7:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    efba:	8b 45 0c             	mov    0xc(%ebp),%eax
    efbd:	0f b6 00             	movzbl (%eax),%eax
    efc0:	0f b6 c0             	movzbl %al,%eax
    efc3:	c1 e0 08             	shl    $0x8,%eax
    efc6:	89 c2                	mov    %eax,%edx
    efc8:	8b 45 0c             	mov    0xc(%ebp),%eax
    efcb:	83 c0 01             	add    $0x1,%eax
    efce:	0f b6 00             	movzbl (%eax),%eax
    efd1:	0f b6 c0             	movzbl %al,%eax
    efd4:	01 d0                	add    %edx,%eax
    efd6:	c1 e0 08             	shl    $0x8,%eax
    efd9:	89 c2                	mov    %eax,%edx
    efdb:	8b 45 0c             	mov    0xc(%ebp),%eax
    efde:	83 c0 02             	add    $0x2,%eax
    efe1:	0f b6 00             	movzbl (%eax),%eax
    efe4:	0f b6 c0             	movzbl %al,%eax
    efe7:	01 d0                	add    %edx,%eax
    efe9:	c1 e0 08             	shl    $0x8,%eax
    efec:	89 c2                	mov    %eax,%edx
    efee:	8b 45 0c             	mov    0xc(%ebp),%eax
    eff1:	83 c0 03             	add    $0x3,%eax
    eff4:	0f b6 00             	movzbl (%eax),%eax
    eff7:	0f b6 c0             	movzbl %al,%eax
    effa:	01 c2                	add    %eax,%edx
    effc:	8b 45 08             	mov    0x8(%ebp),%eax
    efff:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    f005:	8b 45 0c             	mov    0xc(%ebp),%eax
    f008:	83 c0 04             	add    $0x4,%eax
    f00b:	0f b6 00             	movzbl (%eax),%eax
    f00e:	0f b6 c0             	movzbl %al,%eax
    f011:	c1 e0 08             	shl    $0x8,%eax
    f014:	89 c2                	mov    %eax,%edx
    f016:	8b 45 0c             	mov    0xc(%ebp),%eax
    f019:	83 c0 05             	add    $0x5,%eax
    f01c:	0f b6 00             	movzbl (%eax),%eax
    f01f:	0f b6 c0             	movzbl %al,%eax
    f022:	01 d0                	add    %edx,%eax
    f024:	c1 e0 08             	shl    $0x8,%eax
    f027:	89 c2                	mov    %eax,%edx
    f029:	8b 45 0c             	mov    0xc(%ebp),%eax
    f02c:	83 c0 06             	add    $0x6,%eax
    f02f:	0f b6 00             	movzbl (%eax),%eax
    f032:	0f b6 c0             	movzbl %al,%eax
    f035:	01 d0                	add    %edx,%eax
    f037:	c1 e0 08             	shl    $0x8,%eax
    f03a:	89 c2                	mov    %eax,%edx
    f03c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f03f:	83 c0 07             	add    $0x7,%eax
    f042:	0f b6 00             	movzbl (%eax),%eax
    f045:	0f b6 c0             	movzbl %al,%eax
    f048:	01 c2                	add    %eax,%edx
    f04a:	8b 45 08             	mov    0x8(%ebp),%eax
    f04d:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    f053:	8b 45 0c             	mov    0xc(%ebp),%eax
    f056:	83 c0 08             	add    $0x8,%eax
    f059:	0f b6 00             	movzbl (%eax),%eax
    f05c:	0f b6 c0             	movzbl %al,%eax
    f05f:	c1 e0 08             	shl    $0x8,%eax
    f062:	89 c2                	mov    %eax,%edx
    f064:	8b 45 0c             	mov    0xc(%ebp),%eax
    f067:	83 c0 09             	add    $0x9,%eax
    f06a:	0f b6 00             	movzbl (%eax),%eax
    f06d:	0f b6 c0             	movzbl %al,%eax
    f070:	01 d0                	add    %edx,%eax
    f072:	c1 e0 08             	shl    $0x8,%eax
    f075:	89 c2                	mov    %eax,%edx
    f077:	8b 45 0c             	mov    0xc(%ebp),%eax
    f07a:	83 c0 0a             	add    $0xa,%eax
    f07d:	0f b6 00             	movzbl (%eax),%eax
    f080:	0f b6 c0             	movzbl %al,%eax
    f083:	01 d0                	add    %edx,%eax
    f085:	c1 e0 08             	shl    $0x8,%eax
    f088:	89 c2                	mov    %eax,%edx
    f08a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f08d:	83 c0 0b             	add    $0xb,%eax
    f090:	0f b6 00             	movzbl (%eax),%eax
    f093:	0f b6 c0             	movzbl %al,%eax
    f096:	01 c2                	add    %eax,%edx
    f098:	8b 45 08             	mov    0x8(%ebp),%eax
    f09b:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f0a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0a4:	83 c0 0c             	add    $0xc,%eax
    f0a7:	0f b6 00             	movzbl (%eax),%eax
    f0aa:	0f b6 c0             	movzbl %al,%eax
    f0ad:	c1 e0 08             	shl    $0x8,%eax
    f0b0:	89 c2                	mov    %eax,%edx
    f0b2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0b5:	83 c0 0d             	add    $0xd,%eax
    f0b8:	0f b6 00             	movzbl (%eax),%eax
    f0bb:	0f b6 c0             	movzbl %al,%eax
    f0be:	01 d0                	add    %edx,%eax
    f0c0:	c1 e0 08             	shl    $0x8,%eax
    f0c3:	89 c2                	mov    %eax,%edx
    f0c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0c8:	83 c0 0e             	add    $0xe,%eax
    f0cb:	0f b6 00             	movzbl (%eax),%eax
    f0ce:	0f b6 c0             	movzbl %al,%eax
    f0d1:	01 d0                	add    %edx,%eax
    f0d3:	c1 e0 08             	shl    $0x8,%eax
    f0d6:	89 c2                	mov    %eax,%edx
    f0d8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0db:	83 c0 0f             	add    $0xf,%eax
    f0de:	0f b6 00             	movzbl (%eax),%eax
    f0e1:	0f b6 c0             	movzbl %al,%eax
    f0e4:	01 c2                	add    %eax,%edx
    f0e6:	8b 45 08             	mov    0x8(%ebp),%eax
    f0e9:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f0ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0f2:	83 c0 10             	add    $0x10,%eax
    f0f5:	0f b6 00             	movzbl (%eax),%eax
    f0f8:	0f b6 c0             	movzbl %al,%eax
    f0fb:	c1 e0 08             	shl    $0x8,%eax
    f0fe:	89 c2                	mov    %eax,%edx
    f100:	8b 45 0c             	mov    0xc(%ebp),%eax
    f103:	83 c0 11             	add    $0x11,%eax
    f106:	0f b6 00             	movzbl (%eax),%eax
    f109:	0f b6 c0             	movzbl %al,%eax
    f10c:	01 d0                	add    %edx,%eax
    f10e:	c1 e0 08             	shl    $0x8,%eax
    f111:	89 c2                	mov    %eax,%edx
    f113:	8b 45 0c             	mov    0xc(%ebp),%eax
    f116:	83 c0 12             	add    $0x12,%eax
    f119:	0f b6 00             	movzbl (%eax),%eax
    f11c:	0f b6 c0             	movzbl %al,%eax
    f11f:	01 d0                	add    %edx,%eax
    f121:	c1 e0 08             	shl    $0x8,%eax
    f124:	89 c2                	mov    %eax,%edx
    f126:	8b 45 0c             	mov    0xc(%ebp),%eax
    f129:	83 c0 13             	add    $0x13,%eax
    f12c:	0f b6 00             	movzbl (%eax),%eax
    f12f:	0f b6 c0             	movzbl %al,%eax
    f132:	01 c2                	add    %eax,%edx
    f134:	8b 45 08             	mov    0x8(%ebp),%eax
    f137:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f13d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f140:	83 c0 14             	add    $0x14,%eax
    f143:	0f b6 00             	movzbl (%eax),%eax
    f146:	0f b6 c0             	movzbl %al,%eax
    f149:	c1 e0 08             	shl    $0x8,%eax
    f14c:	89 c2                	mov    %eax,%edx
    f14e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f151:	83 c0 15             	add    $0x15,%eax
    f154:	0f b6 00             	movzbl (%eax),%eax
    f157:	0f b6 c0             	movzbl %al,%eax
    f15a:	01 d0                	add    %edx,%eax
    f15c:	c1 e0 08             	shl    $0x8,%eax
    f15f:	89 c2                	mov    %eax,%edx
    f161:	8b 45 0c             	mov    0xc(%ebp),%eax
    f164:	83 c0 16             	add    $0x16,%eax
    f167:	0f b6 00             	movzbl (%eax),%eax
    f16a:	0f b6 c0             	movzbl %al,%eax
    f16d:	01 d0                	add    %edx,%eax
    f16f:	c1 e0 08             	shl    $0x8,%eax
    f172:	89 c2                	mov    %eax,%edx
    f174:	8b 45 0c             	mov    0xc(%ebp),%eax
    f177:	83 c0 17             	add    $0x17,%eax
    f17a:	0f b6 00             	movzbl (%eax),%eax
    f17d:	0f b6 c0             	movzbl %al,%eax
    f180:	01 c2                	add    %eax,%edx
    f182:	8b 45 08             	mov    0x8(%ebp),%eax
    f185:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f18b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f18e:	83 c0 18             	add    $0x18,%eax
    f191:	0f b6 00             	movzbl (%eax),%eax
    f194:	0f b6 c0             	movzbl %al,%eax
    f197:	c1 e0 08             	shl    $0x8,%eax
    f19a:	89 c2                	mov    %eax,%edx
    f19c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f19f:	83 c0 19             	add    $0x19,%eax
    f1a2:	0f b6 00             	movzbl (%eax),%eax
    f1a5:	0f b6 c0             	movzbl %al,%eax
    f1a8:	01 d0                	add    %edx,%eax
    f1aa:	c1 e0 08             	shl    $0x8,%eax
    f1ad:	89 c2                	mov    %eax,%edx
    f1af:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1b2:	83 c0 1a             	add    $0x1a,%eax
    f1b5:	0f b6 00             	movzbl (%eax),%eax
    f1b8:	0f b6 c0             	movzbl %al,%eax
    f1bb:	01 d0                	add    %edx,%eax
    f1bd:	c1 e0 08             	shl    $0x8,%eax
    f1c0:	89 c2                	mov    %eax,%edx
    f1c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1c5:	83 c0 1b             	add    $0x1b,%eax
    f1c8:	0f b6 00             	movzbl (%eax),%eax
    f1cb:	0f b6 c0             	movzbl %al,%eax
    f1ce:	01 c2                	add    %eax,%edx
    f1d0:	8b 45 08             	mov    0x8(%ebp),%eax
    f1d3:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f1d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1dc:	83 c0 1c             	add    $0x1c,%eax
    f1df:	0f b6 00             	movzbl (%eax),%eax
    f1e2:	0f b6 c0             	movzbl %al,%eax
    f1e5:	c1 e0 08             	shl    $0x8,%eax
    f1e8:	89 c2                	mov    %eax,%edx
    f1ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1ed:	83 c0 1d             	add    $0x1d,%eax
    f1f0:	0f b6 00             	movzbl (%eax),%eax
    f1f3:	0f b6 c0             	movzbl %al,%eax
    f1f6:	01 d0                	add    %edx,%eax
    f1f8:	c1 e0 08             	shl    $0x8,%eax
    f1fb:	89 c2                	mov    %eax,%edx
    f1fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    f200:	83 c0 1e             	add    $0x1e,%eax
    f203:	0f b6 00             	movzbl (%eax),%eax
    f206:	0f b6 c0             	movzbl %al,%eax
    f209:	01 d0                	add    %edx,%eax
    f20b:	c1 e0 08             	shl    $0x8,%eax
    f20e:	89 c2                	mov    %eax,%edx
    f210:	8b 45 0c             	mov    0xc(%ebp),%eax
    f213:	83 c0 1f             	add    $0x1f,%eax
    f216:	0f b6 00             	movzbl (%eax),%eax
    f219:	0f b6 c0             	movzbl %al,%eax
    f21c:	01 c2                	add    %eax,%edx
    f21e:	8b 45 08             	mov    0x8(%ebp),%eax
    f221:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f227:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f22c:	5d                   	pop    %ebp
    f22d:	c3                   	ret    

0000f22e <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f22e:	55                   	push   %ebp
    f22f:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f231:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f235:	74 07                	je     f23e <readChunk_sRGB+0x10>
    f237:	b8 62 00 00 00       	mov    $0x62,%eax
    f23c:	eb 24                	jmp    f262 <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f23e:	8b 45 08             	mov    0x8(%ebp),%eax
    f241:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f248:	00 00 00 
  info->srgb_intent = data[0];
    f24b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f24e:	0f b6 00             	movzbl (%eax),%eax
    f251:	0f b6 d0             	movzbl %al,%edx
    f254:	8b 45 08             	mov    0x8(%ebp),%eax
    f257:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f25d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f262:	5d                   	pop    %ebp
    f263:	c3                   	ret    

0000f264 <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f264:	55                   	push   %ebp
    f265:	89 e5                	mov    %esp,%ebp
    f267:	53                   	push   %ebx
    f268:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f26b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f272:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f279:	8b 45 0c             	mov    0xc(%ebp),%eax
    f27c:	8b 10                	mov    (%eax),%edx
    f27e:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f281:	8b 50 04             	mov    0x4(%eax),%edx
    f284:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f287:	8b 50 08             	mov    0x8(%eax),%edx
    f28a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f28d:	8b 50 0c             	mov    0xc(%eax),%edx
    f290:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f293:	8b 50 10             	mov    0x10(%eax),%edx
    f296:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f299:	8b 40 14             	mov    0x14(%eax),%eax
    f29c:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f29f:	8b 45 08             	mov    0x8(%ebp),%eax
    f2a2:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f2a9:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f2ac:	8b 45 08             	mov    0x8(%ebp),%eax
    f2af:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f2b5:	85 c0                	test   %eax,%eax
    f2b7:	74 0e                	je     f2c7 <readChunk_iCCP+0x63>
    f2b9:	83 ec 0c             	sub    $0xc,%esp
    f2bc:	ff 75 08             	pushl  0x8(%ebp)
    f2bf:	e8 ca a6 ff ff       	call   998e <lodepng_clear_icc>
    f2c4:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f2c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f2ce:	eb 04                	jmp    f2d4 <readChunk_iCCP+0x70>
    f2d0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f2d4:	8b 45 14             	mov    0x14(%ebp),%eax
    f2d7:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f2da:	73 0f                	jae    f2eb <readChunk_iCCP+0x87>
    f2dc:	8b 55 10             	mov    0x10(%ebp),%edx
    f2df:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2e2:	01 d0                	add    %edx,%eax
    f2e4:	0f b6 00             	movzbl (%eax),%eax
    f2e7:	84 c0                	test   %al,%al
    f2e9:	75 e5                	jne    f2d0 <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f2eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2ee:	8d 50 02             	lea    0x2(%eax),%edx
    f2f1:	8b 45 14             	mov    0x14(%ebp),%eax
    f2f4:	39 c2                	cmp    %eax,%edx
    f2f6:	72 0a                	jb     f302 <readChunk_iCCP+0x9e>
    f2f8:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f2fd:	e9 46 01 00 00       	jmp    f448 <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f302:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f306:	74 06                	je     f30e <readChunk_iCCP+0xaa>
    f308:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f30c:	76 0a                	jbe    f318 <readChunk_iCCP+0xb4>
    f30e:	b8 59 00 00 00       	mov    $0x59,%eax
    f313:	e9 30 01 00 00       	jmp    f448 <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    f318:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f31b:	83 c0 01             	add    $0x1,%eax
    f31e:	83 ec 0c             	sub    $0xc,%esp
    f321:	50                   	push   %eax
    f322:	e8 1a 40 ff ff       	call   3341 <lodepng_malloc>
    f327:	83 c4 10             	add    $0x10,%esp
    f32a:	89 c2                	mov    %eax,%edx
    f32c:	8b 45 08             	mov    0x8(%ebp),%eax
    f32f:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    f335:	8b 45 08             	mov    0x8(%ebp),%eax
    f338:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f33e:	85 c0                	test   %eax,%eax
    f340:	75 0a                	jne    f34c <readChunk_iCCP+0xe8>
    f342:	b8 53 00 00 00       	mov    $0x53,%eax
    f347:	e9 fc 00 00 00       	jmp    f448 <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    f34c:	8b 45 08             	mov    0x8(%ebp),%eax
    f34f:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f355:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f358:	01 d0                	add    %edx,%eax
    f35a:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    f35d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f364:	eb 1f                	jmp    f385 <readChunk_iCCP+0x121>
    f366:	8b 45 08             	mov    0x8(%ebp),%eax
    f369:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f36f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f372:	01 d0                	add    %edx,%eax
    f374:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f377:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f37a:	01 ca                	add    %ecx,%edx
    f37c:	0f b6 12             	movzbl (%edx),%edx
    f37f:	88 10                	mov    %dl,(%eax)
    f381:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f385:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f388:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f38b:	75 d9                	jne    f366 <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    f38d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f390:	8d 50 01             	lea    0x1(%eax),%edx
    f393:	8b 45 10             	mov    0x10(%ebp),%eax
    f396:	01 d0                	add    %edx,%eax
    f398:	0f b6 00             	movzbl (%eax),%eax
    f39b:	84 c0                	test   %al,%al
    f39d:	74 0a                	je     f3a9 <readChunk_iCCP+0x145>
    f39f:	b8 48 00 00 00       	mov    $0x48,%eax
    f3a4:	e9 9f 00 00 00       	jmp    f448 <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    f3a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f3ac:	83 c0 02             	add    $0x2,%eax
    f3af:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    f3b2:	8b 45 14             	mov    0x14(%ebp),%eax
    f3b5:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f3b8:	76 0a                	jbe    f3c4 <readChunk_iCCP+0x160>
    f3ba:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f3bf:	e9 84 00 00 00       	jmp    f448 <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    f3c4:	8b 45 14             	mov    0x14(%ebp),%eax
    f3c7:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f3ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    f3cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3d0:	8b 40 34             	mov    0x34(%eax),%eax
    f3d3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    f3d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f3d9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f3dc:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f3df:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    f3e2:	8b 55 08             	mov    0x8(%ebp),%edx
    f3e5:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    f3eb:	83 ec 08             	sub    $0x8,%esp
    f3ee:	8d 55 cc             	lea    -0x34(%ebp),%edx
    f3f1:	52                   	push   %edx
    f3f2:	50                   	push   %eax
    f3f3:	53                   	push   %ebx
    f3f4:	6a 00                	push   $0x0
    f3f6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    f3f9:	50                   	push   %eax
    f3fa:	51                   	push   %ecx
    f3fb:	e8 fc 89 ff ff       	call   7dfc <zlib_decompress>
    f400:	83 c4 20             	add    $0x20,%esp
    f403:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    f406:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f40a:	74 11                	je     f41d <readChunk_iCCP+0x1b9>
    f40c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    f40f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f412:	39 c2                	cmp    %eax,%edx
    f414:	7d 07                	jge    f41d <readChunk_iCCP+0x1b9>
    f416:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    f41d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f420:	89 c2                	mov    %eax,%edx
    f422:	8b 45 08             	mov    0x8(%ebp),%eax
    f425:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    f42b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f42f:	75 14                	jne    f445 <readChunk_iCCP+0x1e1>
    f431:	8b 45 08             	mov    0x8(%ebp),%eax
    f434:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    f43a:	85 c0                	test   %eax,%eax
    f43c:	75 07                	jne    f445 <readChunk_iCCP+0x1e1>
    f43e:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    f445:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f448:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f44b:	c9                   	leave  
    f44c:	c3                   	ret    

0000f44d <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    f44d:	55                   	push   %ebp
    f44e:	89 e5                	mov    %esp,%ebp
    f450:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    f453:	8b 55 0c             	mov    0xc(%ebp),%edx
    f456:	8b 45 10             	mov    0x10(%ebp),%eax
    f459:	01 d0                	add    %edx,%eax
    f45b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    f45e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    f465:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    f46c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f46f:	83 c0 04             	add    $0x4,%eax
    f472:	3b 45 14             	cmp    0x14(%ebp),%eax
    f475:	7e 0a                	jle    f481 <lodepng_inspect_chunk+0x34>
    f477:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f47c:	e9 43 03 00 00       	jmp    f7c4 <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    f481:	ff 75 ec             	pushl  -0x14(%ebp)
    f484:	e8 3a 8e ff ff       	call   82c3 <lodepng_chunk_length>
    f489:	83 c4 04             	add    $0x4,%esp
    f48c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    f48f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f492:	85 c0                	test   %eax,%eax
    f494:	79 0a                	jns    f4a0 <lodepng_inspect_chunk+0x53>
    f496:	b8 3f 00 00 00       	mov    $0x3f,%eax
    f49b:	e9 24 03 00 00       	jmp    f7c4 <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    f4a0:	ff 75 ec             	pushl  -0x14(%ebp)
    f4a3:	e8 53 8f ff ff       	call   83fb <lodepng_chunk_data_const>
    f4a8:	83 c4 04             	add    $0x4,%esp
    f4ab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    f4ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f4b1:	8d 50 04             	lea    0x4(%eax),%edx
    f4b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f4b7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    f4ba:	8b 55 14             	mov    0x14(%ebp),%edx
    f4bd:	8b 45 10             	mov    0x10(%ebp),%eax
    f4c0:	01 d0                	add    %edx,%eax
    f4c2:	39 c1                	cmp    %eax,%ecx
    f4c4:	76 0a                	jbe    f4d0 <lodepng_inspect_chunk+0x83>
    f4c6:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f4cb:	e9 f4 02 00 00       	jmp    f7c4 <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    f4d0:	68 88 a0 01 00       	push   $0x1a088
    f4d5:	ff 75 ec             	pushl  -0x14(%ebp)
    f4d8:	e8 33 8e ff ff       	call   8310 <lodepng_chunk_type_equals>
    f4dd:	83 c4 08             	add    $0x8,%esp
    f4e0:	84 c0                	test   %al,%al
    f4e2:	74 24                	je     f508 <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    f4e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f4e7:	8b 55 08             	mov    0x8(%ebp),%edx
    f4ea:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f4f0:	83 ec 04             	sub    $0x4,%esp
    f4f3:	50                   	push   %eax
    f4f4:	ff 75 e4             	pushl  -0x1c(%ebp)
    f4f7:	52                   	push   %edx
    f4f8:	e8 5b ee ff ff       	call   e358 <readChunk_PLTE>
    f4fd:	83 c4 10             	add    $0x10,%esp
    f500:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f503:	e9 8a 02 00 00       	jmp    f792 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    f508:	83 ec 08             	sub    $0x8,%esp
    f50b:	68 8d a0 01 00       	push   $0x1a08d
    f510:	ff 75 ec             	pushl  -0x14(%ebp)
    f513:	e8 f8 8d ff ff       	call   8310 <lodepng_chunk_type_equals>
    f518:	83 c4 10             	add    $0x10,%esp
    f51b:	84 c0                	test   %al,%al
    f51d:	74 24                	je     f543 <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    f51f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f522:	8b 55 08             	mov    0x8(%ebp),%edx
    f525:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f52b:	83 ec 04             	sub    $0x4,%esp
    f52e:	50                   	push   %eax
    f52f:	ff 75 e4             	pushl  -0x1c(%ebp)
    f532:	52                   	push   %edx
    f533:	e8 40 ef ff ff       	call   e478 <readChunk_tRNS>
    f538:	83 c4 10             	add    $0x10,%esp
    f53b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f53e:	e9 4f 02 00 00       	jmp    f792 <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    f543:	83 ec 08             	sub    $0x8,%esp
    f546:	68 92 a0 01 00       	push   $0x1a092
    f54b:	ff 75 ec             	pushl  -0x14(%ebp)
    f54e:	e8 bd 8d ff ff       	call   8310 <lodepng_chunk_type_equals>
    f553:	83 c4 10             	add    $0x10,%esp
    f556:	84 c0                	test   %al,%al
    f558:	74 24                	je     f57e <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    f55a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f55d:	8b 55 08             	mov    0x8(%ebp),%edx
    f560:	81 c2 98 00 00 00    	add    $0x98,%edx
    f566:	83 ec 04             	sub    $0x4,%esp
    f569:	50                   	push   %eax
    f56a:	ff 75 e4             	pushl  -0x1c(%ebp)
    f56d:	52                   	push   %edx
    f56e:	e8 68 f0 ff ff       	call   e5db <readChunk_bKGD>
    f573:	83 c4 10             	add    $0x10,%esp
    f576:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f579:	e9 14 02 00 00       	jmp    f792 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    f57e:	83 ec 08             	sub    $0x8,%esp
    f581:	68 97 a0 01 00       	push   $0x1a097
    f586:	ff 75 ec             	pushl  -0x14(%ebp)
    f589:	e8 82 8d ff ff       	call   8310 <lodepng_chunk_type_equals>
    f58e:	83 c4 10             	add    $0x10,%esp
    f591:	84 c0                	test   %al,%al
    f593:	74 24                	je     f5b9 <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    f595:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f598:	8b 55 08             	mov    0x8(%ebp),%edx
    f59b:	81 c2 98 00 00 00    	add    $0x98,%edx
    f5a1:	83 ec 04             	sub    $0x4,%esp
    f5a4:	50                   	push   %eax
    f5a5:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5a8:	52                   	push   %edx
    f5a9:	e8 b0 f1 ff ff       	call   e75e <readChunk_tEXt>
    f5ae:	83 c4 10             	add    $0x10,%esp
    f5b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f5b4:	e9 d9 01 00 00       	jmp    f792 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    f5b9:	83 ec 08             	sub    $0x8,%esp
    f5bc:	68 9c a0 01 00       	push   $0x1a09c
    f5c1:	ff 75 ec             	pushl  -0x14(%ebp)
    f5c4:	e8 47 8d ff ff       	call   8310 <lodepng_chunk_type_equals>
    f5c9:	83 c4 10             	add    $0x10,%esp
    f5cc:	84 c0                	test   %al,%al
    f5ce:	74 25                	je     f5f5 <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    f5d0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f5d3:	8b 45 08             	mov    0x8(%ebp),%eax
    f5d6:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f5d9:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f5df:	52                   	push   %edx
    f5e0:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5e3:	50                   	push   %eax
    f5e4:	51                   	push   %ecx
    f5e5:	e8 c0 f2 ff ff       	call   e8aa <readChunk_zTXt>
    f5ea:	83 c4 10             	add    $0x10,%esp
    f5ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f5f0:	e9 9d 01 00 00       	jmp    f792 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    f5f5:	83 ec 08             	sub    $0x8,%esp
    f5f8:	68 a1 a0 01 00       	push   $0x1a0a1
    f5fd:	ff 75 ec             	pushl  -0x14(%ebp)
    f600:	e8 0b 8d ff ff       	call   8310 <lodepng_chunk_type_equals>
    f605:	83 c4 10             	add    $0x10,%esp
    f608:	84 c0                	test   %al,%al
    f60a:	74 25                	je     f631 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    f60c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f60f:	8b 45 08             	mov    0x8(%ebp),%eax
    f612:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f615:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f61b:	52                   	push   %edx
    f61c:	ff 75 e4             	pushl  -0x1c(%ebp)
    f61f:	50                   	push   %eax
    f620:	51                   	push   %ecx
    f621:	e8 40 f4 ff ff       	call   ea66 <readChunk_iTXt>
    f626:	83 c4 10             	add    $0x10,%esp
    f629:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f62c:	e9 61 01 00 00       	jmp    f792 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    f631:	83 ec 08             	sub    $0x8,%esp
    f634:	68 a6 a0 01 00       	push   $0x1a0a6
    f639:	ff 75 ec             	pushl  -0x14(%ebp)
    f63c:	e8 cf 8c ff ff       	call   8310 <lodepng_chunk_type_equals>
    f641:	83 c4 10             	add    $0x10,%esp
    f644:	84 c0                	test   %al,%al
    f646:	74 24                	je     f66c <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    f648:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f64b:	8b 55 08             	mov    0x8(%ebp),%edx
    f64e:	81 c2 98 00 00 00    	add    $0x98,%edx
    f654:	83 ec 04             	sub    $0x4,%esp
    f657:	50                   	push   %eax
    f658:	ff 75 e4             	pushl  -0x1c(%ebp)
    f65b:	52                   	push   %edx
    f65c:	e8 5b f7 ff ff       	call   edbc <readChunk_tIME>
    f661:	83 c4 10             	add    $0x10,%esp
    f664:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f667:	e9 26 01 00 00       	jmp    f792 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    f66c:	83 ec 08             	sub    $0x8,%esp
    f66f:	68 ab a0 01 00       	push   $0x1a0ab
    f674:	ff 75 ec             	pushl  -0x14(%ebp)
    f677:	e8 94 8c ff ff       	call   8310 <lodepng_chunk_type_equals>
    f67c:	83 c4 10             	add    $0x10,%esp
    f67f:	84 c0                	test   %al,%al
    f681:	74 24                	je     f6a7 <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    f683:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f686:	8b 55 08             	mov    0x8(%ebp),%edx
    f689:	81 c2 98 00 00 00    	add    $0x98,%edx
    f68f:	83 ec 04             	sub    $0x4,%esp
    f692:	50                   	push   %eax
    f693:	ff 75 e4             	pushl  -0x1c(%ebp)
    f696:	52                   	push   %edx
    f697:	e8 c0 f7 ff ff       	call   ee5c <readChunk_pHYs>
    f69c:	83 c4 10             	add    $0x10,%esp
    f69f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6a2:	e9 eb 00 00 00       	jmp    f792 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    f6a7:	83 ec 08             	sub    $0x8,%esp
    f6aa:	68 b0 a0 01 00       	push   $0x1a0b0
    f6af:	ff 75 ec             	pushl  -0x14(%ebp)
    f6b2:	e8 59 8c ff ff       	call   8310 <lodepng_chunk_type_equals>
    f6b7:	83 c4 10             	add    $0x10,%esp
    f6ba:	84 c0                	test   %al,%al
    f6bc:	74 24                	je     f6e2 <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    f6be:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f6c1:	8b 55 08             	mov    0x8(%ebp),%edx
    f6c4:	81 c2 98 00 00 00    	add    $0x98,%edx
    f6ca:	83 ec 04             	sub    $0x4,%esp
    f6cd:	50                   	push   %eax
    f6ce:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6d1:	52                   	push   %edx
    f6d2:	e8 54 f8 ff ff       	call   ef2b <readChunk_gAMA>
    f6d7:	83 c4 10             	add    $0x10,%esp
    f6da:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6dd:	e9 b0 00 00 00       	jmp    f792 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    f6e2:	83 ec 08             	sub    $0x8,%esp
    f6e5:	68 b5 a0 01 00       	push   $0x1a0b5
    f6ea:	ff 75 ec             	pushl  -0x14(%ebp)
    f6ed:	e8 1e 8c ff ff       	call   8310 <lodepng_chunk_type_equals>
    f6f2:	83 c4 10             	add    $0x10,%esp
    f6f5:	84 c0                	test   %al,%al
    f6f7:	74 21                	je     f71a <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    f6f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f6fc:	8b 55 08             	mov    0x8(%ebp),%edx
    f6ff:	81 c2 98 00 00 00    	add    $0x98,%edx
    f705:	83 ec 04             	sub    $0x4,%esp
    f708:	50                   	push   %eax
    f709:	ff 75 e4             	pushl  -0x1c(%ebp)
    f70c:	52                   	push   %edx
    f70d:	e8 88 f8 ff ff       	call   ef9a <readChunk_cHRM>
    f712:	83 c4 10             	add    $0x10,%esp
    f715:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f718:	eb 78                	jmp    f792 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    f71a:	83 ec 08             	sub    $0x8,%esp
    f71d:	68 ba a0 01 00       	push   $0x1a0ba
    f722:	ff 75 ec             	pushl  -0x14(%ebp)
    f725:	e8 e6 8b ff ff       	call   8310 <lodepng_chunk_type_equals>
    f72a:	83 c4 10             	add    $0x10,%esp
    f72d:	84 c0                	test   %al,%al
    f72f:	74 21                	je     f752 <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    f731:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f734:	8b 55 08             	mov    0x8(%ebp),%edx
    f737:	81 c2 98 00 00 00    	add    $0x98,%edx
    f73d:	83 ec 04             	sub    $0x4,%esp
    f740:	50                   	push   %eax
    f741:	ff 75 e4             	pushl  -0x1c(%ebp)
    f744:	52                   	push   %edx
    f745:	e8 e4 fa ff ff       	call   f22e <readChunk_sRGB>
    f74a:	83 c4 10             	add    $0x10,%esp
    f74d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f750:	eb 40                	jmp    f792 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    f752:	83 ec 08             	sub    $0x8,%esp
    f755:	68 bf a0 01 00       	push   $0x1a0bf
    f75a:	ff 75 ec             	pushl  -0x14(%ebp)
    f75d:	e8 ae 8b ff ff       	call   8310 <lodepng_chunk_type_equals>
    f762:	83 c4 10             	add    $0x10,%esp
    f765:	84 c0                	test   %al,%al
    f767:	74 22                	je     f78b <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    f769:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f76c:	8b 45 08             	mov    0x8(%ebp),%eax
    f76f:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f772:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f778:	52                   	push   %edx
    f779:	ff 75 e4             	pushl  -0x1c(%ebp)
    f77c:	50                   	push   %eax
    f77d:	51                   	push   %ecx
    f77e:	e8 e1 fa ff ff       	call   f264 <readChunk_iCCP>
    f783:	83 c4 10             	add    $0x10,%esp
    f786:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f789:	eb 07                	jmp    f792 <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    f78b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    f792:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f796:	75 29                	jne    f7c1 <lodepng_inspect_chunk+0x374>
    f798:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f79c:	75 23                	jne    f7c1 <lodepng_inspect_chunk+0x374>
    f79e:	8b 45 08             	mov    0x8(%ebp),%eax
    f7a1:	8b 40 18             	mov    0x18(%eax),%eax
    f7a4:	85 c0                	test   %eax,%eax
    f7a6:	75 19                	jne    f7c1 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    f7a8:	83 ec 0c             	sub    $0xc,%esp
    f7ab:	ff 75 ec             	pushl  -0x14(%ebp)
    f7ae:	e8 53 8c ff ff       	call   8406 <lodepng_chunk_check_crc>
    f7b3:	83 c4 10             	add    $0x10,%esp
    f7b6:	85 c0                	test   %eax,%eax
    f7b8:	74 07                	je     f7c1 <lodepng_inspect_chunk+0x374>
    f7ba:	b8 39 00 00 00       	mov    $0x39,%eax
    f7bf:	eb 03                	jmp    f7c4 <lodepng_inspect_chunk+0x377>
  }

  return error;
    f7c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    f7c4:	c9                   	leave  
    f7c5:	c3                   	ret    

0000f7c6 <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    f7c6:	55                   	push   %ebp
    f7c7:	89 e5                	mov    %esp,%ebp
    f7c9:	56                   	push   %esi
    f7ca:	53                   	push   %ebx
    f7cb:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    f7ce:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    f7d2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    f7d9:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    f7e0:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    f7e7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    f7ee:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    f7f5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    f7fc:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    f803:	8b 45 08             	mov    0x8(%ebp),%eax
    f806:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    f80c:	8b 45 10             	mov    0x10(%ebp),%eax
    f80f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    f815:	8b 45 10             	mov    0x10(%ebp),%eax
    f818:	8b 10                	mov    (%eax),%edx
    f81a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f81d:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    f81f:	83 ec 0c             	sub    $0xc,%esp
    f822:	ff 75 1c             	pushl  0x1c(%ebp)
    f825:	ff 75 18             	pushl  0x18(%ebp)
    f828:	ff 75 14             	pushl  0x14(%ebp)
    f82b:	ff 75 10             	pushl  0x10(%ebp)
    f82e:	ff 75 0c             	pushl  0xc(%ebp)
    f831:	e8 d3 da ff ff       	call   d309 <lodepng_inspect>
    f836:	83 c4 20             	add    $0x20,%esp
    f839:	89 c2                	mov    %eax,%edx
    f83b:	8b 45 14             	mov    0x14(%ebp),%eax
    f83e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    f844:	8b 45 14             	mov    0x14(%ebp),%eax
    f847:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    f84d:	85 c0                	test   %eax,%eax
    f84f:	0f 85 24 0a 00 00    	jne    10279 <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    f855:	8b 45 14             	mov    0x14(%ebp),%eax
    f858:	8d 58 78             	lea    0x78(%eax),%ebx
    f85b:	8b 45 14             	mov    0x14(%ebp),%eax
    f85e:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    f864:	8b 45 10             	mov    0x10(%ebp),%eax
    f867:	8b 10                	mov    (%eax),%edx
    f869:	8b 45 0c             	mov    0xc(%ebp),%eax
    f86c:	8b 00                	mov    (%eax),%eax
    f86e:	53                   	push   %ebx
    f86f:	51                   	push   %ecx
    f870:	52                   	push   %edx
    f871:	50                   	push   %eax
    f872:	e8 76 97 ff ff       	call   8fed <lodepng_pixel_overflow>
    f877:	83 c4 10             	add    $0x10,%esp
    f87a:	85 c0                	test   %eax,%eax
    f87c:	74 12                	je     f890 <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    f87e:	8b 45 14             	mov    0x14(%ebp),%eax
    f881:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    f888:	00 00 00 
    f88b:	e9 ea 09 00 00       	jmp    1027a <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    f890:	83 ec 0c             	sub    $0xc,%esp
    f893:	ff 75 1c             	pushl  0x1c(%ebp)
    f896:	e8 a6 3a ff ff       	call   3341 <lodepng_malloc>
    f89b:	83 c4 10             	add    $0x10,%esp
    f89e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    f8a1:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    f8a5:	75 12                	jne    f8b9 <decodeGeneric+0xf3>
    f8a7:	8b 45 14             	mov    0x14(%ebp),%eax
    f8aa:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    f8b1:	00 00 00 
    f8b4:	e9 c1 09 00 00       	jmp    1027a <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    f8b9:	8b 45 18             	mov    0x18(%ebp),%eax
    f8bc:	83 c0 21             	add    $0x21,%eax
    f8bf:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    f8c2:	e9 81 06 00 00       	jmp    ff48 <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    f8c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f8ca:	8b 45 18             	mov    0x18(%ebp),%eax
    f8cd:	29 c2                	sub    %eax,%edx
    f8cf:	89 d0                	mov    %edx,%eax
    f8d1:	83 c0 0c             	add    $0xc,%eax
    f8d4:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f8d7:	7f 08                	jg     f8e1 <decodeGeneric+0x11b>
    f8d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f8dc:	3b 45 18             	cmp    0x18(%ebp),%eax
    f8df:	73 20                	jae    f901 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f8e1:	8b 45 14             	mov    0x14(%ebp),%eax
    f8e4:	8b 40 20             	mov    0x20(%eax),%eax
    f8e7:	85 c0                	test   %eax,%eax
    f8e9:	0f 85 72 06 00 00    	jne    ff61 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    f8ef:	8b 45 14             	mov    0x14(%ebp),%eax
    f8f2:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    f8f9:	00 00 00 
    f8fc:	e9 6a 06 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    f901:	83 ec 0c             	sub    $0xc,%esp
    f904:	ff 75 f0             	pushl  -0x10(%ebp)
    f907:	e8 b7 89 ff ff       	call   82c3 <lodepng_chunk_length>
    f90c:	83 c4 10             	add    $0x10,%esp
    f90f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
    f912:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f915:	85 c0                	test   %eax,%eax
    f917:	79 20                	jns    f939 <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f919:	8b 45 14             	mov    0x14(%ebp),%eax
    f91c:	8b 40 20             	mov    0x20(%eax),%eax
    f91f:	85 c0                	test   %eax,%eax
    f921:	0f 85 3d 06 00 00    	jne    ff64 <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
    f927:	8b 45 14             	mov    0x14(%ebp),%eax
    f92a:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
    f931:	00 00 00 
    f934:	e9 32 06 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
    f939:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f93c:	8b 45 18             	mov    0x18(%ebp),%eax
    f93f:	29 c2                	sub    %eax,%edx
    f941:	89 d0                	mov    %edx,%eax
    f943:	89 c2                	mov    %eax,%edx
    f945:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f948:	01 d0                	add    %edx,%eax
    f94a:	83 c0 0c             	add    $0xc,%eax
    f94d:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f950:	7f 10                	jg     f962 <decodeGeneric+0x19c>
    f952:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f955:	8d 50 0c             	lea    0xc(%eax),%edx
    f958:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f95b:	01 d0                	add    %edx,%eax
    f95d:	3b 45 18             	cmp    0x18(%ebp),%eax
    f960:	73 12                	jae    f974 <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    f962:	8b 45 14             	mov    0x14(%ebp),%eax
    f965:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
    f96c:	00 00 00 
    f96f:	e9 f7 05 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
    f974:	83 ec 0c             	sub    $0xc,%esp
    f977:	ff 75 f0             	pushl  -0x10(%ebp)
    f97a:	e8 7c 8a ff ff       	call   83fb <lodepng_chunk_data_const>
    f97f:	83 c4 10             	add    $0x10,%esp
    f982:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
    f985:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
    f98c:	83 ec 08             	sub    $0x8,%esp
    f98f:	68 c4 a0 01 00       	push   $0x1a0c4
    f994:	ff 75 f0             	pushl  -0x10(%ebp)
    f997:	e8 74 89 ff ff       	call   8310 <lodepng_chunk_type_equals>
    f99c:	83 c4 10             	add    $0x10,%esp
    f99f:	84 c0                	test   %al,%al
    f9a1:	74 79                	je     fa1c <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
    f9a3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9a6:	83 ec 04             	sub    $0x4,%esp
    f9a9:	8d 55 bc             	lea    -0x44(%ebp),%edx
    f9ac:	52                   	push   %edx
    f9ad:	50                   	push   %eax
    f9ae:	ff 75 ec             	pushl  -0x14(%ebp)
    f9b1:	e8 4f 3a ff ff       	call   3405 <lodepng_addofl>
    f9b6:	83 c4 10             	add    $0x10,%esp
    f9b9:	85 c0                	test   %eax,%eax
    f9bb:	74 12                	je     f9cf <decodeGeneric+0x209>
    f9bd:	8b 45 14             	mov    0x14(%ebp),%eax
    f9c0:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    f9c7:	00 00 00 
    f9ca:	e9 9c 05 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
    f9cf:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f9d2:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f9d5:	7e 13                	jle    f9ea <decodeGeneric+0x224>
    f9d7:	8b 45 14             	mov    0x14(%ebp),%eax
    f9da:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    f9e1:	00 00 00 
    f9e4:	90                   	nop
    f9e5:	e9 81 05 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
    f9ea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9ed:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    f9f0:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f9f3:	01 ca                	add    %ecx,%edx
    f9f5:	83 ec 04             	sub    $0x4,%esp
    f9f8:	50                   	push   %eax
    f9f9:	ff 75 d0             	pushl  -0x30(%ebp)
    f9fc:	52                   	push   %edx
    f9fd:	e8 7d 39 ff ff       	call   337f <lodepng_memcpy>
    fa02:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
    fa05:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fa08:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa0b:	01 d0                	add    %edx,%eax
    fa0d:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
    fa10:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    fa17:	e9 db 04 00 00       	jmp    fef7 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
    fa1c:	83 ec 08             	sub    $0x8,%esp
    fa1f:	68 c9 a0 01 00       	push   $0x1a0c9
    fa24:	ff 75 f0             	pushl  -0x10(%ebp)
    fa27:	e8 e4 88 ff ff       	call   8310 <lodepng_chunk_type_equals>
    fa2c:	83 c4 10             	add    $0x10,%esp
    fa2f:	84 c0                	test   %al,%al
    fa31:	74 09                	je     fa3c <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
    fa33:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    fa37:	e9 bb 04 00 00       	jmp    fef7 <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    fa3c:	83 ec 08             	sub    $0x8,%esp
    fa3f:	68 88 a0 01 00       	push   $0x1a088
    fa44:	ff 75 f0             	pushl  -0x10(%ebp)
    fa47:	e8 c4 88 ff ff       	call   8310 <lodepng_chunk_type_equals>
    fa4c:	83 c4 10             	add    $0x10,%esp
    fa4f:	84 c0                	test   %al,%al
    fa51:	74 44                	je     fa97 <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    fa53:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa56:	8b 55 14             	mov    0x14(%ebp),%edx
    fa59:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fa5f:	83 ec 04             	sub    $0x4,%esp
    fa62:	50                   	push   %eax
    fa63:	ff 75 d0             	pushl  -0x30(%ebp)
    fa66:	52                   	push   %edx
    fa67:	e8 ec e8 ff ff       	call   e358 <readChunk_PLTE>
    fa6c:	83 c4 10             	add    $0x10,%esp
    fa6f:	89 c2                	mov    %eax,%edx
    fa71:	8b 45 14             	mov    0x14(%ebp),%eax
    fa74:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fa7a:	8b 45 14             	mov    0x14(%ebp),%eax
    fa7d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fa83:	85 c0                	test   %eax,%eax
    fa85:	0f 85 dc 04 00 00    	jne    ff67 <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
    fa8b:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    fa92:	e9 60 04 00 00       	jmp    fef7 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fa97:	83 ec 08             	sub    $0x8,%esp
    fa9a:	68 8d a0 01 00       	push   $0x1a08d
    fa9f:	ff 75 f0             	pushl  -0x10(%ebp)
    faa2:	e8 69 88 ff ff       	call   8310 <lodepng_chunk_type_equals>
    faa7:	83 c4 10             	add    $0x10,%esp
    faaa:	84 c0                	test   %al,%al
    faac:	74 3d                	je     faeb <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    faae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fab1:	8b 55 14             	mov    0x14(%ebp),%edx
    fab4:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    faba:	83 ec 04             	sub    $0x4,%esp
    fabd:	50                   	push   %eax
    fabe:	ff 75 d0             	pushl  -0x30(%ebp)
    fac1:	52                   	push   %edx
    fac2:	e8 b1 e9 ff ff       	call   e478 <readChunk_tRNS>
    fac7:	83 c4 10             	add    $0x10,%esp
    faca:	89 c2                	mov    %eax,%edx
    facc:	8b 45 14             	mov    0x14(%ebp),%eax
    facf:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fad5:	8b 45 14             	mov    0x14(%ebp),%eax
    fad8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fade:	85 c0                	test   %eax,%eax
    fae0:	0f 84 11 04 00 00    	je     fef7 <decodeGeneric+0x731>
    fae6:	e9 80 04 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    faeb:	83 ec 08             	sub    $0x8,%esp
    faee:	68 92 a0 01 00       	push   $0x1a092
    faf3:	ff 75 f0             	pushl  -0x10(%ebp)
    faf6:	e8 15 88 ff ff       	call   8310 <lodepng_chunk_type_equals>
    fafb:	83 c4 10             	add    $0x10,%esp
    fafe:	84 c0                	test   %al,%al
    fb00:	74 3d                	je     fb3f <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fb02:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb05:	8b 55 14             	mov    0x14(%ebp),%edx
    fb08:	81 c2 98 00 00 00    	add    $0x98,%edx
    fb0e:	83 ec 04             	sub    $0x4,%esp
    fb11:	50                   	push   %eax
    fb12:	ff 75 d0             	pushl  -0x30(%ebp)
    fb15:	52                   	push   %edx
    fb16:	e8 c0 ea ff ff       	call   e5db <readChunk_bKGD>
    fb1b:	83 c4 10             	add    $0x10,%esp
    fb1e:	89 c2                	mov    %eax,%edx
    fb20:	8b 45 14             	mov    0x14(%ebp),%eax
    fb23:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fb29:	8b 45 14             	mov    0x14(%ebp),%eax
    fb2c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb32:	85 c0                	test   %eax,%eax
    fb34:	0f 84 bd 03 00 00    	je     fef7 <decodeGeneric+0x731>
    fb3a:	e9 2c 04 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fb3f:	83 ec 08             	sub    $0x8,%esp
    fb42:	68 97 a0 01 00       	push   $0x1a097
    fb47:	ff 75 f0             	pushl  -0x10(%ebp)
    fb4a:	e8 c1 87 ff ff       	call   8310 <lodepng_chunk_type_equals>
    fb4f:	83 c4 10             	add    $0x10,%esp
    fb52:	84 c0                	test   %al,%al
    fb54:	74 4b                	je     fba1 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
    fb56:	8b 45 14             	mov    0x14(%ebp),%eax
    fb59:	8b 40 28             	mov    0x28(%eax),%eax
    fb5c:	85 c0                	test   %eax,%eax
    fb5e:	0f 84 93 03 00 00    	je     fef7 <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
    fb64:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb67:	8b 55 14             	mov    0x14(%ebp),%edx
    fb6a:	81 c2 98 00 00 00    	add    $0x98,%edx
    fb70:	83 ec 04             	sub    $0x4,%esp
    fb73:	50                   	push   %eax
    fb74:	ff 75 d0             	pushl  -0x30(%ebp)
    fb77:	52                   	push   %edx
    fb78:	e8 e1 eb ff ff       	call   e75e <readChunk_tEXt>
    fb7d:	83 c4 10             	add    $0x10,%esp
    fb80:	89 c2                	mov    %eax,%edx
    fb82:	8b 45 14             	mov    0x14(%ebp),%eax
    fb85:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fb8b:	8b 45 14             	mov    0x14(%ebp),%eax
    fb8e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb94:	85 c0                	test   %eax,%eax
    fb96:	0f 84 5b 03 00 00    	je     fef7 <decodeGeneric+0x731>
    fb9c:	e9 ca 03 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    fba1:	83 ec 08             	sub    $0x8,%esp
    fba4:	68 9c a0 01 00       	push   $0x1a09c
    fba9:	ff 75 f0             	pushl  -0x10(%ebp)
    fbac:	e8 5f 87 ff ff       	call   8310 <lodepng_chunk_type_equals>
    fbb1:	83 c4 10             	add    $0x10,%esp
    fbb4:	84 c0                	test   %al,%al
    fbb6:	74 4c                	je     fc04 <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
    fbb8:	8b 45 14             	mov    0x14(%ebp),%eax
    fbbb:	8b 40 28             	mov    0x28(%eax),%eax
    fbbe:	85 c0                	test   %eax,%eax
    fbc0:	0f 84 31 03 00 00    	je     fef7 <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    fbc6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fbc9:	8b 45 14             	mov    0x14(%ebp),%eax
    fbcc:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fbcf:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fbd5:	52                   	push   %edx
    fbd6:	ff 75 d0             	pushl  -0x30(%ebp)
    fbd9:	50                   	push   %eax
    fbda:	51                   	push   %ecx
    fbdb:	e8 ca ec ff ff       	call   e8aa <readChunk_zTXt>
    fbe0:	83 c4 10             	add    $0x10,%esp
    fbe3:	89 c2                	mov    %eax,%edx
    fbe5:	8b 45 14             	mov    0x14(%ebp),%eax
    fbe8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fbee:	8b 45 14             	mov    0x14(%ebp),%eax
    fbf1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fbf7:	85 c0                	test   %eax,%eax
    fbf9:	0f 84 f8 02 00 00    	je     fef7 <decodeGeneric+0x731>
    fbff:	e9 67 03 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    fc04:	83 ec 08             	sub    $0x8,%esp
    fc07:	68 a1 a0 01 00       	push   $0x1a0a1
    fc0c:	ff 75 f0             	pushl  -0x10(%ebp)
    fc0f:	e8 fc 86 ff ff       	call   8310 <lodepng_chunk_type_equals>
    fc14:	83 c4 10             	add    $0x10,%esp
    fc17:	84 c0                	test   %al,%al
    fc19:	74 4c                	je     fc67 <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
    fc1b:	8b 45 14             	mov    0x14(%ebp),%eax
    fc1e:	8b 40 28             	mov    0x28(%eax),%eax
    fc21:	85 c0                	test   %eax,%eax
    fc23:	0f 84 ce 02 00 00    	je     fef7 <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    fc29:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fc2c:	8b 45 14             	mov    0x14(%ebp),%eax
    fc2f:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fc32:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fc38:	52                   	push   %edx
    fc39:	ff 75 d0             	pushl  -0x30(%ebp)
    fc3c:	50                   	push   %eax
    fc3d:	51                   	push   %ecx
    fc3e:	e8 23 ee ff ff       	call   ea66 <readChunk_iTXt>
    fc43:	83 c4 10             	add    $0x10,%esp
    fc46:	89 c2                	mov    %eax,%edx
    fc48:	8b 45 14             	mov    0x14(%ebp),%eax
    fc4b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fc51:	8b 45 14             	mov    0x14(%ebp),%eax
    fc54:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc5a:	85 c0                	test   %eax,%eax
    fc5c:	0f 84 95 02 00 00    	je     fef7 <decodeGeneric+0x731>
    fc62:	e9 04 03 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    fc67:	83 ec 08             	sub    $0x8,%esp
    fc6a:	68 a6 a0 01 00       	push   $0x1a0a6
    fc6f:	ff 75 f0             	pushl  -0x10(%ebp)
    fc72:	e8 99 86 ff ff       	call   8310 <lodepng_chunk_type_equals>
    fc77:	83 c4 10             	add    $0x10,%esp
    fc7a:	84 c0                	test   %al,%al
    fc7c:	74 3d                	je     fcbb <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
    fc7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fc81:	8b 55 14             	mov    0x14(%ebp),%edx
    fc84:	81 c2 98 00 00 00    	add    $0x98,%edx
    fc8a:	83 ec 04             	sub    $0x4,%esp
    fc8d:	50                   	push   %eax
    fc8e:	ff 75 d0             	pushl  -0x30(%ebp)
    fc91:	52                   	push   %edx
    fc92:	e8 25 f1 ff ff       	call   edbc <readChunk_tIME>
    fc97:	83 c4 10             	add    $0x10,%esp
    fc9a:	89 c2                	mov    %eax,%edx
    fc9c:	8b 45 14             	mov    0x14(%ebp),%eax
    fc9f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fca5:	8b 45 14             	mov    0x14(%ebp),%eax
    fca8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fcae:	85 c0                	test   %eax,%eax
    fcb0:	0f 84 41 02 00 00    	je     fef7 <decodeGeneric+0x731>
    fcb6:	e9 b0 02 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    fcbb:	83 ec 08             	sub    $0x8,%esp
    fcbe:	68 ab a0 01 00       	push   $0x1a0ab
    fcc3:	ff 75 f0             	pushl  -0x10(%ebp)
    fcc6:	e8 45 86 ff ff       	call   8310 <lodepng_chunk_type_equals>
    fccb:	83 c4 10             	add    $0x10,%esp
    fcce:	84 c0                	test   %al,%al
    fcd0:	74 3d                	je     fd0f <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
    fcd2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fcd5:	8b 55 14             	mov    0x14(%ebp),%edx
    fcd8:	81 c2 98 00 00 00    	add    $0x98,%edx
    fcde:	83 ec 04             	sub    $0x4,%esp
    fce1:	50                   	push   %eax
    fce2:	ff 75 d0             	pushl  -0x30(%ebp)
    fce5:	52                   	push   %edx
    fce6:	e8 71 f1 ff ff       	call   ee5c <readChunk_pHYs>
    fceb:	83 c4 10             	add    $0x10,%esp
    fcee:	89 c2                	mov    %eax,%edx
    fcf0:	8b 45 14             	mov    0x14(%ebp),%eax
    fcf3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fcf9:	8b 45 14             	mov    0x14(%ebp),%eax
    fcfc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd02:	85 c0                	test   %eax,%eax
    fd04:	0f 84 ed 01 00 00    	je     fef7 <decodeGeneric+0x731>
    fd0a:	e9 5c 02 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    fd0f:	83 ec 08             	sub    $0x8,%esp
    fd12:	68 b0 a0 01 00       	push   $0x1a0b0
    fd17:	ff 75 f0             	pushl  -0x10(%ebp)
    fd1a:	e8 f1 85 ff ff       	call   8310 <lodepng_chunk_type_equals>
    fd1f:	83 c4 10             	add    $0x10,%esp
    fd22:	84 c0                	test   %al,%al
    fd24:	74 3d                	je     fd63 <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
    fd26:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd29:	8b 55 14             	mov    0x14(%ebp),%edx
    fd2c:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd32:	83 ec 04             	sub    $0x4,%esp
    fd35:	50                   	push   %eax
    fd36:	ff 75 d0             	pushl  -0x30(%ebp)
    fd39:	52                   	push   %edx
    fd3a:	e8 ec f1 ff ff       	call   ef2b <readChunk_gAMA>
    fd3f:	83 c4 10             	add    $0x10,%esp
    fd42:	89 c2                	mov    %eax,%edx
    fd44:	8b 45 14             	mov    0x14(%ebp),%eax
    fd47:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd4d:	8b 45 14             	mov    0x14(%ebp),%eax
    fd50:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd56:	85 c0                	test   %eax,%eax
    fd58:	0f 84 99 01 00 00    	je     fef7 <decodeGeneric+0x731>
    fd5e:	e9 08 02 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    fd63:	83 ec 08             	sub    $0x8,%esp
    fd66:	68 b5 a0 01 00       	push   $0x1a0b5
    fd6b:	ff 75 f0             	pushl  -0x10(%ebp)
    fd6e:	e8 9d 85 ff ff       	call   8310 <lodepng_chunk_type_equals>
    fd73:	83 c4 10             	add    $0x10,%esp
    fd76:	84 c0                	test   %al,%al
    fd78:	74 3d                	je     fdb7 <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
    fd7a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd7d:	8b 55 14             	mov    0x14(%ebp),%edx
    fd80:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd86:	83 ec 04             	sub    $0x4,%esp
    fd89:	50                   	push   %eax
    fd8a:	ff 75 d0             	pushl  -0x30(%ebp)
    fd8d:	52                   	push   %edx
    fd8e:	e8 07 f2 ff ff       	call   ef9a <readChunk_cHRM>
    fd93:	83 c4 10             	add    $0x10,%esp
    fd96:	89 c2                	mov    %eax,%edx
    fd98:	8b 45 14             	mov    0x14(%ebp),%eax
    fd9b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fda1:	8b 45 14             	mov    0x14(%ebp),%eax
    fda4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fdaa:	85 c0                	test   %eax,%eax
    fdac:	0f 84 45 01 00 00    	je     fef7 <decodeGeneric+0x731>
    fdb2:	e9 b4 01 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    fdb7:	83 ec 08             	sub    $0x8,%esp
    fdba:	68 ba a0 01 00       	push   $0x1a0ba
    fdbf:	ff 75 f0             	pushl  -0x10(%ebp)
    fdc2:	e8 49 85 ff ff       	call   8310 <lodepng_chunk_type_equals>
    fdc7:	83 c4 10             	add    $0x10,%esp
    fdca:	84 c0                	test   %al,%al
    fdcc:	74 3d                	je     fe0b <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
    fdce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fdd1:	8b 55 14             	mov    0x14(%ebp),%edx
    fdd4:	81 c2 98 00 00 00    	add    $0x98,%edx
    fdda:	83 ec 04             	sub    $0x4,%esp
    fddd:	50                   	push   %eax
    fdde:	ff 75 d0             	pushl  -0x30(%ebp)
    fde1:	52                   	push   %edx
    fde2:	e8 47 f4 ff ff       	call   f22e <readChunk_sRGB>
    fde7:	83 c4 10             	add    $0x10,%esp
    fdea:	89 c2                	mov    %eax,%edx
    fdec:	8b 45 14             	mov    0x14(%ebp),%eax
    fdef:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fdf5:	8b 45 14             	mov    0x14(%ebp),%eax
    fdf8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fdfe:	85 c0                	test   %eax,%eax
    fe00:	0f 84 f1 00 00 00    	je     fef7 <decodeGeneric+0x731>
    fe06:	e9 60 01 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    fe0b:	83 ec 08             	sub    $0x8,%esp
    fe0e:	68 bf a0 01 00       	push   $0x1a0bf
    fe13:	ff 75 f0             	pushl  -0x10(%ebp)
    fe16:	e8 f5 84 ff ff       	call   8310 <lodepng_chunk_type_equals>
    fe1b:	83 c4 10             	add    $0x10,%esp
    fe1e:	84 c0                	test   %al,%al
    fe20:	74 3e                	je     fe60 <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    fe22:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fe25:	8b 45 14             	mov    0x14(%ebp),%eax
    fe28:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fe2b:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fe31:	52                   	push   %edx
    fe32:	ff 75 d0             	pushl  -0x30(%ebp)
    fe35:	50                   	push   %eax
    fe36:	51                   	push   %ecx
    fe37:	e8 28 f4 ff ff       	call   f264 <readChunk_iCCP>
    fe3c:	83 c4 10             	add    $0x10,%esp
    fe3f:	89 c2                	mov    %eax,%edx
    fe41:	8b 45 14             	mov    0x14(%ebp),%eax
    fe44:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe4a:	8b 45 14             	mov    0x14(%ebp),%eax
    fe4d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe53:	85 c0                	test   %eax,%eax
    fe55:	0f 84 9c 00 00 00    	je     fef7 <decodeGeneric+0x731>
    fe5b:	e9 0b 01 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
    fe60:	8b 45 14             	mov    0x14(%ebp),%eax
    fe63:	8b 40 1c             	mov    0x1c(%eax),%eax
    fe66:	85 c0                	test   %eax,%eax
    fe68:	75 24                	jne    fe8e <decodeGeneric+0x6c8>
    fe6a:	83 ec 0c             	sub    $0xc,%esp
    fe6d:	ff 75 f0             	pushl  -0x10(%ebp)
    fe70:	e8 30 85 ff ff       	call   83a5 <lodepng_chunk_ancillary>
    fe75:	83 c4 10             	add    $0x10,%esp
    fe78:	84 c0                	test   %al,%al
    fe7a:	75 12                	jne    fe8e <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
    fe7c:	8b 45 14             	mov    0x14(%ebp),%eax
    fe7f:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
    fe86:	00 00 00 
    fe89:	e9 dd 00 00 00       	jmp    ff6b <decodeGeneric+0x7a5>
      }

      unknown = 1;
    fe8e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
    fe95:	8b 45 14             	mov    0x14(%ebp),%eax
    fe98:	8b 40 2c             	mov    0x2c(%eax),%eax
    fe9b:	85 c0                	test   %eax,%eax
    fe9d:	74 58                	je     fef7 <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
    fe9f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    fea2:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
    fea5:	83 c0 58             	add    $0x58,%eax
    fea8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    feaf:	8b 45 14             	mov    0x14(%ebp),%eax
    feb2:	01 d0                	add    %edx,%eax
    feb4:	8d 50 10             	lea    0x10(%eax),%edx
    feb7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    feba:	83 e8 01             	sub    $0x1,%eax
    febd:	83 c0 54             	add    $0x54,%eax
    fec0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    fec7:	8b 45 14             	mov    0x14(%ebp),%eax
    feca:	01 c8                	add    %ecx,%eax
    fecc:	83 c0 14             	add    $0x14,%eax
    fecf:	83 ec 04             	sub    $0x4,%esp
    fed2:	ff 75 f0             	pushl  -0x10(%ebp)
    fed5:	52                   	push   %edx
    fed6:	50                   	push   %eax
    fed7:	e8 15 88 ff ff       	call   86f1 <lodepng_chunk_append>
    fedc:	83 c4 10             	add    $0x10,%esp
    fedf:	89 c2                	mov    %eax,%edx
    fee1:	8b 45 14             	mov    0x14(%ebp),%eax
    fee4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    feea:	8b 45 14             	mov    0x14(%ebp),%eax
    feed:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fef3:	85 c0                	test   %eax,%eax
    fef5:	75 73                	jne    ff6a <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
    fef7:	8b 45 14             	mov    0x14(%ebp),%eax
    fefa:	8b 40 18             	mov    0x18(%eax),%eax
    fefd:	85 c0                	test   %eax,%eax
    feff:	75 27                	jne    ff28 <decodeGeneric+0x762>
    ff01:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ff05:	75 21                	jne    ff28 <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
    ff07:	83 ec 0c             	sub    $0xc,%esp
    ff0a:	ff 75 f0             	pushl  -0x10(%ebp)
    ff0d:	e8 f4 84 ff ff       	call   8406 <lodepng_chunk_check_crc>
    ff12:	83 c4 10             	add    $0x10,%esp
    ff15:	85 c0                	test   %eax,%eax
    ff17:	74 0f                	je     ff28 <decodeGeneric+0x762>
    ff19:	8b 45 14             	mov    0x14(%ebp),%eax
    ff1c:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    ff23:	00 00 00 
    ff26:	eb 43                	jmp    ff6b <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
    ff28:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    ff2c:	75 1a                	jne    ff48 <decodeGeneric+0x782>
    ff2e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ff31:	8b 45 18             	mov    0x18(%ebp),%eax
    ff34:	01 d0                	add    %edx,%eax
    ff36:	83 ec 08             	sub    $0x8,%esp
    ff39:	50                   	push   %eax
    ff3a:	ff 75 f0             	pushl  -0x10(%ebp)
    ff3d:	e8 3f 86 ff ff       	call   8581 <lodepng_chunk_next_const>
    ff42:	83 c4 10             	add    $0x10,%esp
    ff45:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    ff48:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    ff4c:	75 1d                	jne    ff6b <decodeGeneric+0x7a5>
    ff4e:	8b 45 14             	mov    0x14(%ebp),%eax
    ff51:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff57:	85 c0                	test   %eax,%eax
    ff59:	0f 84 68 f9 ff ff    	je     f8c7 <decodeGeneric+0x101>
    ff5f:	eb 0a                	jmp    ff6b <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ff61:	90                   	nop
    ff62:	eb 07                	jmp    ff6b <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ff64:	90                   	nop
    ff65:	eb 04                	jmp    ff6b <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
    ff67:	90                   	nop
    ff68:	eb 01                	jmp    ff6b <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    ff6a:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
    ff6b:	8b 45 14             	mov    0x14(%ebp),%eax
    ff6e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff74:	85 c0                	test   %eax,%eax
    ff76:	75 28                	jne    ffa0 <decodeGeneric+0x7da>
    ff78:	8b 45 14             	mov    0x14(%ebp),%eax
    ff7b:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
    ff81:	83 f8 03             	cmp    $0x3,%eax
    ff84:	75 1a                	jne    ffa0 <decodeGeneric+0x7da>
    ff86:	8b 45 14             	mov    0x14(%ebp),%eax
    ff89:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ff8f:	85 c0                	test   %eax,%eax
    ff91:	75 0d                	jne    ffa0 <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
    ff93:	8b 45 14             	mov    0x14(%ebp),%eax
    ff96:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
    ff9d:	00 00 00 
  }

  if(!state->error) {
    ffa0:	8b 45 14             	mov    0x14(%ebp),%eax
    ffa3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ffa9:	85 c0                	test   %eax,%eax
    ffab:	0f 85 d2 01 00 00    	jne    10183 <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
    ffb1:	8b 45 14             	mov    0x14(%ebp),%eax
    ffb4:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    ffba:	85 c0                	test   %eax,%eax
    ffbc:	75 3a                	jne    fff8 <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
    ffbe:	8b 45 14             	mov    0x14(%ebp),%eax
    ffc1:	05 a4 00 00 00       	add    $0xa4,%eax
    ffc6:	83 ec 0c             	sub    $0xc,%esp
    ffc9:	50                   	push   %eax
    ffca:	e8 8e 8e ff ff       	call   8e5d <lodepng_get_bpp>
    ffcf:	83 c4 10             	add    $0x10,%esp
    ffd2:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
    ffd5:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    ffd8:	8b 45 10             	mov    0x10(%ebp),%eax
    ffdb:	8b 10                	mov    (%eax),%edx
    ffdd:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffe0:	8b 00                	mov    (%eax),%eax
    ffe2:	83 ec 04             	sub    $0x4,%esp
    ffe5:	51                   	push   %ecx
    ffe6:	52                   	push   %edx
    ffe7:	50                   	push   %eax
    ffe8:	e8 cf 8f ff ff       	call   8fbc <lodepng_get_raw_size_idat>
    ffed:	83 c4 10             	add    $0x10,%esp
    fff0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    fff3:	e9 60 01 00 00       	jmp    10158 <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
    fff8:	8b 45 14             	mov    0x14(%ebp),%eax
    fffb:	05 a4 00 00 00       	add    $0xa4,%eax
   10000:	83 ec 0c             	sub    $0xc,%esp
   10003:	50                   	push   %eax
   10004:	e8 54 8e ff ff       	call   8e5d <lodepng_get_bpp>
   10009:	83 c4 10             	add    $0x10,%esp
   1000c:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   1000f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   10016:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10019:	8b 55 10             	mov    0x10(%ebp),%edx
   1001c:	8b 12                	mov    (%edx),%edx
   1001e:	83 c2 07             	add    $0x7,%edx
   10021:	89 d1                	mov    %edx,%ecx
   10023:	c1 e9 03             	shr    $0x3,%ecx
   10026:	8b 55 0c             	mov    0xc(%ebp),%edx
   10029:	8b 12                	mov    (%edx),%edx
   1002b:	83 c2 07             	add    $0x7,%edx
   1002e:	c1 ea 03             	shr    $0x3,%edx
   10031:	83 ec 04             	sub    $0x4,%esp
   10034:	50                   	push   %eax
   10035:	51                   	push   %ecx
   10036:	52                   	push   %edx
   10037:	e8 80 8f ff ff       	call   8fbc <lodepng_get_raw_size_idat>
   1003c:	83 c4 10             	add    $0x10,%esp
   1003f:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   10042:	8b 45 0c             	mov    0xc(%ebp),%eax
   10045:	8b 00                	mov    (%eax),%eax
   10047:	83 f8 04             	cmp    $0x4,%eax
   1004a:	76 2c                	jbe    10078 <decodeGeneric+0x8b2>
   1004c:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1004f:	8b 55 10             	mov    0x10(%ebp),%edx
   10052:	8b 12                	mov    (%edx),%edx
   10054:	83 c2 07             	add    $0x7,%edx
   10057:	89 d1                	mov    %edx,%ecx
   10059:	c1 e9 03             	shr    $0x3,%ecx
   1005c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1005f:	8b 12                	mov    (%edx),%edx
   10061:	83 c2 03             	add    $0x3,%edx
   10064:	c1 ea 03             	shr    $0x3,%edx
   10067:	83 ec 04             	sub    $0x4,%esp
   1006a:	50                   	push   %eax
   1006b:	51                   	push   %ecx
   1006c:	52                   	push   %edx
   1006d:	e8 4a 8f ff ff       	call   8fbc <lodepng_get_raw_size_idat>
   10072:	83 c4 10             	add    $0x10,%esp
   10075:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   10078:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1007b:	8b 55 10             	mov    0x10(%ebp),%edx
   1007e:	8b 12                	mov    (%edx),%edx
   10080:	83 c2 03             	add    $0x3,%edx
   10083:	89 d1                	mov    %edx,%ecx
   10085:	c1 e9 03             	shr    $0x3,%ecx
   10088:	8b 55 0c             	mov    0xc(%ebp),%edx
   1008b:	8b 12                	mov    (%edx),%edx
   1008d:	83 c2 03             	add    $0x3,%edx
   10090:	c1 ea 02             	shr    $0x2,%edx
   10093:	83 ec 04             	sub    $0x4,%esp
   10096:	50                   	push   %eax
   10097:	51                   	push   %ecx
   10098:	52                   	push   %edx
   10099:	e8 1e 8f ff ff       	call   8fbc <lodepng_get_raw_size_idat>
   1009e:	83 c4 10             	add    $0x10,%esp
   100a1:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   100a4:	8b 45 0c             	mov    0xc(%ebp),%eax
   100a7:	8b 00                	mov    (%eax),%eax
   100a9:	83 f8 02             	cmp    $0x2,%eax
   100ac:	76 2c                	jbe    100da <decodeGeneric+0x914>
   100ae:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100b1:	8b 55 10             	mov    0x10(%ebp),%edx
   100b4:	8b 12                	mov    (%edx),%edx
   100b6:	83 c2 03             	add    $0x3,%edx
   100b9:	89 d1                	mov    %edx,%ecx
   100bb:	c1 e9 02             	shr    $0x2,%ecx
   100be:	8b 55 0c             	mov    0xc(%ebp),%edx
   100c1:	8b 12                	mov    (%edx),%edx
   100c3:	83 c2 01             	add    $0x1,%edx
   100c6:	c1 ea 02             	shr    $0x2,%edx
   100c9:	83 ec 04             	sub    $0x4,%esp
   100cc:	50                   	push   %eax
   100cd:	51                   	push   %ecx
   100ce:	52                   	push   %edx
   100cf:	e8 e8 8e ff ff       	call   8fbc <lodepng_get_raw_size_idat>
   100d4:	83 c4 10             	add    $0x10,%esp
   100d7:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   100da:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100dd:	8b 55 10             	mov    0x10(%ebp),%edx
   100e0:	8b 12                	mov    (%edx),%edx
   100e2:	83 c2 01             	add    $0x1,%edx
   100e5:	89 d1                	mov    %edx,%ecx
   100e7:	c1 e9 02             	shr    $0x2,%ecx
   100ea:	8b 55 0c             	mov    0xc(%ebp),%edx
   100ed:	8b 12                	mov    (%edx),%edx
   100ef:	83 c2 01             	add    $0x1,%edx
   100f2:	d1 ea                	shr    %edx
   100f4:	83 ec 04             	sub    $0x4,%esp
   100f7:	50                   	push   %eax
   100f8:	51                   	push   %ecx
   100f9:	52                   	push   %edx
   100fa:	e8 bd 8e ff ff       	call   8fbc <lodepng_get_raw_size_idat>
   100ff:	83 c4 10             	add    $0x10,%esp
   10102:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   10105:	8b 45 0c             	mov    0xc(%ebp),%eax
   10108:	8b 00                	mov    (%eax),%eax
   1010a:	83 f8 01             	cmp    $0x1,%eax
   1010d:	76 27                	jbe    10136 <decodeGeneric+0x970>
   1010f:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10112:	8b 55 10             	mov    0x10(%ebp),%edx
   10115:	8b 12                	mov    (%edx),%edx
   10117:	83 c2 01             	add    $0x1,%edx
   1011a:	89 d1                	mov    %edx,%ecx
   1011c:	d1 e9                	shr    %ecx
   1011e:	8b 55 0c             	mov    0xc(%ebp),%edx
   10121:	8b 12                	mov    (%edx),%edx
   10123:	d1 ea                	shr    %edx
   10125:	83 ec 04             	sub    $0x4,%esp
   10128:	50                   	push   %eax
   10129:	51                   	push   %ecx
   1012a:	52                   	push   %edx
   1012b:	e8 8c 8e ff ff       	call   8fbc <lodepng_get_raw_size_idat>
   10130:	83 c4 10             	add    $0x10,%esp
   10133:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   10136:	8b 55 c8             	mov    -0x38(%ebp),%edx
   10139:	8b 45 10             	mov    0x10(%ebp),%eax
   1013c:	8b 00                	mov    (%eax),%eax
   1013e:	d1 e8                	shr    %eax
   10140:	89 c1                	mov    %eax,%ecx
   10142:	8b 45 0c             	mov    0xc(%ebp),%eax
   10145:	8b 00                	mov    (%eax),%eax
   10147:	83 ec 04             	sub    $0x4,%esp
   1014a:	52                   	push   %edx
   1014b:	51                   	push   %ecx
   1014c:	50                   	push   %eax
   1014d:	e8 6a 8e ff ff       	call   8fbc <lodepng_get_raw_size_idat>
   10152:	83 c4 10             	add    $0x10,%esp
   10155:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   10158:	8b 45 14             	mov    0x14(%ebp),%eax
   1015b:	83 ec 08             	sub    $0x8,%esp
   1015e:	50                   	push   %eax
   1015f:	ff 75 ec             	pushl  -0x14(%ebp)
   10162:	ff 75 d8             	pushl  -0x28(%ebp)
   10165:	ff 75 e8             	pushl  -0x18(%ebp)
   10168:	8d 45 c0             	lea    -0x40(%ebp),%eax
   1016b:	50                   	push   %eax
   1016c:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   1016f:	50                   	push   %eax
   10170:	e8 87 7c ff ff       	call   7dfc <zlib_decompress>
   10175:	83 c4 20             	add    $0x20,%esp
   10178:	89 c2                	mov    %eax,%edx
   1017a:	8b 45 14             	mov    0x14(%ebp),%eax
   1017d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   10183:	8b 45 14             	mov    0x14(%ebp),%eax
   10186:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1018c:	85 c0                	test   %eax,%eax
   1018e:	75 15                	jne    101a5 <decodeGeneric+0x9df>
   10190:	8b 45 c0             	mov    -0x40(%ebp),%eax
   10193:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   10196:	74 0d                	je     101a5 <decodeGeneric+0x9df>
   10198:	8b 45 14             	mov    0x14(%ebp),%eax
   1019b:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   101a2:	00 00 00 
  lodepng_free(idat);
   101a5:	83 ec 0c             	sub    $0xc,%esp
   101a8:	ff 75 d8             	pushl  -0x28(%ebp)
   101ab:	e8 b2 31 ff ff       	call   3362 <lodepng_free>
   101b0:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   101b3:	8b 45 14             	mov    0x14(%ebp),%eax
   101b6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   101bc:	85 c0                	test   %eax,%eax
   101be:	75 4f                	jne    1020f <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   101c0:	8b 45 14             	mov    0x14(%ebp),%eax
   101c3:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   101c9:	8b 45 10             	mov    0x10(%ebp),%eax
   101cc:	8b 10                	mov    (%eax),%edx
   101ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   101d1:	8b 00                	mov    (%eax),%eax
   101d3:	83 ec 04             	sub    $0x4,%esp
   101d6:	51                   	push   %ecx
   101d7:	52                   	push   %edx
   101d8:	50                   	push   %eax
   101d9:	e8 be 8d ff ff       	call   8f9c <lodepng_get_raw_size>
   101de:	83 c4 10             	add    $0x10,%esp
   101e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   101e4:	83 ec 0c             	sub    $0xc,%esp
   101e7:	ff 75 e4             	pushl  -0x1c(%ebp)
   101ea:	e8 52 31 ff ff       	call   3341 <lodepng_malloc>
   101ef:	83 c4 10             	add    $0x10,%esp
   101f2:	89 c2                	mov    %eax,%edx
   101f4:	8b 45 08             	mov    0x8(%ebp),%eax
   101f7:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   101f9:	8b 45 08             	mov    0x8(%ebp),%eax
   101fc:	8b 00                	mov    (%eax),%eax
   101fe:	85 c0                	test   %eax,%eax
   10200:	75 0d                	jne    1020f <decodeGeneric+0xa49>
   10202:	8b 45 14             	mov    0x14(%ebp),%eax
   10205:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   1020c:	00 00 00 
  }
  if(!state->error) {
   1020f:	8b 45 14             	mov    0x14(%ebp),%eax
   10212:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10218:	85 c0                	test   %eax,%eax
   1021a:	75 4c                	jne    10268 <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   1021c:	8b 45 08             	mov    0x8(%ebp),%eax
   1021f:	8b 00                	mov    (%eax),%eax
   10221:	83 ec 04             	sub    $0x4,%esp
   10224:	ff 75 e4             	pushl  -0x1c(%ebp)
   10227:	6a 00                	push   $0x0
   10229:	50                   	push   %eax
   1022a:	e8 83 31 ff ff       	call   33b2 <lodepng_memset>
   1022f:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   10232:	8b 45 14             	mov    0x14(%ebp),%eax
   10235:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   1023b:	8b 45 10             	mov    0x10(%ebp),%eax
   1023e:	8b 18                	mov    (%eax),%ebx
   10240:	8b 45 0c             	mov    0xc(%ebp),%eax
   10243:	8b 08                	mov    (%eax),%ecx
   10245:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   10248:	8b 45 08             	mov    0x8(%ebp),%eax
   1024b:	8b 00                	mov    (%eax),%eax
   1024d:	83 ec 0c             	sub    $0xc,%esp
   10250:	56                   	push   %esi
   10251:	53                   	push   %ebx
   10252:	51                   	push   %ecx
   10253:	52                   	push   %edx
   10254:	50                   	push   %eax
   10255:	e8 05 df ff ff       	call   e15f <postProcessScanlines>
   1025a:	83 c4 20             	add    $0x20,%esp
   1025d:	89 c2                	mov    %eax,%edx
   1025f:	8b 45 14             	mov    0x14(%ebp),%eax
   10262:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   10268:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1026b:	83 ec 0c             	sub    $0xc,%esp
   1026e:	50                   	push   %eax
   1026f:	e8 ee 30 ff ff       	call   3362 <lodepng_free>
   10274:	83 c4 10             	add    $0x10,%esp
   10277:	eb 01                	jmp    1027a <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   10279:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   1027a:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1027d:	5b                   	pop    %ebx
   1027e:	5e                   	pop    %esi
   1027f:	5d                   	pop    %ebp
   10280:	c3                   	ret    

00010281 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   10281:	55                   	push   %ebp
   10282:	89 e5                	mov    %esp,%ebp
   10284:	56                   	push   %esi
   10285:	53                   	push   %ebx
   10286:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   10289:	8b 45 08             	mov    0x8(%ebp),%eax
   1028c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   10292:	83 ec 08             	sub    $0x8,%esp
   10295:	ff 75 1c             	pushl  0x1c(%ebp)
   10298:	ff 75 18             	pushl  0x18(%ebp)
   1029b:	ff 75 14             	pushl  0x14(%ebp)
   1029e:	ff 75 10             	pushl  0x10(%ebp)
   102a1:	ff 75 0c             	pushl  0xc(%ebp)
   102a4:	ff 75 08             	pushl  0x8(%ebp)
   102a7:	e8 1a f5 ff ff       	call   f7c6 <decodeGeneric>
   102ac:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   102af:	8b 45 14             	mov    0x14(%ebp),%eax
   102b2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   102b8:	85 c0                	test   %eax,%eax
   102ba:	74 0e                	je     102ca <lodepng_decode+0x49>
   102bc:	8b 45 14             	mov    0x14(%ebp),%eax
   102bf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   102c5:	e9 55 01 00 00       	jmp    1041f <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   102ca:	8b 45 14             	mov    0x14(%ebp),%eax
   102cd:	8b 40 24             	mov    0x24(%eax),%eax
   102d0:	85 c0                	test   %eax,%eax
   102d2:	74 20                	je     102f4 <lodepng_decode+0x73>
   102d4:	8b 45 14             	mov    0x14(%ebp),%eax
   102d7:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   102dd:	8b 45 14             	mov    0x14(%ebp),%eax
   102e0:	83 c0 78             	add    $0x78,%eax
   102e3:	83 ec 08             	sub    $0x8,%esp
   102e6:	52                   	push   %edx
   102e7:	50                   	push   %eax
   102e8:	e8 56 89 ff ff       	call   8c43 <lodepng_color_mode_equal>
   102ed:	83 c4 10             	add    $0x10,%esp
   102f0:	85 c0                	test   %eax,%eax
   102f2:	74 54                	je     10348 <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   102f4:	8b 45 14             	mov    0x14(%ebp),%eax
   102f7:	8b 40 24             	mov    0x24(%eax),%eax
   102fa:	85 c0                	test   %eax,%eax
   102fc:	0f 85 13 01 00 00    	jne    10415 <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   10302:	8b 45 14             	mov    0x14(%ebp),%eax
   10305:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   1030b:	8b 45 14             	mov    0x14(%ebp),%eax
   1030e:	83 c0 78             	add    $0x78,%eax
   10311:	83 ec 08             	sub    $0x8,%esp
   10314:	52                   	push   %edx
   10315:	50                   	push   %eax
   10316:	e8 3f 88 ff ff       	call   8b5a <lodepng_color_mode_copy>
   1031b:	83 c4 10             	add    $0x10,%esp
   1031e:	89 c2                	mov    %eax,%edx
   10320:	8b 45 14             	mov    0x14(%ebp),%eax
   10323:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   10329:	8b 45 14             	mov    0x14(%ebp),%eax
   1032c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10332:	85 c0                	test   %eax,%eax
   10334:	0f 84 db 00 00 00    	je     10415 <lodepng_decode+0x194>
   1033a:	8b 45 14             	mov    0x14(%ebp),%eax
   1033d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10343:	e9 d7 00 00 00       	jmp    1041f <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   10348:	8b 45 08             	mov    0x8(%ebp),%eax
   1034b:	8b 00                	mov    (%eax),%eax
   1034d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   10350:	8b 45 14             	mov    0x14(%ebp),%eax
   10353:	8b 40 78             	mov    0x78(%eax),%eax
   10356:	83 f8 02             	cmp    $0x2,%eax
   10359:	74 20                	je     1037b <lodepng_decode+0xfa>
   1035b:	8b 45 14             	mov    0x14(%ebp),%eax
   1035e:	8b 40 78             	mov    0x78(%eax),%eax
   10361:	83 f8 06             	cmp    $0x6,%eax
   10364:	74 15                	je     1037b <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   10366:	8b 45 14             	mov    0x14(%ebp),%eax
   10369:	8b 40 7c             	mov    0x7c(%eax),%eax
   1036c:	83 f8 08             	cmp    $0x8,%eax
   1036f:	74 0a                	je     1037b <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   10371:	b8 38 00 00 00       	mov    $0x38,%eax
   10376:	e9 a4 00 00 00       	jmp    1041f <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   1037b:	8b 45 14             	mov    0x14(%ebp),%eax
   1037e:	8d 48 78             	lea    0x78(%eax),%ecx
   10381:	8b 45 10             	mov    0x10(%ebp),%eax
   10384:	8b 10                	mov    (%eax),%edx
   10386:	8b 45 0c             	mov    0xc(%ebp),%eax
   10389:	8b 00                	mov    (%eax),%eax
   1038b:	83 ec 04             	sub    $0x4,%esp
   1038e:	51                   	push   %ecx
   1038f:	52                   	push   %edx
   10390:	50                   	push   %eax
   10391:	e8 06 8c ff ff       	call   8f9c <lodepng_get_raw_size>
   10396:	83 c4 10             	add    $0x10,%esp
   10399:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   1039c:	83 ec 0c             	sub    $0xc,%esp
   1039f:	ff 75 f0             	pushl  -0x10(%ebp)
   103a2:	e8 9a 2f ff ff       	call   3341 <lodepng_malloc>
   103a7:	83 c4 10             	add    $0x10,%esp
   103aa:	89 c2                	mov    %eax,%edx
   103ac:	8b 45 08             	mov    0x8(%ebp),%eax
   103af:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   103b1:	8b 45 08             	mov    0x8(%ebp),%eax
   103b4:	8b 00                	mov    (%eax),%eax
   103b6:	85 c0                	test   %eax,%eax
   103b8:	75 0f                	jne    103c9 <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   103ba:	8b 45 14             	mov    0x14(%ebp),%eax
   103bd:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   103c4:	00 00 00 
   103c7:	eb 3c                	jmp    10405 <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   103c9:	8b 45 10             	mov    0x10(%ebp),%eax
   103cc:	8b 08                	mov    (%eax),%ecx
   103ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   103d1:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   103d3:	8b 45 14             	mov    0x14(%ebp),%eax
   103d6:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   103dc:	8b 45 14             	mov    0x14(%ebp),%eax
   103df:	8d 58 78             	lea    0x78(%eax),%ebx
   103e2:	8b 45 08             	mov    0x8(%ebp),%eax
   103e5:	8b 00                	mov    (%eax),%eax
   103e7:	83 ec 08             	sub    $0x8,%esp
   103ea:	51                   	push   %ecx
   103eb:	52                   	push   %edx
   103ec:	56                   	push   %esi
   103ed:	53                   	push   %ebx
   103ee:	ff 75 f4             	pushl  -0xc(%ebp)
   103f1:	50                   	push   %eax
   103f2:	e8 51 b6 ff ff       	call   ba48 <lodepng_convert>
   103f7:	83 c4 20             	add    $0x20,%esp
   103fa:	89 c2                	mov    %eax,%edx
   103fc:	8b 45 14             	mov    0x14(%ebp),%eax
   103ff:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   10405:	83 ec 0c             	sub    $0xc,%esp
   10408:	ff 75 f4             	pushl  -0xc(%ebp)
   1040b:	e8 52 2f ff ff       	call   3362 <lodepng_free>
   10410:	83 c4 10             	add    $0x10,%esp
   10413:	eb 01                	jmp    10416 <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   10415:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   10416:	8b 45 14             	mov    0x14(%ebp),%eax
   10419:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   1041f:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10422:	5b                   	pop    %ebx
   10423:	5e                   	pop    %esi
   10424:	5d                   	pop    %ebp
   10425:	c3                   	ret    

00010426 <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   10426:	55                   	push   %ebp
   10427:	89 e5                	mov    %esp,%ebp
   10429:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   1042f:	83 ec 0c             	sub    $0xc,%esp
   10432:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10438:	50                   	push   %eax
   10439:	e8 d9 01 00 00       	call   10617 <lodepng_state_init>
   1043e:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   10441:	8b 45 1c             	mov    0x1c(%ebp),%eax
   10444:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   1044a:	8b 45 20             	mov    0x20(%ebp),%eax
   1044d:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   10453:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   1045a:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   1045d:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   10464:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   10467:	83 ec 08             	sub    $0x8,%esp
   1046a:	ff 75 18             	pushl  0x18(%ebp)
   1046d:	ff 75 14             	pushl  0x14(%ebp)
   10470:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10476:	50                   	push   %eax
   10477:	ff 75 10             	pushl  0x10(%ebp)
   1047a:	ff 75 0c             	pushl  0xc(%ebp)
   1047d:	ff 75 08             	pushl  0x8(%ebp)
   10480:	e8 fc fd ff ff       	call   10281 <lodepng_decode>
   10485:	83 c4 20             	add    $0x20,%esp
   10488:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   1048b:	83 ec 0c             	sub    $0xc,%esp
   1048e:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10494:	50                   	push   %eax
   10495:	e8 d7 01 00 00       	call   10671 <lodepng_state_cleanup>
   1049a:	83 c4 10             	add    $0x10,%esp
  return error;
   1049d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   104a0:	c9                   	leave  
   104a1:	c3                   	ret    

000104a2 <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   104a2:	55                   	push   %ebp
   104a3:	89 e5                	mov    %esp,%ebp
   104a5:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   104a8:	83 ec 04             	sub    $0x4,%esp
   104ab:	6a 08                	push   $0x8
   104ad:	6a 06                	push   $0x6
   104af:	ff 75 18             	pushl  0x18(%ebp)
   104b2:	ff 75 14             	pushl  0x14(%ebp)
   104b5:	ff 75 10             	pushl  0x10(%ebp)
   104b8:	ff 75 0c             	pushl  0xc(%ebp)
   104bb:	ff 75 08             	pushl  0x8(%ebp)
   104be:	e8 63 ff ff ff       	call   10426 <lodepng_decode_memory>
   104c3:	83 c4 20             	add    $0x20,%esp
}
   104c6:	c9                   	leave  
   104c7:	c3                   	ret    

000104c8 <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   104c8:	55                   	push   %ebp
   104c9:	89 e5                	mov    %esp,%ebp
   104cb:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   104ce:	83 ec 04             	sub    $0x4,%esp
   104d1:	6a 08                	push   $0x8
   104d3:	6a 02                	push   $0x2
   104d5:	ff 75 18             	pushl  0x18(%ebp)
   104d8:	ff 75 14             	pushl  0x14(%ebp)
   104db:	ff 75 10             	pushl  0x10(%ebp)
   104de:	ff 75 0c             	pushl  0xc(%ebp)
   104e1:	ff 75 08             	pushl  0x8(%ebp)
   104e4:	e8 3d ff ff ff       	call   10426 <lodepng_decode_memory>
   104e9:	83 c4 20             	add    $0x20,%esp
}
   104ec:	c9                   	leave  
   104ed:	c3                   	ret    

000104ee <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   104ee:	55                   	push   %ebp
   104ef:	89 e5                	mov    %esp,%ebp
   104f1:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   104f4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   104fb:	8b 45 08             	mov    0x8(%ebp),%eax
   104fe:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   10504:	8b 45 10             	mov    0x10(%ebp),%eax
   10507:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1050d:	8b 45 10             	mov    0x10(%ebp),%eax
   10510:	8b 10                	mov    (%eax),%edx
   10512:	8b 45 0c             	mov    0xc(%ebp),%eax
   10515:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   10517:	83 ec 04             	sub    $0x4,%esp
   1051a:	ff 75 14             	pushl  0x14(%ebp)
   1051d:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10520:	50                   	push   %eax
   10521:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10524:	50                   	push   %eax
   10525:	e8 70 32 ff ff       	call   379a <lodepng_load_file>
   1052a:	83 c4 10             	add    $0x10,%esp
   1052d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   10530:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10534:	75 25                	jne    1055b <lodepng_decode_file+0x6d>
   10536:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10539:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1053c:	83 ec 04             	sub    $0x4,%esp
   1053f:	ff 75 1c             	pushl  0x1c(%ebp)
   10542:	ff 75 18             	pushl  0x18(%ebp)
   10545:	52                   	push   %edx
   10546:	50                   	push   %eax
   10547:	ff 75 10             	pushl  0x10(%ebp)
   1054a:	ff 75 0c             	pushl  0xc(%ebp)
   1054d:	ff 75 08             	pushl  0x8(%ebp)
   10550:	e8 d1 fe ff ff       	call   10426 <lodepng_decode_memory>
   10555:	83 c4 20             	add    $0x20,%esp
   10558:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   1055b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1055e:	83 ec 0c             	sub    $0xc,%esp
   10561:	50                   	push   %eax
   10562:	e8 fb 2d ff ff       	call   3362 <lodepng_free>
   10567:	83 c4 10             	add    $0x10,%esp
  return error;
   1056a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1056d:	c9                   	leave  
   1056e:	c3                   	ret    

0001056f <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   1056f:	55                   	push   %ebp
   10570:	89 e5                	mov    %esp,%ebp
   10572:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   10575:	83 ec 08             	sub    $0x8,%esp
   10578:	6a 08                	push   $0x8
   1057a:	6a 06                	push   $0x6
   1057c:	ff 75 14             	pushl  0x14(%ebp)
   1057f:	ff 75 10             	pushl  0x10(%ebp)
   10582:	ff 75 0c             	pushl  0xc(%ebp)
   10585:	ff 75 08             	pushl  0x8(%ebp)
   10588:	e8 61 ff ff ff       	call   104ee <lodepng_decode_file>
   1058d:	83 c4 20             	add    $0x20,%esp
}
   10590:	c9                   	leave  
   10591:	c3                   	ret    

00010592 <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10592:	55                   	push   %ebp
   10593:	89 e5                	mov    %esp,%ebp
   10595:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   10598:	83 ec 08             	sub    $0x8,%esp
   1059b:	6a 08                	push   $0x8
   1059d:	6a 02                	push   $0x2
   1059f:	ff 75 14             	pushl  0x14(%ebp)
   105a2:	ff 75 10             	pushl  0x10(%ebp)
   105a5:	ff 75 0c             	pushl  0xc(%ebp)
   105a8:	ff 75 08             	pushl  0x8(%ebp)
   105ab:	e8 3e ff ff ff       	call   104ee <lodepng_decode_file>
   105b0:	83 c4 20             	add    $0x20,%esp
}
   105b3:	c9                   	leave  
   105b4:	c3                   	ret    

000105b5 <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   105b5:	55                   	push   %ebp
   105b6:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   105b8:	8b 45 08             	mov    0x8(%ebp),%eax
   105bb:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   105c2:	8b 45 08             	mov    0x8(%ebp),%eax
   105c5:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   105cc:	8b 45 08             	mov    0x8(%ebp),%eax
   105cf:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   105d6:	8b 45 08             	mov    0x8(%ebp),%eax
   105d9:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   105e0:	8b 45 08             	mov    0x8(%ebp),%eax
   105e3:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   105ea:	8b 45 08             	mov    0x8(%ebp),%eax
   105ed:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   105f4:	8b 45 08             	mov    0x8(%ebp),%eax
   105f7:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   105fe:	8b 45 08             	mov    0x8(%ebp),%eax
   10601:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   10608:	8b 45 08             	mov    0x8(%ebp),%eax
   1060b:	50                   	push   %eax
   1060c:	e8 ff 7a ff ff       	call   8110 <lodepng_decompress_settings_init>
   10611:	83 c4 04             	add    $0x4,%esp
}
   10614:	90                   	nop
   10615:	c9                   	leave  
   10616:	c3                   	ret    

00010617 <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   10617:	55                   	push   %ebp
   10618:	89 e5                	mov    %esp,%ebp
   1061a:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   1061d:	8b 45 08             	mov    0x8(%ebp),%eax
   10620:	50                   	push   %eax
   10621:	e8 8f ff ff ff       	call   105b5 <lodepng_decoder_settings_init>
   10626:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   10629:	8b 45 08             	mov    0x8(%ebp),%eax
   1062c:	83 c0 38             	add    $0x38,%eax
   1062f:	83 ec 0c             	sub    $0xc,%esp
   10632:	50                   	push   %eax
   10633:	e8 fc 30 00 00       	call   13734 <lodepng_encoder_settings_init>
   10638:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   1063b:	8b 45 08             	mov    0x8(%ebp),%eax
   1063e:	83 c0 78             	add    $0x78,%eax
   10641:	83 ec 0c             	sub    $0xc,%esp
   10644:	50                   	push   %eax
   10645:	e8 06 84 ff ff       	call   8a50 <lodepng_color_mode_init>
   1064a:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   1064d:	8b 45 08             	mov    0x8(%ebp),%eax
   10650:	05 98 00 00 00       	add    $0x98,%eax
   10655:	83 ec 0c             	sub    $0xc,%esp
   10658:	50                   	push   %eax
   10659:	e8 89 93 ff ff       	call   99e7 <lodepng_info_init>
   1065e:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   10661:	8b 45 08             	mov    0x8(%ebp),%eax
   10664:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   1066b:	00 00 00 
}
   1066e:	90                   	nop
   1066f:	c9                   	leave  
   10670:	c3                   	ret    

00010671 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   10671:	55                   	push   %ebp
   10672:	89 e5                	mov    %esp,%ebp
   10674:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   10677:	8b 45 08             	mov    0x8(%ebp),%eax
   1067a:	83 c0 78             	add    $0x78,%eax
   1067d:	83 ec 0c             	sub    $0xc,%esp
   10680:	50                   	push   %eax
   10681:	e8 bd 84 ff ff       	call   8b43 <lodepng_color_mode_cleanup>
   10686:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   10689:	8b 45 08             	mov    0x8(%ebp),%eax
   1068c:	05 98 00 00 00       	add    $0x98,%eax
   10691:	83 ec 0c             	sub    $0xc,%esp
   10694:	50                   	push   %eax
   10695:	e8 2e 94 ff ff       	call   9ac8 <lodepng_info_cleanup>
   1069a:	83 c4 10             	add    $0x10,%esp
}
   1069d:	90                   	nop
   1069e:	c9                   	leave  
   1069f:	c3                   	ret    

000106a0 <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   106a0:	55                   	push   %ebp
   106a1:	89 e5                	mov    %esp,%ebp
   106a3:	57                   	push   %edi
   106a4:	56                   	push   %esi
   106a5:	53                   	push   %ebx
   106a6:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   106a9:	83 ec 0c             	sub    $0xc,%esp
   106ac:	ff 75 08             	pushl  0x8(%ebp)
   106af:	e8 bd ff ff ff       	call   10671 <lodepng_state_cleanup>
   106b4:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   106b7:	8b 55 08             	mov    0x8(%ebp),%edx
   106ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   106bd:	89 c3                	mov    %eax,%ebx
   106bf:	b8 60 00 00 00       	mov    $0x60,%eax
   106c4:	89 d7                	mov    %edx,%edi
   106c6:	89 de                	mov    %ebx,%esi
   106c8:	89 c1                	mov    %eax,%ecx
   106ca:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   106cc:	8b 45 08             	mov    0x8(%ebp),%eax
   106cf:	83 c0 78             	add    $0x78,%eax
   106d2:	83 ec 0c             	sub    $0xc,%esp
   106d5:	50                   	push   %eax
   106d6:	e8 75 83 ff ff       	call   8a50 <lodepng_color_mode_init>
   106db:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   106de:	8b 45 08             	mov    0x8(%ebp),%eax
   106e1:	05 98 00 00 00       	add    $0x98,%eax
   106e6:	83 ec 0c             	sub    $0xc,%esp
   106e9:	50                   	push   %eax
   106ea:	e8 f8 92 ff ff       	call   99e7 <lodepng_info_init>
   106ef:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   106f2:	8b 45 0c             	mov    0xc(%ebp),%eax
   106f5:	8d 50 78             	lea    0x78(%eax),%edx
   106f8:	8b 45 08             	mov    0x8(%ebp),%eax
   106fb:	83 c0 78             	add    $0x78,%eax
   106fe:	83 ec 08             	sub    $0x8,%esp
   10701:	52                   	push   %edx
   10702:	50                   	push   %eax
   10703:	e8 52 84 ff ff       	call   8b5a <lodepng_color_mode_copy>
   10708:	83 c4 10             	add    $0x10,%esp
   1070b:	89 c2                	mov    %eax,%edx
   1070d:	8b 45 08             	mov    0x8(%ebp),%eax
   10710:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10716:	8b 45 08             	mov    0x8(%ebp),%eax
   10719:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1071f:	85 c0                	test   %eax,%eax
   10721:	75 36                	jne    10759 <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   10723:	8b 45 0c             	mov    0xc(%ebp),%eax
   10726:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   1072c:	8b 45 08             	mov    0x8(%ebp),%eax
   1072f:	05 98 00 00 00       	add    $0x98,%eax
   10734:	83 ec 08             	sub    $0x8,%esp
   10737:	52                   	push   %edx
   10738:	50                   	push   %eax
   10739:	e8 dd 93 ff ff       	call   9b1b <lodepng_info_copy>
   1073e:	83 c4 10             	add    $0x10,%esp
   10741:	89 c2                	mov    %eax,%edx
   10743:	8b 45 08             	mov    0x8(%ebp),%eax
   10746:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   1074c:	8b 45 08             	mov    0x8(%ebp),%eax
   1074f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10755:	85 c0                	test   %eax,%eax
   10757:	eb 01                	jmp    1075a <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   10759:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   1075a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1075d:	5b                   	pop    %ebx
   1075e:	5e                   	pop    %esi
   1075f:	5f                   	pop    %edi
   10760:	5d                   	pop    %ebp
   10761:	c3                   	ret    

00010762 <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   10762:	55                   	push   %ebp
   10763:	89 e5                	mov    %esp,%ebp
   10765:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   10768:	8b 45 08             	mov    0x8(%ebp),%eax
   1076b:	8b 40 04             	mov    0x4(%eax),%eax
   1076e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   10771:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   10775:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   10779:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   1077d:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   10781:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   10785:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   10789:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   1078d:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   10791:	8b 45 08             	mov    0x8(%ebp),%eax
   10794:	8b 40 04             	mov    0x4(%eax),%eax
   10797:	83 c0 08             	add    $0x8,%eax
   1079a:	50                   	push   %eax
   1079b:	ff 75 08             	pushl  0x8(%ebp)
   1079e:	e8 f8 2d ff ff       	call   359b <ucvector_resize>
   107a3:	83 c4 08             	add    $0x8,%esp
   107a6:	85 c0                	test   %eax,%eax
   107a8:	75 07                	jne    107b1 <writeSignature+0x4f>
   107aa:	b8 53 00 00 00       	mov    $0x53,%eax
   107af:	eb 1e                	jmp    107cf <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   107b1:	8b 45 08             	mov    0x8(%ebp),%eax
   107b4:	8b 10                	mov    (%eax),%edx
   107b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   107b9:	01 c2                	add    %eax,%edx
   107bb:	6a 08                	push   $0x8
   107bd:	8d 45 f4             	lea    -0xc(%ebp),%eax
   107c0:	50                   	push   %eax
   107c1:	52                   	push   %edx
   107c2:	e8 b8 2b ff ff       	call   337f <lodepng_memcpy>
   107c7:	83 c4 0c             	add    $0xc,%esp
  return 0;
   107ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
   107cf:	c9                   	leave  
   107d0:	c3                   	ret    

000107d1 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   107d1:	55                   	push   %ebp
   107d2:	89 e5                	mov    %esp,%ebp
   107d4:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   107d7:	68 6c a0 01 00       	push   $0x1a06c
   107dc:	6a 0d                	push   $0xd
   107de:	ff 75 08             	pushl  0x8(%ebp)
   107e1:	8d 45 f4             	lea    -0xc(%ebp),%eax
   107e4:	50                   	push   %eax
   107e5:	e8 cf 7f ff ff       	call   87b9 <lodepng_chunk_init>
   107ea:	83 c4 10             	add    $0x10,%esp
   107ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
   107f0:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   107f4:	74 05                	je     107fb <addChunk_IHDR+0x2a>
   107f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   107f9:	eb 6d                	jmp    10868 <addChunk_IHDR+0x97>
  data = chunk + 8;
   107fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   107fe:	83 c0 08             	add    $0x8,%eax
   10801:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   10804:	ff 75 0c             	pushl  0xc(%ebp)
   10807:	ff 75 f8             	pushl  -0x8(%ebp)
   1080a:	e8 f3 2e ff ff       	call   3702 <lodepng_set32bitInt>
   1080f:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   10812:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10815:	83 c0 04             	add    $0x4,%eax
   10818:	ff 75 10             	pushl  0x10(%ebp)
   1081b:	50                   	push   %eax
   1081c:	e8 e1 2e ff ff       	call   3702 <lodepng_set32bitInt>
   10821:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   10824:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10827:	83 c0 08             	add    $0x8,%eax
   1082a:	8b 55 18             	mov    0x18(%ebp),%edx
   1082d:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   1082f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10832:	83 c0 09             	add    $0x9,%eax
   10835:	8b 55 14             	mov    0x14(%ebp),%edx
   10838:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   1083a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1083d:	83 c0 0a             	add    $0xa,%eax
   10840:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   10843:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10846:	83 c0 0b             	add    $0xb,%eax
   10849:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   1084c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1084f:	83 c0 0c             	add    $0xc,%eax
   10852:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10855:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   10857:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1085a:	50                   	push   %eax
   1085b:	e8 02 7c ff ff       	call   8462 <lodepng_chunk_generate_crc>
   10860:	83 c4 04             	add    $0x4,%esp
  return 0;
   10863:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10868:	c9                   	leave  
   10869:	c3                   	ret    

0001086a <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   1086a:	55                   	push   %ebp
   1086b:	89 e5                	mov    %esp,%ebp
   1086d:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   10870:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   10877:	8b 45 0c             	mov    0xc(%ebp),%eax
   1087a:	8b 50 0c             	mov    0xc(%eax),%edx
   1087d:	89 d0                	mov    %edx,%eax
   1087f:	01 c0                	add    %eax,%eax
   10881:	01 d0                	add    %edx,%eax
   10883:	68 88 a0 01 00       	push   $0x1a088
   10888:	50                   	push   %eax
   10889:	ff 75 08             	pushl  0x8(%ebp)
   1088c:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1088f:	50                   	push   %eax
   10890:	e8 24 7f ff ff       	call   87b9 <lodepng_chunk_init>
   10895:	83 c4 10             	add    $0x10,%esp
   10898:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1089b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1089f:	74 08                	je     108a9 <addChunk_PLTE+0x3f>
   108a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   108a4:	e9 95 00 00 00       	jmp    1093e <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   108a9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   108b0:	eb 70                	jmp    10922 <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   108b2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   108b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108b8:	8d 50 01             	lea    0x1(%eax),%edx
   108bb:	89 55 f8             	mov    %edx,-0x8(%ebp)
   108be:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   108c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   108c4:	8b 40 08             	mov    0x8(%eax),%eax
   108c7:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   108ca:	c1 e1 02             	shl    $0x2,%ecx
   108cd:	01 c8                	add    %ecx,%eax
   108cf:	0f b6 00             	movzbl (%eax),%eax
   108d2:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   108d4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   108d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108da:	8d 50 01             	lea    0x1(%eax),%edx
   108dd:	89 55 f8             	mov    %edx,-0x8(%ebp)
   108e0:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   108e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   108e6:	8b 40 08             	mov    0x8(%eax),%eax
   108e9:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   108ec:	c1 e1 02             	shl    $0x2,%ecx
   108ef:	83 c1 01             	add    $0x1,%ecx
   108f2:	01 c8                	add    %ecx,%eax
   108f4:	0f b6 00             	movzbl (%eax),%eax
   108f7:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   108f9:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   108fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108ff:	8d 50 01             	lea    0x1(%eax),%edx
   10902:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10905:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10908:	8b 45 0c             	mov    0xc(%ebp),%eax
   1090b:	8b 40 08             	mov    0x8(%eax),%eax
   1090e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10911:	c1 e1 02             	shl    $0x2,%ecx
   10914:	83 c1 02             	add    $0x2,%ecx
   10917:	01 c8                	add    %ecx,%eax
   10919:	0f b6 00             	movzbl (%eax),%eax
   1091c:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   1091e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10922:	8b 45 0c             	mov    0xc(%ebp),%eax
   10925:	8b 40 0c             	mov    0xc(%eax),%eax
   10928:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   1092b:	75 85                	jne    108b2 <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   1092d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10930:	50                   	push   %eax
   10931:	e8 2c 7b ff ff       	call   8462 <lodepng_chunk_generate_crc>
   10936:	83 c4 04             	add    $0x4,%esp
  return 0;
   10939:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1093e:	c9                   	leave  
   1093f:	c3                   	ret    

00010940 <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   10940:	55                   	push   %ebp
   10941:	89 e5                	mov    %esp,%ebp
   10943:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10946:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   1094d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10950:	8b 00                	mov    (%eax),%eax
   10952:	83 f8 03             	cmp    $0x3,%eax
   10955:	0f 85 ae 00 00 00    	jne    10a09 <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   1095b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1095e:	8b 40 0c             	mov    0xc(%eax),%eax
   10961:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10964:	8b 45 0c             	mov    0xc(%ebp),%eax
   10967:	8b 40 0c             	mov    0xc(%eax),%eax
   1096a:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1096d:	eb 23                	jmp    10992 <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   1096f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10972:	8b 40 08             	mov    0x8(%eax),%eax
   10975:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10978:	83 ea 01             	sub    $0x1,%edx
   1097b:	c1 e2 02             	shl    $0x2,%edx
   1097e:	83 c2 03             	add    $0x3,%edx
   10981:	01 d0                	add    %edx,%eax
   10983:	0f b6 00             	movzbl (%eax),%eax
   10986:	3c ff                	cmp    $0xff,%al
   10988:	75 10                	jne    1099a <addChunk_tRNS+0x5a>
      --amount;
   1098a:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   1098e:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   10992:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10996:	75 d7                	jne    1096f <addChunk_tRNS+0x2f>
   10998:	eb 01                	jmp    1099b <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   1099a:	90                   	nop
      --amount;
    }
    if(amount) {
   1099b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   1099f:	0f 84 63 01 00 00    	je     10b08 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   109a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
   109a8:	68 8d a0 01 00       	push   $0x1a08d
   109ad:	50                   	push   %eax
   109ae:	ff 75 08             	pushl  0x8(%ebp)
   109b1:	8d 45 e8             	lea    -0x18(%ebp),%eax
   109b4:	50                   	push   %eax
   109b5:	e8 ff 7d ff ff       	call   87b9 <lodepng_chunk_init>
   109ba:	83 c4 10             	add    $0x10,%esp
   109bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
   109c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   109c4:	74 08                	je     109ce <addChunk_tRNS+0x8e>
   109c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   109c9:	e9 52 01 00 00       	jmp    10b20 <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   109ce:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   109d5:	eb 25                	jmp    109fc <addChunk_tRNS+0xbc>
   109d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   109da:	8b 55 fc             	mov    -0x4(%ebp),%edx
   109dd:	83 c2 08             	add    $0x8,%edx
   109e0:	01 c2                	add    %eax,%edx
   109e2:	8b 45 0c             	mov    0xc(%ebp),%eax
   109e5:	8b 40 08             	mov    0x8(%eax),%eax
   109e8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   109eb:	c1 e1 02             	shl    $0x2,%ecx
   109ee:	83 c1 03             	add    $0x3,%ecx
   109f1:	01 c8                	add    %ecx,%eax
   109f3:	0f b6 00             	movzbl (%eax),%eax
   109f6:	88 02                	mov    %al,(%edx)
   109f8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   109fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
   109ff:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   10a02:	75 d3                	jne    109d7 <addChunk_tRNS+0x97>
   10a04:	e9 ff 00 00 00       	jmp    10b08 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   10a09:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a0c:	8b 00                	mov    (%eax),%eax
   10a0e:	85 c0                	test   %eax,%eax
   10a10:	75 59                	jne    10a6b <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   10a12:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a15:	8b 40 10             	mov    0x10(%eax),%eax
   10a18:	85 c0                	test   %eax,%eax
   10a1a:	0f 84 e8 00 00 00    	je     10b08 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   10a20:	68 8d a0 01 00       	push   $0x1a08d
   10a25:	6a 02                	push   $0x2
   10a27:	ff 75 08             	pushl  0x8(%ebp)
   10a2a:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10a2d:	50                   	push   %eax
   10a2e:	e8 86 7d ff ff       	call   87b9 <lodepng_chunk_init>
   10a33:	83 c4 10             	add    $0x10,%esp
   10a36:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10a39:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10a3d:	74 08                	je     10a47 <addChunk_tRNS+0x107>
   10a3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a42:	e9 d9 00 00 00       	jmp    10b20 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10a47:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a4a:	8d 50 08             	lea    0x8(%eax),%edx
   10a4d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a50:	8b 40 14             	mov    0x14(%eax),%eax
   10a53:	c1 e8 08             	shr    $0x8,%eax
   10a56:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10a58:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a5b:	8d 50 09             	lea    0x9(%eax),%edx
   10a5e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a61:	8b 40 14             	mov    0x14(%eax),%eax
   10a64:	88 02                	mov    %al,(%edx)
   10a66:	e9 9d 00 00 00       	jmp    10b08 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   10a6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a6e:	8b 00                	mov    (%eax),%eax
   10a70:	83 f8 02             	cmp    $0x2,%eax
   10a73:	0f 85 8f 00 00 00    	jne    10b08 <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   10a79:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a7c:	8b 40 10             	mov    0x10(%eax),%eax
   10a7f:	85 c0                	test   %eax,%eax
   10a81:	0f 84 81 00 00 00    	je     10b08 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   10a87:	68 8d a0 01 00       	push   $0x1a08d
   10a8c:	6a 06                	push   $0x6
   10a8e:	ff 75 08             	pushl  0x8(%ebp)
   10a91:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10a94:	50                   	push   %eax
   10a95:	e8 1f 7d ff ff       	call   87b9 <lodepng_chunk_init>
   10a9a:	83 c4 10             	add    $0x10,%esp
   10a9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10aa0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10aa4:	74 05                	je     10aab <addChunk_tRNS+0x16b>
   10aa6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10aa9:	eb 75                	jmp    10b20 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10aab:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10aae:	8d 50 08             	lea    0x8(%eax),%edx
   10ab1:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ab4:	8b 40 14             	mov    0x14(%eax),%eax
   10ab7:	c1 e8 08             	shr    $0x8,%eax
   10aba:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10abc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10abf:	8d 50 09             	lea    0x9(%eax),%edx
   10ac2:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ac5:	8b 40 14             	mov    0x14(%eax),%eax
   10ac8:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   10aca:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10acd:	8d 50 0a             	lea    0xa(%eax),%edx
   10ad0:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ad3:	8b 40 18             	mov    0x18(%eax),%eax
   10ad6:	c1 e8 08             	shr    $0x8,%eax
   10ad9:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   10adb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ade:	8d 50 0b             	lea    0xb(%eax),%edx
   10ae1:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ae4:	8b 40 18             	mov    0x18(%eax),%eax
   10ae7:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   10ae9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10aec:	8d 50 0c             	lea    0xc(%eax),%edx
   10aef:	8b 45 0c             	mov    0xc(%ebp),%eax
   10af2:	8b 40 1c             	mov    0x1c(%eax),%eax
   10af5:	c1 e8 08             	shr    $0x8,%eax
   10af8:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   10afa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10afd:	8d 50 0d             	lea    0xd(%eax),%edx
   10b00:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b03:	8b 40 1c             	mov    0x1c(%eax),%eax
   10b06:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   10b08:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b0b:	85 c0                	test   %eax,%eax
   10b0d:	74 0c                	je     10b1b <addChunk_tRNS+0x1db>
   10b0f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b12:	50                   	push   %eax
   10b13:	e8 4a 79 ff ff       	call   8462 <lodepng_chunk_generate_crc>
   10b18:	83 c4 04             	add    $0x4,%esp
  return 0;
   10b1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10b20:	c9                   	leave  
   10b21:	c3                   	ret    

00010b22 <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   10b22:	55                   	push   %ebp
   10b23:	89 e5                	mov    %esp,%ebp
   10b25:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   10b28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   10b2f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   10b36:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   10b3d:	83 ec 0c             	sub    $0xc,%esp
   10b40:	ff 75 14             	pushl  0x14(%ebp)
   10b43:	ff 75 10             	pushl  0x10(%ebp)
   10b46:	ff 75 0c             	pushl  0xc(%ebp)
   10b49:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10b4c:	50                   	push   %eax
   10b4d:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10b50:	50                   	push   %eax
   10b51:	e8 fb 74 ff ff       	call   8051 <zlib_compress>
   10b56:	83 c4 20             	add    $0x20,%esp
   10b59:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   10b5c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10b60:	75 1b                	jne    10b7d <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   10b62:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b65:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10b68:	50                   	push   %eax
   10b69:	68 c4 a0 01 00       	push   $0x1a0c4
   10b6e:	52                   	push   %edx
   10b6f:	ff 75 08             	pushl  0x8(%ebp)
   10b72:	e8 ea 7c ff ff       	call   8861 <lodepng_chunk_createv>
   10b77:	83 c4 10             	add    $0x10,%esp
   10b7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   10b7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b80:	83 ec 0c             	sub    $0xc,%esp
   10b83:	50                   	push   %eax
   10b84:	e8 d9 27 ff ff       	call   3362 <lodepng_free>
   10b89:	83 c4 10             	add    $0x10,%esp
  return error;
   10b8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10b8f:	c9                   	leave  
   10b90:	c3                   	ret    

00010b91 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   10b91:	55                   	push   %ebp
   10b92:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   10b94:	6a 00                	push   $0x0
   10b96:	68 c9 a0 01 00       	push   $0x1a0c9
   10b9b:	6a 00                	push   $0x0
   10b9d:	ff 75 08             	pushl  0x8(%ebp)
   10ba0:	e8 bc 7c ff ff       	call   8861 <lodepng_chunk_createv>
   10ba5:	83 c4 10             	add    $0x10,%esp
}
   10ba8:	c9                   	leave  
   10ba9:	c3                   	ret    

00010baa <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   10baa:	55                   	push   %ebp
   10bab:	89 e5                	mov    %esp,%ebp
   10bad:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10bb0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   10bb7:	ff 75 0c             	pushl  0xc(%ebp)
   10bba:	e8 1e 28 ff ff       	call   33dd <lodepng_strlen>
   10bbf:	83 c4 04             	add    $0x4,%esp
   10bc2:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10bc5:	ff 75 10             	pushl  0x10(%ebp)
   10bc8:	e8 10 28 ff ff       	call   33dd <lodepng_strlen>
   10bcd:	83 c4 04             	add    $0x4,%esp
   10bd0:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   10bd3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10bd6:	8d 50 01             	lea    0x1(%eax),%edx
   10bd9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10bdc:	01 d0                	add    %edx,%eax
   10bde:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10be1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10be5:	7e 06                	jle    10bed <addChunk_tEXt+0x43>
   10be7:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   10beb:	7e 07                	jle    10bf4 <addChunk_tEXt+0x4a>
   10bed:	b8 59 00 00 00       	mov    $0x59,%eax
   10bf2:	eb 74                	jmp    10c68 <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   10bf4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10bf7:	68 97 a0 01 00       	push   $0x1a097
   10bfc:	50                   	push   %eax
   10bfd:	ff 75 08             	pushl  0x8(%ebp)
   10c00:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10c03:	50                   	push   %eax
   10c04:	e8 b0 7b ff ff       	call   87b9 <lodepng_chunk_init>
   10c09:	83 c4 10             	add    $0x10,%esp
   10c0c:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10c0f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10c13:	74 05                	je     10c1a <addChunk_tEXt+0x70>
   10c15:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10c18:	eb 4e                	jmp    10c68 <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   10c1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c1d:	83 c0 08             	add    $0x8,%eax
   10c20:	ff 75 fc             	pushl  -0x4(%ebp)
   10c23:	ff 75 0c             	pushl  0xc(%ebp)
   10c26:	50                   	push   %eax
   10c27:	e8 53 27 ff ff       	call   337f <lodepng_memcpy>
   10c2c:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   10c2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c32:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10c35:	83 c2 08             	add    $0x8,%edx
   10c38:	01 d0                	add    %edx,%eax
   10c3a:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   10c3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c40:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10c43:	83 c2 09             	add    $0x9,%edx
   10c46:	01 d0                	add    %edx,%eax
   10c48:	ff 75 f8             	pushl  -0x8(%ebp)
   10c4b:	ff 75 10             	pushl  0x10(%ebp)
   10c4e:	50                   	push   %eax
   10c4f:	e8 2b 27 ff ff       	call   337f <lodepng_memcpy>
   10c54:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   10c57:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c5a:	50                   	push   %eax
   10c5b:	e8 02 78 ff ff       	call   8462 <lodepng_chunk_generate_crc>
   10c60:	83 c4 04             	add    $0x4,%esp
  return 0;
   10c63:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10c68:	c9                   	leave  
   10c69:	c3                   	ret    

00010c6a <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   10c6a:	55                   	push   %ebp
   10c6b:	89 e5                	mov    %esp,%ebp
   10c6d:	53                   	push   %ebx
   10c6e:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   10c71:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10c78:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   10c7f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   10c86:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10c8d:	ff 75 10             	pushl  0x10(%ebp)
   10c90:	e8 48 27 ff ff       	call   33dd <lodepng_strlen>
   10c95:	83 c4 04             	add    $0x4,%esp
   10c98:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   10c9b:	ff 75 0c             	pushl  0xc(%ebp)
   10c9e:	e8 3a 27 ff ff       	call   33dd <lodepng_strlen>
   10ca3:	83 c4 04             	add    $0x4,%esp
   10ca6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10ca9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10cad:	7e 06                	jle    10cb5 <addChunk_zTXt+0x4b>
   10caf:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10cb3:	7e 0a                	jle    10cbf <addChunk_zTXt+0x55>
   10cb5:	b8 59 00 00 00       	mov    $0x59,%eax
   10cba:	e9 c8 00 00 00       	jmp    10d87 <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   10cbf:	83 ec 0c             	sub    $0xc,%esp
   10cc2:	ff 75 14             	pushl  0x14(%ebp)
   10cc5:	ff 75 f0             	pushl  -0x10(%ebp)
   10cc8:	ff 75 10             	pushl  0x10(%ebp)
   10ccb:	8d 45 dc             	lea    -0x24(%ebp),%eax
   10cce:	50                   	push   %eax
   10ccf:	8d 45 e0             	lea    -0x20(%ebp),%eax
   10cd2:	50                   	push   %eax
   10cd3:	e8 79 73 ff ff       	call   8051 <zlib_compress>
   10cd8:	83 c4 20             	add    $0x20,%esp
   10cdb:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   10cde:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10ce2:	75 29                	jne    10d0d <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   10ce4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ce7:	8d 50 02             	lea    0x2(%eax),%edx
   10cea:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ced:	01 d0                	add    %edx,%eax
   10cef:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   10cf2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10cf5:	68 9c a0 01 00       	push   $0x1a09c
   10cfa:	50                   	push   %eax
   10cfb:	ff 75 08             	pushl  0x8(%ebp)
   10cfe:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   10d01:	50                   	push   %eax
   10d02:	e8 b2 7a ff ff       	call   87b9 <lodepng_chunk_init>
   10d07:	83 c4 10             	add    $0x10,%esp
   10d0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10d0d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10d11:	75 62                	jne    10d75 <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   10d13:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d16:	83 c0 08             	add    $0x8,%eax
   10d19:	83 ec 04             	sub    $0x4,%esp
   10d1c:	ff 75 ec             	pushl  -0x14(%ebp)
   10d1f:	ff 75 0c             	pushl  0xc(%ebp)
   10d22:	50                   	push   %eax
   10d23:	e8 57 26 ff ff       	call   337f <lodepng_memcpy>
   10d28:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   10d2b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d2e:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10d31:	83 c2 08             	add    $0x8,%edx
   10d34:	01 d0                	add    %edx,%eax
   10d36:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   10d39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d3c:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10d3f:	83 c2 09             	add    $0x9,%edx
   10d42:	01 d0                	add    %edx,%eax
   10d44:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   10d47:	8b 55 dc             	mov    -0x24(%ebp),%edx
   10d4a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10d4d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10d50:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   10d53:	83 c3 0a             	add    $0xa,%ebx
   10d56:	01 d9                	add    %ebx,%ecx
   10d58:	83 ec 04             	sub    $0x4,%esp
   10d5b:	52                   	push   %edx
   10d5c:	50                   	push   %eax
   10d5d:	51                   	push   %ecx
   10d5e:	e8 1c 26 ff ff       	call   337f <lodepng_memcpy>
   10d63:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   10d66:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d69:	83 ec 0c             	sub    $0xc,%esp
   10d6c:	50                   	push   %eax
   10d6d:	e8 f0 76 ff ff       	call   8462 <lodepng_chunk_generate_crc>
   10d72:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10d75:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10d78:	83 ec 0c             	sub    $0xc,%esp
   10d7b:	50                   	push   %eax
   10d7c:	e8 e1 25 ff ff       	call   3362 <lodepng_free>
   10d81:	83 c4 10             	add    $0x10,%esp
  return error;
   10d84:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10d87:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10d8a:	c9                   	leave  
   10d8b:	c3                   	ret    

00010d8c <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   10d8c:	55                   	push   %ebp
   10d8d:	89 e5                	mov    %esp,%ebp
   10d8f:	53                   	push   %ebx
   10d90:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   10d93:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10d9a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   10da1:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   10da8:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10daf:	ff 75 1c             	pushl  0x1c(%ebp)
   10db2:	e8 26 26 ff ff       	call   33dd <lodepng_strlen>
   10db7:	83 c4 04             	add    $0x4,%esp
   10dba:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   10dbd:	ff 75 10             	pushl  0x10(%ebp)
   10dc0:	e8 18 26 ff ff       	call   33dd <lodepng_strlen>
   10dc5:	83 c4 04             	add    $0x4,%esp
   10dc8:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10dcb:	ff 75 14             	pushl  0x14(%ebp)
   10dce:	e8 0a 26 ff ff       	call   33dd <lodepng_strlen>
   10dd3:	83 c4 04             	add    $0x4,%esp
   10dd6:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10dd9:	ff 75 18             	pushl  0x18(%ebp)
   10ddc:	e8 fc 25 ff ff       	call   33dd <lodepng_strlen>
   10de1:	83 c4 04             	add    $0x4,%esp
   10de4:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10de7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10deb:	7e 06                	jle    10df3 <addChunk_iTXt+0x67>
   10ded:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10df1:	7e 0a                	jle    10dfd <addChunk_iTXt+0x71>
   10df3:	b8 59 00 00 00       	mov    $0x59,%eax
   10df8:	e9 9a 01 00 00       	jmp    10f97 <addChunk_iTXt+0x20b>

  if(compress) {
   10dfd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10e01:	74 1f                	je     10e22 <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   10e03:	83 ec 0c             	sub    $0xc,%esp
   10e06:	ff 75 20             	pushl  0x20(%ebp)
   10e09:	ff 75 f0             	pushl  -0x10(%ebp)
   10e0c:	ff 75 1c             	pushl  0x1c(%ebp)
   10e0f:	8d 45 d0             	lea    -0x30(%ebp),%eax
   10e12:	50                   	push   %eax
   10e13:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   10e16:	50                   	push   %eax
   10e17:	e8 35 72 ff ff       	call   8051 <zlib_compress>
   10e1c:	83 c4 20             	add    $0x20,%esp
   10e1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   10e22:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e26:	75 44                	jne    10e6c <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   10e28:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e2b:	8d 50 03             	lea    0x3(%eax),%edx
   10e2e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e31:	01 d0                	add    %edx,%eax
   10e33:	8d 50 01             	lea    0x1(%eax),%edx
   10e36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10e39:	01 d0                	add    %edx,%eax
   10e3b:	8d 50 01             	lea    0x1(%eax),%edx
   10e3e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10e42:	74 05                	je     10e49 <addChunk_iTXt+0xbd>
   10e44:	8b 45 d0             	mov    -0x30(%ebp),%eax
   10e47:	eb 03                	jmp    10e4c <addChunk_iTXt+0xc0>
   10e49:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10e4c:	01 d0                	add    %edx,%eax
   10e4e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   10e51:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10e54:	68 a1 a0 01 00       	push   $0x1a0a1
   10e59:	50                   	push   %eax
   10e5a:	ff 75 08             	pushl  0x8(%ebp)
   10e5d:	8d 45 d8             	lea    -0x28(%ebp),%eax
   10e60:	50                   	push   %eax
   10e61:	e8 53 79 ff ff       	call   87b9 <lodepng_chunk_init>
   10e66:	83 c4 10             	add    $0x10,%esp
   10e69:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10e6c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e70:	0f 85 0f 01 00 00    	jne    10f85 <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   10e76:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   10e7d:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10e80:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e83:	01 d0                	add    %edx,%eax
   10e85:	83 ec 04             	sub    $0x4,%esp
   10e88:	ff 75 ec             	pushl  -0x14(%ebp)
   10e8b:	ff 75 10             	pushl  0x10(%ebp)
   10e8e:	50                   	push   %eax
   10e8f:	e8 eb 24 ff ff       	call   337f <lodepng_memcpy>
   10e94:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   10e97:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e9a:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10e9d:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10ea0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ea3:	8d 50 01             	lea    0x1(%eax),%edx
   10ea6:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10ea9:	01 c8                	add    %ecx,%eax
   10eab:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   10eae:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10eb1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10eb4:	8d 50 01             	lea    0x1(%eax),%edx
   10eb7:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10eba:	01 c8                	add    %ecx,%eax
   10ebc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10ec0:	0f 95 c2             	setne  %dl
   10ec3:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   10ec5:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10ec8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ecb:	8d 50 01             	lea    0x1(%eax),%edx
   10ece:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10ed1:	01 c8                	add    %ecx,%eax
   10ed3:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   10ed6:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10ed9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10edc:	01 d0                	add    %edx,%eax
   10ede:	83 ec 04             	sub    $0x4,%esp
   10ee1:	ff 75 e8             	pushl  -0x18(%ebp)
   10ee4:	ff 75 14             	pushl  0x14(%ebp)
   10ee7:	50                   	push   %eax
   10ee8:	e8 92 24 ff ff       	call   337f <lodepng_memcpy>
   10eed:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   10ef0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ef3:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10ef6:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10ef9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10efc:	8d 50 01             	lea    0x1(%eax),%edx
   10eff:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f02:	01 c8                	add    %ecx,%eax
   10f04:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   10f07:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10f0a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f0d:	01 d0                	add    %edx,%eax
   10f0f:	83 ec 04             	sub    $0x4,%esp
   10f12:	ff 75 e4             	pushl  -0x1c(%ebp)
   10f15:	ff 75 18             	pushl  0x18(%ebp)
   10f18:	50                   	push   %eax
   10f19:	e8 61 24 ff ff       	call   337f <lodepng_memcpy>
   10f1e:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   10f21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10f24:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10f27:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f2d:	8d 50 01             	lea    0x1(%eax),%edx
   10f30:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f33:	01 c8                	add    %ecx,%eax
   10f35:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   10f38:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10f3c:	74 1e                	je     10f5c <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   10f3e:	8b 55 d0             	mov    -0x30(%ebp),%edx
   10f41:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10f44:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   10f47:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   10f4a:	01 d9                	add    %ebx,%ecx
   10f4c:	83 ec 04             	sub    $0x4,%esp
   10f4f:	52                   	push   %edx
   10f50:	50                   	push   %eax
   10f51:	51                   	push   %ecx
   10f52:	e8 28 24 ff ff       	call   337f <lodepng_memcpy>
   10f57:	83 c4 10             	add    $0x10,%esp
   10f5a:	eb 1a                	jmp    10f76 <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   10f5c:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10f5f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f62:	01 d0                	add    %edx,%eax
   10f64:	83 ec 04             	sub    $0x4,%esp
   10f67:	ff 75 f0             	pushl  -0x10(%ebp)
   10f6a:	ff 75 1c             	pushl  0x1c(%ebp)
   10f6d:	50                   	push   %eax
   10f6e:	e8 0c 24 ff ff       	call   337f <lodepng_memcpy>
   10f73:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   10f76:	8b 45 d8             	mov    -0x28(%ebp),%eax
   10f79:	83 ec 0c             	sub    $0xc,%esp
   10f7c:	50                   	push   %eax
   10f7d:	e8 e0 74 ff ff       	call   8462 <lodepng_chunk_generate_crc>
   10f82:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10f85:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10f88:	83 ec 0c             	sub    $0xc,%esp
   10f8b:	50                   	push   %eax
   10f8c:	e8 d1 23 ff ff       	call   3362 <lodepng_free>
   10f91:	83 c4 10             	add    $0x10,%esp
  return error;
   10f94:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10f97:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10f9a:	c9                   	leave  
   10f9b:	c3                   	ret    

00010f9c <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   10f9c:	55                   	push   %ebp
   10f9d:	89 e5                	mov    %esp,%ebp
   10f9f:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   10fa2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   10fa9:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fac:	8b 40 0c             	mov    0xc(%eax),%eax
   10faf:	85 c0                	test   %eax,%eax
   10fb1:	74 0b                	je     10fbe <addChunk_bKGD+0x22>
   10fb3:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fb6:	8b 40 0c             	mov    0xc(%eax),%eax
   10fb9:	83 f8 04             	cmp    $0x4,%eax
   10fbc:	75 4b                	jne    11009 <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   10fbe:	68 92 a0 01 00       	push   $0x1a092
   10fc3:	6a 02                	push   $0x2
   10fc5:	ff 75 08             	pushl  0x8(%ebp)
   10fc8:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10fcb:	50                   	push   %eax
   10fcc:	e8 e8 77 ff ff       	call   87b9 <lodepng_chunk_init>
   10fd1:	83 c4 10             	add    $0x10,%esp
   10fd4:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10fd7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10fdb:	74 08                	je     10fe5 <addChunk_bKGD+0x49>
   10fdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10fe0:	e9 19 01 00 00       	jmp    110fe <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   10fe5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10fe8:	8d 50 08             	lea    0x8(%eax),%edx
   10feb:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fee:	8b 40 30             	mov    0x30(%eax),%eax
   10ff1:	c1 e8 08             	shr    $0x8,%eax
   10ff4:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   10ff6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ff9:	8d 50 09             	lea    0x9(%eax),%edx
   10ffc:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fff:	8b 40 30             	mov    0x30(%eax),%eax
   11002:	88 02                	mov    %al,(%edx)
   11004:	e9 dd 00 00 00       	jmp    110e6 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   11009:	8b 45 0c             	mov    0xc(%ebp),%eax
   1100c:	8b 40 0c             	mov    0xc(%eax),%eax
   1100f:	83 f8 02             	cmp    $0x2,%eax
   11012:	74 0f                	je     11023 <addChunk_bKGD+0x87>
   11014:	8b 45 0c             	mov    0xc(%ebp),%eax
   11017:	8b 40 0c             	mov    0xc(%eax),%eax
   1101a:	83 f8 06             	cmp    $0x6,%eax
   1101d:	0f 85 86 00 00 00    	jne    110a9 <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   11023:	68 92 a0 01 00       	push   $0x1a092
   11028:	6a 06                	push   $0x6
   1102a:	ff 75 08             	pushl  0x8(%ebp)
   1102d:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11030:	50                   	push   %eax
   11031:	e8 83 77 ff ff       	call   87b9 <lodepng_chunk_init>
   11036:	83 c4 10             	add    $0x10,%esp
   11039:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1103c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   11040:	74 08                	je     1104a <addChunk_bKGD+0xae>
   11042:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11045:	e9 b4 00 00 00       	jmp    110fe <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   1104a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1104d:	8d 50 08             	lea    0x8(%eax),%edx
   11050:	8b 45 0c             	mov    0xc(%ebp),%eax
   11053:	8b 40 30             	mov    0x30(%eax),%eax
   11056:	c1 e8 08             	shr    $0x8,%eax
   11059:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   1105b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1105e:	8d 50 09             	lea    0x9(%eax),%edx
   11061:	8b 45 0c             	mov    0xc(%ebp),%eax
   11064:	8b 40 30             	mov    0x30(%eax),%eax
   11067:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   11069:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1106c:	8d 50 0a             	lea    0xa(%eax),%edx
   1106f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11072:	8b 40 34             	mov    0x34(%eax),%eax
   11075:	c1 e8 08             	shr    $0x8,%eax
   11078:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   1107a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1107d:	8d 50 0b             	lea    0xb(%eax),%edx
   11080:	8b 45 0c             	mov    0xc(%ebp),%eax
   11083:	8b 40 34             	mov    0x34(%eax),%eax
   11086:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   11088:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1108b:	8d 50 0c             	lea    0xc(%eax),%edx
   1108e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11091:	8b 40 38             	mov    0x38(%eax),%eax
   11094:	c1 e8 08             	shr    $0x8,%eax
   11097:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   11099:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1109c:	8d 50 0d             	lea    0xd(%eax),%edx
   1109f:	8b 45 0c             	mov    0xc(%ebp),%eax
   110a2:	8b 40 38             	mov    0x38(%eax),%eax
   110a5:	88 02                	mov    %al,(%edx)
   110a7:	eb 3d                	jmp    110e6 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   110a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   110ac:	8b 40 0c             	mov    0xc(%eax),%eax
   110af:	83 f8 03             	cmp    $0x3,%eax
   110b2:	75 32                	jne    110e6 <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   110b4:	68 92 a0 01 00       	push   $0x1a092
   110b9:	6a 01                	push   $0x1
   110bb:	ff 75 08             	pushl  0x8(%ebp)
   110be:	8d 45 f0             	lea    -0x10(%ebp),%eax
   110c1:	50                   	push   %eax
   110c2:	e8 f2 76 ff ff       	call   87b9 <lodepng_chunk_init>
   110c7:	83 c4 10             	add    $0x10,%esp
   110ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
   110cd:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   110d1:	74 05                	je     110d8 <addChunk_bKGD+0x13c>
   110d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   110d6:	eb 26                	jmp    110fe <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   110d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110db:	8d 50 08             	lea    0x8(%eax),%edx
   110de:	8b 45 0c             	mov    0xc(%ebp),%eax
   110e1:	8b 40 30             	mov    0x30(%eax),%eax
   110e4:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   110e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110e9:	85 c0                	test   %eax,%eax
   110eb:	74 0c                	je     110f9 <addChunk_bKGD+0x15d>
   110ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110f0:	50                   	push   %eax
   110f1:	e8 6c 73 ff ff       	call   8462 <lodepng_chunk_generate_crc>
   110f6:	83 c4 04             	add    $0x4,%esp
  return 0;
   110f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
   110fe:	c9                   	leave  
   110ff:	c3                   	ret    

00011100 <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   11100:	55                   	push   %ebp
   11101:	89 e5                	mov    %esp,%ebp
   11103:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   11106:	68 a6 a0 01 00       	push   $0x1a0a6
   1110b:	6a 07                	push   $0x7
   1110d:	ff 75 08             	pushl  0x8(%ebp)
   11110:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11113:	50                   	push   %eax
   11114:	e8 a0 76 ff ff       	call   87b9 <lodepng_chunk_init>
   11119:	83 c4 10             	add    $0x10,%esp
   1111c:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1111f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11123:	74 05                	je     1112a <addChunk_tIME+0x2a>
   11125:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11128:	eb 74                	jmp    1119e <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   1112a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1112d:	8d 50 08             	lea    0x8(%eax),%edx
   11130:	8b 45 0c             	mov    0xc(%ebp),%eax
   11133:	8b 00                	mov    (%eax),%eax
   11135:	c1 e8 08             	shr    $0x8,%eax
   11138:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   1113a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1113d:	8d 50 09             	lea    0x9(%eax),%edx
   11140:	8b 45 0c             	mov    0xc(%ebp),%eax
   11143:	8b 00                	mov    (%eax),%eax
   11145:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   11147:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1114a:	8d 50 0a             	lea    0xa(%eax),%edx
   1114d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11150:	8b 40 04             	mov    0x4(%eax),%eax
   11153:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   11155:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11158:	8d 50 0b             	lea    0xb(%eax),%edx
   1115b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1115e:	8b 40 08             	mov    0x8(%eax),%eax
   11161:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   11163:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11166:	8d 50 0c             	lea    0xc(%eax),%edx
   11169:	8b 45 0c             	mov    0xc(%ebp),%eax
   1116c:	8b 40 0c             	mov    0xc(%eax),%eax
   1116f:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   11171:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11174:	8d 50 0d             	lea    0xd(%eax),%edx
   11177:	8b 45 0c             	mov    0xc(%ebp),%eax
   1117a:	8b 40 10             	mov    0x10(%eax),%eax
   1117d:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   1117f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11182:	8d 50 0e             	lea    0xe(%eax),%edx
   11185:	8b 45 0c             	mov    0xc(%ebp),%eax
   11188:	8b 40 14             	mov    0x14(%eax),%eax
   1118b:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   1118d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11190:	50                   	push   %eax
   11191:	e8 cc 72 ff ff       	call   8462 <lodepng_chunk_generate_crc>
   11196:	83 c4 04             	add    $0x4,%esp
  return 0;
   11199:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1119e:	c9                   	leave  
   1119f:	c3                   	ret    

000111a0 <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   111a0:	55                   	push   %ebp
   111a1:	89 e5                	mov    %esp,%ebp
   111a3:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   111a6:	68 ab a0 01 00       	push   $0x1a0ab
   111ab:	6a 09                	push   $0x9
   111ad:	ff 75 08             	pushl  0x8(%ebp)
   111b0:	8d 45 f8             	lea    -0x8(%ebp),%eax
   111b3:	50                   	push   %eax
   111b4:	e8 00 76 ff ff       	call   87b9 <lodepng_chunk_init>
   111b9:	83 c4 10             	add    $0x10,%esp
   111bc:	89 45 fc             	mov    %eax,-0x4(%ebp)
   111bf:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   111c3:	74 05                	je     111ca <addChunk_pHYs+0x2a>
   111c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   111c8:	eb 51                	jmp    1121b <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   111ca:	8b 45 0c             	mov    0xc(%ebp),%eax
   111cd:	8b 40 7c             	mov    0x7c(%eax),%eax
   111d0:	8b 55 f8             	mov    -0x8(%ebp),%edx
   111d3:	83 c2 08             	add    $0x8,%edx
   111d6:	50                   	push   %eax
   111d7:	52                   	push   %edx
   111d8:	e8 25 25 ff ff       	call   3702 <lodepng_set32bitInt>
   111dd:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   111e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   111e3:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   111e9:	8b 55 f8             	mov    -0x8(%ebp),%edx
   111ec:	83 c2 0c             	add    $0xc,%edx
   111ef:	50                   	push   %eax
   111f0:	52                   	push   %edx
   111f1:	e8 0c 25 ff ff       	call   3702 <lodepng_set32bitInt>
   111f6:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   111f9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111fc:	8d 50 10             	lea    0x10(%eax),%edx
   111ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   11202:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   11208:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   1120a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1120d:	50                   	push   %eax
   1120e:	e8 4f 72 ff ff       	call   8462 <lodepng_chunk_generate_crc>
   11213:	83 c4 04             	add    $0x4,%esp
  return 0;
   11216:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1121b:	c9                   	leave  
   1121c:	c3                   	ret    

0001121d <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   1121d:	55                   	push   %ebp
   1121e:	89 e5                	mov    %esp,%ebp
   11220:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   11223:	68 b0 a0 01 00       	push   $0x1a0b0
   11228:	6a 04                	push   $0x4
   1122a:	ff 75 08             	pushl  0x8(%ebp)
   1122d:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11230:	50                   	push   %eax
   11231:	e8 83 75 ff ff       	call   87b9 <lodepng_chunk_init>
   11236:	83 c4 10             	add    $0x10,%esp
   11239:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1123c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11240:	74 05                	je     11247 <addChunk_gAMA+0x2a>
   11242:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11245:	eb 2a                	jmp    11271 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   11247:	8b 45 0c             	mov    0xc(%ebp),%eax
   1124a:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   11250:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11253:	83 c2 08             	add    $0x8,%edx
   11256:	50                   	push   %eax
   11257:	52                   	push   %edx
   11258:	e8 a5 24 ff ff       	call   3702 <lodepng_set32bitInt>
   1125d:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   11260:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11263:	50                   	push   %eax
   11264:	e8 f9 71 ff ff       	call   8462 <lodepng_chunk_generate_crc>
   11269:	83 c4 04             	add    $0x4,%esp
  return 0;
   1126c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11271:	c9                   	leave  
   11272:	c3                   	ret    

00011273 <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   11273:	55                   	push   %ebp
   11274:	89 e5                	mov    %esp,%ebp
   11276:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   11279:	68 b5 a0 01 00       	push   $0x1a0b5
   1127e:	6a 20                	push   $0x20
   11280:	ff 75 08             	pushl  0x8(%ebp)
   11283:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11286:	50                   	push   %eax
   11287:	e8 2d 75 ff ff       	call   87b9 <lodepng_chunk_init>
   1128c:	83 c4 10             	add    $0x10,%esp
   1128f:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11292:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11296:	74 08                	je     112a0 <addChunk_cHRM+0x2d>
   11298:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1129b:	e9 d9 00 00 00       	jmp    11379 <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   112a0:	8b 45 0c             	mov    0xc(%ebp),%eax
   112a3:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   112a9:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112ac:	83 c2 08             	add    $0x8,%edx
   112af:	50                   	push   %eax
   112b0:	52                   	push   %edx
   112b1:	e8 4c 24 ff ff       	call   3702 <lodepng_set32bitInt>
   112b6:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   112b9:	8b 45 0c             	mov    0xc(%ebp),%eax
   112bc:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   112c2:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112c5:	83 c2 0c             	add    $0xc,%edx
   112c8:	50                   	push   %eax
   112c9:	52                   	push   %edx
   112ca:	e8 33 24 ff ff       	call   3702 <lodepng_set32bitInt>
   112cf:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   112d2:	8b 45 0c             	mov    0xc(%ebp),%eax
   112d5:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   112db:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112de:	83 c2 10             	add    $0x10,%edx
   112e1:	50                   	push   %eax
   112e2:	52                   	push   %edx
   112e3:	e8 1a 24 ff ff       	call   3702 <lodepng_set32bitInt>
   112e8:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   112eb:	8b 45 0c             	mov    0xc(%ebp),%eax
   112ee:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   112f4:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112f7:	83 c2 14             	add    $0x14,%edx
   112fa:	50                   	push   %eax
   112fb:	52                   	push   %edx
   112fc:	e8 01 24 ff ff       	call   3702 <lodepng_set32bitInt>
   11301:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   11304:	8b 45 0c             	mov    0xc(%ebp),%eax
   11307:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   1130d:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11310:	83 c2 18             	add    $0x18,%edx
   11313:	50                   	push   %eax
   11314:	52                   	push   %edx
   11315:	e8 e8 23 ff ff       	call   3702 <lodepng_set32bitInt>
   1131a:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   1131d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11320:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   11326:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11329:	83 c2 1c             	add    $0x1c,%edx
   1132c:	50                   	push   %eax
   1132d:	52                   	push   %edx
   1132e:	e8 cf 23 ff ff       	call   3702 <lodepng_set32bitInt>
   11333:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   11336:	8b 45 0c             	mov    0xc(%ebp),%eax
   11339:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   1133f:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11342:	83 c2 20             	add    $0x20,%edx
   11345:	50                   	push   %eax
   11346:	52                   	push   %edx
   11347:	e8 b6 23 ff ff       	call   3702 <lodepng_set32bitInt>
   1134c:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   1134f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11352:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   11358:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1135b:	83 c2 24             	add    $0x24,%edx
   1135e:	50                   	push   %eax
   1135f:	52                   	push   %edx
   11360:	e8 9d 23 ff ff       	call   3702 <lodepng_set32bitInt>
   11365:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   11368:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1136b:	50                   	push   %eax
   1136c:	e8 f1 70 ff ff       	call   8462 <lodepng_chunk_generate_crc>
   11371:	83 c4 04             	add    $0x4,%esp
  return 0;
   11374:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11379:	c9                   	leave  
   1137a:	c3                   	ret    

0001137b <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   1137b:	55                   	push   %ebp
   1137c:	89 e5                	mov    %esp,%ebp
   1137e:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   11381:	8b 45 0c             	mov    0xc(%ebp),%eax
   11384:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   1138a:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   1138d:	8d 45 ff             	lea    -0x1(%ebp),%eax
   11390:	50                   	push   %eax
   11391:	68 ba a0 01 00       	push   $0x1a0ba
   11396:	6a 01                	push   $0x1
   11398:	ff 75 08             	pushl  0x8(%ebp)
   1139b:	e8 c1 74 ff ff       	call   8861 <lodepng_chunk_createv>
   113a0:	83 c4 10             	add    $0x10,%esp
}
   113a3:	c9                   	leave  
   113a4:	c3                   	ret    

000113a5 <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   113a5:	55                   	push   %ebp
   113a6:	89 e5                	mov    %esp,%ebp
   113a8:	53                   	push   %ebx
   113a9:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   113ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   113b3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   113ba:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   113c1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   113c8:	8b 45 0c             	mov    0xc(%ebp),%eax
   113cb:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   113d1:	50                   	push   %eax
   113d2:	e8 06 20 ff ff       	call   33dd <lodepng_strlen>
   113d7:	83 c4 04             	add    $0x4,%esp
   113da:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   113dd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   113e1:	7e 06                	jle    113e9 <addChunk_iCCP+0x44>
   113e3:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   113e7:	7e 0a                	jle    113f3 <addChunk_iCCP+0x4e>
   113e9:	b8 59 00 00 00       	mov    $0x59,%eax
   113ee:	e9 df 00 00 00       	jmp    114d2 <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   113f3:	8b 45 0c             	mov    0xc(%ebp),%eax
   113f6:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   113fc:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   113fe:	8b 45 0c             	mov    0xc(%ebp),%eax
   11401:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   11407:	83 ec 0c             	sub    $0xc,%esp
   1140a:	ff 75 10             	pushl  0x10(%ebp)
   1140d:	52                   	push   %edx
   1140e:	50                   	push   %eax
   1140f:	8d 45 e0             	lea    -0x20(%ebp),%eax
   11412:	50                   	push   %eax
   11413:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   11416:	50                   	push   %eax
   11417:	e8 35 6c ff ff       	call   8051 <zlib_compress>
   1141c:	83 c4 20             	add    $0x20,%esp
   1141f:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   11422:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11426:	75 29                	jne    11451 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   11428:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1142b:	8d 50 02             	lea    0x2(%eax),%edx
   1142e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11431:	01 d0                	add    %edx,%eax
   11433:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   11436:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11439:	68 bf a0 01 00       	push   $0x1a0bf
   1143e:	50                   	push   %eax
   1143f:	ff 75 08             	pushl  0x8(%ebp)
   11442:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11445:	50                   	push   %eax
   11446:	e8 6e 73 ff ff       	call   87b9 <lodepng_chunk_init>
   1144b:	83 c4 10             	add    $0x10,%esp
   1144e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11451:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11455:	75 69                	jne    114c0 <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   11457:	8b 45 0c             	mov    0xc(%ebp),%eax
   1145a:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11460:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11463:	83 c2 08             	add    $0x8,%edx
   11466:	83 ec 04             	sub    $0x4,%esp
   11469:	ff 75 f0             	pushl  -0x10(%ebp)
   1146c:	50                   	push   %eax
   1146d:	52                   	push   %edx
   1146e:	e8 0c 1f ff ff       	call   337f <lodepng_memcpy>
   11473:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   11476:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11479:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1147c:	83 c2 08             	add    $0x8,%edx
   1147f:	01 d0                	add    %edx,%eax
   11481:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   11484:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11487:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1148a:	83 c2 09             	add    $0x9,%edx
   1148d:	01 d0                	add    %edx,%eax
   1148f:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11492:	8b 55 e0             	mov    -0x20(%ebp),%edx
   11495:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11498:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1149b:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   1149e:	83 c3 0a             	add    $0xa,%ebx
   114a1:	01 d9                	add    %ebx,%ecx
   114a3:	83 ec 04             	sub    $0x4,%esp
   114a6:	52                   	push   %edx
   114a7:	50                   	push   %eax
   114a8:	51                   	push   %ecx
   114a9:	e8 d1 1e ff ff       	call   337f <lodepng_memcpy>
   114ae:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   114b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   114b4:	83 ec 0c             	sub    $0xc,%esp
   114b7:	50                   	push   %eax
   114b8:	e8 a5 6f ff ff       	call   8462 <lodepng_chunk_generate_crc>
   114bd:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   114c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   114c3:	83 ec 0c             	sub    $0xc,%esp
   114c6:	50                   	push   %eax
   114c7:	e8 96 1e ff ff       	call   3362 <lodepng_free>
   114cc:	83 c4 10             	add    $0x10,%esp
  return error;
   114cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   114d2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   114d5:	c9                   	leave  
   114d6:	c3                   	ret    

000114d7 <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   114d7:	55                   	push   %ebp
   114d8:	89 e5                	mov    %esp,%ebp
   114da:	56                   	push   %esi
   114db:	53                   	push   %ebx
   114dc:	83 ec 14             	sub    $0x14,%esp
   114df:	8b 45 1c             	mov    0x1c(%ebp),%eax
   114e2:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   114e5:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   114e9:	83 f8 04             	cmp    $0x4,%eax
   114ec:	0f 87 41 03 00 00    	ja     11833 <filterScanline+0x35c>
   114f2:	8b 04 85 d0 a0 01 00 	mov    0x1a0d0(,%eax,4),%eax
   114f9:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   114fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11502:	eb 19                	jmp    1151d <filterScanline+0x46>
   11504:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11507:	8b 45 08             	mov    0x8(%ebp),%eax
   1150a:	01 c2                	add    %eax,%edx
   1150c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1150f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11512:	01 c8                	add    %ecx,%eax
   11514:	0f b6 00             	movzbl (%eax),%eax
   11517:	88 02                	mov    %al,(%edx)
   11519:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1151d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11520:	3b 45 14             	cmp    0x14(%ebp),%eax
   11523:	75 df                	jne    11504 <filterScanline+0x2d>
      break;
   11525:	e9 0a 03 00 00       	jmp    11834 <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   1152a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11531:	eb 19                	jmp    1154c <filterScanline+0x75>
   11533:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11536:	8b 45 08             	mov    0x8(%ebp),%eax
   11539:	01 c2                	add    %eax,%edx
   1153b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1153e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11541:	01 c8                	add    %ecx,%eax
   11543:	0f b6 00             	movzbl (%eax),%eax
   11546:	88 02                	mov    %al,(%edx)
   11548:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1154c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1154f:	3b 45 18             	cmp    0x18(%ebp),%eax
   11552:	75 df                	jne    11533 <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   11554:	8b 45 18             	mov    0x18(%ebp),%eax
   11557:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1155a:	eb 2d                	jmp    11589 <filterScanline+0xb2>
   1155c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1155f:	8b 45 08             	mov    0x8(%ebp),%eax
   11562:	01 c2                	add    %eax,%edx
   11564:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11567:	8b 45 0c             	mov    0xc(%ebp),%eax
   1156a:	01 c8                	add    %ecx,%eax
   1156c:	0f b6 08             	movzbl (%eax),%ecx
   1156f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11572:	2b 45 18             	sub    0x18(%ebp),%eax
   11575:	89 c3                	mov    %eax,%ebx
   11577:	8b 45 0c             	mov    0xc(%ebp),%eax
   1157a:	01 d8                	add    %ebx,%eax
   1157c:	0f b6 00             	movzbl (%eax),%eax
   1157f:	29 c1                	sub    %eax,%ecx
   11581:	89 c8                	mov    %ecx,%eax
   11583:	88 02                	mov    %al,(%edx)
   11585:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11589:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1158c:	3b 45 14             	cmp    0x14(%ebp),%eax
   1158f:	7c cb                	jl     1155c <filterScanline+0x85>
      break;
   11591:	e9 9e 02 00 00       	jmp    11834 <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   11596:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1159a:	74 3e                	je     115da <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   1159c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   115a3:	eb 28                	jmp    115cd <filterScanline+0xf6>
   115a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115a8:	8b 45 08             	mov    0x8(%ebp),%eax
   115ab:	01 d0                	add    %edx,%eax
   115ad:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   115b0:	8b 55 0c             	mov    0xc(%ebp),%edx
   115b3:	01 ca                	add    %ecx,%edx
   115b5:	0f b6 0a             	movzbl (%edx),%ecx
   115b8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   115bb:	8b 55 10             	mov    0x10(%ebp),%edx
   115be:	01 da                	add    %ebx,%edx
   115c0:	0f b6 12             	movzbl (%edx),%edx
   115c3:	29 d1                	sub    %edx,%ecx
   115c5:	89 ca                	mov    %ecx,%edx
   115c7:	88 10                	mov    %dl,(%eax)
   115c9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115d0:	3b 45 14             	cmp    0x14(%ebp),%eax
   115d3:	75 d0                	jne    115a5 <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   115d5:	e9 5a 02 00 00       	jmp    11834 <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   115da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   115e1:	eb 19                	jmp    115fc <filterScanline+0x125>
   115e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115e6:	8b 45 08             	mov    0x8(%ebp),%eax
   115e9:	01 c2                	add    %eax,%edx
   115eb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   115ee:	8b 45 0c             	mov    0xc(%ebp),%eax
   115f1:	01 c8                	add    %ecx,%eax
   115f3:	0f b6 00             	movzbl (%eax),%eax
   115f6:	88 02                	mov    %al,(%edx)
   115f8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115ff:	3b 45 14             	cmp    0x14(%ebp),%eax
   11602:	75 df                	jne    115e3 <filterScanline+0x10c>
      }
      break;
   11604:	e9 2b 02 00 00       	jmp    11834 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   11609:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1160d:	0f 84 90 00 00 00    	je     116a3 <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   11613:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1161a:	eb 28                	jmp    11644 <filterScanline+0x16d>
   1161c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1161f:	8b 45 08             	mov    0x8(%ebp),%eax
   11622:	01 d0                	add    %edx,%eax
   11624:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11627:	8b 55 0c             	mov    0xc(%ebp),%edx
   1162a:	01 ca                	add    %ecx,%edx
   1162c:	0f b6 12             	movzbl (%edx),%edx
   1162f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11632:	8b 4d 10             	mov    0x10(%ebp),%ecx
   11635:	01 d9                	add    %ebx,%ecx
   11637:	0f b6 09             	movzbl (%ecx),%ecx
   1163a:	d0 e9                	shr    %cl
   1163c:	29 ca                	sub    %ecx,%edx
   1163e:	88 10                	mov    %dl,(%eax)
   11640:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11644:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11647:	3b 45 18             	cmp    0x18(%ebp),%eax
   1164a:	75 d0                	jne    1161c <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   1164c:	8b 45 18             	mov    0x18(%ebp),%eax
   1164f:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11652:	eb 42                	jmp    11696 <filterScanline+0x1bf>
   11654:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11657:	8b 45 08             	mov    0x8(%ebp),%eax
   1165a:	01 c2                	add    %eax,%edx
   1165c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1165f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11662:	01 c8                	add    %ecx,%eax
   11664:	0f b6 08             	movzbl (%eax),%ecx
   11667:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1166a:	2b 45 18             	sub    0x18(%ebp),%eax
   1166d:	89 c3                	mov    %eax,%ebx
   1166f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11672:	01 d8                	add    %ebx,%eax
   11674:	0f b6 00             	movzbl (%eax),%eax
   11677:	0f b6 d8             	movzbl %al,%ebx
   1167a:	8b 75 f4             	mov    -0xc(%ebp),%esi
   1167d:	8b 45 10             	mov    0x10(%ebp),%eax
   11680:	01 f0                	add    %esi,%eax
   11682:	0f b6 00             	movzbl (%eax),%eax
   11685:	0f b6 c0             	movzbl %al,%eax
   11688:	01 d8                	add    %ebx,%eax
   1168a:	d1 f8                	sar    %eax
   1168c:	29 c1                	sub    %eax,%ecx
   1168e:	89 c8                	mov    %ecx,%eax
   11690:	88 02                	mov    %al,(%edx)
   11692:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11696:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11699:	3b 45 14             	cmp    0x14(%ebp),%eax
   1169c:	7c b6                	jl     11654 <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   1169e:	e9 91 01 00 00       	jmp    11834 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   116a3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   116aa:	eb 19                	jmp    116c5 <filterScanline+0x1ee>
   116ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116af:	8b 45 08             	mov    0x8(%ebp),%eax
   116b2:	01 c2                	add    %eax,%edx
   116b4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   116b7:	8b 45 0c             	mov    0xc(%ebp),%eax
   116ba:	01 c8                	add    %ecx,%eax
   116bc:	0f b6 00             	movzbl (%eax),%eax
   116bf:	88 02                	mov    %al,(%edx)
   116c1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   116c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116c8:	3b 45 18             	cmp    0x18(%ebp),%eax
   116cb:	75 df                	jne    116ac <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   116cd:	8b 45 18             	mov    0x18(%ebp),%eax
   116d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
   116d3:	eb 2f                	jmp    11704 <filterScanline+0x22d>
   116d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116d8:	8b 45 08             	mov    0x8(%ebp),%eax
   116db:	01 c2                	add    %eax,%edx
   116dd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   116e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   116e3:	01 c8                	add    %ecx,%eax
   116e5:	0f b6 08             	movzbl (%eax),%ecx
   116e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116eb:	2b 45 18             	sub    0x18(%ebp),%eax
   116ee:	89 c3                	mov    %eax,%ebx
   116f0:	8b 45 0c             	mov    0xc(%ebp),%eax
   116f3:	01 d8                	add    %ebx,%eax
   116f5:	0f b6 00             	movzbl (%eax),%eax
   116f8:	d0 e8                	shr    %al
   116fa:	29 c1                	sub    %eax,%ecx
   116fc:	89 c8                	mov    %ecx,%eax
   116fe:	88 02                	mov    %al,(%edx)
   11700:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11704:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11707:	3b 45 14             	cmp    0x14(%ebp),%eax
   1170a:	7c c9                	jl     116d5 <filterScanline+0x1fe>
      }
      break;
   1170c:	e9 23 01 00 00       	jmp    11834 <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   11711:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11715:	0f 84 af 00 00 00    	je     117ca <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   1171b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11722:	eb 28                	jmp    1174c <filterScanline+0x275>
   11724:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11727:	8b 45 08             	mov    0x8(%ebp),%eax
   1172a:	01 d0                	add    %edx,%eax
   1172c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1172f:	8b 55 0c             	mov    0xc(%ebp),%edx
   11732:	01 ca                	add    %ecx,%edx
   11734:	0f b6 0a             	movzbl (%edx),%ecx
   11737:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1173a:	8b 55 10             	mov    0x10(%ebp),%edx
   1173d:	01 da                	add    %ebx,%edx
   1173f:	0f b6 12             	movzbl (%edx),%edx
   11742:	29 d1                	sub    %edx,%ecx
   11744:	89 ca                	mov    %ecx,%edx
   11746:	88 10                	mov    %dl,(%eax)
   11748:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1174c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1174f:	3b 45 18             	cmp    0x18(%ebp),%eax
   11752:	75 d0                	jne    11724 <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   11754:	8b 45 18             	mov    0x18(%ebp),%eax
   11757:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1175a:	eb 64                	jmp    117c0 <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   1175c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1175f:	8b 45 08             	mov    0x8(%ebp),%eax
   11762:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   11765:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11768:	8b 45 0c             	mov    0xc(%ebp),%eax
   1176b:	01 d0                	add    %edx,%eax
   1176d:	0f b6 00             	movzbl (%eax),%eax
   11770:	88 45 e7             	mov    %al,-0x19(%ebp)
   11773:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11776:	2b 45 18             	sub    0x18(%ebp),%eax
   11779:	89 c2                	mov    %eax,%edx
   1177b:	8b 45 10             	mov    0x10(%ebp),%eax
   1177e:	01 d0                	add    %edx,%eax
   11780:	0f b6 00             	movzbl (%eax),%eax
   11783:	0f b6 c8             	movzbl %al,%ecx
   11786:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11789:	8b 45 10             	mov    0x10(%ebp),%eax
   1178c:	01 d0                	add    %edx,%eax
   1178e:	0f b6 00             	movzbl (%eax),%eax
   11791:	0f b6 d0             	movzbl %al,%edx
   11794:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11797:	2b 45 18             	sub    0x18(%ebp),%eax
   1179a:	89 c6                	mov    %eax,%esi
   1179c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1179f:	01 f0                	add    %esi,%eax
   117a1:	0f b6 00             	movzbl (%eax),%eax
   117a4:	0f b6 c0             	movzbl %al,%eax
   117a7:	51                   	push   %ecx
   117a8:	52                   	push   %edx
   117a9:	50                   	push   %eax
   117aa:	e8 49 b8 ff ff       	call   cff8 <paethPredictor>
   117af:	83 c4 0c             	add    $0xc,%esp
   117b2:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   117b6:	29 c1                	sub    %eax,%ecx
   117b8:	89 c8                	mov    %ecx,%eax
   117ba:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   117bc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117c3:	3b 45 14             	cmp    0x14(%ebp),%eax
   117c6:	7c 94                	jl     1175c <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   117c8:	eb 6a                	jmp    11834 <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   117ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   117d1:	eb 19                	jmp    117ec <filterScanline+0x315>
   117d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117d6:	8b 45 08             	mov    0x8(%ebp),%eax
   117d9:	01 c2                	add    %eax,%edx
   117db:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117de:	8b 45 0c             	mov    0xc(%ebp),%eax
   117e1:	01 c8                	add    %ecx,%eax
   117e3:	0f b6 00             	movzbl (%eax),%eax
   117e6:	88 02                	mov    %al,(%edx)
   117e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117ef:	3b 45 18             	cmp    0x18(%ebp),%eax
   117f2:	75 df                	jne    117d3 <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   117f4:	8b 45 18             	mov    0x18(%ebp),%eax
   117f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
   117fa:	eb 2d                	jmp    11829 <filterScanline+0x352>
   117fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117ff:	8b 45 08             	mov    0x8(%ebp),%eax
   11802:	01 c2                	add    %eax,%edx
   11804:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11807:	8b 45 0c             	mov    0xc(%ebp),%eax
   1180a:	01 c8                	add    %ecx,%eax
   1180c:	0f b6 08             	movzbl (%eax),%ecx
   1180f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11812:	2b 45 18             	sub    0x18(%ebp),%eax
   11815:	89 c3                	mov    %eax,%ebx
   11817:	8b 45 0c             	mov    0xc(%ebp),%eax
   1181a:	01 d8                	add    %ebx,%eax
   1181c:	0f b6 00             	movzbl (%eax),%eax
   1181f:	29 c1                	sub    %eax,%ecx
   11821:	89 c8                	mov    %ecx,%eax
   11823:	88 02                	mov    %al,(%edx)
   11825:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11829:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1182c:	3b 45 14             	cmp    0x14(%ebp),%eax
   1182f:	7c cb                	jl     117fc <filterScanline+0x325>
      }
      break;
   11831:	eb 01                	jmp    11834 <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   11833:	90                   	nop
  }
}
   11834:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11837:	5b                   	pop    %ebx
   11838:	5e                   	pop    %esi
   11839:	5d                   	pop    %ebp
   1183a:	c3                   	ret    

0001183b <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   1183b:	55                   	push   %ebp
   1183c:	89 e5                	mov    %esp,%ebp
   1183e:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   11841:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   11848:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   1184f:	7e 08                	jle    11859 <ilog2+0x1e>
   11851:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   11855:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   11859:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   11860:	7e 08                	jle    1186a <ilog2+0x2f>
   11862:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   11866:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   1186a:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   1186e:	7e 08                	jle    11878 <ilog2+0x3d>
   11870:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   11874:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   11878:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   1187c:	7e 08                	jle    11886 <ilog2+0x4b>
   1187e:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   11882:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   11886:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   1188a:	7e 04                	jle    11890 <ilog2+0x55>
   1188c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   11890:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11893:	c9                   	leave  
   11894:	c3                   	ret    

00011895 <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   11895:	55                   	push   %ebp
   11896:	89 e5                	mov    %esp,%ebp
   11898:	56                   	push   %esi
   11899:	53                   	push   %ebx
   1189a:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   1189d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   118a1:	75 07                	jne    118aa <ilog2i+0x15>
   118a3:	b8 00 00 00 00       	mov    $0x0,%eax
   118a8:	eb 30                	jmp    118da <ilog2i+0x45>
  l = ilog2(i);
   118aa:	ff 75 08             	pushl  0x8(%ebp)
   118ad:	e8 89 ff ff ff       	call   1183b <ilog2>
   118b2:	83 c4 04             	add    $0x4,%esp
   118b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   118b8:	8b 45 08             	mov    0x8(%ebp),%eax
   118bb:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   118bf:	89 c3                	mov    %eax,%ebx
   118c1:	8b 55 08             	mov    0x8(%ebp),%edx
   118c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118c7:	be 01 00 00 00       	mov    $0x1,%esi
   118cc:	89 c1                	mov    %eax,%ecx
   118ce:	d3 e6                	shl    %cl,%esi
   118d0:	89 f0                	mov    %esi,%eax
   118d2:	29 c2                	sub    %eax,%edx
   118d4:	89 d0                	mov    %edx,%eax
   118d6:	01 c0                	add    %eax,%eax
   118d8:	01 d8                	add    %ebx,%eax
}
   118da:	8d 65 f8             	lea    -0x8(%ebp),%esp
   118dd:	5b                   	pop    %ebx
   118de:	5e                   	pop    %esi
   118df:	5d                   	pop    %ebp
   118e0:	c3                   	ret    

000118e1 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   118e1:	55                   	push   %ebp
   118e2:	89 e5                	mov    %esp,%ebp
   118e4:	53                   	push   %ebx
   118e5:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   118eb:	ff 75 18             	pushl  0x18(%ebp)
   118ee:	e8 6a 75 ff ff       	call   8e5d <lodepng_get_bpp>
   118f3:	83 c4 04             	add    $0x4,%esp
   118f6:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   118f9:	ff 75 b8             	pushl  -0x48(%ebp)
   118fc:	6a 01                	push   $0x1
   118fe:	ff 75 10             	pushl  0x10(%ebp)
   11901:	e8 b6 76 ff ff       	call   8fbc <lodepng_get_raw_size_idat>
   11906:	83 c4 0c             	add    $0xc,%esp
   11909:	83 e8 01             	sub    $0x1,%eax
   1190c:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   1190f:	8b 45 b8             	mov    -0x48(%ebp),%eax
   11912:	83 c0 07             	add    $0x7,%eax
   11915:	c1 e8 03             	shr    $0x3,%eax
   11918:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   1191b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   11922:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   11929:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1192c:	8b 40 2c             	mov    0x2c(%eax),%eax
   1192f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11932:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11935:	8b 40 28             	mov    0x28(%eax),%eax
   11938:	85 c0                	test   %eax,%eax
   1193a:	74 1c                	je     11958 <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   1193c:	8b 45 18             	mov    0x18(%ebp),%eax
   1193f:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11941:	83 f8 03             	cmp    $0x3,%eax
   11944:	74 0b                	je     11951 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11946:	8b 45 18             	mov    0x18(%ebp),%eax
   11949:	8b 40 04             	mov    0x4(%eax),%eax
   1194c:	83 f8 07             	cmp    $0x7,%eax
   1194f:	77 07                	ja     11958 <filter+0x77>
   11951:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   11958:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   1195c:	75 0a                	jne    11968 <filter+0x87>
   1195e:	b8 1f 00 00 00       	mov    $0x1f,%eax
   11963:	e9 5b 07 00 00       	jmp    120c3 <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   11968:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   1196c:	77 7b                	ja     119e9 <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   1196e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11971:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   11974:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1197b:	eb 5f                	jmp    119dc <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   1197d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11980:	83 c0 01             	add    $0x1,%eax
   11983:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11987:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   1198a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1198d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11991:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   11994:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11997:	8b 45 08             	mov    0x8(%ebp),%eax
   1199a:	01 c2                	add    %eax,%edx
   1199c:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   119a0:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   119a2:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   119a6:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   119a9:	8b 55 0c             	mov    0xc(%ebp),%edx
   119ac:	01 d1                	add    %edx,%ecx
   119ae:	8b 55 9c             	mov    -0x64(%ebp),%edx
   119b1:	8d 5a 01             	lea    0x1(%edx),%ebx
   119b4:	8b 55 08             	mov    0x8(%ebp),%edx
   119b7:	01 da                	add    %ebx,%edx
   119b9:	50                   	push   %eax
   119ba:	ff 75 b0             	pushl  -0x50(%ebp)
   119bd:	ff 75 b4             	pushl  -0x4c(%ebp)
   119c0:	ff 75 f4             	pushl  -0xc(%ebp)
   119c3:	51                   	push   %ecx
   119c4:	52                   	push   %edx
   119c5:	e8 0d fb ff ff       	call   114d7 <filterScanline>
   119ca:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   119cd:	8b 55 98             	mov    -0x68(%ebp),%edx
   119d0:	8b 45 0c             	mov    0xc(%ebp),%eax
   119d3:	01 d0                	add    %edx,%eax
   119d5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   119d8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   119dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119df:	3b 45 14             	cmp    0x14(%ebp),%eax
   119e2:	75 99                	jne    1197d <filter+0x9c>
   119e4:	e9 d7 06 00 00       	jmp    120c0 <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   119e9:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   119ed:	0f 85 e3 01 00 00    	jne    11bd6 <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   119f3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   119fa:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   119fe:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11a02:	eb 2d                	jmp    11a31 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11a04:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   11a08:	83 ec 0c             	sub    $0xc,%esp
   11a0b:	ff 75 b4             	pushl  -0x4c(%ebp)
   11a0e:	e8 2e 19 ff ff       	call   3341 <lodepng_malloc>
   11a13:	83 c4 10             	add    $0x10,%esp
   11a16:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11a1a:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a1e:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11a22:	85 c0                	test   %eax,%eax
   11a24:	75 07                	jne    11a2d <filter+0x14c>
   11a26:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   11a2d:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11a31:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11a35:	75 cd                	jne    11a04 <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11a37:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11a3b:	0f 85 6c 01 00 00    	jne    11bad <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   11a41:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11a48:	e9 54 01 00 00       	jmp    11ba1 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11a4d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11a51:	e9 d5 00 00 00       	jmp    11b2b <filter+0x24a>
          size_t sum = 0;
   11a56:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11a5d:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   11a61:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11a64:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11a68:	89 c1                	mov    %eax,%ecx
   11a6a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a6d:	01 c1                	add    %eax,%ecx
   11a6f:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a73:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11a77:	83 ec 08             	sub    $0x8,%esp
   11a7a:	52                   	push   %edx
   11a7b:	ff 75 b0             	pushl  -0x50(%ebp)
   11a7e:	ff 75 b4             	pushl  -0x4c(%ebp)
   11a81:	ff 75 f4             	pushl  -0xc(%ebp)
   11a84:	51                   	push   %ecx
   11a85:	50                   	push   %eax
   11a86:	e8 4c fa ff ff       	call   114d7 <filterScanline>
   11a8b:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   11a8e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11a92:	75 2d                	jne    11ac1 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   11a94:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11a9b:	eb 1a                	jmp    11ab7 <filter+0x1d6>
   11a9d:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11aa1:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11aa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11aa8:	01 d0                	add    %edx,%eax
   11aaa:	0f b6 00             	movzbl (%eax),%eax
   11aad:	0f b6 c0             	movzbl %al,%eax
   11ab0:	01 45 d8             	add    %eax,-0x28(%ebp)
   11ab3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11ab7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11aba:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11abd:	75 de                	jne    11a9d <filter+0x1bc>
   11abf:	eb 4b                	jmp    11b0c <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   11ac1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11ac8:	eb 3a                	jmp    11b04 <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   11aca:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11ace:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11ad2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ad5:	01 d0                	add    %edx,%eax
   11ad7:	0f b6 00             	movzbl (%eax),%eax
   11ada:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   11add:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11ae1:	84 c0                	test   %al,%al
   11ae3:	78 06                	js     11aeb <filter+0x20a>
   11ae5:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11ae9:	eb 0d                	jmp    11af8 <filter+0x217>
   11aeb:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11aef:	ba ff 00 00 00       	mov    $0xff,%edx
   11af4:	29 c2                	sub    %eax,%edx
   11af6:	89 d0                	mov    %edx,%eax
   11af8:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11afb:	01 d0                	add    %edx,%eax
   11afd:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   11b00:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11b04:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b07:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11b0a:	75 be                	jne    11aca <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   11b0c:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11b10:	74 08                	je     11b1a <filter+0x239>
   11b12:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11b15:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   11b18:	7d 0d                	jge    11b27 <filter+0x246>
            bestType = type;
   11b1a:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b1e:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   11b21:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11b24:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11b27:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11b2b:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11b2f:	0f 85 21 ff ff ff    	jne    11a56 <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   11b35:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b38:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b3c:	89 c2                	mov    %eax,%edx
   11b3e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b41:	01 d0                	add    %edx,%eax
   11b43:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11b46:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b49:	83 c0 01             	add    $0x1,%eax
   11b4c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b50:	89 c2                	mov    %eax,%edx
   11b52:	8b 45 08             	mov    0x8(%ebp),%eax
   11b55:	01 c2                	add    %eax,%edx
   11b57:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11b5b:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11b5d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11b64:	eb 2f                	jmp    11b95 <filter+0x2b4>
   11b66:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b69:	83 c0 01             	add    $0x1,%eax
   11b6c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b70:	89 c2                	mov    %eax,%edx
   11b72:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b75:	01 d0                	add    %edx,%eax
   11b77:	8d 50 01             	lea    0x1(%eax),%edx
   11b7a:	8b 45 08             	mov    0x8(%ebp),%eax
   11b7d:	01 c2                	add    %eax,%edx
   11b7f:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11b83:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   11b87:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b8a:	01 c8                	add    %ecx,%eax
   11b8c:	0f b6 00             	movzbl (%eax),%eax
   11b8f:	88 02                	mov    %al,(%edx)
   11b91:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11b95:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b98:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11b9b:	75 c9                	jne    11b66 <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11b9d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11ba1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11ba4:	3b 45 14             	cmp    0x14(%ebp),%eax
   11ba7:	0f 85 a0 fe ff ff    	jne    11a4d <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11bad:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11bb1:	eb 18                	jmp    11bcb <filter+0x2ea>
   11bb3:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11bb7:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11bbb:	83 ec 0c             	sub    $0xc,%esp
   11bbe:	50                   	push   %eax
   11bbf:	e8 9e 17 ff ff       	call   3362 <lodepng_free>
   11bc4:	83 c4 10             	add    $0x10,%esp
   11bc7:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11bcb:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11bcf:	75 e2                	jne    11bb3 <filter+0x2d2>
   11bd1:	e9 ea 04 00 00       	jmp    120c0 <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   11bd6:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   11bda:	0f 85 17 02 00 00    	jne    11df7 <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   11be0:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   11be7:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11bee:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11bf5:	eb 33                	jmp    11c2a <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11bf7:	83 ec 0c             	sub    $0xc,%esp
   11bfa:	ff 75 b4             	pushl  -0x4c(%ebp)
   11bfd:	e8 3f 17 ff ff       	call   3341 <lodepng_malloc>
   11c02:	83 c4 10             	add    $0x10,%esp
   11c05:	89 c2                	mov    %eax,%edx
   11c07:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c0a:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11c11:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c14:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11c1b:	85 c0                	test   %eax,%eax
   11c1d:	75 07                	jne    11c26 <filter+0x345>
   11c1f:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11c26:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11c2a:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11c2e:	75 c7                	jne    11bf7 <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11c30:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11c34:	0f 85 8f 01 00 00    	jne    11dc9 <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   11c3a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11c41:	e9 77 01 00 00       	jmp    11dbd <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11c46:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11c4d:	e9 f4 00 00 00       	jmp    11d46 <filter+0x465>
          size_t sum = 0;
   11c52:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11c59:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c5c:	0f b6 d0             	movzbl %al,%edx
   11c5f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c62:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c66:	89 c1                	mov    %eax,%ecx
   11c68:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c6b:	01 c1                	add    %eax,%ecx
   11c6d:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c70:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11c77:	83 ec 08             	sub    $0x8,%esp
   11c7a:	52                   	push   %edx
   11c7b:	ff 75 b0             	pushl  -0x50(%ebp)
   11c7e:	ff 75 b4             	pushl  -0x4c(%ebp)
   11c81:	ff 75 f4             	pushl  -0xc(%ebp)
   11c84:	51                   	push   %ecx
   11c85:	50                   	push   %eax
   11c86:	e8 4c f8 ff ff       	call   114d7 <filterScanline>
   11c8b:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   11c8e:	83 ec 04             	sub    $0x4,%esp
   11c91:	68 00 04 00 00       	push   $0x400
   11c96:	6a 00                	push   $0x0
   11c98:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11c9e:	50                   	push   %eax
   11c9f:	e8 0e 17 ff ff       	call   33b2 <lodepng_memset>
   11ca4:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   11ca7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11cae:	eb 2a                	jmp    11cda <filter+0x3f9>
   11cb0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11cb3:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   11cba:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11cbd:	01 d0                	add    %edx,%eax
   11cbf:	0f b6 00             	movzbl (%eax),%eax
   11cc2:	0f b6 c0             	movzbl %al,%eax
   11cc5:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   11ccc:	83 c2 01             	add    $0x1,%edx
   11ccf:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   11cd6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11cda:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11cdd:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11ce0:	75 ce                	jne    11cb0 <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   11ce2:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11ce5:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11cec:	8d 50 01             	lea    0x1(%eax),%edx
   11cef:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11cf2:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   11cf9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d00:	eb 1d                	jmp    11d1f <filter+0x43e>
            sum += ilog2i(count[x]);
   11d02:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d05:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11d0c:	83 ec 0c             	sub    $0xc,%esp
   11d0f:	50                   	push   %eax
   11d10:	e8 80 fb ff ff       	call   11895 <ilog2i>
   11d15:	83 c4 10             	add    $0x10,%esp
   11d18:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   11d1b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d1f:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   11d26:	75 da                	jne    11d02 <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   11d28:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   11d2c:	74 08                	je     11d36 <filter+0x455>
   11d2e:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11d31:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   11d34:	7e 0c                	jle    11d42 <filter+0x461>
            bestType = type;
   11d36:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d39:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   11d3c:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11d3f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11d42:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11d46:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11d4a:	0f 85 02 ff ff ff    	jne    11c52 <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   11d50:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d53:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d57:	89 c2                	mov    %eax,%edx
   11d59:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d5c:	01 d0                	add    %edx,%eax
   11d5e:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11d61:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d64:	83 c0 01             	add    $0x1,%eax
   11d67:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d6b:	89 c2                	mov    %eax,%edx
   11d6d:	8b 45 08             	mov    0x8(%ebp),%eax
   11d70:	01 d0                	add    %edx,%eax
   11d72:	8b 55 cc             	mov    -0x34(%ebp),%edx
   11d75:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11d77:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d7e:	eb 31                	jmp    11db1 <filter+0x4d0>
   11d80:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d83:	83 c0 01             	add    $0x1,%eax
   11d86:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d8a:	89 c2                	mov    %eax,%edx
   11d8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d8f:	01 d0                	add    %edx,%eax
   11d91:	8d 50 01             	lea    0x1(%eax),%edx
   11d94:	8b 45 08             	mov    0x8(%ebp),%eax
   11d97:	01 c2                	add    %eax,%edx
   11d99:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11d9c:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   11da3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11da6:	01 c8                	add    %ecx,%eax
   11da8:	0f b6 00             	movzbl (%eax),%eax
   11dab:	88 02                	mov    %al,(%edx)
   11dad:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11db1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11db4:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11db7:	75 c7                	jne    11d80 <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11db9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11dbd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11dc0:	3b 45 14             	cmp    0x14(%ebp),%eax
   11dc3:	0f 85 7d fe ff ff    	jne    11c46 <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11dc9:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11dd0:	eb 1a                	jmp    11dec <filter+0x50b>
   11dd2:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11dd5:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11ddc:	83 ec 0c             	sub    $0xc,%esp
   11ddf:	50                   	push   %eax
   11de0:	e8 7d 15 ff ff       	call   3362 <lodepng_free>
   11de5:	83 c4 10             	add    $0x10,%esp
   11de8:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11dec:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11df0:	75 e0                	jne    11dd2 <filter+0x4f1>
   11df2:	e9 c9 02 00 00       	jmp    120c0 <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   11df7:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   11dfb:	0f 85 89 00 00 00    	jne    11e8a <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   11e01:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11e08:	eb 73                	jmp    11e7d <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11e0a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e0d:	83 c0 01             	add    $0x1,%eax
   11e10:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e14:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   11e17:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e1a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e1e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   11e21:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11e24:	8b 50 30             	mov    0x30(%eax),%edx
   11e27:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e2a:	01 d0                	add    %edx,%eax
   11e2c:	0f b6 00             	movzbl (%eax),%eax
   11e2f:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   11e32:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11e35:	8b 45 08             	mov    0x8(%ebp),%eax
   11e38:	01 c2                	add    %eax,%edx
   11e3a:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11e3e:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11e40:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11e44:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   11e47:	8b 55 0c             	mov    0xc(%ebp),%edx
   11e4a:	01 d1                	add    %edx,%ecx
   11e4c:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11e4f:	8d 5a 01             	lea    0x1(%edx),%ebx
   11e52:	8b 55 08             	mov    0x8(%ebp),%edx
   11e55:	01 da                	add    %ebx,%edx
   11e57:	83 ec 08             	sub    $0x8,%esp
   11e5a:	50                   	push   %eax
   11e5b:	ff 75 b0             	pushl  -0x50(%ebp)
   11e5e:	ff 75 b4             	pushl  -0x4c(%ebp)
   11e61:	ff 75 f4             	pushl  -0xc(%ebp)
   11e64:	51                   	push   %ecx
   11e65:	52                   	push   %edx
   11e66:	e8 6c f6 ff ff       	call   114d7 <filterScanline>
   11e6b:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   11e6e:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   11e71:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e74:	01 d0                	add    %edx,%eax
   11e76:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   11e79:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11e7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e80:	3b 45 14             	cmp    0x14(%ebp),%eax
   11e83:	75 85                	jne    11e0a <filter+0x529>
   11e85:	e9 36 02 00 00       	jmp    120c0 <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   11e8a:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   11e8e:	0f 85 25 02 00 00    	jne    120b9 <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11e94:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   11e9b:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11ea2:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   11ea9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11eac:	83 ec 04             	sub    $0x4,%esp
   11eaf:	6a 24                	push   $0x24
   11eb1:	50                   	push   %eax
   11eb2:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11eb8:	50                   	push   %eax
   11eb9:	e8 c1 14 ff ff       	call   337f <lodepng_memcpy>
   11ebe:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   11ec1:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   11ec8:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   11ecb:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   11ed2:	00 00 00 
    zlibsettings.custom_deflate = 0;
   11ed5:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   11edc:	00 00 00 
    for(type = 0; type != 5; ++type) {
   11edf:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11ee6:	eb 33                	jmp    11f1b <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11ee8:	83 ec 0c             	sub    $0xc,%esp
   11eeb:	ff 75 b4             	pushl  -0x4c(%ebp)
   11eee:	e8 4e 14 ff ff       	call   3341 <lodepng_malloc>
   11ef3:	83 c4 10             	add    $0x10,%esp
   11ef6:	89 c2                	mov    %eax,%edx
   11ef8:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11efb:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11f02:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f05:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11f0c:	85 c0                	test   %eax,%eax
   11f0e:	75 07                	jne    11f17 <filter+0x636>
   11f10:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   11f17:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   11f1b:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   11f1f:	75 c7                	jne    11ee8 <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   11f21:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11f25:	0f 85 63 01 00 00    	jne    1208e <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   11f2b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11f32:	e9 4b 01 00 00       	jmp    12082 <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   11f37:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11f3e:	e9 c8 00 00 00       	jmp    1200b <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   11f43:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f46:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11f49:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f4c:	0f b6 d0             	movzbl %al,%edx
   11f4f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f52:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11f56:	89 c1                	mov    %eax,%ecx
   11f58:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f5b:	01 c1                	add    %eax,%ecx
   11f5d:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f60:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11f67:	83 ec 08             	sub    $0x8,%esp
   11f6a:	52                   	push   %edx
   11f6b:	ff 75 b0             	pushl  -0x50(%ebp)
   11f6e:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f71:	ff 75 f4             	pushl  -0xc(%ebp)
   11f74:	51                   	push   %ecx
   11f75:	50                   	push   %eax
   11f76:	e8 5c f5 ff ff       	call   114d7 <filterScanline>
   11f7b:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   11f7e:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f81:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   11f88:	00 00 00 00 
          dummy = 0;
   11f8c:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   11f93:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   11f96:	8b 55 ac             	mov    -0x54(%ebp),%edx
   11f99:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f9c:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11fa3:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   11fa9:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   11fac:	c1 e3 02             	shl    $0x2,%ebx
   11faf:	01 cb                	add    %ecx,%ebx
   11fb1:	83 ec 0c             	sub    $0xc,%esp
   11fb4:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   11fba:	51                   	push   %ecx
   11fbb:	52                   	push   %edx
   11fbc:	50                   	push   %eax
   11fbd:	53                   	push   %ebx
   11fbe:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   11fc4:	50                   	push   %eax
   11fc5:	e8 87 60 ff ff       	call   8051 <zlib_compress>
   11fca:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   11fcd:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   11fd3:	83 ec 0c             	sub    $0xc,%esp
   11fd6:	50                   	push   %eax
   11fd7:	e8 86 13 ff ff       	call   3362 <lodepng_free>
   11fdc:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   11fdf:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   11fe3:	74 0f                	je     11ff4 <filter+0x713>
   11fe5:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fe8:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   11fef:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   11ff2:	7d 13                	jge    12007 <filter+0x726>
            bestType = type;
   11ff4:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11ff7:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   11ffa:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11ffd:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   12004:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   12007:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   1200b:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   1200f:	0f 85 2e ff ff ff    	jne    11f43 <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   12015:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12018:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1201c:	89 c2                	mov    %eax,%edx
   1201e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12021:	01 d0                	add    %edx,%eax
   12023:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   12026:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12029:	83 c0 01             	add    $0x1,%eax
   1202c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12030:	89 c2                	mov    %eax,%edx
   12032:	8b 45 08             	mov    0x8(%ebp),%eax
   12035:	01 d0                	add    %edx,%eax
   12037:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1203a:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   1203c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12043:	eb 31                	jmp    12076 <filter+0x795>
   12045:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12048:	83 c0 01             	add    $0x1,%eax
   1204b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1204f:	89 c2                	mov    %eax,%edx
   12051:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12054:	01 d0                	add    %edx,%eax
   12056:	8d 50 01             	lea    0x1(%eax),%edx
   12059:	8b 45 08             	mov    0x8(%ebp),%eax
   1205c:	01 c2                	add    %eax,%edx
   1205e:	8b 45 bc             	mov    -0x44(%ebp),%eax
   12061:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   12068:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1206b:	01 c8                	add    %ecx,%eax
   1206d:	0f b6 00             	movzbl (%eax),%eax
   12070:	88 02                	mov    %al,(%edx)
   12072:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12076:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12079:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1207c:	75 c7                	jne    12045 <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   1207e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12082:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12085:	3b 45 14             	cmp    0x14(%ebp),%eax
   12088:	0f 85 a9 fe ff ff    	jne    11f37 <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   1208e:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12095:	eb 1a                	jmp    120b1 <filter+0x7d0>
   12097:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1209a:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   120a1:	83 ec 0c             	sub    $0xc,%esp
   120a4:	50                   	push   %eax
   120a5:	e8 b8 12 ff ff       	call   3362 <lodepng_free>
   120aa:	83 c4 10             	add    $0x10,%esp
   120ad:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   120b1:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   120b5:	75 e0                	jne    12097 <filter+0x7b6>
   120b7:	eb 07                	jmp    120c0 <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   120b9:	b8 58 00 00 00       	mov    $0x58,%eax
   120be:	eb 03                	jmp    120c3 <filter+0x7e2>

  return error;
   120c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   120c3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   120c6:	c9                   	leave  
   120c7:	c3                   	ret    

000120c8 <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   120c8:	55                   	push   %ebp
   120c9:	89 e5                	mov    %esp,%ebp
   120cb:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   120ce:	8b 45 10             	mov    0x10(%ebp),%eax
   120d1:	2b 45 14             	sub    0x14(%ebp),%eax
   120d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   120d7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   120de:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   120e5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   120ec:	eb 65                	jmp    12153 <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   120ee:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   120f5:	eb 2a                	jmp    12121 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   120f7:	ff 75 0c             	pushl  0xc(%ebp)
   120fa:	8d 45 e8             	lea    -0x18(%ebp),%eax
   120fd:	50                   	push   %eax
   120fe:	e8 9d 60 ff ff       	call   81a0 <readBitFromReversedStream>
   12103:	83 c4 08             	add    $0x8,%esp
   12106:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   12109:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   1210d:	50                   	push   %eax
   1210e:	ff 75 08             	pushl  0x8(%ebp)
   12111:	8d 45 ec             	lea    -0x14(%ebp),%eax
   12114:	50                   	push   %eax
   12115:	e8 08 61 ff ff       	call   8222 <setBitOfReversedStream>
   1211a:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   1211d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12121:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12124:	3b 45 14             	cmp    0x14(%ebp),%eax
   12127:	7c ce                	jl     120f7 <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   12129:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12130:	eb 15                	jmp    12147 <addPaddingBits+0x7f>
   12132:	6a 00                	push   $0x0
   12134:	ff 75 08             	pushl  0x8(%ebp)
   12137:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1213a:	50                   	push   %eax
   1213b:	e8 e2 60 ff ff       	call   8222 <setBitOfReversedStream>
   12140:	83 c4 0c             	add    $0xc,%esp
   12143:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12147:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1214a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1214d:	75 e3                	jne    12132 <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   1214f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12153:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12156:	3b 45 18             	cmp    0x18(%ebp),%eax
   12159:	75 93                	jne    120ee <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   1215b:	90                   	nop
   1215c:	c9                   	leave  
   1215d:	c3                   	ret    

0001215e <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   1215e:	55                   	push   %ebp
   1215f:	89 e5                	mov    %esp,%ebp
   12161:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   12167:	ff 75 18             	pushl  0x18(%ebp)
   1216a:	ff 75 14             	pushl  0x14(%ebp)
   1216d:	ff 75 10             	pushl  0x10(%ebp)
   12170:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   12176:	50                   	push   %eax
   12177:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   1217d:	50                   	push   %eax
   1217e:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12184:	50                   	push   %eax
   12185:	8d 45 94             	lea    -0x6c(%ebp),%eax
   12188:	50                   	push   %eax
   12189:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1218c:	50                   	push   %eax
   1218d:	e8 fc ae ff ff       	call   d08e <Adam7_getpassvalues>
   12192:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   12195:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   12199:	0f 86 0a 01 00 00    	jbe    122a9 <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   1219f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   121a6:	e9 ef 00 00 00       	jmp    1229a <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   121ab:	8b 45 18             	mov    0x18(%ebp),%eax
   121ae:	c1 e8 03             	shr    $0x3,%eax
   121b1:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   121b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   121bb:	e9 c6 00 00 00       	jmp    12286 <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   121c0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   121c7:	e9 a6 00 00 00       	jmp    12272 <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   121cc:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121cf:	8b 14 85 18 a0 01 00 	mov    0x1a018(,%eax,4),%edx
   121d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121d9:	8b 04 85 50 a0 01 00 	mov    0x1a050(,%eax,4),%eax
   121e0:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   121e4:	01 d0                	add    %edx,%eax
   121e6:	0f af 45 10          	imul   0x10(%ebp),%eax
   121ea:	89 c2                	mov    %eax,%edx
   121ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121ef:	8b 04 85 34 a0 01 00 	mov    0x1a034(,%eax,4),%eax
   121f6:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   121fa:	01 c2                	add    %eax,%edx
   121fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121ff:	8b 04 85 fc 9f 01 00 	mov    0x19ffc(,%eax,4),%eax
   12206:	01 c2                	add    %eax,%edx
   12208:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1220b:	0f af c2             	imul   %edx,%eax
   1220e:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   12211:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12214:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   1221b:	89 c1                	mov    %eax,%ecx
   1221d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12220:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12224:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   12228:	89 c2                	mov    %eax,%edx
   1222a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1222d:	01 c2                	add    %eax,%edx
   1222f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12232:	0f af c2             	imul   %edx,%eax
   12235:	01 c8                	add    %ecx,%eax
   12237:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   1223a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12241:	eb 23                	jmp    12266 <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   12243:	8b 55 d8             	mov    -0x28(%ebp),%edx
   12246:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12249:	01 c2                	add    %eax,%edx
   1224b:	8b 45 08             	mov    0x8(%ebp),%eax
   1224e:	01 c2                	add    %eax,%edx
   12250:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   12253:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12256:	01 c1                	add    %eax,%ecx
   12258:	8b 45 0c             	mov    0xc(%ebp),%eax
   1225b:	01 c8                	add    %ecx,%eax
   1225d:	0f b6 00             	movzbl (%eax),%eax
   12260:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   12262:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12266:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12269:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1226c:	72 d5                	jb     12243 <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   1226e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12272:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12275:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12279:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   1227c:	0f 87 4a ff ff ff    	ja     121cc <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   12282:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12286:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12289:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   1228d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12290:	0f 87 2a ff ff ff    	ja     121c0 <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   12296:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1229a:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   1229e:	0f 85 07 ff ff ff    	jne    121ab <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   122a4:	e9 22 01 00 00       	jmp    123cb <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   122a9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   122b0:	e9 0c 01 00 00       	jmp    123c1 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   122b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122b8:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   122bc:	0f af 45 18          	imul   0x18(%ebp),%eax
   122c0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   122c3:	8b 45 18             	mov    0x18(%ebp),%eax
   122c6:	0f af 45 10          	imul   0x10(%ebp),%eax
   122ca:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   122cd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   122d4:	e9 d4 00 00 00       	jmp    123ad <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   122d9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   122e0:	e9 b4 00 00 00       	jmp    12399 <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   122e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122e8:	8b 14 85 18 a0 01 00 	mov    0x1a018(,%eax,4),%edx
   122ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122f2:	8b 04 85 50 a0 01 00 	mov    0x1a050(,%eax,4),%eax
   122f9:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   122fd:	01 d0                	add    %edx,%eax
   122ff:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   12303:	89 c2                	mov    %eax,%edx
   12305:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12308:	8b 0c 85 fc 9f 01 00 	mov    0x19ffc(,%eax,4),%ecx
   1230f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12312:	8b 04 85 34 a0 01 00 	mov    0x1a034(,%eax,4),%eax
   12319:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1231d:	01 c8                	add    %ecx,%eax
   1231f:	0f af 45 18          	imul   0x18(%ebp),%eax
   12323:	01 d0                	add    %edx,%eax
   12325:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   1232b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1232e:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   12335:	c1 e0 03             	shl    $0x3,%eax
   12338:	89 c1                	mov    %eax,%ecx
   1233a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1233d:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   12341:	89 c2                	mov    %eax,%edx
   12343:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12346:	0f af 45 18          	imul   0x18(%ebp),%eax
   1234a:	01 d0                	add    %edx,%eax
   1234c:	01 c8                	add    %ecx,%eax
   1234e:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   12354:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1235b:	eb 30                	jmp    1238d <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   1235d:	ff 75 0c             	pushl  0xc(%ebp)
   12360:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   12366:	50                   	push   %eax
   12367:	e8 34 5e ff ff       	call   81a0 <readBitFromReversedStream>
   1236c:	83 c4 08             	add    $0x8,%esp
   1236f:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   12372:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   12376:	50                   	push   %eax
   12377:	ff 75 08             	pushl  0x8(%ebp)
   1237a:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   12380:	50                   	push   %eax
   12381:	e8 9c 5e ff ff       	call   8222 <setBitOfReversedStream>
   12386:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   12389:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1238d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12390:	3b 45 18             	cmp    0x18(%ebp),%eax
   12393:	72 c8                	jb     1235d <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12395:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12399:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1239c:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   123a0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   123a3:	0f 87 3c ff ff ff    	ja     122e5 <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   123a9:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   123ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123b0:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   123b4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   123b7:	0f 87 1c ff ff ff    	ja     122d9 <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   123bd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   123c1:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   123c5:	0f 85 ea fe ff ff    	jne    122b5 <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   123cb:	90                   	nop
   123cc:	c9                   	leave  
   123cd:	c3                   	ret    

000123ce <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   123ce:	55                   	push   %ebp
   123cf:	89 e5                	mov    %esp,%ebp
   123d1:	57                   	push   %edi
   123d2:	56                   	push   %esi
   123d3:	53                   	push   %ebx
   123d4:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   123da:	8b 45 1c             	mov    0x1c(%ebp),%eax
   123dd:	83 c0 0c             	add    $0xc,%eax
   123e0:	50                   	push   %eax
   123e1:	e8 77 6a ff ff       	call   8e5d <lodepng_get_bpp>
   123e6:	83 c4 04             	add    $0x4,%esp
   123e9:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   123ec:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   123f3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   123f6:	8b 40 08             	mov    0x8(%eax),%eax
   123f9:	85 c0                	test   %eax,%eax
   123fb:	0f 85 49 01 00 00    	jne    1254a <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   12401:	8b 45 14             	mov    0x14(%ebp),%eax
   12404:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12408:	83 c0 07             	add    $0x7,%eax
   1240b:	c1 e8 03             	shr    $0x3,%eax
   1240e:	83 c0 01             	add    $0x1,%eax
   12411:	0f af 45 18          	imul   0x18(%ebp),%eax
   12415:	89 c2                	mov    %eax,%edx
   12417:	8b 45 0c             	mov    0xc(%ebp),%eax
   1241a:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   1241c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1241f:	8b 00                	mov    (%eax),%eax
   12421:	83 ec 0c             	sub    $0xc,%esp
   12424:	50                   	push   %eax
   12425:	e8 17 0f ff ff       	call   3341 <lodepng_malloc>
   1242a:	83 c4 10             	add    $0x10,%esp
   1242d:	89 c2                	mov    %eax,%edx
   1242f:	8b 45 08             	mov    0x8(%ebp),%eax
   12432:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   12434:	8b 45 08             	mov    0x8(%ebp),%eax
   12437:	8b 00                	mov    (%eax),%eax
   12439:	85 c0                	test   %eax,%eax
   1243b:	75 10                	jne    1244d <preProcessScanlines+0x7f>
   1243d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12440:	8b 00                	mov    (%eax),%eax
   12442:	85 c0                	test   %eax,%eax
   12444:	74 07                	je     1244d <preProcessScanlines+0x7f>
   12446:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   1244d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12451:	0f 85 fb 02 00 00    	jne    12752 <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   12457:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   1245b:	0f 87 bd 00 00 00    	ja     1251e <preProcessScanlines+0x150>
   12461:	8b 45 14             	mov    0x14(%ebp),%eax
   12464:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12468:	89 c2                	mov    %eax,%edx
   1246a:	8b 45 14             	mov    0x14(%ebp),%eax
   1246d:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12471:	83 c0 07             	add    $0x7,%eax
   12474:	c1 e8 03             	shr    $0x3,%eax
   12477:	c1 e0 03             	shl    $0x3,%eax
   1247a:	39 c2                	cmp    %eax,%edx
   1247c:	0f 84 9c 00 00 00    	je     1251e <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   12482:	8b 45 14             	mov    0x14(%ebp),%eax
   12485:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12489:	83 c0 07             	add    $0x7,%eax
   1248c:	c1 e8 03             	shr    $0x3,%eax
   1248f:	0f af 45 18          	imul   0x18(%ebp),%eax
   12493:	83 ec 0c             	sub    $0xc,%esp
   12496:	50                   	push   %eax
   12497:	e8 a5 0e ff ff       	call   3341 <lodepng_malloc>
   1249c:	83 c4 10             	add    $0x10,%esp
   1249f:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   124a2:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   124a6:	75 07                	jne    124af <preProcessScanlines+0xe1>
   124a8:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   124af:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   124b3:	75 56                	jne    1250b <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   124b5:	8b 45 14             	mov    0x14(%ebp),%eax
   124b8:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   124bc:	89 c2                	mov    %eax,%edx
   124be:	8b 45 14             	mov    0x14(%ebp),%eax
   124c1:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   124c5:	83 c0 07             	add    $0x7,%eax
   124c8:	c1 e8 03             	shr    $0x3,%eax
   124cb:	c1 e0 03             	shl    $0x3,%eax
   124ce:	83 ec 0c             	sub    $0xc,%esp
   124d1:	ff 75 18             	pushl  0x18(%ebp)
   124d4:	52                   	push   %edx
   124d5:	50                   	push   %eax
   124d6:	ff 75 10             	pushl  0x10(%ebp)
   124d9:	ff 75 d8             	pushl  -0x28(%ebp)
   124dc:	e8 e7 fb ff ff       	call   120c8 <addPaddingBits>
   124e1:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   124e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   124e7:	8d 50 0c             	lea    0xc(%eax),%edx
   124ea:	8b 45 08             	mov    0x8(%ebp),%eax
   124ed:	8b 00                	mov    (%eax),%eax
   124ef:	83 ec 08             	sub    $0x8,%esp
   124f2:	ff 75 20             	pushl  0x20(%ebp)
   124f5:	52                   	push   %edx
   124f6:	ff 75 18             	pushl  0x18(%ebp)
   124f9:	ff 75 14             	pushl  0x14(%ebp)
   124fc:	ff 75 d8             	pushl  -0x28(%ebp)
   124ff:	50                   	push   %eax
   12500:	e8 dc f3 ff ff       	call   118e1 <filter>
   12505:	83 c4 20             	add    $0x20,%esp
   12508:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   1250b:	83 ec 0c             	sub    $0xc,%esp
   1250e:	ff 75 d8             	pushl  -0x28(%ebp)
   12511:	e8 4c 0e ff ff       	call   3362 <lodepng_free>
   12516:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   12519:	e9 34 02 00 00       	jmp    12752 <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   1251e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12521:	8d 50 0c             	lea    0xc(%eax),%edx
   12524:	8b 45 08             	mov    0x8(%ebp),%eax
   12527:	8b 00                	mov    (%eax),%eax
   12529:	83 ec 08             	sub    $0x8,%esp
   1252c:	ff 75 20             	pushl  0x20(%ebp)
   1252f:	52                   	push   %edx
   12530:	ff 75 18             	pushl  0x18(%ebp)
   12533:	ff 75 14             	pushl  0x14(%ebp)
   12536:	ff 75 10             	pushl  0x10(%ebp)
   12539:	50                   	push   %eax
   1253a:	e8 a2 f3 ff ff       	call   118e1 <filter>
   1253f:	83 c4 20             	add    $0x20,%esp
   12542:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   12545:	e9 08 02 00 00       	jmp    12752 <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   1254a:	ff 75 dc             	pushl  -0x24(%ebp)
   1254d:	ff 75 18             	pushl  0x18(%ebp)
   12550:	ff 75 14             	pushl  0x14(%ebp)
   12553:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   12559:	50                   	push   %eax
   1255a:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   12560:	50                   	push   %eax
   12561:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   12567:	50                   	push   %eax
   12568:	8d 45 98             	lea    -0x68(%ebp),%eax
   1256b:	50                   	push   %eax
   1256c:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   1256f:	50                   	push   %eax
   12570:	e8 19 ab ff ff       	call   d08e <Adam7_getpassvalues>
   12575:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   12578:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   1257e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12581:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12583:	8b 45 0c             	mov    0xc(%ebp),%eax
   12586:	8b 00                	mov    (%eax),%eax
   12588:	83 ec 0c             	sub    $0xc,%esp
   1258b:	50                   	push   %eax
   1258c:	e8 b0 0d ff ff       	call   3341 <lodepng_malloc>
   12591:	83 c4 10             	add    $0x10,%esp
   12594:	89 c2                	mov    %eax,%edx
   12596:	8b 45 08             	mov    0x8(%ebp),%eax
   12599:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   1259b:	8b 45 08             	mov    0x8(%ebp),%eax
   1259e:	8b 00                	mov    (%eax),%eax
   125a0:	85 c0                	test   %eax,%eax
   125a2:	75 07                	jne    125ab <preProcessScanlines+0x1dd>
   125a4:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   125ab:	8b 45 94             	mov    -0x6c(%ebp),%eax
   125ae:	83 ec 0c             	sub    $0xc,%esp
   125b1:	50                   	push   %eax
   125b2:	e8 8a 0d ff ff       	call   3341 <lodepng_malloc>
   125b7:	83 c4 10             	add    $0x10,%esp
   125ba:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   125bd:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   125c1:	75 0e                	jne    125d1 <preProcessScanlines+0x203>
   125c3:	8b 45 94             	mov    -0x6c(%ebp),%eax
   125c6:	85 c0                	test   %eax,%eax
   125c8:	74 07                	je     125d1 <preProcessScanlines+0x203>
   125ca:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   125d1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   125d5:	0f 85 69 01 00 00    	jne    12744 <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   125db:	83 ec 0c             	sub    $0xc,%esp
   125de:	ff 75 dc             	pushl  -0x24(%ebp)
   125e1:	ff 75 18             	pushl  0x18(%ebp)
   125e4:	ff 75 14             	pushl  0x14(%ebp)
   125e7:	ff 75 10             	pushl  0x10(%ebp)
   125ea:	ff 75 d4             	pushl  -0x2c(%ebp)
   125ed:	e8 6c fb ff ff       	call   1215e <Adam7_interlace>
   125f2:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   125f5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   125fc:	e9 36 01 00 00       	jmp    12737 <preProcessScanlines+0x369>
        if(bpp < 8) {
   12601:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   12605:	0f 87 d6 00 00 00    	ja     126e1 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   1260b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1260e:	83 c0 01             	add    $0x1,%eax
   12611:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   12618:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1261b:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   12622:	29 c2                	sub    %eax,%edx
   12624:	89 d0                	mov    %edx,%eax
   12626:	83 ec 0c             	sub    $0xc,%esp
   12629:	50                   	push   %eax
   1262a:	e8 12 0d ff ff       	call   3341 <lodepng_malloc>
   1262f:	83 c4 10             	add    $0x10,%esp
   12632:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   12635:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   12639:	75 0c                	jne    12647 <preProcessScanlines+0x279>
   1263b:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   12642:	e9 fd 00 00 00       	jmp    12744 <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   12647:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1264a:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   1264e:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12651:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12655:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   12659:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   1265b:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1265e:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12662:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   12666:	83 c2 07             	add    $0x7,%edx
   12669:	c1 ea 03             	shr    $0x3,%edx
   1266c:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   1266f:	89 d1                	mov    %edx,%ecx
   12671:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12674:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   1267b:	89 d6                	mov    %edx,%esi
   1267d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   12680:	01 f2                	add    %esi,%edx
   12682:	83 ec 0c             	sub    $0xc,%esp
   12685:	50                   	push   %eax
   12686:	53                   	push   %ebx
   12687:	51                   	push   %ecx
   12688:	52                   	push   %edx
   12689:	ff 75 d0             	pushl  -0x30(%ebp)
   1268c:	e8 37 fa ff ff       	call   120c8 <addPaddingBits>
   12691:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   12694:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12697:	8d 58 0c             	lea    0xc(%eax),%ebx
   1269a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1269d:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   126a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126a4:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   126a8:	8b 4d 08             	mov    0x8(%ebp),%ecx
   126ab:	8b 31                	mov    (%ecx),%esi
   126ad:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   126b0:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   126b7:	01 f1                	add    %esi,%ecx
   126b9:	83 ec 08             	sub    $0x8,%esp
   126bc:	ff 75 20             	pushl  0x20(%ebp)
   126bf:	53                   	push   %ebx
   126c0:	52                   	push   %edx
   126c1:	50                   	push   %eax
   126c2:	ff 75 d0             	pushl  -0x30(%ebp)
   126c5:	51                   	push   %ecx
   126c6:	e8 16 f2 ff ff       	call   118e1 <filter>
   126cb:	83 c4 20             	add    $0x20,%esp
   126ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   126d1:	83 ec 0c             	sub    $0xc,%esp
   126d4:	ff 75 d0             	pushl  -0x30(%ebp)
   126d7:	e8 86 0c ff ff       	call   3362 <lodepng_free>
   126dc:	83 c4 10             	add    $0x10,%esp
   126df:	eb 4c                	jmp    1272d <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   126e1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   126e4:	8d 70 0c             	lea    0xc(%eax),%esi
   126e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126ea:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   126ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126f1:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   126f5:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   126f8:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   126ff:	89 cb                	mov    %ecx,%ebx
   12701:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   12704:	01 cb                	add    %ecx,%ebx
   12706:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12709:	8b 39                	mov    (%ecx),%edi
   1270b:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1270e:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12715:	01 f9                	add    %edi,%ecx
   12717:	83 ec 08             	sub    $0x8,%esp
   1271a:	ff 75 20             	pushl  0x20(%ebp)
   1271d:	56                   	push   %esi
   1271e:	52                   	push   %edx
   1271f:	50                   	push   %eax
   12720:	53                   	push   %ebx
   12721:	51                   	push   %ecx
   12722:	e8 ba f1 ff ff       	call   118e1 <filter>
   12727:	83 c4 20             	add    $0x20,%esp
   1272a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   1272d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12731:	75 10                	jne    12743 <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   12733:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   12737:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   1273b:	0f 85 c0 fe ff ff    	jne    12601 <preProcessScanlines+0x233>
   12741:	eb 01                	jmp    12744 <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12743:	90                   	nop
      }
    }

    lodepng_free(adam7);
   12744:	83 ec 0c             	sub    $0xc,%esp
   12747:	ff 75 d4             	pushl  -0x2c(%ebp)
   1274a:	e8 13 0c ff ff       	call   3362 <lodepng_free>
   1274f:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   12752:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   12755:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12758:	5b                   	pop    %ebx
   12759:	5e                   	pop    %esi
   1275a:	5f                   	pop    %edi
   1275b:	5d                   	pop    %ebp
   1275c:	c3                   	ret    

0001275d <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   1275d:	55                   	push   %ebp
   1275e:	89 e5                	mov    %esp,%ebp
   12760:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   12763:	8b 45 0c             	mov    0xc(%ebp),%eax
   12766:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   12769:	eb 47                	jmp    127b2 <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   1276b:	8b 45 08             	mov    0x8(%ebp),%eax
   1276e:	8d 50 04             	lea    0x4(%eax),%edx
   12771:	8b 45 08             	mov    0x8(%ebp),%eax
   12774:	ff 75 fc             	pushl  -0x4(%ebp)
   12777:	52                   	push   %edx
   12778:	50                   	push   %eax
   12779:	e8 73 5f ff ff       	call   86f1 <lodepng_chunk_append>
   1277e:	83 c4 0c             	add    $0xc,%esp
   12781:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12784:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   12788:	74 05                	je     1278f <addUnknownChunks+0x32>
   1278a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1278d:	eb 37                	jmp    127c6 <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   1278f:	8b 45 08             	mov    0x8(%ebp),%eax
   12792:	8b 50 04             	mov    0x4(%eax),%edx
   12795:	8b 45 08             	mov    0x8(%ebp),%eax
   12798:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   1279b:	8b 55 10             	mov    0x10(%ebp),%edx
   1279e:	8b 45 0c             	mov    0xc(%ebp),%eax
   127a1:	01 d0                	add    %edx,%eax
   127a3:	50                   	push   %eax
   127a4:	ff 75 fc             	pushl  -0x4(%ebp)
   127a7:	e8 ff 5c ff ff       	call   84ab <lodepng_chunk_next>
   127ac:	83 c4 08             	add    $0x8,%esp
   127af:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   127b2:	8b 55 fc             	mov    -0x4(%ebp),%edx
   127b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   127b8:	29 c2                	sub    %eax,%edx
   127ba:	89 d0                	mov    %edx,%eax
   127bc:	3b 45 10             	cmp    0x10(%ebp),%eax
   127bf:	7c aa                	jl     1276b <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   127c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
   127c6:	c9                   	leave  
   127c7:	c3                   	ret    

000127c8 <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   127c8:	55                   	push   %ebp
   127c9:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   127cb:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   127cf:	77 07                	ja     127d8 <isGrayICCProfile+0x10>
   127d1:	b8 00 00 00 00       	mov    $0x0,%eax
   127d6:	eb 40                	jmp    12818 <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   127d8:	8b 45 08             	mov    0x8(%ebp),%eax
   127db:	83 c0 10             	add    $0x10,%eax
   127de:	0f b6 00             	movzbl (%eax),%eax
   127e1:	3c 47                	cmp    $0x47,%al
   127e3:	75 2e                	jne    12813 <isGrayICCProfile+0x4b>
   127e5:	8b 45 08             	mov    0x8(%ebp),%eax
   127e8:	83 c0 11             	add    $0x11,%eax
   127eb:	0f b6 00             	movzbl (%eax),%eax
   127ee:	3c 52                	cmp    $0x52,%al
   127f0:	75 21                	jne    12813 <isGrayICCProfile+0x4b>
   127f2:	8b 45 08             	mov    0x8(%ebp),%eax
   127f5:	83 c0 12             	add    $0x12,%eax
   127f8:	0f b6 00             	movzbl (%eax),%eax
   127fb:	3c 41                	cmp    $0x41,%al
   127fd:	75 14                	jne    12813 <isGrayICCProfile+0x4b>
   127ff:	8b 45 08             	mov    0x8(%ebp),%eax
   12802:	83 c0 13             	add    $0x13,%eax
   12805:	0f b6 00             	movzbl (%eax),%eax
   12808:	3c 59                	cmp    $0x59,%al
   1280a:	75 07                	jne    12813 <isGrayICCProfile+0x4b>
   1280c:	b8 01 00 00 00       	mov    $0x1,%eax
   12811:	eb 05                	jmp    12818 <isGrayICCProfile+0x50>
   12813:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12818:	5d                   	pop    %ebp
   12819:	c3                   	ret    

0001281a <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   1281a:	55                   	push   %ebp
   1281b:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   1281d:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12821:	77 07                	ja     1282a <isRGBICCProfile+0x10>
   12823:	b8 00 00 00 00       	mov    $0x0,%eax
   12828:	eb 40                	jmp    1286a <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   1282a:	8b 45 08             	mov    0x8(%ebp),%eax
   1282d:	83 c0 10             	add    $0x10,%eax
   12830:	0f b6 00             	movzbl (%eax),%eax
   12833:	3c 52                	cmp    $0x52,%al
   12835:	75 2e                	jne    12865 <isRGBICCProfile+0x4b>
   12837:	8b 45 08             	mov    0x8(%ebp),%eax
   1283a:	83 c0 11             	add    $0x11,%eax
   1283d:	0f b6 00             	movzbl (%eax),%eax
   12840:	3c 47                	cmp    $0x47,%al
   12842:	75 21                	jne    12865 <isRGBICCProfile+0x4b>
   12844:	8b 45 08             	mov    0x8(%ebp),%eax
   12847:	83 c0 12             	add    $0x12,%eax
   1284a:	0f b6 00             	movzbl (%eax),%eax
   1284d:	3c 42                	cmp    $0x42,%al
   1284f:	75 14                	jne    12865 <isRGBICCProfile+0x4b>
   12851:	8b 45 08             	mov    0x8(%ebp),%eax
   12854:	83 c0 13             	add    $0x13,%eax
   12857:	0f b6 00             	movzbl (%eax),%eax
   1285a:	3c 20                	cmp    $0x20,%al
   1285c:	75 07                	jne    12865 <isRGBICCProfile+0x4b>
   1285e:	b8 01 00 00 00       	mov    $0x1,%eax
   12863:	eb 05                	jmp    1286a <isRGBICCProfile+0x50>
   12865:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1286a:	5d                   	pop    %ebp
   1286b:	c3                   	ret    

0001286c <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   1286c:	55                   	push   %ebp
   1286d:	89 e5                	mov    %esp,%ebp
   1286f:	57                   	push   %edi
   12870:	56                   	push   %esi
   12871:	53                   	push   %ebx
   12872:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   12878:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   1287f:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   12886:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12889:	6a 00                	push   $0x0
   1288b:	6a 00                	push   $0x0
   1288d:	50                   	push   %eax
   1288e:	e8 6f 0d ff ff       	call   3602 <ucvector_init>
   12893:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   12896:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12899:	05 98 00 00 00       	add    $0x98,%eax
   1289e:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   128a1:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   128a7:	50                   	push   %eax
   128a8:	e8 3a 71 ff ff       	call   99e7 <lodepng_info_init>
   128ad:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   128b0:	8b 45 08             	mov    0x8(%ebp),%eax
   128b3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   128b9:	8b 45 0c             	mov    0xc(%ebp),%eax
   128bc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   128c2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128c5:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   128cc:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   128cf:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128d2:	8b 40 0c             	mov    0xc(%eax),%eax
   128d5:	83 f8 03             	cmp    $0x3,%eax
   128d8:	74 0a                	je     128e4 <lodepng_encode+0x78>
   128da:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128dd:	8b 40 6c             	mov    0x6c(%eax),%eax
   128e0:	85 c0                	test   %eax,%eax
   128e2:	74 29                	je     1290d <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   128e4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128e7:	8b 40 18             	mov    0x18(%eax),%eax
   128ea:	85 c0                	test   %eax,%eax
   128ec:	74 0d                	je     128fb <lodepng_encode+0x8f>
   128ee:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128f1:	8b 40 18             	mov    0x18(%eax),%eax
   128f4:	3d 00 01 00 00       	cmp    $0x100,%eax
   128f9:	7e 12                	jle    1290d <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   128fb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128fe:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   12905:	00 00 00 
    goto cleanup;
   12908:	e9 78 0c 00 00       	jmp    13585 <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   1290d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12910:	8b 40 38             	mov    0x38(%eax),%eax
   12913:	83 f8 02             	cmp    $0x2,%eax
   12916:	76 12                	jbe    1292a <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   12918:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1291b:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   12922:	00 00 00 
    goto cleanup;
   12925:	e9 5b 0c 00 00       	jmp    13585 <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   1292a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1292d:	8b 40 08             	mov    0x8(%eax),%eax
   12930:	83 f8 01             	cmp    $0x1,%eax
   12933:	76 12                	jbe    12947 <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   12935:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12938:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   1293f:	00 00 00 
    goto cleanup;
   12942:	e9 3e 0c 00 00       	jmp    13585 <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   12947:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1294a:	8b 50 10             	mov    0x10(%eax),%edx
   1294d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12950:	8b 40 0c             	mov    0xc(%eax),%eax
   12953:	52                   	push   %edx
   12954:	50                   	push   %eax
   12955:	e8 a4 5f ff ff       	call   88fe <checkColorValidity>
   1295a:	83 c4 08             	add    $0x8,%esp
   1295d:	89 c2                	mov    %eax,%edx
   1295f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12962:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12968:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1296b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12971:	85 c0                	test   %eax,%eax
   12973:	0f 85 c6 0b 00 00    	jne    1353f <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   12979:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1297c:	8b 50 7c             	mov    0x7c(%eax),%edx
   1297f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12982:	8b 40 78             	mov    0x78(%eax),%eax
   12985:	52                   	push   %edx
   12986:	50                   	push   %eax
   12987:	e8 72 5f ff ff       	call   88fe <checkColorValidity>
   1298c:	83 c4 08             	add    $0x8,%esp
   1298f:	89 c2                	mov    %eax,%edx
   12991:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12994:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   1299a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1299d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   129a3:	85 c0                	test   %eax,%eax
   129a5:	0f 85 97 0b 00 00    	jne    13542 <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   129ab:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129ae:	05 98 00 00 00       	add    $0x98,%eax
   129b3:	83 ec 08             	sub    $0x8,%esp
   129b6:	50                   	push   %eax
   129b7:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   129bd:	50                   	push   %eax
   129be:	e8 58 71 ff ff       	call   9b1b <lodepng_info_copy>
   129c3:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   129c6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129c9:	8b 40 5c             	mov    0x5c(%eax),%eax
   129cc:	85 c0                	test   %eax,%eax
   129ce:	0f 84 3c 02 00 00    	je     12c10 <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   129d4:	83 ec 0c             	sub    $0xc,%esp
   129d7:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   129dd:	50                   	push   %eax
   129de:	e8 5f 96 ff ff       	call   c042 <lodepng_color_stats_init>
   129e3:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   129e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129e9:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   129ef:	85 c0                	test   %eax,%eax
   129f1:	74 2d                	je     12a20 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   129f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129f6:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   129fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129ff:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12a05:	83 ec 08             	sub    $0x8,%esp
   12a08:	52                   	push   %edx
   12a09:	50                   	push   %eax
   12a0a:	e8 b9 fd ff ff       	call   127c8 <isGrayICCProfile>
   12a0f:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12a12:	85 c0                	test   %eax,%eax
   12a14:	74 0a                	je     12a20 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   12a16:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   12a1d:	00 00 00 
    }
    if(info_png->iccp_defined &&
   12a20:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a23:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12a29:	85 c0                	test   %eax,%eax
   12a2b:	74 2d                	je     12a5a <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12a2d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a30:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12a36:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a39:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12a3f:	83 ec 08             	sub    $0x8,%esp
   12a42:	52                   	push   %edx
   12a43:	50                   	push   %eax
   12a44:	e8 d1 fd ff ff       	call   1281a <isRGBICCProfile>
   12a49:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   12a4c:	85 c0                	test   %eax,%eax
   12a4e:	74 0a                	je     12a5a <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   12a50:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   12a57:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   12a5a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a5d:	83 c0 78             	add    $0x78,%eax
   12a60:	83 ec 0c             	sub    $0xc,%esp
   12a63:	50                   	push   %eax
   12a64:	ff 75 18             	pushl  0x18(%ebp)
   12a67:	ff 75 14             	pushl  0x14(%ebp)
   12a6a:	ff 75 10             	pushl  0x10(%ebp)
   12a6d:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12a73:	50                   	push   %eax
   12a74:	e8 e0 96 ff ff       	call   c159 <lodepng_compute_color_stats>
   12a79:	83 c4 20             	add    $0x20,%esp
   12a7c:	89 c2                	mov    %eax,%edx
   12a7e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a81:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12a87:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a8a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12a90:	85 c0                	test   %eax,%eax
   12a92:	0f 85 ad 0a 00 00    	jne    13545 <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   12a98:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a9b:	8b 40 2c             	mov    0x2c(%eax),%eax
   12a9e:	85 c0                	test   %eax,%eax
   12aa0:	0f 84 be 00 00 00    	je     12b64 <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   12aa6:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   12aad:	00 00 00 
   12ab0:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   12ab7:	00 00 00 
   12aba:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   12ac1:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   12ac4:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   12aca:	83 ec 04             	sub    $0x4,%esp
   12acd:	6a 10                	push   $0x10
   12acf:	6a 02                	push   $0x2
   12ad1:	50                   	push   %eax
   12ad2:	e8 15 61 ff ff       	call   8bec <lodepng_color_mode_make>
   12ad7:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   12ada:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12add:	8d 58 0c             	lea    0xc(%eax),%ebx
   12ae0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ae3:	8b 48 38             	mov    0x38(%eax),%ecx
   12ae6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ae9:	8b 50 34             	mov    0x34(%eax),%edx
   12aec:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12aef:	8b 40 30             	mov    0x30(%eax),%eax
   12af2:	53                   	push   %ebx
   12af3:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   12af9:	53                   	push   %ebx
   12afa:	51                   	push   %ecx
   12afb:	52                   	push   %edx
   12afc:	50                   	push   %eax
   12afd:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   12b03:	50                   	push   %eax
   12b04:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   12b0a:	50                   	push   %eax
   12b0b:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   12b11:	50                   	push   %eax
   12b12:	e8 8a 92 ff ff       	call   bda1 <lodepng_convert_rgb>
   12b17:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   12b1a:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   12b20:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   12b26:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   12b2c:	83 ec 0c             	sub    $0xc,%esp
   12b2f:	68 ff ff 00 00       	push   $0xffff
   12b34:	51                   	push   %ecx
   12b35:	52                   	push   %edx
   12b36:	50                   	push   %eax
   12b37:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12b3d:	50                   	push   %eax
   12b3e:	e8 26 a1 ff ff       	call   cc69 <lodepng_color_stats_add>
   12b43:	83 c4 20             	add    $0x20,%esp
   12b46:	89 c2                	mov    %eax,%edx
   12b48:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b4b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12b51:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b54:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12b5a:	85 c0                	test   %eax,%eax
   12b5c:	74 06                	je     12b64 <lodepng_encode+0x2f8>
   12b5e:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   12b5f:	e9 e1 09 00 00       	jmp    13545 <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   12b64:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b67:	8d 50 78             	lea    0x78(%eax),%edx
   12b6a:	83 ec 04             	sub    $0x4,%esp
   12b6d:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12b73:	50                   	push   %eax
   12b74:	52                   	push   %edx
   12b75:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12b7b:	83 c0 0c             	add    $0xc,%eax
   12b7e:	50                   	push   %eax
   12b7f:	e8 79 a1 ff ff       	call   ccfd <auto_choose_color>
   12b84:	83 c4 10             	add    $0x10,%esp
   12b87:	89 c2                	mov    %eax,%edx
   12b89:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b8c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12b92:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b95:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12b9b:	85 c0                	test   %eax,%eax
   12b9d:	0f 85 a5 09 00 00    	jne    13548 <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   12ba3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ba6:	8b 40 2c             	mov    0x2c(%eax),%eax
   12ba9:	85 c0                	test   %eax,%eax
   12bab:	74 63                	je     12c10 <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   12bad:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bb0:	8d 58 0c             	lea    0xc(%eax),%ebx
   12bb3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bb6:	8b 48 38             	mov    0x38(%eax),%ecx
   12bb9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bbc:	8b 50 34             	mov    0x34(%eax),%edx
   12bbf:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bc2:	8b 40 30             	mov    0x30(%eax),%eax
   12bc5:	53                   	push   %ebx
   12bc6:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   12bcc:	83 c3 0c             	add    $0xc,%ebx
   12bcf:	53                   	push   %ebx
   12bd0:	51                   	push   %ecx
   12bd1:	52                   	push   %edx
   12bd2:	50                   	push   %eax
   12bd3:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12bd9:	83 c0 38             	add    $0x38,%eax
   12bdc:	50                   	push   %eax
   12bdd:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12be3:	83 c0 34             	add    $0x34,%eax
   12be6:	50                   	push   %eax
   12be7:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12bed:	83 c0 30             	add    $0x30,%eax
   12bf0:	50                   	push   %eax
   12bf1:	e8 ab 91 ff ff       	call   bda1 <lodepng_convert_rgb>
   12bf6:	83 c4 20             	add    $0x20,%esp
   12bf9:	85 c0                	test   %eax,%eax
   12bfb:	74 13                	je     12c10 <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   12bfd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c00:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   12c07:	00 00 00 
        goto cleanup;
   12c0a:	90                   	nop
   12c0b:	e9 75 09 00 00       	jmp    13585 <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   12c10:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c13:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12c19:	85 c0                	test   %eax,%eax
   12c1b:	0f 84 b2 00 00 00    	je     12cd3 <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12c21:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c24:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12c2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c2d:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12c33:	83 ec 08             	sub    $0x8,%esp
   12c36:	52                   	push   %edx
   12c37:	50                   	push   %eax
   12c38:	e8 8b fb ff ff       	call   127c8 <isGrayICCProfile>
   12c3d:	83 c4 10             	add    $0x10,%esp
   12c40:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12c43:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c46:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12c4c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c4f:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12c55:	83 ec 08             	sub    $0x8,%esp
   12c58:	52                   	push   %edx
   12c59:	50                   	push   %eax
   12c5a:	e8 bb fb ff ff       	call   1281a <isRGBICCProfile>
   12c5f:	83 c4 10             	add    $0x10,%esp
   12c62:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   12c65:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12c6b:	85 c0                	test   %eax,%eax
   12c6d:	74 0b                	je     12c7a <lodepng_encode+0x40e>
   12c6f:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12c75:	83 f8 04             	cmp    $0x4,%eax
   12c78:	75 07                	jne    12c81 <lodepng_encode+0x415>
   12c7a:	b8 01 00 00 00       	mov    $0x1,%eax
   12c7f:	eb 05                	jmp    12c86 <lodepng_encode+0x41a>
   12c81:	b8 00 00 00 00       	mov    $0x0,%eax
   12c86:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   12c89:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12c8d:	75 18                	jne    12ca7 <lodepng_encode+0x43b>
   12c8f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12c93:	75 12                	jne    12ca7 <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   12c95:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c98:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   12c9f:	00 00 00 
      goto cleanup;
   12ca2:	e9 de 08 00 00       	jmp    13585 <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   12ca7:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12caa:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   12cad:	74 24                	je     12cd3 <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   12caf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cb2:	8b 40 5c             	mov    0x5c(%eax),%eax
   12cb5:	85 c0                	test   %eax,%eax
   12cb7:	74 07                	je     12cc0 <lodepng_encode+0x454>
   12cb9:	ba 66 00 00 00       	mov    $0x66,%edx
   12cbe:	eb 05                	jmp    12cc5 <lodepng_encode+0x459>
   12cc0:	ba 65 00 00 00       	mov    $0x65,%edx
   12cc5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cc8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   12cce:	e9 b2 08 00 00       	jmp    13585 <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   12cd3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cd6:	83 c0 78             	add    $0x78,%eax
   12cd9:	83 ec 08             	sub    $0x8,%esp
   12cdc:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   12ce2:	83 c2 0c             	add    $0xc,%edx
   12ce5:	52                   	push   %edx
   12ce6:	50                   	push   %eax
   12ce7:	e8 57 5f ff ff       	call   8c43 <lodepng_color_mode_equal>
   12cec:	83 c4 10             	add    $0x10,%esp
   12cef:	85 c0                	test   %eax,%eax
   12cf1:	0f 85 f8 00 00 00    	jne    12def <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   12cf7:	8b 55 14             	mov    0x14(%ebp),%edx
   12cfa:	8b 45 18             	mov    0x18(%ebp),%eax
   12cfd:	89 d3                	mov    %edx,%ebx
   12cff:	0f af d8             	imul   %eax,%ebx
   12d02:	83 ec 0c             	sub    $0xc,%esp
   12d05:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d0b:	83 c0 0c             	add    $0xc,%eax
   12d0e:	50                   	push   %eax
   12d0f:	e8 49 61 ff ff       	call   8e5d <lodepng_get_bpp>
   12d14:	83 c4 10             	add    $0x10,%esp
   12d17:	0f af c3             	imul   %ebx,%eax
   12d1a:	83 c0 07             	add    $0x7,%eax
   12d1d:	c1 e8 03             	shr    $0x3,%eax
   12d20:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   12d23:	83 ec 0c             	sub    $0xc,%esp
   12d26:	ff 75 cc             	pushl  -0x34(%ebp)
   12d29:	e8 13 06 ff ff       	call   3341 <lodepng_malloc>
   12d2e:	83 c4 10             	add    $0x10,%esp
   12d31:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   12d34:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12d38:	75 13                	jne    12d4d <lodepng_encode+0x4e1>
   12d3a:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   12d3e:	74 0d                	je     12d4d <lodepng_encode+0x4e1>
   12d40:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d43:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   12d4a:	00 00 00 
    if(!state->error) {
   12d4d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d50:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d56:	85 c0                	test   %eax,%eax
   12d58:	75 33                	jne    12d8d <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   12d5a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d5d:	83 c0 78             	add    $0x78,%eax
   12d60:	83 ec 08             	sub    $0x8,%esp
   12d63:	ff 75 18             	pushl  0x18(%ebp)
   12d66:	ff 75 14             	pushl  0x14(%ebp)
   12d69:	50                   	push   %eax
   12d6a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d70:	83 c0 0c             	add    $0xc,%eax
   12d73:	50                   	push   %eax
   12d74:	ff 75 10             	pushl  0x10(%ebp)
   12d77:	ff 75 c8             	pushl  -0x38(%ebp)
   12d7a:	e8 c9 8c ff ff       	call   ba48 <lodepng_convert>
   12d7f:	83 c4 20             	add    $0x20,%esp
   12d82:	89 c2                	mov    %eax,%edx
   12d84:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d87:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   12d8d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d90:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d96:	85 c0                	test   %eax,%eax
   12d98:	75 35                	jne    12dcf <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   12d9a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d9d:	83 c0 38             	add    $0x38,%eax
   12da0:	83 ec 04             	sub    $0x4,%esp
   12da3:	50                   	push   %eax
   12da4:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12daa:	50                   	push   %eax
   12dab:	ff 75 18             	pushl  0x18(%ebp)
   12dae:	ff 75 14             	pushl  0x14(%ebp)
   12db1:	ff 75 c8             	pushl  -0x38(%ebp)
   12db4:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12db7:	50                   	push   %eax
   12db8:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12dbb:	50                   	push   %eax
   12dbc:	e8 0d f6 ff ff       	call   123ce <preProcessScanlines>
   12dc1:	83 c4 20             	add    $0x20,%esp
   12dc4:	89 c2                	mov    %eax,%edx
   12dc6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dc9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   12dcf:	83 ec 0c             	sub    $0xc,%esp
   12dd2:	ff 75 c8             	pushl  -0x38(%ebp)
   12dd5:	e8 88 05 ff ff       	call   3362 <lodepng_free>
   12dda:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   12ddd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12de0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12de6:	85 c0                	test   %eax,%eax
   12de8:	74 4b                	je     12e35 <lodepng_encode+0x5c9>
   12dea:	e9 96 07 00 00       	jmp    13585 <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   12def:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12df2:	83 c0 38             	add    $0x38,%eax
   12df5:	83 ec 04             	sub    $0x4,%esp
   12df8:	50                   	push   %eax
   12df9:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12dff:	50                   	push   %eax
   12e00:	ff 75 18             	pushl  0x18(%ebp)
   12e03:	ff 75 14             	pushl  0x14(%ebp)
   12e06:	ff 75 10             	pushl  0x10(%ebp)
   12e09:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12e0c:	50                   	push   %eax
   12e0d:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12e10:	50                   	push   %eax
   12e11:	e8 b8 f5 ff ff       	call   123ce <preProcessScanlines>
   12e16:	83 c4 20             	add    $0x20,%esp
   12e19:	89 c2                	mov    %eax,%edx
   12e1b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e1e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e24:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e27:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e2d:	85 c0                	test   %eax,%eax
   12e2f:	0f 85 16 07 00 00    	jne    1354b <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   12e35:	83 ec 0c             	sub    $0xc,%esp
   12e38:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e3b:	50                   	push   %eax
   12e3c:	e8 21 d9 ff ff       	call   10762 <writeSignature>
   12e41:	83 c4 10             	add    $0x10,%esp
   12e44:	89 c2                	mov    %eax,%edx
   12e46:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e49:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e4f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e52:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e58:	85 c0                	test   %eax,%eax
   12e5a:	0f 85 ee 06 00 00    	jne    1354e <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   12e60:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   12e66:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   12e6c:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12e72:	83 ec 08             	sub    $0x8,%esp
   12e75:	51                   	push   %ecx
   12e76:	52                   	push   %edx
   12e77:	50                   	push   %eax
   12e78:	ff 75 18             	pushl  0x18(%ebp)
   12e7b:	ff 75 14             	pushl  0x14(%ebp)
   12e7e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e81:	50                   	push   %eax
   12e82:	e8 4a d9 ff ff       	call   107d1 <addChunk_IHDR>
   12e87:	83 c4 20             	add    $0x20,%esp
   12e8a:	89 c2                	mov    %eax,%edx
   12e8c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e8f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e95:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e98:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e9e:	85 c0                	test   %eax,%eax
   12ea0:	0f 85 ab 06 00 00    	jne    13551 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   12ea6:	8b 45 98             	mov    -0x68(%ebp),%eax
   12ea9:	85 c0                	test   %eax,%eax
   12eab:	74 33                	je     12ee0 <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   12ead:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   12eb0:	8b 45 98             	mov    -0x68(%ebp),%eax
   12eb3:	83 ec 04             	sub    $0x4,%esp
   12eb6:	52                   	push   %edx
   12eb7:	50                   	push   %eax
   12eb8:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12ebb:	50                   	push   %eax
   12ebc:	e8 9c f8 ff ff       	call   1275d <addUnknownChunks>
   12ec1:	83 c4 10             	add    $0x10,%esp
   12ec4:	89 c2                	mov    %eax,%edx
   12ec6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ec9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12ecf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ed2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ed8:	85 c0                	test   %eax,%eax
   12eda:	0f 85 74 06 00 00    	jne    13554 <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   12ee0:	8b 45 88             	mov    -0x78(%ebp),%eax
   12ee3:	85 c0                	test   %eax,%eax
   12ee5:	74 39                	je     12f20 <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   12ee7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12eea:	83 c0 38             	add    $0x38,%eax
   12eed:	83 ec 04             	sub    $0x4,%esp
   12ef0:	50                   	push   %eax
   12ef1:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12ef7:	50                   	push   %eax
   12ef8:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12efb:	50                   	push   %eax
   12efc:	e8 a4 e4 ff ff       	call   113a5 <addChunk_iCCP>
   12f01:	83 c4 10             	add    $0x10,%esp
   12f04:	89 c2                	mov    %eax,%edx
   12f06:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f09:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f0f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f12:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f18:	85 c0                	test   %eax,%eax
   12f1a:	0f 85 37 06 00 00    	jne    13557 <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   12f20:	8b 45 80             	mov    -0x80(%ebp),%eax
   12f23:	85 c0                	test   %eax,%eax
   12f25:	74 32                	je     12f59 <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   12f27:	83 ec 08             	sub    $0x8,%esp
   12f2a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f30:	50                   	push   %eax
   12f31:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f34:	50                   	push   %eax
   12f35:	e8 41 e4 ff ff       	call   1137b <addChunk_sRGB>
   12f3a:	83 c4 10             	add    $0x10,%esp
   12f3d:	89 c2                	mov    %eax,%edx
   12f3f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f42:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f48:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f4b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f51:	85 c0                	test   %eax,%eax
   12f53:	0f 85 01 06 00 00    	jne    1355a <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   12f59:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   12f5f:	85 c0                	test   %eax,%eax
   12f61:	74 32                	je     12f95 <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   12f63:	83 ec 08             	sub    $0x8,%esp
   12f66:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f6c:	50                   	push   %eax
   12f6d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f70:	50                   	push   %eax
   12f71:	e8 a7 e2 ff ff       	call   1121d <addChunk_gAMA>
   12f76:	83 c4 10             	add    $0x10,%esp
   12f79:	89 c2                	mov    %eax,%edx
   12f7b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f7e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f84:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f87:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f8d:	85 c0                	test   %eax,%eax
   12f8f:	0f 85 c8 05 00 00    	jne    1355d <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   12f95:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   12f9b:	85 c0                	test   %eax,%eax
   12f9d:	74 32                	je     12fd1 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   12f9f:	83 ec 08             	sub    $0x8,%esp
   12fa2:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12fa8:	50                   	push   %eax
   12fa9:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12fac:	50                   	push   %eax
   12fad:	e8 c1 e2 ff ff       	call   11273 <addChunk_cHRM>
   12fb2:	83 c4 10             	add    $0x10,%esp
   12fb5:	89 c2                	mov    %eax,%edx
   12fb7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fba:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12fc0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fc3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12fc9:	85 c0                	test   %eax,%eax
   12fcb:	0f 85 8f 05 00 00    	jne    13560 <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   12fd1:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12fd7:	83 f8 03             	cmp    $0x3,%eax
   12fda:	75 35                	jne    13011 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   12fdc:	83 ec 08             	sub    $0x8,%esp
   12fdf:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12fe5:	83 c0 0c             	add    $0xc,%eax
   12fe8:	50                   	push   %eax
   12fe9:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12fec:	50                   	push   %eax
   12fed:	e8 78 d8 ff ff       	call   1086a <addChunk_PLTE>
   12ff2:	83 c4 10             	add    $0x10,%esp
   12ff5:	89 c2                	mov    %eax,%edx
   12ff7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ffa:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13000:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13003:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13009:	85 c0                	test   %eax,%eax
   1300b:	0f 85 52 05 00 00    	jne    13563 <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   13011:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13014:	8b 40 6c             	mov    0x6c(%eax),%eax
   13017:	85 c0                	test   %eax,%eax
   13019:	74 4b                	je     13066 <lodepng_encode+0x7fa>
   1301b:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13021:	83 f8 02             	cmp    $0x2,%eax
   13024:	74 0b                	je     13031 <lodepng_encode+0x7c5>
   13026:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1302c:	83 f8 06             	cmp    $0x6,%eax
   1302f:	75 35                	jne    13066 <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   13031:	83 ec 08             	sub    $0x8,%esp
   13034:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1303a:	83 c0 0c             	add    $0xc,%eax
   1303d:	50                   	push   %eax
   1303e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13041:	50                   	push   %eax
   13042:	e8 23 d8 ff ff       	call   1086a <addChunk_PLTE>
   13047:	83 c4 10             	add    $0x10,%esp
   1304a:	89 c2                	mov    %eax,%edx
   1304c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1304f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13055:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13058:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1305e:	85 c0                	test   %eax,%eax
   13060:	0f 85 00 05 00 00    	jne    13566 <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   13066:	83 ec 08             	sub    $0x8,%esp
   13069:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1306f:	83 c0 0c             	add    $0xc,%eax
   13072:	50                   	push   %eax
   13073:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13076:	50                   	push   %eax
   13077:	e8 c4 d8 ff ff       	call   10940 <addChunk_tRNS>
   1307c:	83 c4 10             	add    $0x10,%esp
   1307f:	89 c2                	mov    %eax,%edx
   13081:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13084:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1308a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1308d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13093:	85 c0                	test   %eax,%eax
   13095:	0f 85 ce 04 00 00    	jne    13569 <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   1309b:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   130a1:	85 c0                	test   %eax,%eax
   130a3:	74 32                	je     130d7 <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   130a5:	83 ec 08             	sub    $0x8,%esp
   130a8:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130ae:	50                   	push   %eax
   130af:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130b2:	50                   	push   %eax
   130b3:	e8 e4 de ff ff       	call   10f9c <addChunk_bKGD>
   130b8:	83 c4 10             	add    $0x10,%esp
   130bb:	89 c2                	mov    %eax,%edx
   130bd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130c0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   130c6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130c9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130cf:	85 c0                	test   %eax,%eax
   130d1:	0f 85 95 04 00 00    	jne    1356c <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   130d7:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   130dd:	85 c0                	test   %eax,%eax
   130df:	74 32                	je     13113 <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   130e1:	83 ec 08             	sub    $0x8,%esp
   130e4:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130ea:	50                   	push   %eax
   130eb:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130ee:	50                   	push   %eax
   130ef:	e8 ac e0 ff ff       	call   111a0 <addChunk_pHYs>
   130f4:	83 c4 10             	add    $0x10,%esp
   130f7:	89 c2                	mov    %eax,%edx
   130f9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130fc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13102:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13105:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1310b:	85 c0                	test   %eax,%eax
   1310d:	0f 85 5c 04 00 00    	jne    1356f <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   13113:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13116:	85 c0                	test   %eax,%eax
   13118:	74 33                	je     1314d <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   1311a:	8b 55 a8             	mov    -0x58(%ebp),%edx
   1311d:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13120:	83 ec 04             	sub    $0x4,%esp
   13123:	52                   	push   %edx
   13124:	50                   	push   %eax
   13125:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13128:	50                   	push   %eax
   13129:	e8 2f f6 ff ff       	call   1275d <addUnknownChunks>
   1312e:	83 c4 10             	add    $0x10,%esp
   13131:	89 c2                	mov    %eax,%edx
   13133:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13136:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1313c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1313f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13145:	85 c0                	test   %eax,%eax
   13147:	0f 85 25 04 00 00    	jne    13572 <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   1314d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13150:	8d 48 38             	lea    0x38(%eax),%ecx
   13153:	8b 55 bc             	mov    -0x44(%ebp),%edx
   13156:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13159:	51                   	push   %ecx
   1315a:	52                   	push   %edx
   1315b:	50                   	push   %eax
   1315c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1315f:	50                   	push   %eax
   13160:	e8 bd d9 ff ff       	call   10b22 <addChunk_IDAT>
   13165:	83 c4 10             	add    $0x10,%esp
   13168:	89 c2                	mov    %eax,%edx
   1316a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1316d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13173:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13176:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1317c:	85 c0                	test   %eax,%eax
   1317e:	0f 85 f1 03 00 00    	jne    13575 <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   13184:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   1318a:	85 c0                	test   %eax,%eax
   1318c:	74 35                	je     131c3 <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   1318e:	83 ec 08             	sub    $0x8,%esp
   13191:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13197:	83 c0 60             	add    $0x60,%eax
   1319a:	50                   	push   %eax
   1319b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1319e:	50                   	push   %eax
   1319f:	e8 5c df ff ff       	call   11100 <addChunk_tIME>
   131a4:	83 c4 10             	add    $0x10,%esp
   131a7:	89 c2                	mov    %eax,%edx
   131a9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131ac:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   131b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131b5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   131bb:	85 c0                	test   %eax,%eax
   131bd:	0f 85 b5 03 00 00    	jne    13578 <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   131c3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   131ca:	e9 12 01 00 00       	jmp    132e1 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   131cf:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   131d5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   131d8:	c1 e2 02             	shl    $0x2,%edx
   131db:	01 d0                	add    %edx,%eax
   131dd:	8b 00                	mov    (%eax),%eax
   131df:	83 ec 0c             	sub    $0xc,%esp
   131e2:	50                   	push   %eax
   131e3:	e8 f5 01 ff ff       	call   33dd <lodepng_strlen>
   131e8:	83 c4 10             	add    $0x10,%esp
   131eb:	83 f8 4f             	cmp    $0x4f,%eax
   131ee:	7e 12                	jle    13202 <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   131f0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131f3:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   131fa:	00 00 00 
        goto cleanup;
   131fd:	e9 83 03 00 00       	jmp    13585 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   13202:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13208:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1320b:	c1 e2 02             	shl    $0x2,%edx
   1320e:	01 d0                	add    %edx,%eax
   13210:	8b 00                	mov    (%eax),%eax
   13212:	83 ec 0c             	sub    $0xc,%esp
   13215:	50                   	push   %eax
   13216:	e8 c2 01 ff ff       	call   33dd <lodepng_strlen>
   1321b:	83 c4 10             	add    $0x10,%esp
   1321e:	85 c0                	test   %eax,%eax
   13220:	7f 12                	jg     13234 <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   13222:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13225:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   1322c:	00 00 00 
        goto cleanup;
   1322f:	e9 51 03 00 00       	jmp    13585 <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   13234:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13237:	8b 40 74             	mov    0x74(%eax),%eax
   1323a:	85 c0                	test   %eax,%eax
   1323c:	74 52                	je     13290 <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   1323e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13241:	8d 48 38             	lea    0x38(%eax),%ecx
   13244:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   1324a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1324d:	c1 e2 02             	shl    $0x2,%edx
   13250:	01 d0                	add    %edx,%eax
   13252:	8b 10                	mov    (%eax),%edx
   13254:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1325a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   1325d:	c1 e3 02             	shl    $0x2,%ebx
   13260:	01 d8                	add    %ebx,%eax
   13262:	8b 00                	mov    (%eax),%eax
   13264:	51                   	push   %ecx
   13265:	52                   	push   %edx
   13266:	50                   	push   %eax
   13267:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1326a:	50                   	push   %eax
   1326b:	e8 fa d9 ff ff       	call   10c6a <addChunk_zTXt>
   13270:	83 c4 10             	add    $0x10,%esp
   13273:	89 c2                	mov    %eax,%edx
   13275:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13278:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   1327e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13281:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13287:	85 c0                	test   %eax,%eax
   13289:	74 52                	je     132dd <lodepng_encode+0xa71>
   1328b:	e9 f5 02 00 00       	jmp    13585 <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   13290:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   13296:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13299:	c1 e2 02             	shl    $0x2,%edx
   1329c:	01 d0                	add    %edx,%eax
   1329e:	8b 10                	mov    (%eax),%edx
   132a0:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   132a6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   132a9:	c1 e1 02             	shl    $0x2,%ecx
   132ac:	01 c8                	add    %ecx,%eax
   132ae:	8b 00                	mov    (%eax),%eax
   132b0:	83 ec 04             	sub    $0x4,%esp
   132b3:	52                   	push   %edx
   132b4:	50                   	push   %eax
   132b5:	8d 45 b0             	lea    -0x50(%ebp),%eax
   132b8:	50                   	push   %eax
   132b9:	e8 ec d8 ff ff       	call   10baa <addChunk_tEXt>
   132be:	83 c4 10             	add    $0x10,%esp
   132c1:	89 c2                	mov    %eax,%edx
   132c3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132c6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   132cc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132cf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   132d5:	85 c0                	test   %eax,%eax
   132d7:	0f 85 9e 02 00 00    	jne    1357b <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   132dd:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   132e1:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   132e7:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   132ea:	0f 85 df fe ff ff    	jne    131cf <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   132f0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132f3:	8b 40 70             	mov    0x70(%eax),%eax
   132f6:	85 c0                	test   %eax,%eax
   132f8:	0f 84 e3 00 00 00    	je     133e1 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   132fe:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   13305:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1330c:	e9 85 00 00 00       	jmp    13396 <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   13311:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13317:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1331a:	c1 e2 02             	shl    $0x2,%edx
   1331d:	01 d0                	add    %edx,%eax
   1331f:	8b 00                	mov    (%eax),%eax
   13321:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13324:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13327:	0f b6 00             	movzbl (%eax),%eax
   1332a:	3c 4c                	cmp    $0x4c,%al
   1332c:	75 64                	jne    13392 <lodepng_encode+0xb26>
   1332e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13331:	83 c0 01             	add    $0x1,%eax
   13334:	0f b6 00             	movzbl (%eax),%eax
   13337:	3c 6f                	cmp    $0x6f,%al
   13339:	75 57                	jne    13392 <lodepng_encode+0xb26>
   1333b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1333e:	83 c0 02             	add    $0x2,%eax
   13341:	0f b6 00             	movzbl (%eax),%eax
   13344:	3c 64                	cmp    $0x64,%al
   13346:	75 4a                	jne    13392 <lodepng_encode+0xb26>
   13348:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1334b:	83 c0 03             	add    $0x3,%eax
   1334e:	0f b6 00             	movzbl (%eax),%eax
   13351:	3c 65                	cmp    $0x65,%al
   13353:	75 3d                	jne    13392 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13355:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13358:	83 c0 04             	add    $0x4,%eax
   1335b:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   1335e:	3c 50                	cmp    $0x50,%al
   13360:	75 30                	jne    13392 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13362:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13365:	83 c0 05             	add    $0x5,%eax
   13368:	0f b6 00             	movzbl (%eax),%eax
   1336b:	3c 4e                	cmp    $0x4e,%al
   1336d:	75 23                	jne    13392 <lodepng_encode+0xb26>
   1336f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13372:	83 c0 06             	add    $0x6,%eax
   13375:	0f b6 00             	movzbl (%eax),%eax
   13378:	3c 47                	cmp    $0x47,%al
   1337a:	75 16                	jne    13392 <lodepng_encode+0xb26>
   1337c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1337f:	83 c0 07             	add    $0x7,%eax
   13382:	0f b6 00             	movzbl (%eax),%eax
   13385:	84 c0                	test   %al,%al
   13387:	75 09                	jne    13392 <lodepng_encode+0xb26>
          already_added_id_text = 1;
   13389:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   13390:	eb 13                	jmp    133a5 <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   13392:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13396:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   1339c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1339f:	0f 85 6c ff ff ff    	jne    13311 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   133a5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   133a9:	75 36                	jne    133e1 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   133ab:	a1 20 e1 01 00       	mov    0x1e120,%eax
   133b0:	83 ec 04             	sub    $0x4,%esp
   133b3:	50                   	push   %eax
   133b4:	68 e4 a0 01 00       	push   $0x1a0e4
   133b9:	8d 45 b0             	lea    -0x50(%ebp),%eax
   133bc:	50                   	push   %eax
   133bd:	e8 e8 d7 ff ff       	call   10baa <addChunk_tEXt>
   133c2:	83 c4 10             	add    $0x10,%esp
   133c5:	89 c2                	mov    %eax,%edx
   133c7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133ca:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   133d0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133d3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   133d9:	85 c0                	test   %eax,%eax
   133db:	0f 85 9d 01 00 00    	jne    1357e <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   133e1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   133e8:	e9 e6 00 00 00       	jmp    134d3 <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   133ed:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   133f3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   133f6:	c1 e2 02             	shl    $0x2,%edx
   133f9:	01 d0                	add    %edx,%eax
   133fb:	8b 00                	mov    (%eax),%eax
   133fd:	83 ec 0c             	sub    $0xc,%esp
   13400:	50                   	push   %eax
   13401:	e8 d7 ff fe ff       	call   33dd <lodepng_strlen>
   13406:	83 c4 10             	add    $0x10,%esp
   13409:	83 f8 4f             	cmp    $0x4f,%eax
   1340c:	7e 12                	jle    13420 <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   1340e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13411:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   13418:	00 00 00 
        goto cleanup;
   1341b:	e9 65 01 00 00       	jmp    13585 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   13420:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13426:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13429:	c1 e2 02             	shl    $0x2,%edx
   1342c:	01 d0                	add    %edx,%eax
   1342e:	8b 00                	mov    (%eax),%eax
   13430:	83 ec 0c             	sub    $0xc,%esp
   13433:	50                   	push   %eax
   13434:	e8 a4 ff fe ff       	call   33dd <lodepng_strlen>
   13439:	83 c4 10             	add    $0x10,%esp
   1343c:	85 c0                	test   %eax,%eax
   1343e:	7f 12                	jg     13452 <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   13440:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13443:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   1344a:	00 00 00 
        goto cleanup;
   1344d:	e9 33 01 00 00       	jmp    13585 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   13452:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13455:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13458:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   1345e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13461:	c1 e2 02             	shl    $0x2,%edx
   13464:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13466:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13468:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   1346e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13471:	c1 e2 02             	shl    $0x2,%edx
   13474:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13476:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13478:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   1347e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13481:	c1 e2 02             	shl    $0x2,%edx
   13484:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13486:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13488:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   1348e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13491:	c1 e2 02             	shl    $0x2,%edx
   13494:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13496:	8b 10                	mov    (%eax),%edx
   13498:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1349b:	8b 40 74             	mov    0x74(%eax),%eax
   1349e:	83 ec 04             	sub    $0x4,%esp
   134a1:	57                   	push   %edi
   134a2:	56                   	push   %esi
   134a3:	53                   	push   %ebx
   134a4:	51                   	push   %ecx
   134a5:	52                   	push   %edx
   134a6:	50                   	push   %eax
   134a7:	8d 45 b0             	lea    -0x50(%ebp),%eax
   134aa:	50                   	push   %eax
   134ab:	e8 dc d8 ff ff       	call   10d8c <addChunk_iTXt>
   134b0:	83 c4 20             	add    $0x20,%esp
   134b3:	89 c2                	mov    %eax,%edx
   134b5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134b8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   134be:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134c1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134c7:	85 c0                	test   %eax,%eax
   134c9:	0f 85 b2 00 00 00    	jne    13581 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   134cf:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   134d3:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   134d9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   134dc:	0f 85 0b ff ff ff    	jne    133ed <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   134e2:	8b 45 a0             	mov    -0x60(%ebp),%eax
   134e5:	85 c0                	test   %eax,%eax
   134e7:	74 2f                	je     13518 <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   134e9:	8b 55 ac             	mov    -0x54(%ebp),%edx
   134ec:	8b 45 a0             	mov    -0x60(%ebp),%eax
   134ef:	83 ec 04             	sub    $0x4,%esp
   134f2:	52                   	push   %edx
   134f3:	50                   	push   %eax
   134f4:	8d 45 b0             	lea    -0x50(%ebp),%eax
   134f7:	50                   	push   %eax
   134f8:	e8 60 f2 ff ff       	call   1275d <addUnknownChunks>
   134fd:	83 c4 10             	add    $0x10,%esp
   13500:	89 c2                	mov    %eax,%edx
   13502:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13505:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1350b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1350e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13514:	85 c0                	test   %eax,%eax
   13516:	75 6c                	jne    13584 <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   13518:	83 ec 0c             	sub    $0xc,%esp
   1351b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1351e:	50                   	push   %eax
   1351f:	e8 6d d6 ff ff       	call   10b91 <addChunk_IEND>
   13524:	83 c4 10             	add    $0x10,%esp
   13527:	89 c2                	mov    %eax,%edx
   13529:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1352c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13532:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13535:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1353b:	85 c0                	test   %eax,%eax
   1353d:	eb 46                	jmp    13585 <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   1353f:	90                   	nop
   13540:	eb 43                	jmp    13585 <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13542:	90                   	nop
   13543:	eb 40                	jmp    13585 <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   13545:	90                   	nop
   13546:	eb 3d                	jmp    13585 <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   13548:	90                   	nop
   13549:	eb 3a                	jmp    13585 <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   1354b:	90                   	nop
   1354c:	eb 37                	jmp    13585 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   1354e:	90                   	nop
   1354f:	eb 34                	jmp    13585 <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   13551:	90                   	nop
   13552:	eb 31                	jmp    13585 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   13554:	90                   	nop
   13555:	eb 2e                	jmp    13585 <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13557:	90                   	nop
   13558:	eb 2b                	jmp    13585 <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   1355a:	90                   	nop
   1355b:	eb 28                	jmp    13585 <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   1355d:	90                   	nop
   1355e:	eb 25                	jmp    13585 <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   13560:	90                   	nop
   13561:	eb 22                	jmp    13585 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13563:	90                   	nop
   13564:	eb 1f                	jmp    13585 <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13566:	90                   	nop
   13567:	eb 1c                	jmp    13585 <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   13569:	90                   	nop
   1356a:	eb 19                	jmp    13585 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   1356c:	90                   	nop
   1356d:	eb 16                	jmp    13585 <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   1356f:	90                   	nop
   13570:	eb 13                	jmp    13585 <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   13572:	90                   	nop
   13573:	eb 10                	jmp    13585 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   13575:	90                   	nop
   13576:	eb 0d                	jmp    13585 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   13578:	90                   	nop
   13579:	eb 0a                	jmp    13585 <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   1357b:	90                   	nop
   1357c:	eb 07                	jmp    13585 <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   1357e:	90                   	nop
   1357f:	eb 04                	jmp    13585 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13581:	90                   	nop
   13582:	eb 01                	jmp    13585 <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   13584:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   13585:	83 ec 0c             	sub    $0xc,%esp
   13588:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1358e:	50                   	push   %eax
   1358f:	e8 34 65 ff ff       	call   9ac8 <lodepng_info_cleanup>
   13594:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   13597:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1359a:	83 ec 0c             	sub    $0xc,%esp
   1359d:	50                   	push   %eax
   1359e:	e8 bf fd fe ff       	call   3362 <lodepng_free>
   135a3:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   135a6:	8b 55 b0             	mov    -0x50(%ebp),%edx
   135a9:	8b 45 08             	mov    0x8(%ebp),%eax
   135ac:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   135ae:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   135b1:	8b 45 0c             	mov    0xc(%ebp),%eax
   135b4:	89 10                	mov    %edx,(%eax)

  return state->error;
   135b6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135b9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   135bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
   135c2:	5b                   	pop    %ebx
   135c3:	5e                   	pop    %esi
   135c4:	5f                   	pop    %edi
   135c5:	5d                   	pop    %ebp
   135c6:	c3                   	ret    

000135c7 <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   135c7:	55                   	push   %ebp
   135c8:	89 e5                	mov    %esp,%ebp
   135ca:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   135d0:	83 ec 0c             	sub    $0xc,%esp
   135d3:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   135d9:	50                   	push   %eax
   135da:	e8 38 d0 ff ff       	call   10617 <lodepng_state_init>
   135df:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   135e2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135e5:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   135eb:	8b 45 20             	mov    0x20(%ebp),%eax
   135ee:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   135f4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135f7:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   135fd:	8b 45 20             	mov    0x20(%ebp),%eax
   13600:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   13606:	83 ec 08             	sub    $0x8,%esp
   13609:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1360f:	50                   	push   %eax
   13610:	ff 75 18             	pushl  0x18(%ebp)
   13613:	ff 75 14             	pushl  0x14(%ebp)
   13616:	ff 75 10             	pushl  0x10(%ebp)
   13619:	ff 75 0c             	pushl  0xc(%ebp)
   1361c:	ff 75 08             	pushl  0x8(%ebp)
   1361f:	e8 48 f2 ff ff       	call   1286c <lodepng_encode>
   13624:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   13627:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1362a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   1362d:	83 ec 0c             	sub    $0xc,%esp
   13630:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13636:	50                   	push   %eax
   13637:	e8 35 d0 ff ff       	call   10671 <lodepng_state_cleanup>
   1363c:	83 c4 10             	add    $0x10,%esp
  return error;
   1363f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13642:	c9                   	leave  
   13643:	c3                   	ret    

00013644 <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13644:	55                   	push   %ebp
   13645:	89 e5                	mov    %esp,%ebp
   13647:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   1364a:	83 ec 04             	sub    $0x4,%esp
   1364d:	6a 08                	push   $0x8
   1364f:	6a 06                	push   $0x6
   13651:	ff 75 18             	pushl  0x18(%ebp)
   13654:	ff 75 14             	pushl  0x14(%ebp)
   13657:	ff 75 10             	pushl  0x10(%ebp)
   1365a:	ff 75 0c             	pushl  0xc(%ebp)
   1365d:	ff 75 08             	pushl  0x8(%ebp)
   13660:	e8 62 ff ff ff       	call   135c7 <lodepng_encode_memory>
   13665:	83 c4 20             	add    $0x20,%esp
}
   13668:	c9                   	leave  
   13669:	c3                   	ret    

0001366a <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   1366a:	55                   	push   %ebp
   1366b:	89 e5                	mov    %esp,%ebp
   1366d:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   13670:	83 ec 04             	sub    $0x4,%esp
   13673:	6a 08                	push   $0x8
   13675:	6a 02                	push   $0x2
   13677:	ff 75 18             	pushl  0x18(%ebp)
   1367a:	ff 75 14             	pushl  0x14(%ebp)
   1367d:	ff 75 10             	pushl  0x10(%ebp)
   13680:	ff 75 0c             	pushl  0xc(%ebp)
   13683:	ff 75 08             	pushl  0x8(%ebp)
   13686:	e8 3c ff ff ff       	call   135c7 <lodepng_encode_memory>
   1368b:	83 c4 20             	add    $0x20,%esp
}
   1368e:	c9                   	leave  
   1368f:	c3                   	ret    

00013690 <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   13690:	55                   	push   %ebp
   13691:	89 e5                	mov    %esp,%ebp
   13693:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   13696:	83 ec 04             	sub    $0x4,%esp
   13699:	ff 75 1c             	pushl  0x1c(%ebp)
   1369c:	ff 75 18             	pushl  0x18(%ebp)
   1369f:	ff 75 14             	pushl  0x14(%ebp)
   136a2:	ff 75 10             	pushl  0x10(%ebp)
   136a5:	ff 75 0c             	pushl  0xc(%ebp)
   136a8:	8d 45 ec             	lea    -0x14(%ebp),%eax
   136ab:	50                   	push   %eax
   136ac:	8d 45 f0             	lea    -0x10(%ebp),%eax
   136af:	50                   	push   %eax
   136b0:	e8 12 ff ff ff       	call   135c7 <lodepng_encode_memory>
   136b5:	83 c4 20             	add    $0x20,%esp
   136b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   136bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   136bf:	75 19                	jne    136da <lodepng_encode_file+0x4a>
   136c1:	8b 55 ec             	mov    -0x14(%ebp),%edx
   136c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   136c7:	83 ec 04             	sub    $0x4,%esp
   136ca:	ff 75 08             	pushl  0x8(%ebp)
   136cd:	52                   	push   %edx
   136ce:	50                   	push   %eax
   136cf:	e8 36 01 ff ff       	call   380a <lodepng_save_file>
   136d4:	83 c4 10             	add    $0x10,%esp
   136d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   136da:	8b 45 f0             	mov    -0x10(%ebp),%eax
   136dd:	83 ec 0c             	sub    $0xc,%esp
   136e0:	50                   	push   %eax
   136e1:	e8 7c fc fe ff       	call   3362 <lodepng_free>
   136e6:	83 c4 10             	add    $0x10,%esp
  return error;
   136e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   136ec:	c9                   	leave  
   136ed:	c3                   	ret    

000136ee <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   136ee:	55                   	push   %ebp
   136ef:	89 e5                	mov    %esp,%ebp
   136f1:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   136f4:	83 ec 08             	sub    $0x8,%esp
   136f7:	6a 08                	push   $0x8
   136f9:	6a 06                	push   $0x6
   136fb:	ff 75 14             	pushl  0x14(%ebp)
   136fe:	ff 75 10             	pushl  0x10(%ebp)
   13701:	ff 75 0c             	pushl  0xc(%ebp)
   13704:	ff 75 08             	pushl  0x8(%ebp)
   13707:	e8 84 ff ff ff       	call   13690 <lodepng_encode_file>
   1370c:	83 c4 20             	add    $0x20,%esp
}
   1370f:	c9                   	leave  
   13710:	c3                   	ret    

00013711 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   13711:	55                   	push   %ebp
   13712:	89 e5                	mov    %esp,%ebp
   13714:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   13717:	83 ec 08             	sub    $0x8,%esp
   1371a:	6a 08                	push   $0x8
   1371c:	6a 02                	push   $0x2
   1371e:	ff 75 14             	pushl  0x14(%ebp)
   13721:	ff 75 10             	pushl  0x10(%ebp)
   13724:	ff 75 0c             	pushl  0xc(%ebp)
   13727:	ff 75 08             	pushl  0x8(%ebp)
   1372a:	e8 61 ff ff ff       	call   13690 <lodepng_encode_file>
   1372f:	83 c4 20             	add    $0x20,%esp
}
   13732:	c9                   	leave  
   13733:	c3                   	ret    

00013734 <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   13734:	55                   	push   %ebp
   13735:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   13737:	8b 45 08             	mov    0x8(%ebp),%eax
   1373a:	50                   	push   %eax
   1373b:	e8 71 49 ff ff       	call   80b1 <lodepng_compress_settings_init>
   13740:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   13743:	8b 45 08             	mov    0x8(%ebp),%eax
   13746:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   1374d:	8b 45 08             	mov    0x8(%ebp),%eax
   13750:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   13757:	8b 45 08             	mov    0x8(%ebp),%eax
   1375a:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   13761:	8b 45 08             	mov    0x8(%ebp),%eax
   13764:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   1376b:	8b 45 08             	mov    0x8(%ebp),%eax
   1376e:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   13775:	8b 45 08             	mov    0x8(%ebp),%eax
   13778:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   1377f:	8b 45 08             	mov    0x8(%ebp),%eax
   13782:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   13789:	90                   	nop
   1378a:	c9                   	leave  
   1378b:	c3                   	ret    

0001378c <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   1378c:	55                   	push   %ebp
   1378d:	89 e5                	mov    %esp,%ebp
  switch(code) {
   1378f:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   13793:	0f 87 c1 03 00 00    	ja     13b5a <lodepng_error_text+0x3ce>
   13799:	8b 45 08             	mov    0x8(%ebp),%eax
   1379c:	c1 e0 02             	shl    $0x2,%eax
   1379f:	05 20 b4 01 00       	add    $0x1b420,%eax
   137a4:	8b 00                	mov    (%eax),%eax
   137a6:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   137a8:	b8 ec a0 01 00       	mov    $0x1a0ec,%eax
   137ad:	e9 ad 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   137b2:	b8 09 a1 01 00       	mov    $0x1a109,%eax
   137b7:	e9 a3 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   137bc:	b8 1c a1 01 00       	mov    $0x1a11c,%eax
   137c1:	e9 99 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   137c6:	b8 54 a1 01 00       	mov    $0x1a154,%eax
   137cb:	e9 8f 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   137d0:	b8 8c a1 01 00       	mov    $0x1a18c,%eax
   137d5:	e9 85 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   137da:	b8 8c a1 01 00       	mov    $0x1a18c,%eax
   137df:	e9 7b 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   137e4:	b8 8c a1 01 00       	mov    $0x1a18c,%eax
   137e9:	e9 71 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   137ee:	b8 bc a1 01 00       	mov    $0x1a1bc,%eax
   137f3:	e9 67 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   137f8:	b8 f0 a1 01 00       	mov    $0x1a1f0,%eax
   137fd:	e9 5d 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   13802:	b8 24 a2 01 00       	mov    $0x1a224,%eax
   13807:	e9 53 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   1380c:	b8 f0 a1 01 00       	mov    $0x1a1f0,%eax
   13811:	e9 49 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   13816:	b8 4c a2 01 00       	mov    $0x1a24c,%eax
   1381b:	e9 3f 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   13820:	b8 84 a2 01 00       	mov    $0x1a284,%eax
   13825:	e9 35 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   1382a:	b8 f0 a1 01 00       	mov    $0x1a1f0,%eax
   1382f:	e9 2b 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   13834:	b8 bc a2 01 00       	mov    $0x1a2bc,%eax
   13839:	e9 21 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   1383e:	b8 ec a2 01 00       	mov    $0x1a2ec,%eax
   13843:	e9 17 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   13848:	b8 0c a3 01 00       	mov    $0x1a30c,%eax
   1384d:	e9 0d 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   13852:	b8 38 a3 01 00       	mov    $0x1a338,%eax
   13857:	e9 03 03 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   1385c:	b8 78 a3 01 00       	mov    $0x1a378,%eax
   13861:	e9 f9 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   13866:	b8 a0 a3 01 00       	mov    $0x1a3a0,%eax
   1386b:	e9 ef 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   13870:	b8 d4 a3 01 00       	mov    $0x1a3d4,%eax
   13875:	e9 e5 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   1387a:	b8 f8 a3 01 00       	mov    $0x1a3f8,%eax
   1387f:	e9 db 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   13884:	b8 30 a4 01 00       	mov    $0x1a430,%eax
   13889:	e9 d1 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   1388e:	b8 50 a4 01 00       	mov    $0x1a450,%eax
   13893:	e9 c7 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   13898:	b8 6f a4 01 00       	mov    $0x1a46f,%eax
   1389d:	e9 bd 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   138a2:	b8 89 a4 01 00       	mov    $0x1a489,%eax
   138a7:	e9 b3 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   138ac:	b8 a8 a4 01 00       	mov    $0x1a4a8,%eax
   138b1:	e9 a9 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   138b6:	b8 e4 a4 01 00       	mov    $0x1a4e4,%eax
   138bb:	e9 9f 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   138c0:	b8 08 a5 01 00       	mov    $0x1a508,%eax
   138c5:	e9 95 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   138ca:	b8 34 a5 01 00       	mov    $0x1a534,%eax
   138cf:	e9 8b 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   138d4:	b8 58 a5 01 00       	mov    $0x1a558,%eax
   138d9:	e9 81 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   138de:	b8 98 a5 01 00       	mov    $0x1a598,%eax
   138e3:	e9 77 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   138e8:	b8 c8 a5 01 00       	mov    $0x1a5c8,%eax
   138ed:	e9 6d 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   138f2:	b8 f0 a5 01 00       	mov    $0x1a5f0,%eax
   138f7:	e9 63 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   138fc:	b8 34 a6 01 00       	mov    $0x1a634,%eax
   13901:	e9 59 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   13906:	b8 60 a6 01 00       	mov    $0x1a660,%eax
   1390b:	e9 4f 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   13910:	b8 90 a6 01 00       	mov    $0x1a690,%eax
   13915:	e9 45 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   1391a:	b8 b8 a6 01 00       	mov    $0x1a6b8,%eax
   1391f:	e9 3b 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   13924:	b8 00 a7 01 00       	mov    $0x1a700,%eax
   13929:	e9 31 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   1392e:	b8 00 a7 01 00       	mov    $0x1a700,%eax
   13933:	e9 27 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   13938:	b8 3c a7 01 00       	mov    $0x1a73c,%eax
   1393d:	e9 1d 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   13942:	b8 70 a7 01 00       	mov    $0x1a770,%eax
   13947:	e9 13 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   1394c:	b8 93 a7 01 00       	mov    $0x1a793,%eax
   13951:	e9 09 02 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   13956:	b8 b0 a7 01 00       	mov    $0x1a7b0,%eax
   1395b:	e9 ff 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   13960:	b8 ec a7 01 00       	mov    $0x1a7ec,%eax
   13965:	e9 f5 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   1396a:	b8 1c a8 01 00       	mov    $0x1a81c,%eax
   1396f:	e9 eb 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   13974:	b8 68 a8 01 00       	mov    $0x1a868,%eax
   13979:	e9 e1 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   1397e:	b8 a0 a8 01 00       	mov    $0x1a8a0,%eax
   13983:	e9 d7 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   13988:	b8 e0 a8 01 00       	mov    $0x1a8e0,%eax
   1398d:	e9 cd 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   13992:	b8 0c a9 01 00       	mov    $0x1a90c,%eax
   13997:	e9 c3 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   1399c:	b8 58 a9 01 00       	mov    $0x1a958,%eax
   139a1:	e9 b9 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   139a6:	b8 ac a9 01 00       	mov    $0x1a9ac,%eax
   139ab:	e9 af 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   139b0:	b8 e0 a9 01 00       	mov    $0x1a9e0,%eax
   139b5:	e9 a5 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   139ba:	b8 30 aa 01 00       	mov    $0x1aa30,%eax
   139bf:	e9 9b 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   139c4:	b8 6c aa 01 00       	mov    $0x1aa6c,%eax
   139c9:	e9 91 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   139ce:	b8 cc aa 01 00       	mov    $0x1aacc,%eax
   139d3:	e9 87 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   139d8:	b8 2c ab 01 00       	mov    $0x1ab2c,%eax
   139dd:	e9 7d 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   139e2:	b8 88 ab 01 00       	mov    $0x1ab88,%eax
   139e7:	e9 73 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   139ec:	b8 cc ab 01 00       	mov    $0x1abcc,%eax
   139f1:	e9 69 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   139f6:	b8 08 ac 01 00       	mov    $0x1ac08,%eax
   139fb:	e9 5f 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   13a00:	b8 65 ac 01 00       	mov    $0x1ac65,%eax
   13a05:	e9 55 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   13a0a:	b8 7d ac 01 00       	mov    $0x1ac7d,%eax
   13a0f:	e9 4b 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   13a14:	b8 98 ac 01 00       	mov    $0x1ac98,%eax
   13a19:	e9 41 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   13a1e:	b8 d4 ac 01 00       	mov    $0x1acd4,%eax
   13a23:	e9 37 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   13a28:	b8 04 ad 01 00       	mov    $0x1ad04,%eax
   13a2d:	e9 2d 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   13a32:	b8 24 ad 01 00       	mov    $0x1ad24,%eax
   13a37:	e9 23 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   13a3c:	b8 44 ad 01 00       	mov    $0x1ad44,%eax
   13a41:	e9 19 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   13a46:	b8 64 ad 01 00       	mov    $0x1ad64,%eax
   13a4b:	e9 0f 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   13a50:	b8 88 ad 01 00       	mov    $0x1ad88,%eax
   13a55:	e9 05 01 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   13a5a:	b8 b0 ad 01 00       	mov    $0x1adb0,%eax
   13a5f:	e9 fb 00 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   13a64:	b8 0d ae 01 00       	mov    $0x1ae0d,%eax
   13a69:	e9 f1 00 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   13a6e:	b8 28 ae 01 00       	mov    $0x1ae28,%eax
   13a73:	e9 e7 00 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   13a78:	b8 64 ae 01 00       	mov    $0x1ae64,%eax
   13a7d:	e9 dd 00 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   13a82:	b8 98 ae 01 00       	mov    $0x1ae98,%eax
   13a87:	e9 d3 00 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   13a8c:	b8 ec ae 01 00       	mov    $0x1aeec,%eax
   13a91:	e9 c9 00 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   13a96:	b8 38 af 01 00       	mov    $0x1af38,%eax
   13a9b:	e9 bf 00 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   13aa0:	b8 74 af 01 00       	mov    $0x1af74,%eax
   13aa5:	e9 b5 00 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   13aaa:	b8 98 af 01 00       	mov    $0x1af98,%eax
   13aaf:	e9 ab 00 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   13ab4:	b8 b8 af 01 00       	mov    $0x1afb8,%eax
   13ab9:	e9 a1 00 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   13abe:	b8 e0 af 01 00       	mov    $0x1afe0,%eax
   13ac3:	e9 97 00 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   13ac8:	b8 00 b0 01 00       	mov    $0x1b000,%eax
   13acd:	e9 8d 00 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   13ad2:	b8 2c b0 01 00       	mov    $0x1b02c,%eax
   13ad7:	e9 83 00 00 00       	jmp    13b5f <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   13adc:	b8 5b b0 01 00       	mov    $0x1b05b,%eax
   13ae1:	eb 7c                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   13ae3:	b8 73 b0 01 00       	mov    $0x1b073,%eax
   13ae8:	eb 75                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   13aea:	b8 8b b0 01 00       	mov    $0x1b08b,%eax
   13aef:	eb 6e                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   13af1:	b8 a3 b0 01 00       	mov    $0x1b0a3,%eax
   13af6:	eb 67                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   13af8:	b8 c4 b0 01 00       	mov    $0x1b0c4,%eax
   13afd:	eb 60                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   13aff:	b8 14 b1 01 00       	mov    $0x1b114,%eax
   13b04:	eb 59                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   13b06:	b8 68 b1 01 00       	mov    $0x1b168,%eax
   13b0b:	eb 52                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   13b0d:	b8 bc b1 01 00       	mov    $0x1b1bc,%eax
   13b12:	eb 4b                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   13b14:	b8 04 b2 01 00       	mov    $0x1b204,%eax
   13b19:	eb 44                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   13b1b:	b8 48 b2 01 00       	mov    $0x1b248,%eax
   13b20:	eb 3d                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   13b22:	b8 64 b2 01 00       	mov    $0x1b264,%eax
   13b27:	eb 36                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   13b29:	b8 9c b2 01 00       	mov    $0x1b29c,%eax
   13b2e:	eb 2f                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   13b30:	b8 f0 b2 01 00       	mov    $0x1b2f0,%eax
   13b35:	eb 28                	jmp    13b5f <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   13b37:	b8 20 b3 01 00       	mov    $0x1b320,%eax
   13b3c:	eb 21                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   13b3e:	b8 70 b3 01 00       	mov    $0x1b370,%eax
   13b43:	eb 1a                	jmp    13b5f <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   13b45:	b8 9c b3 01 00       	mov    $0x1b39c,%eax
   13b4a:	eb 13                	jmp    13b5f <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   13b4c:	b8 c8 b3 01 00       	mov    $0x1b3c8,%eax
   13b51:	eb 0c                	jmp    13b5f <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   13b53:	b8 ec b3 01 00       	mov    $0x1b3ec,%eax
   13b58:	eb 05                	jmp    13b5f <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   13b5a:	b8 0b b4 01 00       	mov    $0x1b40b,%eax
}
   13b5f:	5d                   	pop    %ebp
   13b60:	c3                   	ret    

00013b61 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   13b61:	55                   	push   %ebp
   13b62:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   13b64:	8b 45 08             	mov    0x8(%ebp),%eax
   13b67:	8b 40 28             	mov    0x28(%eax),%eax
   13b6a:	83 f8 01             	cmp    $0x1,%eax
   13b6d:	75 08                	jne    13b77 <GetImage+0x16>
   13b6f:	8b 45 08             	mov    0x8(%ebp),%eax
   13b72:	8b 40 54             	mov    0x54(%eax),%eax
   13b75:	eb 09                	jmp    13b80 <GetImage+0x1f>
   13b77:	8b 45 08             	mov    0x8(%ebp),%eax
   13b7a:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   13b80:	5d                   	pop    %ebp
   13b81:	c3                   	ret    

00013b82 <GetWidth>:

int GetWidth(Context* ctx){
   13b82:	55                   	push   %ebp
   13b83:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   13b85:	8b 45 08             	mov    0x8(%ebp),%eax
   13b88:	8b 40 10             	mov    0x10(%eax),%eax
}
   13b8b:	5d                   	pop    %ebp
   13b8c:	c3                   	ret    

00013b8d <GetHeight>:

int GetHeight(Context* ctx){
   13b8d:	55                   	push   %ebp
   13b8e:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   13b90:	8b 45 08             	mov    0x8(%ebp),%eax
   13b93:	8b 40 14             	mov    0x14(%eax),%eax
}
   13b96:	5d                   	pop    %ebp
   13b97:	c3                   	ret    

00013b98 <GetImageSize>:

uint GetImageSize(Context* ctx){
   13b98:	55                   	push   %ebp
   13b99:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   13b9b:	8b 45 08             	mov    0x8(%ebp),%eax
   13b9e:	8b 50 10             	mov    0x10(%eax),%edx
   13ba1:	8b 45 08             	mov    0x8(%ebp),%eax
   13ba4:	8b 40 14             	mov    0x14(%eax),%eax
   13ba7:	0f af d0             	imul   %eax,%edx
   13baa:	8b 45 08             	mov    0x8(%ebp),%eax
   13bad:	8b 40 28             	mov    0x28(%eax),%eax
   13bb0:	0f af c2             	imul   %edx,%eax
}
   13bb3:	5d                   	pop    %ebp
   13bb4:	c3                   	ret    

00013bb5 <_Clip>:

uchar _Clip(const int x){
   13bb5:	55                   	push   %ebp
   13bb6:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   13bb8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13bbc:	78 15                	js     13bd3 <_Clip+0x1e>
   13bbe:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   13bc5:	7f 05                	jg     13bcc <_Clip+0x17>
   13bc7:	8b 45 08             	mov    0x8(%ebp),%eax
   13bca:	eb 0c                	jmp    13bd8 <_Clip+0x23>
   13bcc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13bd1:	eb 05                	jmp    13bd8 <_Clip+0x23>
   13bd3:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13bd8:	5d                   	pop    %ebp
   13bd9:	c3                   	ret    

00013bda <_Skip>:

void _Skip(Context* ctx, int c){
   13bda:	55                   	push   %ebp
   13bdb:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   13bdd:	8b 45 08             	mov    0x8(%ebp),%eax
   13be0:	8b 50 04             	mov    0x4(%eax),%edx
   13be3:	8b 45 0c             	mov    0xc(%ebp),%eax
   13be6:	01 c2                	add    %eax,%edx
   13be8:	8b 45 08             	mov    0x8(%ebp),%eax
   13beb:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   13bee:	8b 45 08             	mov    0x8(%ebp),%eax
   13bf1:	8b 40 08             	mov    0x8(%eax),%eax
   13bf4:	2b 45 0c             	sub    0xc(%ebp),%eax
   13bf7:	89 c2                	mov    %eax,%edx
   13bf9:	8b 45 08             	mov    0x8(%ebp),%eax
   13bfc:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   13bff:	8b 45 08             	mov    0x8(%ebp),%eax
   13c02:	8b 40 0c             	mov    0xc(%eax),%eax
   13c05:	2b 45 0c             	sub    0xc(%ebp),%eax
   13c08:	89 c2                	mov    %eax,%edx
   13c0a:	8b 45 08             	mov    0x8(%ebp),%eax
   13c0d:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   13c10:	8b 45 08             	mov    0x8(%ebp),%eax
   13c13:	8b 40 08             	mov    0x8(%eax),%eax
   13c16:	85 c0                	test   %eax,%eax
   13c18:	79 09                	jns    13c23 <_Skip+0x49>
   13c1a:	8b 45 08             	mov    0x8(%ebp),%eax
   13c1d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   13c23:	90                   	nop
   13c24:	5d                   	pop    %ebp
   13c25:	c3                   	ret    

00013c26 <_DecodeLength>:

void _DecodeLength(Context* ctx){
   13c26:	55                   	push   %ebp
   13c27:	89 e5                	mov    %esp,%ebp
   13c29:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   13c2c:	8b 45 08             	mov    0x8(%ebp),%eax
   13c2f:	8b 40 08             	mov    0x8(%eax),%eax
   13c32:	83 f8 01             	cmp    $0x1,%eax
   13c35:	7f 0b                	jg     13c42 <_DecodeLength+0x1c>
   13c37:	8b 45 08             	mov    0x8(%ebp),%eax
   13c3a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13c40:	eb 45                	jmp    13c87 <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   13c42:	8b 45 08             	mov    0x8(%ebp),%eax
   13c45:	8b 40 04             	mov    0x4(%eax),%eax
   13c48:	83 ec 0c             	sub    $0xc,%esp
   13c4b:	50                   	push   %eax
   13c4c:	e8 38 00 00 00       	call   13c89 <_Decode2Bytes>
   13c51:	83 c4 10             	add    $0x10,%esp
   13c54:	89 c2                	mov    %eax,%edx
   13c56:	8b 45 08             	mov    0x8(%ebp),%eax
   13c59:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   13c5c:	8b 45 08             	mov    0x8(%ebp),%eax
   13c5f:	8b 50 0c             	mov    0xc(%eax),%edx
   13c62:	8b 45 08             	mov    0x8(%ebp),%eax
   13c65:	8b 40 08             	mov    0x8(%eax),%eax
   13c68:	39 c2                	cmp    %eax,%edx
   13c6a:	7e 0b                	jle    13c77 <_DecodeLength+0x51>
   13c6c:	8b 45 08             	mov    0x8(%ebp),%eax
   13c6f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13c75:	eb 10                	jmp    13c87 <_DecodeLength+0x61>
    _Skip(ctx, 2);
   13c77:	83 ec 08             	sub    $0x8,%esp
   13c7a:	6a 02                	push   $0x2
   13c7c:	ff 75 08             	pushl  0x8(%ebp)
   13c7f:	e8 56 ff ff ff       	call   13bda <_Skip>
   13c84:	83 c4 10             	add    $0x10,%esp
}
   13c87:	c9                   	leave  
   13c88:	c3                   	ret    

00013c89 <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   13c89:	55                   	push   %ebp
   13c8a:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   13c8c:	8b 45 08             	mov    0x8(%ebp),%eax
   13c8f:	0f b6 00             	movzbl (%eax),%eax
   13c92:	0f b6 c0             	movzbl %al,%eax
   13c95:	c1 e0 08             	shl    $0x8,%eax
   13c98:	89 c2                	mov    %eax,%edx
   13c9a:	8b 45 08             	mov    0x8(%ebp),%eax
   13c9d:	83 c0 01             	add    $0x1,%eax
   13ca0:	0f b6 00             	movzbl (%eax),%eax
   13ca3:	0f b6 c0             	movzbl %al,%eax
   13ca6:	09 d0                	or     %edx,%eax
}
   13ca8:	5d                   	pop    %ebp
   13ca9:	c3                   	ret    

00013caa <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   13caa:	55                   	push   %ebp
   13cab:	89 e5                	mov    %esp,%ebp
   13cad:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   13cb0:	8b 45 08             	mov    0x8(%ebp),%eax
   13cb3:	8b 55 10             	mov    0x10(%ebp),%edx
   13cb6:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   13cb9:	8b 45 14             	mov    0x14(%ebp),%eax
   13cbc:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   13cc1:	89 c2                	mov    %eax,%edx
   13cc3:	8b 45 08             	mov    0x8(%ebp),%eax
   13cc6:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   13cc9:	8b 45 08             	mov    0x8(%ebp),%eax
   13ccc:	8b 40 08             	mov    0x8(%eax),%eax
   13ccf:	83 f8 01             	cmp    $0x1,%eax
   13cd2:	7e 1d                	jle    13cf1 <_DecodeJPEG+0x47>
   13cd4:	8b 45 08             	mov    0x8(%ebp),%eax
   13cd7:	8b 40 04             	mov    0x4(%eax),%eax
   13cda:	0f b6 00             	movzbl (%eax),%eax
   13cdd:	3c ff                	cmp    $0xff,%al
   13cdf:	75 10                	jne    13cf1 <_DecodeJPEG+0x47>
   13ce1:	8b 45 08             	mov    0x8(%ebp),%eax
   13ce4:	8b 40 04             	mov    0x4(%eax),%eax
   13ce7:	83 c0 01             	add    $0x1,%eax
   13cea:	0f b6 00             	movzbl (%eax),%eax
   13ced:	3c d8                	cmp    $0xd8,%al
   13cef:	74 0a                	je     13cfb <_DecodeJPEG+0x51>
   13cf1:	b8 01 00 00 00       	mov    $0x1,%eax
   13cf6:	e9 56 01 00 00       	jmp    13e51 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   13cfb:	6a 02                	push   $0x2
   13cfd:	ff 75 08             	pushl  0x8(%ebp)
   13d00:	e8 d5 fe ff ff       	call   13bda <_Skip>
   13d05:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   13d08:	e9 0a 01 00 00       	jmp    13e17 <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   13d0d:	8b 45 08             	mov    0x8(%ebp),%eax
   13d10:	8b 40 08             	mov    0x8(%eax),%eax
   13d13:	85 c0                	test   %eax,%eax
   13d15:	78 0d                	js     13d24 <_DecodeJPEG+0x7a>
   13d17:	8b 45 08             	mov    0x8(%ebp),%eax
   13d1a:	8b 40 04             	mov    0x4(%eax),%eax
   13d1d:	0f b6 00             	movzbl (%eax),%eax
   13d20:	3c ff                	cmp    $0xff,%al
   13d22:	74 0a                	je     13d2e <_DecodeJPEG+0x84>
   13d24:	b8 05 00 00 00       	mov    $0x5,%eax
   13d29:	e9 23 01 00 00       	jmp    13e51 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   13d2e:	6a 02                	push   $0x2
   13d30:	ff 75 08             	pushl  0x8(%ebp)
   13d33:	e8 a2 fe ff ff       	call   13bda <_Skip>
   13d38:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   13d3b:	8b 45 08             	mov    0x8(%ebp),%eax
   13d3e:	8b 40 04             	mov    0x4(%eax),%eax
   13d41:	83 e8 01             	sub    $0x1,%eax
   13d44:	0f b6 00             	movzbl (%eax),%eax
   13d47:	0f b6 c0             	movzbl %al,%eax
   13d4a:	3d da 00 00 00       	cmp    $0xda,%eax
   13d4f:	74 71                	je     13dc2 <_DecodeJPEG+0x118>
   13d51:	3d da 00 00 00       	cmp    $0xda,%eax
   13d56:	7f 10                	jg     13d68 <_DecodeJPEG+0xbe>
   13d58:	3d c0 00 00 00       	cmp    $0xc0,%eax
   13d5d:	74 20                	je     13d7f <_DecodeJPEG+0xd5>
   13d5f:	3d c4 00 00 00       	cmp    $0xc4,%eax
   13d64:	74 2c                	je     13d92 <_DecodeJPEG+0xe8>
   13d66:	eb 7d                	jmp    13de5 <_DecodeJPEG+0x13b>
   13d68:	3d dd 00 00 00       	cmp    $0xdd,%eax
   13d6d:	74 43                	je     13db2 <_DecodeJPEG+0x108>
   13d6f:	3d fe 00 00 00       	cmp    $0xfe,%eax
   13d74:	74 5f                	je     13dd5 <_DecodeJPEG+0x12b>
   13d76:	3d db 00 00 00       	cmp    $0xdb,%eax
   13d7b:	74 25                	je     13da2 <_DecodeJPEG+0xf8>
   13d7d:	eb 66                	jmp    13de5 <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   13d7f:	83 ec 0c             	sub    $0xc,%esp
   13d82:	ff 75 08             	pushl  0x8(%ebp)
   13d85:	e8 c9 00 00 00       	call   13e53 <_DecodeSOF>
   13d8a:	83 c4 10             	add    $0x10,%esp
   13d8d:	e9 85 00 00 00       	jmp    13e17 <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   13d92:	83 ec 0c             	sub    $0xc,%esp
   13d95:	ff 75 08             	pushl  0x8(%ebp)
   13d98:	e8 28 05 00 00       	call   142c5 <_DecodeDHT>
   13d9d:	83 c4 10             	add    $0x10,%esp
   13da0:	eb 75                	jmp    13e17 <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   13da2:	83 ec 0c             	sub    $0xc,%esp
   13da5:	ff 75 08             	pushl  0x8(%ebp)
   13da8:	e8 05 07 00 00       	call   144b2 <_DecodeDQT>
   13dad:	83 c4 10             	add    $0x10,%esp
   13db0:	eb 65                	jmp    13e17 <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   13db2:	83 ec 0c             	sub    $0xc,%esp
   13db5:	ff 75 08             	pushl  0x8(%ebp)
   13db8:	e8 ff 07 00 00       	call   145bc <_DecodeDRI>
   13dbd:	83 c4 10             	add    $0x10,%esp
   13dc0:	eb 55                	jmp    13e17 <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   13dc2:	83 ec 08             	sub    $0x8,%esp
   13dc5:	ff 75 0c             	pushl  0xc(%ebp)
   13dc8:	ff 75 08             	pushl  0x8(%ebp)
   13dcb:	e8 56 08 00 00       	call   14626 <_DecodeSOS>
   13dd0:	83 c4 10             	add    $0x10,%esp
   13dd3:	eb 42                	jmp    13e17 <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   13dd5:	83 ec 0c             	sub    $0xc,%esp
   13dd8:	ff 75 08             	pushl  0x8(%ebp)
   13ddb:	e8 a8 15 00 00       	call   15388 <_SkipMarker>
   13de0:	83 c4 10             	add    $0x10,%esp
   13de3:	eb 32                	jmp    13e17 <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   13de5:	8b 45 08             	mov    0x8(%ebp),%eax
   13de8:	8b 40 04             	mov    0x4(%eax),%eax
   13deb:	83 e8 01             	sub    $0x1,%eax
   13dee:	0f b6 00             	movzbl (%eax),%eax
   13df1:	0f b6 c0             	movzbl %al,%eax
   13df4:	25 f0 00 00 00       	and    $0xf0,%eax
   13df9:	3d e0 00 00 00       	cmp    $0xe0,%eax
   13dfe:	75 10                	jne    13e10 <_DecodeJPEG+0x166>
   13e00:	83 ec 0c             	sub    $0xc,%esp
   13e03:	ff 75 08             	pushl  0x8(%ebp)
   13e06:	e8 7d 15 00 00       	call   15388 <_SkipMarker>
   13e0b:	83 c4 10             	add    $0x10,%esp
   13e0e:	eb 07                	jmp    13e17 <_DecodeJPEG+0x16d>
                else return Unsupported;
   13e10:	b8 02 00 00 00       	mov    $0x2,%eax
   13e15:	eb 3a                	jmp    13e51 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   13e17:	8b 45 08             	mov    0x8(%ebp),%eax
   13e1a:	8b 00                	mov    (%eax),%eax
   13e1c:	85 c0                	test   %eax,%eax
   13e1e:	0f 84 e9 fe ff ff    	je     13d0d <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   13e24:	8b 45 08             	mov    0x8(%ebp),%eax
   13e27:	8b 00                	mov    (%eax),%eax
   13e29:	83 f8 06             	cmp    $0x6,%eax
   13e2c:	74 07                	je     13e35 <_DecodeJPEG+0x18b>
   13e2e:	8b 45 08             	mov    0x8(%ebp),%eax
   13e31:	8b 00                	mov    (%eax),%eax
   13e33:	eb 1c                	jmp    13e51 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   13e35:	8b 45 08             	mov    0x8(%ebp),%eax
   13e38:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   13e3e:	83 ec 0c             	sub    $0xc,%esp
   13e41:	ff 75 08             	pushl  0x8(%ebp)
   13e44:	e8 6b 15 00 00       	call   153b4 <_Convert>
   13e49:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   13e4c:	8b 45 08             	mov    0x8(%ebp),%eax
   13e4f:	8b 00                	mov    (%eax),%eax
 }
   13e51:	c9                   	leave  
   13e52:	c3                   	ret    

00013e53 <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   13e53:	55                   	push   %ebp
   13e54:	89 e5                	mov    %esp,%ebp
   13e56:	53                   	push   %ebx
   13e57:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   13e5a:	83 ec 0c             	sub    $0xc,%esp
   13e5d:	ff 75 08             	pushl  0x8(%ebp)
   13e60:	e8 c1 fd ff ff       	call   13c26 <_DecodeLength>
   13e65:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   13e68:	8b 45 08             	mov    0x8(%ebp),%eax
   13e6b:	8b 00                	mov    (%eax),%eax
   13e6d:	85 c0                	test   %eax,%eax
   13e6f:	0f 85 4a 04 00 00    	jne    142bf <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   13e75:	8b 45 08             	mov    0x8(%ebp),%eax
   13e78:	8b 40 0c             	mov    0xc(%eax),%eax
   13e7b:	83 f8 08             	cmp    $0x8,%eax
   13e7e:	7f 0e                	jg     13e8e <_DecodeSOF+0x3b>
   13e80:	8b 45 08             	mov    0x8(%ebp),%eax
   13e83:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13e89:	e9 32 04 00 00       	jmp    142c0 <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   13e8e:	8b 45 08             	mov    0x8(%ebp),%eax
   13e91:	8b 40 04             	mov    0x4(%eax),%eax
   13e94:	0f b6 00             	movzbl (%eax),%eax
   13e97:	3c 08                	cmp    $0x8,%al
   13e99:	74 0e                	je     13ea9 <_DecodeSOF+0x56>
   13e9b:	8b 45 08             	mov    0x8(%ebp),%eax
   13e9e:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13ea4:	e9 17 04 00 00       	jmp    142c0 <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   13ea9:	8b 45 08             	mov    0x8(%ebp),%eax
   13eac:	8b 40 04             	mov    0x4(%eax),%eax
   13eaf:	83 c0 01             	add    $0x1,%eax
   13eb2:	83 ec 0c             	sub    $0xc,%esp
   13eb5:	50                   	push   %eax
   13eb6:	e8 ce fd ff ff       	call   13c89 <_Decode2Bytes>
   13ebb:	83 c4 10             	add    $0x10,%esp
   13ebe:	89 c2                	mov    %eax,%edx
   13ec0:	8b 45 08             	mov    0x8(%ebp),%eax
   13ec3:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   13ec6:	8b 45 08             	mov    0x8(%ebp),%eax
   13ec9:	8b 40 04             	mov    0x4(%eax),%eax
   13ecc:	83 c0 03             	add    $0x3,%eax
   13ecf:	83 ec 0c             	sub    $0xc,%esp
   13ed2:	50                   	push   %eax
   13ed3:	e8 b1 fd ff ff       	call   13c89 <_Decode2Bytes>
   13ed8:	83 c4 10             	add    $0x10,%esp
   13edb:	89 c2                	mov    %eax,%edx
   13edd:	8b 45 08             	mov    0x8(%ebp),%eax
   13ee0:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   13ee3:	8b 45 08             	mov    0x8(%ebp),%eax
   13ee6:	8b 40 04             	mov    0x4(%eax),%eax
   13ee9:	83 c0 05             	add    $0x5,%eax
   13eec:	0f b6 00             	movzbl (%eax),%eax
   13eef:	0f b6 d0             	movzbl %al,%edx
   13ef2:	8b 45 08             	mov    0x8(%ebp),%eax
   13ef5:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   13ef8:	83 ec 08             	sub    $0x8,%esp
   13efb:	6a 06                	push   $0x6
   13efd:	ff 75 08             	pushl  0x8(%ebp)
   13f00:	e8 d5 fc ff ff       	call   13bda <_Skip>
   13f05:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   13f08:	8b 45 08             	mov    0x8(%ebp),%eax
   13f0b:	8b 40 28             	mov    0x28(%eax),%eax
   13f0e:	83 f8 01             	cmp    $0x1,%eax
   13f11:	74 13                	je     13f26 <_DecodeSOF+0xd3>
   13f13:	83 f8 03             	cmp    $0x3,%eax
   13f16:	74 0e                	je     13f26 <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   13f18:	8b 45 08             	mov    0x8(%ebp),%eax
   13f1b:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13f21:	e9 9a 03 00 00       	jmp    142c0 <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   13f26:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   13f27:	8b 45 08             	mov    0x8(%ebp),%eax
   13f2a:	8b 48 0c             	mov    0xc(%eax),%ecx
   13f2d:	8b 45 08             	mov    0x8(%ebp),%eax
   13f30:	8b 50 28             	mov    0x28(%eax),%edx
   13f33:	89 d0                	mov    %edx,%eax
   13f35:	01 c0                	add    %eax,%eax
   13f37:	01 d0                	add    %edx,%eax
   13f39:	39 c1                	cmp    %eax,%ecx
   13f3b:	7d 0e                	jge    13f4b <_DecodeSOF+0xf8>
   13f3d:	8b 45 08             	mov    0x8(%ebp),%eax
   13f40:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13f46:	e9 75 03 00 00       	jmp    142c0 <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   13f4b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13f52:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   13f59:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13f60:	8b 45 08             	mov    0x8(%ebp),%eax
   13f63:	83 c0 2c             	add    $0x2c,%eax
   13f66:	89 45 e8             	mov    %eax,-0x18(%ebp)
   13f69:	e9 50 01 00 00       	jmp    140be <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   13f6e:	8b 45 08             	mov    0x8(%ebp),%eax
   13f71:	8b 40 04             	mov    0x4(%eax),%eax
   13f74:	0f b6 00             	movzbl (%eax),%eax
   13f77:	0f b6 d0             	movzbl %al,%edx
   13f7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f7d:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   13f7f:	8b 45 08             	mov    0x8(%ebp),%eax
   13f82:	8b 40 04             	mov    0x4(%eax),%eax
   13f85:	83 c0 01             	add    $0x1,%eax
   13f88:	0f b6 00             	movzbl (%eax),%eax
   13f8b:	c0 e8 04             	shr    $0x4,%al
   13f8e:	0f b6 d0             	movzbl %al,%edx
   13f91:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f94:	89 50 04             	mov    %edx,0x4(%eax)
   13f97:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f9a:	8b 40 04             	mov    0x4(%eax),%eax
   13f9d:	85 c0                	test   %eax,%eax
   13f9f:	75 0e                	jne    13faf <_DecodeSOF+0x15c>
   13fa1:	8b 45 08             	mov    0x8(%ebp),%eax
   13fa4:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13faa:	e9 11 03 00 00       	jmp    142c0 <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   13faf:	8b 45 08             	mov    0x8(%ebp),%eax
   13fb2:	8b 40 04             	mov    0x4(%eax),%eax
   13fb5:	83 c0 01             	add    $0x1,%eax
   13fb8:	0f b6 00             	movzbl (%eax),%eax
   13fbb:	0f b6 c0             	movzbl %al,%eax
   13fbe:	83 e0 0f             	and    $0xf,%eax
   13fc1:	89 c2                	mov    %eax,%edx
   13fc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fc6:	89 50 08             	mov    %edx,0x8(%eax)
   13fc9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fcc:	8b 40 08             	mov    0x8(%eax),%eax
   13fcf:	85 c0                	test   %eax,%eax
   13fd1:	75 0e                	jne    13fe1 <_DecodeSOF+0x18e>
   13fd3:	8b 45 08             	mov    0x8(%ebp),%eax
   13fd6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13fdc:	e9 df 02 00 00       	jmp    142c0 <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   13fe1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fe4:	8b 50 04             	mov    0x4(%eax),%edx
   13fe7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fea:	8b 40 04             	mov    0x4(%eax),%eax
   13fed:	83 e8 01             	sub    $0x1,%eax
   13ff0:	21 d0                	and    %edx,%eax
   13ff2:	85 c0                	test   %eax,%eax
   13ff4:	74 0e                	je     14004 <_DecodeSOF+0x1b1>
   13ff6:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff9:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13fff:	e9 bc 02 00 00       	jmp    142c0 <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   14004:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14007:	8b 50 08             	mov    0x8(%eax),%edx
   1400a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1400d:	8b 40 08             	mov    0x8(%eax),%eax
   14010:	83 e8 01             	sub    $0x1,%eax
   14013:	21 d0                	and    %edx,%eax
   14015:	85 c0                	test   %eax,%eax
   14017:	74 0e                	je     14027 <_DecodeSOF+0x1d4>
   14019:	8b 45 08             	mov    0x8(%ebp),%eax
   1401c:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14022:	e9 99 02 00 00       	jmp    142c0 <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   14027:	8b 45 08             	mov    0x8(%ebp),%eax
   1402a:	8b 40 04             	mov    0x4(%eax),%eax
   1402d:	83 c0 02             	add    $0x2,%eax
   14030:	0f b6 00             	movzbl (%eax),%eax
   14033:	0f b6 d0             	movzbl %al,%edx
   14036:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14039:	89 50 18             	mov    %edx,0x18(%eax)
   1403c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1403f:	8b 40 18             	mov    0x18(%eax),%eax
   14042:	25 fc 00 00 00       	and    $0xfc,%eax
   14047:	85 c0                	test   %eax,%eax
   14049:	74 0e                	je     14059 <_DecodeSOF+0x206>
   1404b:	8b 45 08             	mov    0x8(%ebp),%eax
   1404e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14054:	e9 67 02 00 00       	jmp    142c0 <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   14059:	83 ec 08             	sub    $0x8,%esp
   1405c:	6a 03                	push   $0x3
   1405e:	ff 75 08             	pushl  0x8(%ebp)
   14061:	e8 74 fb ff ff       	call   13bda <_Skip>
   14066:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   14069:	8b 45 08             	mov    0x8(%ebp),%eax
   1406c:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   14072:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14075:	8b 40 18             	mov    0x18(%eax),%eax
   14078:	bb 01 00 00 00       	mov    $0x1,%ebx
   1407d:	89 c1                	mov    %eax,%ecx
   1407f:	d3 e3                	shl    %cl,%ebx
   14081:	89 d8                	mov    %ebx,%eax
   14083:	09 c2                	or     %eax,%edx
   14085:	8b 45 08             	mov    0x8(%ebp),%eax
   14088:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   1408e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14091:	8b 40 04             	mov    0x4(%eax),%eax
   14094:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14097:	7e 09                	jle    140a2 <_DecodeSOF+0x24f>
   14099:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1409c:	8b 40 04             	mov    0x4(%eax),%eax
   1409f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   140a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140a5:	8b 40 08             	mov    0x8(%eax),%eax
   140a8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   140ab:	7e 09                	jle    140b6 <_DecodeSOF+0x263>
   140ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140b0:	8b 40 08             	mov    0x8(%eax),%eax
   140b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   140b6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   140ba:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   140be:	8b 45 08             	mov    0x8(%ebp),%eax
   140c1:	8b 40 28             	mov    0x28(%eax),%eax
   140c4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   140c7:	0f 8f a1 fe ff ff    	jg     13f6e <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   140cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   140d0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   140d7:	8b 45 08             	mov    0x8(%ebp),%eax
   140da:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   140dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   140e0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   140e7:	8b 45 08             	mov    0x8(%ebp),%eax
   140ea:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   140ed:	8b 45 08             	mov    0x8(%ebp),%eax
   140f0:	8b 50 10             	mov    0x10(%eax),%edx
   140f3:	8b 45 08             	mov    0x8(%ebp),%eax
   140f6:	8b 40 20             	mov    0x20(%eax),%eax
   140f9:	01 d0                	add    %edx,%eax
   140fb:	8d 48 ff             	lea    -0x1(%eax),%ecx
   140fe:	8b 45 08             	mov    0x8(%ebp),%eax
   14101:	8b 58 20             	mov    0x20(%eax),%ebx
   14104:	89 c8                	mov    %ecx,%eax
   14106:	99                   	cltd   
   14107:	f7 fb                	idiv   %ebx
   14109:	89 c2                	mov    %eax,%edx
   1410b:	8b 45 08             	mov    0x8(%ebp),%eax
   1410e:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   14111:	8b 45 08             	mov    0x8(%ebp),%eax
   14114:	8b 50 14             	mov    0x14(%eax),%edx
   14117:	8b 45 08             	mov    0x8(%ebp),%eax
   1411a:	8b 40 24             	mov    0x24(%eax),%eax
   1411d:	01 d0                	add    %edx,%eax
   1411f:	8d 48 ff             	lea    -0x1(%eax),%ecx
   14122:	8b 45 08             	mov    0x8(%ebp),%eax
   14125:	8b 58 24             	mov    0x24(%eax),%ebx
   14128:	89 c8                	mov    %ecx,%eax
   1412a:	99                   	cltd   
   1412b:	f7 fb                	idiv   %ebx
   1412d:	89 c2                	mov    %eax,%edx
   1412f:	8b 45 08             	mov    0x8(%ebp),%eax
   14132:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   14135:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1413c:	8b 45 08             	mov    0x8(%ebp),%eax
   1413f:	83 c0 2c             	add    $0x2c,%eax
   14142:	89 45 e8             	mov    %eax,-0x18(%ebp)
   14145:	e9 fd 00 00 00       	jmp    14247 <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   1414a:	8b 45 08             	mov    0x8(%ebp),%eax
   1414d:	8b 50 10             	mov    0x10(%eax),%edx
   14150:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14153:	8b 40 04             	mov    0x4(%eax),%eax
   14156:	0f af d0             	imul   %eax,%edx
   14159:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1415c:	01 d0                	add    %edx,%eax
   1415e:	83 e8 01             	sub    $0x1,%eax
   14161:	99                   	cltd   
   14162:	f7 7d ec             	idivl  -0x14(%ebp)
   14165:	89 c2                	mov    %eax,%edx
   14167:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1416a:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   1416d:	8b 45 08             	mov    0x8(%ebp),%eax
   14170:	8b 50 14             	mov    0x14(%eax),%edx
   14173:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14176:	8b 40 08             	mov    0x8(%eax),%eax
   14179:	0f af d0             	imul   %eax,%edx
   1417c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1417f:	01 d0                	add    %edx,%eax
   14181:	83 e8 01             	sub    $0x1,%eax
   14184:	99                   	cltd   
   14185:	f7 7d f0             	idivl  -0x10(%ebp)
   14188:	89 c2                	mov    %eax,%edx
   1418a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1418d:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   14190:	8b 45 08             	mov    0x8(%ebp),%eax
   14193:	8b 50 18             	mov    0x18(%eax),%edx
   14196:	8b 45 08             	mov    0x8(%ebp),%eax
   14199:	8b 40 20             	mov    0x20(%eax),%eax
   1419c:	0f af d0             	imul   %eax,%edx
   1419f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141a2:	8b 40 04             	mov    0x4(%eax),%eax
   141a5:	0f af c2             	imul   %edx,%eax
   141a8:	99                   	cltd   
   141a9:	f7 7d ec             	idivl  -0x14(%ebp)
   141ac:	89 c2                	mov    %eax,%edx
   141ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141b1:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   141b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141b7:	8b 40 0c             	mov    0xc(%eax),%eax
   141ba:	83 f8 02             	cmp    $0x2,%eax
   141bd:	7f 0b                	jg     141ca <_DecodeSOF+0x377>
   141bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141c2:	8b 40 04             	mov    0x4(%eax),%eax
   141c5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   141c8:	75 16                	jne    141e0 <_DecodeSOF+0x38d>
   141ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141cd:	8b 40 10             	mov    0x10(%eax),%eax
   141d0:	83 f8 02             	cmp    $0x2,%eax
   141d3:	7f 19                	jg     141ee <_DecodeSOF+0x39b>
   141d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141d8:	8b 40 08             	mov    0x8(%eax),%eax
   141db:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   141de:	74 0e                	je     141ee <_DecodeSOF+0x39b>
   141e0:	8b 45 08             	mov    0x8(%ebp),%eax
   141e3:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   141e9:	e9 d2 00 00 00       	jmp    142c0 <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   141ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141f1:	8b 48 14             	mov    0x14(%eax),%ecx
   141f4:	8b 45 08             	mov    0x8(%ebp),%eax
   141f7:	8b 50 1c             	mov    0x1c(%eax),%edx
   141fa:	8b 45 08             	mov    0x8(%ebp),%eax
   141fd:	8b 40 24             	mov    0x24(%eax),%eax
   14200:	0f af d0             	imul   %eax,%edx
   14203:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14206:	8b 40 08             	mov    0x8(%eax),%eax
   14209:	0f af c2             	imul   %edx,%eax
   1420c:	99                   	cltd   
   1420d:	f7 7d f0             	idivl  -0x10(%ebp)
   14210:	0f af c1             	imul   %ecx,%eax
   14213:	83 ec 0c             	sub    $0xc,%esp
   14216:	50                   	push   %eax
   14217:	e8 45 c5 fe ff       	call   761 <malloc>
   1421c:	83 c4 10             	add    $0x10,%esp
   1421f:	89 c2                	mov    %eax,%edx
   14221:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14224:	89 50 28             	mov    %edx,0x28(%eax)
   14227:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1422a:	8b 40 28             	mov    0x28(%eax),%eax
   1422d:	85 c0                	test   %eax,%eax
   1422f:	75 0e                	jne    1423f <_DecodeSOF+0x3ec>
   14231:	8b 45 08             	mov    0x8(%ebp),%eax
   14234:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1423a:	e9 81 00 00 00       	jmp    142c0 <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   1423f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14243:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   14247:	8b 45 08             	mov    0x8(%ebp),%eax
   1424a:	8b 40 28             	mov    0x28(%eax),%eax
   1424d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14250:	0f 8f f4 fe ff ff    	jg     1414a <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   14256:	8b 45 08             	mov    0x8(%ebp),%eax
   14259:	8b 40 28             	mov    0x28(%eax),%eax
   1425c:	83 f8 03             	cmp    $0x3,%eax
   1425f:	75 47                	jne    142a8 <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   14261:	8b 45 08             	mov    0x8(%ebp),%eax
   14264:	8b 50 10             	mov    0x10(%eax),%edx
   14267:	8b 45 08             	mov    0x8(%ebp),%eax
   1426a:	8b 40 14             	mov    0x14(%eax),%eax
   1426d:	0f af d0             	imul   %eax,%edx
   14270:	8b 45 08             	mov    0x8(%ebp),%eax
   14273:	8b 40 28             	mov    0x28(%eax),%eax
   14276:	0f af c2             	imul   %edx,%eax
   14279:	83 ec 0c             	sub    $0xc,%esp
   1427c:	50                   	push   %eax
   1427d:	e8 df c4 fe ff       	call   761 <malloc>
   14282:	83 c4 10             	add    $0x10,%esp
   14285:	89 c2                	mov    %eax,%edx
   14287:	8b 45 08             	mov    0x8(%ebp),%eax
   1428a:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   14290:	8b 45 08             	mov    0x8(%ebp),%eax
   14293:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   14299:	85 c0                	test   %eax,%eax
   1429b:	75 0b                	jne    142a8 <_DecodeSOF+0x455>
   1429d:	8b 45 08             	mov    0x8(%ebp),%eax
   142a0:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   142a6:	eb 18                	jmp    142c0 <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   142a8:	8b 45 08             	mov    0x8(%ebp),%eax
   142ab:	8b 40 0c             	mov    0xc(%eax),%eax
   142ae:	83 ec 08             	sub    $0x8,%esp
   142b1:	50                   	push   %eax
   142b2:	ff 75 08             	pushl  0x8(%ebp)
   142b5:	e8 20 f9 ff ff       	call   13bda <_Skip>
   142ba:	83 c4 10             	add    $0x10,%esp
   142bd:	eb 01                	jmp    142c0 <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   142bf:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   142c0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   142c3:	c9                   	leave  
   142c4:	c3                   	ret    

000142c5 <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   142c5:	55                   	push   %ebp
   142c6:	89 e5                	mov    %esp,%ebp
   142c8:	53                   	push   %ebx
   142c9:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   142cc:	83 ec 0c             	sub    $0xc,%esp
   142cf:	ff 75 08             	pushl  0x8(%ebp)
   142d2:	e8 4f f9 ff ff       	call   13c26 <_DecodeLength>
   142d7:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   142da:	8b 45 08             	mov    0x8(%ebp),%eax
   142dd:	8b 00                	mov    (%eax),%eax
   142df:	85 c0                	test   %eax,%eax
   142e1:	0f 85 c5 01 00 00    	jne    144ac <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   142e7:	e9 9c 01 00 00       	jmp    14488 <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   142ec:	8b 45 08             	mov    0x8(%ebp),%eax
   142ef:	8b 40 04             	mov    0x4(%eax),%eax
   142f2:	0f b6 00             	movzbl (%eax),%eax
   142f5:	0f b6 c0             	movzbl %al,%eax
   142f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   142fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   142fe:	25 ec 00 00 00       	and    $0xec,%eax
   14303:	85 c0                	test   %eax,%eax
   14305:	74 0e                	je     14315 <_DecodeDHT+0x50>
   14307:	8b 45 08             	mov    0x8(%ebp),%eax
   1430a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14310:	e9 98 01 00 00       	jmp    144ad <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   14315:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14318:	83 e0 02             	and    $0x2,%eax
   1431b:	85 c0                	test   %eax,%eax
   1431d:	74 0e                	je     1432d <_DecodeDHT+0x68>
   1431f:	8b 45 08             	mov    0x8(%ebp),%eax
   14322:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14328:	e9 80 01 00 00       	jmp    144ad <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   1432d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14330:	c1 f8 03             	sar    $0x3,%eax
   14333:	0b 45 f4             	or     -0xc(%ebp),%eax
   14336:	83 e0 03             	and    $0x3,%eax
   14339:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   1433c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14343:	eb 1c                	jmp    14361 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   14345:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14348:	8d 50 ff             	lea    -0x1(%eax),%edx
   1434b:	8b 45 08             	mov    0x8(%ebp),%eax
   1434e:	8b 48 04             	mov    0x4(%eax),%ecx
   14351:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14354:	01 c8                	add    %ecx,%eax
   14356:	0f b6 00             	movzbl (%eax),%eax
   14359:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   1435d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14361:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14365:	7e de                	jle    14345 <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   14367:	83 ec 08             	sub    $0x8,%esp
   1436a:	6a 11                	push   $0x11
   1436c:	ff 75 08             	pushl  0x8(%ebp)
   1436f:	e8 66 f8 ff ff       	call   13bda <_Skip>
   14374:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   14377:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1437a:	c1 e0 11             	shl    $0x11,%eax
   1437d:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14383:	8b 45 08             	mov    0x8(%ebp),%eax
   14386:	01 d0                	add    %edx,%eax
   14388:	83 c0 08             	add    $0x8,%eax
   1438b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   1438e:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   14395:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14398:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   1439b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   143a2:	e9 be 00 00 00       	jmp    14465 <_DecodeDHT+0x1a0>
            spread >>= 1;
   143a7:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   143aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143ad:	83 e8 01             	sub    $0x1,%eax
   143b0:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   143b5:	0f b6 c0             	movzbl %al,%eax
   143b8:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   143bb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   143bf:	0f 84 9b 00 00 00    	je     14460 <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   143c5:	8b 45 08             	mov    0x8(%ebp),%eax
   143c8:	8b 40 0c             	mov    0xc(%eax),%eax
   143cb:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   143ce:	7d 0e                	jge    143de <_DecodeDHT+0x119>
   143d0:	8b 45 08             	mov    0x8(%ebp),%eax
   143d3:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   143d9:	e9 cf 00 00 00       	jmp    144ad <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   143de:	b8 10 00 00 00       	mov    $0x10,%eax
   143e3:	2b 45 f0             	sub    -0x10(%ebp),%eax
   143e6:	8b 55 e0             	mov    -0x20(%ebp),%edx
   143e9:	89 c1                	mov    %eax,%ecx
   143eb:	d3 e2                	shl    %cl,%edx
   143ed:	89 d0                	mov    %edx,%eax
   143ef:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   143f2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   143f6:	79 0e                	jns    14406 <_DecodeDHT+0x141>
   143f8:	8b 45 08             	mov    0x8(%ebp),%eax
   143fb:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14401:	e9 a7 00 00 00       	jmp    144ad <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   14406:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1440d:	eb 36                	jmp    14445 <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   1440f:	8b 45 08             	mov    0x8(%ebp),%eax
   14412:	8b 50 04             	mov    0x4(%eax),%edx
   14415:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14418:	01 d0                	add    %edx,%eax
   1441a:	0f b6 00             	movzbl (%eax),%eax
   1441d:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   1441f:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   14422:	eb 14                	jmp    14438 <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   14424:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14427:	89 c2                	mov    %eax,%edx
   14429:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1442c:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   1442e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14431:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   14434:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   14438:	89 d8                	mov    %ebx,%eax
   1443a:	8d 58 ff             	lea    -0x1(%eax),%ebx
   1443d:	85 c0                	test   %eax,%eax
   1443f:	75 e3                	jne    14424 <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   14441:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14445:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14448:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   1444b:	7c c2                	jl     1440f <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   1444d:	83 ec 08             	sub    $0x8,%esp
   14450:	ff 75 e0             	pushl  -0x20(%ebp)
   14453:	ff 75 08             	pushl  0x8(%ebp)
   14456:	e8 7f f7 ff ff       	call   13bda <_Skip>
   1445b:	83 c4 10             	add    $0x10,%esp
   1445e:	eb 01                	jmp    14461 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   14460:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   14461:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14465:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14469:	0f 8e 38 ff ff ff    	jle    143a7 <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   1446f:	eb 0a                	jmp    1447b <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   14471:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14474:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   14477:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   1447b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1447e:	8d 50 ff             	lea    -0x1(%eax),%edx
   14481:	89 55 ec             	mov    %edx,-0x14(%ebp)
   14484:	85 c0                	test   %eax,%eax
   14486:	75 e9                	jne    14471 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   14488:	8b 45 08             	mov    0x8(%ebp),%eax
   1448b:	8b 40 0c             	mov    0xc(%eax),%eax
   1448e:	83 f8 10             	cmp    $0x10,%eax
   14491:	0f 8f 55 fe ff ff    	jg     142ec <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14497:	8b 45 08             	mov    0x8(%ebp),%eax
   1449a:	8b 40 0c             	mov    0xc(%eax),%eax
   1449d:	85 c0                	test   %eax,%eax
   1449f:	74 0c                	je     144ad <_DecodeDHT+0x1e8>
   144a1:	8b 45 08             	mov    0x8(%ebp),%eax
   144a4:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   144aa:	eb 01                	jmp    144ad <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   144ac:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   144ad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   144b0:	c9                   	leave  
   144b1:	c3                   	ret    

000144b2 <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   144b2:	55                   	push   %ebp
   144b3:	89 e5                	mov    %esp,%ebp
   144b5:	53                   	push   %ebx
   144b6:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   144b9:	83 ec 0c             	sub    $0xc,%esp
   144bc:	ff 75 08             	pushl  0x8(%ebp)
   144bf:	e8 62 f7 ff ff       	call   13c26 <_DecodeLength>
   144c4:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   144c7:	8b 45 08             	mov    0x8(%ebp),%eax
   144ca:	8b 00                	mov    (%eax),%eax
   144cc:	85 c0                	test   %eax,%eax
   144ce:	0f 85 e2 00 00 00    	jne    145b6 <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   144d4:	e9 b8 00 00 00       	jmp    14591 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   144d9:	8b 45 08             	mov    0x8(%ebp),%eax
   144dc:	8b 40 04             	mov    0x4(%eax),%eax
   144df:	0f b6 00             	movzbl (%eax),%eax
   144e2:	0f b6 c0             	movzbl %al,%eax
   144e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   144e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144eb:	25 ec 00 00 00       	and    $0xec,%eax
   144f0:	85 c0                	test   %eax,%eax
   144f2:	74 0e                	je     14502 <_DecodeDQT+0x50>
   144f4:	8b 45 08             	mov    0x8(%ebp),%eax
   144f7:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   144fd:	e9 b5 00 00 00       	jmp    145b7 <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   14502:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14505:	83 e0 10             	and    $0x10,%eax
   14508:	85 c0                	test   %eax,%eax
   1450a:	74 0e                	je     1451a <_DecodeDQT+0x68>
   1450c:	8b 45 08             	mov    0x8(%ebp),%eax
   1450f:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14515:	e9 9d 00 00 00       	jmp    145b7 <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   1451a:	8b 45 08             	mov    0x8(%ebp),%eax
   1451d:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   14523:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14526:	bb 01 00 00 00       	mov    $0x1,%ebx
   1452b:	89 c1                	mov    %eax,%ecx
   1452d:	d3 e3                	shl    %cl,%ebx
   1452f:	89 d8                	mov    %ebx,%eax
   14531:	09 c2                	or     %eax,%edx
   14533:	8b 45 08             	mov    0x8(%ebp),%eax
   14536:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   1453c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1453f:	c1 e0 06             	shl    $0x6,%eax
   14542:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   14548:	8b 45 08             	mov    0x8(%ebp),%eax
   1454b:	01 d0                	add    %edx,%eax
   1454d:	83 c0 08             	add    $0x8,%eax
   14550:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   14553:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1455a:	eb 1f                	jmp    1457b <_DecodeDQT+0xc9>
   1455c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1455f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14562:	01 c2                	add    %eax,%edx
   14564:	8b 45 08             	mov    0x8(%ebp),%eax
   14567:	8b 40 04             	mov    0x4(%eax),%eax
   1456a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1456d:	83 c1 01             	add    $0x1,%ecx
   14570:	01 c8                	add    %ecx,%eax
   14572:	0f b6 00             	movzbl (%eax),%eax
   14575:	88 02                	mov    %al,(%edx)
   14577:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1457b:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   1457f:	7e db                	jle    1455c <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   14581:	83 ec 08             	sub    $0x8,%esp
   14584:	6a 41                	push   $0x41
   14586:	ff 75 08             	pushl  0x8(%ebp)
   14589:	e8 4c f6 ff ff       	call   13bda <_Skip>
   1458e:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   14591:	8b 45 08             	mov    0x8(%ebp),%eax
   14594:	8b 40 0c             	mov    0xc(%eax),%eax
   14597:	83 f8 40             	cmp    $0x40,%eax
   1459a:	0f 8f 39 ff ff ff    	jg     144d9 <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   145a0:	8b 45 08             	mov    0x8(%ebp),%eax
   145a3:	8b 40 0c             	mov    0xc(%eax),%eax
   145a6:	85 c0                	test   %eax,%eax
   145a8:	74 0d                	je     145b7 <_DecodeDQT+0x105>
   145aa:	8b 45 08             	mov    0x8(%ebp),%eax
   145ad:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   145b3:	90                   	nop
   145b4:	eb 01                	jmp    145b7 <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   145b6:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   145b7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   145ba:	c9                   	leave  
   145bb:	c3                   	ret    

000145bc <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   145bc:	55                   	push   %ebp
   145bd:	89 e5                	mov    %esp,%ebp
   145bf:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   145c2:	83 ec 0c             	sub    $0xc,%esp
   145c5:	ff 75 08             	pushl  0x8(%ebp)
   145c8:	e8 59 f6 ff ff       	call   13c26 <_DecodeLength>
   145cd:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   145d0:	8b 45 08             	mov    0x8(%ebp),%eax
   145d3:	8b 00                	mov    (%eax),%eax
   145d5:	85 c0                	test   %eax,%eax
   145d7:	75 4a                	jne    14623 <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   145d9:	8b 45 08             	mov    0x8(%ebp),%eax
   145dc:	8b 40 0c             	mov    0xc(%eax),%eax
   145df:	83 f8 01             	cmp    $0x1,%eax
   145e2:	7f 0b                	jg     145ef <_DecodeDRI+0x33>
   145e4:	8b 45 08             	mov    0x8(%ebp),%eax
   145e7:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   145ed:	eb 35                	jmp    14624 <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   145ef:	8b 45 08             	mov    0x8(%ebp),%eax
   145f2:	8b 40 04             	mov    0x4(%eax),%eax
   145f5:	83 ec 0c             	sub    $0xc,%esp
   145f8:	50                   	push   %eax
   145f9:	e8 8b f6 ff ff       	call   13c89 <_Decode2Bytes>
   145fe:	83 c4 10             	add    $0x10,%esp
   14601:	89 c2                	mov    %eax,%edx
   14603:	8b 45 08             	mov    0x8(%ebp),%eax
   14606:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   1460c:	8b 45 08             	mov    0x8(%ebp),%eax
   1460f:	8b 40 0c             	mov    0xc(%eax),%eax
   14612:	83 ec 08             	sub    $0x8,%esp
   14615:	50                   	push   %eax
   14616:	ff 75 08             	pushl  0x8(%ebp)
   14619:	e8 bc f5 ff ff       	call   13bda <_Skip>
   1461e:	83 c4 10             	add    $0x10,%esp
   14621:	eb 01                	jmp    14624 <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   14623:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   14624:	c9                   	leave  
   14625:	c3                   	ret    

00014626 <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   14626:	55                   	push   %ebp
   14627:	89 e5                	mov    %esp,%ebp
   14629:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   1462c:	8b 45 08             	mov    0x8(%ebp),%eax
   1462f:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14635:	89 45 e0             	mov    %eax,-0x20(%ebp)
   14638:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   1463f:	83 ec 0c             	sub    $0xc,%esp
   14642:	ff 75 08             	pushl  0x8(%ebp)
   14645:	e8 dc f5 ff ff       	call   13c26 <_DecodeLength>
   1464a:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1464d:	8b 45 08             	mov    0x8(%ebp),%eax
   14650:	8b 00                	mov    (%eax),%eax
   14652:	85 c0                	test   %eax,%eax
   14654:	0f 85 c2 02 00 00    	jne    1491c <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   1465a:	8b 45 08             	mov    0x8(%ebp),%eax
   1465d:	8b 50 0c             	mov    0xc(%eax),%edx
   14660:	8b 45 08             	mov    0x8(%ebp),%eax
   14663:	8b 40 28             	mov    0x28(%eax),%eax
   14666:	83 c0 02             	add    $0x2,%eax
   14669:	01 c0                	add    %eax,%eax
   1466b:	39 c2                	cmp    %eax,%edx
   1466d:	7c 16                	jl     14685 <_DecodeSOS+0x5f>
   1466f:	8b 45 08             	mov    0x8(%ebp),%eax
   14672:	8b 40 04             	mov    0x4(%eax),%eax
   14675:	0f b6 00             	movzbl (%eax),%eax
   14678:	0f b6 d0             	movzbl %al,%edx
   1467b:	8b 45 08             	mov    0x8(%ebp),%eax
   1467e:	8b 40 28             	mov    0x28(%eax),%eax
   14681:	39 c2                	cmp    %eax,%edx
   14683:	74 0e                	je     14693 <_DecodeSOS+0x6d>
   14685:	8b 45 08             	mov    0x8(%ebp),%eax
   14688:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1468e:	e9 8d 02 00 00       	jmp    14920 <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   14693:	83 ec 08             	sub    $0x8,%esp
   14696:	6a 01                	push   $0x1
   14698:	ff 75 08             	pushl  0x8(%ebp)
   1469b:	e8 3a f5 ff ff       	call   13bda <_Skip>
   146a0:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   146a3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   146aa:	8b 45 08             	mov    0x8(%ebp),%eax
   146ad:	83 c0 2c             	add    $0x2c,%eax
   146b0:	89 45 dc             	mov    %eax,-0x24(%ebp)
   146b3:	e9 ba 00 00 00       	jmp    14772 <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   146b8:	8b 45 08             	mov    0x8(%ebp),%eax
   146bb:	8b 40 04             	mov    0x4(%eax),%eax
   146be:	0f b6 00             	movzbl (%eax),%eax
   146c1:	0f b6 d0             	movzbl %al,%edx
   146c4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   146c7:	8b 00                	mov    (%eax),%eax
   146c9:	39 c2                	cmp    %eax,%edx
   146cb:	74 0e                	je     146db <_DecodeSOS+0xb5>
   146cd:	8b 45 08             	mov    0x8(%ebp),%eax
   146d0:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146d6:	e9 45 02 00 00       	jmp    14920 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   146db:	8b 45 08             	mov    0x8(%ebp),%eax
   146de:	8b 40 04             	mov    0x4(%eax),%eax
   146e1:	83 c0 01             	add    $0x1,%eax
   146e4:	0f b6 00             	movzbl (%eax),%eax
   146e7:	0f b6 c0             	movzbl %al,%eax
   146ea:	25 ec 00 00 00       	and    $0xec,%eax
   146ef:	85 c0                	test   %eax,%eax
   146f1:	74 0e                	je     14701 <_DecodeSOS+0xdb>
   146f3:	8b 45 08             	mov    0x8(%ebp),%eax
   146f6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146fc:	e9 1f 02 00 00       	jmp    14920 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   14701:	8b 45 08             	mov    0x8(%ebp),%eax
   14704:	8b 40 04             	mov    0x4(%eax),%eax
   14707:	83 c0 01             	add    $0x1,%eax
   1470a:	0f b6 00             	movzbl (%eax),%eax
   1470d:	0f b6 c0             	movzbl %al,%eax
   14710:	83 e0 02             	and    $0x2,%eax
   14713:	85 c0                	test   %eax,%eax
   14715:	74 0e                	je     14725 <_DecodeSOS+0xff>
   14717:	8b 45 08             	mov    0x8(%ebp),%eax
   1471a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14720:	e9 fb 01 00 00       	jmp    14920 <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   14725:	8b 45 08             	mov    0x8(%ebp),%eax
   14728:	8b 40 04             	mov    0x4(%eax),%eax
   1472b:	83 c0 01             	add    $0x1,%eax
   1472e:	0f b6 00             	movzbl (%eax),%eax
   14731:	c0 e8 04             	shr    $0x4,%al
   14734:	0f b6 d0             	movzbl %al,%edx
   14737:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1473a:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   1473d:	8b 45 08             	mov    0x8(%ebp),%eax
   14740:	8b 40 04             	mov    0x4(%eax),%eax
   14743:	83 c0 01             	add    $0x1,%eax
   14746:	0f b6 00             	movzbl (%eax),%eax
   14749:	0f b6 c0             	movzbl %al,%eax
   1474c:	83 e0 01             	and    $0x1,%eax
   1474f:	83 c8 02             	or     $0x2,%eax
   14752:	89 c2                	mov    %eax,%edx
   14754:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14757:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   1475a:	83 ec 08             	sub    $0x8,%esp
   1475d:	6a 02                	push   $0x2
   1475f:	ff 75 08             	pushl  0x8(%ebp)
   14762:	e8 73 f4 ff ff       	call   13bda <_Skip>
   14767:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1476a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1476e:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14772:	8b 45 08             	mov    0x8(%ebp),%eax
   14775:	8b 40 28             	mov    0x28(%eax),%eax
   14778:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1477b:	0f 8f 37 ff ff ff    	jg     146b8 <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   14781:	8b 45 08             	mov    0x8(%ebp),%eax
   14784:	8b 40 04             	mov    0x4(%eax),%eax
   14787:	0f b6 00             	movzbl (%eax),%eax
   1478a:	84 c0                	test   %al,%al
   1478c:	75 10                	jne    1479e <_DecodeSOS+0x178>
   1478e:	8b 45 08             	mov    0x8(%ebp),%eax
   14791:	8b 40 04             	mov    0x4(%eax),%eax
   14794:	83 c0 01             	add    $0x1,%eax
   14797:	0f b6 00             	movzbl (%eax),%eax
   1479a:	3c 3f                	cmp    $0x3f,%al
   1479c:	74 0e                	je     147ac <_DecodeSOS+0x186>
   1479e:	8b 45 08             	mov    0x8(%ebp),%eax
   147a1:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   147a7:	e9 74 01 00 00       	jmp    14920 <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   147ac:	8b 45 08             	mov    0x8(%ebp),%eax
   147af:	8b 40 04             	mov    0x4(%eax),%eax
   147b2:	83 c0 02             	add    $0x2,%eax
   147b5:	0f b6 00             	movzbl (%eax),%eax
   147b8:	84 c0                	test   %al,%al
   147ba:	74 0e                	je     147ca <_DecodeSOS+0x1a4>
   147bc:	8b 45 08             	mov    0x8(%ebp),%eax
   147bf:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   147c5:	e9 56 01 00 00       	jmp    14920 <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   147ca:	8b 45 08             	mov    0x8(%ebp),%eax
   147cd:	8b 40 0c             	mov    0xc(%eax),%eax
   147d0:	83 ec 08             	sub    $0x8,%esp
   147d3:	50                   	push   %eax
   147d4:	ff 75 08             	pushl  0x8(%ebp)
   147d7:	e8 fe f3 ff ff       	call   13bda <_Skip>
   147dc:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   147df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   147e6:	e9 17 01 00 00       	jmp    14902 <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   147eb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   147f2:	e9 f8 00 00 00       	jmp    148ef <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   147f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   147fe:	8b 45 08             	mov    0x8(%ebp),%eax
   14801:	83 c0 2c             	add    $0x2c,%eax
   14804:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14807:	e9 8d 00 00 00       	jmp    14899 <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   1480c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   14813:	eb 71                	jmp    14886 <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14815:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   1481c:	eb 59                	jmp    14877 <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   1481e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14821:	8b 50 28             	mov    0x28(%eax),%edx
   14824:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14827:	8b 40 08             	mov    0x8(%eax),%eax
   1482a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1482e:	89 c1                	mov    %eax,%ecx
   14830:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14833:	01 c1                	add    %eax,%ecx
   14835:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14838:	8b 40 14             	mov    0x14(%eax),%eax
   1483b:	0f af c8             	imul   %eax,%ecx
   1483e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14841:	8b 40 04             	mov    0x4(%eax),%eax
   14844:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14848:	01 c1                	add    %eax,%ecx
   1484a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1484d:	01 c8                	add    %ecx,%eax
   1484f:	c1 e0 03             	shl    $0x3,%eax
   14852:	01 d0                	add    %edx,%eax
   14854:	50                   	push   %eax
   14855:	ff 75 dc             	pushl  -0x24(%ebp)
   14858:	ff 75 0c             	pushl  0xc(%ebp)
   1485b:	ff 75 08             	pushl  0x8(%ebp)
   1485e:	e8 bf 00 00 00       	call   14922 <_DecodeBlock>
   14863:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   14866:	8b 45 08             	mov    0x8(%ebp),%eax
   14869:	8b 00                	mov    (%eax),%eax
   1486b:	85 c0                	test   %eax,%eax
   1486d:	0f 85 ac 00 00 00    	jne    1491f <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14873:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   14877:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1487a:	8b 40 04             	mov    0x4(%eax),%eax
   1487d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   14880:	7f 9c                	jg     1481e <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   14882:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   14886:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14889:	8b 40 08             	mov    0x8(%eax),%eax
   1488c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1488f:	7f 84                	jg     14815 <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14891:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14895:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14899:	8b 45 08             	mov    0x8(%ebp),%eax
   1489c:	8b 40 28             	mov    0x28(%eax),%eax
   1489f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   148a2:	0f 8f 64 ff ff ff    	jg     1480c <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   148a8:	8b 45 08             	mov    0x8(%ebp),%eax
   148ab:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   148b1:	85 c0                	test   %eax,%eax
   148b3:	74 36                	je     148eb <_DecodeSOS+0x2c5>
   148b5:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   148b9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   148bd:	75 2c                	jne    148eb <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   148bf:	83 ec 0c             	sub    $0xc,%esp
   148c2:	ff 75 08             	pushl  0x8(%ebp)
   148c5:	e8 9f 0a 00 00       	call   15369 <_ByteAlign>
   148ca:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   148cd:	83 ec 08             	sub    $0x8,%esp
   148d0:	6a 10                	push   $0x10
   148d2:	ff 75 08             	pushl  0x8(%ebp)
   148d5:	e8 ce 04 00 00       	call   14da8 <_GetBits>
   148da:	83 c4 10             	add    $0x10,%esp
   148dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   148e0:	8b 45 08             	mov    0x8(%ebp),%eax
   148e3:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   148e9:	eb 35                	jmp    14920 <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   148eb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   148ef:	8b 45 08             	mov    0x8(%ebp),%eax
   148f2:	8b 40 18             	mov    0x18(%eax),%eax
   148f5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   148f8:	0f 8f f9 fe ff ff    	jg     147f7 <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   148fe:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   14902:	8b 45 08             	mov    0x8(%ebp),%eax
   14905:	8b 40 1c             	mov    0x1c(%eax),%eax
   14908:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1490b:	0f 8f da fe ff ff    	jg     147eb <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   14911:	8b 45 08             	mov    0x8(%ebp),%eax
   14914:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   1491a:	eb 04                	jmp    14920 <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   1491c:	90                   	nop
   1491d:	eb 01                	jmp    14920 <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   1491f:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   14920:	c9                   	leave  
   14921:	c3                   	ret    

00014922 <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   14922:	55                   	push   %ebp
   14923:	89 e5                	mov    %esp,%ebp
   14925:	53                   	push   %ebx
   14926:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   14929:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   14930:	8b 45 08             	mov    0x8(%ebp),%eax
   14933:	05 c0 01 08 00       	add    $0x801c0,%eax
   14938:	83 ec 04             	sub    $0x4,%esp
   1493b:	68 00 01 00 00       	push   $0x100
   14940:	6a 00                	push   $0x0
   14942:	50                   	push   %eax
   14943:	e8 04 b8 fe ff       	call   14c <memset>
   14948:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   1494b:	8b 45 10             	mov    0x10(%ebp),%eax
   1494e:	8b 40 20             	mov    0x20(%eax),%eax
   14951:	c1 e0 11             	shl    $0x11,%eax
   14954:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   1495a:	8b 45 08             	mov    0x8(%ebp),%eax
   1495d:	01 d0                	add    %edx,%eax
   1495f:	83 c0 08             	add    $0x8,%eax
   14962:	83 ec 04             	sub    $0x4,%esp
   14965:	6a 00                	push   $0x0
   14967:	50                   	push   %eax
   14968:	ff 75 08             	pushl  0x8(%ebp)
   1496b:	e8 86 01 00 00       	call   14af6 <_GetVLC>
   14970:	83 c4 10             	add    $0x10,%esp
   14973:	89 c2                	mov    %eax,%edx
   14975:	8b 45 10             	mov    0x10(%ebp),%eax
   14978:	8b 40 24             	mov    0x24(%eax),%eax
   1497b:	01 c2                	add    %eax,%edx
   1497d:	8b 45 10             	mov    0x10(%ebp),%eax
   14980:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   14983:	8b 45 10             	mov    0x10(%ebp),%eax
   14986:	8b 50 24             	mov    0x24(%eax),%edx
   14989:	8b 45 10             	mov    0x10(%ebp),%eax
   1498c:	8b 48 18             	mov    0x18(%eax),%ecx
   1498f:	8b 45 08             	mov    0x8(%ebp),%eax
   14992:	c1 e1 06             	shl    $0x6,%ecx
   14995:	01 c8                	add    %ecx,%eax
   14997:	05 b8 00 00 00       	add    $0xb8,%eax
   1499c:	0f b6 00             	movzbl (%eax),%eax
   1499f:	0f b6 c0             	movzbl %al,%eax
   149a2:	0f af d0             	imul   %eax,%edx
   149a5:	8b 45 08             	mov    0x8(%ebp),%eax
   149a8:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   149ae:	8b 45 10             	mov    0x10(%ebp),%eax
   149b1:	8b 40 1c             	mov    0x1c(%eax),%eax
   149b4:	c1 e0 11             	shl    $0x11,%eax
   149b7:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   149bd:	8b 45 08             	mov    0x8(%ebp),%eax
   149c0:	01 d0                	add    %edx,%eax
   149c2:	8d 50 08             	lea    0x8(%eax),%edx
   149c5:	83 ec 04             	sub    $0x4,%esp
   149c8:	8d 45 ef             	lea    -0x11(%ebp),%eax
   149cb:	50                   	push   %eax
   149cc:	52                   	push   %edx
   149cd:	ff 75 08             	pushl  0x8(%ebp)
   149d0:	e8 21 01 00 00       	call   14af6 <_GetVLC>
   149d5:	83 c4 10             	add    $0x10,%esp
   149d8:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   149db:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149df:	84 c0                	test   %al,%al
   149e1:	0f 84 92 00 00 00    	je     14a79 <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   149e7:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149eb:	0f b6 c0             	movzbl %al,%eax
   149ee:	83 e0 0f             	and    $0xf,%eax
   149f1:	85 c0                	test   %eax,%eax
   149f3:	75 16                	jne    14a0b <_DecodeBlock+0xe9>
   149f5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149f9:	3c f0                	cmp    $0xf0,%al
   149fb:	74 0e                	je     14a0b <_DecodeBlock+0xe9>
   149fd:	8b 45 08             	mov    0x8(%ebp),%eax
   14a00:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a06:	e9 e6 00 00 00       	jmp    14af1 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   14a0b:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14a0f:	c0 e8 04             	shr    $0x4,%al
   14a12:	0f b6 c0             	movzbl %al,%eax
   14a15:	83 c0 01             	add    $0x1,%eax
   14a18:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   14a1b:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14a1f:	7e 0e                	jle    14a2f <_DecodeBlock+0x10d>
   14a21:	8b 45 08             	mov    0x8(%ebp),%eax
   14a24:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a2a:	e9 c2 00 00 00       	jmp    14af1 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   14a2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14a32:	8b 45 0c             	mov    0xc(%ebp),%eax
   14a35:	01 d0                	add    %edx,%eax
   14a37:	0f b6 00             	movzbl (%eax),%eax
   14a3a:	0f be c8             	movsbl %al,%ecx
   14a3d:	8b 45 10             	mov    0x10(%ebp),%eax
   14a40:	8b 50 18             	mov    0x18(%eax),%edx
   14a43:	8b 45 08             	mov    0x8(%ebp),%eax
   14a46:	c1 e2 06             	shl    $0x6,%edx
   14a49:	01 c2                	add    %eax,%edx
   14a4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a4e:	01 d0                	add    %edx,%eax
   14a50:	05 b8 00 00 00       	add    $0xb8,%eax
   14a55:	0f b6 00             	movzbl (%eax),%eax
   14a58:	0f b6 c0             	movzbl %al,%eax
   14a5b:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14a5f:	89 c2                	mov    %eax,%edx
   14a61:	8b 45 08             	mov    0x8(%ebp),%eax
   14a64:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   14a6a:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   14a6d:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   14a71:	0f 8e 37 ff ff ff    	jle    149ae <_DecodeBlock+0x8c>
   14a77:	eb 01                	jmp    14a7a <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   14a79:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   14a7a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14a81:	eb 24                	jmp    14aa7 <_DecodeBlock+0x185>
   14a83:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a86:	05 70 00 02 00       	add    $0x20070,%eax
   14a8b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14a92:	8b 45 08             	mov    0x8(%ebp),%eax
   14a95:	01 d0                	add    %edx,%eax
   14a97:	83 ec 0c             	sub    $0xc,%esp
   14a9a:	50                   	push   %eax
   14a9b:	e8 32 03 00 00       	call   14dd2 <_RowIDCT>
   14aa0:	83 c4 10             	add    $0x10,%esp
   14aa3:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   14aa7:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14aab:	7e d6                	jle    14a83 <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   14aad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14ab4:	eb 35                	jmp    14aeb <_DecodeBlock+0x1c9>
   14ab6:	8b 45 10             	mov    0x10(%ebp),%eax
   14ab9:	8b 40 14             	mov    0x14(%eax),%eax
   14abc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14abf:	8b 55 14             	mov    0x14(%ebp),%edx
   14ac2:	01 d1                	add    %edx,%ecx
   14ac4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14ac7:	81 c2 70 00 02 00    	add    $0x20070,%edx
   14acd:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   14ad4:	8b 55 08             	mov    0x8(%ebp),%edx
   14ad7:	01 da                	add    %ebx,%edx
   14ad9:	83 ec 04             	sub    $0x4,%esp
   14adc:	50                   	push   %eax
   14add:	51                   	push   %ecx
   14ade:	52                   	push   %edx
   14adf:	e8 7b 05 00 00       	call   1505f <_ColIDCT>
   14ae4:	83 c4 10             	add    $0x10,%esp
   14ae7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14aeb:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14aef:	7e c5                	jle    14ab6 <_DecodeBlock+0x194>
}
   14af1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14af4:	c9                   	leave  
   14af5:	c3                   	ret    

00014af6 <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   14af6:	55                   	push   %ebp
   14af7:	89 e5                	mov    %esp,%ebp
   14af9:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   14afc:	83 ec 08             	sub    $0x8,%esp
   14aff:	6a 10                	push   $0x10
   14b01:	ff 75 08             	pushl  0x8(%ebp)
   14b04:	e8 c2 00 00 00       	call   14bcb <_ShowBits>
   14b09:	83 c4 10             	add    $0x10,%esp
   14b0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   14b0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b12:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14b15:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b18:	01 d0                	add    %edx,%eax
   14b1a:	0f b6 00             	movzbl (%eax),%eax
   14b1d:	0f b6 c0             	movzbl %al,%eax
   14b20:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   14b23:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14b27:	75 13                	jne    14b3c <_GetVLC+0x46>
   14b29:	8b 45 08             	mov    0x8(%ebp),%eax
   14b2c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14b32:	b8 00 00 00 00       	mov    $0x0,%eax
   14b37:	e9 8d 00 00 00       	jmp    14bc9 <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   14b3c:	83 ec 08             	sub    $0x8,%esp
   14b3f:	ff 75 f0             	pushl  -0x10(%ebp)
   14b42:	ff 75 08             	pushl  0x8(%ebp)
   14b45:	e8 25 02 00 00       	call   14d6f <_SkipBits>
   14b4a:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   14b4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b50:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14b53:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b56:	01 d0                	add    %edx,%eax
   14b58:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   14b5c:	0f b6 c0             	movzbl %al,%eax
   14b5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   14b62:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14b66:	74 0a                	je     14b72 <_GetVLC+0x7c>
   14b68:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b6b:	89 c2                	mov    %eax,%edx
   14b6d:	8b 45 10             	mov    0x10(%ebp),%eax
   14b70:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   14b72:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b75:	83 e0 0f             	and    $0xf,%eax
   14b78:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   14b7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14b7f:	75 07                	jne    14b88 <_GetVLC+0x92>
   14b81:	b8 00 00 00 00       	mov    $0x0,%eax
   14b86:	eb 41                	jmp    14bc9 <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   14b88:	83 ec 08             	sub    $0x8,%esp
   14b8b:	ff 75 f0             	pushl  -0x10(%ebp)
   14b8e:	ff 75 08             	pushl  0x8(%ebp)
   14b91:	e8 12 02 00 00       	call   14da8 <_GetBits>
   14b96:	83 c4 10             	add    $0x10,%esp
   14b99:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   14b9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14b9f:	83 e8 01             	sub    $0x1,%eax
   14ba2:	ba 01 00 00 00       	mov    $0x1,%edx
   14ba7:	89 c1                	mov    %eax,%ecx
   14ba9:	d3 e2                	shl    %cl,%edx
   14bab:	89 d0                	mov    %edx,%eax
   14bad:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14bb0:	7e 14                	jle    14bc6 <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   14bb2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14bb5:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   14bba:	89 c1                	mov    %eax,%ecx
   14bbc:	d3 e2                	shl    %cl,%edx
   14bbe:	89 d0                	mov    %edx,%eax
   14bc0:	83 c0 01             	add    $0x1,%eax
   14bc3:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   14bc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14bc9:	c9                   	leave  
   14bca:	c3                   	ret    

00014bcb <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   14bcb:	55                   	push   %ebp
   14bcc:	89 e5                	mov    %esp,%ebp
   14bce:	53                   	push   %ebx
   14bcf:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   14bd2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14bd6:	0f 85 4f 01 00 00    	jne    14d2b <_ShowBits+0x160>
   14bdc:	b8 00 00 00 00       	mov    $0x0,%eax
   14be1:	e9 83 01 00 00       	jmp    14d69 <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   14be6:	8b 45 08             	mov    0x8(%ebp),%eax
   14be9:	8b 40 08             	mov    0x8(%eax),%eax
   14bec:	85 c0                	test   %eax,%eax
   14bee:	7f 33                	jg     14c23 <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   14bf0:	8b 45 08             	mov    0x8(%ebp),%eax
   14bf3:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14bf9:	c1 e0 08             	shl    $0x8,%eax
   14bfc:	0c ff                	or     $0xff,%al
   14bfe:	89 c2                	mov    %eax,%edx
   14c00:	8b 45 08             	mov    0x8(%ebp),%eax
   14c03:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   14c09:	8b 45 08             	mov    0x8(%ebp),%eax
   14c0c:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14c12:	8d 50 08             	lea    0x8(%eax),%edx
   14c15:	8b 45 08             	mov    0x8(%ebp),%eax
   14c18:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   14c1e:	e9 08 01 00 00       	jmp    14d2b <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   14c23:	8b 45 08             	mov    0x8(%ebp),%eax
   14c26:	8b 40 04             	mov    0x4(%eax),%eax
   14c29:	8d 48 01             	lea    0x1(%eax),%ecx
   14c2c:	8b 55 08             	mov    0x8(%ebp),%edx
   14c2f:	89 4a 04             	mov    %ecx,0x4(%edx)
   14c32:	0f b6 00             	movzbl (%eax),%eax
   14c35:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   14c38:	8b 45 08             	mov    0x8(%ebp),%eax
   14c3b:	8b 40 08             	mov    0x8(%eax),%eax
   14c3e:	8d 50 ff             	lea    -0x1(%eax),%edx
   14c41:	8b 45 08             	mov    0x8(%ebp),%eax
   14c44:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   14c47:	8b 45 08             	mov    0x8(%ebp),%eax
   14c4a:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14c50:	8d 50 08             	lea    0x8(%eax),%edx
   14c53:	8b 45 08             	mov    0x8(%ebp),%eax
   14c56:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   14c5c:	8b 45 08             	mov    0x8(%ebp),%eax
   14c5f:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14c65:	c1 e0 08             	shl    $0x8,%eax
   14c68:	89 c2                	mov    %eax,%edx
   14c6a:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   14c6e:	09 c2                	or     %eax,%edx
   14c70:	8b 45 08             	mov    0x8(%ebp),%eax
   14c73:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   14c79:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   14c7d:	0f 85 a8 00 00 00    	jne    14d2b <_ShowBits+0x160>
            if(ctx->size){
   14c83:	8b 45 08             	mov    0x8(%ebp),%eax
   14c86:	8b 40 08             	mov    0x8(%eax),%eax
   14c89:	85 c0                	test   %eax,%eax
   14c8b:	0f 84 91 00 00 00    	je     14d22 <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   14c91:	8b 45 08             	mov    0x8(%ebp),%eax
   14c94:	8b 40 04             	mov    0x4(%eax),%eax
   14c97:	8d 48 01             	lea    0x1(%eax),%ecx
   14c9a:	8b 55 08             	mov    0x8(%ebp),%edx
   14c9d:	89 4a 04             	mov    %ecx,0x4(%edx)
   14ca0:	0f b6 00             	movzbl (%eax),%eax
   14ca3:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   14ca6:	8b 45 08             	mov    0x8(%ebp),%eax
   14ca9:	8b 40 08             	mov    0x8(%eax),%eax
   14cac:	8d 50 ff             	lea    -0x1(%eax),%edx
   14caf:	8b 45 08             	mov    0x8(%ebp),%eax
   14cb2:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   14cb5:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14cb9:	85 c0                	test   %eax,%eax
   14cbb:	74 62                	je     14d1f <_ShowBits+0x154>
   14cbd:	3d d9 00 00 00       	cmp    $0xd9,%eax
   14cc2:	75 0c                	jne    14cd0 <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   14cc4:	8b 45 08             	mov    0x8(%ebp),%eax
   14cc7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   14cce:	eb 5b                	jmp    14d2b <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   14cd0:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14cd4:	25 f8 00 00 00       	and    $0xf8,%eax
   14cd9:	3d d0 00 00 00       	cmp    $0xd0,%eax
   14cde:	74 0b                	je     14ceb <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   14ce0:	8b 45 08             	mov    0x8(%ebp),%eax
   14ce3:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14ce9:	eb 40                	jmp    14d2b <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   14ceb:	8b 45 08             	mov    0x8(%ebp),%eax
   14cee:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14cf4:	c1 e0 08             	shl    $0x8,%eax
   14cf7:	89 c2                	mov    %eax,%edx
   14cf9:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14cfd:	09 c2                	or     %eax,%edx
   14cff:	8b 45 08             	mov    0x8(%ebp),%eax
   14d02:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   14d08:	8b 45 08             	mov    0x8(%ebp),%eax
   14d0b:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d11:	8d 50 08             	lea    0x8(%eax),%edx
   14d14:	8b 45 08             	mov    0x8(%ebp),%eax
   14d17:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   14d1d:	eb 0c                	jmp    14d2b <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   14d1f:	90                   	nop
   14d20:	eb 09                	jmp    14d2b <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   14d22:	8b 45 08             	mov    0x8(%ebp),%eax
   14d25:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   14d2b:	8b 45 08             	mov    0x8(%ebp),%eax
   14d2e:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d34:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14d37:	0f 8c a9 fe ff ff    	jl     14be6 <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   14d3d:	8b 45 08             	mov    0x8(%ebp),%eax
   14d40:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   14d46:	8b 45 08             	mov    0x8(%ebp),%eax
   14d49:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d4f:	2b 45 0c             	sub    0xc(%ebp),%eax
   14d52:	89 c1                	mov    %eax,%ecx
   14d54:	d3 fa                	sar    %cl,%edx
   14d56:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d59:	bb 01 00 00 00       	mov    $0x1,%ebx
   14d5e:	89 c1                	mov    %eax,%ecx
   14d60:	d3 e3                	shl    %cl,%ebx
   14d62:	89 d8                	mov    %ebx,%eax
   14d64:	83 e8 01             	sub    $0x1,%eax
   14d67:	21 d0                	and    %edx,%eax
}
   14d69:	83 c4 10             	add    $0x10,%esp
   14d6c:	5b                   	pop    %ebx
   14d6d:	5d                   	pop    %ebp
   14d6e:	c3                   	ret    

00014d6f <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   14d6f:	55                   	push   %ebp
   14d70:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   14d72:	8b 45 08             	mov    0x8(%ebp),%eax
   14d75:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d7b:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14d7e:	7d 0e                	jge    14d8e <_SkipBits+0x1f>
   14d80:	ff 75 0c             	pushl  0xc(%ebp)
   14d83:	ff 75 08             	pushl  0x8(%ebp)
   14d86:	e8 40 fe ff ff       	call   14bcb <_ShowBits>
   14d8b:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   14d8e:	8b 45 08             	mov    0x8(%ebp),%eax
   14d91:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d97:	2b 45 0c             	sub    0xc(%ebp),%eax
   14d9a:	89 c2                	mov    %eax,%edx
   14d9c:	8b 45 08             	mov    0x8(%ebp),%eax
   14d9f:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   14da5:	90                   	nop
   14da6:	c9                   	leave  
   14da7:	c3                   	ret    

00014da8 <_GetBits>:

int _GetBits(Context* ctx, int bits){
   14da8:	55                   	push   %ebp
   14da9:	89 e5                	mov    %esp,%ebp
   14dab:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   14dae:	ff 75 0c             	pushl  0xc(%ebp)
   14db1:	ff 75 08             	pushl  0x8(%ebp)
   14db4:	e8 12 fe ff ff       	call   14bcb <_ShowBits>
   14db9:	83 c4 08             	add    $0x8,%esp
   14dbc:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   14dbf:	ff 75 0c             	pushl  0xc(%ebp)
   14dc2:	ff 75 08             	pushl  0x8(%ebp)
   14dc5:	e8 a5 ff ff ff       	call   14d6f <_SkipBits>
   14dca:	83 c4 08             	add    $0x8,%esp
    return res;
   14dcd:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   14dd0:	c9                   	leave  
   14dd1:	c3                   	ret    

00014dd2 <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   14dd2:	55                   	push   %ebp
   14dd3:	89 e5                	mov    %esp,%ebp
   14dd5:	57                   	push   %edi
   14dd6:	56                   	push   %esi
   14dd7:	53                   	push   %ebx
   14dd8:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14ddb:	8b 45 08             	mov    0x8(%ebp),%eax
   14dde:	83 c0 10             	add    $0x10,%eax
   14de1:	8b 00                	mov    (%eax),%eax
   14de3:	c1 e0 0b             	shl    $0xb,%eax
   14de6:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   14de9:	8b 45 08             	mov    0x8(%ebp),%eax
   14dec:	8b 40 18             	mov    0x18(%eax),%eax
   14def:	89 45 ec             	mov    %eax,-0x14(%ebp)
   14df2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14df5:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   14df8:	8b 55 08             	mov    0x8(%ebp),%edx
   14dfb:	8b 52 08             	mov    0x8(%edx),%edx
   14dfe:	89 55 e8             	mov    %edx,-0x18(%ebp)
   14e01:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   14e04:	8b 55 08             	mov    0x8(%ebp),%edx
   14e07:	8b 52 04             	mov    0x4(%edx),%edx
   14e0a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   14e0d:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   14e10:	8b 55 08             	mov    0x8(%ebp),%edx
   14e13:	8b 52 1c             	mov    0x1c(%edx),%edx
   14e16:	89 55 e0             	mov    %edx,-0x20(%ebp)
   14e19:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   14e1c:	8b 55 08             	mov    0x8(%ebp),%edx
   14e1f:	8b 52 14             	mov    0x14(%edx),%edx
   14e22:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14e25:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   14e28:	8b 55 08             	mov    0x8(%ebp),%edx
   14e2b:	8b 52 0c             	mov    0xc(%edx),%edx
   14e2e:	89 55 d8             	mov    %edx,-0x28(%ebp)
   14e31:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14e34:	85 c0                	test   %eax,%eax
   14e36:	75 68                	jne    14ea0 <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   14e38:	8b 45 08             	mov    0x8(%ebp),%eax
   14e3b:	8d 48 04             	lea    0x4(%eax),%ecx
   14e3e:	8b 45 08             	mov    0x8(%ebp),%eax
   14e41:	8d 58 08             	lea    0x8(%eax),%ebx
   14e44:	8b 45 08             	mov    0x8(%ebp),%eax
   14e47:	8d 70 0c             	lea    0xc(%eax),%esi
   14e4a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e4d:	8d 78 10             	lea    0x10(%eax),%edi
   14e50:	8b 45 08             	mov    0x8(%ebp),%eax
   14e53:	83 c0 14             	add    $0x14,%eax
   14e56:	89 45 c0             	mov    %eax,-0x40(%ebp)
   14e59:	8b 45 08             	mov    0x8(%ebp),%eax
   14e5c:	83 c0 18             	add    $0x18,%eax
   14e5f:	89 45 bc             	mov    %eax,-0x44(%ebp)
   14e62:	8b 45 08             	mov    0x8(%ebp),%eax
   14e65:	8d 50 1c             	lea    0x1c(%eax),%edx
   14e68:	8b 45 08             	mov    0x8(%ebp),%eax
   14e6b:	8b 00                	mov    (%eax),%eax
   14e6d:	c1 e0 03             	shl    $0x3,%eax
   14e70:	89 02                	mov    %eax,(%edx)
   14e72:	8b 02                	mov    (%edx),%eax
   14e74:	8b 55 bc             	mov    -0x44(%ebp),%edx
   14e77:	89 02                	mov    %eax,(%edx)
   14e79:	89 d0                	mov    %edx,%eax
   14e7b:	8b 00                	mov    (%eax),%eax
   14e7d:	8b 55 c0             	mov    -0x40(%ebp),%edx
   14e80:	89 02                	mov    %eax,(%edx)
   14e82:	89 d0                	mov    %edx,%eax
   14e84:	8b 00                	mov    (%eax),%eax
   14e86:	89 07                	mov    %eax,(%edi)
   14e88:	8b 07                	mov    (%edi),%eax
   14e8a:	89 06                	mov    %eax,(%esi)
   14e8c:	8b 06                	mov    (%esi),%eax
   14e8e:	89 03                	mov    %eax,(%ebx)
   14e90:	8b 03                	mov    (%ebx),%eax
   14e92:	89 01                	mov    %eax,(%ecx)
   14e94:	8b 11                	mov    (%ecx),%edx
   14e96:	8b 45 08             	mov    0x8(%ebp),%eax
   14e99:	89 10                	mov    %edx,(%eax)
        return;
   14e9b:	e9 b7 01 00 00       	jmp    15057 <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   14ea0:	8b 45 08             	mov    0x8(%ebp),%eax
   14ea3:	8b 00                	mov    (%eax),%eax
   14ea5:	c1 e0 0b             	shl    $0xb,%eax
   14ea8:	83 e8 80             	sub    $0xffffff80,%eax
   14eab:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   14eae:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14eb1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14eb4:	01 d0                	add    %edx,%eax
   14eb6:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   14ebc:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   14ebf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14ec2:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   14ec8:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ecb:	01 d0                	add    %edx,%eax
   14ecd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   14ed0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14ed3:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   14ed9:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14edc:	01 d0                	add    %edx,%eax
   14ede:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   14ee1:	8b 55 dc             	mov    -0x24(%ebp),%edx
   14ee4:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14ee7:	01 d0                	add    %edx,%eax
   14ee9:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   14eef:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   14ef2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14ef5:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   14efb:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14efe:	01 d0                	add    %edx,%eax
   14f00:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   14f03:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f06:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   14f0c:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14f0f:	01 d0                	add    %edx,%eax
   14f11:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   14f14:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14f17:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f1a:	01 d0                	add    %edx,%eax
   14f1c:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   14f1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f22:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   14f25:	8b 55 e8             	mov    -0x18(%ebp),%edx
   14f28:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f2b:	01 d0                	add    %edx,%eax
   14f2d:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14f33:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   14f36:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f39:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   14f3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f42:	01 d0                	add    %edx,%eax
   14f44:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   14f47:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f4a:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   14f50:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f53:	01 d0                	add    %edx,%eax
   14f55:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   14f58:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14f5b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f5e:	01 d0                	add    %edx,%eax
   14f60:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   14f63:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f66:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   14f69:	8b 55 e0             	mov    -0x20(%ebp),%edx
   14f6c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f6f:	01 d0                	add    %edx,%eax
   14f71:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   14f74:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f77:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   14f7a:	8b 55 d0             	mov    -0x30(%ebp),%edx
   14f7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f80:	01 d0                	add    %edx,%eax
   14f82:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   14f85:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f88:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   14f8b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14f8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f91:	01 d0                	add    %edx,%eax
   14f93:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   14f96:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f99:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   14f9c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14f9f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14fa2:	01 d0                	add    %edx,%eax
   14fa4:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   14faa:	83 e8 80             	sub    $0xffffff80,%eax
   14fad:	c1 f8 08             	sar    $0x8,%eax
   14fb0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   14fb3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14fb6:	2b 45 e0             	sub    -0x20(%ebp),%eax
   14fb9:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   14fbf:	83 e8 80             	sub    $0xffffff80,%eax
   14fc2:	c1 f8 08             	sar    $0x8,%eax
   14fc5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   14fc8:	8b 55 d8             	mov    -0x28(%ebp),%edx
   14fcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14fce:	01 d0                	add    %edx,%eax
   14fd0:	c1 f8 08             	sar    $0x8,%eax
   14fd3:	89 c2                	mov    %eax,%edx
   14fd5:	8b 45 08             	mov    0x8(%ebp),%eax
   14fd8:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   14fda:	8b 45 08             	mov    0x8(%ebp),%eax
   14fdd:	83 c0 04             	add    $0x4,%eax
   14fe0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   14fe3:	8b 55 ec             	mov    -0x14(%ebp),%edx
   14fe6:	01 ca                	add    %ecx,%edx
   14fe8:	c1 fa 08             	sar    $0x8,%edx
   14feb:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   14fed:	8b 45 08             	mov    0x8(%ebp),%eax
   14ff0:	83 c0 08             	add    $0x8,%eax
   14ff3:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   14ff6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14ff9:	01 ca                	add    %ecx,%edx
   14ffb:	c1 fa 08             	sar    $0x8,%edx
   14ffe:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   15000:	8b 45 08             	mov    0x8(%ebp),%eax
   15003:	83 c0 0c             	add    $0xc,%eax
   15006:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   15009:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1500c:	01 ca                	add    %ecx,%edx
   1500e:	c1 fa 08             	sar    $0x8,%edx
   15011:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   15013:	8b 45 08             	mov    0x8(%ebp),%eax
   15016:	8d 50 10             	lea    0x10(%eax),%edx
   15019:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1501c:	2b 45 dc             	sub    -0x24(%ebp),%eax
   1501f:	c1 f8 08             	sar    $0x8,%eax
   15022:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   15024:	8b 45 08             	mov    0x8(%ebp),%eax
   15027:	8d 50 14             	lea    0x14(%eax),%edx
   1502a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1502d:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   15030:	c1 f8 08             	sar    $0x8,%eax
   15033:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   15035:	8b 45 08             	mov    0x8(%ebp),%eax
   15038:	8d 50 18             	lea    0x18(%eax),%edx
   1503b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1503e:	2b 45 ec             	sub    -0x14(%ebp),%eax
   15041:	c1 f8 08             	sar    $0x8,%eax
   15044:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   15046:	8b 45 08             	mov    0x8(%ebp),%eax
   15049:	8d 50 1c             	lea    0x1c(%eax),%edx
   1504c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1504f:	2b 45 f0             	sub    -0x10(%ebp),%eax
   15052:	c1 f8 08             	sar    $0x8,%eax
   15055:	89 02                	mov    %eax,(%edx)
}
   15057:	83 c4 38             	add    $0x38,%esp
   1505a:	5b                   	pop    %ebx
   1505b:	5e                   	pop    %esi
   1505c:	5f                   	pop    %edi
   1505d:	5d                   	pop    %ebp
   1505e:	c3                   	ret    

0001505f <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   1505f:	55                   	push   %ebp
   15060:	89 e5                	mov    %esp,%ebp
   15062:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   15065:	8b 45 08             	mov    0x8(%ebp),%eax
   15068:	83 e8 80             	sub    $0xffffff80,%eax
   1506b:	8b 00                	mov    (%eax),%eax
   1506d:	c1 e0 08             	shl    $0x8,%eax
   15070:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   15073:	8b 45 08             	mov    0x8(%ebp),%eax
   15076:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   1507c:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1507f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15082:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   15085:	8b 55 08             	mov    0x8(%ebp),%edx
   15088:	8b 52 40             	mov    0x40(%edx),%edx
   1508b:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1508e:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   15091:	8b 55 08             	mov    0x8(%ebp),%edx
   15094:	8b 52 20             	mov    0x20(%edx),%edx
   15097:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1509a:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   1509d:	8b 55 08             	mov    0x8(%ebp),%edx
   150a0:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   150a6:	89 55 e8             	mov    %edx,-0x18(%ebp)
   150a9:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   150ac:	8b 55 08             	mov    0x8(%ebp),%edx
   150af:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   150b5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   150b8:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   150bb:	8b 55 08             	mov    0x8(%ebp),%edx
   150be:	8b 52 60             	mov    0x60(%edx),%edx
   150c1:	89 55 e0             	mov    %edx,-0x20(%ebp)
   150c4:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   150c7:	85 c0                	test   %eax,%eax
   150c9:	75 45                	jne    15110 <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   150cb:	8b 45 08             	mov    0x8(%ebp),%eax
   150ce:	8b 00                	mov    (%eax),%eax
   150d0:	83 c0 20             	add    $0x20,%eax
   150d3:	c1 f8 06             	sar    $0x6,%eax
   150d6:	83 e8 80             	sub    $0xffffff80,%eax
   150d9:	50                   	push   %eax
   150da:	e8 d6 ea ff ff       	call   13bb5 <_Clip>
   150df:	83 c4 04             	add    $0x4,%esp
   150e2:	0f b6 c0             	movzbl %al,%eax
   150e5:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   150e8:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   150ef:	eb 14                	jmp    15105 <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   150f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   150f4:	89 c2                	mov    %eax,%edx
   150f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   150f9:	88 10                	mov    %dl,(%eax)
            out += stride;
   150fb:	8b 45 10             	mov    0x10(%ebp),%eax
   150fe:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   15101:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   15105:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   15109:	75 e6                	jne    150f1 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   1510b:	e9 57 02 00 00       	jmp    15367 <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   15110:	8b 45 08             	mov    0x8(%ebp),%eax
   15113:	8b 00                	mov    (%eax),%eax
   15115:	c1 e0 08             	shl    $0x8,%eax
   15118:	05 00 20 00 00       	add    $0x2000,%eax
   1511d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   15120:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15123:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15126:	01 d0                	add    %edx,%eax
   15128:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   1512e:	83 c0 04             	add    $0x4,%eax
   15131:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   15134:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15137:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   1513d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15140:	01 d0                	add    %edx,%eax
   15142:	c1 f8 03             	sar    $0x3,%eax
   15145:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   15148:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1514b:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   15151:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15154:	01 d0                	add    %edx,%eax
   15156:	c1 f8 03             	sar    $0x3,%eax
   15159:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   1515c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1515f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15162:	01 d0                	add    %edx,%eax
   15164:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   1516a:	83 c0 04             	add    $0x4,%eax
   1516d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   15170:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15173:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   15179:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1517c:	01 d0                	add    %edx,%eax
   1517e:	c1 f8 03             	sar    $0x3,%eax
   15181:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   15184:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15187:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   1518d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15190:	01 d0                	add    %edx,%eax
   15192:	c1 f8 03             	sar    $0x3,%eax
   15195:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   15198:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1519b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1519e:	01 d0                	add    %edx,%eax
   151a0:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   151a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   151a6:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   151a9:	8b 55 f0             	mov    -0x10(%ebp),%edx
   151ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151af:	01 d0                	add    %edx,%eax
   151b1:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   151b7:	83 c0 04             	add    $0x4,%eax
   151ba:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   151bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151c0:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   151c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   151c9:	01 d0                	add    %edx,%eax
   151cb:	c1 f8 03             	sar    $0x3,%eax
   151ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   151d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151d4:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   151da:	8b 45 f8             	mov    -0x8(%ebp),%eax
   151dd:	01 d0                	add    %edx,%eax
   151df:	c1 f8 03             	sar    $0x3,%eax
   151e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   151e5:	8b 55 ec             	mov    -0x14(%ebp),%edx
   151e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   151eb:	01 d0                	add    %edx,%eax
   151ed:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   151f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   151f3:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   151f6:	8b 55 e8             	mov    -0x18(%ebp),%edx
   151f9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   151fc:	01 d0                	add    %edx,%eax
   151fe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   15201:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15204:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   15207:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1520a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1520d:	01 d0                	add    %edx,%eax
   1520f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   15212:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15215:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   15218:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1521b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1521e:	01 d0                	add    %edx,%eax
   15220:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   15223:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15226:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   15229:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1522c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1522f:	01 d0                	add    %edx,%eax
   15231:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15237:	83 e8 80             	sub    $0xffffff80,%eax
   1523a:	c1 f8 08             	sar    $0x8,%eax
   1523d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   15240:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15243:	2b 45 e8             	sub    -0x18(%ebp),%eax
   15246:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1524c:	83 e8 80             	sub    $0xffffff80,%eax
   1524f:	c1 f8 08             	sar    $0x8,%eax
   15252:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   15255:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15258:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1525b:	01 d0                	add    %edx,%eax
   1525d:	c1 f8 0e             	sar    $0xe,%eax
   15260:	83 e8 80             	sub    $0xffffff80,%eax
   15263:	50                   	push   %eax
   15264:	e8 4c e9 ff ff       	call   13bb5 <_Clip>
   15269:	83 c4 04             	add    $0x4,%esp
   1526c:	89 c2                	mov    %eax,%edx
   1526e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15271:	88 10                	mov    %dl,(%eax)
   15273:	8b 45 10             	mov    0x10(%ebp),%eax
   15276:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   15279:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1527c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1527f:	01 d0                	add    %edx,%eax
   15281:	c1 f8 0e             	sar    $0xe,%eax
   15284:	83 e8 80             	sub    $0xffffff80,%eax
   15287:	50                   	push   %eax
   15288:	e8 28 e9 ff ff       	call   13bb5 <_Clip>
   1528d:	83 c4 04             	add    $0x4,%esp
   15290:	89 c2                	mov    %eax,%edx
   15292:	8b 45 0c             	mov    0xc(%ebp),%eax
   15295:	88 10                	mov    %dl,(%eax)
   15297:	8b 45 10             	mov    0x10(%ebp),%eax
   1529a:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   1529d:	8b 55 fc             	mov    -0x4(%ebp),%edx
   152a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   152a3:	01 d0                	add    %edx,%eax
   152a5:	c1 f8 0e             	sar    $0xe,%eax
   152a8:	83 e8 80             	sub    $0xffffff80,%eax
   152ab:	50                   	push   %eax
   152ac:	e8 04 e9 ff ff       	call   13bb5 <_Clip>
   152b1:	83 c4 04             	add    $0x4,%esp
   152b4:	89 c2                	mov    %eax,%edx
   152b6:	8b 45 0c             	mov    0xc(%ebp),%eax
   152b9:	88 10                	mov    %dl,(%eax)
   152bb:	8b 45 10             	mov    0x10(%ebp),%eax
   152be:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   152c1:	8b 55 dc             	mov    -0x24(%ebp),%edx
   152c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   152c7:	01 d0                	add    %edx,%eax
   152c9:	c1 f8 0e             	sar    $0xe,%eax
   152cc:	83 e8 80             	sub    $0xffffff80,%eax
   152cf:	50                   	push   %eax
   152d0:	e8 e0 e8 ff ff       	call   13bb5 <_Clip>
   152d5:	83 c4 04             	add    $0x4,%esp
   152d8:	89 c2                	mov    %eax,%edx
   152da:	8b 45 0c             	mov    0xc(%ebp),%eax
   152dd:	88 10                	mov    %dl,(%eax)
   152df:	8b 45 10             	mov    0x10(%ebp),%eax
   152e2:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   152e5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   152e8:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   152eb:	c1 f8 0e             	sar    $0xe,%eax
   152ee:	83 e8 80             	sub    $0xffffff80,%eax
   152f1:	50                   	push   %eax
   152f2:	e8 be e8 ff ff       	call   13bb5 <_Clip>
   152f7:	83 c4 04             	add    $0x4,%esp
   152fa:	89 c2                	mov    %eax,%edx
   152fc:	8b 45 0c             	mov    0xc(%ebp),%eax
   152ff:	88 10                	mov    %dl,(%eax)
   15301:	8b 45 10             	mov    0x10(%ebp),%eax
   15304:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   15307:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1530a:	2b 45 ec             	sub    -0x14(%ebp),%eax
   1530d:	c1 f8 0e             	sar    $0xe,%eax
   15310:	83 e8 80             	sub    $0xffffff80,%eax
   15313:	50                   	push   %eax
   15314:	e8 9c e8 ff ff       	call   13bb5 <_Clip>
   15319:	83 c4 04             	add    $0x4,%esp
   1531c:	89 c2                	mov    %eax,%edx
   1531e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15321:	88 10                	mov    %dl,(%eax)
   15323:	8b 45 10             	mov    0x10(%ebp),%eax
   15326:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   15329:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1532c:	2b 45 f4             	sub    -0xc(%ebp),%eax
   1532f:	c1 f8 0e             	sar    $0xe,%eax
   15332:	83 e8 80             	sub    $0xffffff80,%eax
   15335:	50                   	push   %eax
   15336:	e8 7a e8 ff ff       	call   13bb5 <_Clip>
   1533b:	83 c4 04             	add    $0x4,%esp
   1533e:	89 c2                	mov    %eax,%edx
   15340:	8b 45 0c             	mov    0xc(%ebp),%eax
   15343:	88 10                	mov    %dl,(%eax)
   15345:	8b 45 10             	mov    0x10(%ebp),%eax
   15348:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   1534b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1534e:	2b 45 f8             	sub    -0x8(%ebp),%eax
   15351:	c1 f8 0e             	sar    $0xe,%eax
   15354:	83 e8 80             	sub    $0xffffff80,%eax
   15357:	50                   	push   %eax
   15358:	e8 58 e8 ff ff       	call   13bb5 <_Clip>
   1535d:	83 c4 04             	add    $0x4,%esp
   15360:	89 c2                	mov    %eax,%edx
   15362:	8b 45 0c             	mov    0xc(%ebp),%eax
   15365:	88 10                	mov    %dl,(%eax)
}
   15367:	c9                   	leave  
   15368:	c3                   	ret    

00015369 <_ByteAlign>:

void _ByteAlign(Context* ctx){
   15369:	55                   	push   %ebp
   1536a:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   1536c:	8b 45 08             	mov    0x8(%ebp),%eax
   1536f:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15375:	25 f8 00 00 00       	and    $0xf8,%eax
   1537a:	89 c2                	mov    %eax,%edx
   1537c:	8b 45 08             	mov    0x8(%ebp),%eax
   1537f:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   15385:	90                   	nop
   15386:	5d                   	pop    %ebp
   15387:	c3                   	ret    

00015388 <_SkipMarker>:

void _SkipMarker(Context* ctx){
   15388:	55                   	push   %ebp
   15389:	89 e5                	mov    %esp,%ebp
   1538b:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   1538e:	83 ec 0c             	sub    $0xc,%esp
   15391:	ff 75 08             	pushl  0x8(%ebp)
   15394:	e8 8d e8 ff ff       	call   13c26 <_DecodeLength>
   15399:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   1539c:	8b 45 08             	mov    0x8(%ebp),%eax
   1539f:	8b 40 0c             	mov    0xc(%eax),%eax
   153a2:	83 ec 08             	sub    $0x8,%esp
   153a5:	50                   	push   %eax
   153a6:	ff 75 08             	pushl  0x8(%ebp)
   153a9:	e8 2c e8 ff ff       	call   13bda <_Skip>
   153ae:	83 c4 10             	add    $0x10,%esp
}
   153b1:	90                   	nop
   153b2:	c9                   	leave  
   153b3:	c3                   	ret    

000153b4 <_Convert>:

void _Convert(Context* ctx){
   153b4:	55                   	push   %ebp
   153b5:	89 e5                	mov    %esp,%ebp
   153b7:	57                   	push   %edi
   153b8:	56                   	push   %esi
   153b9:	53                   	push   %ebx
   153ba:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   153bd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   153c4:	8b 45 08             	mov    0x8(%ebp),%eax
   153c7:	83 c0 2c             	add    $0x2c,%eax
   153ca:	89 45 e0             	mov    %eax,-0x20(%ebp)
   153cd:	e9 b2 00 00 00       	jmp    15484 <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   153d2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   153d5:	8b 50 0c             	mov    0xc(%eax),%edx
   153d8:	8b 45 08             	mov    0x8(%ebp),%eax
   153db:	8b 40 10             	mov    0x10(%eax),%eax
   153de:	39 c2                	cmp    %eax,%edx
   153e0:	7d 11                	jge    153f3 <_Convert+0x3f>
   153e2:	83 ec 08             	sub    $0x8,%esp
   153e5:	ff 75 e0             	pushl  -0x20(%ebp)
   153e8:	ff 75 08             	pushl  0x8(%ebp)
   153eb:	e8 79 02 00 00       	call   15669 <_UpsampleH>
   153f0:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   153f3:	8b 45 08             	mov    0x8(%ebp),%eax
   153f6:	8b 00                	mov    (%eax),%eax
   153f8:	85 c0                	test   %eax,%eax
   153fa:	0f 85 5d 02 00 00    	jne    1565d <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   15400:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15403:	8b 50 10             	mov    0x10(%eax),%edx
   15406:	8b 45 08             	mov    0x8(%ebp),%eax
   15409:	8b 40 14             	mov    0x14(%eax),%eax
   1540c:	39 c2                	cmp    %eax,%edx
   1540e:	7d 11                	jge    15421 <_Convert+0x6d>
   15410:	83 ec 08             	sub    $0x8,%esp
   15413:	ff 75 e0             	pushl  -0x20(%ebp)
   15416:	ff 75 08             	pushl  0x8(%ebp)
   15419:	e8 db 05 00 00       	call   159f9 <_UpsampleV>
   1541e:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15421:	8b 45 08             	mov    0x8(%ebp),%eax
   15424:	8b 00                	mov    (%eax),%eax
   15426:	85 c0                	test   %eax,%eax
   15428:	0f 85 32 02 00 00    	jne    15660 <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   1542e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15431:	8b 50 0c             	mov    0xc(%eax),%edx
   15434:	8b 45 08             	mov    0x8(%ebp),%eax
   15437:	8b 40 10             	mov    0x10(%eax),%eax
   1543a:	39 c2                	cmp    %eax,%edx
   1543c:	7c 94                	jl     153d2 <_Convert+0x1e>
   1543e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15441:	8b 50 10             	mov    0x10(%eax),%edx
   15444:	8b 45 08             	mov    0x8(%ebp),%eax
   15447:	8b 40 14             	mov    0x14(%eax),%eax
   1544a:	39 c2                	cmp    %eax,%edx
   1544c:	7c 84                	jl     153d2 <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   1544e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15451:	8b 50 0c             	mov    0xc(%eax),%edx
   15454:	8b 45 08             	mov    0x8(%ebp),%eax
   15457:	8b 40 10             	mov    0x10(%eax),%eax
   1545a:	39 c2                	cmp    %eax,%edx
   1545c:	7c 10                	jl     1546e <_Convert+0xba>
   1545e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15461:	8b 50 10             	mov    0x10(%eax),%edx
   15464:	8b 45 08             	mov    0x8(%ebp),%eax
   15467:	8b 40 14             	mov    0x14(%eax),%eax
   1546a:	39 c2                	cmp    %eax,%edx
   1546c:	7d 0e                	jge    1547c <_Convert+0xc8>
   1546e:	8b 45 08             	mov    0x8(%ebp),%eax
   15471:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   15477:	e9 e5 01 00 00       	jmp    15661 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1547c:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   15480:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   15484:	8b 45 08             	mov    0x8(%ebp),%eax
   15487:	8b 40 28             	mov    0x28(%eax),%eax
   1548a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1548d:	7f 9f                	jg     1542e <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   1548f:	8b 45 08             	mov    0x8(%ebp),%eax
   15492:	8b 40 28             	mov    0x28(%eax),%eax
   15495:	83 f8 03             	cmp    $0x3,%eax
   15498:	0f 85 3d 01 00 00    	jne    155db <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   1549e:	8b 45 08             	mov    0x8(%ebp),%eax
   154a1:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   154a7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   154aa:	8b 45 08             	mov    0x8(%ebp),%eax
   154ad:	8b 40 54             	mov    0x54(%eax),%eax
   154b0:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   154b3:	8b 45 08             	mov    0x8(%ebp),%eax
   154b6:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   154bc:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   154bf:	8b 45 08             	mov    0x8(%ebp),%eax
   154c2:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   154c8:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   154cb:	8b 45 08             	mov    0x8(%ebp),%eax
   154ce:	8b 40 14             	mov    0x14(%eax),%eax
   154d1:	89 45 d8             	mov    %eax,-0x28(%ebp)
   154d4:	e9 f3 00 00 00       	jmp    155cc <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   154d9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   154e0:	e9 b6 00 00 00       	jmp    1559b <_Convert+0x1e7>
                register int y = py[x] << 8;
   154e5:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154e8:	8b 45 d0             	mov    -0x30(%ebp),%eax
   154eb:	01 d0                	add    %edx,%eax
   154ed:	0f b6 00             	movzbl (%eax),%eax
   154f0:	0f b6 c0             	movzbl %al,%eax
   154f3:	c1 e0 08             	shl    $0x8,%eax
   154f6:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   154f8:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154fb:	8b 45 cc             	mov    -0x34(%ebp),%eax
   154fe:	01 d0                	add    %edx,%eax
   15500:	0f b6 00             	movzbl (%eax),%eax
   15503:	0f b6 c0             	movzbl %al,%eax
   15506:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   15509:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1550c:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1550f:	01 d0                	add    %edx,%eax
   15511:	0f b6 00             	movzbl (%eax),%eax
   15514:	0f b6 c0             	movzbl %al,%eax
   15517:	83 c0 80             	add    $0xffffff80,%eax
   1551a:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   1551c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1551f:	8d 46 01             	lea    0x1(%esi),%eax
   15522:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15525:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   15528:	89 c8                	mov    %ecx,%eax
   1552a:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   15530:	01 d8                	add    %ebx,%eax
   15532:	83 e8 80             	sub    $0xffffff80,%eax
   15535:	c1 f8 08             	sar    $0x8,%eax
   15538:	83 ec 0c             	sub    $0xc,%esp
   1553b:	50                   	push   %eax
   1553c:	e8 74 e6 ff ff       	call   13bb5 <_Clip>
   15541:	83 c4 10             	add    $0x10,%esp
   15544:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   15546:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15549:	8d 46 01             	lea    0x1(%esi),%eax
   1554c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1554f:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   15552:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   15555:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   1555c:	01 d0                	add    %edx,%eax
   1555e:	83 e8 80             	sub    $0xffffff80,%eax
   15561:	c1 f8 08             	sar    $0x8,%eax
   15564:	83 ec 0c             	sub    $0xc,%esp
   15567:	50                   	push   %eax
   15568:	e8 48 e6 ff ff       	call   13bb5 <_Clip>
   1556d:	83 c4 10             	add    $0x10,%esp
   15570:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   15572:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15575:	8d 46 01             	lea    0x1(%esi),%eax
   15578:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1557b:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   15581:	01 d8                	add    %ebx,%eax
   15583:	83 e8 80             	sub    $0xffffff80,%eax
   15586:	c1 f8 08             	sar    $0x8,%eax
   15589:	83 ec 0c             	sub    $0xc,%esp
   1558c:	50                   	push   %eax
   1558d:	e8 23 e6 ff ff       	call   13bb5 <_Clip>
   15592:	83 c4 10             	add    $0x10,%esp
   15595:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   15597:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   1559b:	8b 45 08             	mov    0x8(%ebp),%eax
   1559e:	8b 40 10             	mov    0x10(%eax),%eax
   155a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   155a4:	0f 8f 3b ff ff ff    	jg     154e5 <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   155aa:	8b 45 08             	mov    0x8(%ebp),%eax
   155ad:	8b 40 40             	mov    0x40(%eax),%eax
   155b0:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   155b3:	8b 45 08             	mov    0x8(%ebp),%eax
   155b6:	8b 40 6c             	mov    0x6c(%eax),%eax
   155b9:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   155bc:	8b 45 08             	mov    0x8(%ebp),%eax
   155bf:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   155c5:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   155c8:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   155cc:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   155d0:	0f 85 03 ff ff ff    	jne    154d9 <_Convert+0x125>
   155d6:	e9 86 00 00 00       	jmp    15661 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   155db:	8b 45 08             	mov    0x8(%ebp),%eax
   155de:	8b 50 38             	mov    0x38(%eax),%edx
   155e1:	8b 45 08             	mov    0x8(%ebp),%eax
   155e4:	8b 40 40             	mov    0x40(%eax),%eax
   155e7:	39 c2                	cmp    %eax,%edx
   155e9:	74 76                	je     15661 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   155eb:	8b 45 08             	mov    0x8(%ebp),%eax
   155ee:	8b 50 54             	mov    0x54(%eax),%edx
   155f1:	8b 45 08             	mov    0x8(%ebp),%eax
   155f4:	8b 40 40             	mov    0x40(%eax),%eax
   155f7:	01 d0                	add    %edx,%eax
   155f9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   155fc:	8b 45 08             	mov    0x8(%ebp),%eax
   155ff:	8b 50 54             	mov    0x54(%eax),%edx
   15602:	8b 45 08             	mov    0x8(%ebp),%eax
   15605:	8b 40 38             	mov    0x38(%eax),%eax
   15608:	01 d0                	add    %edx,%eax
   1560a:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   1560d:	8b 45 08             	mov    0x8(%ebp),%eax
   15610:	8b 40 3c             	mov    0x3c(%eax),%eax
   15613:	83 e8 01             	sub    $0x1,%eax
   15616:	89 45 bc             	mov    %eax,-0x44(%ebp)
   15619:	eb 2e                	jmp    15649 <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   1561b:	8b 45 08             	mov    0x8(%ebp),%eax
   1561e:	8b 40 38             	mov    0x38(%eax),%eax
   15621:	83 ec 04             	sub    $0x4,%esp
   15624:	50                   	push   %eax
   15625:	ff 75 c4             	pushl  -0x3c(%ebp)
   15628:	ff 75 c0             	pushl  -0x40(%ebp)
   1562b:	e8 72 ac fe ff       	call   2a2 <memmove>
   15630:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   15633:	8b 45 08             	mov    0x8(%ebp),%eax
   15636:	8b 40 40             	mov    0x40(%eax),%eax
   15639:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   1563c:	8b 45 08             	mov    0x8(%ebp),%eax
   1563f:	8b 40 38             	mov    0x38(%eax),%eax
   15642:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   15645:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   15649:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   1564d:	75 cc                	jne    1561b <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   1564f:	8b 45 08             	mov    0x8(%ebp),%eax
   15652:	8b 50 38             	mov    0x38(%eax),%edx
   15655:	8b 45 08             	mov    0x8(%ebp),%eax
   15658:	89 50 40             	mov    %edx,0x40(%eax)
   1565b:	eb 04                	jmp    15661 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   1565d:	90                   	nop
   1565e:	eb 01                	jmp    15661 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   15660:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   15661:	8d 65 f4             	lea    -0xc(%ebp),%esp
   15664:	5b                   	pop    %ebx
   15665:	5e                   	pop    %esi
   15666:	5f                   	pop    %edi
   15667:	5d                   	pop    %ebp
   15668:	c3                   	ret    

00015669 <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   15669:	55                   	push   %ebp
   1566a:	89 e5                	mov    %esp,%ebp
   1566c:	53                   	push   %ebx
   1566d:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   15670:	8b 45 0c             	mov    0xc(%ebp),%eax
   15673:	8b 40 0c             	mov    0xc(%eax),%eax
   15676:	83 e8 03             	sub    $0x3,%eax
   15679:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   1567c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1567f:	8b 50 0c             	mov    0xc(%eax),%edx
   15682:	8b 45 0c             	mov    0xc(%ebp),%eax
   15685:	8b 40 10             	mov    0x10(%eax),%eax
   15688:	0f af c2             	imul   %edx,%eax
   1568b:	01 c0                	add    %eax,%eax
   1568d:	83 ec 0c             	sub    $0xc,%esp
   15690:	50                   	push   %eax
   15691:	e8 cb b0 fe ff       	call   761 <malloc>
   15696:	83 c4 10             	add    $0x10,%esp
   15699:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   1569c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   156a0:	75 0e                	jne    156b0 <_UpsampleH+0x47>
   156a2:	8b 45 08             	mov    0x8(%ebp),%eax
   156a5:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   156ab:	e9 44 03 00 00       	jmp    159f4 <_UpsampleH+0x38b>
    lin = c->pixels;
   156b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   156b3:	8b 40 28             	mov    0x28(%eax),%eax
   156b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   156b9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   156bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   156bf:	8b 45 0c             	mov    0xc(%ebp),%eax
   156c2:	8b 40 10             	mov    0x10(%eax),%eax
   156c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   156c8:	e9 e0 02 00 00       	jmp    159ad <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   156cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156d0:	0f b6 00             	movzbl (%eax),%eax
   156d3:	0f b6 c0             	movzbl %al,%eax
   156d6:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   156dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156df:	83 c0 01             	add    $0x1,%eax
   156e2:	0f b6 00             	movzbl (%eax),%eax
   156e5:	0f b6 c0             	movzbl %al,%eax
   156e8:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   156eb:	01 d0                	add    %edx,%eax
   156ed:	83 ec 0c             	sub    $0xc,%esp
   156f0:	50                   	push   %eax
   156f1:	e8 c4 06 00 00       	call   15dba <CF>
   156f6:	83 c4 10             	add    $0x10,%esp
   156f9:	89 c2                	mov    %eax,%edx
   156fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   156fe:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   15700:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15703:	8d 58 01             	lea    0x1(%eax),%ebx
   15706:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15709:	0f b6 00             	movzbl (%eax),%eax
   1570c:	0f b6 c0             	movzbl %al,%eax
   1570f:	6b c8 68             	imul   $0x68,%eax,%ecx
   15712:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15715:	83 c0 01             	add    $0x1,%eax
   15718:	0f b6 00             	movzbl (%eax),%eax
   1571b:	0f b6 d0             	movzbl %al,%edx
   1571e:	89 d0                	mov    %edx,%eax
   15720:	01 c0                	add    %eax,%eax
   15722:	01 d0                	add    %edx,%eax
   15724:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1572b:	01 d0                	add    %edx,%eax
   1572d:	01 c1                	add    %eax,%ecx
   1572f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15732:	83 c0 02             	add    $0x2,%eax
   15735:	0f b6 00             	movzbl (%eax),%eax
   15738:	0f b6 d0             	movzbl %al,%edx
   1573b:	89 d0                	mov    %edx,%eax
   1573d:	01 c0                	add    %eax,%eax
   1573f:	01 d0                	add    %edx,%eax
   15741:	f7 d8                	neg    %eax
   15743:	01 c8                	add    %ecx,%eax
   15745:	83 ec 0c             	sub    $0xc,%esp
   15748:	50                   	push   %eax
   15749:	e8 6c 06 00 00       	call   15dba <CF>
   1574e:	83 c4 10             	add    $0x10,%esp
   15751:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   15753:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15756:	8d 58 02             	lea    0x2(%eax),%ebx
   15759:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1575c:	0f b6 00             	movzbl (%eax),%eax
   1575f:	0f b6 c0             	movzbl %al,%eax
   15762:	c1 e0 02             	shl    $0x2,%eax
   15765:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1576c:	29 c2                	sub    %eax,%edx
   1576e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15771:	83 c0 01             	add    $0x1,%eax
   15774:	0f b6 00             	movzbl (%eax),%eax
   15777:	0f b6 c0             	movzbl %al,%eax
   1577a:	6b c0 6d             	imul   $0x6d,%eax,%eax
   1577d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15780:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15783:	83 c0 02             	add    $0x2,%eax
   15786:	0f b6 00             	movzbl (%eax),%eax
   15789:	0f b6 d0             	movzbl %al,%edx
   1578c:	89 d0                	mov    %edx,%eax
   1578e:	c1 e0 03             	shl    $0x3,%eax
   15791:	01 d0                	add    %edx,%eax
   15793:	f7 d8                	neg    %eax
   15795:	01 c8                	add    %ecx,%eax
   15797:	83 ec 0c             	sub    $0xc,%esp
   1579a:	50                   	push   %eax
   1579b:	e8 1a 06 00 00       	call   15dba <CF>
   157a0:	83 c4 10             	add    $0x10,%esp
   157a3:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   157a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   157ac:	e9 fa 00 00 00       	jmp    158ab <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   157b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   157b4:	01 c0                	add    %eax,%eax
   157b6:	8d 50 03             	lea    0x3(%eax),%edx
   157b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   157bc:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   157bf:	8b 55 ec             	mov    -0x14(%ebp),%edx
   157c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157c5:	01 d0                	add    %edx,%eax
   157c7:	0f b6 00             	movzbl (%eax),%eax
   157ca:	0f b6 d0             	movzbl %al,%edx
   157cd:	89 d0                	mov    %edx,%eax
   157cf:	c1 e0 03             	shl    $0x3,%eax
   157d2:	01 d0                	add    %edx,%eax
   157d4:	f7 d8                	neg    %eax
   157d6:	8b 55 ec             	mov    -0x14(%ebp),%edx
   157d9:	8d 4a 01             	lea    0x1(%edx),%ecx
   157dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
   157df:	01 ca                	add    %ecx,%edx
   157e1:	0f b6 12             	movzbl (%edx),%edx
   157e4:	0f b6 d2             	movzbl %dl,%edx
   157e7:	6b d2 6f             	imul   $0x6f,%edx,%edx
   157ea:	01 c2                	add    %eax,%edx
   157ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
   157ef:	8d 48 02             	lea    0x2(%eax),%ecx
   157f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157f5:	01 c8                	add    %ecx,%eax
   157f7:	0f b6 00             	movzbl (%eax),%eax
   157fa:	0f b6 c0             	movzbl %al,%eax
   157fd:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15800:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15803:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15806:	8d 50 03             	lea    0x3(%eax),%edx
   15809:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1580c:	01 d0                	add    %edx,%eax
   1580e:	0f b6 00             	movzbl (%eax),%eax
   15811:	0f b6 d0             	movzbl %al,%edx
   15814:	89 d0                	mov    %edx,%eax
   15816:	01 c0                	add    %eax,%eax
   15818:	01 d0                	add    %edx,%eax
   1581a:	f7 d8                	neg    %eax
   1581c:	01 c8                	add    %ecx,%eax
   1581e:	83 ec 0c             	sub    $0xc,%esp
   15821:	50                   	push   %eax
   15822:	e8 93 05 00 00       	call   15dba <CF>
   15827:	83 c4 10             	add    $0x10,%esp
   1582a:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   1582c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1582f:	01 c0                	add    %eax,%eax
   15831:	8d 50 04             	lea    0x4(%eax),%edx
   15834:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15837:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1583a:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1583d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15840:	01 d0                	add    %edx,%eax
   15842:	0f b6 00             	movzbl (%eax),%eax
   15845:	0f b6 d0             	movzbl %al,%edx
   15848:	89 d0                	mov    %edx,%eax
   1584a:	01 c0                	add    %eax,%eax
   1584c:	01 d0                	add    %edx,%eax
   1584e:	f7 d8                	neg    %eax
   15850:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15853:	8d 4a 01             	lea    0x1(%edx),%ecx
   15856:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15859:	01 ca                	add    %ecx,%edx
   1585b:	0f b6 12             	movzbl (%edx),%edx
   1585e:	0f b6 d2             	movzbl %dl,%edx
   15861:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15864:	01 c2                	add    %eax,%edx
   15866:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15869:	8d 48 02             	lea    0x2(%eax),%ecx
   1586c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1586f:	01 c8                	add    %ecx,%eax
   15871:	0f b6 00             	movzbl (%eax),%eax
   15874:	0f b6 c0             	movzbl %al,%eax
   15877:	6b c0 6f             	imul   $0x6f,%eax,%eax
   1587a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1587d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15880:	8d 50 03             	lea    0x3(%eax),%edx
   15883:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15886:	01 d0                	add    %edx,%eax
   15888:	0f b6 00             	movzbl (%eax),%eax
   1588b:	0f b6 d0             	movzbl %al,%edx
   1588e:	89 d0                	mov    %edx,%eax
   15890:	c1 e0 03             	shl    $0x3,%eax
   15893:	01 d0                	add    %edx,%eax
   15895:	f7 d8                	neg    %eax
   15897:	01 c8                	add    %ecx,%eax
   15899:	83 ec 0c             	sub    $0xc,%esp
   1589c:	50                   	push   %eax
   1589d:	e8 18 05 00 00       	call   15dba <CF>
   158a2:	83 c4 10             	add    $0x10,%esp
   158a5:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   158a7:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   158ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
   158ae:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   158b1:	0f 8c fa fe ff ff    	jl     157b1 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   158b7:	8b 45 0c             	mov    0xc(%ebp),%eax
   158ba:	8b 40 14             	mov    0x14(%eax),%eax
   158bd:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   158c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   158c3:	8b 40 0c             	mov    0xc(%eax),%eax
   158c6:	01 c0                	add    %eax,%eax
   158c8:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   158cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158ce:	8d 58 fd             	lea    -0x3(%eax),%ebx
   158d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158d4:	83 e8 01             	sub    $0x1,%eax
   158d7:	0f b6 00             	movzbl (%eax),%eax
   158da:	0f b6 c0             	movzbl %al,%eax
   158dd:	c1 e0 02             	shl    $0x2,%eax
   158e0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   158e7:	29 c2                	sub    %eax,%edx
   158e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158ec:	83 e8 02             	sub    $0x2,%eax
   158ef:	0f b6 00             	movzbl (%eax),%eax
   158f2:	0f b6 c0             	movzbl %al,%eax
   158f5:	6b c0 6d             	imul   $0x6d,%eax,%eax
   158f8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   158fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158fe:	83 e8 03             	sub    $0x3,%eax
   15901:	0f b6 00             	movzbl (%eax),%eax
   15904:	0f b6 d0             	movzbl %al,%edx
   15907:	89 d0                	mov    %edx,%eax
   15909:	c1 e0 03             	shl    $0x3,%eax
   1590c:	01 d0                	add    %edx,%eax
   1590e:	f7 d8                	neg    %eax
   15910:	01 c8                	add    %ecx,%eax
   15912:	83 ec 0c             	sub    $0xc,%esp
   15915:	50                   	push   %eax
   15916:	e8 9f 04 00 00       	call   15dba <CF>
   1591b:	83 c4 10             	add    $0x10,%esp
   1591e:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   15920:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15923:	8d 58 fe             	lea    -0x2(%eax),%ebx
   15926:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15929:	83 e8 01             	sub    $0x1,%eax
   1592c:	0f b6 00             	movzbl (%eax),%eax
   1592f:	0f b6 c0             	movzbl %al,%eax
   15932:	6b c8 68             	imul   $0x68,%eax,%ecx
   15935:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15938:	83 e8 02             	sub    $0x2,%eax
   1593b:	0f b6 00             	movzbl (%eax),%eax
   1593e:	0f b6 d0             	movzbl %al,%edx
   15941:	89 d0                	mov    %edx,%eax
   15943:	01 c0                	add    %eax,%eax
   15945:	01 d0                	add    %edx,%eax
   15947:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1594e:	01 d0                	add    %edx,%eax
   15950:	01 c1                	add    %eax,%ecx
   15952:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15955:	83 e8 03             	sub    $0x3,%eax
   15958:	0f b6 00             	movzbl (%eax),%eax
   1595b:	0f b6 d0             	movzbl %al,%edx
   1595e:	89 d0                	mov    %edx,%eax
   15960:	01 c0                	add    %eax,%eax
   15962:	01 d0                	add    %edx,%eax
   15964:	f7 d8                	neg    %eax
   15966:	01 c8                	add    %ecx,%eax
   15968:	83 ec 0c             	sub    $0xc,%esp
   1596b:	50                   	push   %eax
   1596c:	e8 49 04 00 00       	call   15dba <CF>
   15971:	83 c4 10             	add    $0x10,%esp
   15974:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   15976:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15979:	8d 58 ff             	lea    -0x1(%eax),%ebx
   1597c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1597f:	83 e8 01             	sub    $0x1,%eax
   15982:	0f b6 00             	movzbl (%eax),%eax
   15985:	0f b6 c0             	movzbl %al,%eax
   15988:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   1598e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15991:	83 e8 02             	sub    $0x2,%eax
   15994:	0f b6 00             	movzbl (%eax),%eax
   15997:	0f b6 c0             	movzbl %al,%eax
   1599a:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   1599d:	01 d0                	add    %edx,%eax
   1599f:	83 ec 0c             	sub    $0xc,%esp
   159a2:	50                   	push   %eax
   159a3:	e8 12 04 00 00       	call   15dba <CF>
   159a8:	83 c4 10             	add    $0x10,%esp
   159ab:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   159ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
   159b0:	8d 50 ff             	lea    -0x1(%eax),%edx
   159b3:	89 55 e8             	mov    %edx,-0x18(%ebp)
   159b6:	85 c0                	test   %eax,%eax
   159b8:	0f 85 0f fd ff ff    	jne    156cd <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   159be:	8b 45 0c             	mov    0xc(%ebp),%eax
   159c1:	8b 40 0c             	mov    0xc(%eax),%eax
   159c4:	8d 14 00             	lea    (%eax,%eax,1),%edx
   159c7:	8b 45 0c             	mov    0xc(%ebp),%eax
   159ca:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   159cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   159d0:	8b 50 0c             	mov    0xc(%eax),%edx
   159d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   159d6:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   159d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   159dc:	8b 40 28             	mov    0x28(%eax),%eax
   159df:	83 ec 0c             	sub    $0xc,%esp
   159e2:	50                   	push   %eax
   159e3:	e8 37 ac fe ff       	call   61f <free>
   159e8:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   159eb:	8b 45 0c             	mov    0xc(%ebp),%eax
   159ee:	8b 55 e0             	mov    -0x20(%ebp),%edx
   159f1:	89 50 28             	mov    %edx,0x28(%eax)
}
   159f4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   159f7:	c9                   	leave  
   159f8:	c3                   	ret    

000159f9 <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   159f9:	55                   	push   %ebp
   159fa:	89 e5                	mov    %esp,%ebp
   159fc:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   159ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a02:	8b 40 0c             	mov    0xc(%eax),%eax
   15a05:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   15a08:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a0b:	8b 40 14             	mov    0x14(%eax),%eax
   15a0e:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15a11:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15a14:	01 c0                	add    %eax,%eax
   15a16:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15a19:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a1c:	8b 50 0c             	mov    0xc(%eax),%edx
   15a1f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a22:	8b 40 10             	mov    0x10(%eax),%eax
   15a25:	0f af c2             	imul   %edx,%eax
   15a28:	01 c0                	add    %eax,%eax
   15a2a:	83 ec 0c             	sub    $0xc,%esp
   15a2d:	50                   	push   %eax
   15a2e:	e8 2e ad fe ff       	call   761 <malloc>
   15a33:	83 c4 10             	add    $0x10,%esp
   15a36:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15a39:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15a3d:	75 0e                	jne    15a4d <_UpsampleV+0x54>
   15a3f:	8b 45 08             	mov    0x8(%ebp),%eax
   15a42:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15a48:	e9 6b 03 00 00       	jmp    15db8 <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   15a4d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15a54:	e9 1d 03 00 00       	jmp    15d76 <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   15a59:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a5c:	8b 50 28             	mov    0x28(%eax),%edx
   15a5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15a62:	01 d0                	add    %edx,%eax
   15a64:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   15a67:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15a6a:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15a6d:	01 d0                	add    %edx,%eax
   15a6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   15a72:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a75:	0f b6 00             	movzbl (%eax),%eax
   15a78:	0f b6 c0             	movzbl %al,%eax
   15a7b:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15a81:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15a84:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a87:	01 c8                	add    %ecx,%eax
   15a89:	0f b6 00             	movzbl (%eax),%eax
   15a8c:	0f b6 c0             	movzbl %al,%eax
   15a8f:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15a92:	01 d0                	add    %edx,%eax
   15a94:	83 ec 0c             	sub    $0xc,%esp
   15a97:	50                   	push   %eax
   15a98:	e8 1d 03 00 00       	call   15dba <CF>
   15a9d:	83 c4 10             	add    $0x10,%esp
   15aa0:	89 c2                	mov    %eax,%edx
   15aa2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15aa5:	88 10                	mov    %dl,(%eax)
   15aa7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15aaa:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   15aad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ab0:	0f b6 00             	movzbl (%eax),%eax
   15ab3:	0f b6 c0             	movzbl %al,%eax
   15ab6:	6b c8 68             	imul   $0x68,%eax,%ecx
   15ab9:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15abc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15abf:	01 d0                	add    %edx,%eax
   15ac1:	0f b6 00             	movzbl (%eax),%eax
   15ac4:	0f b6 d0             	movzbl %al,%edx
   15ac7:	89 d0                	mov    %edx,%eax
   15ac9:	01 c0                	add    %eax,%eax
   15acb:	01 d0                	add    %edx,%eax
   15acd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15ad4:	01 d0                	add    %edx,%eax
   15ad6:	01 c1                	add    %eax,%ecx
   15ad8:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15adb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ade:	01 d0                	add    %edx,%eax
   15ae0:	0f b6 00             	movzbl (%eax),%eax
   15ae3:	0f b6 d0             	movzbl %al,%edx
   15ae6:	89 d0                	mov    %edx,%eax
   15ae8:	01 c0                	add    %eax,%eax
   15aea:	01 d0                	add    %edx,%eax
   15aec:	f7 d8                	neg    %eax
   15aee:	01 c8                	add    %ecx,%eax
   15af0:	83 ec 0c             	sub    $0xc,%esp
   15af3:	50                   	push   %eax
   15af4:	e8 c1 02 00 00       	call   15dba <CF>
   15af9:	83 c4 10             	add    $0x10,%esp
   15afc:	89 c2                	mov    %eax,%edx
   15afe:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b01:	88 10                	mov    %dl,(%eax)
   15b03:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b06:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   15b09:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b0c:	0f b6 00             	movzbl (%eax),%eax
   15b0f:	0f b6 c0             	movzbl %al,%eax
   15b12:	c1 e0 02             	shl    $0x2,%eax
   15b15:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15b1c:	89 d1                	mov    %edx,%ecx
   15b1e:	29 c1                	sub    %eax,%ecx
   15b20:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15b23:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b26:	01 d0                	add    %edx,%eax
   15b28:	0f b6 00             	movzbl (%eax),%eax
   15b2b:	0f b6 c0             	movzbl %al,%eax
   15b2e:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15b31:	01 c1                	add    %eax,%ecx
   15b33:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15b36:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b39:	01 d0                	add    %edx,%eax
   15b3b:	0f b6 00             	movzbl (%eax),%eax
   15b3e:	0f b6 d0             	movzbl %al,%edx
   15b41:	89 d0                	mov    %edx,%eax
   15b43:	c1 e0 03             	shl    $0x3,%eax
   15b46:	01 d0                	add    %edx,%eax
   15b48:	f7 d8                	neg    %eax
   15b4a:	01 c8                	add    %ecx,%eax
   15b4c:	83 ec 0c             	sub    $0xc,%esp
   15b4f:	50                   	push   %eax
   15b50:	e8 65 02 00 00       	call   15dba <CF>
   15b55:	83 c4 10             	add    $0x10,%esp
   15b58:	89 c2                	mov    %eax,%edx
   15b5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b5d:	88 10                	mov    %dl,(%eax)
   15b5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b62:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   15b65:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b68:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   15b6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b6e:	8b 40 10             	mov    0x10(%eax),%eax
   15b71:	83 e8 03             	sub    $0x3,%eax
   15b74:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15b77:	e9 e6 00 00 00       	jmp    15c62 <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   15b7c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b7f:	f7 d8                	neg    %eax
   15b81:	89 c2                	mov    %eax,%edx
   15b83:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b86:	01 d0                	add    %edx,%eax
   15b88:	0f b6 00             	movzbl (%eax),%eax
   15b8b:	0f b6 d0             	movzbl %al,%edx
   15b8e:	89 d0                	mov    %edx,%eax
   15b90:	c1 e0 03             	shl    $0x3,%eax
   15b93:	01 d0                	add    %edx,%eax
   15b95:	f7 d8                	neg    %eax
   15b97:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15b9a:	0f b6 12             	movzbl (%edx),%edx
   15b9d:	0f b6 d2             	movzbl %dl,%edx
   15ba0:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15ba3:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15ba6:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15ba9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bac:	01 d0                	add    %edx,%eax
   15bae:	0f b6 00             	movzbl (%eax),%eax
   15bb1:	0f b6 c0             	movzbl %al,%eax
   15bb4:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15bb7:	01 c1                	add    %eax,%ecx
   15bb9:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15bbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bbf:	01 d0                	add    %edx,%eax
   15bc1:	0f b6 00             	movzbl (%eax),%eax
   15bc4:	0f b6 d0             	movzbl %al,%edx
   15bc7:	89 d0                	mov    %edx,%eax
   15bc9:	01 c0                	add    %eax,%eax
   15bcb:	01 d0                	add    %edx,%eax
   15bcd:	f7 d8                	neg    %eax
   15bcf:	01 c8                	add    %ecx,%eax
   15bd1:	83 ec 0c             	sub    $0xc,%esp
   15bd4:	50                   	push   %eax
   15bd5:	e8 e0 01 00 00       	call   15dba <CF>
   15bda:	83 c4 10             	add    $0x10,%esp
   15bdd:	89 c2                	mov    %eax,%edx
   15bdf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15be2:	88 10                	mov    %dl,(%eax)
   15be4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15be7:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   15bea:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15bed:	f7 d8                	neg    %eax
   15bef:	89 c2                	mov    %eax,%edx
   15bf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bf4:	01 d0                	add    %edx,%eax
   15bf6:	0f b6 00             	movzbl (%eax),%eax
   15bf9:	0f b6 d0             	movzbl %al,%edx
   15bfc:	89 d0                	mov    %edx,%eax
   15bfe:	01 c0                	add    %eax,%eax
   15c00:	01 d0                	add    %edx,%eax
   15c02:	f7 d8                	neg    %eax
   15c04:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15c07:	0f b6 12             	movzbl (%edx),%edx
   15c0a:	0f b6 d2             	movzbl %dl,%edx
   15c0d:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15c10:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15c13:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15c16:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c19:	01 d0                	add    %edx,%eax
   15c1b:	0f b6 00             	movzbl (%eax),%eax
   15c1e:	0f b6 c0             	movzbl %al,%eax
   15c21:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15c24:	01 c1                	add    %eax,%ecx
   15c26:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15c29:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c2c:	01 d0                	add    %edx,%eax
   15c2e:	0f b6 00             	movzbl (%eax),%eax
   15c31:	0f b6 d0             	movzbl %al,%edx
   15c34:	89 d0                	mov    %edx,%eax
   15c36:	c1 e0 03             	shl    $0x3,%eax
   15c39:	01 d0                	add    %edx,%eax
   15c3b:	f7 d8                	neg    %eax
   15c3d:	01 c8                	add    %ecx,%eax
   15c3f:	83 ec 0c             	sub    $0xc,%esp
   15c42:	50                   	push   %eax
   15c43:	e8 72 01 00 00       	call   15dba <CF>
   15c48:	83 c4 10             	add    $0x10,%esp
   15c4b:	89 c2                	mov    %eax,%edx
   15c4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c50:	88 10                	mov    %dl,(%eax)
   15c52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15c55:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   15c58:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c5b:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   15c5e:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   15c62:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15c66:	0f 85 10 ff ff ff    	jne    15b7c <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   15c6c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c6f:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   15c72:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c75:	0f b6 00             	movzbl (%eax),%eax
   15c78:	0f b6 c0             	movzbl %al,%eax
   15c7b:	c1 e0 02             	shl    $0x2,%eax
   15c7e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15c85:	29 c2                	sub    %eax,%edx
   15c87:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c8a:	f7 d8                	neg    %eax
   15c8c:	89 c1                	mov    %eax,%ecx
   15c8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c91:	01 c8                	add    %ecx,%eax
   15c93:	0f b6 00             	movzbl (%eax),%eax
   15c96:	0f b6 c0             	movzbl %al,%eax
   15c99:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15c9c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15c9f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15ca2:	f7 d8                	neg    %eax
   15ca4:	89 c2                	mov    %eax,%edx
   15ca6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ca9:	01 d0                	add    %edx,%eax
   15cab:	0f b6 00             	movzbl (%eax),%eax
   15cae:	0f b6 d0             	movzbl %al,%edx
   15cb1:	89 d0                	mov    %edx,%eax
   15cb3:	c1 e0 03             	shl    $0x3,%eax
   15cb6:	01 d0                	add    %edx,%eax
   15cb8:	f7 d8                	neg    %eax
   15cba:	01 c8                	add    %ecx,%eax
   15cbc:	83 ec 0c             	sub    $0xc,%esp
   15cbf:	50                   	push   %eax
   15cc0:	e8 f5 00 00 00       	call   15dba <CF>
   15cc5:	83 c4 10             	add    $0x10,%esp
   15cc8:	89 c2                	mov    %eax,%edx
   15cca:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15ccd:	88 10                	mov    %dl,(%eax)
   15ccf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15cd2:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   15cd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cd8:	0f b6 00             	movzbl (%eax),%eax
   15cdb:	0f b6 c0             	movzbl %al,%eax
   15cde:	6b c8 68             	imul   $0x68,%eax,%ecx
   15ce1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15ce4:	f7 d8                	neg    %eax
   15ce6:	89 c2                	mov    %eax,%edx
   15ce8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ceb:	01 d0                	add    %edx,%eax
   15ced:	0f b6 00             	movzbl (%eax),%eax
   15cf0:	0f b6 d0             	movzbl %al,%edx
   15cf3:	89 d0                	mov    %edx,%eax
   15cf5:	01 c0                	add    %eax,%eax
   15cf7:	01 d0                	add    %edx,%eax
   15cf9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15d00:	01 d0                	add    %edx,%eax
   15d02:	01 c1                	add    %eax,%ecx
   15d04:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15d07:	f7 d8                	neg    %eax
   15d09:	89 c2                	mov    %eax,%edx
   15d0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d0e:	01 d0                	add    %edx,%eax
   15d10:	0f b6 00             	movzbl (%eax),%eax
   15d13:	0f b6 d0             	movzbl %al,%edx
   15d16:	89 d0                	mov    %edx,%eax
   15d18:	01 c0                	add    %eax,%eax
   15d1a:	01 d0                	add    %edx,%eax
   15d1c:	f7 d8                	neg    %eax
   15d1e:	01 c8                	add    %ecx,%eax
   15d20:	83 ec 0c             	sub    $0xc,%esp
   15d23:	50                   	push   %eax
   15d24:	e8 91 00 00 00       	call   15dba <CF>
   15d29:	83 c4 10             	add    $0x10,%esp
   15d2c:	89 c2                	mov    %eax,%edx
   15d2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d31:	88 10                	mov    %dl,(%eax)
   15d33:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d36:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   15d39:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d3c:	0f b6 00             	movzbl (%eax),%eax
   15d3f:	0f b6 c0             	movzbl %al,%eax
   15d42:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15d48:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d4b:	f7 d8                	neg    %eax
   15d4d:	89 c1                	mov    %eax,%ecx
   15d4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d52:	01 c8                	add    %ecx,%eax
   15d54:	0f b6 00             	movzbl (%eax),%eax
   15d57:	0f b6 c0             	movzbl %al,%eax
   15d5a:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15d5d:	01 d0                	add    %edx,%eax
   15d5f:	83 ec 0c             	sub    $0xc,%esp
   15d62:	50                   	push   %eax
   15d63:	e8 52 00 00 00       	call   15dba <CF>
   15d68:	83 c4 10             	add    $0x10,%esp
   15d6b:	89 c2                	mov    %eax,%edx
   15d6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d70:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   15d72:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15d76:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d79:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15d7c:	0f 8c d7 fc ff ff    	jl     15a59 <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   15d82:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d85:	8b 40 10             	mov    0x10(%eax),%eax
   15d88:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15d8b:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d8e:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   15d91:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d94:	8b 50 0c             	mov    0xc(%eax),%edx
   15d97:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d9a:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15d9d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15da0:	8b 40 28             	mov    0x28(%eax),%eax
   15da3:	83 ec 0c             	sub    $0xc,%esp
   15da6:	50                   	push   %eax
   15da7:	e8 73 a8 fe ff       	call   61f <free>
   15dac:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15daf:	8b 45 0c             	mov    0xc(%ebp),%eax
   15db2:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15db5:	89 50 28             	mov    %edx,0x28(%eax)
}
   15db8:	c9                   	leave  
   15db9:	c3                   	ret    

00015dba <CF>:

uchar CF(const int x){
   15dba:	55                   	push   %ebp
   15dbb:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   15dbd:	8b 45 08             	mov    0x8(%ebp),%eax
   15dc0:	83 c0 40             	add    $0x40,%eax
   15dc3:	c1 f8 07             	sar    $0x7,%eax
   15dc6:	50                   	push   %eax
   15dc7:	e8 e9 dd ff ff       	call   13bb5 <_Clip>
   15dcc:	83 c4 04             	add    $0x4,%esp
}
   15dcf:	c9                   	leave  
   15dd0:	c3                   	ret    
