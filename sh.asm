
_sh：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <runcmd>:
struct cmd *parsecmd(char*);

// Execute cmd.  Never returns.
void
runcmd(struct cmd *cmd)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	83 ec 28             	sub    $0x28,%esp
  struct execcmd *ecmd;
  struct listcmd *lcmd;
  struct pipecmd *pcmd;
  struct redircmd *rcmd;

  if(cmd == 0)
       6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
       a:	75 05                	jne    11 <runcmd+0x11>
    exit();
       c:	e8 40 0e 00 00       	call   e51 <exit>
  
  switch(cmd->type){
      11:	8b 45 08             	mov    0x8(%ebp),%eax
      14:	8b 00                	mov    (%eax),%eax
      16:	83 f8 05             	cmp    $0x5,%eax
      19:	77 09                	ja     24 <runcmd+0x24>
      1b:	8b 04 85 6c 69 01 00 	mov    0x1696c(,%eax,4),%eax
      22:	ff e0                	jmp    *%eax
  default:
    panic("runcmd");
      24:	83 ec 0c             	sub    $0xc,%esp
      27:	68 40 69 01 00       	push   $0x16940
      2c:	e8 e7 02 00 00       	call   318 <panic>
      31:	83 c4 10             	add    $0x10,%esp

  case EXEC:
    ecmd = (struct execcmd*)cmd;
      34:	8b 45 08             	mov    0x8(%ebp),%eax
      37:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(ecmd->argv[0] == 0)
      3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
      3d:	8b 40 04             	mov    0x4(%eax),%eax
      40:	85 c0                	test   %eax,%eax
      42:	75 05                	jne    49 <runcmd+0x49>
      exit();
      44:	e8 08 0e 00 00       	call   e51 <exit>
    exec(ecmd->argv[0], ecmd->argv);
      49:	8b 45 f4             	mov    -0xc(%ebp),%eax
      4c:	8d 50 04             	lea    0x4(%eax),%edx
      4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
      52:	8b 40 04             	mov    0x4(%eax),%eax
      55:	83 ec 08             	sub    $0x8,%esp
      58:	52                   	push   %edx
      59:	50                   	push   %eax
      5a:	e8 2a 0e 00 00       	call   e89 <exec>
      5f:	83 c4 10             	add    $0x10,%esp
    printf(2, "exec %s failed\n", ecmd->argv[0]);
      62:	8b 45 f4             	mov    -0xc(%ebp),%eax
      65:	8b 40 04             	mov    0x4(%eax),%eax
      68:	83 ec 04             	sub    $0x4,%esp
      6b:	50                   	push   %eax
      6c:	68 47 69 01 00       	push   $0x16947
      71:	6a 02                	push   $0x2
      73:	e8 80 0f 00 00       	call   ff8 <printf>
      78:	83 c4 10             	add    $0x10,%esp
    break;
      7b:	e9 c6 01 00 00       	jmp    246 <runcmd+0x246>

  case REDIR:
    rcmd = (struct redircmd*)cmd;
      80:	8b 45 08             	mov    0x8(%ebp),%eax
      83:	89 45 f0             	mov    %eax,-0x10(%ebp)
    close(rcmd->fd);
      86:	8b 45 f0             	mov    -0x10(%ebp),%eax
      89:	8b 40 14             	mov    0x14(%eax),%eax
      8c:	83 ec 0c             	sub    $0xc,%esp
      8f:	50                   	push   %eax
      90:	e8 e4 0d 00 00       	call   e79 <close>
      95:	83 c4 10             	add    $0x10,%esp
    if(open(rcmd->file, rcmd->mode) < 0){
      98:	8b 45 f0             	mov    -0x10(%ebp),%eax
      9b:	8b 50 10             	mov    0x10(%eax),%edx
      9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
      a1:	8b 40 08             	mov    0x8(%eax),%eax
      a4:	83 ec 08             	sub    $0x8,%esp
      a7:	52                   	push   %edx
      a8:	50                   	push   %eax
      a9:	e8 e3 0d 00 00       	call   e91 <open>
      ae:	83 c4 10             	add    $0x10,%esp
      b1:	85 c0                	test   %eax,%eax
      b3:	79 1e                	jns    d3 <runcmd+0xd3>
      printf(2, "open %s failed\n", rcmd->file);
      b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
      b8:	8b 40 08             	mov    0x8(%eax),%eax
      bb:	83 ec 04             	sub    $0x4,%esp
      be:	50                   	push   %eax
      bf:	68 57 69 01 00       	push   $0x16957
      c4:	6a 02                	push   $0x2
      c6:	e8 2d 0f 00 00       	call   ff8 <printf>
      cb:	83 c4 10             	add    $0x10,%esp
      exit();
      ce:	e8 7e 0d 00 00       	call   e51 <exit>
    }
    runcmd(rcmd->cmd);
      d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
      d6:	8b 40 04             	mov    0x4(%eax),%eax
      d9:	83 ec 0c             	sub    $0xc,%esp
      dc:	50                   	push   %eax
      dd:	e8 1e ff ff ff       	call   0 <runcmd>
      e2:	83 c4 10             	add    $0x10,%esp
    break;
      e5:	e9 5c 01 00 00       	jmp    246 <runcmd+0x246>

  case LIST:
    lcmd = (struct listcmd*)cmd;
      ea:	8b 45 08             	mov    0x8(%ebp),%eax
      ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(fork1() == 0)
      f0:	e8 43 02 00 00       	call   338 <fork1>
      f5:	85 c0                	test   %eax,%eax
      f7:	75 12                	jne    10b <runcmd+0x10b>
      runcmd(lcmd->left);
      f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
      fc:	8b 40 04             	mov    0x4(%eax),%eax
      ff:	83 ec 0c             	sub    $0xc,%esp
     102:	50                   	push   %eax
     103:	e8 f8 fe ff ff       	call   0 <runcmd>
     108:	83 c4 10             	add    $0x10,%esp
    wait();
     10b:	e8 49 0d 00 00       	call   e59 <wait>
    runcmd(lcmd->right);
     110:	8b 45 ec             	mov    -0x14(%ebp),%eax
     113:	8b 40 08             	mov    0x8(%eax),%eax
     116:	83 ec 0c             	sub    $0xc,%esp
     119:	50                   	push   %eax
     11a:	e8 e1 fe ff ff       	call   0 <runcmd>
     11f:	83 c4 10             	add    $0x10,%esp
    break;
     122:	e9 1f 01 00 00       	jmp    246 <runcmd+0x246>

  case PIPE:
    pcmd = (struct pipecmd*)cmd;
     127:	8b 45 08             	mov    0x8(%ebp),%eax
     12a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(pipe(p) < 0)
     12d:	83 ec 0c             	sub    $0xc,%esp
     130:	8d 45 dc             	lea    -0x24(%ebp),%eax
     133:	50                   	push   %eax
     134:	e8 28 0d 00 00       	call   e61 <pipe>
     139:	83 c4 10             	add    $0x10,%esp
     13c:	85 c0                	test   %eax,%eax
     13e:	79 10                	jns    150 <runcmd+0x150>
      panic("pipe");
     140:	83 ec 0c             	sub    $0xc,%esp
     143:	68 67 69 01 00       	push   $0x16967
     148:	e8 cb 01 00 00       	call   318 <panic>
     14d:	83 c4 10             	add    $0x10,%esp
    if(fork1() == 0){
     150:	e8 e3 01 00 00       	call   338 <fork1>
     155:	85 c0                	test   %eax,%eax
     157:	75 4c                	jne    1a5 <runcmd+0x1a5>
      close(1);
     159:	83 ec 0c             	sub    $0xc,%esp
     15c:	6a 01                	push   $0x1
     15e:	e8 16 0d 00 00       	call   e79 <close>
     163:	83 c4 10             	add    $0x10,%esp
      dup(p[1]);
     166:	8b 45 e0             	mov    -0x20(%ebp),%eax
     169:	83 ec 0c             	sub    $0xc,%esp
     16c:	50                   	push   %eax
     16d:	e8 57 0d 00 00       	call   ec9 <dup>
     172:	83 c4 10             	add    $0x10,%esp
      close(p[0]);
     175:	8b 45 dc             	mov    -0x24(%ebp),%eax
     178:	83 ec 0c             	sub    $0xc,%esp
     17b:	50                   	push   %eax
     17c:	e8 f8 0c 00 00       	call   e79 <close>
     181:	83 c4 10             	add    $0x10,%esp
      close(p[1]);
     184:	8b 45 e0             	mov    -0x20(%ebp),%eax
     187:	83 ec 0c             	sub    $0xc,%esp
     18a:	50                   	push   %eax
     18b:	e8 e9 0c 00 00       	call   e79 <close>
     190:	83 c4 10             	add    $0x10,%esp
      runcmd(pcmd->left);
     193:	8b 45 e8             	mov    -0x18(%ebp),%eax
     196:	8b 40 04             	mov    0x4(%eax),%eax
     199:	83 ec 0c             	sub    $0xc,%esp
     19c:	50                   	push   %eax
     19d:	e8 5e fe ff ff       	call   0 <runcmd>
     1a2:	83 c4 10             	add    $0x10,%esp
    }
    if(fork1() == 0){
     1a5:	e8 8e 01 00 00       	call   338 <fork1>
     1aa:	85 c0                	test   %eax,%eax
     1ac:	75 4c                	jne    1fa <runcmd+0x1fa>
      close(0);
     1ae:	83 ec 0c             	sub    $0xc,%esp
     1b1:	6a 00                	push   $0x0
     1b3:	e8 c1 0c 00 00       	call   e79 <close>
     1b8:	83 c4 10             	add    $0x10,%esp
      dup(p[0]);
     1bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
     1be:	83 ec 0c             	sub    $0xc,%esp
     1c1:	50                   	push   %eax
     1c2:	e8 02 0d 00 00       	call   ec9 <dup>
     1c7:	83 c4 10             	add    $0x10,%esp
      close(p[0]);
     1ca:	8b 45 dc             	mov    -0x24(%ebp),%eax
     1cd:	83 ec 0c             	sub    $0xc,%esp
     1d0:	50                   	push   %eax
     1d1:	e8 a3 0c 00 00       	call   e79 <close>
     1d6:	83 c4 10             	add    $0x10,%esp
      close(p[1]);
     1d9:	8b 45 e0             	mov    -0x20(%ebp),%eax
     1dc:	83 ec 0c             	sub    $0xc,%esp
     1df:	50                   	push   %eax
     1e0:	e8 94 0c 00 00       	call   e79 <close>
     1e5:	83 c4 10             	add    $0x10,%esp
      runcmd(pcmd->right);
     1e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
     1eb:	8b 40 08             	mov    0x8(%eax),%eax
     1ee:	83 ec 0c             	sub    $0xc,%esp
     1f1:	50                   	push   %eax
     1f2:	e8 09 fe ff ff       	call   0 <runcmd>
     1f7:	83 c4 10             	add    $0x10,%esp
    }
    close(p[0]);
     1fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
     1fd:	83 ec 0c             	sub    $0xc,%esp
     200:	50                   	push   %eax
     201:	e8 73 0c 00 00       	call   e79 <close>
     206:	83 c4 10             	add    $0x10,%esp
    close(p[1]);
     209:	8b 45 e0             	mov    -0x20(%ebp),%eax
     20c:	83 ec 0c             	sub    $0xc,%esp
     20f:	50                   	push   %eax
     210:	e8 64 0c 00 00       	call   e79 <close>
     215:	83 c4 10             	add    $0x10,%esp
    wait();
     218:	e8 3c 0c 00 00       	call   e59 <wait>
    wait();
     21d:	e8 37 0c 00 00       	call   e59 <wait>
    break;
     222:	eb 22                	jmp    246 <runcmd+0x246>
    
  case BACK:
    bcmd = (struct backcmd*)cmd;
     224:	8b 45 08             	mov    0x8(%ebp),%eax
     227:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(fork1() == 0)
     22a:	e8 09 01 00 00       	call   338 <fork1>
     22f:	85 c0                	test   %eax,%eax
     231:	75 12                	jne    245 <runcmd+0x245>
      runcmd(bcmd->cmd);
     233:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     236:	8b 40 04             	mov    0x4(%eax),%eax
     239:	83 ec 0c             	sub    $0xc,%esp
     23c:	50                   	push   %eax
     23d:	e8 be fd ff ff       	call   0 <runcmd>
     242:	83 c4 10             	add    $0x10,%esp
    break;
     245:	90                   	nop
  }
  exit();
     246:	e8 06 0c 00 00       	call   e51 <exit>

0000024b <getcmd>:
}

int
getcmd(char *buf, int nbuf)
{
     24b:	55                   	push   %ebp
     24c:	89 e5                	mov    %esp,%ebp
     24e:	83 ec 08             	sub    $0x8,%esp
  printf(2, "$ ");
     251:	83 ec 08             	sub    $0x8,%esp
     254:	68 84 69 01 00       	push   $0x16984
     259:	6a 02                	push   $0x2
     25b:	e8 98 0d 00 00       	call   ff8 <printf>
     260:	83 c4 10             	add    $0x10,%esp
  memset(buf, 0, nbuf);
     263:	8b 45 0c             	mov    0xc(%ebp),%eax
     266:	83 ec 04             	sub    $0x4,%esp
     269:	50                   	push   %eax
     26a:	6a 00                	push   $0x0
     26c:	ff 75 08             	pushl  0x8(%ebp)
     26f:	e8 42 0a 00 00       	call   cb6 <memset>
     274:	83 c4 10             	add    $0x10,%esp
  gets(buf, nbuf);
     277:	83 ec 08             	sub    $0x8,%esp
     27a:	ff 75 0c             	pushl  0xc(%ebp)
     27d:	ff 75 08             	pushl  0x8(%ebp)
     280:	e8 7e 0a 00 00       	call   d03 <gets>
     285:	83 c4 10             	add    $0x10,%esp
  if(buf[0] == 0) // EOF
     288:	8b 45 08             	mov    0x8(%ebp),%eax
     28b:	0f b6 00             	movzbl (%eax),%eax
     28e:	84 c0                	test   %al,%al
     290:	75 07                	jne    299 <getcmd+0x4e>
    return -1;
     292:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     297:	eb 05                	jmp    29e <getcmd+0x53>
  return 0;
     299:	b8 00 00 00 00       	mov    $0x0,%eax
}
     29e:	c9                   	leave  
     29f:	c3                   	ret    

000002a0 <main>:

int
main(void)
{
     2a0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
     2a4:	83 e4 f0             	and    $0xfffffff0,%esp
     2a7:	ff 71 fc             	pushl  -0x4(%ecx)
     2aa:	55                   	push   %ebp
     2ab:	89 e5                	mov    %esp,%ebp
     2ad:	51                   	push   %ecx
     2ae:	83 ec 14             	sub    $0x14,%esp
  int fd;

  int h, w;

  // Assumes three file descriptors open.
  while((fd = open("console", O_RDWR)) >= 0){
     2b1:	eb 16                	jmp    2c9 <main+0x29>
    if(fd >= 3){
     2b3:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
     2b7:	7e 10                	jle    2c9 <main+0x29>
      close(fd);
     2b9:	83 ec 0c             	sub    $0xc,%esp
     2bc:	ff 75 f4             	pushl  -0xc(%ebp)
     2bf:	e8 b5 0b 00 00       	call   e79 <close>
     2c4:	83 c4 10             	add    $0x10,%esp
      break;
     2c7:	eb 1b                	jmp    2e4 <main+0x44>
  int fd;

  int h, w;

  // Assumes three file descriptors open.
  while((fd = open("console", O_RDWR)) >= 0){
     2c9:	83 ec 08             	sub    $0x8,%esp
     2cc:	6a 02                	push   $0x2
     2ce:	68 87 69 01 00       	push   $0x16987
     2d3:	e8 b9 0b 00 00       	call   e91 <open>
     2d8:	83 c4 10             	add    $0x10,%esp
     2db:	89 45 f4             	mov    %eax,-0xc(%ebp)
     2de:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     2e2:	79 cf                	jns    2b3 <main+0x13>
      close(fd);
      break;
    }
  }
  
  int res = read24BitmapFile("desktop.bmp", image, &h, &w);
     2e4:	8d 45 e8             	lea    -0x18(%ebp),%eax
     2e7:	50                   	push   %eax
     2e8:	8d 45 ec             	lea    -0x14(%ebp),%eax
     2eb:	50                   	push   %eax
     2ec:	68 20 f4 01 00       	push   $0x1f420
     2f1:	68 8f 69 01 00       	push   $0x1698f
     2f6:	e8 df 16 00 00       	call   19da <read24BitmapFile>
     2fb:	83 c4 10             	add    $0x10,%esp
     2fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
  printf(1, "res: %d\n", res);
     301:	83 ec 04             	sub    $0x4,%esp
     304:	ff 75 f0             	pushl  -0x10(%ebp)
     307:	68 9b 69 01 00       	push   $0x1699b
     30c:	6a 01                	push   $0x1
     30e:	e8 e5 0c 00 00       	call   ff8 <printf>
     313:	83 c4 10             	add    $0x10,%esp


  while(1) ;
     316:	eb fe                	jmp    316 <main+0x76>

00000318 <panic>:
  exit();
}

void
panic(char *s)
{
     318:	55                   	push   %ebp
     319:	89 e5                	mov    %esp,%ebp
     31b:	83 ec 08             	sub    $0x8,%esp
  printf(2, "%s\n", s);
     31e:	83 ec 04             	sub    $0x4,%esp
     321:	ff 75 08             	pushl  0x8(%ebp)
     324:	68 a4 69 01 00       	push   $0x169a4
     329:	6a 02                	push   $0x2
     32b:	e8 c8 0c 00 00       	call   ff8 <printf>
     330:	83 c4 10             	add    $0x10,%esp
  exit();
     333:	e8 19 0b 00 00       	call   e51 <exit>

00000338 <fork1>:
}

int
fork1(void)
{
     338:	55                   	push   %ebp
     339:	89 e5                	mov    %esp,%ebp
     33b:	83 ec 18             	sub    $0x18,%esp
  int pid;
  
  pid = fork();
     33e:	e8 06 0b 00 00       	call   e49 <fork>
     343:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(pid == -1)
     346:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     34a:	75 10                	jne    35c <fork1+0x24>
    panic("fork");
     34c:	83 ec 0c             	sub    $0xc,%esp
     34f:	68 a8 69 01 00       	push   $0x169a8
     354:	e8 bf ff ff ff       	call   318 <panic>
     359:	83 c4 10             	add    $0x10,%esp
  return pid;
     35c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
     35f:	c9                   	leave  
     360:	c3                   	ret    

00000361 <execcmd>:
//PAGEBREAK!
// Constructors

struct cmd*
execcmd(void)
{
     361:	55                   	push   %ebp
     362:	89 e5                	mov    %esp,%ebp
     364:	83 ec 18             	sub    $0x18,%esp
  struct execcmd *cmd;

  cmd = malloc(sizeof(*cmd));
     367:	83 ec 0c             	sub    $0xc,%esp
     36a:	6a 54                	push   $0x54
     36c:	e8 5a 0f 00 00       	call   12cb <malloc>
     371:	83 c4 10             	add    $0x10,%esp
     374:	89 45 f4             	mov    %eax,-0xc(%ebp)
  memset(cmd, 0, sizeof(*cmd));
     377:	83 ec 04             	sub    $0x4,%esp
     37a:	6a 54                	push   $0x54
     37c:	6a 00                	push   $0x0
     37e:	ff 75 f4             	pushl  -0xc(%ebp)
     381:	e8 30 09 00 00       	call   cb6 <memset>
     386:	83 c4 10             	add    $0x10,%esp
  cmd->type = EXEC;
     389:	8b 45 f4             	mov    -0xc(%ebp),%eax
     38c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  return (struct cmd*)cmd;
     392:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
     395:	c9                   	leave  
     396:	c3                   	ret    

00000397 <redircmd>:

struct cmd*
redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
{
     397:	55                   	push   %ebp
     398:	89 e5                	mov    %esp,%ebp
     39a:	83 ec 18             	sub    $0x18,%esp
  struct redircmd *cmd;

  cmd = malloc(sizeof(*cmd));
     39d:	83 ec 0c             	sub    $0xc,%esp
     3a0:	6a 18                	push   $0x18
     3a2:	e8 24 0f 00 00       	call   12cb <malloc>
     3a7:	83 c4 10             	add    $0x10,%esp
     3aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  memset(cmd, 0, sizeof(*cmd));
     3ad:	83 ec 04             	sub    $0x4,%esp
     3b0:	6a 18                	push   $0x18
     3b2:	6a 00                	push   $0x0
     3b4:	ff 75 f4             	pushl  -0xc(%ebp)
     3b7:	e8 fa 08 00 00       	call   cb6 <memset>
     3bc:	83 c4 10             	add    $0x10,%esp
  cmd->type = REDIR;
     3bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
     3c2:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  cmd->cmd = subcmd;
     3c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
     3cb:	8b 55 08             	mov    0x8(%ebp),%edx
     3ce:	89 50 04             	mov    %edx,0x4(%eax)
  cmd->file = file;
     3d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
     3d4:	8b 55 0c             	mov    0xc(%ebp),%edx
     3d7:	89 50 08             	mov    %edx,0x8(%eax)
  cmd->efile = efile;
     3da:	8b 45 f4             	mov    -0xc(%ebp),%eax
     3dd:	8b 55 10             	mov    0x10(%ebp),%edx
     3e0:	89 50 0c             	mov    %edx,0xc(%eax)
  cmd->mode = mode;
     3e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
     3e6:	8b 55 14             	mov    0x14(%ebp),%edx
     3e9:	89 50 10             	mov    %edx,0x10(%eax)
  cmd->fd = fd;
     3ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
     3ef:	8b 55 18             	mov    0x18(%ebp),%edx
     3f2:	89 50 14             	mov    %edx,0x14(%eax)
  return (struct cmd*)cmd;
     3f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
     3f8:	c9                   	leave  
     3f9:	c3                   	ret    

000003fa <pipecmd>:

struct cmd*
pipecmd(struct cmd *left, struct cmd *right)
{
     3fa:	55                   	push   %ebp
     3fb:	89 e5                	mov    %esp,%ebp
     3fd:	83 ec 18             	sub    $0x18,%esp
  struct pipecmd *cmd;

  cmd = malloc(sizeof(*cmd));
     400:	83 ec 0c             	sub    $0xc,%esp
     403:	6a 0c                	push   $0xc
     405:	e8 c1 0e 00 00       	call   12cb <malloc>
     40a:	83 c4 10             	add    $0x10,%esp
     40d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  memset(cmd, 0, sizeof(*cmd));
     410:	83 ec 04             	sub    $0x4,%esp
     413:	6a 0c                	push   $0xc
     415:	6a 00                	push   $0x0
     417:	ff 75 f4             	pushl  -0xc(%ebp)
     41a:	e8 97 08 00 00       	call   cb6 <memset>
     41f:	83 c4 10             	add    $0x10,%esp
  cmd->type = PIPE;
     422:	8b 45 f4             	mov    -0xc(%ebp),%eax
     425:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
  cmd->left = left;
     42b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     42e:	8b 55 08             	mov    0x8(%ebp),%edx
     431:	89 50 04             	mov    %edx,0x4(%eax)
  cmd->right = right;
     434:	8b 45 f4             	mov    -0xc(%ebp),%eax
     437:	8b 55 0c             	mov    0xc(%ebp),%edx
     43a:	89 50 08             	mov    %edx,0x8(%eax)
  return (struct cmd*)cmd;
     43d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
     440:	c9                   	leave  
     441:	c3                   	ret    

00000442 <listcmd>:

struct cmd*
listcmd(struct cmd *left, struct cmd *right)
{
     442:	55                   	push   %ebp
     443:	89 e5                	mov    %esp,%ebp
     445:	83 ec 18             	sub    $0x18,%esp
  struct listcmd *cmd;

  cmd = malloc(sizeof(*cmd));
     448:	83 ec 0c             	sub    $0xc,%esp
     44b:	6a 0c                	push   $0xc
     44d:	e8 79 0e 00 00       	call   12cb <malloc>
     452:	83 c4 10             	add    $0x10,%esp
     455:	89 45 f4             	mov    %eax,-0xc(%ebp)
  memset(cmd, 0, sizeof(*cmd));
     458:	83 ec 04             	sub    $0x4,%esp
     45b:	6a 0c                	push   $0xc
     45d:	6a 00                	push   $0x0
     45f:	ff 75 f4             	pushl  -0xc(%ebp)
     462:	e8 4f 08 00 00       	call   cb6 <memset>
     467:	83 c4 10             	add    $0x10,%esp
  cmd->type = LIST;
     46a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     46d:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
  cmd->left = left;
     473:	8b 45 f4             	mov    -0xc(%ebp),%eax
     476:	8b 55 08             	mov    0x8(%ebp),%edx
     479:	89 50 04             	mov    %edx,0x4(%eax)
  cmd->right = right;
     47c:	8b 45 f4             	mov    -0xc(%ebp),%eax
     47f:	8b 55 0c             	mov    0xc(%ebp),%edx
     482:	89 50 08             	mov    %edx,0x8(%eax)
  return (struct cmd*)cmd;
     485:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
     488:	c9                   	leave  
     489:	c3                   	ret    

0000048a <backcmd>:

struct cmd*
backcmd(struct cmd *subcmd)
{
     48a:	55                   	push   %ebp
     48b:	89 e5                	mov    %esp,%ebp
     48d:	83 ec 18             	sub    $0x18,%esp
  struct backcmd *cmd;

  cmd = malloc(sizeof(*cmd));
     490:	83 ec 0c             	sub    $0xc,%esp
     493:	6a 08                	push   $0x8
     495:	e8 31 0e 00 00       	call   12cb <malloc>
     49a:	83 c4 10             	add    $0x10,%esp
     49d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  memset(cmd, 0, sizeof(*cmd));
     4a0:	83 ec 04             	sub    $0x4,%esp
     4a3:	6a 08                	push   $0x8
     4a5:	6a 00                	push   $0x0
     4a7:	ff 75 f4             	pushl  -0xc(%ebp)
     4aa:	e8 07 08 00 00       	call   cb6 <memset>
     4af:	83 c4 10             	add    $0x10,%esp
  cmd->type = BACK;
     4b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
     4b5:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
  cmd->cmd = subcmd;
     4bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
     4be:	8b 55 08             	mov    0x8(%ebp),%edx
     4c1:	89 50 04             	mov    %edx,0x4(%eax)
  return (struct cmd*)cmd;
     4c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
     4c7:	c9                   	leave  
     4c8:	c3                   	ret    

000004c9 <gettoken>:
char whitespace[] = " \t\r\n\v";
char symbols[] = "<|>&;()";

int
gettoken(char **ps, char *es, char **q, char **eq)
{
     4c9:	55                   	push   %ebp
     4ca:	89 e5                	mov    %esp,%ebp
     4cc:	83 ec 18             	sub    $0x18,%esp
  char *s;
  int ret;
  
  s = *ps;
     4cf:	8b 45 08             	mov    0x8(%ebp),%eax
     4d2:	8b 00                	mov    (%eax),%eax
     4d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while(s < es && strchr(whitespace, *s))
     4d7:	eb 04                	jmp    4dd <gettoken+0x14>
    s++;
     4d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
{
  char *s;
  int ret;
  
  s = *ps;
  while(s < es && strchr(whitespace, *s))
     4dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
     4e0:	3b 45 0c             	cmp    0xc(%ebp),%eax
     4e3:	73 1e                	jae    503 <gettoken+0x3a>
     4e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
     4e8:	0f b6 00             	movzbl (%eax),%eax
     4eb:	0f be c0             	movsbl %al,%eax
     4ee:	83 ec 08             	sub    $0x8,%esp
     4f1:	50                   	push   %eax
     4f2:	68 40 ef 01 00       	push   $0x1ef40
     4f7:	e8 d4 07 00 00       	call   cd0 <strchr>
     4fc:	83 c4 10             	add    $0x10,%esp
     4ff:	85 c0                	test   %eax,%eax
     501:	75 d6                	jne    4d9 <gettoken+0x10>
    s++;
  if(q)
     503:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
     507:	74 08                	je     511 <gettoken+0x48>
    *q = s;
     509:	8b 45 10             	mov    0x10(%ebp),%eax
     50c:	8b 55 f4             	mov    -0xc(%ebp),%edx
     50f:	89 10                	mov    %edx,(%eax)
  ret = *s;
     511:	8b 45 f4             	mov    -0xc(%ebp),%eax
     514:	0f b6 00             	movzbl (%eax),%eax
     517:	0f be c0             	movsbl %al,%eax
     51a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  switch(*s){
     51d:	8b 45 f4             	mov    -0xc(%ebp),%eax
     520:	0f b6 00             	movzbl (%eax),%eax
     523:	0f be c0             	movsbl %al,%eax
     526:	83 f8 29             	cmp    $0x29,%eax
     529:	7f 14                	jg     53f <gettoken+0x76>
     52b:	83 f8 28             	cmp    $0x28,%eax
     52e:	7d 28                	jge    558 <gettoken+0x8f>
     530:	85 c0                	test   %eax,%eax
     532:	0f 84 94 00 00 00    	je     5cc <gettoken+0x103>
     538:	83 f8 26             	cmp    $0x26,%eax
     53b:	74 1b                	je     558 <gettoken+0x8f>
     53d:	eb 3a                	jmp    579 <gettoken+0xb0>
     53f:	83 f8 3e             	cmp    $0x3e,%eax
     542:	74 1a                	je     55e <gettoken+0x95>
     544:	83 f8 3e             	cmp    $0x3e,%eax
     547:	7f 0a                	jg     553 <gettoken+0x8a>
     549:	83 e8 3b             	sub    $0x3b,%eax
     54c:	83 f8 01             	cmp    $0x1,%eax
     54f:	77 28                	ja     579 <gettoken+0xb0>
     551:	eb 05                	jmp    558 <gettoken+0x8f>
     553:	83 f8 7c             	cmp    $0x7c,%eax
     556:	75 21                	jne    579 <gettoken+0xb0>
  case '(':
  case ')':
  case ';':
  case '&':
  case '<':
    s++;
     558:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    break;
     55c:	eb 75                	jmp    5d3 <gettoken+0x10a>
  case '>':
    s++;
     55e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    if(*s == '>'){
     562:	8b 45 f4             	mov    -0xc(%ebp),%eax
     565:	0f b6 00             	movzbl (%eax),%eax
     568:	3c 3e                	cmp    $0x3e,%al
     56a:	75 63                	jne    5cf <gettoken+0x106>
      ret = '+';
     56c:	c7 45 f0 2b 00 00 00 	movl   $0x2b,-0x10(%ebp)
      s++;
     573:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    }
    break;
     577:	eb 56                	jmp    5cf <gettoken+0x106>
  default:
    ret = 'a';
     579:	c7 45 f0 61 00 00 00 	movl   $0x61,-0x10(%ebp)
    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
     580:	eb 04                	jmp    586 <gettoken+0xbd>
      s++;
     582:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      s++;
    }
    break;
  default:
    ret = 'a';
    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
     586:	8b 45 f4             	mov    -0xc(%ebp),%eax
     589:	3b 45 0c             	cmp    0xc(%ebp),%eax
     58c:	73 44                	jae    5d2 <gettoken+0x109>
     58e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     591:	0f b6 00             	movzbl (%eax),%eax
     594:	0f be c0             	movsbl %al,%eax
     597:	83 ec 08             	sub    $0x8,%esp
     59a:	50                   	push   %eax
     59b:	68 40 ef 01 00       	push   $0x1ef40
     5a0:	e8 2b 07 00 00       	call   cd0 <strchr>
     5a5:	83 c4 10             	add    $0x10,%esp
     5a8:	85 c0                	test   %eax,%eax
     5aa:	75 26                	jne    5d2 <gettoken+0x109>
     5ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
     5af:	0f b6 00             	movzbl (%eax),%eax
     5b2:	0f be c0             	movsbl %al,%eax
     5b5:	83 ec 08             	sub    $0x8,%esp
     5b8:	50                   	push   %eax
     5b9:	68 48 ef 01 00       	push   $0x1ef48
     5be:	e8 0d 07 00 00       	call   cd0 <strchr>
     5c3:	83 c4 10             	add    $0x10,%esp
     5c6:	85 c0                	test   %eax,%eax
     5c8:	74 b8                	je     582 <gettoken+0xb9>
      s++;
    break;
     5ca:	eb 06                	jmp    5d2 <gettoken+0x109>
  if(q)
    *q = s;
  ret = *s;
  switch(*s){
  case 0:
    break;
     5cc:	90                   	nop
     5cd:	eb 04                	jmp    5d3 <gettoken+0x10a>
    s++;
    if(*s == '>'){
      ret = '+';
      s++;
    }
    break;
     5cf:	90                   	nop
     5d0:	eb 01                	jmp    5d3 <gettoken+0x10a>
  default:
    ret = 'a';
    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
      s++;
    break;
     5d2:	90                   	nop
  }
  if(eq)
     5d3:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     5d7:	74 0e                	je     5e7 <gettoken+0x11e>
    *eq = s;
     5d9:	8b 45 14             	mov    0x14(%ebp),%eax
     5dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
     5df:	89 10                	mov    %edx,(%eax)
  
  while(s < es && strchr(whitespace, *s))
     5e1:	eb 04                	jmp    5e7 <gettoken+0x11e>
    s++;
     5e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    break;
  }
  if(eq)
    *eq = s;
  
  while(s < es && strchr(whitespace, *s))
     5e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
     5ea:	3b 45 0c             	cmp    0xc(%ebp),%eax
     5ed:	73 1e                	jae    60d <gettoken+0x144>
     5ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
     5f2:	0f b6 00             	movzbl (%eax),%eax
     5f5:	0f be c0             	movsbl %al,%eax
     5f8:	83 ec 08             	sub    $0x8,%esp
     5fb:	50                   	push   %eax
     5fc:	68 40 ef 01 00       	push   $0x1ef40
     601:	e8 ca 06 00 00       	call   cd0 <strchr>
     606:	83 c4 10             	add    $0x10,%esp
     609:	85 c0                	test   %eax,%eax
     60b:	75 d6                	jne    5e3 <gettoken+0x11a>
    s++;
  *ps = s;
     60d:	8b 45 08             	mov    0x8(%ebp),%eax
     610:	8b 55 f4             	mov    -0xc(%ebp),%edx
     613:	89 10                	mov    %edx,(%eax)
  return ret;
     615:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     618:	c9                   	leave  
     619:	c3                   	ret    

0000061a <peek>:

int
peek(char **ps, char *es, char *toks)
{
     61a:	55                   	push   %ebp
     61b:	89 e5                	mov    %esp,%ebp
     61d:	83 ec 18             	sub    $0x18,%esp
  char *s;
  
  s = *ps;
     620:	8b 45 08             	mov    0x8(%ebp),%eax
     623:	8b 00                	mov    (%eax),%eax
     625:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while(s < es && strchr(whitespace, *s))
     628:	eb 04                	jmp    62e <peek+0x14>
    s++;
     62a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
peek(char **ps, char *es, char *toks)
{
  char *s;
  
  s = *ps;
  while(s < es && strchr(whitespace, *s))
     62e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     631:	3b 45 0c             	cmp    0xc(%ebp),%eax
     634:	73 1e                	jae    654 <peek+0x3a>
     636:	8b 45 f4             	mov    -0xc(%ebp),%eax
     639:	0f b6 00             	movzbl (%eax),%eax
     63c:	0f be c0             	movsbl %al,%eax
     63f:	83 ec 08             	sub    $0x8,%esp
     642:	50                   	push   %eax
     643:	68 40 ef 01 00       	push   $0x1ef40
     648:	e8 83 06 00 00       	call   cd0 <strchr>
     64d:	83 c4 10             	add    $0x10,%esp
     650:	85 c0                	test   %eax,%eax
     652:	75 d6                	jne    62a <peek+0x10>
    s++;
  *ps = s;
     654:	8b 45 08             	mov    0x8(%ebp),%eax
     657:	8b 55 f4             	mov    -0xc(%ebp),%edx
     65a:	89 10                	mov    %edx,(%eax)
  return *s && strchr(toks, *s);
     65c:	8b 45 f4             	mov    -0xc(%ebp),%eax
     65f:	0f b6 00             	movzbl (%eax),%eax
     662:	84 c0                	test   %al,%al
     664:	74 23                	je     689 <peek+0x6f>
     666:	8b 45 f4             	mov    -0xc(%ebp),%eax
     669:	0f b6 00             	movzbl (%eax),%eax
     66c:	0f be c0             	movsbl %al,%eax
     66f:	83 ec 08             	sub    $0x8,%esp
     672:	50                   	push   %eax
     673:	ff 75 10             	pushl  0x10(%ebp)
     676:	e8 55 06 00 00       	call   cd0 <strchr>
     67b:	83 c4 10             	add    $0x10,%esp
     67e:	85 c0                	test   %eax,%eax
     680:	74 07                	je     689 <peek+0x6f>
     682:	b8 01 00 00 00       	mov    $0x1,%eax
     687:	eb 05                	jmp    68e <peek+0x74>
     689:	b8 00 00 00 00       	mov    $0x0,%eax
}
     68e:	c9                   	leave  
     68f:	c3                   	ret    

00000690 <parsecmd>:
struct cmd *parseexec(char**, char*);
struct cmd *nulterminate(struct cmd*);

struct cmd*
parsecmd(char *s)
{
     690:	55                   	push   %ebp
     691:	89 e5                	mov    %esp,%ebp
     693:	53                   	push   %ebx
     694:	83 ec 14             	sub    $0x14,%esp
  char *es;
  struct cmd *cmd;

  es = s + strlen(s);
     697:	8b 5d 08             	mov    0x8(%ebp),%ebx
     69a:	8b 45 08             	mov    0x8(%ebp),%eax
     69d:	83 ec 0c             	sub    $0xc,%esp
     6a0:	50                   	push   %eax
     6a1:	e8 e9 05 00 00       	call   c8f <strlen>
     6a6:	83 c4 10             	add    $0x10,%esp
     6a9:	01 d8                	add    %ebx,%eax
     6ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
  cmd = parseline(&s, es);
     6ae:	83 ec 08             	sub    $0x8,%esp
     6b1:	ff 75 f4             	pushl  -0xc(%ebp)
     6b4:	8d 45 08             	lea    0x8(%ebp),%eax
     6b7:	50                   	push   %eax
     6b8:	e8 61 00 00 00       	call   71e <parseline>
     6bd:	83 c4 10             	add    $0x10,%esp
     6c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  peek(&s, es, "");
     6c3:	83 ec 04             	sub    $0x4,%esp
     6c6:	68 ad 69 01 00       	push   $0x169ad
     6cb:	ff 75 f4             	pushl  -0xc(%ebp)
     6ce:	8d 45 08             	lea    0x8(%ebp),%eax
     6d1:	50                   	push   %eax
     6d2:	e8 43 ff ff ff       	call   61a <peek>
     6d7:	83 c4 10             	add    $0x10,%esp
  if(s != es){
     6da:	8b 45 08             	mov    0x8(%ebp),%eax
     6dd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
     6e0:	74 26                	je     708 <parsecmd+0x78>
    printf(2, "leftovers: %s\n", s);
     6e2:	8b 45 08             	mov    0x8(%ebp),%eax
     6e5:	83 ec 04             	sub    $0x4,%esp
     6e8:	50                   	push   %eax
     6e9:	68 ae 69 01 00       	push   $0x169ae
     6ee:	6a 02                	push   $0x2
     6f0:	e8 03 09 00 00       	call   ff8 <printf>
     6f5:	83 c4 10             	add    $0x10,%esp
    panic("syntax");
     6f8:	83 ec 0c             	sub    $0xc,%esp
     6fb:	68 bd 69 01 00       	push   $0x169bd
     700:	e8 13 fc ff ff       	call   318 <panic>
     705:	83 c4 10             	add    $0x10,%esp
  }
  nulterminate(cmd);
     708:	83 ec 0c             	sub    $0xc,%esp
     70b:	ff 75 f0             	pushl  -0x10(%ebp)
     70e:	e8 eb 03 00 00       	call   afe <nulterminate>
     713:	83 c4 10             	add    $0x10,%esp
  return cmd;
     716:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     719:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     71c:	c9                   	leave  
     71d:	c3                   	ret    

0000071e <parseline>:

struct cmd*
parseline(char **ps, char *es)
{
     71e:	55                   	push   %ebp
     71f:	89 e5                	mov    %esp,%ebp
     721:	83 ec 18             	sub    $0x18,%esp
  struct cmd *cmd;

  cmd = parsepipe(ps, es);
     724:	83 ec 08             	sub    $0x8,%esp
     727:	ff 75 0c             	pushl  0xc(%ebp)
     72a:	ff 75 08             	pushl  0x8(%ebp)
     72d:	e8 99 00 00 00       	call   7cb <parsepipe>
     732:	83 c4 10             	add    $0x10,%esp
     735:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while(peek(ps, es, "&")){
     738:	eb 23                	jmp    75d <parseline+0x3f>
    gettoken(ps, es, 0, 0);
     73a:	6a 00                	push   $0x0
     73c:	6a 00                	push   $0x0
     73e:	ff 75 0c             	pushl  0xc(%ebp)
     741:	ff 75 08             	pushl  0x8(%ebp)
     744:	e8 80 fd ff ff       	call   4c9 <gettoken>
     749:	83 c4 10             	add    $0x10,%esp
    cmd = backcmd(cmd);
     74c:	83 ec 0c             	sub    $0xc,%esp
     74f:	ff 75 f4             	pushl  -0xc(%ebp)
     752:	e8 33 fd ff ff       	call   48a <backcmd>
     757:	83 c4 10             	add    $0x10,%esp
     75a:	89 45 f4             	mov    %eax,-0xc(%ebp)
parseline(char **ps, char *es)
{
  struct cmd *cmd;

  cmd = parsepipe(ps, es);
  while(peek(ps, es, "&")){
     75d:	83 ec 04             	sub    $0x4,%esp
     760:	68 c4 69 01 00       	push   $0x169c4
     765:	ff 75 0c             	pushl  0xc(%ebp)
     768:	ff 75 08             	pushl  0x8(%ebp)
     76b:	e8 aa fe ff ff       	call   61a <peek>
     770:	83 c4 10             	add    $0x10,%esp
     773:	85 c0                	test   %eax,%eax
     775:	75 c3                	jne    73a <parseline+0x1c>
    gettoken(ps, es, 0, 0);
    cmd = backcmd(cmd);
  }
  if(peek(ps, es, ";")){
     777:	83 ec 04             	sub    $0x4,%esp
     77a:	68 c6 69 01 00       	push   $0x169c6
     77f:	ff 75 0c             	pushl  0xc(%ebp)
     782:	ff 75 08             	pushl  0x8(%ebp)
     785:	e8 90 fe ff ff       	call   61a <peek>
     78a:	83 c4 10             	add    $0x10,%esp
     78d:	85 c0                	test   %eax,%eax
     78f:	74 35                	je     7c6 <parseline+0xa8>
    gettoken(ps, es, 0, 0);
     791:	6a 00                	push   $0x0
     793:	6a 00                	push   $0x0
     795:	ff 75 0c             	pushl  0xc(%ebp)
     798:	ff 75 08             	pushl  0x8(%ebp)
     79b:	e8 29 fd ff ff       	call   4c9 <gettoken>
     7a0:	83 c4 10             	add    $0x10,%esp
    cmd = listcmd(cmd, parseline(ps, es));
     7a3:	83 ec 08             	sub    $0x8,%esp
     7a6:	ff 75 0c             	pushl  0xc(%ebp)
     7a9:	ff 75 08             	pushl  0x8(%ebp)
     7ac:	e8 6d ff ff ff       	call   71e <parseline>
     7b1:	83 c4 10             	add    $0x10,%esp
     7b4:	83 ec 08             	sub    $0x8,%esp
     7b7:	50                   	push   %eax
     7b8:	ff 75 f4             	pushl  -0xc(%ebp)
     7bb:	e8 82 fc ff ff       	call   442 <listcmd>
     7c0:	83 c4 10             	add    $0x10,%esp
     7c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  return cmd;
     7c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
     7c9:	c9                   	leave  
     7ca:	c3                   	ret    

000007cb <parsepipe>:

struct cmd*
parsepipe(char **ps, char *es)
{
     7cb:	55                   	push   %ebp
     7cc:	89 e5                	mov    %esp,%ebp
     7ce:	83 ec 18             	sub    $0x18,%esp
  struct cmd *cmd;

  cmd = parseexec(ps, es);
     7d1:	83 ec 08             	sub    $0x8,%esp
     7d4:	ff 75 0c             	pushl  0xc(%ebp)
     7d7:	ff 75 08             	pushl  0x8(%ebp)
     7da:	e8 ec 01 00 00       	call   9cb <parseexec>
     7df:	83 c4 10             	add    $0x10,%esp
     7e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(peek(ps, es, "|")){
     7e5:	83 ec 04             	sub    $0x4,%esp
     7e8:	68 c8 69 01 00       	push   $0x169c8
     7ed:	ff 75 0c             	pushl  0xc(%ebp)
     7f0:	ff 75 08             	pushl  0x8(%ebp)
     7f3:	e8 22 fe ff ff       	call   61a <peek>
     7f8:	83 c4 10             	add    $0x10,%esp
     7fb:	85 c0                	test   %eax,%eax
     7fd:	74 35                	je     834 <parsepipe+0x69>
    gettoken(ps, es, 0, 0);
     7ff:	6a 00                	push   $0x0
     801:	6a 00                	push   $0x0
     803:	ff 75 0c             	pushl  0xc(%ebp)
     806:	ff 75 08             	pushl  0x8(%ebp)
     809:	e8 bb fc ff ff       	call   4c9 <gettoken>
     80e:	83 c4 10             	add    $0x10,%esp
    cmd = pipecmd(cmd, parsepipe(ps, es));
     811:	83 ec 08             	sub    $0x8,%esp
     814:	ff 75 0c             	pushl  0xc(%ebp)
     817:	ff 75 08             	pushl  0x8(%ebp)
     81a:	e8 ac ff ff ff       	call   7cb <parsepipe>
     81f:	83 c4 10             	add    $0x10,%esp
     822:	83 ec 08             	sub    $0x8,%esp
     825:	50                   	push   %eax
     826:	ff 75 f4             	pushl  -0xc(%ebp)
     829:	e8 cc fb ff ff       	call   3fa <pipecmd>
     82e:	83 c4 10             	add    $0x10,%esp
     831:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  return cmd;
     834:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
     837:	c9                   	leave  
     838:	c3                   	ret    

00000839 <parseredirs>:

struct cmd*
parseredirs(struct cmd *cmd, char **ps, char *es)
{
     839:	55                   	push   %ebp
     83a:	89 e5                	mov    %esp,%ebp
     83c:	83 ec 18             	sub    $0x18,%esp
  int tok;
  char *q, *eq;

  while(peek(ps, es, "<>")){
     83f:	e9 b6 00 00 00       	jmp    8fa <parseredirs+0xc1>
    tok = gettoken(ps, es, 0, 0);
     844:	6a 00                	push   $0x0
     846:	6a 00                	push   $0x0
     848:	ff 75 10             	pushl  0x10(%ebp)
     84b:	ff 75 0c             	pushl  0xc(%ebp)
     84e:	e8 76 fc ff ff       	call   4c9 <gettoken>
     853:	83 c4 10             	add    $0x10,%esp
     856:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(gettoken(ps, es, &q, &eq) != 'a')
     859:	8d 45 ec             	lea    -0x14(%ebp),%eax
     85c:	50                   	push   %eax
     85d:	8d 45 f0             	lea    -0x10(%ebp),%eax
     860:	50                   	push   %eax
     861:	ff 75 10             	pushl  0x10(%ebp)
     864:	ff 75 0c             	pushl  0xc(%ebp)
     867:	e8 5d fc ff ff       	call   4c9 <gettoken>
     86c:	83 c4 10             	add    $0x10,%esp
     86f:	83 f8 61             	cmp    $0x61,%eax
     872:	74 10                	je     884 <parseredirs+0x4b>
      panic("missing file for redirection");
     874:	83 ec 0c             	sub    $0xc,%esp
     877:	68 ca 69 01 00       	push   $0x169ca
     87c:	e8 97 fa ff ff       	call   318 <panic>
     881:	83 c4 10             	add    $0x10,%esp
    switch(tok){
     884:	8b 45 f4             	mov    -0xc(%ebp),%eax
     887:	83 f8 3c             	cmp    $0x3c,%eax
     88a:	74 0c                	je     898 <parseredirs+0x5f>
     88c:	83 f8 3e             	cmp    $0x3e,%eax
     88f:	74 26                	je     8b7 <parseredirs+0x7e>
     891:	83 f8 2b             	cmp    $0x2b,%eax
     894:	74 43                	je     8d9 <parseredirs+0xa0>
     896:	eb 62                	jmp    8fa <parseredirs+0xc1>
    case '<':
      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
     898:	8b 55 ec             	mov    -0x14(%ebp),%edx
     89b:	8b 45 f0             	mov    -0x10(%ebp),%eax
     89e:	83 ec 0c             	sub    $0xc,%esp
     8a1:	6a 00                	push   $0x0
     8a3:	6a 00                	push   $0x0
     8a5:	52                   	push   %edx
     8a6:	50                   	push   %eax
     8a7:	ff 75 08             	pushl  0x8(%ebp)
     8aa:	e8 e8 fa ff ff       	call   397 <redircmd>
     8af:	83 c4 20             	add    $0x20,%esp
     8b2:	89 45 08             	mov    %eax,0x8(%ebp)
      break;
     8b5:	eb 43                	jmp    8fa <parseredirs+0xc1>
    case '>':
      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
     8b7:	8b 55 ec             	mov    -0x14(%ebp),%edx
     8ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
     8bd:	83 ec 0c             	sub    $0xc,%esp
     8c0:	6a 01                	push   $0x1
     8c2:	68 01 02 00 00       	push   $0x201
     8c7:	52                   	push   %edx
     8c8:	50                   	push   %eax
     8c9:	ff 75 08             	pushl  0x8(%ebp)
     8cc:	e8 c6 fa ff ff       	call   397 <redircmd>
     8d1:	83 c4 20             	add    $0x20,%esp
     8d4:	89 45 08             	mov    %eax,0x8(%ebp)
      break;
     8d7:	eb 21                	jmp    8fa <parseredirs+0xc1>
    case '+':  // >>
      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
     8d9:	8b 55 ec             	mov    -0x14(%ebp),%edx
     8dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
     8df:	83 ec 0c             	sub    $0xc,%esp
     8e2:	6a 01                	push   $0x1
     8e4:	68 01 02 00 00       	push   $0x201
     8e9:	52                   	push   %edx
     8ea:	50                   	push   %eax
     8eb:	ff 75 08             	pushl  0x8(%ebp)
     8ee:	e8 a4 fa ff ff       	call   397 <redircmd>
     8f3:	83 c4 20             	add    $0x20,%esp
     8f6:	89 45 08             	mov    %eax,0x8(%ebp)
      break;
     8f9:	90                   	nop
parseredirs(struct cmd *cmd, char **ps, char *es)
{
  int tok;
  char *q, *eq;

  while(peek(ps, es, "<>")){
     8fa:	83 ec 04             	sub    $0x4,%esp
     8fd:	68 e7 69 01 00       	push   $0x169e7
     902:	ff 75 10             	pushl  0x10(%ebp)
     905:	ff 75 0c             	pushl  0xc(%ebp)
     908:	e8 0d fd ff ff       	call   61a <peek>
     90d:	83 c4 10             	add    $0x10,%esp
     910:	85 c0                	test   %eax,%eax
     912:	0f 85 2c ff ff ff    	jne    844 <parseredirs+0xb>
    case '+':  // >>
      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
      break;
    }
  }
  return cmd;
     918:	8b 45 08             	mov    0x8(%ebp),%eax
}
     91b:	c9                   	leave  
     91c:	c3                   	ret    

0000091d <parseblock>:

struct cmd*
parseblock(char **ps, char *es)
{
     91d:	55                   	push   %ebp
     91e:	89 e5                	mov    %esp,%ebp
     920:	83 ec 18             	sub    $0x18,%esp
  struct cmd *cmd;

  if(!peek(ps, es, "("))
     923:	83 ec 04             	sub    $0x4,%esp
     926:	68 ea 69 01 00       	push   $0x169ea
     92b:	ff 75 0c             	pushl  0xc(%ebp)
     92e:	ff 75 08             	pushl  0x8(%ebp)
     931:	e8 e4 fc ff ff       	call   61a <peek>
     936:	83 c4 10             	add    $0x10,%esp
     939:	85 c0                	test   %eax,%eax
     93b:	75 10                	jne    94d <parseblock+0x30>
    panic("parseblock");
     93d:	83 ec 0c             	sub    $0xc,%esp
     940:	68 ec 69 01 00       	push   $0x169ec
     945:	e8 ce f9 ff ff       	call   318 <panic>
     94a:	83 c4 10             	add    $0x10,%esp
  gettoken(ps, es, 0, 0);
     94d:	6a 00                	push   $0x0
     94f:	6a 00                	push   $0x0
     951:	ff 75 0c             	pushl  0xc(%ebp)
     954:	ff 75 08             	pushl  0x8(%ebp)
     957:	e8 6d fb ff ff       	call   4c9 <gettoken>
     95c:	83 c4 10             	add    $0x10,%esp
  cmd = parseline(ps, es);
     95f:	83 ec 08             	sub    $0x8,%esp
     962:	ff 75 0c             	pushl  0xc(%ebp)
     965:	ff 75 08             	pushl  0x8(%ebp)
     968:	e8 b1 fd ff ff       	call   71e <parseline>
     96d:	83 c4 10             	add    $0x10,%esp
     970:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!peek(ps, es, ")"))
     973:	83 ec 04             	sub    $0x4,%esp
     976:	68 f7 69 01 00       	push   $0x169f7
     97b:	ff 75 0c             	pushl  0xc(%ebp)
     97e:	ff 75 08             	pushl  0x8(%ebp)
     981:	e8 94 fc ff ff       	call   61a <peek>
     986:	83 c4 10             	add    $0x10,%esp
     989:	85 c0                	test   %eax,%eax
     98b:	75 10                	jne    99d <parseblock+0x80>
    panic("syntax - missing )");
     98d:	83 ec 0c             	sub    $0xc,%esp
     990:	68 f9 69 01 00       	push   $0x169f9
     995:	e8 7e f9 ff ff       	call   318 <panic>
     99a:	83 c4 10             	add    $0x10,%esp
  gettoken(ps, es, 0, 0);
     99d:	6a 00                	push   $0x0
     99f:	6a 00                	push   $0x0
     9a1:	ff 75 0c             	pushl  0xc(%ebp)
     9a4:	ff 75 08             	pushl  0x8(%ebp)
     9a7:	e8 1d fb ff ff       	call   4c9 <gettoken>
     9ac:	83 c4 10             	add    $0x10,%esp
  cmd = parseredirs(cmd, ps, es);
     9af:	83 ec 04             	sub    $0x4,%esp
     9b2:	ff 75 0c             	pushl  0xc(%ebp)
     9b5:	ff 75 08             	pushl  0x8(%ebp)
     9b8:	ff 75 f4             	pushl  -0xc(%ebp)
     9bb:	e8 79 fe ff ff       	call   839 <parseredirs>
     9c0:	83 c4 10             	add    $0x10,%esp
     9c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return cmd;
     9c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
     9c9:	c9                   	leave  
     9ca:	c3                   	ret    

000009cb <parseexec>:

struct cmd*
parseexec(char **ps, char *es)
{
     9cb:	55                   	push   %ebp
     9cc:	89 e5                	mov    %esp,%ebp
     9ce:	83 ec 28             	sub    $0x28,%esp
  char *q, *eq;
  int tok, argc;
  struct execcmd *cmd;
  struct cmd *ret;
  
  if(peek(ps, es, "("))
     9d1:	83 ec 04             	sub    $0x4,%esp
     9d4:	68 ea 69 01 00       	push   $0x169ea
     9d9:	ff 75 0c             	pushl  0xc(%ebp)
     9dc:	ff 75 08             	pushl  0x8(%ebp)
     9df:	e8 36 fc ff ff       	call   61a <peek>
     9e4:	83 c4 10             	add    $0x10,%esp
     9e7:	85 c0                	test   %eax,%eax
     9e9:	74 16                	je     a01 <parseexec+0x36>
    return parseblock(ps, es);
     9eb:	83 ec 08             	sub    $0x8,%esp
     9ee:	ff 75 0c             	pushl  0xc(%ebp)
     9f1:	ff 75 08             	pushl  0x8(%ebp)
     9f4:	e8 24 ff ff ff       	call   91d <parseblock>
     9f9:	83 c4 10             	add    $0x10,%esp
     9fc:	e9 fb 00 00 00       	jmp    afc <parseexec+0x131>

  ret = execcmd();
     a01:	e8 5b f9 ff ff       	call   361 <execcmd>
     a06:	89 45 f0             	mov    %eax,-0x10(%ebp)
  cmd = (struct execcmd*)ret;
     a09:	8b 45 f0             	mov    -0x10(%ebp),%eax
     a0c:	89 45 ec             	mov    %eax,-0x14(%ebp)

  argc = 0;
     a0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  ret = parseredirs(ret, ps, es);
     a16:	83 ec 04             	sub    $0x4,%esp
     a19:	ff 75 0c             	pushl  0xc(%ebp)
     a1c:	ff 75 08             	pushl  0x8(%ebp)
     a1f:	ff 75 f0             	pushl  -0x10(%ebp)
     a22:	e8 12 fe ff ff       	call   839 <parseredirs>
     a27:	83 c4 10             	add    $0x10,%esp
     a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while(!peek(ps, es, "|)&;")){
     a2d:	e9 87 00 00 00       	jmp    ab9 <parseexec+0xee>
    if((tok=gettoken(ps, es, &q, &eq)) == 0)
     a32:	8d 45 e0             	lea    -0x20(%ebp),%eax
     a35:	50                   	push   %eax
     a36:	8d 45 e4             	lea    -0x1c(%ebp),%eax
     a39:	50                   	push   %eax
     a3a:	ff 75 0c             	pushl  0xc(%ebp)
     a3d:	ff 75 08             	pushl  0x8(%ebp)
     a40:	e8 84 fa ff ff       	call   4c9 <gettoken>
     a45:	83 c4 10             	add    $0x10,%esp
     a48:	89 45 e8             	mov    %eax,-0x18(%ebp)
     a4b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
     a4f:	0f 84 84 00 00 00    	je     ad9 <parseexec+0x10e>
      break;
    if(tok != 'a')
     a55:	83 7d e8 61          	cmpl   $0x61,-0x18(%ebp)
     a59:	74 10                	je     a6b <parseexec+0xa0>
      panic("syntax");
     a5b:	83 ec 0c             	sub    $0xc,%esp
     a5e:	68 bd 69 01 00       	push   $0x169bd
     a63:	e8 b0 f8 ff ff       	call   318 <panic>
     a68:	83 c4 10             	add    $0x10,%esp
    cmd->argv[argc] = q;
     a6b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
     a6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
     a71:	8b 55 f4             	mov    -0xc(%ebp),%edx
     a74:	89 4c 90 04          	mov    %ecx,0x4(%eax,%edx,4)
    cmd->eargv[argc] = eq;
     a78:	8b 55 e0             	mov    -0x20(%ebp),%edx
     a7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
     a7e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     a81:	83 c1 08             	add    $0x8,%ecx
     a84:	89 54 88 0c          	mov    %edx,0xc(%eax,%ecx,4)
    argc++;
     a88:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    if(argc >= MAXARGS)
     a8c:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
     a90:	7e 10                	jle    aa2 <parseexec+0xd7>
      panic("too many args");
     a92:	83 ec 0c             	sub    $0xc,%esp
     a95:	68 0c 6a 01 00       	push   $0x16a0c
     a9a:	e8 79 f8 ff ff       	call   318 <panic>
     a9f:	83 c4 10             	add    $0x10,%esp
    ret = parseredirs(ret, ps, es);
     aa2:	83 ec 04             	sub    $0x4,%esp
     aa5:	ff 75 0c             	pushl  0xc(%ebp)
     aa8:	ff 75 08             	pushl  0x8(%ebp)
     aab:	ff 75 f0             	pushl  -0x10(%ebp)
     aae:	e8 86 fd ff ff       	call   839 <parseredirs>
     ab3:	83 c4 10             	add    $0x10,%esp
     ab6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  ret = execcmd();
  cmd = (struct execcmd*)ret;

  argc = 0;
  ret = parseredirs(ret, ps, es);
  while(!peek(ps, es, "|)&;")){
     ab9:	83 ec 04             	sub    $0x4,%esp
     abc:	68 1a 6a 01 00       	push   $0x16a1a
     ac1:	ff 75 0c             	pushl  0xc(%ebp)
     ac4:	ff 75 08             	pushl  0x8(%ebp)
     ac7:	e8 4e fb ff ff       	call   61a <peek>
     acc:	83 c4 10             	add    $0x10,%esp
     acf:	85 c0                	test   %eax,%eax
     ad1:	0f 84 5b ff ff ff    	je     a32 <parseexec+0x67>
     ad7:	eb 01                	jmp    ada <parseexec+0x10f>
    if((tok=gettoken(ps, es, &q, &eq)) == 0)
      break;
     ad9:	90                   	nop
    argc++;
    if(argc >= MAXARGS)
      panic("too many args");
    ret = parseredirs(ret, ps, es);
  }
  cmd->argv[argc] = 0;
     ada:	8b 45 ec             	mov    -0x14(%ebp),%eax
     add:	8b 55 f4             	mov    -0xc(%ebp),%edx
     ae0:	c7 44 90 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,4)
     ae7:	00 
  cmd->eargv[argc] = 0;
     ae8:	8b 45 ec             	mov    -0x14(%ebp),%eax
     aeb:	8b 55 f4             	mov    -0xc(%ebp),%edx
     aee:	83 c2 08             	add    $0x8,%edx
     af1:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
     af8:	00 
  return ret;
     af9:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     afc:	c9                   	leave  
     afd:	c3                   	ret    

00000afe <nulterminate>:

// NUL-terminate all the counted strings.
struct cmd*
nulterminate(struct cmd *cmd)
{
     afe:	55                   	push   %ebp
     aff:	89 e5                	mov    %esp,%ebp
     b01:	83 ec 28             	sub    $0x28,%esp
  struct execcmd *ecmd;
  struct listcmd *lcmd;
  struct pipecmd *pcmd;
  struct redircmd *rcmd;

  if(cmd == 0)
     b04:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
     b08:	75 0a                	jne    b14 <nulterminate+0x16>
    return 0;
     b0a:	b8 00 00 00 00       	mov    $0x0,%eax
     b0f:	e9 e4 00 00 00       	jmp    bf8 <nulterminate+0xfa>
  
  switch(cmd->type){
     b14:	8b 45 08             	mov    0x8(%ebp),%eax
     b17:	8b 00                	mov    (%eax),%eax
     b19:	83 f8 05             	cmp    $0x5,%eax
     b1c:	0f 87 d3 00 00 00    	ja     bf5 <nulterminate+0xf7>
     b22:	8b 04 85 20 6a 01 00 	mov    0x16a20(,%eax,4),%eax
     b29:	ff e0                	jmp    *%eax
  case EXEC:
    ecmd = (struct execcmd*)cmd;
     b2b:	8b 45 08             	mov    0x8(%ebp),%eax
     b2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(i=0; ecmd->argv[i]; i++)
     b31:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     b38:	eb 14                	jmp    b4e <nulterminate+0x50>
      *ecmd->eargv[i] = 0;
     b3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
     b3d:	8b 55 f4             	mov    -0xc(%ebp),%edx
     b40:	83 c2 08             	add    $0x8,%edx
     b43:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
     b47:	c6 00 00             	movb   $0x0,(%eax)
    return 0;
  
  switch(cmd->type){
  case EXEC:
    ecmd = (struct execcmd*)cmd;
    for(i=0; ecmd->argv[i]; i++)
     b4a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     b4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
     b51:	8b 55 f4             	mov    -0xc(%ebp),%edx
     b54:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
     b58:	85 c0                	test   %eax,%eax
     b5a:	75 de                	jne    b3a <nulterminate+0x3c>
      *ecmd->eargv[i] = 0;
    break;
     b5c:	e9 94 00 00 00       	jmp    bf5 <nulterminate+0xf7>

  case REDIR:
    rcmd = (struct redircmd*)cmd;
     b61:	8b 45 08             	mov    0x8(%ebp),%eax
     b64:	89 45 ec             	mov    %eax,-0x14(%ebp)
    nulterminate(rcmd->cmd);
     b67:	8b 45 ec             	mov    -0x14(%ebp),%eax
     b6a:	8b 40 04             	mov    0x4(%eax),%eax
     b6d:	83 ec 0c             	sub    $0xc,%esp
     b70:	50                   	push   %eax
     b71:	e8 88 ff ff ff       	call   afe <nulterminate>
     b76:	83 c4 10             	add    $0x10,%esp
    *rcmd->efile = 0;
     b79:	8b 45 ec             	mov    -0x14(%ebp),%eax
     b7c:	8b 40 0c             	mov    0xc(%eax),%eax
     b7f:	c6 00 00             	movb   $0x0,(%eax)
    break;
     b82:	eb 71                	jmp    bf5 <nulterminate+0xf7>

  case PIPE:
    pcmd = (struct pipecmd*)cmd;
     b84:	8b 45 08             	mov    0x8(%ebp),%eax
     b87:	89 45 e8             	mov    %eax,-0x18(%ebp)
    nulterminate(pcmd->left);
     b8a:	8b 45 e8             	mov    -0x18(%ebp),%eax
     b8d:	8b 40 04             	mov    0x4(%eax),%eax
     b90:	83 ec 0c             	sub    $0xc,%esp
     b93:	50                   	push   %eax
     b94:	e8 65 ff ff ff       	call   afe <nulterminate>
     b99:	83 c4 10             	add    $0x10,%esp
    nulterminate(pcmd->right);
     b9c:	8b 45 e8             	mov    -0x18(%ebp),%eax
     b9f:	8b 40 08             	mov    0x8(%eax),%eax
     ba2:	83 ec 0c             	sub    $0xc,%esp
     ba5:	50                   	push   %eax
     ba6:	e8 53 ff ff ff       	call   afe <nulterminate>
     bab:	83 c4 10             	add    $0x10,%esp
    break;
     bae:	eb 45                	jmp    bf5 <nulterminate+0xf7>
    
  case LIST:
    lcmd = (struct listcmd*)cmd;
     bb0:	8b 45 08             	mov    0x8(%ebp),%eax
     bb3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    nulterminate(lcmd->left);
     bb6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     bb9:	8b 40 04             	mov    0x4(%eax),%eax
     bbc:	83 ec 0c             	sub    $0xc,%esp
     bbf:	50                   	push   %eax
     bc0:	e8 39 ff ff ff       	call   afe <nulterminate>
     bc5:	83 c4 10             	add    $0x10,%esp
    nulterminate(lcmd->right);
     bc8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     bcb:	8b 40 08             	mov    0x8(%eax),%eax
     bce:	83 ec 0c             	sub    $0xc,%esp
     bd1:	50                   	push   %eax
     bd2:	e8 27 ff ff ff       	call   afe <nulterminate>
     bd7:	83 c4 10             	add    $0x10,%esp
    break;
     bda:	eb 19                	jmp    bf5 <nulterminate+0xf7>

  case BACK:
    bcmd = (struct backcmd*)cmd;
     bdc:	8b 45 08             	mov    0x8(%ebp),%eax
     bdf:	89 45 e0             	mov    %eax,-0x20(%ebp)
    nulterminate(bcmd->cmd);
     be2:	8b 45 e0             	mov    -0x20(%ebp),%eax
     be5:	8b 40 04             	mov    0x4(%eax),%eax
     be8:	83 ec 0c             	sub    $0xc,%esp
     beb:	50                   	push   %eax
     bec:	e8 0d ff ff ff       	call   afe <nulterminate>
     bf1:	83 c4 10             	add    $0x10,%esp
    break;
     bf4:	90                   	nop
  }
  return cmd;
     bf5:	8b 45 08             	mov    0x8(%ebp),%eax
}
     bf8:	c9                   	leave  
     bf9:	c3                   	ret    

00000bfa <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
     bfa:	55                   	push   %ebp
     bfb:	89 e5                	mov    %esp,%ebp
     bfd:	57                   	push   %edi
     bfe:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
     bff:	8b 4d 08             	mov    0x8(%ebp),%ecx
     c02:	8b 55 10             	mov    0x10(%ebp),%edx
     c05:	8b 45 0c             	mov    0xc(%ebp),%eax
     c08:	89 cb                	mov    %ecx,%ebx
     c0a:	89 df                	mov    %ebx,%edi
     c0c:	89 d1                	mov    %edx,%ecx
     c0e:	fc                   	cld    
     c0f:	f3 aa                	rep stos %al,%es:(%edi)
     c11:	89 ca                	mov    %ecx,%edx
     c13:	89 fb                	mov    %edi,%ebx
     c15:	89 5d 08             	mov    %ebx,0x8(%ebp)
     c18:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
     c1b:	90                   	nop
     c1c:	5b                   	pop    %ebx
     c1d:	5f                   	pop    %edi
     c1e:	5d                   	pop    %ebp
     c1f:	c3                   	ret    

00000c20 <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
     c20:	55                   	push   %ebp
     c21:	89 e5                	mov    %esp,%ebp
     c23:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
     c26:	8b 45 08             	mov    0x8(%ebp),%eax
     c29:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
     c2c:	90                   	nop
     c2d:	8b 45 08             	mov    0x8(%ebp),%eax
     c30:	8d 50 01             	lea    0x1(%eax),%edx
     c33:	89 55 08             	mov    %edx,0x8(%ebp)
     c36:	8b 55 0c             	mov    0xc(%ebp),%edx
     c39:	8d 4a 01             	lea    0x1(%edx),%ecx
     c3c:	89 4d 0c             	mov    %ecx,0xc(%ebp)
     c3f:	0f b6 12             	movzbl (%edx),%edx
     c42:	88 10                	mov    %dl,(%eax)
     c44:	0f b6 00             	movzbl (%eax),%eax
     c47:	84 c0                	test   %al,%al
     c49:	75 e2                	jne    c2d <strcpy+0xd>
    ;
  return os;
     c4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     c4e:	c9                   	leave  
     c4f:	c3                   	ret    

00000c50 <strcmp>:

int
strcmp(const char *p, const char *q)
{
     c50:	55                   	push   %ebp
     c51:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
     c53:	eb 08                	jmp    c5d <strcmp+0xd>
    p++, q++;
     c55:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     c59:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
     c5d:	8b 45 08             	mov    0x8(%ebp),%eax
     c60:	0f b6 00             	movzbl (%eax),%eax
     c63:	84 c0                	test   %al,%al
     c65:	74 10                	je     c77 <strcmp+0x27>
     c67:	8b 45 08             	mov    0x8(%ebp),%eax
     c6a:	0f b6 10             	movzbl (%eax),%edx
     c6d:	8b 45 0c             	mov    0xc(%ebp),%eax
     c70:	0f b6 00             	movzbl (%eax),%eax
     c73:	38 c2                	cmp    %al,%dl
     c75:	74 de                	je     c55 <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
     c77:	8b 45 08             	mov    0x8(%ebp),%eax
     c7a:	0f b6 00             	movzbl (%eax),%eax
     c7d:	0f b6 d0             	movzbl %al,%edx
     c80:	8b 45 0c             	mov    0xc(%ebp),%eax
     c83:	0f b6 00             	movzbl (%eax),%eax
     c86:	0f b6 c0             	movzbl %al,%eax
     c89:	29 c2                	sub    %eax,%edx
     c8b:	89 d0                	mov    %edx,%eax
}
     c8d:	5d                   	pop    %ebp
     c8e:	c3                   	ret    

00000c8f <strlen>:

uint
strlen(char *s)
{
     c8f:	55                   	push   %ebp
     c90:	89 e5                	mov    %esp,%ebp
     c92:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     c95:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     c9c:	eb 04                	jmp    ca2 <strlen+0x13>
     c9e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     ca2:	8b 55 fc             	mov    -0x4(%ebp),%edx
     ca5:	8b 45 08             	mov    0x8(%ebp),%eax
     ca8:	01 d0                	add    %edx,%eax
     caa:	0f b6 00             	movzbl (%eax),%eax
     cad:	84 c0                	test   %al,%al
     caf:	75 ed                	jne    c9e <strlen+0xf>
    ;
  return n;
     cb1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     cb4:	c9                   	leave  
     cb5:	c3                   	ret    

00000cb6 <memset>:

void*
memset(void *dst, int c, uint n)
{
     cb6:	55                   	push   %ebp
     cb7:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     cb9:	8b 45 10             	mov    0x10(%ebp),%eax
     cbc:	50                   	push   %eax
     cbd:	ff 75 0c             	pushl  0xc(%ebp)
     cc0:	ff 75 08             	pushl  0x8(%ebp)
     cc3:	e8 32 ff ff ff       	call   bfa <stosb>
     cc8:	83 c4 0c             	add    $0xc,%esp
  return dst;
     ccb:	8b 45 08             	mov    0x8(%ebp),%eax
}
     cce:	c9                   	leave  
     ccf:	c3                   	ret    

00000cd0 <strchr>:

char*
strchr(const char *s, char c)
{
     cd0:	55                   	push   %ebp
     cd1:	89 e5                	mov    %esp,%ebp
     cd3:	83 ec 04             	sub    $0x4,%esp
     cd6:	8b 45 0c             	mov    0xc(%ebp),%eax
     cd9:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     cdc:	eb 14                	jmp    cf2 <strchr+0x22>
    if(*s == c)
     cde:	8b 45 08             	mov    0x8(%ebp),%eax
     ce1:	0f b6 00             	movzbl (%eax),%eax
     ce4:	3a 45 fc             	cmp    -0x4(%ebp),%al
     ce7:	75 05                	jne    cee <strchr+0x1e>
      return (char*)s;
     ce9:	8b 45 08             	mov    0x8(%ebp),%eax
     cec:	eb 13                	jmp    d01 <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     cee:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     cf2:	8b 45 08             	mov    0x8(%ebp),%eax
     cf5:	0f b6 00             	movzbl (%eax),%eax
     cf8:	84 c0                	test   %al,%al
     cfa:	75 e2                	jne    cde <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     cfc:	b8 00 00 00 00       	mov    $0x0,%eax
}
     d01:	c9                   	leave  
     d02:	c3                   	ret    

00000d03 <gets>:

char*
gets(char *buf, int max)
{
     d03:	55                   	push   %ebp
     d04:	89 e5                	mov    %esp,%ebp
     d06:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     d09:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     d10:	eb 42                	jmp    d54 <gets+0x51>
    cc = read(0, &c, 1);
     d12:	83 ec 04             	sub    $0x4,%esp
     d15:	6a 01                	push   $0x1
     d17:	8d 45 ef             	lea    -0x11(%ebp),%eax
     d1a:	50                   	push   %eax
     d1b:	6a 00                	push   $0x0
     d1d:	e8 47 01 00 00       	call   e69 <read>
     d22:	83 c4 10             	add    $0x10,%esp
     d25:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     d28:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     d2c:	7e 33                	jle    d61 <gets+0x5e>
      break;
    buf[i++] = c;
     d2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d31:	8d 50 01             	lea    0x1(%eax),%edx
     d34:	89 55 f4             	mov    %edx,-0xc(%ebp)
     d37:	89 c2                	mov    %eax,%edx
     d39:	8b 45 08             	mov    0x8(%ebp),%eax
     d3c:	01 c2                	add    %eax,%edx
     d3e:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     d42:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     d44:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     d48:	3c 0a                	cmp    $0xa,%al
     d4a:	74 16                	je     d62 <gets+0x5f>
     d4c:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     d50:	3c 0d                	cmp    $0xd,%al
     d52:	74 0e                	je     d62 <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     d54:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d57:	83 c0 01             	add    $0x1,%eax
     d5a:	3b 45 0c             	cmp    0xc(%ebp),%eax
     d5d:	7c b3                	jl     d12 <gets+0xf>
     d5f:	eb 01                	jmp    d62 <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     d61:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     d62:	8b 55 f4             	mov    -0xc(%ebp),%edx
     d65:	8b 45 08             	mov    0x8(%ebp),%eax
     d68:	01 d0                	add    %edx,%eax
     d6a:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     d6d:	8b 45 08             	mov    0x8(%ebp),%eax
}
     d70:	c9                   	leave  
     d71:	c3                   	ret    

00000d72 <stat>:

int
stat(char *n, struct stat *st)
{
     d72:	55                   	push   %ebp
     d73:	89 e5                	mov    %esp,%ebp
     d75:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     d78:	83 ec 08             	sub    $0x8,%esp
     d7b:	6a 00                	push   $0x0
     d7d:	ff 75 08             	pushl  0x8(%ebp)
     d80:	e8 0c 01 00 00       	call   e91 <open>
     d85:	83 c4 10             	add    $0x10,%esp
     d88:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     d8b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     d8f:	79 07                	jns    d98 <stat+0x26>
    return -1;
     d91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     d96:	eb 25                	jmp    dbd <stat+0x4b>
  r = fstat(fd, st);
     d98:	83 ec 08             	sub    $0x8,%esp
     d9b:	ff 75 0c             	pushl  0xc(%ebp)
     d9e:	ff 75 f4             	pushl  -0xc(%ebp)
     da1:	e8 03 01 00 00       	call   ea9 <fstat>
     da6:	83 c4 10             	add    $0x10,%esp
     da9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     dac:	83 ec 0c             	sub    $0xc,%esp
     daf:	ff 75 f4             	pushl  -0xc(%ebp)
     db2:	e8 c2 00 00 00       	call   e79 <close>
     db7:	83 c4 10             	add    $0x10,%esp
  return r;
     dba:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     dbd:	c9                   	leave  
     dbe:	c3                   	ret    

00000dbf <atoi>:

int
atoi(const char *s)
{
     dbf:	55                   	push   %ebp
     dc0:	89 e5                	mov    %esp,%ebp
     dc2:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     dc5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     dcc:	eb 25                	jmp    df3 <atoi+0x34>
    n = n*10 + *s++ - '0';
     dce:	8b 55 fc             	mov    -0x4(%ebp),%edx
     dd1:	89 d0                	mov    %edx,%eax
     dd3:	c1 e0 02             	shl    $0x2,%eax
     dd6:	01 d0                	add    %edx,%eax
     dd8:	01 c0                	add    %eax,%eax
     dda:	89 c1                	mov    %eax,%ecx
     ddc:	8b 45 08             	mov    0x8(%ebp),%eax
     ddf:	8d 50 01             	lea    0x1(%eax),%edx
     de2:	89 55 08             	mov    %edx,0x8(%ebp)
     de5:	0f b6 00             	movzbl (%eax),%eax
     de8:	0f be c0             	movsbl %al,%eax
     deb:	01 c8                	add    %ecx,%eax
     ded:	83 e8 30             	sub    $0x30,%eax
     df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     df3:	8b 45 08             	mov    0x8(%ebp),%eax
     df6:	0f b6 00             	movzbl (%eax),%eax
     df9:	3c 2f                	cmp    $0x2f,%al
     dfb:	7e 0a                	jle    e07 <atoi+0x48>
     dfd:	8b 45 08             	mov    0x8(%ebp),%eax
     e00:	0f b6 00             	movzbl (%eax),%eax
     e03:	3c 39                	cmp    $0x39,%al
     e05:	7e c7                	jle    dce <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     e07:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     e0a:	c9                   	leave  
     e0b:	c3                   	ret    

00000e0c <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     e0c:	55                   	push   %ebp
     e0d:	89 e5                	mov    %esp,%ebp
     e0f:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     e12:	8b 45 08             	mov    0x8(%ebp),%eax
     e15:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     e18:	8b 45 0c             	mov    0xc(%ebp),%eax
     e1b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     e1e:	eb 17                	jmp    e37 <memmove+0x2b>
    *dst++ = *src++;
     e20:	8b 45 fc             	mov    -0x4(%ebp),%eax
     e23:	8d 50 01             	lea    0x1(%eax),%edx
     e26:	89 55 fc             	mov    %edx,-0x4(%ebp)
     e29:	8b 55 f8             	mov    -0x8(%ebp),%edx
     e2c:	8d 4a 01             	lea    0x1(%edx),%ecx
     e2f:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     e32:	0f b6 12             	movzbl (%edx),%edx
     e35:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     e37:	8b 45 10             	mov    0x10(%ebp),%eax
     e3a:	8d 50 ff             	lea    -0x1(%eax),%edx
     e3d:	89 55 10             	mov    %edx,0x10(%ebp)
     e40:	85 c0                	test   %eax,%eax
     e42:	7f dc                	jg     e20 <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     e44:	8b 45 08             	mov    0x8(%ebp),%eax
}
     e47:	c9                   	leave  
     e48:	c3                   	ret    

00000e49 <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     e49:	b8 01 00 00 00       	mov    $0x1,%eax
     e4e:	cd 40                	int    $0x40
     e50:	c3                   	ret    

00000e51 <exit>:
SYSCALL(exit)
     e51:	b8 02 00 00 00       	mov    $0x2,%eax
     e56:	cd 40                	int    $0x40
     e58:	c3                   	ret    

00000e59 <wait>:
SYSCALL(wait)
     e59:	b8 03 00 00 00       	mov    $0x3,%eax
     e5e:	cd 40                	int    $0x40
     e60:	c3                   	ret    

00000e61 <pipe>:
SYSCALL(pipe)
     e61:	b8 04 00 00 00       	mov    $0x4,%eax
     e66:	cd 40                	int    $0x40
     e68:	c3                   	ret    

00000e69 <read>:
SYSCALL(read)
     e69:	b8 05 00 00 00       	mov    $0x5,%eax
     e6e:	cd 40                	int    $0x40
     e70:	c3                   	ret    

00000e71 <write>:
SYSCALL(write)
     e71:	b8 10 00 00 00       	mov    $0x10,%eax
     e76:	cd 40                	int    $0x40
     e78:	c3                   	ret    

00000e79 <close>:
SYSCALL(close)
     e79:	b8 15 00 00 00       	mov    $0x15,%eax
     e7e:	cd 40                	int    $0x40
     e80:	c3                   	ret    

00000e81 <kill>:
SYSCALL(kill)
     e81:	b8 06 00 00 00       	mov    $0x6,%eax
     e86:	cd 40                	int    $0x40
     e88:	c3                   	ret    

00000e89 <exec>:
SYSCALL(exec)
     e89:	b8 07 00 00 00       	mov    $0x7,%eax
     e8e:	cd 40                	int    $0x40
     e90:	c3                   	ret    

00000e91 <open>:
SYSCALL(open)
     e91:	b8 0f 00 00 00       	mov    $0xf,%eax
     e96:	cd 40                	int    $0x40
     e98:	c3                   	ret    

00000e99 <mknod>:
SYSCALL(mknod)
     e99:	b8 11 00 00 00       	mov    $0x11,%eax
     e9e:	cd 40                	int    $0x40
     ea0:	c3                   	ret    

00000ea1 <unlink>:
SYSCALL(unlink)
     ea1:	b8 12 00 00 00       	mov    $0x12,%eax
     ea6:	cd 40                	int    $0x40
     ea8:	c3                   	ret    

00000ea9 <fstat>:
SYSCALL(fstat)
     ea9:	b8 08 00 00 00       	mov    $0x8,%eax
     eae:	cd 40                	int    $0x40
     eb0:	c3                   	ret    

00000eb1 <link>:
SYSCALL(link)
     eb1:	b8 13 00 00 00       	mov    $0x13,%eax
     eb6:	cd 40                	int    $0x40
     eb8:	c3                   	ret    

00000eb9 <mkdir>:
SYSCALL(mkdir)
     eb9:	b8 14 00 00 00       	mov    $0x14,%eax
     ebe:	cd 40                	int    $0x40
     ec0:	c3                   	ret    

00000ec1 <chdir>:
SYSCALL(chdir)
     ec1:	b8 09 00 00 00       	mov    $0x9,%eax
     ec6:	cd 40                	int    $0x40
     ec8:	c3                   	ret    

00000ec9 <dup>:
SYSCALL(dup)
     ec9:	b8 0a 00 00 00       	mov    $0xa,%eax
     ece:	cd 40                	int    $0x40
     ed0:	c3                   	ret    

00000ed1 <getpid>:
SYSCALL(getpid)
     ed1:	b8 0b 00 00 00       	mov    $0xb,%eax
     ed6:	cd 40                	int    $0x40
     ed8:	c3                   	ret    

00000ed9 <sbrk>:
SYSCALL(sbrk)
     ed9:	b8 0c 00 00 00       	mov    $0xc,%eax
     ede:	cd 40                	int    $0x40
     ee0:	c3                   	ret    

00000ee1 <sleep>:
SYSCALL(sleep)
     ee1:	b8 0d 00 00 00       	mov    $0xd,%eax
     ee6:	cd 40                	int    $0x40
     ee8:	c3                   	ret    

00000ee9 <uptime>:
SYSCALL(uptime)
     ee9:	b8 0e 00 00 00       	mov    $0xe,%eax
     eee:	cd 40                	int    $0x40
     ef0:	c3                   	ret    

00000ef1 <createwindow>:
SYSCALL(createwindow)
     ef1:	b8 16 00 00 00       	mov    $0x16,%eax
     ef6:	cd 40                	int    $0x40
     ef8:	c3                   	ret    

00000ef9 <repaintwindow>:
SYSCALL(repaintwindow)
     ef9:	b8 17 00 00 00       	mov    $0x17,%eax
     efe:	cd 40                	int    $0x40
     f00:	c3                   	ret    

00000f01 <getmessage>:
SYSCALL(getmessage)
     f01:	b8 18 00 00 00       	mov    $0x18,%eax
     f06:	cd 40                	int    $0x40
     f08:	c3                   	ret    

00000f09 <settimer>:
SYSCALL(settimer)
     f09:	b8 19 00 00 00       	mov    $0x19,%eax
     f0e:	cd 40                	int    $0x40
     f10:	c3                   	ret    

00000f11 <updatewindow>:
SYSCALL(updatewindow)
     f11:	b8 1a 00 00 00       	mov    $0x1a,%eax
     f16:	cd 40                	int    $0x40
     f18:	c3                   	ret    

00000f19 <destroywindow>:
SYSCALL(destroywindow)
     f19:	b8 1b 00 00 00       	mov    $0x1b,%eax
     f1e:	cd 40                	int    $0x40
     f20:	c3                   	ret    

00000f21 <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     f21:	55                   	push   %ebp
     f22:	89 e5                	mov    %esp,%ebp
     f24:	83 ec 18             	sub    $0x18,%esp
     f27:	8b 45 0c             	mov    0xc(%ebp),%eax
     f2a:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     f2d:	83 ec 04             	sub    $0x4,%esp
     f30:	6a 01                	push   $0x1
     f32:	8d 45 f4             	lea    -0xc(%ebp),%eax
     f35:	50                   	push   %eax
     f36:	ff 75 08             	pushl  0x8(%ebp)
     f39:	e8 33 ff ff ff       	call   e71 <write>
     f3e:	83 c4 10             	add    $0x10,%esp
}
     f41:	90                   	nop
     f42:	c9                   	leave  
     f43:	c3                   	ret    

00000f44 <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     f44:	55                   	push   %ebp
     f45:	89 e5                	mov    %esp,%ebp
     f47:	53                   	push   %ebx
     f48:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     f4b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     f52:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     f56:	74 17                	je     f6f <printint+0x2b>
     f58:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     f5c:	79 11                	jns    f6f <printint+0x2b>
    neg = 1;
     f5e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     f65:	8b 45 0c             	mov    0xc(%ebp),%eax
     f68:	f7 d8                	neg    %eax
     f6a:	89 45 ec             	mov    %eax,-0x14(%ebp)
     f6d:	eb 06                	jmp    f75 <printint+0x31>
  } else {
    x = xx;
     f6f:	8b 45 0c             	mov    0xc(%ebp),%eax
     f72:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     f75:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     f7c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     f7f:	8d 41 01             	lea    0x1(%ecx),%eax
     f82:	89 45 f4             	mov    %eax,-0xc(%ebp)
     f85:	8b 5d 10             	mov    0x10(%ebp),%ebx
     f88:	8b 45 ec             	mov    -0x14(%ebp),%eax
     f8b:	ba 00 00 00 00       	mov    $0x0,%edx
     f90:	f7 f3                	div    %ebx
     f92:	89 d0                	mov    %edx,%eax
     f94:	0f b6 80 50 ef 01 00 	movzbl 0x1ef50(%eax),%eax
     f9b:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     f9f:	8b 5d 10             	mov    0x10(%ebp),%ebx
     fa2:	8b 45 ec             	mov    -0x14(%ebp),%eax
     fa5:	ba 00 00 00 00       	mov    $0x0,%edx
     faa:	f7 f3                	div    %ebx
     fac:	89 45 ec             	mov    %eax,-0x14(%ebp)
     faf:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     fb3:	75 c7                	jne    f7c <printint+0x38>
  if(neg)
     fb5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     fb9:	74 2d                	je     fe8 <printint+0xa4>
    buf[i++] = '-';
     fbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
     fbe:	8d 50 01             	lea    0x1(%eax),%edx
     fc1:	89 55 f4             	mov    %edx,-0xc(%ebp)
     fc4:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     fc9:	eb 1d                	jmp    fe8 <printint+0xa4>
    putc(fd, buf[i]);
     fcb:	8d 55 dc             	lea    -0x24(%ebp),%edx
     fce:	8b 45 f4             	mov    -0xc(%ebp),%eax
     fd1:	01 d0                	add    %edx,%eax
     fd3:	0f b6 00             	movzbl (%eax),%eax
     fd6:	0f be c0             	movsbl %al,%eax
     fd9:	83 ec 08             	sub    $0x8,%esp
     fdc:	50                   	push   %eax
     fdd:	ff 75 08             	pushl  0x8(%ebp)
     fe0:	e8 3c ff ff ff       	call   f21 <putc>
     fe5:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     fe8:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     fec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     ff0:	79 d9                	jns    fcb <printint+0x87>
    putc(fd, buf[i]);
}
     ff2:	90                   	nop
     ff3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     ff6:	c9                   	leave  
     ff7:	c3                   	ret    

00000ff8 <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     ff8:	55                   	push   %ebp
     ff9:	89 e5                	mov    %esp,%ebp
     ffb:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     ffe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
    1005:	8d 45 0c             	lea    0xc(%ebp),%eax
    1008:	83 c0 04             	add    $0x4,%eax
    100b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
    100e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1015:	e9 59 01 00 00       	jmp    1173 <printf+0x17b>
    c = fmt[i] & 0xff;
    101a:	8b 55 0c             	mov    0xc(%ebp),%edx
    101d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1020:	01 d0                	add    %edx,%eax
    1022:	0f b6 00             	movzbl (%eax),%eax
    1025:	0f be c0             	movsbl %al,%eax
    1028:	25 ff 00 00 00       	and    $0xff,%eax
    102d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
    1030:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1034:	75 2c                	jne    1062 <printf+0x6a>
      if(c == '%'){
    1036:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
    103a:	75 0c                	jne    1048 <printf+0x50>
        state = '%';
    103c:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
    1043:	e9 27 01 00 00       	jmp    116f <printf+0x177>
      } else {
        putc(fd, c);
    1048:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    104b:	0f be c0             	movsbl %al,%eax
    104e:	83 ec 08             	sub    $0x8,%esp
    1051:	50                   	push   %eax
    1052:	ff 75 08             	pushl  0x8(%ebp)
    1055:	e8 c7 fe ff ff       	call   f21 <putc>
    105a:	83 c4 10             	add    $0x10,%esp
    105d:	e9 0d 01 00 00       	jmp    116f <printf+0x177>
      }
    } else if(state == '%'){
    1062:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
    1066:	0f 85 03 01 00 00    	jne    116f <printf+0x177>
      if(c == 'd'){
    106c:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
    1070:	75 1e                	jne    1090 <printf+0x98>
        printint(fd, *ap, 10, 1);
    1072:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1075:	8b 00                	mov    (%eax),%eax
    1077:	6a 01                	push   $0x1
    1079:	6a 0a                	push   $0xa
    107b:	50                   	push   %eax
    107c:	ff 75 08             	pushl  0x8(%ebp)
    107f:	e8 c0 fe ff ff       	call   f44 <printint>
    1084:	83 c4 10             	add    $0x10,%esp
        ap++;
    1087:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    108b:	e9 d8 00 00 00       	jmp    1168 <printf+0x170>
      } else if(c == 'x' || c == 'p'){
    1090:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
    1094:	74 06                	je     109c <printf+0xa4>
    1096:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
    109a:	75 1e                	jne    10ba <printf+0xc2>
        printint(fd, *ap, 16, 0);
    109c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    109f:	8b 00                	mov    (%eax),%eax
    10a1:	6a 00                	push   $0x0
    10a3:	6a 10                	push   $0x10
    10a5:	50                   	push   %eax
    10a6:	ff 75 08             	pushl  0x8(%ebp)
    10a9:	e8 96 fe ff ff       	call   f44 <printint>
    10ae:	83 c4 10             	add    $0x10,%esp
        ap++;
    10b1:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    10b5:	e9 ae 00 00 00       	jmp    1168 <printf+0x170>
      } else if(c == 's'){
    10ba:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
    10be:	75 43                	jne    1103 <printf+0x10b>
        s = (char*)*ap;
    10c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    10c3:	8b 00                	mov    (%eax),%eax
    10c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
    10c8:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
    10cc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    10d0:	75 25                	jne    10f7 <printf+0xff>
          s = "(null)";
    10d2:	c7 45 f4 38 6a 01 00 	movl   $0x16a38,-0xc(%ebp)
        while(*s != 0){
    10d9:	eb 1c                	jmp    10f7 <printf+0xff>
          putc(fd, *s);
    10db:	8b 45 f4             	mov    -0xc(%ebp),%eax
    10de:	0f b6 00             	movzbl (%eax),%eax
    10e1:	0f be c0             	movsbl %al,%eax
    10e4:	83 ec 08             	sub    $0x8,%esp
    10e7:	50                   	push   %eax
    10e8:	ff 75 08             	pushl  0x8(%ebp)
    10eb:	e8 31 fe ff ff       	call   f21 <putc>
    10f0:	83 c4 10             	add    $0x10,%esp
          s++;
    10f3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
    10f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    10fa:	0f b6 00             	movzbl (%eax),%eax
    10fd:	84 c0                	test   %al,%al
    10ff:	75 da                	jne    10db <printf+0xe3>
    1101:	eb 65                	jmp    1168 <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
    1103:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
    1107:	75 1d                	jne    1126 <printf+0x12e>
        putc(fd, *ap);
    1109:	8b 45 e8             	mov    -0x18(%ebp),%eax
    110c:	8b 00                	mov    (%eax),%eax
    110e:	0f be c0             	movsbl %al,%eax
    1111:	83 ec 08             	sub    $0x8,%esp
    1114:	50                   	push   %eax
    1115:	ff 75 08             	pushl  0x8(%ebp)
    1118:	e8 04 fe ff ff       	call   f21 <putc>
    111d:	83 c4 10             	add    $0x10,%esp
        ap++;
    1120:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    1124:	eb 42                	jmp    1168 <printf+0x170>
      } else if(c == '%'){
    1126:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
    112a:	75 17                	jne    1143 <printf+0x14b>
        putc(fd, c);
    112c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    112f:	0f be c0             	movsbl %al,%eax
    1132:	83 ec 08             	sub    $0x8,%esp
    1135:	50                   	push   %eax
    1136:	ff 75 08             	pushl  0x8(%ebp)
    1139:	e8 e3 fd ff ff       	call   f21 <putc>
    113e:	83 c4 10             	add    $0x10,%esp
    1141:	eb 25                	jmp    1168 <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
    1143:	83 ec 08             	sub    $0x8,%esp
    1146:	6a 25                	push   $0x25
    1148:	ff 75 08             	pushl  0x8(%ebp)
    114b:	e8 d1 fd ff ff       	call   f21 <putc>
    1150:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
    1153:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1156:	0f be c0             	movsbl %al,%eax
    1159:	83 ec 08             	sub    $0x8,%esp
    115c:	50                   	push   %eax
    115d:	ff 75 08             	pushl  0x8(%ebp)
    1160:	e8 bc fd ff ff       	call   f21 <putc>
    1165:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
    1168:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
    116f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1173:	8b 55 0c             	mov    0xc(%ebp),%edx
    1176:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1179:	01 d0                	add    %edx,%eax
    117b:	0f b6 00             	movzbl (%eax),%eax
    117e:	84 c0                	test   %al,%al
    1180:	0f 85 94 fe ff ff    	jne    101a <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
    1186:	90                   	nop
    1187:	c9                   	leave  
    1188:	c3                   	ret    

00001189 <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
    1189:	55                   	push   %ebp
    118a:	89 e5                	mov    %esp,%ebp
    118c:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
    118f:	8b 45 08             	mov    0x8(%ebp),%eax
    1192:	83 e8 08             	sub    $0x8,%eax
    1195:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
    1198:	a1 0c f4 01 00       	mov    0x1f40c,%eax
    119d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    11a0:	eb 24                	jmp    11c6 <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
    11a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    11a5:	8b 00                	mov    (%eax),%eax
    11a7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    11aa:	77 12                	ja     11be <free+0x35>
    11ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
    11af:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    11b2:	77 24                	ja     11d8 <free+0x4f>
    11b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    11b7:	8b 00                	mov    (%eax),%eax
    11b9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    11bc:	77 1a                	ja     11d8 <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
    11be:	8b 45 fc             	mov    -0x4(%ebp),%eax
    11c1:	8b 00                	mov    (%eax),%eax
    11c3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    11c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    11c9:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    11cc:	76 d4                	jbe    11a2 <free+0x19>
    11ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
    11d1:	8b 00                	mov    (%eax),%eax
    11d3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    11d6:	76 ca                	jbe    11a2 <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
    11d8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    11db:	8b 40 04             	mov    0x4(%eax),%eax
    11de:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    11e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    11e8:	01 c2                	add    %eax,%edx
    11ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
    11ed:	8b 00                	mov    (%eax),%eax
    11ef:	39 c2                	cmp    %eax,%edx
    11f1:	75 24                	jne    1217 <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
    11f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    11f6:	8b 50 04             	mov    0x4(%eax),%edx
    11f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    11fc:	8b 00                	mov    (%eax),%eax
    11fe:	8b 40 04             	mov    0x4(%eax),%eax
    1201:	01 c2                	add    %eax,%edx
    1203:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1206:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
    1209:	8b 45 fc             	mov    -0x4(%ebp),%eax
    120c:	8b 00                	mov    (%eax),%eax
    120e:	8b 10                	mov    (%eax),%edx
    1210:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1213:	89 10                	mov    %edx,(%eax)
    1215:	eb 0a                	jmp    1221 <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
    1217:	8b 45 fc             	mov    -0x4(%ebp),%eax
    121a:	8b 10                	mov    (%eax),%edx
    121c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    121f:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
    1221:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1224:	8b 40 04             	mov    0x4(%eax),%eax
    1227:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    122e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1231:	01 d0                	add    %edx,%eax
    1233:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1236:	75 20                	jne    1258 <free+0xcf>
    p->s.size += bp->s.size;
    1238:	8b 45 fc             	mov    -0x4(%ebp),%eax
    123b:	8b 50 04             	mov    0x4(%eax),%edx
    123e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1241:	8b 40 04             	mov    0x4(%eax),%eax
    1244:	01 c2                	add    %eax,%edx
    1246:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1249:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
    124c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    124f:	8b 10                	mov    (%eax),%edx
    1251:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1254:	89 10                	mov    %edx,(%eax)
    1256:	eb 08                	jmp    1260 <free+0xd7>
  } else
    p->s.ptr = bp;
    1258:	8b 45 fc             	mov    -0x4(%ebp),%eax
    125b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    125e:	89 10                	mov    %edx,(%eax)
  freep = p;
    1260:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1263:	a3 0c f4 01 00       	mov    %eax,0x1f40c
}
    1268:	90                   	nop
    1269:	c9                   	leave  
    126a:	c3                   	ret    

0000126b <morecore>:

static Header*
morecore(uint nu)
{
    126b:	55                   	push   %ebp
    126c:	89 e5                	mov    %esp,%ebp
    126e:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
    1271:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
    1278:	77 07                	ja     1281 <morecore+0x16>
    nu = 4096;
    127a:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
    1281:	8b 45 08             	mov    0x8(%ebp),%eax
    1284:	c1 e0 03             	shl    $0x3,%eax
    1287:	83 ec 0c             	sub    $0xc,%esp
    128a:	50                   	push   %eax
    128b:	e8 49 fc ff ff       	call   ed9 <sbrk>
    1290:	83 c4 10             	add    $0x10,%esp
    1293:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
    1296:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
    129a:	75 07                	jne    12a3 <morecore+0x38>
    return 0;
    129c:	b8 00 00 00 00       	mov    $0x0,%eax
    12a1:	eb 26                	jmp    12c9 <morecore+0x5e>
  hp = (Header*)p;
    12a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    12a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
    12a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    12ac:	8b 55 08             	mov    0x8(%ebp),%edx
    12af:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
    12b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    12b5:	83 c0 08             	add    $0x8,%eax
    12b8:	83 ec 0c             	sub    $0xc,%esp
    12bb:	50                   	push   %eax
    12bc:	e8 c8 fe ff ff       	call   1189 <free>
    12c1:	83 c4 10             	add    $0x10,%esp
  return freep;
    12c4:	a1 0c f4 01 00       	mov    0x1f40c,%eax
}
    12c9:	c9                   	leave  
    12ca:	c3                   	ret    

000012cb <malloc>:

void*
malloc(uint nbytes)
{
    12cb:	55                   	push   %ebp
    12cc:	89 e5                	mov    %esp,%ebp
    12ce:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
    12d1:	8b 45 08             	mov    0x8(%ebp),%eax
    12d4:	83 c0 07             	add    $0x7,%eax
    12d7:	c1 e8 03             	shr    $0x3,%eax
    12da:	83 c0 01             	add    $0x1,%eax
    12dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
    12e0:	a1 0c f4 01 00       	mov    0x1f40c,%eax
    12e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    12e8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    12ec:	75 23                	jne    1311 <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
    12ee:	c7 45 f0 04 f4 01 00 	movl   $0x1f404,-0x10(%ebp)
    12f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    12f8:	a3 0c f4 01 00       	mov    %eax,0x1f40c
    12fd:	a1 0c f4 01 00       	mov    0x1f40c,%eax
    1302:	a3 04 f4 01 00       	mov    %eax,0x1f404
    base.s.size = 0;
    1307:	c7 05 08 f4 01 00 00 	movl   $0x0,0x1f408
    130e:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
    1311:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1314:	8b 00                	mov    (%eax),%eax
    1316:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
    1319:	8b 45 f4             	mov    -0xc(%ebp),%eax
    131c:	8b 40 04             	mov    0x4(%eax),%eax
    131f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    1322:	72 4d                	jb     1371 <malloc+0xa6>
      if(p->s.size == nunits)
    1324:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1327:	8b 40 04             	mov    0x4(%eax),%eax
    132a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    132d:	75 0c                	jne    133b <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
    132f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1332:	8b 10                	mov    (%eax),%edx
    1334:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1337:	89 10                	mov    %edx,(%eax)
    1339:	eb 26                	jmp    1361 <malloc+0x96>
      else {
        p->s.size -= nunits;
    133b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    133e:	8b 40 04             	mov    0x4(%eax),%eax
    1341:	2b 45 ec             	sub    -0x14(%ebp),%eax
    1344:	89 c2                	mov    %eax,%edx
    1346:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1349:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
    134c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    134f:	8b 40 04             	mov    0x4(%eax),%eax
    1352:	c1 e0 03             	shl    $0x3,%eax
    1355:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
    1358:	8b 45 f4             	mov    -0xc(%ebp),%eax
    135b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    135e:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
    1361:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1364:	a3 0c f4 01 00       	mov    %eax,0x1f40c
      return (void*)(p + 1);
    1369:	8b 45 f4             	mov    -0xc(%ebp),%eax
    136c:	83 c0 08             	add    $0x8,%eax
    136f:	eb 3b                	jmp    13ac <malloc+0xe1>
    }
    if(p == freep)
    1371:	a1 0c f4 01 00       	mov    0x1f40c,%eax
    1376:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    1379:	75 1e                	jne    1399 <malloc+0xce>
      if((p = morecore(nunits)) == 0)
    137b:	83 ec 0c             	sub    $0xc,%esp
    137e:	ff 75 ec             	pushl  -0x14(%ebp)
    1381:	e8 e5 fe ff ff       	call   126b <morecore>
    1386:	83 c4 10             	add    $0x10,%esp
    1389:	89 45 f4             	mov    %eax,-0xc(%ebp)
    138c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1390:	75 07                	jne    1399 <malloc+0xce>
        return 0;
    1392:	b8 00 00 00 00       	mov    $0x0,%eax
    1397:	eb 13                	jmp    13ac <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
    1399:	8b 45 f4             	mov    -0xc(%ebp),%eax
    139c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    139f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    13a2:	8b 00                	mov    (%eax),%eax
    13a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
    13a7:	e9 6d ff ff ff       	jmp    1319 <malloc+0x4e>
}
    13ac:	c9                   	leave  
    13ad:	c3                   	ret    

000013ae <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
    13ae:	55                   	push   %ebp
    13af:	89 e5                	mov    %esp,%ebp
    ++g_seed;
    13b1:	a1 10 f4 01 00       	mov    0x1f410,%eax
    13b6:	83 c0 01             	add    $0x1,%eax
    13b9:	a3 10 f4 01 00       	mov    %eax,0x1f410
    g_seed = (214013*g_seed+2531011);
    13be:	a1 10 f4 01 00       	mov    0x1f410,%eax
    13c3:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
    13c9:	05 c3 9e 26 00       	add    $0x269ec3,%eax
    13ce:	a3 10 f4 01 00       	mov    %eax,0x1f410
    return (g_seed>>16)&0x7FFF;
    13d3:	a1 10 f4 01 00       	mov    0x1f410,%eax
    13d8:	c1 e8 10             	shr    $0x10,%eax
    13db:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
    13e0:	5d                   	pop    %ebp
    13e1:	c3                   	ret    

000013e2 <abs>:

#define PI 3.1415926536

float abs(float x) 
{
    13e2:	55                   	push   %ebp
    13e3:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
    13e5:	d9 45 08             	flds   0x8(%ebp)
    13e8:	d9 ee                	fldz   
    13ea:	d9 c9                	fxch   %st(1)
    13ec:	df e9                	fucomip %st(1),%st
    13ee:	dd d8                	fstp   %st(0)
    13f0:	76 05                	jbe    13f7 <abs+0x15>
    13f2:	d9 45 08             	flds   0x8(%ebp)
    13f5:	eb 05                	jmp    13fc <abs+0x1a>
	return -x;
    13f7:	d9 45 08             	flds   0x8(%ebp)
    13fa:	d9 e0                	fchs   
}
    13fc:	5d                   	pop    %ebp
    13fd:	c3                   	ret    

000013fe <pow>:

float pow(float a, int b)
{
    13fe:	55                   	push   %ebp
    13ff:	89 e5                	mov    %esp,%ebp
    1401:	83 ec 10             	sub    $0x10,%esp
	float r = a;
    1404:	d9 45 08             	flds   0x8(%ebp)
    1407:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
    140a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    140e:	7e 17                	jle    1427 <pow+0x29>
		while (--b)
    1410:	eb 09                	jmp    141b <pow+0x1d>
			r *= a;
    1412:	d9 45 fc             	flds   -0x4(%ebp)
    1415:	d8 4d 08             	fmuls  0x8(%ebp)
    1418:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
    141b:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    141f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1423:	75 ed                	jne    1412 <pow+0x14>
    1425:	eb 2a                	jmp    1451 <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
    1427:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    142b:	79 1f                	jns    144c <pow+0x4e>
		while (++b)
    142d:	eb 09                	jmp    1438 <pow+0x3a>
			r *= a;
    142f:	d9 45 fc             	flds   -0x4(%ebp)
    1432:	d8 4d 08             	fmuls  0x8(%ebp)
    1435:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
    1438:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    143c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1440:	75 ed                	jne    142f <pow+0x31>
			r *= a;
		r = 1.0 / r;
    1442:	d9 e8                	fld1   
    1444:	d8 75 fc             	fdivs  -0x4(%ebp)
    1447:	d9 5d fc             	fstps  -0x4(%ebp)
    144a:	eb 05                	jmp    1451 <pow+0x53>
	}
	else r = 0;
    144c:	d9 ee                	fldz   
    144e:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
    1451:	d9 45 fc             	flds   -0x4(%ebp)
}
    1454:	c9                   	leave  
    1455:	c3                   	ret    

00001456 <sqrt>:

float sqrt(float number) {
    1456:	55                   	push   %ebp
    1457:	89 e5                	mov    %esp,%ebp
    1459:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
    145c:	d9 ee                	fldz   
    145e:	d9 45 08             	flds   0x8(%ebp)
    1461:	d9 c9                	fxch   %st(1)
    1463:	df e9                	fucomip %st(1),%st
    1465:	dd d8                	fstp   %st(0)
    1467:	76 06                	jbe    146f <sqrt+0x19>
		return -1;
    1469:	d9 e8                	fld1   
    146b:	d9 e0                	fchs   
    146d:	eb 3a                	jmp    14a9 <sqrt+0x53>
	}

	new_guess = 1;
    146f:	d9 e8                	fld1   
    1471:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
    1474:	d9 45 fc             	flds   -0x4(%ebp)
    1477:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
    147a:	d9 45 08             	flds   0x8(%ebp)
    147d:	d8 75 f8             	fdivs  -0x8(%ebp)
    1480:	d8 45 f8             	fadds  -0x8(%ebp)
    1483:	d9 05 40 6a 01 00    	flds   0x16a40
    1489:	de f9                	fdivrp %st,%st(1)
    148b:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
    148e:	d9 45 fc             	flds   -0x4(%ebp)
    1491:	d9 45 f8             	flds   -0x8(%ebp)
    1494:	df e9                	fucomip %st(1),%st
    1496:	dd d8                	fstp   %st(0)
    1498:	7a da                	jp     1474 <sqrt+0x1e>
    149a:	d9 45 fc             	flds   -0x4(%ebp)
    149d:	d9 45 f8             	flds   -0x8(%ebp)
    14a0:	df e9                	fucomip %st(1),%st
    14a2:	dd d8                	fstp   %st(0)
    14a4:	75 ce                	jne    1474 <sqrt+0x1e>

	return new_guess;
    14a6:	d9 45 fc             	flds   -0x4(%ebp)
}
    14a9:	c9                   	leave  
    14aa:	c3                   	ret    

000014ab <cos>:

float cos(float x)
{
    14ab:	55                   	push   %ebp
    14ac:	89 e5                	mov    %esp,%ebp
    14ae:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
    14b1:	d9 e8                	fld1   
    14b3:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
    14b6:	d9 45 08             	flds   0x8(%ebp)
    14b9:	dd 05 48 6a 01 00    	fldl   0x16a48
    14bf:	d9 c9                	fxch   %st(1)
    14c1:	df e9                	fucomip %st(1),%st
    14c3:	dd d8                	fstp   %st(0)
    14c5:	77 0f                	ja     14d6 <cos+0x2b>
    14c7:	d9 45 08             	flds   0x8(%ebp)
    14ca:	dd 05 50 6a 01 00    	fldl   0x16a50
    14d0:	df e9                	fucomip %st(1),%st
    14d2:	dd d8                	fstp   %st(0)
    14d4:	76 3c                	jbe    1512 <cos+0x67>
    14d6:	d9 45 08             	flds   0x8(%ebp)
    14d9:	d9 45 08             	flds   0x8(%ebp)
    14dc:	dd 05 48 6a 01 00    	fldl   0x16a48
    14e2:	de f9                	fdivrp %st,%st(1)
    14e4:	d9 7d e2             	fnstcw -0x1e(%ebp)
    14e7:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
    14eb:	b4 0c                	mov    $0xc,%ah
    14ed:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    14f1:	d9 6d e0             	fldcw  -0x20(%ebp)
    14f4:	db 5d dc             	fistpl -0x24(%ebp)
    14f7:	d9 6d e2             	fldcw  -0x1e(%ebp)
    14fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
    14fd:	01 c0                	add    %eax,%eax
    14ff:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1502:	db 45 d8             	fildl  -0x28(%ebp)
    1505:	dd 05 58 6a 01 00    	fldl   0x16a58
    150b:	de c9                	fmulp  %st,%st(1)
    150d:	de e9                	fsubrp %st,%st(1)
    150f:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
    1512:	d9 45 08             	flds   0x8(%ebp)
    1515:	dd 05 58 6a 01 00    	fldl   0x16a58
    151b:	d9 c9                	fxch   %st(1)
    151d:	df e9                	fucomip %st(1),%st
    151f:	dd d8                	fstp   %st(0)
    1521:	76 0e                	jbe    1531 <cos+0x86>
    1523:	d9 45 08             	flds   0x8(%ebp)
    1526:	dd 05 48 6a 01 00    	fldl   0x16a48
    152c:	de e9                	fsubrp %st,%st(1)
    152e:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
    1531:	d9 45 08             	flds   0x8(%ebp)
    1534:	dd 05 60 6a 01 00    	fldl   0x16a60
    153a:	df e9                	fucomip %st(1),%st
    153c:	dd d8                	fstp   %st(0)
    153e:	76 0e                	jbe    154e <cos+0xa3>
    1540:	d9 45 08             	flds   0x8(%ebp)
    1543:	dd 05 48 6a 01 00    	fldl   0x16a48
    1549:	de c1                	faddp  %st,%st(1)
    154b:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
    154e:	d9 45 08             	flds   0x8(%ebp)
    1551:	dd 05 68 6a 01 00    	fldl   0x16a68
    1557:	d9 c9                	fxch   %st(1)
    1559:	df e9                	fucomip %st(1),%st
    155b:	dd d8                	fstp   %st(0)
    155d:	76 16                	jbe    1575 <cos+0xca>
    {
        x -= PI;
    155f:	d9 45 08             	flds   0x8(%ebp)
    1562:	dd 05 58 6a 01 00    	fldl   0x16a58
    1568:	de e9                	fsubrp %st,%st(1)
    156a:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    156d:	d9 45 f4             	flds   -0xc(%ebp)
    1570:	d9 e0                	fchs   
    1572:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
    1575:	d9 45 08             	flds   0x8(%ebp)
    1578:	dd 05 70 6a 01 00    	fldl   0x16a70
    157e:	df e9                	fucomip %st(1),%st
    1580:	dd d8                	fstp   %st(0)
    1582:	76 16                	jbe    159a <cos+0xef>
    {
        x += PI;
    1584:	d9 45 08             	flds   0x8(%ebp)
    1587:	dd 05 58 6a 01 00    	fldl   0x16a58
    158d:	de c1                	faddp  %st,%st(1)
    158f:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    1592:	d9 45 f4             	flds   -0xc(%ebp)
    1595:	d9 e0                	fchs   
    1597:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
    159a:	d9 45 08             	flds   0x8(%ebp)
    159d:	dd 05 78 6a 01 00    	fldl   0x16a78
    15a3:	d9 c9                	fxch   %st(1)
    15a5:	df e9                	fucomip %st(1),%st
    15a7:	dd d8                	fstp   %st(0)
    15a9:	76 28                	jbe    15d3 <cos+0x128>
    15ab:	d9 45 08             	flds   0x8(%ebp)
    15ae:	dd 05 68 6a 01 00    	fldl   0x16a68
    15b4:	de e1                	fsubp  %st,%st(1)
    15b6:	d9 5d e4             	fstps  -0x1c(%ebp)
    15b9:	d9 45 e4             	flds   -0x1c(%ebp)
    15bc:	83 ec 0c             	sub    $0xc,%esp
    15bf:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    15c3:	d9 1c 24             	fstps  (%esp)
    15c6:	e8 83 00 00 00       	call   164e <sin>
    15cb:	83 c4 10             	add    $0x10,%esp
    15ce:	d8 4d f4             	fmuls  -0xc(%ebp)
    15d1:	eb 79                	jmp    164c <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
    15d3:	83 ec 08             	sub    $0x8,%esp
    15d6:	6a 02                	push   $0x2
    15d8:	ff 75 08             	pushl  0x8(%ebp)
    15db:	e8 1e fe ff ff       	call   13fe <pow>
    15e0:	83 c4 10             	add    $0x10,%esp
    15e3:	d9 05 40 6a 01 00    	flds   0x16a40
    15e9:	de f9                	fdivrp %st,%st(1)
    15eb:	d9 e8                	fld1   
    15ed:	de e1                	fsubp  %st,%st(1)
    15ef:	d9 5d d8             	fstps  -0x28(%ebp)
    15f2:	83 ec 08             	sub    $0x8,%esp
    15f5:	6a 04                	push   $0x4
    15f7:	ff 75 08             	pushl  0x8(%ebp)
    15fa:	e8 ff fd ff ff       	call   13fe <pow>
    15ff:	83 c4 10             	add    $0x10,%esp
    1602:	d9 05 80 6a 01 00    	flds   0x16a80
    1608:	de f9                	fdivrp %st,%st(1)
    160a:	d8 45 d8             	fadds  -0x28(%ebp)
    160d:	d9 5d d8             	fstps  -0x28(%ebp)
    1610:	83 ec 08             	sub    $0x8,%esp
    1613:	6a 06                	push   $0x6
    1615:	ff 75 08             	pushl  0x8(%ebp)
    1618:	e8 e1 fd ff ff       	call   13fe <pow>
    161d:	83 c4 10             	add    $0x10,%esp
    1620:	d9 05 84 6a 01 00    	flds   0x16a84
    1626:	de f9                	fdivrp %st,%st(1)
    1628:	d8 6d d8             	fsubrs -0x28(%ebp)
    162b:	d9 5d d8             	fstps  -0x28(%ebp)
    162e:	83 ec 08             	sub    $0x8,%esp
    1631:	6a 08                	push   $0x8
    1633:	ff 75 08             	pushl  0x8(%ebp)
    1636:	e8 c3 fd ff ff       	call   13fe <pow>
    163b:	83 c4 10             	add    $0x10,%esp
    163e:	d9 05 88 6a 01 00    	flds   0x16a88
    1644:	de f9                	fdivrp %st,%st(1)
    1646:	d8 45 d8             	fadds  -0x28(%ebp)
    1649:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    164c:	c9                   	leave  
    164d:	c3                   	ret    

0000164e <sin>:

float sin(float x)
{
    164e:	55                   	push   %ebp
    164f:	89 e5                	mov    %esp,%ebp
    1651:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
    1654:	d9 e8                	fld1   
    1656:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
    1659:	d9 45 08             	flds   0x8(%ebp)
    165c:	dd 05 48 6a 01 00    	fldl   0x16a48
    1662:	d9 c9                	fxch   %st(1)
    1664:	df e9                	fucomip %st(1),%st
    1666:	dd d8                	fstp   %st(0)
    1668:	77 0f                	ja     1679 <sin+0x2b>
    166a:	d9 45 08             	flds   0x8(%ebp)
    166d:	dd 05 50 6a 01 00    	fldl   0x16a50
    1673:	df e9                	fucomip %st(1),%st
    1675:	dd d8                	fstp   %st(0)
    1677:	76 3c                	jbe    16b5 <sin+0x67>
    1679:	d9 45 08             	flds   0x8(%ebp)
    167c:	d9 45 08             	flds   0x8(%ebp)
    167f:	dd 05 48 6a 01 00    	fldl   0x16a48
    1685:	de f9                	fdivrp %st,%st(1)
    1687:	d9 7d e2             	fnstcw -0x1e(%ebp)
    168a:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
    168e:	b4 0c                	mov    $0xc,%ah
    1690:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    1694:	d9 6d e0             	fldcw  -0x20(%ebp)
    1697:	db 5d dc             	fistpl -0x24(%ebp)
    169a:	d9 6d e2             	fldcw  -0x1e(%ebp)
    169d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    16a0:	01 c0                	add    %eax,%eax
    16a2:	89 45 d8             	mov    %eax,-0x28(%ebp)
    16a5:	db 45 d8             	fildl  -0x28(%ebp)
    16a8:	dd 05 58 6a 01 00    	fldl   0x16a58
    16ae:	de c9                	fmulp  %st,%st(1)
    16b0:	de e9                	fsubrp %st,%st(1)
    16b2:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
    16b5:	d9 45 08             	flds   0x8(%ebp)
    16b8:	dd 05 58 6a 01 00    	fldl   0x16a58
    16be:	d9 c9                	fxch   %st(1)
    16c0:	df e9                	fucomip %st(1),%st
    16c2:	dd d8                	fstp   %st(0)
    16c4:	76 0e                	jbe    16d4 <sin+0x86>
    16c6:	d9 45 08             	flds   0x8(%ebp)
    16c9:	dd 05 48 6a 01 00    	fldl   0x16a48
    16cf:	de e9                	fsubrp %st,%st(1)
    16d1:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
    16d4:	d9 45 08             	flds   0x8(%ebp)
    16d7:	dd 05 60 6a 01 00    	fldl   0x16a60
    16dd:	df e9                	fucomip %st(1),%st
    16df:	dd d8                	fstp   %st(0)
    16e1:	76 0e                	jbe    16f1 <sin+0xa3>
    16e3:	d9 45 08             	flds   0x8(%ebp)
    16e6:	dd 05 48 6a 01 00    	fldl   0x16a48
    16ec:	de c1                	faddp  %st,%st(1)
    16ee:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
    16f1:	d9 45 08             	flds   0x8(%ebp)
    16f4:	dd 05 68 6a 01 00    	fldl   0x16a68
    16fa:	d9 c9                	fxch   %st(1)
    16fc:	df e9                	fucomip %st(1),%st
    16fe:	dd d8                	fstp   %st(0)
    1700:	76 16                	jbe    1718 <sin+0xca>
    {
        x -= PI;
    1702:	d9 45 08             	flds   0x8(%ebp)
    1705:	dd 05 58 6a 01 00    	fldl   0x16a58
    170b:	de e9                	fsubrp %st,%st(1)
    170d:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    1710:	d9 45 f4             	flds   -0xc(%ebp)
    1713:	d9 e0                	fchs   
    1715:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
    1718:	d9 45 08             	flds   0x8(%ebp)
    171b:	dd 05 70 6a 01 00    	fldl   0x16a70
    1721:	df e9                	fucomip %st(1),%st
    1723:	dd d8                	fstp   %st(0)
    1725:	76 16                	jbe    173d <sin+0xef>
    {
        x += PI;
    1727:	d9 45 08             	flds   0x8(%ebp)
    172a:	dd 05 58 6a 01 00    	fldl   0x16a58
    1730:	de c1                	faddp  %st,%st(1)
    1732:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    1735:	d9 45 f4             	flds   -0xc(%ebp)
    1738:	d9 e0                	fchs   
    173a:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
    173d:	d9 ee                	fldz   
    173f:	d9 45 08             	flds   0x8(%ebp)
    1742:	d9 c9                	fxch   %st(1)
    1744:	df e9                	fucomip %st(1),%st
    1746:	dd d8                	fstp   %st(0)
    1748:	76 10                	jbe    175a <sin+0x10c>
    {
        x *= -1;
    174a:	d9 45 08             	flds   0x8(%ebp)
    174d:	d9 e0                	fchs   
    174f:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    1752:	d9 45 f4             	flds   -0xc(%ebp)
    1755:	d9 e0                	fchs   
    1757:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
    175a:	d9 45 08             	flds   0x8(%ebp)
    175d:	dd 05 78 6a 01 00    	fldl   0x16a78
    1763:	d9 c9                	fxch   %st(1)
    1765:	df e9                	fucomip %st(1),%st
    1767:	dd d8                	fstp   %st(0)
    1769:	76 28                	jbe    1793 <sin+0x145>
    176b:	d9 45 08             	flds   0x8(%ebp)
    176e:	dd 05 68 6a 01 00    	fldl   0x16a68
    1774:	de e1                	fsubp  %st,%st(1)
    1776:	d9 5d e4             	fstps  -0x1c(%ebp)
    1779:	d9 45 e4             	flds   -0x1c(%ebp)
    177c:	83 ec 0c             	sub    $0xc,%esp
    177f:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    1783:	d9 1c 24             	fstps  (%esp)
    1786:	e8 20 fd ff ff       	call   14ab <cos>
    178b:	83 c4 10             	add    $0x10,%esp
    178e:	d8 4d f4             	fmuls  -0xc(%ebp)
    1791:	eb 7a                	jmp    180d <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
    1793:	83 ec 08             	sub    $0x8,%esp
    1796:	6a 03                	push   $0x3
    1798:	ff 75 08             	pushl  0x8(%ebp)
    179b:	e8 5e fc ff ff       	call   13fe <pow>
    17a0:	83 c4 10             	add    $0x10,%esp
    17a3:	d9 05 8c 6a 01 00    	flds   0x16a8c
    17a9:	de f9                	fdivrp %st,%st(1)
    17ab:	d9 45 08             	flds   0x8(%ebp)
    17ae:	de e1                	fsubp  %st,%st(1)
    17b0:	d9 5d d8             	fstps  -0x28(%ebp)
    17b3:	83 ec 08             	sub    $0x8,%esp
    17b6:	6a 05                	push   $0x5
    17b8:	ff 75 08             	pushl  0x8(%ebp)
    17bb:	e8 3e fc ff ff       	call   13fe <pow>
    17c0:	83 c4 10             	add    $0x10,%esp
    17c3:	d9 05 90 6a 01 00    	flds   0x16a90
    17c9:	de f9                	fdivrp %st,%st(1)
    17cb:	d8 45 d8             	fadds  -0x28(%ebp)
    17ce:	d9 5d d8             	fstps  -0x28(%ebp)
    17d1:	83 ec 08             	sub    $0x8,%esp
    17d4:	6a 07                	push   $0x7
    17d6:	ff 75 08             	pushl  0x8(%ebp)
    17d9:	e8 20 fc ff ff       	call   13fe <pow>
    17de:	83 c4 10             	add    $0x10,%esp
    17e1:	d9 05 94 6a 01 00    	flds   0x16a94
    17e7:	de f9                	fdivrp %st,%st(1)
    17e9:	d8 6d d8             	fsubrs -0x28(%ebp)
    17ec:	d9 5d d8             	fstps  -0x28(%ebp)
    17ef:	83 ec 08             	sub    $0x8,%esp
    17f2:	6a 09                	push   $0x9
    17f4:	ff 75 08             	pushl  0x8(%ebp)
    17f7:	e8 02 fc ff ff       	call   13fe <pow>
    17fc:	83 c4 10             	add    $0x10,%esp
    17ff:	d9 05 98 6a 01 00    	flds   0x16a98
    1805:	de f9                	fdivrp %st,%st(1)
    1807:	d8 45 d8             	fadds  -0x28(%ebp)
    180a:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    180d:	c9                   	leave  
    180e:	c3                   	ret    

0000180f <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
    180f:	55                   	push   %ebp
    1810:	89 e5                	mov    %esp,%ebp
    1812:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    1815:	83 ec 04             	sub    $0x4,%esp
    1818:	6a 0e                	push   $0xe
    181a:	ff 75 0c             	pushl  0xc(%ebp)
    181d:	ff 75 08             	pushl  0x8(%ebp)
    1820:	e8 44 f6 ff ff       	call   e69 <read>
    1825:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1828:	83 ec 04             	sub    $0x4,%esp
    182b:	6a 28                	push   $0x28
    182d:	ff 75 10             	pushl  0x10(%ebp)
    1830:	ff 75 08             	pushl  0x8(%ebp)
    1833:	e8 31 f6 ff ff       	call   e69 <read>
    1838:	83 c4 10             	add    $0x10,%esp
}
    183b:	90                   	nop
    183c:	c9                   	leave  
    183d:	c3                   	ret    

0000183e <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
    183e:	55                   	push   %ebp
    183f:	89 e5                	mov    %esp,%ebp
    1841:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    1847:	83 ec 08             	sub    $0x8,%esp
    184a:	6a 00                	push   $0x0
    184c:	ff 75 08             	pushl  0x8(%ebp)
    184f:	e8 3d f6 ff ff       	call   e91 <open>
    1854:	83 c4 10             	add    $0x10,%esp
    1857:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    185a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    185e:	79 0a                	jns    186a <readBitmapFile+0x2c>
        return -1;
    1860:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    1865:	e9 6e 01 00 00       	jmp    19d8 <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    186a:	83 ec 04             	sub    $0x4,%esp
    186d:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    1870:	50                   	push   %eax
    1871:	8d 45 ca             	lea    -0x36(%ebp),%eax
    1874:	50                   	push   %eax
    1875:	ff 75 ec             	pushl  -0x14(%ebp)
    1878:	e8 92 ff ff ff       	call   180f <readBitmapHeader>
    187d:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    1880:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    1883:	83 e8 36             	sub    $0x36,%eax
    1886:	83 ec 04             	sub    $0x4,%esp
    1889:	50                   	push   %eax
    188a:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    1890:	50                   	push   %eax
    1891:	ff 75 ec             	pushl  -0x14(%ebp)
    1894:	e8 d0 f5 ff ff       	call   e69 <read>
    1899:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    189c:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    189f:	8b 45 14             	mov    0x14(%ebp),%eax
    18a2:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    18a4:	8b 55 aa             	mov    -0x56(%ebp),%edx
    18a7:	8b 45 10             	mov    0x10(%ebp),%eax
    18aa:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    18ac:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    18af:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    18b2:	8b 45 aa             	mov    -0x56(%ebp),%eax
    18b5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    18b8:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    18bc:	0f b7 c0             	movzwl %ax,%eax
    18bf:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    18c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    18c5:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    18c9:	8d 50 07             	lea    0x7(%eax),%edx
    18cc:	85 c0                	test   %eax,%eax
    18ce:	0f 48 c2             	cmovs  %edx,%eax
    18d1:	c1 f8 03             	sar    $0x3,%eax
    18d4:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    18d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    18da:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    18dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    18e0:	83 e8 01             	sub    $0x1,%eax
    18e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    18e6:	e9 d0 00 00 00       	jmp    19bb <readBitmapFile+0x17d>
        if (bits == 32) {
    18eb:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
    18ef:	75 22                	jne    1913 <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    18f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    18f4:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    18f8:	89 c2                	mov    %eax,%edx
    18fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
    18fd:	01 d0                	add    %edx,%eax
    18ff:	83 ec 04             	sub    $0x4,%esp
    1902:	ff 75 dc             	pushl  -0x24(%ebp)
    1905:	50                   	push   %eax
    1906:	ff 75 ec             	pushl  -0x14(%ebp)
    1909:	e8 5b f5 ff ff       	call   e69 <read>
    190e:	83 c4 10             	add    $0x10,%esp
    1911:	eb 65                	jmp    1978 <readBitmapFile+0x13a>
        } else {
            int j = 0;
    1913:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    191a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1921:	eb 4d                	jmp    1970 <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
    1923:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1926:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    192a:	c1 e0 02             	shl    $0x2,%eax
    192d:	89 c2                	mov    %eax,%edx
    192f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1932:	c1 e0 02             	shl    $0x2,%eax
    1935:	01 c2                	add    %eax,%edx
    1937:	8b 45 d8             	mov    -0x28(%ebp),%eax
    193a:	01 d0                	add    %edx,%eax
    193c:	83 ec 04             	sub    $0x4,%esp
    193f:	6a 03                	push   $0x3
    1941:	50                   	push   %eax
    1942:	ff 75 ec             	pushl  -0x14(%ebp)
    1945:	e8 1f f5 ff ff       	call   e69 <read>
    194a:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
    194d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1950:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    1954:	c1 e0 02             	shl    $0x2,%eax
    1957:	89 c2                	mov    %eax,%edx
    1959:	8b 45 f0             	mov    -0x10(%ebp),%eax
    195c:	c1 e0 02             	shl    $0x2,%eax
    195f:	01 d0                	add    %edx,%eax
    1961:	8d 50 03             	lea    0x3(%eax),%edx
    1964:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1967:	01 d0                	add    %edx,%eax
    1969:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    196c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1970:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1973:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    1976:	7c ab                	jl     1923 <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
    1978:	8b 45 dc             	mov    -0x24(%ebp),%eax
    197b:	99                   	cltd   
    197c:	c1 ea 1e             	shr    $0x1e,%edx
    197f:	01 d0                	add    %edx,%eax
    1981:	83 e0 03             	and    $0x3,%eax
    1984:	29 d0                	sub    %edx,%eax
    1986:	85 c0                	test   %eax,%eax
    1988:	7e 2d                	jle    19b7 <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    198a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    198d:	99                   	cltd   
    198e:	c1 ea 1e             	shr    $0x1e,%edx
    1991:	01 d0                	add    %edx,%eax
    1993:	83 e0 03             	and    $0x3,%eax
    1996:	29 d0                	sub    %edx,%eax
    1998:	ba 04 00 00 00       	mov    $0x4,%edx
    199d:	29 c2                	sub    %eax,%edx
    199f:	89 d0                	mov    %edx,%eax
    19a1:	83 ec 04             	sub    $0x4,%esp
    19a4:	50                   	push   %eax
    19a5:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    19ab:	50                   	push   %eax
    19ac:	ff 75 ec             	pushl  -0x14(%ebp)
    19af:	e8 b5 f4 ff ff       	call   e69 <read>
    19b4:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    19b7:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    19bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    19bf:	0f 89 26 ff ff ff    	jns    18eb <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    19c5:	83 ec 0c             	sub    $0xc,%esp
    19c8:	ff 75 ec             	pushl  -0x14(%ebp)
    19cb:	e8 a9 f4 ff ff       	call   e79 <close>
    19d0:	83 c4 10             	add    $0x10,%esp
    return 0;
    19d3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    19d8:	c9                   	leave  
    19d9:	c3                   	ret    

000019da <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
    19da:	55                   	push   %ebp
    19db:	89 e5                	mov    %esp,%ebp
    19dd:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    19e3:	83 ec 08             	sub    $0x8,%esp
    19e6:	6a 00                	push   $0x0
    19e8:	ff 75 08             	pushl  0x8(%ebp)
    19eb:	e8 a1 f4 ff ff       	call   e91 <open>
    19f0:	83 c4 10             	add    $0x10,%esp
    19f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    19f6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    19fa:	79 0a                	jns    1a06 <read24BitmapFile+0x2c>
        return -1;
    19fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    1a01:	e9 66 01 00 00       	jmp    1b6c <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    1a06:	83 ec 04             	sub    $0x4,%esp
    1a09:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    1a0c:	50                   	push   %eax
    1a0d:	8d 45 ca             	lea    -0x36(%ebp),%eax
    1a10:	50                   	push   %eax
    1a11:	ff 75 ec             	pushl  -0x14(%ebp)
    1a14:	e8 f6 fd ff ff       	call   180f <readBitmapHeader>
    1a19:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    1a1c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    1a1f:	83 e8 36             	sub    $0x36,%eax
    1a22:	83 ec 04             	sub    $0x4,%esp
    1a25:	50                   	push   %eax
    1a26:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    1a2c:	50                   	push   %eax
    1a2d:	ff 75 ec             	pushl  -0x14(%ebp)
    1a30:	e8 34 f4 ff ff       	call   e69 <read>
    1a35:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    1a38:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    1a3b:	8b 45 14             	mov    0x14(%ebp),%eax
    1a3e:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    1a40:	8b 55 aa             	mov    -0x56(%ebp),%edx
    1a43:	8b 45 10             	mov    0x10(%ebp),%eax
    1a46:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    1a48:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    1a4b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    1a4e:	8b 45 aa             	mov    -0x56(%ebp),%eax
    1a51:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    1a54:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    1a58:	0f b7 c0             	movzwl %ax,%eax
    1a5b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
    1a5e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    1a61:	89 d0                	mov    %edx,%eax
    1a63:	01 c0                	add    %eax,%eax
    1a65:	01 d0                	add    %edx,%eax
    1a67:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    1a6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a6d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    1a70:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1a73:	83 e8 01             	sub    $0x1,%eax
    1a76:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1a79:	e9 d1 00 00 00       	jmp    1b4f <read24BitmapFile+0x175>
        if (bits == 24) {
    1a7e:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
    1a82:	75 22                	jne    1aa6 <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    1a84:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1a87:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    1a8b:	89 c2                	mov    %eax,%edx
    1a8d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1a90:	01 d0                	add    %edx,%eax
    1a92:	83 ec 04             	sub    $0x4,%esp
    1a95:	ff 75 dc             	pushl  -0x24(%ebp)
    1a98:	50                   	push   %eax
    1a99:	ff 75 ec             	pushl  -0x14(%ebp)
    1a9c:	e8 c8 f3 ff ff       	call   e69 <read>
    1aa1:	83 c4 10             	add    $0x10,%esp
    1aa4:	eb 66                	jmp    1b0c <read24BitmapFile+0x132>
        } else {
            int j = 0;
    1aa6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    1aad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1ab4:	eb 4e                	jmp    1b04 <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
    1ab6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1ab9:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    1abd:	89 c2                	mov    %eax,%edx
    1abf:	89 d0                	mov    %edx,%eax
    1ac1:	01 c0                	add    %eax,%eax
    1ac3:	01 d0                	add    %edx,%eax
    1ac5:	89 c1                	mov    %eax,%ecx
    1ac7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1aca:	89 d0                	mov    %edx,%eax
    1acc:	01 c0                	add    %eax,%eax
    1ace:	01 d0                	add    %edx,%eax
    1ad0:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    1ad3:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1ad6:	01 d0                	add    %edx,%eax
    1ad8:	83 ec 04             	sub    $0x4,%esp
    1adb:	6a 03                	push   $0x3
    1add:	50                   	push   %eax
    1ade:	ff 75 ec             	pushl  -0x14(%ebp)
    1ae1:	e8 83 f3 ff ff       	call   e69 <read>
    1ae6:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
    1ae9:	83 ec 04             	sub    $0x4,%esp
    1aec:	6a 01                	push   $0x1
    1aee:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    1af4:	50                   	push   %eax
    1af5:	ff 75 ec             	pushl  -0x14(%ebp)
    1af8:	e8 6c f3 ff ff       	call   e69 <read>
    1afd:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    1b00:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1b04:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1b07:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    1b0a:	7c aa                	jl     1ab6 <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    1b0c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1b0f:	99                   	cltd   
    1b10:	c1 ea 1e             	shr    $0x1e,%edx
    1b13:	01 d0                	add    %edx,%eax
    1b15:	83 e0 03             	and    $0x3,%eax
    1b18:	29 d0                	sub    %edx,%eax
    1b1a:	85 c0                	test   %eax,%eax
    1b1c:	7e 2d                	jle    1b4b <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1b1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1b21:	99                   	cltd   
    1b22:	c1 ea 1e             	shr    $0x1e,%edx
    1b25:	01 d0                	add    %edx,%eax
    1b27:	83 e0 03             	and    $0x3,%eax
    1b2a:	29 d0                	sub    %edx,%eax
    1b2c:	ba 04 00 00 00       	mov    $0x4,%edx
    1b31:	29 c2                	sub    %eax,%edx
    1b33:	89 d0                	mov    %edx,%eax
    1b35:	83 ec 04             	sub    $0x4,%esp
    1b38:	50                   	push   %eax
    1b39:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    1b3f:	50                   	push   %eax
    1b40:	ff 75 ec             	pushl  -0x14(%ebp)
    1b43:	e8 21 f3 ff ff       	call   e69 <read>
    1b48:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    1b4b:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1b4f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1b53:	0f 89 25 ff ff ff    	jns    1a7e <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1b59:	83 ec 0c             	sub    $0xc,%esp
    1b5c:	ff 75 ec             	pushl  -0x14(%ebp)
    1b5f:	e8 15 f3 ff ff       	call   e79 <close>
    1b64:	83 c4 10             	add    $0x10,%esp
    return 0;
    1b67:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1b6c:	c9                   	leave  
    1b6d:	c3                   	ret    

00001b6e <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    1b6e:	55                   	push   %ebp
    1b6f:	89 e5                	mov    %esp,%ebp
    1b71:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    1b74:	8b 55 10             	mov    0x10(%ebp),%edx
    1b77:	89 d0                	mov    %edx,%eax
    1b79:	01 c0                	add    %eax,%eax
    1b7b:	01 d0                	add    %edx,%eax
    1b7d:	c1 e0 03             	shl    $0x3,%eax
    1b80:	83 c0 1f             	add    $0x1f,%eax
    1b83:	8d 50 1f             	lea    0x1f(%eax),%edx
    1b86:	85 c0                	test   %eax,%eax
    1b88:	0f 48 c2             	cmovs  %edx,%eax
    1b8b:	c1 f8 05             	sar    $0x5,%eax
    1b8e:	c1 e0 02             	shl    $0x2,%eax
    1b91:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    1b94:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    1b9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1b9d:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1ba1:	83 c0 36             	add    $0x36,%eax
    1ba4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    1ba7:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    1bad:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    1bb3:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    1bba:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    1bc1:	8b 45 10             	mov    0x10(%ebp),%eax
    1bc4:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    1bc7:	8b 45 0c             	mov    0xc(%ebp),%eax
    1bca:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    1bcd:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    1bd3:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    1bd9:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    1be0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1be3:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1be7:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    1bea:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    1bf1:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    1bf8:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    1bff:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    1c06:	83 ec 04             	sub    $0x4,%esp
    1c09:	6a 0e                	push   $0xe
    1c0b:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    1c0e:	50                   	push   %eax
    1c0f:	ff 75 08             	pushl  0x8(%ebp)
    1c12:	e8 5a f2 ff ff       	call   e71 <write>
    1c17:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1c1a:	83 ec 04             	sub    $0x4,%esp
    1c1d:	6a 28                	push   $0x28
    1c1f:	8d 45 be             	lea    -0x42(%ebp),%eax
    1c22:	50                   	push   %eax
    1c23:	ff 75 08             	pushl  0x8(%ebp)
    1c26:	e8 46 f2 ff ff       	call   e71 <write>
    1c2b:	83 c4 10             	add    $0x10,%esp
}
    1c2e:	90                   	nop
    1c2f:	c9                   	leave  
    1c30:	c3                   	ret    

00001c31 <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    1c31:	55                   	push   %ebp
    1c32:	89 e5                	mov    %esp,%ebp
    1c34:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    1c37:	83 ec 08             	sub    $0x8,%esp
    1c3a:	68 02 02 00 00       	push   $0x202
    1c3f:	ff 75 08             	pushl  0x8(%ebp)
    1c42:	e8 4a f2 ff ff       	call   e91 <open>
    1c47:	83 c4 10             	add    $0x10,%esp
    1c4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    1c4d:	8b 55 14             	mov    0x14(%ebp),%edx
    1c50:	89 d0                	mov    %edx,%eax
    1c52:	01 c0                	add    %eax,%eax
    1c54:	01 d0                	add    %edx,%eax
    1c56:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    1c59:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    1c5d:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    1c61:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    1c65:	83 ec 04             	sub    $0x4,%esp
    1c68:	ff 75 14             	pushl  0x14(%ebp)
    1c6b:	ff 75 10             	pushl  0x10(%ebp)
    1c6e:	ff 75 f0             	pushl  -0x10(%ebp)
    1c71:	e8 f8 fe ff ff       	call   1b6e <write24BitmapFileHeader>
    1c76:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    1c79:	8b 45 10             	mov    0x10(%ebp),%eax
    1c7c:	83 e8 01             	sub    $0x1,%eax
    1c7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1c82:	eb 66                	jmp    1cea <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    1c84:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1c87:	0f af 45 14          	imul   0x14(%ebp),%eax
    1c8b:	89 c2                	mov    %eax,%edx
    1c8d:	89 d0                	mov    %edx,%eax
    1c8f:	01 c0                	add    %eax,%eax
    1c91:	01 c2                	add    %eax,%edx
    1c93:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c96:	01 d0                	add    %edx,%eax
    1c98:	83 ec 04             	sub    $0x4,%esp
    1c9b:	ff 75 ec             	pushl  -0x14(%ebp)
    1c9e:	50                   	push   %eax
    1c9f:	ff 75 f0             	pushl  -0x10(%ebp)
    1ca2:	e8 ca f1 ff ff       	call   e71 <write>
    1ca7:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    1caa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1cad:	99                   	cltd   
    1cae:	c1 ea 1e             	shr    $0x1e,%edx
    1cb1:	01 d0                	add    %edx,%eax
    1cb3:	83 e0 03             	and    $0x3,%eax
    1cb6:	29 d0                	sub    %edx,%eax
    1cb8:	85 c0                	test   %eax,%eax
    1cba:	7e 2a                	jle    1ce6 <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1cbc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1cbf:	99                   	cltd   
    1cc0:	c1 ea 1e             	shr    $0x1e,%edx
    1cc3:	01 d0                	add    %edx,%eax
    1cc5:	83 e0 03             	and    $0x3,%eax
    1cc8:	29 d0                	sub    %edx,%eax
    1cca:	ba 04 00 00 00       	mov    $0x4,%edx
    1ccf:	29 c2                	sub    %eax,%edx
    1cd1:	89 d0                	mov    %edx,%eax
    1cd3:	83 ec 04             	sub    $0x4,%esp
    1cd6:	50                   	push   %eax
    1cd7:	8d 45 e9             	lea    -0x17(%ebp),%eax
    1cda:	50                   	push   %eax
    1cdb:	ff 75 f0             	pushl  -0x10(%ebp)
    1cde:	e8 8e f1 ff ff       	call   e71 <write>
    1ce3:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    1ce6:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1cea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1cee:	79 94                	jns    1c84 <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1cf0:	83 ec 0c             	sub    $0xc,%esp
    1cf3:	ff 75 f0             	pushl  -0x10(%ebp)
    1cf6:	e8 7e f1 ff ff       	call   e79 <close>
    1cfb:	83 c4 10             	add    $0x10,%esp
    return 0;
    1cfe:	b8 00 00 00 00       	mov    $0x0,%eax
    1d03:	c9                   	leave  
    1d04:	c3                   	ret    

00001d05 <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    1d05:	55                   	push   %ebp
    1d06:	89 e5                	mov    %esp,%ebp
    1d08:	57                   	push   %edi
    1d09:	56                   	push   %esi
    1d0a:	53                   	push   %ebx
    1d0b:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    1d0e:	8b 45 08             	mov    0x8(%ebp),%eax
    1d11:	8b 50 10             	mov    0x10(%eax),%edx
    1d14:	8b 40 0c             	mov    0xc(%eax),%eax
    1d17:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1d1a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    1d1d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1d20:	8b 55 e0             	mov    -0x20(%ebp),%edx
    1d23:	83 c2 1e             	add    $0x1e,%edx
    1d26:	0f af d0             	imul   %eax,%edx
    1d29:	89 d0                	mov    %edx,%eax
    1d2b:	01 c0                	add    %eax,%eax
    1d2d:	01 d0                	add    %edx,%eax
    1d2f:	83 ec 0c             	sub    $0xc,%esp
    1d32:	50                   	push   %eax
    1d33:	e8 93 f5 ff ff       	call   12cb <malloc>
    1d38:	83 c4 10             	add    $0x10,%esp
    1d3b:	89 c2                	mov    %eax,%edx
    1d3d:	8b 45 08             	mov    0x8(%ebp),%eax
    1d40:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    1d43:	8b 45 08             	mov    0x8(%ebp),%eax
    1d46:	8b 40 1c             	mov    0x1c(%eax),%eax
    1d49:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    1d4c:	6b d2 5a             	imul   $0x5a,%edx,%edx
    1d4f:	01 c2                	add    %eax,%edx
    1d51:	8b 45 08             	mov    0x8(%ebp),%eax
    1d54:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    1d57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    1d5a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    1d5d:	0f af d0             	imul   %eax,%edx
    1d60:	89 d0                	mov    %edx,%eax
    1d62:	01 c0                	add    %eax,%eax
    1d64:	01 d0                	add    %edx,%eax
    1d66:	89 c2                	mov    %eax,%edx
    1d68:	8b 45 08             	mov    0x8(%ebp),%eax
    1d6b:	8b 40 18             	mov    0x18(%eax),%eax
    1d6e:	83 ec 04             	sub    $0x4,%esp
    1d71:	52                   	push   %edx
    1d72:	68 ff 00 00 00       	push   $0xff
    1d77:	50                   	push   %eax
    1d78:	e8 39 ef ff ff       	call   cb6 <memset>
    1d7d:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    1d80:	8b 45 08             	mov    0x8(%ebp),%eax
    1d83:	8b 78 1c             	mov    0x1c(%eax),%edi
    1d86:	8b 45 08             	mov    0x8(%ebp),%eax
    1d89:	8b 70 14             	mov    0x14(%eax),%esi
    1d8c:	8b 45 08             	mov    0x8(%ebp),%eax
    1d8f:	8b 58 0c             	mov    0xc(%eax),%ebx
    1d92:	8b 45 08             	mov    0x8(%ebp),%eax
    1d95:	8b 48 10             	mov    0x10(%eax),%ecx
    1d98:	8b 45 08             	mov    0x8(%ebp),%eax
    1d9b:	8b 50 08             	mov    0x8(%eax),%edx
    1d9e:	8b 45 08             	mov    0x8(%ebp),%eax
    1da1:	8b 40 04             	mov    0x4(%eax),%eax
    1da4:	83 ec 08             	sub    $0x8,%esp
    1da7:	57                   	push   %edi
    1da8:	56                   	push   %esi
    1da9:	53                   	push   %ebx
    1daa:	51                   	push   %ecx
    1dab:	52                   	push   %edx
    1dac:	50                   	push   %eax
    1dad:	e8 3f f1 ff ff       	call   ef1 <createwindow>
    1db2:	83 c4 20             	add    $0x20,%esp
    1db5:	89 c2                	mov    %eax,%edx
    1db7:	8b 45 08             	mov    0x8(%ebp),%eax
    1dba:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    1dbc:	8b 45 08             	mov    0x8(%ebp),%eax
    1dbf:	8b 00                	mov    (%eax),%eax
}
    1dc1:	8d 65 f4             	lea    -0xc(%ebp),%esp
    1dc4:	5b                   	pop    %ebx
    1dc5:	5e                   	pop    %esi
    1dc6:	5f                   	pop    %edi
    1dc7:	5d                   	pop    %ebp
    1dc8:	c3                   	ret    

00001dc9 <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    1dc9:	55                   	push   %ebp
    1dca:	89 e5                	mov    %esp,%ebp
    1dcc:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    1dcf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1dd6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1ddd:	8b 45 08             	mov    0x8(%ebp),%eax
    1de0:	8b 40 18             	mov    0x18(%eax),%eax
    1de3:	ff 75 1c             	pushl  0x1c(%ebp)
    1de6:	ff 75 18             	pushl  0x18(%ebp)
    1de9:	ff 75 1c             	pushl  0x1c(%ebp)
    1dec:	ff 75 18             	pushl  0x18(%ebp)
    1def:	8b 55 08             	mov    0x8(%ebp),%edx
    1df2:	ff 72 10             	pushl  0x10(%edx)
    1df5:	ff 72 0c             	pushl  0xc(%edx)
    1df8:	ff 75 f4             	pushl  -0xc(%ebp)
    1dfb:	ff 75 f0             	pushl  -0x10(%ebp)
    1dfe:	ff 75 14             	pushl  0x14(%ebp)
    1e01:	ff 75 10             	pushl  0x10(%ebp)
    1e04:	ff 75 0c             	pushl  0xc(%ebp)
    1e07:	50                   	push   %eax
    1e08:	e8 d5 07 00 00       	call   25e2 <drawBitmap>
    1e0d:	83 c4 30             	add    $0x30,%esp
    return 0;
    1e10:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1e15:	c9                   	leave  
    1e16:	c3                   	ret    

00001e17 <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    1e17:	55                   	push   %ebp
    1e18:	89 e5                	mov    %esp,%ebp
    1e1a:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1e1d:	8b 45 08             	mov    0x8(%ebp),%eax
    1e20:	8b 40 18             	mov    0x18(%eax),%eax
    1e23:	ff 75 2c             	pushl  0x2c(%ebp)
    1e26:	ff 75 28             	pushl  0x28(%ebp)
    1e29:	ff 75 24             	pushl  0x24(%ebp)
    1e2c:	ff 75 20             	pushl  0x20(%ebp)
    1e2f:	8b 55 08             	mov    0x8(%ebp),%edx
    1e32:	ff 72 10             	pushl  0x10(%edx)
    1e35:	ff 72 0c             	pushl  0xc(%edx)
    1e38:	ff 75 1c             	pushl  0x1c(%ebp)
    1e3b:	ff 75 18             	pushl  0x18(%ebp)
    1e3e:	ff 75 14             	pushl  0x14(%ebp)
    1e41:	ff 75 10             	pushl  0x10(%ebp)
    1e44:	ff 75 0c             	pushl  0xc(%ebp)
    1e47:	50                   	push   %eax
    1e48:	e8 95 07 00 00       	call   25e2 <drawBitmap>
    1e4d:	83 c4 30             	add    $0x30,%esp
    return 0;
    1e50:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1e55:	c9                   	leave  
    1e56:	c3                   	ret    

00001e57 <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    1e57:	55                   	push   %ebp
    1e58:	89 e5                	mov    %esp,%ebp
    1e5a:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1e5d:	8b 45 08             	mov    0x8(%ebp),%eax
    1e60:	8b 40 18             	mov    0x18(%eax),%eax
    1e63:	ff 75 2c             	pushl  0x2c(%ebp)
    1e66:	ff 75 28             	pushl  0x28(%ebp)
    1e69:	ff 75 24             	pushl  0x24(%ebp)
    1e6c:	ff 75 20             	pushl  0x20(%ebp)
    1e6f:	8b 55 08             	mov    0x8(%ebp),%edx
    1e72:	ff 72 10             	pushl  0x10(%edx)
    1e75:	ff 72 0c             	pushl  0xc(%edx)
    1e78:	ff 75 1c             	pushl  0x1c(%ebp)
    1e7b:	ff 75 18             	pushl  0x18(%ebp)
    1e7e:	ff 75 14             	pushl  0x14(%ebp)
    1e81:	ff 75 10             	pushl  0x10(%ebp)
    1e84:	ff 75 0c             	pushl  0xc(%ebp)
    1e87:	50                   	push   %eax
    1e88:	e8 75 08 00 00       	call   2702 <drawTransparentBitmap>
    1e8d:	83 c4 30             	add    $0x30,%esp
    return 0;
    1e90:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1e95:	c9                   	leave  
    1e96:	c3                   	ret    

00001e97 <api_repaint>:

int api_repaint(Window* wnd)
{
    1e97:	55                   	push   %ebp
    1e98:	89 e5                	mov    %esp,%ebp
    1e9a:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    1e9d:	8b 45 08             	mov    0x8(%ebp),%eax
    1ea0:	8b 00                	mov    (%eax),%eax
    1ea2:	83 ec 0c             	sub    $0xc,%esp
    1ea5:	50                   	push   %eax
    1ea6:	e8 4e f0 ff ff       	call   ef9 <repaintwindow>
    1eab:	83 c4 10             	add    $0x10,%esp
    return 0;
    1eae:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1eb3:	c9                   	leave  
    1eb4:	c3                   	ret    

00001eb5 <api_update>:

int api_update(Window* wnd, Rect rect)
{
    1eb5:	55                   	push   %ebp
    1eb6:	89 e5                	mov    %esp,%ebp
    1eb8:	56                   	push   %esi
    1eb9:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    1eba:	8b 75 18             	mov    0x18(%ebp),%esi
    1ebd:	8b 5d 14             	mov    0x14(%ebp),%ebx
    1ec0:	8b 4d 10             	mov    0x10(%ebp),%ecx
    1ec3:	8b 55 0c             	mov    0xc(%ebp),%edx
    1ec6:	8b 45 08             	mov    0x8(%ebp),%eax
    1ec9:	8b 00                	mov    (%eax),%eax
    1ecb:	83 ec 0c             	sub    $0xc,%esp
    1ece:	56                   	push   %esi
    1ecf:	53                   	push   %ebx
    1ed0:	51                   	push   %ecx
    1ed1:	52                   	push   %edx
    1ed2:	50                   	push   %eax
    1ed3:	e8 39 f0 ff ff       	call   f11 <updatewindow>
    1ed8:	83 c4 20             	add    $0x20,%esp
    return 0;
    1edb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1ee0:	8d 65 f8             	lea    -0x8(%ebp),%esp
    1ee3:	5b                   	pop    %ebx
    1ee4:	5e                   	pop    %esi
    1ee5:	5d                   	pop    %ebp
    1ee6:	c3                   	ret    

00001ee7 <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    1ee7:	55                   	push   %ebp
    1ee8:	89 e5                	mov    %esp,%ebp
    1eea:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    1eed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    1ef4:	8b 45 08             	mov    0x8(%ebp),%eax
    1ef7:	8b 00                	mov    (%eax),%eax
    1ef9:	83 ec 08             	sub    $0x8,%esp
    1efc:	8d 55 c8             	lea    -0x38(%ebp),%edx
    1eff:	52                   	push   %edx
    1f00:	50                   	push   %eax
    1f01:	e8 fb ef ff ff       	call   f01 <getmessage>
    1f06:	83 c4 10             	add    $0x10,%esp
    1f09:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    1f0c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1f10:	74 e2                	je     1ef4 <api_exec+0xd>
        {
            pf(&msg);
    1f12:	83 ec 0c             	sub    $0xc,%esp
    1f15:	8d 45 c8             	lea    -0x38(%ebp),%eax
    1f18:	50                   	push   %eax
    1f19:	8b 45 0c             	mov    0xc(%ebp),%eax
    1f1c:	ff d0                	call   *%eax
    1f1e:	83 c4 10             	add    $0x10,%esp
        }
    }
    1f21:	eb d1                	jmp    1ef4 <api_exec+0xd>

00001f23 <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    1f23:	55                   	push   %ebp
    1f24:	89 e5                	mov    %esp,%ebp
    1f26:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    1f29:	8b 45 08             	mov    0x8(%ebp),%eax
    1f2c:	8b 00                	mov    (%eax),%eax
    1f2e:	83 ec 08             	sub    $0x8,%esp
    1f31:	ff 75 0c             	pushl  0xc(%ebp)
    1f34:	50                   	push   %eax
    1f35:	e8 cf ef ff ff       	call   f09 <settimer>
    1f3a:	83 c4 10             	add    $0x10,%esp
    return 0;
    1f3d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1f42:	c9                   	leave  
    1f43:	c3                   	ret    

00001f44 <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    1f44:	55                   	push   %ebp
    1f45:	89 e5                	mov    %esp,%ebp
    1f47:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    1f4a:	8b 45 08             	mov    0x8(%ebp),%eax
    1f4d:	8b 50 18             	mov    0x18(%eax),%edx
    1f50:	ff 75 18             	pushl  0x18(%ebp)
    1f53:	ff 75 14             	pushl  0x14(%ebp)
    1f56:	83 ec 04             	sub    $0x4,%esp
    1f59:	89 e0                	mov    %esp,%eax
    1f5b:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    1f5f:	66 89 08             	mov    %cx,(%eax)
    1f62:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    1f66:	88 48 02             	mov    %cl,0x2(%eax)
    1f69:	8b 45 08             	mov    0x8(%ebp),%eax
    1f6c:	ff 70 10             	pushl  0x10(%eax)
    1f6f:	ff 70 0c             	pushl  0xc(%eax)
    1f72:	ff 75 10             	pushl  0x10(%ebp)
    1f75:	ff 75 0c             	pushl  0xc(%ebp)
    1f78:	52                   	push   %edx
    1f79:	e8 6f 04 00 00       	call   23ed <drawRect>
    1f7e:	83 c4 20             	add    $0x20,%esp
    return 0;
    1f81:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1f86:	c9                   	leave  
    1f87:	c3                   	ret    

00001f88 <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    1f88:	55                   	push   %ebp
    1f89:	89 e5                	mov    %esp,%ebp
    1f8b:	83 ec 28             	sub    $0x28,%esp
    1f8e:	8b 45 14             	mov    0x14(%ebp),%eax
    1f91:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    1f94:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    1f98:	8b 45 0c             	mov    0xc(%ebp),%eax
    1f9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1f9e:	8b 45 10             	mov    0x10(%ebp),%eax
    1fa1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1fa4:	8b 45 08             	mov    0x8(%ebp),%eax
    1fa7:	8b 40 18             	mov    0x18(%eax),%eax
    1faa:	83 ec 04             	sub    $0x4,%esp
    1fad:	ff 75 18             	pushl  0x18(%ebp)
    1fb0:	52                   	push   %edx
    1fb1:	8b 55 08             	mov    0x8(%ebp),%edx
    1fb4:	ff 72 10             	pushl  0x10(%edx)
    1fb7:	ff 72 0c             	pushl  0xc(%edx)
    1fba:	ff 75 f4             	pushl  -0xc(%ebp)
    1fbd:	ff 75 f0             	pushl  -0x10(%ebp)
    1fc0:	50                   	push   %eax
    1fc1:	e8 d4 02 00 00       	call   229a <drawCharacter>
    1fc6:	83 c4 20             	add    $0x20,%esp
    return 0;
    1fc9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1fce:	c9                   	leave  
    1fcf:	c3                   	ret    

00001fd0 <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    1fd0:	55                   	push   %ebp
    1fd1:	89 e5                	mov    %esp,%ebp
    1fd3:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    1fd6:	8b 45 0c             	mov    0xc(%ebp),%eax
    1fd9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1fdc:	8b 45 10             	mov    0x10(%ebp),%eax
    1fdf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1fe2:	8b 45 08             	mov    0x8(%ebp),%eax
    1fe5:	8b 40 18             	mov    0x18(%eax),%eax
    1fe8:	83 ec 04             	sub    $0x4,%esp
    1feb:	ff 75 18             	pushl  0x18(%ebp)
    1fee:	ff 75 14             	pushl  0x14(%ebp)
    1ff1:	8b 55 08             	mov    0x8(%ebp),%edx
    1ff4:	ff 72 10             	pushl  0x10(%edx)
    1ff7:	ff 72 0c             	pushl  0xc(%edx)
    1ffa:	ff 75 f4             	pushl  -0xc(%ebp)
    1ffd:	ff 75 f0             	pushl  -0x10(%ebp)
    2000:	50                   	push   %eax
    2001:	e8 8e 03 00 00       	call   2394 <drawString>
    2006:	83 c4 20             	add    $0x20,%esp
    return 0;
    2009:	b8 00 00 00 00       	mov    $0x0,%eax
}
    200e:	c9                   	leave  
    200f:	c3                   	ret    

00002010 <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    2010:	55                   	push   %ebp
    2011:	89 e5                	mov    %esp,%ebp
    2013:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    2016:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    201a:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    201e:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    2022:	83 ec 08             	sub    $0x8,%esp
    2025:	83 ec 04             	sub    $0x4,%esp
    2028:	89 e0                	mov    %esp,%eax
    202a:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    202e:	66 89 10             	mov    %dx,(%eax)
    2031:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    2035:	88 50 02             	mov    %dl,0x2(%eax)
    2038:	ff 75 18             	pushl  0x18(%ebp)
    203b:	ff 75 14             	pushl  0x14(%ebp)
    203e:	ff 75 10             	pushl  0x10(%ebp)
    2041:	ff 75 0c             	pushl  0xc(%ebp)
    2044:	ff 75 08             	pushl  0x8(%ebp)
    2047:	e8 f8 fe ff ff       	call   1f44 <api_drawRect>
    204c:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    204f:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    2053:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    2057:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    205b:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    205f:	8b 45 10             	mov    0x10(%ebp),%eax
    2062:	8d 50 0a             	lea    0xa(%eax),%edx
    2065:	8b 45 0c             	mov    0xc(%ebp),%eax
    2068:	83 c0 0a             	add    $0xa,%eax
    206b:	83 ec 0c             	sub    $0xc,%esp
    206e:	ff 75 f4             	pushl  -0xc(%ebp)
    2071:	ff 75 1c             	pushl  0x1c(%ebp)
    2074:	52                   	push   %edx
    2075:	50                   	push   %eax
    2076:	ff 75 08             	pushl  0x8(%ebp)
    2079:	e8 52 ff ff ff       	call   1fd0 <api_drawString>
    207e:	83 c4 20             	add    $0x20,%esp
    return 0;
    2081:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2086:	c9                   	leave  
    2087:	c3                   	ret    

00002088 <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    2088:	55                   	push   %ebp
    2089:	89 e5                	mov    %esp,%ebp
    208b:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    208e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2095:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    209c:	8b 45 08             	mov    0x8(%ebp),%eax
    209f:	8b 40 18             	mov    0x18(%eax),%eax
    20a2:	ff 75 1c             	pushl  0x1c(%ebp)
    20a5:	ff 75 18             	pushl  0x18(%ebp)
    20a8:	ff 75 1c             	pushl  0x1c(%ebp)
    20ab:	ff 75 18             	pushl  0x18(%ebp)
    20ae:	8b 55 08             	mov    0x8(%ebp),%edx
    20b1:	ff 72 10             	pushl  0x10(%edx)
    20b4:	ff 72 0c             	pushl  0xc(%edx)
    20b7:	ff 75 f4             	pushl  -0xc(%ebp)
    20ba:	ff 75 f0             	pushl  -0x10(%ebp)
    20bd:	ff 75 14             	pushl  0x14(%ebp)
    20c0:	ff 75 10             	pushl  0x10(%ebp)
    20c3:	ff 75 0c             	pushl  0xc(%ebp)
    20c6:	50                   	push   %eax
    20c7:	e8 16 05 00 00       	call   25e2 <drawBitmap>
    20cc:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    20cf:	8b 45 08             	mov    0x8(%ebp),%eax
    20d2:	8b 40 18             	mov    0x18(%eax),%eax
    20d5:	ff 75 28             	pushl  0x28(%ebp)
    20d8:	ff 75 1c             	pushl  0x1c(%ebp)
    20db:	ff 75 18             	pushl  0x18(%ebp)
    20de:	8b 55 08             	mov    0x8(%ebp),%edx
    20e1:	ff 72 10             	pushl  0x10(%edx)
    20e4:	ff 72 0c             	pushl  0xc(%edx)
    20e7:	ff 75 14             	pushl  0x14(%ebp)
    20ea:	ff 75 10             	pushl  0x10(%ebp)
    20ed:	50                   	push   %eax
    20ee:	e8 99 07 00 00       	call   288c <colorShift>
    20f3:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    20f6:	8b 45 08             	mov    0x8(%ebp),%eax
    20f9:	8b 50 18             	mov    0x18(%eax),%edx
    20fc:	83 ec 0c             	sub    $0xc,%esp
    20ff:	ff 75 20             	pushl  0x20(%ebp)
    2102:	ff 75 1c             	pushl  0x1c(%ebp)
    2105:	ff 75 18             	pushl  0x18(%ebp)
    2108:	83 ec 04             	sub    $0x4,%esp
    210b:	89 e0                	mov    %esp,%eax
    210d:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    2111:	66 89 08             	mov    %cx,(%eax)
    2114:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    2118:	88 48 02             	mov    %cl,0x2(%eax)
    211b:	8b 45 08             	mov    0x8(%ebp),%eax
    211e:	ff 70 10             	pushl  0x10(%eax)
    2121:	ff 70 0c             	pushl  0xc(%eax)
    2124:	ff 75 14             	pushl  0x14(%ebp)
    2127:	ff 75 10             	pushl  0x10(%ebp)
    212a:	52                   	push   %edx
    212b:	e8 6d 03 00 00       	call   249d <drawBorder>
    2130:	83 c4 30             	add    $0x30,%esp
    return 0;
    2133:	b8 00 00 00 00       	mov    $0x0,%eax
}
    2138:	c9                   	leave  
    2139:	c3                   	ret    

0000213a <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    213a:	55                   	push   %ebp
    213b:	89 e5                	mov    %esp,%ebp
    213d:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    2140:	8b 45 08             	mov    0x8(%ebp),%eax
    2143:	8b 00                	mov    (%eax),%eax
    2145:	83 ec 0c             	sub    $0xc,%esp
    2148:	50                   	push   %eax
    2149:	e8 cb ed ff ff       	call   f19 <destroywindow>
    214e:	83 c4 10             	add    $0x10,%esp
    return 0;
    2151:	b8 00 00 00 00       	mov    $0x0,%eax
    2156:	c9                   	leave  
    2157:	c3                   	ret    

00002158 <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    2158:	55                   	push   %ebp
    2159:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    215b:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    215f:	8b 45 08             	mov    0x8(%ebp),%eax
    2162:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    2165:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    2169:	8b 45 08             	mov    0x8(%ebp),%eax
    216c:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    216f:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    2173:	8b 45 08             	mov    0x8(%ebp),%eax
    2176:	88 10                	mov    %dl,(%eax)
}
    2178:	90                   	nop
    2179:	5d                   	pop    %ebp
    217a:	c3                   	ret    

0000217b <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    217b:	55                   	push   %ebp
    217c:	89 e5                	mov    %esp,%ebp
    217e:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    2181:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    2185:	3c ff                	cmp    $0xff,%al
    2187:	75 22                	jne    21ab <drawPointAlpha+0x30>
        color->R = origin.R;
    2189:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    218d:	8b 45 08             	mov    0x8(%ebp),%eax
    2190:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    2193:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    2197:	8b 45 08             	mov    0x8(%ebp),%eax
    219a:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    219d:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    21a1:	8b 45 08             	mov    0x8(%ebp),%eax
    21a4:	88 10                	mov    %dl,(%eax)
        return;
    21a6:	e9 ed 00 00 00       	jmp    2298 <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    21ab:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    21af:	84 c0                	test   %al,%al
    21b1:	0f 84 e0 00 00 00    	je     2297 <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    21b7:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    21bb:	0f b6 c0             	movzbl %al,%eax
    21be:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    21c2:	df 45 e4             	fild   -0x1c(%ebp)
    21c5:	d9 05 e0 a8 01 00    	flds   0x1a8e0
    21cb:	de f9                	fdivrp %st,%st(1)
    21cd:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    21d0:	8b 45 08             	mov    0x8(%ebp),%eax
    21d3:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    21d7:	0f b6 c0             	movzbl %al,%eax
    21da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    21dd:	db 45 e4             	fildl  -0x1c(%ebp)
    21e0:	d9 e8                	fld1   
    21e2:	d8 65 fc             	fsubs  -0x4(%ebp)
    21e5:	de c9                	fmulp  %st,%st(1)
    21e7:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    21eb:	0f b6 c0             	movzbl %al,%eax
    21ee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    21f1:	db 45 e4             	fildl  -0x1c(%ebp)
    21f4:	d8 4d fc             	fmuls  -0x4(%ebp)
    21f7:	de c1                	faddp  %st,%st(1)
    21f9:	d9 7d ee             	fnstcw -0x12(%ebp)
    21fc:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    2200:	b4 0c                	mov    $0xc,%ah
    2202:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    2206:	d9 6d ec             	fldcw  -0x14(%ebp)
    2209:	df 5d ea             	fistp  -0x16(%ebp)
    220c:	d9 6d ee             	fldcw  -0x12(%ebp)
    220f:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    2213:	89 c2                	mov    %eax,%edx
    2215:	8b 45 08             	mov    0x8(%ebp),%eax
    2218:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    221b:	8b 45 08             	mov    0x8(%ebp),%eax
    221e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2222:	0f b6 c0             	movzbl %al,%eax
    2225:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2228:	db 45 e4             	fildl  -0x1c(%ebp)
    222b:	d9 e8                	fld1   
    222d:	d8 65 fc             	fsubs  -0x4(%ebp)
    2230:	de c9                	fmulp  %st,%st(1)
    2232:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    2236:	0f b6 c0             	movzbl %al,%eax
    2239:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    223c:	db 45 e4             	fildl  -0x1c(%ebp)
    223f:	d8 4d fc             	fmuls  -0x4(%ebp)
    2242:	de c1                	faddp  %st,%st(1)
    2244:	d9 6d ec             	fldcw  -0x14(%ebp)
    2247:	df 5d ea             	fistp  -0x16(%ebp)
    224a:	d9 6d ee             	fldcw  -0x12(%ebp)
    224d:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    2251:	89 c2                	mov    %eax,%edx
    2253:	8b 45 08             	mov    0x8(%ebp),%eax
    2256:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    2259:	8b 45 08             	mov    0x8(%ebp),%eax
    225c:	0f b6 00             	movzbl (%eax),%eax
    225f:	0f b6 c0             	movzbl %al,%eax
    2262:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2265:	db 45 e4             	fildl  -0x1c(%ebp)
    2268:	d9 e8                	fld1   
    226a:	d8 65 fc             	fsubs  -0x4(%ebp)
    226d:	de c9                	fmulp  %st,%st(1)
    226f:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    2273:	0f b6 c0             	movzbl %al,%eax
    2276:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2279:	db 45 e4             	fildl  -0x1c(%ebp)
    227c:	d8 4d fc             	fmuls  -0x4(%ebp)
    227f:	de c1                	faddp  %st,%st(1)
    2281:	d9 6d ec             	fldcw  -0x14(%ebp)
    2284:	df 5d ea             	fistp  -0x16(%ebp)
    2287:	d9 6d ee             	fldcw  -0x12(%ebp)
    228a:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    228e:	89 c2                	mov    %eax,%edx
    2290:	8b 45 08             	mov    0x8(%ebp),%eax
    2293:	88 10                	mov    %dl,(%eax)
    2295:	eb 01                	jmp    2298 <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    2297:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    2298:	c9                   	leave  
    2299:	c3                   	ret    

0000229a <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    229a:	55                   	push   %ebp
    229b:	89 e5                	mov    %esp,%ebp
    229d:	83 ec 14             	sub    $0x14,%esp
    22a0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    22a3:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    22a6:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    22aa:	83 e8 20             	sub    $0x20,%eax
    22ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    22b0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    22b4:	0f 88 d7 00 00 00    	js     2391 <drawCharacter+0xf7>
    22ba:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    22be:	0f 8f cd 00 00 00    	jg     2391 <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    22c4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    22cb:	e9 b5 00 00 00       	jmp    2385 <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    22d0:	8b 55 10             	mov    0x10(%ebp),%edx
    22d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    22d6:	01 c2                	add    %eax,%edx
    22d8:	8b 45 14             	mov    0x14(%ebp),%eax
    22db:	39 c2                	cmp    %eax,%edx
    22dd:	0f 8f af 00 00 00    	jg     2392 <drawCharacter+0xf8>
    22e3:	8b 55 10             	mov    0x10(%ebp),%edx
    22e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    22e9:	01 d0                	add    %edx,%eax
    22eb:	85 c0                	test   %eax,%eax
    22ed:	0f 88 9f 00 00 00    	js     2392 <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    22f3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    22fa:	eb 7b                	jmp    2377 <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    22fc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    22ff:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    2302:	89 d0                	mov    %edx,%eax
    2304:	c1 e0 03             	shl    $0x3,%eax
    2307:	01 d0                	add    %edx,%eax
    2309:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    230f:	01 c2                	add    %eax,%edx
    2311:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2314:	01 d0                	add    %edx,%eax
    2316:	05 c0 6c 01 00       	add    $0x16cc0,%eax
    231b:	0f b6 00             	movzbl (%eax),%eax
    231e:	3c 01                	cmp    $0x1,%al
    2320:	75 51                	jne    2373 <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    2322:	8b 55 0c             	mov    0xc(%ebp),%edx
    2325:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2328:	01 c2                	add    %eax,%edx
    232a:	8b 45 18             	mov    0x18(%ebp),%eax
    232d:	39 c2                	cmp    %eax,%edx
    232f:	7f 50                	jg     2381 <drawCharacter+0xe7>
    2331:	8b 55 0c             	mov    0xc(%ebp),%edx
    2334:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2337:	01 d0                	add    %edx,%eax
    2339:	85 c0                	test   %eax,%eax
    233b:	78 44                	js     2381 <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    233d:	8b 55 10             	mov    0x10(%ebp),%edx
    2340:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2343:	01 c2                	add    %eax,%edx
    2345:	8b 45 18             	mov    0x18(%ebp),%eax
    2348:	0f af c2             	imul   %edx,%eax
    234b:	89 c2                	mov    %eax,%edx
    234d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2350:	01 c2                	add    %eax,%edx
    2352:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2355:	01 c2                	add    %eax,%edx
    2357:	89 d0                	mov    %edx,%eax
    2359:	01 c0                	add    %eax,%eax
    235b:	01 c2                	add    %eax,%edx
    235d:	8b 45 08             	mov    0x8(%ebp),%eax
    2360:	01 d0                	add    %edx,%eax
    2362:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    2365:	ff 75 20             	pushl  0x20(%ebp)
    2368:	ff 75 f0             	pushl  -0x10(%ebp)
    236b:	e8 0b fe ff ff       	call   217b <drawPointAlpha>
    2370:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    2373:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2377:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    237b:	0f 8e 7b ff ff ff    	jle    22fc <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    2381:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2385:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    2389:	0f 8e 41 ff ff ff    	jle    22d0 <drawCharacter+0x36>
    238f:	eb 01                	jmp    2392 <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    2391:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    2392:	c9                   	leave  
    2393:	c3                   	ret    

00002394 <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    2394:	55                   	push   %ebp
    2395:	89 e5                	mov    %esp,%ebp
    2397:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    239a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    23a1:	eb 3d                	jmp    23e0 <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    23a3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    23a6:	0f b6 00             	movzbl (%eax),%eax
    23a9:	0f be c0             	movsbl %al,%eax
    23ac:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    23af:	8b 55 fc             	mov    -0x4(%ebp),%edx
    23b2:	01 ca                	add    %ecx,%edx
    23b4:	89 55 f4             	mov    %edx,-0xc(%ebp)
    23b7:	8b 55 10             	mov    0x10(%ebp),%edx
    23ba:	89 55 f8             	mov    %edx,-0x8(%ebp)
    23bd:	ff 75 20             	pushl  0x20(%ebp)
    23c0:	50                   	push   %eax
    23c1:	ff 75 18             	pushl  0x18(%ebp)
    23c4:	ff 75 14             	pushl  0x14(%ebp)
    23c7:	ff 75 f8             	pushl  -0x8(%ebp)
    23ca:	ff 75 f4             	pushl  -0xc(%ebp)
    23cd:	ff 75 08             	pushl  0x8(%ebp)
    23d0:	e8 c5 fe ff ff       	call   229a <drawCharacter>
    23d5:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    23d8:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    23dc:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    23e0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    23e3:	0f b6 00             	movzbl (%eax),%eax
    23e6:	84 c0                	test   %al,%al
    23e8:	75 b9                	jne    23a3 <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    23ea:	90                   	nop
    23eb:	c9                   	leave  
    23ec:	c3                   	ret    

000023ed <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    23ed:	55                   	push   %ebp
    23ee:	89 e5                	mov    %esp,%ebp
    23f0:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    23f3:	8b 45 20             	mov    0x20(%ebp),%eax
    23f6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    23f9:	8b 45 24             	mov    0x24(%ebp),%eax
    23fc:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    23ff:	8b 55 14             	mov    0x14(%ebp),%edx
    2402:	8b 45 10             	mov    0x10(%ebp),%eax
    2405:	29 c2                	sub    %eax,%edx
    2407:	89 d0                	mov    %edx,%eax
    2409:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    240c:	7d 0d                	jge    241b <drawRect+0x2e>
        draw_h = s.h - p.y;
    240e:	8b 55 14             	mov    0x14(%ebp),%edx
    2411:	8b 45 10             	mov    0x10(%ebp),%eax
    2414:	29 c2                	sub    %eax,%edx
    2416:	89 d0                	mov    %edx,%eax
    2418:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    241b:	8b 55 18             	mov    0x18(%ebp),%edx
    241e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2421:	29 c2                	sub    %eax,%edx
    2423:	89 d0                	mov    %edx,%eax
    2425:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2428:	7d 0d                	jge    2437 <drawRect+0x4a>
        draw_w = s.w - p.x;
    242a:	8b 55 18             	mov    0x18(%ebp),%edx
    242d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2430:	29 c2                	sub    %eax,%edx
    2432:	89 d0                	mov    %edx,%eax
    2434:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    2437:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    243e:	eb 52                	jmp    2492 <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    2440:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2447:	eb 3d                	jmp    2486 <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    2449:	8b 55 10             	mov    0x10(%ebp),%edx
    244c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    244f:	01 c2                	add    %eax,%edx
    2451:	8b 45 18             	mov    0x18(%ebp),%eax
    2454:	0f af c2             	imul   %edx,%eax
    2457:	89 c2                	mov    %eax,%edx
    2459:	8b 45 0c             	mov    0xc(%ebp),%eax
    245c:	01 c2                	add    %eax,%edx
    245e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2461:	01 c2                	add    %eax,%edx
    2463:	89 d0                	mov    %edx,%eax
    2465:	01 c0                	add    %eax,%eax
    2467:	01 c2                	add    %eax,%edx
    2469:	8b 45 08             	mov    0x8(%ebp),%eax
    246c:	01 d0                	add    %edx,%eax
    246e:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    2471:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2474:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    2478:	66 89 10             	mov    %dx,(%eax)
    247b:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    247f:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    2482:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2486:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2489:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    248c:	7c bb                	jl     2449 <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    248e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2492:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2495:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2498:	7c a6                	jl     2440 <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    249a:	90                   	nop
    249b:	c9                   	leave  
    249c:	c3                   	ret    

0000249d <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    249d:	55                   	push   %ebp
    249e:	89 e5                	mov    %esp,%ebp
    24a0:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    24a3:	8b 45 28             	mov    0x28(%ebp),%eax
    24a6:	89 45 c8             	mov    %eax,-0x38(%ebp)
    24a9:	8b 45 24             	mov    0x24(%ebp),%eax
    24ac:	89 45 cc             	mov    %eax,-0x34(%ebp)
    24af:	ff 75 cc             	pushl  -0x34(%ebp)
    24b2:	ff 75 c8             	pushl  -0x38(%ebp)
    24b5:	83 ec 04             	sub    $0x4,%esp
    24b8:	89 e0                	mov    %esp,%eax
    24ba:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    24be:	66 89 10             	mov    %dx,(%eax)
    24c1:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    24c5:	88 50 02             	mov    %dl,0x2(%eax)
    24c8:	ff 75 18             	pushl  0x18(%ebp)
    24cb:	ff 75 14             	pushl  0x14(%ebp)
    24ce:	ff 75 10             	pushl  0x10(%ebp)
    24d1:	ff 75 0c             	pushl  0xc(%ebp)
    24d4:	ff 75 08             	pushl  0x8(%ebp)
    24d7:	e8 11 ff ff ff       	call   23ed <drawRect>
    24dc:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    24df:	8b 45 28             	mov    0x28(%ebp),%eax
    24e2:	89 45 d0             	mov    %eax,-0x30(%ebp)
    24e5:	8b 45 24             	mov    0x24(%ebp),%eax
    24e8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    24eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    24ee:	89 45 d8             	mov    %eax,-0x28(%ebp)
    24f1:	8b 55 10             	mov    0x10(%ebp),%edx
    24f4:	8b 45 20             	mov    0x20(%ebp),%eax
    24f7:	01 d0                	add    %edx,%eax
    24f9:	2b 45 28             	sub    0x28(%ebp),%eax
    24fc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    24ff:	ff 75 d4             	pushl  -0x2c(%ebp)
    2502:	ff 75 d0             	pushl  -0x30(%ebp)
    2505:	83 ec 04             	sub    $0x4,%esp
    2508:	89 e0                	mov    %esp,%eax
    250a:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    250e:	66 89 10             	mov    %dx,(%eax)
    2511:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    2515:	88 50 02             	mov    %dl,0x2(%eax)
    2518:	ff 75 18             	pushl  0x18(%ebp)
    251b:	ff 75 14             	pushl  0x14(%ebp)
    251e:	ff 75 dc             	pushl  -0x24(%ebp)
    2521:	ff 75 d8             	pushl  -0x28(%ebp)
    2524:	ff 75 08             	pushl  0x8(%ebp)
    2527:	e8 c1 fe ff ff       	call   23ed <drawRect>
    252c:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    252f:	8b 45 20             	mov    0x20(%ebp),%eax
    2532:	8b 55 28             	mov    0x28(%ebp),%edx
    2535:	01 d2                	add    %edx,%edx
    2537:	29 d0                	sub    %edx,%eax
    2539:	89 45 e0             	mov    %eax,-0x20(%ebp)
    253c:	8b 45 28             	mov    0x28(%ebp),%eax
    253f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2542:	8b 45 0c             	mov    0xc(%ebp),%eax
    2545:	89 45 e8             	mov    %eax,-0x18(%ebp)
    2548:	8b 55 10             	mov    0x10(%ebp),%edx
    254b:	8b 45 28             	mov    0x28(%ebp),%eax
    254e:	01 d0                	add    %edx,%eax
    2550:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2553:	ff 75 e4             	pushl  -0x1c(%ebp)
    2556:	ff 75 e0             	pushl  -0x20(%ebp)
    2559:	83 ec 04             	sub    $0x4,%esp
    255c:	89 e0                	mov    %esp,%eax
    255e:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    2562:	66 89 10             	mov    %dx,(%eax)
    2565:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    2569:	88 50 02             	mov    %dl,0x2(%eax)
    256c:	ff 75 18             	pushl  0x18(%ebp)
    256f:	ff 75 14             	pushl  0x14(%ebp)
    2572:	ff 75 ec             	pushl  -0x14(%ebp)
    2575:	ff 75 e8             	pushl  -0x18(%ebp)
    2578:	ff 75 08             	pushl  0x8(%ebp)
    257b:	e8 6d fe ff ff       	call   23ed <drawRect>
    2580:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    2583:	8b 45 20             	mov    0x20(%ebp),%eax
    2586:	8b 55 28             	mov    0x28(%ebp),%edx
    2589:	01 d2                	add    %edx,%edx
    258b:	29 d0                	sub    %edx,%eax
    258d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    2590:	8b 45 28             	mov    0x28(%ebp),%eax
    2593:	89 45 f4             	mov    %eax,-0xc(%ebp)
    2596:	8b 55 0c             	mov    0xc(%ebp),%edx
    2599:	8b 45 24             	mov    0x24(%ebp),%eax
    259c:	01 d0                	add    %edx,%eax
    259e:	2b 45 28             	sub    0x28(%ebp),%eax
    25a1:	89 45 f8             	mov    %eax,-0x8(%ebp)
    25a4:	8b 55 10             	mov    0x10(%ebp),%edx
    25a7:	8b 45 28             	mov    0x28(%ebp),%eax
    25aa:	01 d0                	add    %edx,%eax
    25ac:	89 45 fc             	mov    %eax,-0x4(%ebp)
    25af:	ff 75 f4             	pushl  -0xc(%ebp)
    25b2:	ff 75 f0             	pushl  -0x10(%ebp)
    25b5:	83 ec 04             	sub    $0x4,%esp
    25b8:	89 e0                	mov    %esp,%eax
    25ba:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    25be:	66 89 10             	mov    %dx,(%eax)
    25c1:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    25c5:	88 50 02             	mov    %dl,0x2(%eax)
    25c8:	ff 75 18             	pushl  0x18(%ebp)
    25cb:	ff 75 14             	pushl  0x14(%ebp)
    25ce:	ff 75 fc             	pushl  -0x4(%ebp)
    25d1:	ff 75 f8             	pushl  -0x8(%ebp)
    25d4:	ff 75 08             	pushl  0x8(%ebp)
    25d7:	e8 11 fe ff ff       	call   23ed <drawRect>
    25dc:	83 c4 20             	add    $0x20,%esp
}
    25df:	90                   	nop
    25e0:	c9                   	leave  
    25e1:	c3                   	ret    

000025e2 <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    25e2:	55                   	push   %ebp
    25e3:	89 e5                	mov    %esp,%ebp
    25e5:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    25e8:	8b 45 30             	mov    0x30(%ebp),%eax
    25eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    25ee:	8b 45 34             	mov    0x34(%ebp),%eax
    25f1:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    25f4:	8b 55 20             	mov    0x20(%ebp),%edx
    25f7:	8b 45 14             	mov    0x14(%ebp),%eax
    25fa:	29 c2                	sub    %eax,%edx
    25fc:	89 d0                	mov    %edx,%eax
    25fe:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2601:	7d 0d                	jge    2610 <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    2603:	8b 55 20             	mov    0x20(%ebp),%edx
    2606:	8b 45 14             	mov    0x14(%ebp),%eax
    2609:	29 c2                	sub    %eax,%edx
    260b:	89 d0                	mov    %edx,%eax
    260d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    2610:	8b 55 28             	mov    0x28(%ebp),%edx
    2613:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2616:	29 c2                	sub    %eax,%edx
    2618:	89 d0                	mov    %edx,%eax
    261a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    261d:	7d 0d                	jge    262c <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    261f:	8b 55 28             	mov    0x28(%ebp),%edx
    2622:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2625:	29 c2                	sub    %eax,%edx
    2627:	89 d0                	mov    %edx,%eax
    2629:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    262c:	8b 55 24             	mov    0x24(%ebp),%edx
    262f:	8b 45 10             	mov    0x10(%ebp),%eax
    2632:	29 c2                	sub    %eax,%edx
    2634:	89 d0                	mov    %edx,%eax
    2636:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2639:	7d 0d                	jge    2648 <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    263b:	8b 55 24             	mov    0x24(%ebp),%edx
    263e:	8b 45 10             	mov    0x10(%ebp),%eax
    2641:	29 c2                	sub    %eax,%edx
    2643:	89 d0                	mov    %edx,%eax
    2645:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    2648:	8b 55 2c             	mov    0x2c(%ebp),%edx
    264b:	8b 45 18             	mov    0x18(%ebp),%eax
    264e:	29 c2                	sub    %eax,%edx
    2650:	89 d0                	mov    %edx,%eax
    2652:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2655:	7d 0d                	jge    2664 <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    2657:	8b 55 2c             	mov    0x2c(%ebp),%edx
    265a:	8b 45 18             	mov    0x18(%ebp),%eax
    265d:	29 c2                	sub    %eax,%edx
    265f:	89 d0                	mov    %edx,%eax
    2661:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    2664:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    266b:	e9 83 00 00 00       	jmp    26f3 <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    2670:	8b 55 14             	mov    0x14(%ebp),%edx
    2673:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2676:	01 d0                	add    %edx,%eax
    2678:	85 c0                	test   %eax,%eax
    267a:	78 72                	js     26ee <drawBitmap+0x10c>
    267c:	8b 55 14             	mov    0x14(%ebp),%edx
    267f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2682:	01 c2                	add    %eax,%edx
    2684:	8b 45 20             	mov    0x20(%ebp),%eax
    2687:	39 c2                	cmp    %eax,%edx
    2689:	7d 63                	jge    26ee <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    268b:	8b 55 14             	mov    0x14(%ebp),%edx
    268e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2691:	01 c2                	add    %eax,%edx
    2693:	8b 45 24             	mov    0x24(%ebp),%eax
    2696:	0f af c2             	imul   %edx,%eax
    2699:	89 c2                	mov    %eax,%edx
    269b:	8b 45 10             	mov    0x10(%ebp),%eax
    269e:	01 c2                	add    %eax,%edx
    26a0:	89 d0                	mov    %edx,%eax
    26a2:	01 c0                	add    %eax,%eax
    26a4:	01 c2                	add    %eax,%edx
    26a6:	8b 45 08             	mov    0x8(%ebp),%eax
    26a9:	01 d0                	add    %edx,%eax
    26ab:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    26ae:	8b 55 1c             	mov    0x1c(%ebp),%edx
    26b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    26b4:	01 c2                	add    %eax,%edx
    26b6:	8b 45 2c             	mov    0x2c(%ebp),%eax
    26b9:	0f af c2             	imul   %edx,%eax
    26bc:	89 c2                	mov    %eax,%edx
    26be:	8b 45 18             	mov    0x18(%ebp),%eax
    26c1:	01 c2                	add    %eax,%edx
    26c3:	89 d0                	mov    %edx,%eax
    26c5:	01 c0                	add    %eax,%eax
    26c7:	01 c2                	add    %eax,%edx
    26c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    26cc:	01 d0                	add    %edx,%eax
    26ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    26d1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    26d4:	89 d0                	mov    %edx,%eax
    26d6:	01 c0                	add    %eax,%eax
    26d8:	01 d0                	add    %edx,%eax
    26da:	83 ec 04             	sub    $0x4,%esp
    26dd:	50                   	push   %eax
    26de:	ff 75 e4             	pushl  -0x1c(%ebp)
    26e1:	ff 75 e8             	pushl  -0x18(%ebp)
    26e4:	e8 23 e7 ff ff       	call   e0c <memmove>
    26e9:	83 c4 10             	add    $0x10,%esp
    26ec:	eb 01                	jmp    26ef <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    26ee:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    26ef:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    26f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    26f6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    26f9:	0f 8c 71 ff ff ff    	jl     2670 <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    26ff:	90                   	nop
    2700:	c9                   	leave  
    2701:	c3                   	ret    

00002702 <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    2702:	55                   	push   %ebp
    2703:	89 e5                	mov    %esp,%ebp
    2705:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    2708:	8b 45 30             	mov    0x30(%ebp),%eax
    270b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    270e:	8b 45 34             	mov    0x34(%ebp),%eax
    2711:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    2714:	8b 55 20             	mov    0x20(%ebp),%edx
    2717:	8b 45 14             	mov    0x14(%ebp),%eax
    271a:	29 c2                	sub    %eax,%edx
    271c:	89 d0                	mov    %edx,%eax
    271e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2721:	7d 0d                	jge    2730 <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    2723:	8b 55 20             	mov    0x20(%ebp),%edx
    2726:	8b 45 14             	mov    0x14(%ebp),%eax
    2729:	29 c2                	sub    %eax,%edx
    272b:	89 d0                	mov    %edx,%eax
    272d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    2730:	8b 55 28             	mov    0x28(%ebp),%edx
    2733:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2736:	29 c2                	sub    %eax,%edx
    2738:	89 d0                	mov    %edx,%eax
    273a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    273d:	7d 0d                	jge    274c <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    273f:	8b 55 28             	mov    0x28(%ebp),%edx
    2742:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2745:	29 c2                	sub    %eax,%edx
    2747:	89 d0                	mov    %edx,%eax
    2749:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    274c:	8b 55 24             	mov    0x24(%ebp),%edx
    274f:	8b 45 10             	mov    0x10(%ebp),%eax
    2752:	29 c2                	sub    %eax,%edx
    2754:	89 d0                	mov    %edx,%eax
    2756:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2759:	7d 0d                	jge    2768 <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    275b:	8b 55 24             	mov    0x24(%ebp),%edx
    275e:	8b 45 10             	mov    0x10(%ebp),%eax
    2761:	29 c2                	sub    %eax,%edx
    2763:	89 d0                	mov    %edx,%eax
    2765:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    2768:	8b 55 2c             	mov    0x2c(%ebp),%edx
    276b:	8b 45 18             	mov    0x18(%ebp),%eax
    276e:	29 c2                	sub    %eax,%edx
    2770:	89 d0                	mov    %edx,%eax
    2772:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2775:	7d 0d                	jge    2784 <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    2777:	8b 55 2c             	mov    0x2c(%ebp),%edx
    277a:	8b 45 18             	mov    0x18(%ebp),%eax
    277d:	29 c2                	sub    %eax,%edx
    277f:	89 d0                	mov    %edx,%eax
    2781:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    2784:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    278b:	e9 b8 00 00 00       	jmp    2848 <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    2790:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2797:	e9 9c 00 00 00       	jmp    2838 <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    279c:	8b 55 14             	mov    0x14(%ebp),%edx
    279f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    27a2:	01 c2                	add    %eax,%edx
    27a4:	8b 45 24             	mov    0x24(%ebp),%eax
    27a7:	0f af c2             	imul   %edx,%eax
    27aa:	89 c2                	mov    %eax,%edx
    27ac:	8b 45 10             	mov    0x10(%ebp),%eax
    27af:	01 c2                	add    %eax,%edx
    27b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    27b4:	01 c2                	add    %eax,%edx
    27b6:	89 d0                	mov    %edx,%eax
    27b8:	01 c0                	add    %eax,%eax
    27ba:	01 c2                	add    %eax,%edx
    27bc:	8b 45 08             	mov    0x8(%ebp),%eax
    27bf:	01 d0                	add    %edx,%eax
    27c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    27c4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    27c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    27ca:	01 c2                	add    %eax,%edx
    27cc:	8b 45 2c             	mov    0x2c(%ebp),%eax
    27cf:	0f af c2             	imul   %edx,%eax
    27d2:	89 c2                	mov    %eax,%edx
    27d4:	8b 45 18             	mov    0x18(%ebp),%eax
    27d7:	01 c2                	add    %eax,%edx
    27d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    27dc:	01 c2                	add    %eax,%edx
    27de:	89 d0                	mov    %edx,%eax
    27e0:	01 c0                	add    %eax,%eax
    27e2:	01 c2                	add    %eax,%edx
    27e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    27e7:	01 d0                	add    %edx,%eax
    27e9:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    27ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
    27ef:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    27f3:	3c ff                	cmp    $0xff,%al
    27f5:	75 15                	jne    280c <drawTransparentBitmap+0x10a>
    27f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    27fa:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    27fe:	3c ff                	cmp    $0xff,%al
    2800:	75 0a                	jne    280c <drawTransparentBitmap+0x10a>
    2802:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2805:	0f b6 00             	movzbl (%eax),%eax
    2808:	3c ff                	cmp    $0xff,%al
    280a:	74 27                	je     2833 <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    280c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    280f:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    2813:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2816:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    2819:	8b 45 e8             	mov    -0x18(%ebp),%eax
    281c:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    2820:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2823:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    2826:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2829:	0f b6 10             	movzbl (%eax),%edx
    282c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    282f:	88 10                	mov    %dl,(%eax)
    2831:	eb 01                	jmp    2834 <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    2833:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    2834:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2838:	8b 45 34             	mov    0x34(%ebp),%eax
    283b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    283e:	0f 8f 58 ff ff ff    	jg     279c <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    2844:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2848:	8b 45 30             	mov    0x30(%ebp),%eax
    284b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    284e:	0f 8f 3c ff ff ff    	jg     2790 <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    2854:	90                   	nop
    2855:	c9                   	leave  
    2856:	c3                   	ret    

00002857 <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    2857:	55                   	push   %ebp
    2858:	89 e5                	mov    %esp,%ebp
    285a:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    285d:	ff 75 24             	pushl  0x24(%ebp)
    2860:	ff 75 20             	pushl  0x20(%ebp)
    2863:	ff 75 1c             	pushl  0x1c(%ebp)
    2866:	ff 75 18             	pushl  0x18(%ebp)
    2869:	ff 75 1c             	pushl  0x1c(%ebp)
    286c:	ff 75 18             	pushl  0x18(%ebp)
    286f:	ff 75 14             	pushl  0x14(%ebp)
    2872:	ff 75 10             	pushl  0x10(%ebp)
    2875:	ff 75 14             	pushl  0x14(%ebp)
    2878:	ff 75 10             	pushl  0x10(%ebp)
    287b:	ff 75 0c             	pushl  0xc(%ebp)
    287e:	ff 75 08             	pushl  0x8(%ebp)
    2881:	e8 5c fd ff ff       	call   25e2 <drawBitmap>
    2886:	83 c4 30             	add    $0x30,%esp
}
    2889:	90                   	nop
    288a:	c9                   	leave  
    288b:	c3                   	ret    

0000288c <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    288c:	55                   	push   %ebp
    288d:	89 e5                	mov    %esp,%ebp
    288f:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    2892:	8b 45 1c             	mov    0x1c(%ebp),%eax
    2895:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    2898:	8b 45 20             	mov    0x20(%ebp),%eax
    289b:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    289e:	8b 55 14             	mov    0x14(%ebp),%edx
    28a1:	8b 45 10             	mov    0x10(%ebp),%eax
    28a4:	29 c2                	sub    %eax,%edx
    28a6:	89 d0                	mov    %edx,%eax
    28a8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    28ab:	7d 0d                	jge    28ba <colorShift+0x2e>
        draw_h = s.h - p.y;
    28ad:	8b 55 14             	mov    0x14(%ebp),%edx
    28b0:	8b 45 10             	mov    0x10(%ebp),%eax
    28b3:	29 c2                	sub    %eax,%edx
    28b5:	89 d0                	mov    %edx,%eax
    28b7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    28ba:	8b 55 18             	mov    0x18(%ebp),%edx
    28bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    28c0:	29 c2                	sub    %eax,%edx
    28c2:	89 d0                	mov    %edx,%eax
    28c4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    28c7:	7d 0d                	jge    28d6 <colorShift+0x4a>
        draw_w = s.w - p.x;
    28c9:	8b 55 18             	mov    0x18(%ebp),%edx
    28cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    28cf:	29 c2                	sub    %eax,%edx
    28d1:	89 d0                	mov    %edx,%eax
    28d3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    28d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    28dd:	e9 fc 00 00 00       	jmp    29de <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    28e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    28e9:	e9 e0 00 00 00       	jmp    29ce <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    28ee:	8b 55 10             	mov    0x10(%ebp),%edx
    28f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    28f4:	01 c2                	add    %eax,%edx
    28f6:	8b 45 18             	mov    0x18(%ebp),%eax
    28f9:	0f af c2             	imul   %edx,%eax
    28fc:	89 c2                	mov    %eax,%edx
    28fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    2901:	01 c2                	add    %eax,%edx
    2903:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2906:	01 c2                	add    %eax,%edx
    2908:	89 d0                	mov    %edx,%eax
    290a:	01 c0                	add    %eax,%eax
    290c:	01 c2                	add    %eax,%edx
    290e:	8b 45 08             	mov    0x8(%ebp),%eax
    2911:	01 d0                	add    %edx,%eax
    2913:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    2916:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2919:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    291d:	3c c8                	cmp    $0xc8,%al
    291f:	0f 86 a5 00 00 00    	jbe    29ca <colorShift+0x13e>
    2925:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2928:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    292c:	3c c8                	cmp    $0xc8,%al
    292e:	0f 86 96 00 00 00    	jbe    29ca <colorShift+0x13e>
    2934:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2937:	0f b6 00             	movzbl (%eax),%eax
    293a:	3c c8                	cmp    $0xc8,%al
    293c:	0f 86 88 00 00 00    	jbe    29ca <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    2942:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2945:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2949:	0f b6 d0             	movzbl %al,%edx
    294c:	8b 45 24             	mov    0x24(%ebp),%eax
    294f:	01 d0                	add    %edx,%eax
    2951:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    2957:	89 d0                	mov    %edx,%eax
    2959:	c1 f8 1f             	sar    $0x1f,%eax
    295c:	c1 e8 18             	shr    $0x18,%eax
    295f:	01 c2                	add    %eax,%edx
    2961:	0f b6 d2             	movzbl %dl,%edx
    2964:	29 c2                	sub    %eax,%edx
    2966:	89 d0                	mov    %edx,%eax
    2968:	89 c2                	mov    %eax,%edx
    296a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    296d:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    2970:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2973:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2977:	0f b6 d0             	movzbl %al,%edx
    297a:	8b 45 24             	mov    0x24(%ebp),%eax
    297d:	01 d0                	add    %edx,%eax
    297f:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    2985:	89 d0                	mov    %edx,%eax
    2987:	c1 f8 1f             	sar    $0x1f,%eax
    298a:	c1 e8 18             	shr    $0x18,%eax
    298d:	01 c2                	add    %eax,%edx
    298f:	0f b6 d2             	movzbl %dl,%edx
    2992:	29 c2                	sub    %eax,%edx
    2994:	89 d0                	mov    %edx,%eax
    2996:	89 c2                	mov    %eax,%edx
    2998:	8b 45 ec             	mov    -0x14(%ebp),%eax
    299b:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    299e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    29a1:	0f b6 00             	movzbl (%eax),%eax
    29a4:	0f b6 d0             	movzbl %al,%edx
    29a7:	8b 45 24             	mov    0x24(%ebp),%eax
    29aa:	01 d0                	add    %edx,%eax
    29ac:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    29b2:	89 d0                	mov    %edx,%eax
    29b4:	c1 f8 1f             	sar    $0x1f,%eax
    29b7:	c1 e8 18             	shr    $0x18,%eax
    29ba:	01 c2                	add    %eax,%edx
    29bc:	0f b6 d2             	movzbl %dl,%edx
    29bf:	29 c2                	sub    %eax,%edx
    29c1:	89 d0                	mov    %edx,%eax
    29c3:	89 c2                	mov    %eax,%edx
    29c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    29c8:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    29ca:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    29ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
    29d1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    29d4:	0f 8c 14 ff ff ff    	jl     28ee <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    29da:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    29de:	8b 45 f4             	mov    -0xc(%ebp),%eax
    29e1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    29e4:	0f 8c f8 fe ff ff    	jl     28e2 <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    29ea:	90                   	nop
    29eb:	c9                   	leave  
    29ec:	c3                   	ret    

000029ed <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    29ed:	55                   	push   %ebp
    29ee:	89 e5                	mov    %esp,%ebp
    29f0:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    29f3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    29fa:	e9 fb 00 00 00       	jmp    2afa <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    29ff:	8b 55 14             	mov    0x14(%ebp),%edx
    2a02:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2a05:	01 c2                	add    %eax,%edx
    2a07:	0f b7 05 22 ed 17 00 	movzwl 0x17ed22,%eax
    2a0e:	0f b7 c0             	movzwl %ax,%eax
    2a11:	39 c2                	cmp    %eax,%edx
    2a13:	0f 8f eb 00 00 00    	jg     2b04 <drawMouse+0x117>
    2a19:	8b 55 14             	mov    0x14(%ebp),%edx
    2a1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2a1f:	01 d0                	add    %edx,%eax
    2a21:	85 c0                	test   %eax,%eax
    2a23:	0f 88 db 00 00 00    	js     2b04 <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    2a29:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2a30:	e9 b7 00 00 00       	jmp    2aec <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    2a35:	8b 55 10             	mov    0x10(%ebp),%edx
    2a38:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a3b:	01 c2                	add    %eax,%edx
    2a3d:	0f b7 05 20 ed 17 00 	movzwl 0x17ed20,%eax
    2a44:	0f b7 c0             	movzwl %ax,%eax
    2a47:	39 c2                	cmp    %eax,%edx
    2a49:	0f 8f a7 00 00 00    	jg     2af6 <drawMouse+0x109>
    2a4f:	8b 55 10             	mov    0x10(%ebp),%edx
    2a52:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a55:	01 d0                	add    %edx,%eax
    2a57:	85 c0                	test   %eax,%eax
    2a59:	0f 88 97 00 00 00    	js     2af6 <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    2a5f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    2a62:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    2a65:	89 d0                	mov    %edx,%eax
    2a67:	c1 e0 04             	shl    $0x4,%eax
    2a6a:	29 d0                	sub    %edx,%eax
    2a6c:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    2a72:	01 c2                	add    %eax,%edx
    2a74:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a77:	01 d0                	add    %edx,%eax
    2a79:	05 a0 6a 01 00       	add    $0x16aa0,%eax
    2a7e:	0f b6 00             	movzbl (%eax),%eax
    2a81:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    2a84:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    2a88:	74 5e                	je     2ae8 <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    2a8a:	8b 55 14             	mov    0x14(%ebp),%edx
    2a8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2a90:	01 c2                	add    %eax,%edx
    2a92:	0f b7 05 20 ed 17 00 	movzwl 0x17ed20,%eax
    2a99:	0f b7 c0             	movzwl %ax,%eax
    2a9c:	0f af c2             	imul   %edx,%eax
    2a9f:	89 c2                	mov    %eax,%edx
    2aa1:	8b 45 10             	mov    0x10(%ebp),%eax
    2aa4:	01 c2                	add    %eax,%edx
    2aa6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2aa9:	01 c2                	add    %eax,%edx
    2aab:	89 d0                	mov    %edx,%eax
    2aad:	01 c0                	add    %eax,%eax
    2aaf:	01 c2                	add    %eax,%edx
    2ab1:	8b 45 08             	mov    0x8(%ebp),%eax
    2ab4:	01 d0                	add    %edx,%eax
    2ab6:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    2ab9:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    2abd:	8d 50 ff             	lea    -0x1(%eax),%edx
    2ac0:	89 d0                	mov    %edx,%eax
    2ac2:	01 c0                	add    %eax,%eax
    2ac4:	01 d0                	add    %edx,%eax
    2ac6:	05 28 ed 17 00       	add    $0x17ed28,%eax
    2acb:	83 ec 04             	sub    $0x4,%esp
    2ace:	89 e2                	mov    %esp,%edx
    2ad0:	0f b7 08             	movzwl (%eax),%ecx
    2ad3:	66 89 0a             	mov    %cx,(%edx)
    2ad6:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2ada:	88 42 02             	mov    %al,0x2(%edx)
    2add:	ff 75 f0             	pushl  -0x10(%ebp)
    2ae0:	e8 73 f6 ff ff       	call   2158 <drawPoint>
    2ae5:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    2ae8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2aec:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    2af0:	0f 8e 3f ff ff ff    	jle    2a35 <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    2af6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2afa:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    2afe:	0f 8e fb fe ff ff    	jle    29ff <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    2b04:	90                   	nop
    2b05:	c9                   	leave  
    2b06:	c3                   	ret    

00002b07 <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    2b07:	55                   	push   %ebp
    2b08:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    2b0a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    2b0e:	78 1b                	js     2b2b <getColor+0x24>
    2b10:	8b 45 08             	mov    0x8(%ebp),%eax
    2b13:	8b 40 04             	mov    0x4(%eax),%eax
    2b16:	3b 45 0c             	cmp    0xc(%ebp),%eax
    2b19:	7c 10                	jl     2b2b <getColor+0x24>
    2b1b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    2b1f:	78 0a                	js     2b2b <getColor+0x24>
    2b21:	8b 45 08             	mov    0x8(%ebp),%eax
    2b24:	8b 00                	mov    (%eax),%eax
    2b26:	3b 45 10             	cmp    0x10(%ebp),%eax
    2b29:	7d 10                	jge    2b3b <getColor+0x34>
    {
        *isInPic = 1;
    2b2b:	8b 45 14             	mov    0x14(%ebp),%eax
    2b2e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    2b34:	b8 61 ef 01 00       	mov    $0x1ef61,%eax
    2b39:	eb 44                	jmp    2b7f <getColor+0x78>
    }

    if (y == pic->height)
    2b3b:	8b 45 08             	mov    0x8(%ebp),%eax
    2b3e:	8b 40 04             	mov    0x4(%eax),%eax
    2b41:	3b 45 0c             	cmp    0xc(%ebp),%eax
    2b44:	75 04                	jne    2b4a <getColor+0x43>
        y--;
    2b46:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    2b4a:	8b 45 08             	mov    0x8(%ebp),%eax
    2b4d:	8b 00                	mov    (%eax),%eax
    2b4f:	3b 45 10             	cmp    0x10(%ebp),%eax
    2b52:	75 04                	jne    2b58 <getColor+0x51>
        x--;
    2b54:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    2b58:	8b 45 14             	mov    0x14(%ebp),%eax
    2b5b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    2b61:	8b 45 08             	mov    0x8(%ebp),%eax
    2b64:	8b 48 08             	mov    0x8(%eax),%ecx
    2b67:	8b 45 08             	mov    0x8(%ebp),%eax
    2b6a:	8b 00                	mov    (%eax),%eax
    2b6c:	0f af 45 0c          	imul   0xc(%ebp),%eax
    2b70:	89 c2                	mov    %eax,%edx
    2b72:	8b 45 10             	mov    0x10(%ebp),%eax
    2b75:	01 c2                	add    %eax,%edx
    2b77:	89 d0                	mov    %edx,%eax
    2b79:	01 c0                	add    %eax,%eax
    2b7b:	01 d0                	add    %edx,%eax
    2b7d:	01 c8                	add    %ecx,%eax
}
    2b7f:	5d                   	pop    %ebp
    2b80:	c3                   	ret    

00002b81 <setColor>:

int setColor(RGB *src, RGB *dst)
{
    2b81:	55                   	push   %ebp
    2b82:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    2b84:	8b 45 08             	mov    0x8(%ebp),%eax
    2b87:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    2b8b:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b8e:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    2b91:	8b 45 08             	mov    0x8(%ebp),%eax
    2b94:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    2b98:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b9b:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    2b9e:	8b 45 08             	mov    0x8(%ebp),%eax
    2ba1:	0f b6 10             	movzbl (%eax),%edx
    2ba4:	8b 45 0c             	mov    0xc(%ebp),%eax
    2ba7:	88 10                	mov    %dl,(%eax)

    return 1;
    2ba9:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2bae:	5d                   	pop    %ebp
    2baf:	c3                   	ret    

00002bb0 <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    2bb0:	55                   	push   %ebp
    2bb1:	89 e5                	mov    %esp,%ebp
    2bb3:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    2bb6:	d9 45 10             	flds   0x10(%ebp)
    2bb9:	d9 7d be             	fnstcw -0x42(%ebp)
    2bbc:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    2bc0:	b4 0c                	mov    $0xc,%ah
    2bc2:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    2bc6:	d9 6d bc             	fldcw  -0x44(%ebp)
    2bc9:	db 5d fc             	fistpl -0x4(%ebp)
    2bcc:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    2bcf:	d9 45 0c             	flds   0xc(%ebp)
    2bd2:	d9 6d bc             	fldcw  -0x44(%ebp)
    2bd5:	db 5d f8             	fistpl -0x8(%ebp)
    2bd8:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    2bdb:	db 45 fc             	fildl  -0x4(%ebp)
    2bde:	d9 45 10             	flds   0x10(%ebp)
    2be1:	d9 c9                	fxch   %st(1)
    2be3:	df e9                	fucomip %st(1),%st
    2be5:	dd d8                	fstp   %st(0)
    2be7:	76 04                	jbe    2bed <mixColor+0x3d>
        x--;
    2be9:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    2bed:	db 45 f8             	fildl  -0x8(%ebp)
    2bf0:	d9 45 0c             	flds   0xc(%ebp)
    2bf3:	d9 c9                	fxch   %st(1)
    2bf5:	df e9                	fucomip %st(1),%st
    2bf7:	dd d8                	fstp   %st(0)
    2bf9:	76 04                	jbe    2bff <mixColor+0x4f>
        y--;
    2bfb:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2bff:	8d 45 c0             	lea    -0x40(%ebp),%eax
    2c02:	50                   	push   %eax
    2c03:	ff 75 fc             	pushl  -0x4(%ebp)
    2c06:	ff 75 f8             	pushl  -0x8(%ebp)
    2c09:	ff 75 08             	pushl  0x8(%ebp)
    2c0c:	e8 f6 fe ff ff       	call   2b07 <getColor>
    2c11:	83 c4 10             	add    $0x10,%esp
    2c14:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    2c17:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2c1a:	83 c0 01             	add    $0x1,%eax
    2c1d:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2c20:	83 c2 04             	add    $0x4,%edx
    2c23:	52                   	push   %edx
    2c24:	ff 75 fc             	pushl  -0x4(%ebp)
    2c27:	50                   	push   %eax
    2c28:	ff 75 08             	pushl  0x8(%ebp)
    2c2b:	e8 d7 fe ff ff       	call   2b07 <getColor>
    2c30:	83 c4 10             	add    $0x10,%esp
    2c33:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    2c36:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2c39:	83 c0 01             	add    $0x1,%eax
    2c3c:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2c3f:	83 c2 08             	add    $0x8,%edx
    2c42:	52                   	push   %edx
    2c43:	50                   	push   %eax
    2c44:	ff 75 f8             	pushl  -0x8(%ebp)
    2c47:	ff 75 08             	pushl  0x8(%ebp)
    2c4a:	e8 b8 fe ff ff       	call   2b07 <getColor>
    2c4f:	83 c4 10             	add    $0x10,%esp
    2c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    2c55:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2c58:	8d 50 01             	lea    0x1(%eax),%edx
    2c5b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2c5e:	83 c0 01             	add    $0x1,%eax
    2c61:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    2c64:	83 c1 0c             	add    $0xc,%ecx
    2c67:	51                   	push   %ecx
    2c68:	52                   	push   %edx
    2c69:	50                   	push   %eax
    2c6a:	ff 75 08             	pushl  0x8(%ebp)
    2c6d:	e8 95 fe ff ff       	call   2b07 <getColor>
    2c72:	83 c4 10             	add    $0x10,%esp
    2c75:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    2c78:	db 45 fc             	fildl  -0x4(%ebp)
    2c7b:	d9 45 10             	flds   0x10(%ebp)
    2c7e:	de e1                	fsubp  %st,%st(1)
    2c80:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    2c83:	db 45 f8             	fildl  -0x8(%ebp)
    2c86:	d9 45 0c             	flds   0xc(%ebp)
    2c89:	de e1                	fsubp  %st,%st(1)
    2c8b:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    2c8e:	d9 45 e4             	flds   -0x1c(%ebp)
    2c91:	d8 4d e0             	fmuls  -0x20(%ebp)
    2c94:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    2c97:	d9 e8                	fld1   
    2c99:	d8 65 e0             	fsubs  -0x20(%ebp)
    2c9c:	d8 4d e4             	fmuls  -0x1c(%ebp)
    2c9f:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    2ca2:	d9 e8                	fld1   
    2ca4:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2ca7:	d8 4d e0             	fmuls  -0x20(%ebp)
    2caa:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    2cad:	d9 e8                	fld1   
    2caf:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2cb2:	d9 e8                	fld1   
    2cb4:	d8 65 e0             	fsubs  -0x20(%ebp)
    2cb7:	de c9                	fmulp  %st,%st(1)
    2cb9:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    2cbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2cbf:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2cc3:	0f b6 c0             	movzbl %al,%eax
    2cc6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2cc9:	db 45 b4             	fildl  -0x4c(%ebp)
    2ccc:	d8 4d d0             	fmuls  -0x30(%ebp)
    2ccf:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2cd2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2cd5:	db 45 b4             	fildl  -0x4c(%ebp)
    2cd8:	de c9                	fmulp  %st,%st(1)
    2cda:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2cdd:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2ce1:	0f b6 c0             	movzbl %al,%eax
    2ce4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2ce7:	db 45 b4             	fildl  -0x4c(%ebp)
    2cea:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2ced:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2cf0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2cf3:	db 45 b4             	fildl  -0x4c(%ebp)
    2cf6:	de c9                	fmulp  %st,%st(1)
    2cf8:	de c1                	faddp  %st,%st(1)
    2cfa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2cfd:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2d01:	0f b6 c0             	movzbl %al,%eax
    2d04:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2d07:	db 45 b4             	fildl  -0x4c(%ebp)
    2d0a:	d8 4d d8             	fmuls  -0x28(%ebp)
    2d0d:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2d10:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2d13:	db 45 b4             	fildl  -0x4c(%ebp)
    2d16:	de c9                	fmulp  %st,%st(1)
    2d18:	de c1                	faddp  %st,%st(1)
    2d1a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2d1d:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2d21:	0f b6 c0             	movzbl %al,%eax
    2d24:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2d27:	db 45 b4             	fildl  -0x4c(%ebp)
    2d2a:	d8 4d dc             	fmuls  -0x24(%ebp)
    2d2d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2d30:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2d33:	db 45 b4             	fildl  -0x4c(%ebp)
    2d36:	de c9                	fmulp  %st,%st(1)
    2d38:	de c1                	faddp  %st,%st(1)
    2d3a:	d9 7d be             	fnstcw -0x42(%ebp)
    2d3d:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    2d41:	b4 0c                	mov    $0xc,%ah
    2d43:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    2d47:	d9 6d bc             	fldcw  -0x44(%ebp)
    2d4a:	db 5d b8             	fistpl -0x48(%ebp)
    2d4d:	d9 6d be             	fldcw  -0x42(%ebp)
    2d50:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2d53:	89 c2                	mov    %eax,%edx
    2d55:	8b 45 14             	mov    0x14(%ebp),%eax
    2d58:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    2d5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2d5e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2d62:	0f b6 c0             	movzbl %al,%eax
    2d65:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2d68:	db 45 b4             	fildl  -0x4c(%ebp)
    2d6b:	d8 4d d0             	fmuls  -0x30(%ebp)
    2d6e:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2d71:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2d74:	db 45 b4             	fildl  -0x4c(%ebp)
    2d77:	de c9                	fmulp  %st,%st(1)
    2d79:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2d7c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2d80:	0f b6 c0             	movzbl %al,%eax
    2d83:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2d86:	db 45 b4             	fildl  -0x4c(%ebp)
    2d89:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2d8c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2d8f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2d92:	db 45 b4             	fildl  -0x4c(%ebp)
    2d95:	de c9                	fmulp  %st,%st(1)
    2d97:	de c1                	faddp  %st,%st(1)
    2d99:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2d9c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2da0:	0f b6 c0             	movzbl %al,%eax
    2da3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2da6:	db 45 b4             	fildl  -0x4c(%ebp)
    2da9:	d8 4d d8             	fmuls  -0x28(%ebp)
    2dac:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2daf:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2db2:	db 45 b4             	fildl  -0x4c(%ebp)
    2db5:	de c9                	fmulp  %st,%st(1)
    2db7:	de c1                	faddp  %st,%st(1)
    2db9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2dbc:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2dc0:	0f b6 c0             	movzbl %al,%eax
    2dc3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2dc6:	db 45 b4             	fildl  -0x4c(%ebp)
    2dc9:	d8 4d dc             	fmuls  -0x24(%ebp)
    2dcc:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2dcf:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2dd2:	db 45 b4             	fildl  -0x4c(%ebp)
    2dd5:	de c9                	fmulp  %st,%st(1)
    2dd7:	de c1                	faddp  %st,%st(1)
    2dd9:	d9 6d bc             	fldcw  -0x44(%ebp)
    2ddc:	db 5d b8             	fistpl -0x48(%ebp)
    2ddf:	d9 6d be             	fldcw  -0x42(%ebp)
    2de2:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2de5:	89 c2                	mov    %eax,%edx
    2de7:	8b 45 14             	mov    0x14(%ebp),%eax
    2dea:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    2ded:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2df0:	0f b6 00             	movzbl (%eax),%eax
    2df3:	0f b6 c0             	movzbl %al,%eax
    2df6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2df9:	db 45 b4             	fildl  -0x4c(%ebp)
    2dfc:	d8 4d d0             	fmuls  -0x30(%ebp)
    2dff:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2e02:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2e05:	db 45 b4             	fildl  -0x4c(%ebp)
    2e08:	de c9                	fmulp  %st,%st(1)
    2e0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e0d:	0f b6 00             	movzbl (%eax),%eax
    2e10:	0f b6 c0             	movzbl %al,%eax
    2e13:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2e16:	db 45 b4             	fildl  -0x4c(%ebp)
    2e19:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2e1c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2e1f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2e22:	db 45 b4             	fildl  -0x4c(%ebp)
    2e25:	de c9                	fmulp  %st,%st(1)
    2e27:	de c1                	faddp  %st,%st(1)
    2e29:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2e2c:	0f b6 00             	movzbl (%eax),%eax
    2e2f:	0f b6 c0             	movzbl %al,%eax
    2e32:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2e35:	db 45 b4             	fildl  -0x4c(%ebp)
    2e38:	d8 4d d8             	fmuls  -0x28(%ebp)
    2e3b:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2e3e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2e41:	db 45 b4             	fildl  -0x4c(%ebp)
    2e44:	de c9                	fmulp  %st,%st(1)
    2e46:	de c1                	faddp  %st,%st(1)
    2e48:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2e4b:	0f b6 00             	movzbl (%eax),%eax
    2e4e:	0f b6 c0             	movzbl %al,%eax
    2e51:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2e54:	db 45 b4             	fildl  -0x4c(%ebp)
    2e57:	d8 4d dc             	fmuls  -0x24(%ebp)
    2e5a:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2e5d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2e60:	db 45 b4             	fildl  -0x4c(%ebp)
    2e63:	de c9                	fmulp  %st,%st(1)
    2e65:	de c1                	faddp  %st,%st(1)
    2e67:	d9 6d bc             	fldcw  -0x44(%ebp)
    2e6a:	db 5d b8             	fistpl -0x48(%ebp)
    2e6d:	d9 6d be             	fldcw  -0x42(%ebp)
    2e70:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2e73:	89 c2                	mov    %eax,%edx
    2e75:	8b 45 14             	mov    0x14(%ebp),%eax
    2e78:	88 10                	mov    %dl,(%eax)

    return 1;
    2e7a:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2e7f:	c9                   	leave  
    2e80:	c3                   	ret    

00002e81 <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    2e81:	55                   	push   %ebp
    2e82:	89 e5                	mov    %esp,%ebp
    2e84:	53                   	push   %ebx
    2e85:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    2e88:	8b 45 10             	mov    0x10(%ebp),%eax
    2e8b:	c1 f8 10             	sar    $0x10,%eax
    2e8e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    2e91:	8b 45 0c             	mov    0xc(%ebp),%eax
    2e94:	c1 f8 10             	sar    $0x10,%eax
    2e97:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2e9a:	8d 45 bc             	lea    -0x44(%ebp),%eax
    2e9d:	50                   	push   %eax
    2e9e:	ff 75 f8             	pushl  -0x8(%ebp)
    2ea1:	ff 75 f4             	pushl  -0xc(%ebp)
    2ea4:	ff 75 08             	pushl  0x8(%ebp)
    2ea7:	e8 5b fc ff ff       	call   2b07 <getColor>
    2eac:	83 c4 10             	add    $0x10,%esp
    2eaf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    2eb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2eb5:	83 c0 01             	add    $0x1,%eax
    2eb8:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2ebb:	83 c2 04             	add    $0x4,%edx
    2ebe:	52                   	push   %edx
    2ebf:	ff 75 f8             	pushl  -0x8(%ebp)
    2ec2:	50                   	push   %eax
    2ec3:	ff 75 08             	pushl  0x8(%ebp)
    2ec6:	e8 3c fc ff ff       	call   2b07 <getColor>
    2ecb:	83 c4 10             	add    $0x10,%esp
    2ece:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    2ed1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2ed4:	83 c0 01             	add    $0x1,%eax
    2ed7:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2eda:	83 c2 08             	add    $0x8,%edx
    2edd:	52                   	push   %edx
    2ede:	50                   	push   %eax
    2edf:	ff 75 f4             	pushl  -0xc(%ebp)
    2ee2:	ff 75 08             	pushl  0x8(%ebp)
    2ee5:	e8 1d fc ff ff       	call   2b07 <getColor>
    2eea:	83 c4 10             	add    $0x10,%esp
    2eed:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    2ef0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2ef3:	8d 50 01             	lea    0x1(%eax),%edx
    2ef6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ef9:	83 c0 01             	add    $0x1,%eax
    2efc:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    2eff:	83 c1 0c             	add    $0xc,%ecx
    2f02:	51                   	push   %ecx
    2f03:	52                   	push   %edx
    2f04:	50                   	push   %eax
    2f05:	ff 75 08             	pushl  0x8(%ebp)
    2f08:	e8 fa fb ff ff       	call   2b07 <getColor>
    2f0d:	83 c4 10             	add    $0x10,%esp
    2f10:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    2f13:	8b 45 10             	mov    0x10(%ebp),%eax
    2f16:	0f b7 c0             	movzwl %ax,%eax
    2f19:	c1 f8 08             	sar    $0x8,%eax
    2f1c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    2f1f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2f22:	0f b7 c0             	movzwl %ax,%eax
    2f25:	c1 f8 08             	sar    $0x8,%eax
    2f28:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    2f2b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2f2e:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    2f32:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    2f35:	b8 ff 00 00 00       	mov    $0xff,%eax
    2f3a:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2f3d:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    2f41:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    2f44:	b8 ff 00 00 00       	mov    $0xff,%eax
    2f49:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2f4c:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    2f50:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    2f53:	b8 ff 00 00 00       	mov    $0xff,%eax
    2f58:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2f5b:	89 c2                	mov    %eax,%edx
    2f5d:	b8 ff 00 00 00       	mov    $0xff,%eax
    2f62:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2f65:	0f af c2             	imul   %edx,%eax
    2f68:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    2f6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2f6e:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2f72:	0f b6 c0             	movzbl %al,%eax
    2f75:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2f79:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2f7c:	0f af d0             	imul   %eax,%edx
    2f7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2f82:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2f86:	0f b6 c0             	movzbl %al,%eax
    2f89:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2f8d:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2f90:	0f af c1             	imul   %ecx,%eax
    2f93:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2f96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2f99:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2f9d:	0f b6 c0             	movzbl %al,%eax
    2fa0:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2fa4:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2fa7:	0f af d0             	imul   %eax,%edx
    2faa:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2fad:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2fb1:	0f b6 c0             	movzbl %al,%eax
    2fb4:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2fb8:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2fbb:	0f af c1             	imul   %ecx,%eax
    2fbe:	01 d0                	add    %edx,%eax
    2fc0:	01 d8                	add    %ebx,%eax
    2fc2:	c1 e8 10             	shr    $0x10,%eax
    2fc5:	89 c2                	mov    %eax,%edx
    2fc7:	8b 45 14             	mov    0x14(%ebp),%eax
    2fca:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    2fcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2fd0:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2fd4:	0f b6 c0             	movzbl %al,%eax
    2fd7:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2fdb:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2fde:	0f af d0             	imul   %eax,%edx
    2fe1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2fe4:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2fe8:	0f b6 c0             	movzbl %al,%eax
    2feb:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2fef:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2ff2:	0f af c1             	imul   %ecx,%eax
    2ff5:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2ff8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2ffb:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2fff:	0f b6 c0             	movzbl %al,%eax
    3002:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    3006:	8b 55 c8             	mov    -0x38(%ebp),%edx
    3009:	0f af d0             	imul   %eax,%edx
    300c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    300f:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    3013:	0f b6 c0             	movzbl %al,%eax
    3016:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    301a:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    301d:	0f af c1             	imul   %ecx,%eax
    3020:	01 d0                	add    %edx,%eax
    3022:	01 d8                	add    %ebx,%eax
    3024:	c1 e8 10             	shr    $0x10,%eax
    3027:	89 c2                	mov    %eax,%edx
    3029:	8b 45 14             	mov    0x14(%ebp),%eax
    302c:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    302f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3032:	0f b6 00             	movzbl (%eax),%eax
    3035:	0f b6 c0             	movzbl %al,%eax
    3038:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    303c:	8b 55 bc             	mov    -0x44(%ebp),%edx
    303f:	0f af d0             	imul   %eax,%edx
    3042:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3045:	0f b6 00             	movzbl (%eax),%eax
    3048:	0f b6 c0             	movzbl %al,%eax
    304b:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    304f:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    3052:	0f af c1             	imul   %ecx,%eax
    3055:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    3058:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    305b:	0f b6 00             	movzbl (%eax),%eax
    305e:	0f b6 c0             	movzbl %al,%eax
    3061:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    3065:	8b 55 c8             	mov    -0x38(%ebp),%edx
    3068:	0f af d0             	imul   %eax,%edx
    306b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    306e:	0f b6 00             	movzbl (%eax),%eax
    3071:	0f b6 c0             	movzbl %al,%eax
    3074:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    3078:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    307b:	0f af c1             	imul   %ecx,%eax
    307e:	01 d0                	add    %edx,%eax
    3080:	01 d8                	add    %ebx,%eax
    3082:	c1 e8 10             	shr    $0x10,%eax
    3085:	89 c2                	mov    %eax,%edx
    3087:	8b 45 14             	mov    0x14(%ebp),%eax
    308a:	88 10                	mov    %dl,(%eax)
}
    308c:	90                   	nop
    308d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3090:	c9                   	leave  
    3091:	c3                   	ret    

00003092 <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    3092:	55                   	push   %ebp
    3093:	89 e5                	mov    %esp,%ebp
    3095:	53                   	push   %ebx
    3096:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    3099:	8b 45 08             	mov    0x8(%ebp),%eax
    309c:	8b 00                	mov    (%eax),%eax
    309e:	c1 e0 10             	shl    $0x10,%eax
    30a1:	89 c1                	mov    %eax,%ecx
    30a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    30a6:	8b 18                	mov    (%eax),%ebx
    30a8:	89 c8                	mov    %ecx,%eax
    30aa:	99                   	cltd   
    30ab:	f7 fb                	idiv   %ebx
    30ad:	83 c0 01             	add    $0x1,%eax
    30b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    30b3:	8b 45 08             	mov    0x8(%ebp),%eax
    30b6:	8b 40 04             	mov    0x4(%eax),%eax
    30b9:	c1 e0 10             	shl    $0x10,%eax
    30bc:	89 c1                	mov    %eax,%ecx
    30be:	8b 45 0c             	mov    0xc(%ebp),%eax
    30c1:	8b 58 04             	mov    0x4(%eax),%ebx
    30c4:	89 c8                	mov    %ecx,%eax
    30c6:	99                   	cltd   
    30c7:	f7 fb                	idiv   %ebx
    30c9:	83 c0 01             	add    $0x1,%eax
    30cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    30cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    30d2:	d1 f8                	sar    %eax
    30d4:	2d 00 80 00 00       	sub    $0x8000,%eax
    30d9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    30dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    30df:	d1 f8                	sar    %eax
    30e1:	2d 00 80 00 00       	sub    $0x8000,%eax
    30e6:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    30e9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    30ec:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    30ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    30f6:	eb 5d                	jmp    3155 <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    30f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    30fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    30fe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    3105:	eb 3a                	jmp    3141 <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    3107:	8b 45 0c             	mov    0xc(%ebp),%eax
    310a:	8b 48 08             	mov    0x8(%eax),%ecx
    310d:	8b 45 0c             	mov    0xc(%ebp),%eax
    3110:	8b 00                	mov    (%eax),%eax
    3112:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    3116:	89 c2                	mov    %eax,%edx
    3118:	8b 45 ec             	mov    -0x14(%ebp),%eax
    311b:	01 c2                	add    %eax,%edx
    311d:	89 d0                	mov    %edx,%eax
    311f:	01 c0                	add    %eax,%eax
    3121:	01 d0                	add    %edx,%eax
    3123:	01 c8                	add    %ecx,%eax
    3125:	50                   	push   %eax
    3126:	ff 75 f0             	pushl  -0x10(%ebp)
    3129:	ff 75 f8             	pushl  -0x8(%ebp)
    312c:	ff 75 08             	pushl  0x8(%ebp)
    312f:	e8 4d fd ff ff       	call   2e81 <mixColorInt>
    3134:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    3137:	8b 45 e8             	mov    -0x18(%ebp),%eax
    313a:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    313d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    3141:	8b 45 0c             	mov    0xc(%ebp),%eax
    3144:	8b 00                	mov    (%eax),%eax
    3146:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    3149:	7f bc                	jg     3107 <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    314b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    314e:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    3151:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3155:	8b 45 0c             	mov    0xc(%ebp),%eax
    3158:	8b 40 04             	mov    0x4(%eax),%eax
    315b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    315e:	7f 98                	jg     30f8 <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    3160:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3165:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3168:	c9                   	leave  
    3169:	c3                   	ret    

0000316a <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    316a:	55                   	push   %ebp
    316b:	89 e5                	mov    %esp,%ebp
    316d:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    3170:	8b 45 08             	mov    0x8(%ebp),%eax
    3173:	8b 00                	mov    (%eax),%eax
    3175:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    3178:	db 45 e4             	fildl  -0x1c(%ebp)
    317b:	8b 45 0c             	mov    0xc(%ebp),%eax
    317e:	8b 00                	mov    (%eax),%eax
    3180:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    3183:	db 45 e4             	fildl  -0x1c(%ebp)
    3186:	de f9                	fdivrp %st,%st(1)
    3188:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    318b:	8b 45 08             	mov    0x8(%ebp),%eax
    318e:	8b 40 04             	mov    0x4(%eax),%eax
    3191:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    3194:	db 45 e4             	fildl  -0x1c(%ebp)
    3197:	8b 45 0c             	mov    0xc(%ebp),%eax
    319a:	8b 40 04             	mov    0x4(%eax),%eax
    319d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    31a0:	db 45 e4             	fildl  -0x1c(%ebp)
    31a3:	de f9                	fdivrp %st,%st(1)
    31a5:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    31a8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    31af:	eb 5e                	jmp    320f <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    31b1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    31b8:	eb 47                	jmp    3201 <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    31ba:	db 45 f8             	fildl  -0x8(%ebp)
    31bd:	d8 4d f4             	fmuls  -0xc(%ebp)
    31c0:	d9 7d ee             	fnstcw -0x12(%ebp)
    31c3:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    31c7:	b4 0c                	mov    $0xc,%ah
    31c9:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    31cd:	d9 6d ec             	fldcw  -0x14(%ebp)
    31d0:	db 5d e8             	fistpl -0x18(%ebp)
    31d3:	d9 6d ee             	fldcw  -0x12(%ebp)
    31d6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    31d9:	db 45 fc             	fildl  -0x4(%ebp)
    31dc:	d8 4d f0             	fmuls  -0x10(%ebp)
    31df:	d9 6d ec             	fldcw  -0x14(%ebp)
    31e2:	db 5d e8             	fistpl -0x18(%ebp)
    31e5:	d9 6d ee             	fldcw  -0x12(%ebp)
    31e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    31eb:	6a 00                	push   $0x0
    31ed:	52                   	push   %edx
    31ee:	50                   	push   %eax
    31ef:	ff 75 08             	pushl  0x8(%ebp)
    31f2:	e8 10 f9 ff ff       	call   2b07 <getColor>
    31f7:	83 c4 10             	add    $0x10,%esp
    31fa:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    31fd:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    3201:	8b 45 0c             	mov    0xc(%ebp),%eax
    3204:	8b 00                	mov    (%eax),%eax
    3206:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    3209:	7f af                	jg     31ba <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    320b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    320f:	8b 45 0c             	mov    0xc(%ebp),%eax
    3212:	8b 40 04             	mov    0x4(%eax),%eax
    3215:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    3218:	7f 97                	jg     31b1 <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    321a:	b8 01 00 00 00       	mov    $0x1,%eax
}
    321f:	c9                   	leave  
    3220:	c3                   	ret    

00003221 <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    3221:	55                   	push   %ebp
    3222:	89 e5                	mov    %esp,%ebp
    3224:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    3227:	8b 45 08             	mov    0x8(%ebp),%eax
    322a:	8b 00                	mov    (%eax),%eax
    322c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    322f:	db 45 e0             	fildl  -0x20(%ebp)
    3232:	d9 5d e0             	fstps  -0x20(%ebp)
    3235:	83 ec 0c             	sub    $0xc,%esp
    3238:	ff 75 10             	pushl  0x10(%ebp)
    323b:	e8 6b e2 ff ff       	call   14ab <cos>
    3240:	83 c4 10             	add    $0x10,%esp
    3243:	d9 5d dc             	fstps  -0x24(%ebp)
    3246:	8b 45 dc             	mov    -0x24(%ebp),%eax
    3249:	83 ec 0c             	sub    $0xc,%esp
    324c:	50                   	push   %eax
    324d:	e8 90 e1 ff ff       	call   13e2 <abs>
    3252:	83 c4 10             	add    $0x10,%esp
    3255:	d8 4d e0             	fmuls  -0x20(%ebp)
    3258:	d9 5d e0             	fstps  -0x20(%ebp)
    325b:	8b 45 0c             	mov    0xc(%ebp),%eax
    325e:	8b 00                	mov    (%eax),%eax
    3260:	89 45 dc             	mov    %eax,-0x24(%ebp)
    3263:	db 45 dc             	fildl  -0x24(%ebp)
    3266:	d9 5d dc             	fstps  -0x24(%ebp)
    3269:	83 ec 0c             	sub    $0xc,%esp
    326c:	ff 75 10             	pushl  0x10(%ebp)
    326f:	e8 da e3 ff ff       	call   164e <sin>
    3274:	83 c4 10             	add    $0x10,%esp
    3277:	d9 5d d8             	fstps  -0x28(%ebp)
    327a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    327d:	83 ec 0c             	sub    $0xc,%esp
    3280:	50                   	push   %eax
    3281:	e8 5c e1 ff ff       	call   13e2 <abs>
    3286:	83 c4 10             	add    $0x10,%esp
    3289:	d8 4d dc             	fmuls  -0x24(%ebp)
    328c:	d8 45 e0             	fadds  -0x20(%ebp)
    328f:	d9 7d e6             	fnstcw -0x1a(%ebp)
    3292:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    3296:	b4 0c                	mov    $0xc,%ah
    3298:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    329c:	d9 6d e4             	fldcw  -0x1c(%ebp)
    329f:	db 5d f4             	fistpl -0xc(%ebp)
    32a2:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    32a5:	8b 45 08             	mov    0x8(%ebp),%eax
    32a8:	8b 00                	mov    (%eax),%eax
    32aa:	89 45 e0             	mov    %eax,-0x20(%ebp)
    32ad:	db 45 e0             	fildl  -0x20(%ebp)
    32b0:	d9 5d e0             	fstps  -0x20(%ebp)
    32b3:	83 ec 0c             	sub    $0xc,%esp
    32b6:	ff 75 10             	pushl  0x10(%ebp)
    32b9:	e8 90 e3 ff ff       	call   164e <sin>
    32be:	83 c4 10             	add    $0x10,%esp
    32c1:	d9 5d dc             	fstps  -0x24(%ebp)
    32c4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    32c7:	83 ec 0c             	sub    $0xc,%esp
    32ca:	50                   	push   %eax
    32cb:	e8 12 e1 ff ff       	call   13e2 <abs>
    32d0:	83 c4 10             	add    $0x10,%esp
    32d3:	d8 4d e0             	fmuls  -0x20(%ebp)
    32d6:	d9 5d e0             	fstps  -0x20(%ebp)
    32d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    32dc:	8b 00                	mov    (%eax),%eax
    32de:	89 45 dc             	mov    %eax,-0x24(%ebp)
    32e1:	db 45 dc             	fildl  -0x24(%ebp)
    32e4:	d9 5d dc             	fstps  -0x24(%ebp)
    32e7:	83 ec 0c             	sub    $0xc,%esp
    32ea:	ff 75 10             	pushl  0x10(%ebp)
    32ed:	e8 b9 e1 ff ff       	call   14ab <cos>
    32f2:	83 c4 10             	add    $0x10,%esp
    32f5:	d9 5d d8             	fstps  -0x28(%ebp)
    32f8:	8b 45 d8             	mov    -0x28(%ebp),%eax
    32fb:	83 ec 0c             	sub    $0xc,%esp
    32fe:	50                   	push   %eax
    32ff:	e8 de e0 ff ff       	call   13e2 <abs>
    3304:	83 c4 10             	add    $0x10,%esp
    3307:	d8 4d dc             	fmuls  -0x24(%ebp)
    330a:	d8 45 e0             	fadds  -0x20(%ebp)
    330d:	d9 7d e6             	fnstcw -0x1a(%ebp)
    3310:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    3314:	b4 0c                	mov    $0xc,%ah
    3316:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    331a:	d9 6d e4             	fldcw  -0x1c(%ebp)
    331d:	db 5d f0             	fistpl -0x10(%ebp)
    3320:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    3323:	8b 45 0c             	mov    0xc(%ebp),%eax
    3326:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3329:	89 10                	mov    %edx,(%eax)
    *width = w;
    332b:	8b 45 08             	mov    0x8(%ebp),%eax
    332e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3331:	89 10                	mov    %edx,(%eax)
    return 1;
    3333:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3338:	c9                   	leave  
    3339:	c3                   	ret    

0000333a <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    333a:	55                   	push   %ebp
    333b:	89 e5                	mov    %esp,%ebp
    333d:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    3340:	8b 45 08             	mov    0x8(%ebp),%eax
    3343:	8b 40 04             	mov    0x4(%eax),%eax
    3346:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    3349:	db 45 c4             	fildl  -0x3c(%ebp)
    334c:	d9 05 e4 a8 01 00    	flds   0x1a8e4
    3352:	de f9                	fdivrp %st,%st(1)
    3354:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    3357:	8b 45 08             	mov    0x8(%ebp),%eax
    335a:	8b 00                	mov    (%eax),%eax
    335c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    335f:	db 45 c4             	fildl  -0x3c(%ebp)
    3362:	d9 05 e4 a8 01 00    	flds   0x1a8e4
    3368:	de f9                	fdivrp %st,%st(1)
    336a:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    336d:	8b 45 0c             	mov    0xc(%ebp),%eax
    3370:	8b 50 04             	mov    0x4(%eax),%edx
    3373:	8b 45 08             	mov    0x8(%ebp),%eax
    3376:	8b 40 04             	mov    0x4(%eax),%eax
    3379:	29 c2                	sub    %eax,%edx
    337b:	89 d0                	mov    %edx,%eax
    337d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    3380:	db 45 c4             	fildl  -0x3c(%ebp)
    3383:	d9 05 e4 a8 01 00    	flds   0x1a8e4
    3389:	de f9                	fdivrp %st,%st(1)
    338b:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    338e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3391:	8b 10                	mov    (%eax),%edx
    3393:	8b 45 08             	mov    0x8(%ebp),%eax
    3396:	8b 00                	mov    (%eax),%eax
    3398:	29 c2                	sub    %eax,%edx
    339a:	89 d0                	mov    %edx,%eax
    339c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    339f:	db 45 c4             	fildl  -0x3c(%ebp)
    33a2:	d9 05 e4 a8 01 00    	flds   0x1a8e4
    33a8:	de f9                	fdivrp %st,%st(1)
    33aa:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    33ad:	d9 45 10             	flds   0x10(%ebp)
    33b0:	d9 e0                	fchs   
    33b2:	83 ec 0c             	sub    $0xc,%esp
    33b5:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    33b9:	d9 1c 24             	fstps  (%esp)
    33bc:	e8 ea e0 ff ff       	call   14ab <cos>
    33c1:	83 c4 10             	add    $0x10,%esp
    33c4:	d9 5d c4             	fstps  -0x3c(%ebp)
    33c7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    33ca:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    33cd:	d9 45 10             	flds   0x10(%ebp)
    33d0:	d9 e0                	fchs   
    33d2:	83 ec 0c             	sub    $0xc,%esp
    33d5:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    33d9:	d9 1c 24             	fstps  (%esp)
    33dc:	e8 6d e2 ff ff       	call   164e <sin>
    33e1:	83 c4 10             	add    $0x10,%esp
    33e4:	d9 5d c4             	fstps  -0x3c(%ebp)
    33e7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    33ea:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    33ed:	d9 ee                	fldz   
    33ef:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    33f2:	d9 ee                	fldz   
    33f4:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    33f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    33fe:	e9 28 01 00 00       	jmp    352b <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    3403:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    340a:	e9 0a 01 00 00       	jmp    3519 <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    340f:	db 45 f4             	fildl  -0xc(%ebp)
    3412:	d8 65 e4             	fsubs  -0x1c(%ebp)
    3415:	d8 65 ec             	fsubs  -0x14(%ebp)
    3418:	d8 4d dc             	fmuls  -0x24(%ebp)
    341b:	db 45 f0             	fildl  -0x10(%ebp)
    341e:	d8 65 e0             	fsubs  -0x20(%ebp)
    3421:	d8 65 e8             	fsubs  -0x18(%ebp)
    3424:	d8 4d d8             	fmuls  -0x28(%ebp)
    3427:	de c1                	faddp  %st,%st(1)
    3429:	d8 45 ec             	fadds  -0x14(%ebp)
    342c:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    342f:	db 45 f0             	fildl  -0x10(%ebp)
    3432:	d8 65 e0             	fsubs  -0x20(%ebp)
    3435:	d8 65 e8             	fsubs  -0x18(%ebp)
    3438:	d8 4d dc             	fmuls  -0x24(%ebp)
    343b:	db 45 f4             	fildl  -0xc(%ebp)
    343e:	d8 65 e4             	fsubs  -0x1c(%ebp)
    3441:	d8 65 ec             	fsubs  -0x14(%ebp)
    3444:	d8 4d d8             	fmuls  -0x28(%ebp)
    3447:	de e9                	fsubrp %st,%st(1)
    3449:	d8 45 e8             	fadds  -0x18(%ebp)
    344c:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    344f:	d9 45 d4             	flds   -0x2c(%ebp)
    3452:	d9 ee                	fldz   
    3454:	d9 c9                	fxch   %st(1)
    3456:	df e9                	fucomip %st(1),%st
    3458:	dd d8                	fstp   %st(0)
    345a:	0f 93 c0             	setae  %al
    345d:	83 f0 01             	xor    $0x1,%eax
    3460:	84 c0                	test   %al,%al
    3462:	75 52                	jne    34b6 <picTurn+0x17c>
    3464:	8b 45 08             	mov    0x8(%ebp),%eax
    3467:	8b 40 04             	mov    0x4(%eax),%eax
    346a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    346d:	db 45 c4             	fildl  -0x3c(%ebp)
    3470:	d9 45 d4             	flds   -0x2c(%ebp)
    3473:	d9 c9                	fxch   %st(1)
    3475:	df e9                	fucomip %st(1),%st
    3477:	dd d8                	fstp   %st(0)
    3479:	0f 97 c0             	seta   %al
    347c:	83 f0 01             	xor    $0x1,%eax
    347f:	84 c0                	test   %al,%al
    3481:	75 33                	jne    34b6 <picTurn+0x17c>
    3483:	d9 45 d0             	flds   -0x30(%ebp)
    3486:	d9 ee                	fldz   
    3488:	d9 c9                	fxch   %st(1)
    348a:	df e9                	fucomip %st(1),%st
    348c:	dd d8                	fstp   %st(0)
    348e:	0f 93 c0             	setae  %al
    3491:	83 f0 01             	xor    $0x1,%eax
    3494:	84 c0                	test   %al,%al
    3496:	75 1e                	jne    34b6 <picTurn+0x17c>
    3498:	8b 45 08             	mov    0x8(%ebp),%eax
    349b:	8b 00                	mov    (%eax),%eax
    349d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    34a0:	db 45 c4             	fildl  -0x3c(%ebp)
    34a3:	d9 45 d0             	flds   -0x30(%ebp)
    34a6:	d9 c9                	fxch   %st(1)
    34a8:	df e9                	fucomip %st(1),%st
    34aa:	dd d8                	fstp   %st(0)
    34ac:	0f 97 c0             	seta   %al
    34af:	83 f0 01             	xor    $0x1,%eax
    34b2:	84 c0                	test   %al,%al
    34b4:	74 2f                	je     34e5 <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    34b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    34b9:	8b 48 08             	mov    0x8(%eax),%ecx
    34bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    34bf:	8b 00                	mov    (%eax),%eax
    34c1:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    34c5:	89 c2                	mov    %eax,%edx
    34c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    34ca:	01 c2                	add    %eax,%edx
    34cc:	89 d0                	mov    %edx,%eax
    34ce:	01 c0                	add    %eax,%eax
    34d0:	01 d0                	add    %edx,%eax
    34d2:	01 c8                	add    %ecx,%eax
    34d4:	83 ec 08             	sub    $0x8,%esp
    34d7:	50                   	push   %eax
    34d8:	68 61 ef 01 00       	push   $0x1ef61
    34dd:	e8 9f f6 ff ff       	call   2b81 <setColor>
    34e2:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    34e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    34e8:	8b 48 08             	mov    0x8(%eax),%ecx
    34eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    34ee:	8b 00                	mov    (%eax),%eax
    34f0:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    34f4:	89 c2                	mov    %eax,%edx
    34f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    34f9:	01 c2                	add    %eax,%edx
    34fb:	89 d0                	mov    %edx,%eax
    34fd:	01 c0                	add    %eax,%eax
    34ff:	01 d0                	add    %edx,%eax
    3501:	01 c8                	add    %ecx,%eax
    3503:	50                   	push   %eax
    3504:	ff 75 d0             	pushl  -0x30(%ebp)
    3507:	ff 75 d4             	pushl  -0x2c(%ebp)
    350a:	ff 75 08             	pushl  0x8(%ebp)
    350d:	e8 9e f6 ff ff       	call   2bb0 <mixColor>
    3512:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    3515:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    3519:	8b 45 0c             	mov    0xc(%ebp),%eax
    351c:	8b 00                	mov    (%eax),%eax
    351e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3521:	0f 8f e8 fe ff ff    	jg     340f <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    3527:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    352b:	8b 45 0c             	mov    0xc(%ebp),%eax
    352e:	8b 40 04             	mov    0x4(%eax),%eax
    3531:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    3534:	0f 8f c9 fe ff ff    	jg     3403 <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    353a:	b8 01 00 00 00       	mov    $0x1,%eax
}
    353f:	c9                   	leave  
    3540:	c3                   	ret    

00003541 <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    3541:	55                   	push   %ebp
    3542:	89 e5                	mov    %esp,%ebp
    3544:	53                   	push   %ebx
    3545:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    3548:	8b 45 08             	mov    0x8(%ebp),%eax
    354b:	8b 10                	mov    (%eax),%edx
    354d:	8b 45 0c             	mov    0xc(%ebp),%eax
    3550:	8b 00                	mov    (%eax),%eax
    3552:	39 c2                	cmp    %eax,%edx
    3554:	75 10                	jne    3566 <picRollingOver+0x25>
    3556:	8b 45 08             	mov    0x8(%ebp),%eax
    3559:	8b 50 04             	mov    0x4(%eax),%edx
    355c:	8b 45 0c             	mov    0xc(%ebp),%eax
    355f:	8b 40 04             	mov    0x4(%eax),%eax
    3562:	39 c2                	cmp    %eax,%edx
    3564:	74 0a                	je     3570 <picRollingOver+0x2f>
        return 0;
    3566:	b8 00 00 00 00       	mov    $0x0,%eax
    356b:	e9 88 00 00 00       	jmp    35f8 <picRollingOver+0xb7>

    int h = src->height;
    3570:	8b 45 08             	mov    0x8(%ebp),%eax
    3573:	8b 40 04             	mov    0x4(%eax),%eax
    3576:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    3579:	8b 45 08             	mov    0x8(%ebp),%eax
    357c:	8b 00                	mov    (%eax),%eax
    357e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    3581:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    3588:	eb 61                	jmp    35eb <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    358a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3591:	eb 4c                	jmp    35df <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    3593:	8b 45 0c             	mov    0xc(%ebp),%eax
    3596:	8b 48 08             	mov    0x8(%eax),%ecx
    3599:	8b 45 f0             	mov    -0x10(%ebp),%eax
    359c:	2b 45 f8             	sub    -0x8(%ebp),%eax
    359f:	83 e8 01             	sub    $0x1,%eax
    35a2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    35a6:	89 c2                	mov    %eax,%edx
    35a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    35ab:	01 c2                	add    %eax,%edx
    35ad:	89 d0                	mov    %edx,%eax
    35af:	01 c0                	add    %eax,%eax
    35b1:	01 d0                	add    %edx,%eax
    35b3:	01 c1                	add    %eax,%ecx
    35b5:	8b 45 08             	mov    0x8(%ebp),%eax
    35b8:	8b 58 08             	mov    0x8(%eax),%ebx
    35bb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    35be:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    35c2:	89 c2                	mov    %eax,%edx
    35c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    35c7:	01 c2                	add    %eax,%edx
    35c9:	89 d0                	mov    %edx,%eax
    35cb:	01 c0                	add    %eax,%eax
    35cd:	01 d0                	add    %edx,%eax
    35cf:	01 d8                	add    %ebx,%eax
    35d1:	51                   	push   %ecx
    35d2:	50                   	push   %eax
    35d3:	e8 a9 f5 ff ff       	call   2b81 <setColor>
    35d8:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    35db:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    35df:	8b 45 f4             	mov    -0xc(%ebp),%eax
    35e2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    35e5:	7c ac                	jl     3593 <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    35e7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    35eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    35ee:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    35f1:	7c 97                	jl     358a <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    35f3:	b8 01 00 00 00       	mov    $0x1,%eax
}
    35f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    35fb:	c9                   	leave  
    35fc:	c3                   	ret    

000035fd <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    35fd:	55                   	push   %ebp
    35fe:	89 e5                	mov    %esp,%ebp
    3600:	53                   	push   %ebx
    3601:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    3604:	8b 45 08             	mov    0x8(%ebp),%eax
    3607:	8b 10                	mov    (%eax),%edx
    3609:	8b 45 0c             	mov    0xc(%ebp),%eax
    360c:	8b 00                	mov    (%eax),%eax
    360e:	39 c2                	cmp    %eax,%edx
    3610:	75 10                	jne    3622 <picTurnAround+0x25>
    3612:	8b 45 08             	mov    0x8(%ebp),%eax
    3615:	8b 50 04             	mov    0x4(%eax),%edx
    3618:	8b 45 0c             	mov    0xc(%ebp),%eax
    361b:	8b 40 04             	mov    0x4(%eax),%eax
    361e:	39 c2                	cmp    %eax,%edx
    3620:	74 0a                	je     362c <picTurnAround+0x2f>
        return 0;
    3622:	b8 00 00 00 00       	mov    $0x0,%eax
    3627:	e9 88 00 00 00       	jmp    36b4 <picTurnAround+0xb7>

    int h = src->height;
    362c:	8b 45 08             	mov    0x8(%ebp),%eax
    362f:	8b 40 04             	mov    0x4(%eax),%eax
    3632:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    3635:	8b 45 08             	mov    0x8(%ebp),%eax
    3638:	8b 00                	mov    (%eax),%eax
    363a:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    363d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    3644:	eb 61                	jmp    36a7 <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    3646:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    364d:	eb 4c                	jmp    369b <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    364f:	8b 45 0c             	mov    0xc(%ebp),%eax
    3652:	8b 48 08             	mov    0x8(%eax),%ecx
    3655:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3658:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    365c:	89 c2                	mov    %eax,%edx
    365e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3661:	2b 45 f4             	sub    -0xc(%ebp),%eax
    3664:	01 c2                	add    %eax,%edx
    3666:	89 d0                	mov    %edx,%eax
    3668:	01 c0                	add    %eax,%eax
    366a:	01 d0                	add    %edx,%eax
    366c:	83 e8 03             	sub    $0x3,%eax
    366f:	01 c1                	add    %eax,%ecx
    3671:	8b 45 08             	mov    0x8(%ebp),%eax
    3674:	8b 58 08             	mov    0x8(%eax),%ebx
    3677:	8b 45 f8             	mov    -0x8(%ebp),%eax
    367a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    367e:	89 c2                	mov    %eax,%edx
    3680:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3683:	01 c2                	add    %eax,%edx
    3685:	89 d0                	mov    %edx,%eax
    3687:	01 c0                	add    %eax,%eax
    3689:	01 d0                	add    %edx,%eax
    368b:	01 d8                	add    %ebx,%eax
    368d:	51                   	push   %ecx
    368e:	50                   	push   %eax
    368f:	e8 ed f4 ff ff       	call   2b81 <setColor>
    3694:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    3697:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    369b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    369e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    36a1:	7c ac                	jl     364f <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    36a3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    36a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    36aa:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    36ad:	7c 97                	jl     3646 <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    36af:	b8 01 00 00 00       	mov    $0x1,%eax
}
    36b4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    36b7:	c9                   	leave  
    36b8:	c3                   	ret    

000036b9 <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    36b9:	55                   	push   %ebp
    36ba:	89 e5                	mov    %esp,%ebp
    36bc:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    36bf:	83 ec 0c             	sub    $0xc,%esp
    36c2:	ff 75 08             	pushl  0x8(%ebp)
    36c5:	e8 c5 d5 ff ff       	call   c8f <strlen>
    36ca:	83 c4 10             	add    $0x10,%esp
    36cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    36d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    36d3:	8d 50 ff             	lea    -0x1(%eax),%edx
    36d6:	8b 45 08             	mov    0x8(%ebp),%eax
    36d9:	01 d0                	add    %edx,%eax
    36db:	0f b6 00             	movzbl (%eax),%eax
    36de:	3c 67                	cmp    $0x67,%al
    36e0:	75 2b                	jne    370d <type+0x54>
    36e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    36e5:	8d 50 fe             	lea    -0x2(%eax),%edx
    36e8:	8b 45 08             	mov    0x8(%ebp),%eax
    36eb:	01 d0                	add    %edx,%eax
    36ed:	0f b6 00             	movzbl (%eax),%eax
    36f0:	3c 70                	cmp    $0x70,%al
    36f2:	75 19                	jne    370d <type+0x54>
    36f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    36f7:	8d 50 fd             	lea    -0x3(%eax),%edx
    36fa:	8b 45 08             	mov    0x8(%ebp),%eax
    36fd:	01 d0                	add    %edx,%eax
    36ff:	0f b6 00             	movzbl (%eax),%eax
    3702:	3c 6a                	cmp    $0x6a,%al
    3704:	75 07                	jne    370d <type+0x54>
    3706:	b8 00 00 00 00       	mov    $0x0,%eax
    370b:	eb 7f                	jmp    378c <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    370d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3710:	8d 50 ff             	lea    -0x1(%eax),%edx
    3713:	8b 45 08             	mov    0x8(%ebp),%eax
    3716:	01 d0                	add    %edx,%eax
    3718:	0f b6 00             	movzbl (%eax),%eax
    371b:	3c 70                	cmp    $0x70,%al
    371d:	75 2b                	jne    374a <type+0x91>
    371f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3722:	8d 50 fe             	lea    -0x2(%eax),%edx
    3725:	8b 45 08             	mov    0x8(%ebp),%eax
    3728:	01 d0                	add    %edx,%eax
    372a:	0f b6 00             	movzbl (%eax),%eax
    372d:	3c 6d                	cmp    $0x6d,%al
    372f:	75 19                	jne    374a <type+0x91>
    3731:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3734:	8d 50 fd             	lea    -0x3(%eax),%edx
    3737:	8b 45 08             	mov    0x8(%ebp),%eax
    373a:	01 d0                	add    %edx,%eax
    373c:	0f b6 00             	movzbl (%eax),%eax
    373f:	3c 62                	cmp    $0x62,%al
    3741:	75 07                	jne    374a <type+0x91>
    3743:	b8 01 00 00 00       	mov    $0x1,%eax
    3748:	eb 42                	jmp    378c <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    374a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    374d:	8d 50 ff             	lea    -0x1(%eax),%edx
    3750:	8b 45 08             	mov    0x8(%ebp),%eax
    3753:	01 d0                	add    %edx,%eax
    3755:	0f b6 00             	movzbl (%eax),%eax
    3758:	3c 67                	cmp    $0x67,%al
    375a:	75 2b                	jne    3787 <type+0xce>
    375c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    375f:	8d 50 fe             	lea    -0x2(%eax),%edx
    3762:	8b 45 08             	mov    0x8(%ebp),%eax
    3765:	01 d0                	add    %edx,%eax
    3767:	0f b6 00             	movzbl (%eax),%eax
    376a:	3c 6e                	cmp    $0x6e,%al
    376c:	75 19                	jne    3787 <type+0xce>
    376e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3771:	8d 50 fd             	lea    -0x3(%eax),%edx
    3774:	8b 45 08             	mov    0x8(%ebp),%eax
    3777:	01 d0                	add    %edx,%eax
    3779:	0f b6 00             	movzbl (%eax),%eax
    377c:	3c 70                	cmp    $0x70,%al
    377e:	75 07                	jne    3787 <type+0xce>
    3780:	b8 02 00 00 00       	mov    $0x2,%eax
    3785:	eb 05                	jmp    378c <type+0xd3>
    else return NONE;
    3787:	b8 03 00 00 00       	mov    $0x3,%eax
}
    378c:	c9                   	leave  
    378d:	c3                   	ret    

0000378e <LoadBmp>:

PBitmap LoadBmp(char* filename){
    378e:	55                   	push   %ebp
    378f:	89 e5                	mov    %esp,%ebp
    3791:	56                   	push   %esi
    3792:	53                   	push   %ebx
    3793:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    3796:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    379d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    37a4:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    37ab:	83 ec 08             	sub    $0x8,%esp
    37ae:	6a 00                	push   $0x0
    37b0:	ff 75 0c             	pushl  0xc(%ebp)
    37b3:	e8 d9 d6 ff ff       	call   e91 <open>
    37b8:	83 c4 10             	add    $0x10,%esp
    37bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    37be:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    37c2:	79 2c                	jns    37f0 <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    37c4:	83 ec 08             	sub    $0x8,%esp
    37c7:	ff 75 0c             	pushl  0xc(%ebp)
    37ca:	68 e8 a8 01 00       	push   $0x1a8e8
    37cf:	e8 24 d8 ff ff       	call   ff8 <printf>
    37d4:	83 c4 10             	add    $0x10,%esp
        return bmp;
    37d7:	8b 45 08             	mov    0x8(%ebp),%eax
    37da:	8b 55 b8             	mov    -0x48(%ebp),%edx
    37dd:	89 10                	mov    %edx,(%eax)
    37df:	8b 55 bc             	mov    -0x44(%ebp),%edx
    37e2:	89 50 04             	mov    %edx,0x4(%eax)
    37e5:	8b 55 c0             	mov    -0x40(%ebp),%edx
    37e8:	89 50 08             	mov    %edx,0x8(%eax)
    37eb:	e9 2d 02 00 00       	jmp    3a1d <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    37f0:	83 ec 04             	sub    $0x4,%esp
    37f3:	6a 0e                	push   $0xe
    37f5:	8d 45 aa             	lea    -0x56(%ebp),%eax
    37f8:	50                   	push   %eax
    37f9:	ff 75 ec             	pushl  -0x14(%ebp)
    37fc:	e8 68 d6 ff ff       	call   e69 <read>
    3801:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    3804:	83 ec 04             	sub    $0x4,%esp
    3807:	6a 28                	push   $0x28
    3809:	8d 45 82             	lea    -0x7e(%ebp),%eax
    380c:	50                   	push   %eax
    380d:	ff 75 ec             	pushl  -0x14(%ebp)
    3810:	e8 54 d6 ff ff       	call   e69 <read>
    3815:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    3818:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    381c:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    381f:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    3823:	0f b7 d8             	movzwl %ax,%ebx
    3826:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    3829:	8b 55 ac             	mov    -0x54(%ebp),%edx
    382c:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    3830:	0f b7 c0             	movzwl %ax,%eax
    3833:	83 ec 04             	sub    $0x4,%esp
    3836:	6a 36                	push   $0x36
    3838:	56                   	push   %esi
    3839:	53                   	push   %ebx
    383a:	51                   	push   %ecx
    383b:	52                   	push   %edx
    383c:	50                   	push   %eax
    383d:	68 f8 a8 01 00       	push   $0x1a8f8
    3842:	e8 b1 d7 ff ff       	call   ff8 <printf>
    3847:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    384a:	8b 45 86             	mov    -0x7a(%ebp),%eax
    384d:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    3850:	8b 45 8a             	mov    -0x76(%ebp),%eax
    3853:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    3856:	8b 55 b8             	mov    -0x48(%ebp),%edx
    3859:	8b 45 bc             	mov    -0x44(%ebp),%eax
    385c:	0f af c2             	imul   %edx,%eax
    385f:	89 c2                	mov    %eax,%edx
    3861:	89 d0                	mov    %edx,%eax
    3863:	01 c0                	add    %eax,%eax
    3865:	01 d0                	add    %edx,%eax
    3867:	83 ec 0c             	sub    $0xc,%esp
    386a:	50                   	push   %eax
    386b:	e8 5b da ff ff       	call   12cb <malloc>
    3870:	83 c4 10             	add    $0x10,%esp
    3873:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    3876:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    387a:	0f b7 c0             	movzwl %ax,%eax
    387d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    3880:	8b 45 b8             	mov    -0x48(%ebp),%eax
    3883:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    3887:	83 c0 1f             	add    $0x1f,%eax
    388a:	c1 f8 05             	sar    $0x5,%eax
    388d:	c1 e0 02             	shl    $0x2,%eax
    3890:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    3893:	8b 45 bc             	mov    -0x44(%ebp),%eax
    3896:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    389a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    389d:	8b 55 bc             	mov    -0x44(%ebp),%edx
    38a0:	8b 45 b8             	mov    -0x48(%ebp),%eax
    38a3:	83 ec 08             	sub    $0x8,%esp
    38a6:	52                   	push   %edx
    38a7:	50                   	push   %eax
    38a8:	ff 75 e8             	pushl  -0x18(%ebp)
    38ab:	ff 75 e0             	pushl  -0x20(%ebp)
    38ae:	ff 75 e4             	pushl  -0x1c(%ebp)
    38b1:	68 20 a9 01 00       	push   $0x1a920
    38b6:	e8 3d d7 ff ff       	call   ff8 <printf>
    38bb:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    38be:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    38c1:	83 e8 36             	sub    $0x36,%eax
    38c4:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    38c7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    38ca:	83 ec 0c             	sub    $0xc,%esp
    38cd:	50                   	push   %eax
    38ce:	e8 f8 d9 ff ff       	call   12cb <malloc>
    38d3:	83 c4 10             	add    $0x10,%esp
    38d6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    38d9:	83 ec 04             	sub    $0x4,%esp
    38dc:	ff 75 dc             	pushl  -0x24(%ebp)
    38df:	ff 75 d8             	pushl  -0x28(%ebp)
    38e2:	ff 75 ec             	pushl  -0x14(%ebp)
    38e5:	e8 7f d5 ff ff       	call   e69 <read>
    38ea:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    38ed:	8b 45 ac             	mov    -0x54(%ebp),%eax
    38f0:	83 ec 0c             	sub    $0xc,%esp
    38f3:	50                   	push   %eax
    38f4:	e8 d2 d9 ff ff       	call   12cb <malloc>
    38f9:	83 c4 10             	add    $0x10,%esp
    38fc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    38ff:	8b 45 ac             	mov    -0x54(%ebp),%eax
    3902:	83 ec 04             	sub    $0x4,%esp
    3905:	50                   	push   %eax
    3906:	ff 75 d4             	pushl  -0x2c(%ebp)
    3909:	ff 75 ec             	pushl  -0x14(%ebp)
    390c:	e8 58 d5 ff ff       	call   e69 <read>
    3911:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    3914:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    3918:	66 c1 e8 03          	shr    $0x3,%ax
    391c:	0f b7 c0             	movzwl %ax,%eax
    391f:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    3922:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3929:	e9 c1 00 00 00       	jmp    39ef <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    392e:	8b 45 bc             	mov    -0x44(%ebp),%eax
    3931:	2b 45 f4             	sub    -0xc(%ebp),%eax
    3934:	8d 50 ff             	lea    -0x1(%eax),%edx
    3937:	8b 45 b8             	mov    -0x48(%ebp),%eax
    393a:	0f af c2             	imul   %edx,%eax
    393d:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    3940:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3943:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    3947:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    394a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    3951:	e9 89 00 00 00       	jmp    39df <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    3956:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3959:	83 c0 01             	add    $0x1,%eax
    395c:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    3960:	89 c2                	mov    %eax,%edx
    3962:	8b 45 c8             	mov    -0x38(%ebp),%eax
    3965:	01 d0                	add    %edx,%eax
    3967:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    396a:	8b 55 c0             	mov    -0x40(%ebp),%edx
    396d:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    3970:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3973:	01 c8                	add    %ecx,%eax
    3975:	89 c1                	mov    %eax,%ecx
    3977:	89 c8                	mov    %ecx,%eax
    3979:	01 c0                	add    %eax,%eax
    397b:	01 c8                	add    %ecx,%eax
    397d:	01 c2                	add    %eax,%edx
    397f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    3982:	8d 48 ff             	lea    -0x1(%eax),%ecx
    3985:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    3988:	01 c8                	add    %ecx,%eax
    398a:	0f b6 00             	movzbl (%eax),%eax
    398d:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    3990:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3993:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    3996:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3999:	01 c8                	add    %ecx,%eax
    399b:	89 c1                	mov    %eax,%ecx
    399d:	89 c8                	mov    %ecx,%eax
    399f:	01 c0                	add    %eax,%eax
    39a1:	01 c8                	add    %ecx,%eax
    39a3:	01 c2                	add    %eax,%edx
    39a5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    39a8:	8d 48 fe             	lea    -0x2(%eax),%ecx
    39ab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    39ae:	01 c8                	add    %ecx,%eax
    39b0:	0f b6 00             	movzbl (%eax),%eax
    39b3:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    39b6:	8b 55 c0             	mov    -0x40(%ebp),%edx
    39b9:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    39bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    39bf:	01 c8                	add    %ecx,%eax
    39c1:	89 c1                	mov    %eax,%ecx
    39c3:	89 c8                	mov    %ecx,%eax
    39c5:	01 c0                	add    %eax,%eax
    39c7:	01 c8                	add    %ecx,%eax
    39c9:	01 c2                	add    %eax,%edx
    39cb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    39ce:	8d 48 fd             	lea    -0x3(%eax),%ecx
    39d1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    39d4:	01 c8                	add    %ecx,%eax
    39d6:	0f b6 00             	movzbl (%eax),%eax
    39d9:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    39db:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    39df:	8b 45 b8             	mov    -0x48(%ebp),%eax
    39e2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    39e5:	0f 8f 6b ff ff ff    	jg     3956 <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    39eb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    39ef:	8b 45 bc             	mov    -0x44(%ebp),%eax
    39f2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    39f5:	0f 8f 33 ff ff ff    	jg     392e <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    39fb:	83 ec 0c             	sub    $0xc,%esp
    39fe:	ff 75 ec             	pushl  -0x14(%ebp)
    3a01:	e8 73 d4 ff ff       	call   e79 <close>
    3a06:	83 c4 10             	add    $0x10,%esp
    return bmp;
    3a09:	8b 45 08             	mov    0x8(%ebp),%eax
    3a0c:	8b 55 b8             	mov    -0x48(%ebp),%edx
    3a0f:	89 10                	mov    %edx,(%eax)
    3a11:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3a14:	89 50 04             	mov    %edx,0x4(%eax)
    3a17:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3a1a:	89 50 08             	mov    %edx,0x8(%eax)
}
    3a1d:	8b 45 08             	mov    0x8(%ebp),%eax
    3a20:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3a23:	5b                   	pop    %ebx
    3a24:	5e                   	pop    %esi
    3a25:	5d                   	pop    %ebp
    3a26:	c2 04 00             	ret    $0x4

00003a29 <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    3a29:	55                   	push   %ebp
    3a2a:	89 e5                	mov    %esp,%ebp
    3a2c:	53                   	push   %ebx
    3a2d:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    3a30:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    3a34:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    3a38:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    3a3c:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    3a40:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    3a44:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    3a48:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    3a4c:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    3a50:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    3a54:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    3a58:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    3a5c:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    3a60:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    3a64:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    3a68:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    3a6c:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    3a70:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    3a74:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    3a78:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    3a7c:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    3a80:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    3a84:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    3a88:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    3a8c:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    3a90:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    3a94:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    3a98:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    3a9c:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    3aa0:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    3aa4:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    3aa8:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    3aac:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    3ab0:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    3ab4:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    3ab8:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    3abc:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    3ac0:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    3ac4:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    3ac8:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    3acc:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    3ad0:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    3ad4:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    3ad8:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    3adc:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    3ae0:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    3ae4:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    3ae8:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    3aec:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    3af0:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    3af4:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    3af8:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    3afc:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    3b00:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    3b04:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    3b08:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    3b0c:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    3b10:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    3b14:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    3b18:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    3b1c:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    3b20:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    3b24:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    3b28:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    3b2c:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    3b30:	83 ec 0c             	sub    $0xc,%esp
    3b33:	68 c8 02 08 00       	push   $0x802c8
    3b38:	e8 8e d7 ff ff       	call   12cb <malloc>
    3b3d:	83 c4 10             	add    $0x10,%esp
    3b40:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    3b43:	83 ec 04             	sub    $0x4,%esp
    3b46:	68 c8 02 08 00       	push   $0x802c8
    3b4b:	6a 00                	push   $0x0
    3b4d:	ff 75 f0             	pushl  -0x10(%ebp)
    3b50:	e8 61 d1 ff ff       	call   cb6 <memset>
    3b55:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    3b58:	83 ec 08             	sub    $0x8,%esp
    3b5b:	6a 00                	push   $0x0
    3b5d:	ff 75 0c             	pushl  0xc(%ebp)
    3b60:	e8 2c d3 ff ff       	call   e91 <open>
    3b65:	83 c4 10             	add    $0x10,%esp
    3b68:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    3b6b:	83 ec 0c             	sub    $0xc,%esp
    3b6e:	68 40 42 0f 00       	push   $0xf4240
    3b73:	e8 53 d7 ff ff       	call   12cb <malloc>
    3b78:	83 c4 10             	add    $0x10,%esp
    3b7b:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    3b7e:	83 ec 04             	sub    $0x4,%esp
    3b81:	68 40 42 0f 00       	push   $0xf4240
    3b86:	ff 75 e8             	pushl  -0x18(%ebp)
    3b89:	ff 75 ec             	pushl  -0x14(%ebp)
    3b8c:	e8 d8 d2 ff ff       	call   e69 <read>
    3b91:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    3b94:	83 ec 0c             	sub    $0xc,%esp
    3b97:	ff 75 ec             	pushl  -0x14(%ebp)
    3b9a:	e8 da d2 ff ff       	call   e79 <close>
    3b9f:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    3ba2:	68 40 42 0f 00       	push   $0xf4240
    3ba7:	ff 75 e8             	pushl  -0x18(%ebp)
    3baa:	8d 45 9c             	lea    -0x64(%ebp),%eax
    3bad:	50                   	push   %eax
    3bae:	ff 75 f0             	pushl  -0x10(%ebp)
    3bb1:	e8 5e 0c 01 00       	call   14814 <_DecodeJPEG>
    3bb6:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    3bb9:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    3bc0:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    3bc7:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    3bce:	83 ec 0c             	sub    $0xc,%esp
    3bd1:	ff 75 f0             	pushl  -0x10(%ebp)
    3bd4:	e8 29 0b 01 00       	call   14702 <GetImageSize>
    3bd9:	83 c4 10             	add    $0x10,%esp
    3bdc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    3bdf:	83 ec 0c             	sub    $0xc,%esp
    3be2:	ff 75 f0             	pushl  -0x10(%ebp)
    3be5:	e8 e1 0a 01 00       	call   146cb <GetImage>
    3bea:	83 c4 10             	add    $0x10,%esp
    3bed:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    3bf0:	83 ec 0c             	sub    $0xc,%esp
    3bf3:	ff 75 f0             	pushl  -0x10(%ebp)
    3bf6:	e8 f1 0a 01 00       	call   146ec <GetWidth>
    3bfb:	83 c4 10             	add    $0x10,%esp
    3bfe:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    3c01:	83 ec 0c             	sub    $0xc,%esp
    3c04:	ff 75 f0             	pushl  -0x10(%ebp)
    3c07:	e8 eb 0a 01 00       	call   146f7 <GetHeight>
    3c0c:	83 c4 10             	add    $0x10,%esp
    3c0f:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    3c12:	8b 55 90             	mov    -0x70(%ebp),%edx
    3c15:	8b 45 94             	mov    -0x6c(%ebp),%eax
    3c18:	0f af c2             	imul   %edx,%eax
    3c1b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    3c1e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    3c21:	89 d0                	mov    %edx,%eax
    3c23:	01 c0                	add    %eax,%eax
    3c25:	01 d0                	add    %edx,%eax
    3c27:	83 ec 0c             	sub    $0xc,%esp
    3c2a:	50                   	push   %eax
    3c2b:	e8 9b d6 ff ff       	call   12cb <malloc>
    3c30:	83 c4 10             	add    $0x10,%esp
    3c33:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    3c36:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3c3d:	e9 9c 00 00 00       	jmp    3cde <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    3c42:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3c45:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3c48:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3c4d:	89 c8                	mov    %ecx,%eax
    3c4f:	f7 ea                	imul   %edx
    3c51:	89 c8                	mov    %ecx,%eax
    3c53:	c1 f8 1f             	sar    $0x1f,%eax
    3c56:	29 c2                	sub    %eax,%edx
    3c58:	89 d0                	mov    %edx,%eax
    3c5a:	89 c2                	mov    %eax,%edx
    3c5c:	89 d0                	mov    %edx,%eax
    3c5e:	01 c0                	add    %eax,%eax
    3c60:	01 d0                	add    %edx,%eax
    3c62:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3c65:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3c68:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3c6b:	01 c8                	add    %ecx,%eax
    3c6d:	0f b6 00             	movzbl (%eax),%eax
    3c70:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    3c73:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3c76:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3c79:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3c7e:	89 c8                	mov    %ecx,%eax
    3c80:	f7 ea                	imul   %edx
    3c82:	89 c8                	mov    %ecx,%eax
    3c84:	c1 f8 1f             	sar    $0x1f,%eax
    3c87:	29 c2                	sub    %eax,%edx
    3c89:	89 d0                	mov    %edx,%eax
    3c8b:	89 c2                	mov    %eax,%edx
    3c8d:	89 d0                	mov    %edx,%eax
    3c8f:	01 c0                	add    %eax,%eax
    3c91:	01 d0                	add    %edx,%eax
    3c93:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3c96:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3c99:	8d 48 01             	lea    0x1(%eax),%ecx
    3c9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3c9f:	01 c8                	add    %ecx,%eax
    3ca1:	0f b6 00             	movzbl (%eax),%eax
    3ca4:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    3ca7:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3caa:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3cad:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3cb2:	89 c8                	mov    %ecx,%eax
    3cb4:	f7 ea                	imul   %edx
    3cb6:	89 c8                	mov    %ecx,%eax
    3cb8:	c1 f8 1f             	sar    $0x1f,%eax
    3cbb:	29 c2                	sub    %eax,%edx
    3cbd:	89 d0                	mov    %edx,%eax
    3cbf:	89 c2                	mov    %eax,%edx
    3cc1:	89 d0                	mov    %edx,%eax
    3cc3:	01 c0                	add    %eax,%eax
    3cc5:	01 d0                	add    %edx,%eax
    3cc7:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3cca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3ccd:	8d 48 02             	lea    0x2(%eax),%ecx
    3cd0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3cd3:	01 c8                	add    %ecx,%eax
    3cd5:	0f b6 00             	movzbl (%eax),%eax
    3cd8:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    3cda:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    3cde:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3ce1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    3ce4:	0f 8c 58 ff ff ff    	jl     3c42 <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    3cea:	8b 45 08             	mov    0x8(%ebp),%eax
    3ced:	8b 55 90             	mov    -0x70(%ebp),%edx
    3cf0:	89 10                	mov    %edx,(%eax)
    3cf2:	8b 55 94             	mov    -0x6c(%ebp),%edx
    3cf5:	89 50 04             	mov    %edx,0x4(%eax)
    3cf8:	8b 55 98             	mov    -0x68(%ebp),%edx
    3cfb:	89 50 08             	mov    %edx,0x8(%eax)
}
    3cfe:	8b 45 08             	mov    0x8(%ebp),%eax
    3d01:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3d04:	c9                   	leave  
    3d05:	c2 04 00             	ret    $0x4

00003d08 <LoadPng>:

PBitmap LoadPng(char* filename){
    3d08:	55                   	push   %ebp
    3d09:	89 e5                	mov    %esp,%ebp
    3d0b:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    3d0e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    3d15:	ff 75 0c             	pushl  0xc(%ebp)
    3d18:	8d 45 e0             	lea    -0x20(%ebp),%eax
    3d1b:	50                   	push   %eax
    3d1c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    3d1f:	50                   	push   %eax
    3d20:	8d 45 e8             	lea    -0x18(%ebp),%eax
    3d23:	50                   	push   %eax
    3d24:	e8 d3 d3 00 00       	call   110fc <lodepng_decode24_file>
    3d29:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    3d2c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3d2f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    3d32:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3d35:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    3d38:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    3d3f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3d42:	8b 45 d8             	mov    -0x28(%ebp),%eax
    3d45:	0f af c2             	imul   %edx,%eax
    3d48:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    3d4b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3d4e:	89 d0                	mov    %edx,%eax
    3d50:	01 c0                	add    %eax,%eax
    3d52:	01 d0                	add    %edx,%eax
    3d54:	83 ec 0c             	sub    $0xc,%esp
    3d57:	50                   	push   %eax
    3d58:	e8 6e d5 ff ff       	call   12cb <malloc>
    3d5d:	83 c4 10             	add    $0x10,%esp
    3d60:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    3d63:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3d6a:	e9 87 00 00 00       	jmp    3df6 <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    3d6f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3d72:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3d75:	89 d0                	mov    %edx,%eax
    3d77:	01 c0                	add    %eax,%eax
    3d79:	01 d0                	add    %edx,%eax
    3d7b:	01 c8                	add    %ecx,%eax
    3d7d:	0f b6 00             	movzbl (%eax),%eax
    3d80:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    3d83:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3d86:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3d89:	89 d0                	mov    %edx,%eax
    3d8b:	01 c0                	add    %eax,%eax
    3d8d:	01 d0                	add    %edx,%eax
    3d8f:	83 c0 01             	add    $0x1,%eax
    3d92:	01 c8                	add    %ecx,%eax
    3d94:	0f b6 00             	movzbl (%eax),%eax
    3d97:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    3d9a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3d9d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3da0:	89 d0                	mov    %edx,%eax
    3da2:	01 c0                	add    %eax,%eax
    3da4:	01 d0                	add    %edx,%eax
    3da6:	83 c0 02             	add    $0x2,%eax
    3da9:	01 c8                	add    %ecx,%eax
    3dab:	0f b6 00             	movzbl (%eax),%eax
    3dae:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    3db1:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3db4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3db7:	89 d0                	mov    %edx,%eax
    3db9:	01 c0                	add    %eax,%eax
    3dbb:	01 d0                	add    %edx,%eax
    3dbd:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3dc0:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    3dc4:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    3dc7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3dca:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3dcd:	89 d0                	mov    %edx,%eax
    3dcf:	01 c0                	add    %eax,%eax
    3dd1:	01 d0                	add    %edx,%eax
    3dd3:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3dd6:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    3dda:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    3ddd:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3de0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3de3:	89 d0                	mov    %edx,%eax
    3de5:	01 c0                	add    %eax,%eax
    3de7:	01 d0                	add    %edx,%eax
    3de9:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3dec:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    3df0:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    3df2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3df6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3df9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3dfc:	0f 8c 6d ff ff ff    	jl     3d6f <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    3e02:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3e05:	83 ec 0c             	sub    $0xc,%esp
    3e08:	50                   	push   %eax
    3e09:	e8 7b d3 ff ff       	call   1189 <free>
    3e0e:	83 c4 10             	add    $0x10,%esp
    return bmp;
    3e11:	8b 45 08             	mov    0x8(%ebp),%eax
    3e14:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3e17:	89 10                	mov    %edx,(%eax)
    3e19:	8b 55 d8             	mov    -0x28(%ebp),%edx
    3e1c:	89 50 04             	mov    %edx,0x4(%eax)
    3e1f:	8b 55 dc             	mov    -0x24(%ebp),%edx
    3e22:	89 50 08             	mov    %edx,0x8(%eax)

}
    3e25:	8b 45 08             	mov    0x8(%ebp),%eax
    3e28:	c9                   	leave  
    3e29:	c2 04 00             	ret    $0x4

00003e2c <LoadImg>:

PBitmap LoadImg(char* filename){
    3e2c:	55                   	push   %ebp
    3e2d:	89 e5                	mov    %esp,%ebp
    3e2f:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    3e32:	83 ec 0c             	sub    $0xc,%esp
    3e35:	ff 75 0c             	pushl  0xc(%ebp)
    3e38:	e8 7c f8 ff ff       	call   36b9 <type>
    3e3d:	83 c4 10             	add    $0x10,%esp
    3e40:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    3e43:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3e46:	83 f8 01             	cmp    $0x1,%eax
    3e49:	74 1d                	je     3e68 <LoadImg+0x3c>
    3e4b:	83 f8 02             	cmp    $0x2,%eax
    3e4e:	74 2c                	je     3e7c <LoadImg+0x50>
    3e50:	85 c0                	test   %eax,%eax
    3e52:	75 3c                	jne    3e90 <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    3e54:	8b 45 08             	mov    0x8(%ebp),%eax
    3e57:	83 ec 08             	sub    $0x8,%esp
    3e5a:	ff 75 0c             	pushl  0xc(%ebp)
    3e5d:	50                   	push   %eax
    3e5e:	e8 c6 fb ff ff       	call   3a29 <LoadJpeg>
    3e63:	83 c4 0c             	add    $0xc,%esp
    3e66:	eb 3c                	jmp    3ea4 <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    3e68:	8b 45 08             	mov    0x8(%ebp),%eax
    3e6b:	83 ec 08             	sub    $0x8,%esp
    3e6e:	ff 75 0c             	pushl  0xc(%ebp)
    3e71:	50                   	push   %eax
    3e72:	e8 17 f9 ff ff       	call   378e <LoadBmp>
    3e77:	83 c4 0c             	add    $0xc,%esp
    3e7a:	eb 28                	jmp    3ea4 <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    3e7c:	8b 45 08             	mov    0x8(%ebp),%eax
    3e7f:	83 ec 08             	sub    $0x8,%esp
    3e82:	ff 75 0c             	pushl  0xc(%ebp)
    3e85:	50                   	push   %eax
    3e86:	e8 7d fe ff ff       	call   3d08 <LoadPng>
    3e8b:	83 c4 0c             	add    $0xc,%esp
    3e8e:	eb 14                	jmp    3ea4 <LoadImg+0x78>

        default: return bmp;
    3e90:	8b 45 08             	mov    0x8(%ebp),%eax
    3e93:	8b 55 e8             	mov    -0x18(%ebp),%edx
    3e96:	89 10                	mov    %edx,(%eax)
    3e98:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3e9b:	89 50 04             	mov    %edx,0x4(%eax)
    3e9e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3ea1:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    3ea4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ea7:	c9                   	leave  
    3ea8:	c2 04 00             	ret    $0x4

00003eab <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    3eab:	55                   	push   %ebp
    3eac:	89 e5                	mov    %esp,%ebp
    3eae:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    3eb1:	8b 45 08             	mov    0x8(%ebp),%eax
    3eb4:	83 ec 0c             	sub    $0xc,%esp
    3eb7:	50                   	push   %eax
    3eb8:	e8 0e d4 ff ff       	call   12cb <malloc>
    3ebd:	83 c4 10             	add    $0x10,%esp
}
    3ec0:	c9                   	leave  
    3ec1:	c3                   	ret    

00003ec2 <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    3ec2:	55                   	push   %ebp
    3ec3:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    3ec5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3eca:	5d                   	pop    %ebp
    3ecb:	c3                   	ret    

00003ecc <lodepng_free>:

static void lodepng_free(void* ptr) {
    3ecc:	55                   	push   %ebp
    3ecd:	89 e5                	mov    %esp,%ebp
    3ecf:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    3ed2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    3ed6:	74 0e                	je     3ee6 <lodepng_free+0x1a>
    free(ptr);
    3ed8:	83 ec 0c             	sub    $0xc,%esp
    3edb:	ff 75 08             	pushl  0x8(%ebp)
    3ede:	e8 a6 d2 ff ff       	call   1189 <free>
    3ee3:	83 c4 10             	add    $0x10,%esp
}
    3ee6:	90                   	nop
    3ee7:	c9                   	leave  
    3ee8:	c3                   	ret    

00003ee9 <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    3ee9:	55                   	push   %ebp
    3eea:	89 e5                	mov    %esp,%ebp
    3eec:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    3eef:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3ef6:	eb 19                	jmp    3f11 <lodepng_memcpy+0x28>
    3ef8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3efb:	8b 45 08             	mov    0x8(%ebp),%eax
    3efe:	01 c2                	add    %eax,%edx
    3f00:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3f03:	8b 45 0c             	mov    0xc(%ebp),%eax
    3f06:	01 c8                	add    %ecx,%eax
    3f08:	0f b6 00             	movzbl (%eax),%eax
    3f0b:	88 02                	mov    %al,(%edx)
    3f0d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3f11:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3f14:	3b 45 10             	cmp    0x10(%ebp),%eax
    3f17:	7c df                	jl     3ef8 <lodepng_memcpy+0xf>
}
    3f19:	90                   	nop
    3f1a:	c9                   	leave  
    3f1b:	c3                   	ret    

00003f1c <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    3f1c:	55                   	push   %ebp
    3f1d:	89 e5                	mov    %esp,%ebp
    3f1f:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    3f22:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3f29:	eb 11                	jmp    3f3c <lodepng_memset+0x20>
    3f2b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3f2e:	8b 45 08             	mov    0x8(%ebp),%eax
    3f31:	01 d0                	add    %edx,%eax
    3f33:	8b 55 0c             	mov    0xc(%ebp),%edx
    3f36:	88 10                	mov    %dl,(%eax)
    3f38:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3f3c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3f3f:	3b 45 10             	cmp    0x10(%ebp),%eax
    3f42:	7c e7                	jl     3f2b <lodepng_memset+0xf>
}
    3f44:	90                   	nop
    3f45:	c9                   	leave  
    3f46:	c3                   	ret    

00003f47 <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    3f47:	55                   	push   %ebp
    3f48:	89 e5                	mov    %esp,%ebp
    3f4a:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    3f4d:	8b 45 08             	mov    0x8(%ebp),%eax
    3f50:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    3f53:	eb 04                	jmp    3f59 <lodepng_strlen+0x12>
    3f55:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    3f59:	8b 45 08             	mov    0x8(%ebp),%eax
    3f5c:	0f b6 00             	movzbl (%eax),%eax
    3f5f:	84 c0                	test   %al,%al
    3f61:	75 f2                	jne    3f55 <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    3f63:	8b 55 08             	mov    0x8(%ebp),%edx
    3f66:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3f69:	29 c2                	sub    %eax,%edx
    3f6b:	89 d0                	mov    %edx,%eax
}
    3f6d:	c9                   	leave  
    3f6e:	c3                   	ret    

00003f6f <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    3f6f:	55                   	push   %ebp
    3f70:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    3f72:	8b 55 08             	mov    0x8(%ebp),%edx
    3f75:	8b 45 0c             	mov    0xc(%ebp),%eax
    3f78:	01 c2                	add    %eax,%edx
    3f7a:	8b 45 10             	mov    0x10(%ebp),%eax
    3f7d:	89 10                	mov    %edx,(%eax)
  return *result < a;
    3f7f:	8b 45 10             	mov    0x10(%ebp),%eax
    3f82:	8b 00                	mov    (%eax),%eax
    3f84:	3b 45 08             	cmp    0x8(%ebp),%eax
    3f87:	0f 9c c0             	setl   %al
    3f8a:	0f b6 c0             	movzbl %al,%eax
}
    3f8d:	5d                   	pop    %ebp
    3f8e:	c3                   	ret    

00003f8f <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    3f8f:	55                   	push   %ebp
    3f90:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    3f92:	8b 45 08             	mov    0x8(%ebp),%eax
    3f95:	0f af 45 0c          	imul   0xc(%ebp),%eax
    3f99:	89 c2                	mov    %eax,%edx
    3f9b:	8b 45 10             	mov    0x10(%ebp),%eax
    3f9e:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    3fa0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    3fa4:	74 15                	je     3fbb <lodepng_mulofl+0x2c>
    3fa6:	8b 45 10             	mov    0x10(%ebp),%eax
    3fa9:	8b 00                	mov    (%eax),%eax
    3fab:	99                   	cltd   
    3fac:	f7 7d 08             	idivl  0x8(%ebp)
    3faf:	3b 45 0c             	cmp    0xc(%ebp),%eax
    3fb2:	74 07                	je     3fbb <lodepng_mulofl+0x2c>
    3fb4:	b8 01 00 00 00       	mov    $0x1,%eax
    3fb9:	eb 05                	jmp    3fc0 <lodepng_mulofl+0x31>
    3fbb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3fc0:	5d                   	pop    %ebp
    3fc1:	c3                   	ret    

00003fc2 <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    3fc2:	55                   	push   %ebp
    3fc3:	89 e5                	mov    %esp,%ebp
    3fc5:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    3fc8:	8d 45 fc             	lea    -0x4(%ebp),%eax
    3fcb:	50                   	push   %eax
    3fcc:	ff 75 0c             	pushl  0xc(%ebp)
    3fcf:	ff 75 08             	pushl  0x8(%ebp)
    3fd2:	e8 98 ff ff ff       	call   3f6f <lodepng_addofl>
    3fd7:	83 c4 0c             	add    $0xc,%esp
    3fda:	85 c0                	test   %eax,%eax
    3fdc:	74 07                	je     3fe5 <lodepng_gtofl+0x23>
    3fde:	b8 01 00 00 00       	mov    $0x1,%eax
    3fe3:	eb 0c                	jmp    3ff1 <lodepng_gtofl+0x2f>
  return d > c;
    3fe5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3fe8:	3b 45 10             	cmp    0x10(%ebp),%eax
    3feb:	0f 9f c0             	setg   %al
    3fee:	0f b6 c0             	movzbl %al,%eax
}
    3ff1:	c9                   	leave  
    3ff2:	c3                   	ret    

00003ff3 <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    3ff3:	55                   	push   %ebp
    3ff4:	89 e5                	mov    %esp,%ebp
    3ff6:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    3ff9:	8b 45 08             	mov    0x8(%ebp),%eax
    3ffc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    4003:	8b 45 08             	mov    0x8(%ebp),%eax
    4006:	8b 50 08             	mov    0x8(%eax),%edx
    4009:	8b 45 08             	mov    0x8(%ebp),%eax
    400c:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    400f:	8b 45 08             	mov    0x8(%ebp),%eax
    4012:	8b 00                	mov    (%eax),%eax
    4014:	83 ec 0c             	sub    $0xc,%esp
    4017:	50                   	push   %eax
    4018:	e8 af fe ff ff       	call   3ecc <lodepng_free>
    401d:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    4020:	8b 45 08             	mov    0x8(%ebp),%eax
    4023:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    4029:	90                   	nop
    402a:	c9                   	leave  
    402b:	c3                   	ret    

0000402c <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    402c:	55                   	push   %ebp
    402d:	89 e5                	mov    %esp,%ebp
    402f:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    4032:	8b 45 0c             	mov    0xc(%ebp),%eax
    4035:	c1 e0 02             	shl    $0x2,%eax
    4038:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    403b:	8b 45 08             	mov    0x8(%ebp),%eax
    403e:	8b 40 08             	mov    0x8(%eax),%eax
    4041:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    4044:	7d 46                	jge    408c <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    4046:	8b 45 08             	mov    0x8(%ebp),%eax
    4049:	8b 40 08             	mov    0x8(%eax),%eax
    404c:	d1 f8                	sar    %eax
    404e:	89 c2                	mov    %eax,%edx
    4050:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4053:	01 d0                	add    %edx,%eax
    4055:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    4058:	8b 45 08             	mov    0x8(%ebp),%eax
    405b:	8b 00                	mov    (%eax),%eax
    405d:	ff 75 f8             	pushl  -0x8(%ebp)
    4060:	50                   	push   %eax
    4061:	e8 5c fe ff ff       	call   3ec2 <lodepng_realloc>
    4066:	83 c4 08             	add    $0x8,%esp
    4069:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    406c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4070:	74 13                	je     4085 <uivector_resize+0x59>
      p->allocsize = newsize;
    4072:	8b 45 08             	mov    0x8(%ebp),%eax
    4075:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4078:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    407b:	8b 45 08             	mov    0x8(%ebp),%eax
    407e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4081:	89 10                	mov    %edx,(%eax)
    4083:	eb 07                	jmp    408c <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    4085:	b8 00 00 00 00       	mov    $0x0,%eax
    408a:	eb 0e                	jmp    409a <uivector_resize+0x6e>
  }
  p->size = size;
    408c:	8b 45 08             	mov    0x8(%ebp),%eax
    408f:	8b 55 0c             	mov    0xc(%ebp),%edx
    4092:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    4095:	b8 01 00 00 00       	mov    $0x1,%eax
}
    409a:	c9                   	leave  
    409b:	c3                   	ret    

0000409c <uivector_init>:

static void uivector_init(uivector* p) {
    409c:	55                   	push   %ebp
    409d:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    409f:	8b 45 08             	mov    0x8(%ebp),%eax
    40a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    40a8:	8b 45 08             	mov    0x8(%ebp),%eax
    40ab:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    40b2:	8b 45 08             	mov    0x8(%ebp),%eax
    40b5:	8b 50 08             	mov    0x8(%eax),%edx
    40b8:	8b 45 08             	mov    0x8(%ebp),%eax
    40bb:	89 50 04             	mov    %edx,0x4(%eax)
}
    40be:	90                   	nop
    40bf:	5d                   	pop    %ebp
    40c0:	c3                   	ret    

000040c1 <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    40c1:	55                   	push   %ebp
    40c2:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    40c4:	8b 45 08             	mov    0x8(%ebp),%eax
    40c7:	8b 40 04             	mov    0x4(%eax),%eax
    40ca:	83 c0 01             	add    $0x1,%eax
    40cd:	50                   	push   %eax
    40ce:	ff 75 08             	pushl  0x8(%ebp)
    40d1:	e8 56 ff ff ff       	call   402c <uivector_resize>
    40d6:	83 c4 08             	add    $0x8,%esp
    40d9:	85 c0                	test   %eax,%eax
    40db:	75 07                	jne    40e4 <uivector_push_back+0x23>
    40dd:	b8 00 00 00 00       	mov    $0x0,%eax
    40e2:	eb 1f                	jmp    4103 <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    40e4:	8b 45 08             	mov    0x8(%ebp),%eax
    40e7:	8b 10                	mov    (%eax),%edx
    40e9:	8b 45 08             	mov    0x8(%ebp),%eax
    40ec:	8b 40 04             	mov    0x4(%eax),%eax
    40ef:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    40f4:	c1 e0 02             	shl    $0x2,%eax
    40f7:	01 c2                	add    %eax,%edx
    40f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    40fc:	89 02                	mov    %eax,(%edx)
  return 1;
    40fe:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4103:	c9                   	leave  
    4104:	c3                   	ret    

00004105 <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    4105:	55                   	push   %ebp
    4106:	89 e5                	mov    %esp,%ebp
    4108:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    410b:	8b 45 08             	mov    0x8(%ebp),%eax
    410e:	8b 40 08             	mov    0x8(%eax),%eax
    4111:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4114:	7d 46                	jge    415c <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    4116:	8b 45 08             	mov    0x8(%ebp),%eax
    4119:	8b 40 08             	mov    0x8(%eax),%eax
    411c:	d1 f8                	sar    %eax
    411e:	89 c2                	mov    %eax,%edx
    4120:	8b 45 0c             	mov    0xc(%ebp),%eax
    4123:	01 d0                	add    %edx,%eax
    4125:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    4128:	8b 45 08             	mov    0x8(%ebp),%eax
    412b:	8b 00                	mov    (%eax),%eax
    412d:	ff 75 fc             	pushl  -0x4(%ebp)
    4130:	50                   	push   %eax
    4131:	e8 8c fd ff ff       	call   3ec2 <lodepng_realloc>
    4136:	83 c4 08             	add    $0x8,%esp
    4139:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    413c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    4140:	74 13                	je     4155 <ucvector_resize+0x50>
      p->allocsize = newsize;
    4142:	8b 45 08             	mov    0x8(%ebp),%eax
    4145:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4148:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    414b:	8b 45 08             	mov    0x8(%ebp),%eax
    414e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4151:	89 10                	mov    %edx,(%eax)
    4153:	eb 07                	jmp    415c <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    4155:	b8 00 00 00 00       	mov    $0x0,%eax
    415a:	eb 0e                	jmp    416a <ucvector_resize+0x65>
  }
  p->size = size;
    415c:	8b 45 08             	mov    0x8(%ebp),%eax
    415f:	8b 55 0c             	mov    0xc(%ebp),%edx
    4162:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    4165:	b8 01 00 00 00       	mov    $0x1,%eax
}
    416a:	c9                   	leave  
    416b:	c3                   	ret    

0000416c <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    416c:	55                   	push   %ebp
    416d:	89 e5                	mov    %esp,%ebp
    416f:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    4172:	8b 45 0c             	mov    0xc(%ebp),%eax
    4175:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    4178:	8b 45 10             	mov    0x10(%ebp),%eax
    417b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    417e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4181:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    4184:	8b 45 08             	mov    0x8(%ebp),%eax
    4187:	8b 55 f4             	mov    -0xc(%ebp),%edx
    418a:	89 10                	mov    %edx,(%eax)
    418c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    418f:	89 50 04             	mov    %edx,0x4(%eax)
    4192:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4195:	89 50 08             	mov    %edx,0x8(%eax)
}
    4198:	8b 45 08             	mov    0x8(%ebp),%eax
    419b:	c9                   	leave  
    419c:	c2 04 00             	ret    $0x4

0000419f <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    419f:	55                   	push   %ebp
    41a0:	89 e5                	mov    %esp,%ebp
    41a2:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    41a5:	8b 45 08             	mov    0x8(%ebp),%eax
    41a8:	8b 00                	mov    (%eax),%eax
    41aa:	83 ec 0c             	sub    $0xc,%esp
    41ad:	50                   	push   %eax
    41ae:	e8 19 fd ff ff       	call   3ecc <lodepng_free>
    41b3:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    41b6:	8b 45 08             	mov    0x8(%ebp),%eax
    41b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    41bf:	90                   	nop
    41c0:	c9                   	leave  
    41c1:	c3                   	ret    

000041c2 <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    41c2:	55                   	push   %ebp
    41c3:	89 e5                	mov    %esp,%ebp
    41c5:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    41c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    41cb:	83 c0 01             	add    $0x1,%eax
    41ce:	83 ec 0c             	sub    $0xc,%esp
    41d1:	50                   	push   %eax
    41d2:	e8 d4 fc ff ff       	call   3eab <lodepng_malloc>
    41d7:	83 c4 10             	add    $0x10,%esp
    41da:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    41dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    41e1:	74 1f                	je     4202 <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    41e3:	83 ec 04             	sub    $0x4,%esp
    41e6:	ff 75 0c             	pushl  0xc(%ebp)
    41e9:	ff 75 08             	pushl  0x8(%ebp)
    41ec:	ff 75 f4             	pushl  -0xc(%ebp)
    41ef:	e8 f5 fc ff ff       	call   3ee9 <lodepng_memcpy>
    41f4:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    41f7:	8b 55 0c             	mov    0xc(%ebp),%edx
    41fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    41fd:	01 d0                	add    %edx,%eax
    41ff:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    4202:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4205:	c9                   	leave  
    4206:	c3                   	ret    

00004207 <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    4207:	55                   	push   %ebp
    4208:	89 e5                	mov    %esp,%ebp
    420a:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    420d:	ff 75 08             	pushl  0x8(%ebp)
    4210:	e8 32 fd ff ff       	call   3f47 <lodepng_strlen>
    4215:	83 c4 04             	add    $0x4,%esp
    4218:	83 ec 08             	sub    $0x8,%esp
    421b:	50                   	push   %eax
    421c:	ff 75 08             	pushl  0x8(%ebp)
    421f:	e8 9e ff ff ff       	call   41c2 <alloc_string_sized>
    4224:	83 c4 10             	add    $0x10,%esp
}
    4227:	c9                   	leave  
    4228:	c3                   	ret    

00004229 <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    4229:	55                   	push   %ebp
    422a:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    422c:	8b 45 08             	mov    0x8(%ebp),%eax
    422f:	0f b6 00             	movzbl (%eax),%eax
    4232:	0f b6 c0             	movzbl %al,%eax
    4235:	c1 e0 18             	shl    $0x18,%eax
    4238:	89 c2                	mov    %eax,%edx
    423a:	8b 45 08             	mov    0x8(%ebp),%eax
    423d:	83 c0 01             	add    $0x1,%eax
    4240:	0f b6 00             	movzbl (%eax),%eax
    4243:	0f b6 c0             	movzbl %al,%eax
    4246:	c1 e0 10             	shl    $0x10,%eax
    4249:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    424b:	8b 45 08             	mov    0x8(%ebp),%eax
    424e:	83 c0 02             	add    $0x2,%eax
    4251:	0f b6 00             	movzbl (%eax),%eax
    4254:	0f b6 c0             	movzbl %al,%eax
    4257:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    425a:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    425c:	8b 45 08             	mov    0x8(%ebp),%eax
    425f:	83 c0 03             	add    $0x3,%eax
    4262:	0f b6 00             	movzbl (%eax),%eax
    4265:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    4268:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    426a:	5d                   	pop    %ebp
    426b:	c3                   	ret    

0000426c <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    426c:	55                   	push   %ebp
    426d:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    426f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4272:	c1 e8 18             	shr    $0x18,%eax
    4275:	89 c2                	mov    %eax,%edx
    4277:	8b 45 08             	mov    0x8(%ebp),%eax
    427a:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    427c:	8b 45 08             	mov    0x8(%ebp),%eax
    427f:	83 c0 01             	add    $0x1,%eax
    4282:	8b 55 0c             	mov    0xc(%ebp),%edx
    4285:	c1 ea 10             	shr    $0x10,%edx
    4288:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    428a:	8b 45 08             	mov    0x8(%ebp),%eax
    428d:	83 c0 02             	add    $0x2,%eax
    4290:	8b 55 0c             	mov    0xc(%ebp),%edx
    4293:	c1 ea 08             	shr    $0x8,%edx
    4296:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    4298:	8b 45 08             	mov    0x8(%ebp),%eax
    429b:	83 c0 03             	add    $0x3,%eax
    429e:	8b 55 0c             	mov    0xc(%ebp),%edx
    42a1:	88 10                	mov    %dl,(%eax)
}
    42a3:	90                   	nop
    42a4:	5d                   	pop    %ebp
    42a5:	c3                   	ret    

000042a6 <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    42a6:	55                   	push   %ebp
    42a7:	89 e5                	mov    %esp,%ebp
    42a9:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    42ac:	83 ec 08             	sub    $0x8,%esp
    42af:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    42b2:	50                   	push   %eax
    42b3:	ff 75 08             	pushl  0x8(%ebp)
    42b6:	e8 b7 ca ff ff       	call   d72 <stat>
    42bb:	83 c4 10             	add    $0x10,%esp
  return s.size;
    42be:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    42c1:	c9                   	leave  
    42c2:	c3                   	ret    

000042c3 <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    42c3:	55                   	push   %ebp
    42c4:	89 e5                	mov    %esp,%ebp
    42c6:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    42c9:	83 ec 08             	sub    $0x8,%esp
    42cc:	6a 00                	push   $0x0
    42ce:	ff 75 10             	pushl  0x10(%ebp)
    42d1:	e8 bb cb ff ff       	call   e91 <open>
    42d6:	83 c4 10             	add    $0x10,%esp
    42d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    42dc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    42e0:	79 07                	jns    42e9 <lodepng_buffer_file+0x26>
  {
      return -1;
    42e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    42e7:	eb 19                	jmp    4302 <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    42e9:	83 ec 04             	sub    $0x4,%esp
    42ec:	ff 75 0c             	pushl  0xc(%ebp)
    42ef:	ff 75 08             	pushl  0x8(%ebp)
    42f2:	ff 75 f4             	pushl  -0xc(%ebp)
    42f5:	e8 6f cb ff ff       	call   e69 <read>
    42fa:	83 c4 10             	add    $0x10,%esp
  return 0;
    42fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4302:	c9                   	leave  
    4303:	c3                   	ret    

00004304 <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    4304:	55                   	push   %ebp
    4305:	89 e5                	mov    %esp,%ebp
    4307:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    430a:	83 ec 0c             	sub    $0xc,%esp
    430d:	ff 75 10             	pushl  0x10(%ebp)
    4310:	e8 91 ff ff ff       	call   42a6 <lodepng_filesize>
    4315:	83 c4 10             	add    $0x10,%esp
    4318:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    431b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    431f:	79 07                	jns    4328 <lodepng_load_file+0x24>
    4321:	b8 4e 00 00 00       	mov    $0x4e,%eax
    4326:	eb 4a                	jmp    4372 <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    4328:	8b 45 0c             	mov    0xc(%ebp),%eax
    432b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    432e:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    4330:	83 ec 0c             	sub    $0xc,%esp
    4333:	ff 75 f4             	pushl  -0xc(%ebp)
    4336:	e8 70 fb ff ff       	call   3eab <lodepng_malloc>
    433b:	83 c4 10             	add    $0x10,%esp
    433e:	89 c2                	mov    %eax,%edx
    4340:	8b 45 08             	mov    0x8(%ebp),%eax
    4343:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    4345:	8b 45 08             	mov    0x8(%ebp),%eax
    4348:	8b 00                	mov    (%eax),%eax
    434a:	85 c0                	test   %eax,%eax
    434c:	75 0d                	jne    435b <lodepng_load_file+0x57>
    434e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4352:	7e 07                	jle    435b <lodepng_load_file+0x57>
    4354:	b8 53 00 00 00       	mov    $0x53,%eax
    4359:	eb 17                	jmp    4372 <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    435b:	8b 45 08             	mov    0x8(%ebp),%eax
    435e:	8b 00                	mov    (%eax),%eax
    4360:	83 ec 04             	sub    $0x4,%esp
    4363:	ff 75 10             	pushl  0x10(%ebp)
    4366:	ff 75 f4             	pushl  -0xc(%ebp)
    4369:	50                   	push   %eax
    436a:	e8 54 ff ff ff       	call   42c3 <lodepng_buffer_file>
    436f:	83 c4 10             	add    $0x10,%esp
}
    4372:	c9                   	leave  
    4373:	c3                   	ret    

00004374 <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    4374:	55                   	push   %ebp
    4375:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    4377:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    437c:	5d                   	pop    %ebp
    437d:	c3                   	ret    

0000437e <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    437e:	55                   	push   %ebp
    437f:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    4381:	8b 45 08             	mov    0x8(%ebp),%eax
    4384:	8b 55 0c             	mov    0xc(%ebp),%edx
    4387:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    4389:	8b 45 08             	mov    0x8(%ebp),%eax
    438c:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    4390:	90                   	nop
    4391:	5d                   	pop    %ebp
    4392:	c3                   	ret    

00004393 <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    4393:	55                   	push   %ebp
    4394:	89 e5                	mov    %esp,%ebp
    4396:	56                   	push   %esi
    4397:	53                   	push   %ebx
    4398:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    439b:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    439f:	0f 85 aa 00 00 00    	jne    444f <writeBits+0xbc>
    WRITEBIT(writer, value);
    43a5:	8b 45 08             	mov    0x8(%ebp),%eax
    43a8:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    43ac:	0f b6 c0             	movzbl %al,%eax
    43af:	83 e0 07             	and    $0x7,%eax
    43b2:	85 c0                	test   %eax,%eax
    43b4:	75 39                	jne    43ef <writeBits+0x5c>
    43b6:	8b 45 08             	mov    0x8(%ebp),%eax
    43b9:	8b 00                	mov    (%eax),%eax
    43bb:	8b 40 04             	mov    0x4(%eax),%eax
    43be:	8d 50 01             	lea    0x1(%eax),%edx
    43c1:	8b 45 08             	mov    0x8(%ebp),%eax
    43c4:	8b 00                	mov    (%eax),%eax
    43c6:	52                   	push   %edx
    43c7:	50                   	push   %eax
    43c8:	e8 38 fd ff ff       	call   4105 <ucvector_resize>
    43cd:	83 c4 08             	add    $0x8,%esp
    43d0:	85 c0                	test   %eax,%eax
    43d2:	0f 84 44 01 00 00    	je     451c <writeBits+0x189>
    43d8:	8b 45 08             	mov    0x8(%ebp),%eax
    43db:	8b 00                	mov    (%eax),%eax
    43dd:	8b 10                	mov    (%eax),%edx
    43df:	8b 45 08             	mov    0x8(%ebp),%eax
    43e2:	8b 00                	mov    (%eax),%eax
    43e4:	8b 40 04             	mov    0x4(%eax),%eax
    43e7:	83 e8 01             	sub    $0x1,%eax
    43ea:	01 d0                	add    %edx,%eax
    43ec:	c6 00 00             	movb   $0x0,(%eax)
    43ef:	8b 45 08             	mov    0x8(%ebp),%eax
    43f2:	8b 00                	mov    (%eax),%eax
    43f4:	8b 10                	mov    (%eax),%edx
    43f6:	8b 45 08             	mov    0x8(%ebp),%eax
    43f9:	8b 00                	mov    (%eax),%eax
    43fb:	8b 40 04             	mov    0x4(%eax),%eax
    43fe:	83 e8 01             	sub    $0x1,%eax
    4401:	01 c2                	add    %eax,%edx
    4403:	8b 45 08             	mov    0x8(%ebp),%eax
    4406:	8b 00                	mov    (%eax),%eax
    4408:	8b 08                	mov    (%eax),%ecx
    440a:	8b 45 08             	mov    0x8(%ebp),%eax
    440d:	8b 00                	mov    (%eax),%eax
    440f:	8b 40 04             	mov    0x4(%eax),%eax
    4412:	83 e8 01             	sub    $0x1,%eax
    4415:	01 c8                	add    %ecx,%eax
    4417:	0f b6 00             	movzbl (%eax),%eax
    441a:	88 45 e7             	mov    %al,-0x19(%ebp)
    441d:	8b 45 08             	mov    0x8(%ebp),%eax
    4420:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4424:	0f b6 c0             	movzbl %al,%eax
    4427:	83 e0 07             	and    $0x7,%eax
    442a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    442d:	89 de                	mov    %ebx,%esi
    442f:	89 c1                	mov    %eax,%ecx
    4431:	d3 e6                	shl    %cl,%esi
    4433:	89 f0                	mov    %esi,%eax
    4435:	0a 45 e7             	or     -0x19(%ebp),%al
    4438:	88 02                	mov    %al,(%edx)
    443a:	8b 45 08             	mov    0x8(%ebp),%eax
    443d:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4441:	8d 50 01             	lea    0x1(%eax),%edx
    4444:	8b 45 08             	mov    0x8(%ebp),%eax
    4447:	88 50 04             	mov    %dl,0x4(%eax)
    444a:	e9 d1 00 00 00       	jmp    4520 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    444f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4456:	e9 b3 00 00 00       	jmp    450e <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    445b:	8b 45 08             	mov    0x8(%ebp),%eax
    445e:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4462:	0f b6 c0             	movzbl %al,%eax
    4465:	83 e0 07             	and    $0x7,%eax
    4468:	85 c0                	test   %eax,%eax
    446a:	75 39                	jne    44a5 <writeBits+0x112>
    446c:	8b 45 08             	mov    0x8(%ebp),%eax
    446f:	8b 00                	mov    (%eax),%eax
    4471:	8b 40 04             	mov    0x4(%eax),%eax
    4474:	8d 50 01             	lea    0x1(%eax),%edx
    4477:	8b 45 08             	mov    0x8(%ebp),%eax
    447a:	8b 00                	mov    (%eax),%eax
    447c:	52                   	push   %edx
    447d:	50                   	push   %eax
    447e:	e8 82 fc ff ff       	call   4105 <ucvector_resize>
    4483:	83 c4 08             	add    $0x8,%esp
    4486:	85 c0                	test   %eax,%eax
    4488:	0f 84 91 00 00 00    	je     451f <writeBits+0x18c>
    448e:	8b 45 08             	mov    0x8(%ebp),%eax
    4491:	8b 00                	mov    (%eax),%eax
    4493:	8b 10                	mov    (%eax),%edx
    4495:	8b 45 08             	mov    0x8(%ebp),%eax
    4498:	8b 00                	mov    (%eax),%eax
    449a:	8b 40 04             	mov    0x4(%eax),%eax
    449d:	83 e8 01             	sub    $0x1,%eax
    44a0:	01 d0                	add    %edx,%eax
    44a2:	c6 00 00             	movb   $0x0,(%eax)
    44a5:	8b 45 08             	mov    0x8(%ebp),%eax
    44a8:	8b 00                	mov    (%eax),%eax
    44aa:	8b 10                	mov    (%eax),%edx
    44ac:	8b 45 08             	mov    0x8(%ebp),%eax
    44af:	8b 00                	mov    (%eax),%eax
    44b1:	8b 40 04             	mov    0x4(%eax),%eax
    44b4:	83 e8 01             	sub    $0x1,%eax
    44b7:	01 c2                	add    %eax,%edx
    44b9:	8b 45 08             	mov    0x8(%ebp),%eax
    44bc:	8b 00                	mov    (%eax),%eax
    44be:	8b 08                	mov    (%eax),%ecx
    44c0:	8b 45 08             	mov    0x8(%ebp),%eax
    44c3:	8b 00                	mov    (%eax),%eax
    44c5:	8b 40 04             	mov    0x4(%eax),%eax
    44c8:	83 e8 01             	sub    $0x1,%eax
    44cb:	01 c8                	add    %ecx,%eax
    44cd:	0f b6 00             	movzbl (%eax),%eax
    44d0:	89 c6                	mov    %eax,%esi
    44d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    44d5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    44d8:	89 c1                	mov    %eax,%ecx
    44da:	d3 eb                	shr    %cl,%ebx
    44dc:	89 d8                	mov    %ebx,%eax
    44de:	83 e0 01             	and    $0x1,%eax
    44e1:	89 c3                	mov    %eax,%ebx
    44e3:	8b 45 08             	mov    0x8(%ebp),%eax
    44e6:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    44ea:	0f b6 c0             	movzbl %al,%eax
    44ed:	83 e0 07             	and    $0x7,%eax
    44f0:	89 c1                	mov    %eax,%ecx
    44f2:	d3 e3                	shl    %cl,%ebx
    44f4:	89 d8                	mov    %ebx,%eax
    44f6:	09 f0                	or     %esi,%eax
    44f8:	88 02                	mov    %al,(%edx)
    44fa:	8b 45 08             	mov    0x8(%ebp),%eax
    44fd:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4501:	8d 50 01             	lea    0x1(%eax),%edx
    4504:	8b 45 08             	mov    0x8(%ebp),%eax
    4507:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    450a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    450e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4511:	3b 45 10             	cmp    0x10(%ebp),%eax
    4514:	0f 85 41 ff ff ff    	jne    445b <writeBits+0xc8>
    451a:	eb 04                	jmp    4520 <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    451c:	90                   	nop
    451d:	eb 01                	jmp    4520 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    451f:	90                   	nop
    }
  }
}
    4520:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4523:	5b                   	pop    %ebx
    4524:	5e                   	pop    %esi
    4525:	5d                   	pop    %ebp
    4526:	c3                   	ret    

00004527 <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    4527:	55                   	push   %ebp
    4528:	89 e5                	mov    %esp,%ebp
    452a:	56                   	push   %esi
    452b:	53                   	push   %ebx
    452c:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    452f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4536:	e9 bd 00 00 00       	jmp    45f8 <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    453b:	8b 45 08             	mov    0x8(%ebp),%eax
    453e:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    4542:	0f b6 c0             	movzbl %al,%eax
    4545:	83 e0 07             	and    $0x7,%eax
    4548:	85 c0                	test   %eax,%eax
    454a:	75 39                	jne    4585 <writeBitsReversed+0x5e>
    454c:	8b 45 08             	mov    0x8(%ebp),%eax
    454f:	8b 00                	mov    (%eax),%eax
    4551:	8b 40 04             	mov    0x4(%eax),%eax
    4554:	8d 50 01             	lea    0x1(%eax),%edx
    4557:	8b 45 08             	mov    0x8(%ebp),%eax
    455a:	8b 00                	mov    (%eax),%eax
    455c:	52                   	push   %edx
    455d:	50                   	push   %eax
    455e:	e8 a2 fb ff ff       	call   4105 <ucvector_resize>
    4563:	83 c4 08             	add    $0x8,%esp
    4566:	85 c0                	test   %eax,%eax
    4568:	0f 84 98 00 00 00    	je     4606 <writeBitsReversed+0xdf>
    456e:	8b 45 08             	mov    0x8(%ebp),%eax
    4571:	8b 00                	mov    (%eax),%eax
    4573:	8b 10                	mov    (%eax),%edx
    4575:	8b 45 08             	mov    0x8(%ebp),%eax
    4578:	8b 00                	mov    (%eax),%eax
    457a:	8b 40 04             	mov    0x4(%eax),%eax
    457d:	83 e8 01             	sub    $0x1,%eax
    4580:	01 d0                	add    %edx,%eax
    4582:	c6 00 00             	movb   $0x0,(%eax)
    4585:	8b 45 08             	mov    0x8(%ebp),%eax
    4588:	8b 00                	mov    (%eax),%eax
    458a:	8b 10                	mov    (%eax),%edx
    458c:	8b 45 08             	mov    0x8(%ebp),%eax
    458f:	8b 00                	mov    (%eax),%eax
    4591:	8b 40 04             	mov    0x4(%eax),%eax
    4594:	83 e8 01             	sub    $0x1,%eax
    4597:	01 c2                	add    %eax,%edx
    4599:	8b 45 08             	mov    0x8(%ebp),%eax
    459c:	8b 00                	mov    (%eax),%eax
    459e:	8b 08                	mov    (%eax),%ecx
    45a0:	8b 45 08             	mov    0x8(%ebp),%eax
    45a3:	8b 00                	mov    (%eax),%eax
    45a5:	8b 40 04             	mov    0x4(%eax),%eax
    45a8:	83 e8 01             	sub    $0x1,%eax
    45ab:	01 c8                	add    %ecx,%eax
    45ad:	0f b6 00             	movzbl (%eax),%eax
    45b0:	89 c6                	mov    %eax,%esi
    45b2:	8b 4d 10             	mov    0x10(%ebp),%ecx
    45b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    45b8:	29 c1                	sub    %eax,%ecx
    45ba:	89 c8                	mov    %ecx,%eax
    45bc:	83 e8 01             	sub    $0x1,%eax
    45bf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    45c2:	89 c1                	mov    %eax,%ecx
    45c4:	d3 eb                	shr    %cl,%ebx
    45c6:	89 d8                	mov    %ebx,%eax
    45c8:	83 e0 01             	and    $0x1,%eax
    45cb:	89 c3                	mov    %eax,%ebx
    45cd:	8b 45 08             	mov    0x8(%ebp),%eax
    45d0:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    45d4:	0f b6 c0             	movzbl %al,%eax
    45d7:	83 e0 07             	and    $0x7,%eax
    45da:	89 c1                	mov    %eax,%ecx
    45dc:	d3 e3                	shl    %cl,%ebx
    45de:	89 d8                	mov    %ebx,%eax
    45e0:	09 f0                	or     %esi,%eax
    45e2:	88 02                	mov    %al,(%edx)
    45e4:	8b 45 08             	mov    0x8(%ebp),%eax
    45e7:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    45eb:	8d 50 01             	lea    0x1(%eax),%edx
    45ee:	8b 45 08             	mov    0x8(%ebp),%eax
    45f1:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    45f4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    45f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    45fb:	3b 45 10             	cmp    0x10(%ebp),%eax
    45fe:	0f 85 37 ff ff ff    	jne    453b <writeBitsReversed+0x14>
    4604:	eb 01                	jmp    4607 <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    4606:	90                   	nop
  }
}
    4607:	8d 65 f8             	lea    -0x8(%ebp),%esp
    460a:	5b                   	pop    %ebx
    460b:	5e                   	pop    %esi
    460c:	5d                   	pop    %ebp
    460d:	c3                   	ret    

0000460e <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    460e:	55                   	push   %ebp
    460f:	89 e5                	mov    %esp,%ebp
    4611:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    4614:	8b 45 08             	mov    0x8(%ebp),%eax
    4617:	8b 55 0c             	mov    0xc(%ebp),%edx
    461a:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    461c:	8b 45 08             	mov    0x8(%ebp),%eax
    461f:	8b 55 10             	mov    0x10(%ebp),%edx
    4622:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    4625:	8b 45 08             	mov    0x8(%ebp),%eax
    4628:	83 c0 08             	add    $0x8,%eax
    462b:	50                   	push   %eax
    462c:	6a 08                	push   $0x8
    462e:	ff 75 10             	pushl  0x10(%ebp)
    4631:	e8 59 f9 ff ff       	call   3f8f <lodepng_mulofl>
    4636:	83 c4 0c             	add    $0xc,%esp
    4639:	85 c0                	test   %eax,%eax
    463b:	74 07                	je     4644 <LodePNGBitReader_init+0x36>
    463d:	b8 69 00 00 00       	mov    $0x69,%eax
    4642:	eb 39                	jmp    467d <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    4644:	8b 45 08             	mov    0x8(%ebp),%eax
    4647:	8b 40 08             	mov    0x8(%eax),%eax
    464a:	8d 55 fc             	lea    -0x4(%ebp),%edx
    464d:	52                   	push   %edx
    464e:	6a 40                	push   $0x40
    4650:	50                   	push   %eax
    4651:	e8 19 f9 ff ff       	call   3f6f <lodepng_addofl>
    4656:	83 c4 0c             	add    $0xc,%esp
    4659:	85 c0                	test   %eax,%eax
    465b:	74 07                	je     4664 <LodePNGBitReader_init+0x56>
    465d:	b8 69 00 00 00       	mov    $0x69,%eax
    4662:	eb 19                	jmp    467d <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    4664:	8b 45 08             	mov    0x8(%ebp),%eax
    4667:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    466e:	8b 45 08             	mov    0x8(%ebp),%eax
    4671:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    4678:	b8 00 00 00 00       	mov    $0x0,%eax
}
    467d:	c9                   	leave  
    467e:	c3                   	ret    

0000467f <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    467f:	55                   	push   %ebp
    4680:	89 e5                	mov    %esp,%ebp
    4682:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4685:	8b 45 08             	mov    0x8(%ebp),%eax
    4688:	8b 40 0c             	mov    0xc(%eax),%eax
    468b:	c1 f8 03             	sar    $0x3,%eax
    468e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    4691:	8b 45 08             	mov    0x8(%ebp),%eax
    4694:	8b 40 04             	mov    0x4(%eax),%eax
    4697:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    469a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    469d:	8d 50 01             	lea    0x1(%eax),%edx
    46a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    46a3:	39 c2                	cmp    %eax,%edx
    46a5:	73 4e                	jae    46f5 <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    46a7:	8b 45 08             	mov    0x8(%ebp),%eax
    46aa:	8b 10                	mov    (%eax),%edx
    46ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
    46af:	01 d0                	add    %edx,%eax
    46b1:	0f b6 00             	movzbl (%eax),%eax
    46b4:	0f b6 d0             	movzbl %al,%edx
    46b7:	8b 45 08             	mov    0x8(%ebp),%eax
    46ba:	8b 00                	mov    (%eax),%eax
    46bc:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    46bf:	83 c1 01             	add    $0x1,%ecx
    46c2:	01 c8                	add    %ecx,%eax
    46c4:	0f b6 00             	movzbl (%eax),%eax
    46c7:	0f b6 c0             	movzbl %al,%eax
    46ca:	c1 e0 08             	shl    $0x8,%eax
    46cd:	09 c2                	or     %eax,%edx
    46cf:	8b 45 08             	mov    0x8(%ebp),%eax
    46d2:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    46d5:	8b 45 08             	mov    0x8(%ebp),%eax
    46d8:	8b 50 10             	mov    0x10(%eax),%edx
    46db:	8b 45 08             	mov    0x8(%ebp),%eax
    46de:	8b 40 0c             	mov    0xc(%eax),%eax
    46e1:	83 e0 07             	and    $0x7,%eax
    46e4:	89 c1                	mov    %eax,%ecx
    46e6:	d3 ea                	shr    %cl,%edx
    46e8:	8b 45 08             	mov    0x8(%ebp),%eax
    46eb:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    46ee:	b8 01 00 00 00       	mov    $0x1,%eax
    46f3:	eb 64                	jmp    4759 <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    46f5:	8b 45 08             	mov    0x8(%ebp),%eax
    46f8:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    46ff:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4702:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4705:	39 c2                	cmp    %eax,%edx
    4707:	73 1e                	jae    4727 <ensureBits9+0xa8>
    4709:	8b 45 08             	mov    0x8(%ebp),%eax
    470c:	8b 50 10             	mov    0x10(%eax),%edx
    470f:	8b 45 08             	mov    0x8(%ebp),%eax
    4712:	8b 08                	mov    (%eax),%ecx
    4714:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4717:	01 c8                	add    %ecx,%eax
    4719:	0f b6 00             	movzbl (%eax),%eax
    471c:	0f b6 c0             	movzbl %al,%eax
    471f:	09 c2                	or     %eax,%edx
    4721:	8b 45 08             	mov    0x8(%ebp),%eax
    4724:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4727:	8b 45 08             	mov    0x8(%ebp),%eax
    472a:	8b 50 10             	mov    0x10(%eax),%edx
    472d:	8b 45 08             	mov    0x8(%ebp),%eax
    4730:	8b 40 0c             	mov    0xc(%eax),%eax
    4733:	83 e0 07             	and    $0x7,%eax
    4736:	89 c1                	mov    %eax,%ecx
    4738:	d3 ea                	shr    %cl,%edx
    473a:	8b 45 08             	mov    0x8(%ebp),%eax
    473d:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4740:	8b 45 08             	mov    0x8(%ebp),%eax
    4743:	8b 50 0c             	mov    0xc(%eax),%edx
    4746:	8b 45 0c             	mov    0xc(%ebp),%eax
    4749:	01 c2                	add    %eax,%edx
    474b:	8b 45 08             	mov    0x8(%ebp),%eax
    474e:	8b 40 08             	mov    0x8(%eax),%eax
    4751:	39 c2                	cmp    %eax,%edx
    4753:	0f 9e c0             	setle  %al
    4756:	0f b6 c0             	movzbl %al,%eax
  }
}
    4759:	c9                   	leave  
    475a:	c3                   	ret    

0000475b <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    475b:	55                   	push   %ebp
    475c:	89 e5                	mov    %esp,%ebp
    475e:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4761:	8b 45 08             	mov    0x8(%ebp),%eax
    4764:	8b 40 0c             	mov    0xc(%eax),%eax
    4767:	c1 f8 03             	sar    $0x3,%eax
    476a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    476d:	8b 45 08             	mov    0x8(%ebp),%eax
    4770:	8b 40 04             	mov    0x4(%eax),%eax
    4773:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    4776:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4779:	8d 50 02             	lea    0x2(%eax),%edx
    477c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    477f:	39 c2                	cmp    %eax,%edx
    4781:	73 6d                	jae    47f0 <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4783:	8b 45 08             	mov    0x8(%ebp),%eax
    4786:	8b 10                	mov    (%eax),%edx
    4788:	8b 45 fc             	mov    -0x4(%ebp),%eax
    478b:	01 d0                	add    %edx,%eax
    478d:	0f b6 00             	movzbl (%eax),%eax
    4790:	0f b6 d0             	movzbl %al,%edx
    4793:	8b 45 08             	mov    0x8(%ebp),%eax
    4796:	8b 00                	mov    (%eax),%eax
    4798:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    479b:	83 c1 01             	add    $0x1,%ecx
    479e:	01 c8                	add    %ecx,%eax
    47a0:	0f b6 00             	movzbl (%eax),%eax
    47a3:	0f b6 c0             	movzbl %al,%eax
    47a6:	c1 e0 08             	shl    $0x8,%eax
    47a9:	89 d1                	mov    %edx,%ecx
    47ab:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    47ad:	8b 45 08             	mov    0x8(%ebp),%eax
    47b0:	8b 00                	mov    (%eax),%eax
    47b2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    47b5:	83 c2 02             	add    $0x2,%edx
    47b8:	01 d0                	add    %edx,%eax
    47ba:	0f b6 00             	movzbl (%eax),%eax
    47bd:	0f b6 c0             	movzbl %al,%eax
    47c0:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    47c3:	09 c1                	or     %eax,%ecx
    47c5:	89 ca                	mov    %ecx,%edx
    47c7:	8b 45 08             	mov    0x8(%ebp),%eax
    47ca:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    47cd:	8b 45 08             	mov    0x8(%ebp),%eax
    47d0:	8b 50 10             	mov    0x10(%eax),%edx
    47d3:	8b 45 08             	mov    0x8(%ebp),%eax
    47d6:	8b 40 0c             	mov    0xc(%eax),%eax
    47d9:	83 e0 07             	and    $0x7,%eax
    47dc:	89 c1                	mov    %eax,%ecx
    47de:	d3 ea                	shr    %cl,%edx
    47e0:	8b 45 08             	mov    0x8(%ebp),%eax
    47e3:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    47e6:	b8 01 00 00 00       	mov    $0x1,%eax
    47eb:	e9 95 00 00 00       	jmp    4885 <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    47f0:	8b 45 08             	mov    0x8(%ebp),%eax
    47f3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    47fa:	8b 55 fc             	mov    -0x4(%ebp),%edx
    47fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4800:	39 c2                	cmp    %eax,%edx
    4802:	73 1e                	jae    4822 <ensureBits17+0xc7>
    4804:	8b 45 08             	mov    0x8(%ebp),%eax
    4807:	8b 50 10             	mov    0x10(%eax),%edx
    480a:	8b 45 08             	mov    0x8(%ebp),%eax
    480d:	8b 08                	mov    (%eax),%ecx
    480f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4812:	01 c8                	add    %ecx,%eax
    4814:	0f b6 00             	movzbl (%eax),%eax
    4817:	0f b6 c0             	movzbl %al,%eax
    481a:	09 c2                	or     %eax,%edx
    481c:	8b 45 08             	mov    0x8(%ebp),%eax
    481f:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    4822:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4825:	8d 50 01             	lea    0x1(%eax),%edx
    4828:	8b 45 f8             	mov    -0x8(%ebp),%eax
    482b:	39 c2                	cmp    %eax,%edx
    482d:	73 24                	jae    4853 <ensureBits17+0xf8>
    482f:	8b 45 08             	mov    0x8(%ebp),%eax
    4832:	8b 50 10             	mov    0x10(%eax),%edx
    4835:	8b 45 08             	mov    0x8(%ebp),%eax
    4838:	8b 00                	mov    (%eax),%eax
    483a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    483d:	83 c1 01             	add    $0x1,%ecx
    4840:	01 c8                	add    %ecx,%eax
    4842:	0f b6 00             	movzbl (%eax),%eax
    4845:	0f b6 c0             	movzbl %al,%eax
    4848:	c1 e0 08             	shl    $0x8,%eax
    484b:	09 c2                	or     %eax,%edx
    484d:	8b 45 08             	mov    0x8(%ebp),%eax
    4850:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4853:	8b 45 08             	mov    0x8(%ebp),%eax
    4856:	8b 50 10             	mov    0x10(%eax),%edx
    4859:	8b 45 08             	mov    0x8(%ebp),%eax
    485c:	8b 40 0c             	mov    0xc(%eax),%eax
    485f:	83 e0 07             	and    $0x7,%eax
    4862:	89 c1                	mov    %eax,%ecx
    4864:	d3 ea                	shr    %cl,%edx
    4866:	8b 45 08             	mov    0x8(%ebp),%eax
    4869:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    486c:	8b 45 08             	mov    0x8(%ebp),%eax
    486f:	8b 50 0c             	mov    0xc(%eax),%edx
    4872:	8b 45 0c             	mov    0xc(%ebp),%eax
    4875:	01 c2                	add    %eax,%edx
    4877:	8b 45 08             	mov    0x8(%ebp),%eax
    487a:	8b 40 08             	mov    0x8(%eax),%eax
    487d:	39 c2                	cmp    %eax,%edx
    487f:	0f 9e c0             	setle  %al
    4882:	0f b6 c0             	movzbl %al,%eax
  }
}
    4885:	c9                   	leave  
    4886:	c3                   	ret    

00004887 <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    4887:	55                   	push   %ebp
    4888:	89 e5                	mov    %esp,%ebp
    488a:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    488d:	8b 45 08             	mov    0x8(%ebp),%eax
    4890:	8b 40 0c             	mov    0xc(%eax),%eax
    4893:	c1 f8 03             	sar    $0x3,%eax
    4896:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    4899:	8b 45 08             	mov    0x8(%ebp),%eax
    489c:	8b 40 04             	mov    0x4(%eax),%eax
    489f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    48a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    48a5:	8d 50 03             	lea    0x3(%eax),%edx
    48a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    48ab:	39 c2                	cmp    %eax,%edx
    48ad:	0f 83 85 00 00 00    	jae    4938 <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    48b3:	8b 45 08             	mov    0x8(%ebp),%eax
    48b6:	8b 10                	mov    (%eax),%edx
    48b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    48bb:	01 d0                	add    %edx,%eax
    48bd:	0f b6 00             	movzbl (%eax),%eax
    48c0:	0f b6 d0             	movzbl %al,%edx
    48c3:	8b 45 08             	mov    0x8(%ebp),%eax
    48c6:	8b 00                	mov    (%eax),%eax
    48c8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    48cb:	83 c1 01             	add    $0x1,%ecx
    48ce:	01 c8                	add    %ecx,%eax
    48d0:	0f b6 00             	movzbl (%eax),%eax
    48d3:	0f b6 c0             	movzbl %al,%eax
    48d6:	c1 e0 08             	shl    $0x8,%eax
    48d9:	89 d1                	mov    %edx,%ecx
    48db:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    48dd:	8b 45 08             	mov    0x8(%ebp),%eax
    48e0:	8b 00                	mov    (%eax),%eax
    48e2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    48e5:	83 c2 02             	add    $0x2,%edx
    48e8:	01 d0                	add    %edx,%eax
    48ea:	0f b6 00             	movzbl (%eax),%eax
    48ed:	0f b6 c0             	movzbl %al,%eax
    48f0:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    48f3:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    48f5:	8b 45 08             	mov    0x8(%ebp),%eax
    48f8:	8b 00                	mov    (%eax),%eax
    48fa:	8b 55 fc             	mov    -0x4(%ebp),%edx
    48fd:	83 c2 03             	add    $0x3,%edx
    4900:	01 d0                	add    %edx,%eax
    4902:	0f b6 00             	movzbl (%eax),%eax
    4905:	0f b6 c0             	movzbl %al,%eax
    4908:	c1 e0 18             	shl    $0x18,%eax
    490b:	09 c1                	or     %eax,%ecx
    490d:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    490f:	8b 45 08             	mov    0x8(%ebp),%eax
    4912:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    4915:	8b 45 08             	mov    0x8(%ebp),%eax
    4918:	8b 50 10             	mov    0x10(%eax),%edx
    491b:	8b 45 08             	mov    0x8(%ebp),%eax
    491e:	8b 40 0c             	mov    0xc(%eax),%eax
    4921:	83 e0 07             	and    $0x7,%eax
    4924:	89 c1                	mov    %eax,%ecx
    4926:	d3 ea                	shr    %cl,%edx
    4928:	8b 45 08             	mov    0x8(%ebp),%eax
    492b:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    492e:	b8 01 00 00 00       	mov    $0x1,%eax
    4933:	e9 c6 00 00 00       	jmp    49fe <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    4938:	8b 45 08             	mov    0x8(%ebp),%eax
    493b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    4942:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4945:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4948:	39 c2                	cmp    %eax,%edx
    494a:	73 1e                	jae    496a <ensureBits25+0xe3>
    494c:	8b 45 08             	mov    0x8(%ebp),%eax
    494f:	8b 50 10             	mov    0x10(%eax),%edx
    4952:	8b 45 08             	mov    0x8(%ebp),%eax
    4955:	8b 08                	mov    (%eax),%ecx
    4957:	8b 45 fc             	mov    -0x4(%ebp),%eax
    495a:	01 c8                	add    %ecx,%eax
    495c:	0f b6 00             	movzbl (%eax),%eax
    495f:	0f b6 c0             	movzbl %al,%eax
    4962:	09 c2                	or     %eax,%edx
    4964:	8b 45 08             	mov    0x8(%ebp),%eax
    4967:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    496a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    496d:	8d 50 01             	lea    0x1(%eax),%edx
    4970:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4973:	39 c2                	cmp    %eax,%edx
    4975:	73 24                	jae    499b <ensureBits25+0x114>
    4977:	8b 45 08             	mov    0x8(%ebp),%eax
    497a:	8b 50 10             	mov    0x10(%eax),%edx
    497d:	8b 45 08             	mov    0x8(%ebp),%eax
    4980:	8b 00                	mov    (%eax),%eax
    4982:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4985:	83 c1 01             	add    $0x1,%ecx
    4988:	01 c8                	add    %ecx,%eax
    498a:	0f b6 00             	movzbl (%eax),%eax
    498d:	0f b6 c0             	movzbl %al,%eax
    4990:	c1 e0 08             	shl    $0x8,%eax
    4993:	09 c2                	or     %eax,%edx
    4995:	8b 45 08             	mov    0x8(%ebp),%eax
    4998:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    499b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    499e:	8d 50 02             	lea    0x2(%eax),%edx
    49a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    49a4:	39 c2                	cmp    %eax,%edx
    49a6:	73 24                	jae    49cc <ensureBits25+0x145>
    49a8:	8b 45 08             	mov    0x8(%ebp),%eax
    49ab:	8b 50 10             	mov    0x10(%eax),%edx
    49ae:	8b 45 08             	mov    0x8(%ebp),%eax
    49b1:	8b 00                	mov    (%eax),%eax
    49b3:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    49b6:	83 c1 02             	add    $0x2,%ecx
    49b9:	01 c8                	add    %ecx,%eax
    49bb:	0f b6 00             	movzbl (%eax),%eax
    49be:	0f b6 c0             	movzbl %al,%eax
    49c1:	c1 e0 10             	shl    $0x10,%eax
    49c4:	09 c2                	or     %eax,%edx
    49c6:	8b 45 08             	mov    0x8(%ebp),%eax
    49c9:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    49cc:	8b 45 08             	mov    0x8(%ebp),%eax
    49cf:	8b 50 10             	mov    0x10(%eax),%edx
    49d2:	8b 45 08             	mov    0x8(%ebp),%eax
    49d5:	8b 40 0c             	mov    0xc(%eax),%eax
    49d8:	83 e0 07             	and    $0x7,%eax
    49db:	89 c1                	mov    %eax,%ecx
    49dd:	d3 ea                	shr    %cl,%edx
    49df:	8b 45 08             	mov    0x8(%ebp),%eax
    49e2:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    49e5:	8b 45 08             	mov    0x8(%ebp),%eax
    49e8:	8b 50 0c             	mov    0xc(%eax),%edx
    49eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    49ee:	01 c2                	add    %eax,%edx
    49f0:	8b 45 08             	mov    0x8(%ebp),%eax
    49f3:	8b 40 08             	mov    0x8(%eax),%eax
    49f6:	39 c2                	cmp    %eax,%edx
    49f8:	0f 9e c0             	setle  %al
    49fb:	0f b6 c0             	movzbl %al,%eax
  }
}
    49fe:	c9                   	leave  
    49ff:	c3                   	ret    

00004a00 <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    4a00:	55                   	push   %ebp
    4a01:	89 e5                	mov    %esp,%ebp
    4a03:	53                   	push   %ebx
    4a04:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4a07:	8b 45 08             	mov    0x8(%ebp),%eax
    4a0a:	8b 40 0c             	mov    0xc(%eax),%eax
    4a0d:	c1 f8 03             	sar    $0x3,%eax
    4a10:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    4a13:	8b 45 08             	mov    0x8(%ebp),%eax
    4a16:	8b 40 04             	mov    0x4(%eax),%eax
    4a19:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    4a1c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4a1f:	8d 50 04             	lea    0x4(%eax),%edx
    4a22:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a25:	39 c2                	cmp    %eax,%edx
    4a27:	0f 83 c3 00 00 00    	jae    4af0 <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4a2d:	8b 45 08             	mov    0x8(%ebp),%eax
    4a30:	8b 10                	mov    (%eax),%edx
    4a32:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4a35:	01 d0                	add    %edx,%eax
    4a37:	0f b6 00             	movzbl (%eax),%eax
    4a3a:	0f b6 d0             	movzbl %al,%edx
    4a3d:	8b 45 08             	mov    0x8(%ebp),%eax
    4a40:	8b 00                	mov    (%eax),%eax
    4a42:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4a45:	83 c1 01             	add    $0x1,%ecx
    4a48:	01 c8                	add    %ecx,%eax
    4a4a:	0f b6 00             	movzbl (%eax),%eax
    4a4d:	0f b6 c0             	movzbl %al,%eax
    4a50:	c1 e0 08             	shl    $0x8,%eax
    4a53:	89 d1                	mov    %edx,%ecx
    4a55:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4a57:	8b 45 08             	mov    0x8(%ebp),%eax
    4a5a:	8b 00                	mov    (%eax),%eax
    4a5c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a5f:	83 c2 02             	add    $0x2,%edx
    4a62:	01 d0                	add    %edx,%eax
    4a64:	0f b6 00             	movzbl (%eax),%eax
    4a67:	0f b6 c0             	movzbl %al,%eax
    4a6a:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4a6d:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4a6f:	8b 45 08             	mov    0x8(%ebp),%eax
    4a72:	8b 00                	mov    (%eax),%eax
    4a74:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a77:	83 c2 03             	add    $0x3,%edx
    4a7a:	01 d0                	add    %edx,%eax
    4a7c:	0f b6 00             	movzbl (%eax),%eax
    4a7f:	0f b6 c0             	movzbl %al,%eax
    4a82:	c1 e0 18             	shl    $0x18,%eax
    4a85:	09 c1                	or     %eax,%ecx
    4a87:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4a89:	8b 45 08             	mov    0x8(%ebp),%eax
    4a8c:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    4a8f:	8b 45 08             	mov    0x8(%ebp),%eax
    4a92:	8b 50 10             	mov    0x10(%eax),%edx
    4a95:	8b 45 08             	mov    0x8(%ebp),%eax
    4a98:	8b 40 0c             	mov    0xc(%eax),%eax
    4a9b:	83 e0 07             	and    $0x7,%eax
    4a9e:	89 c1                	mov    %eax,%ecx
    4aa0:	d3 ea                	shr    %cl,%edx
    4aa2:	8b 45 08             	mov    0x8(%ebp),%eax
    4aa5:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    4aa8:	8b 45 08             	mov    0x8(%ebp),%eax
    4aab:	8b 50 10             	mov    0x10(%eax),%edx
    4aae:	8b 45 08             	mov    0x8(%ebp),%eax
    4ab1:	8b 00                	mov    (%eax),%eax
    4ab3:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4ab6:	83 c1 04             	add    $0x4,%ecx
    4ab9:	01 c8                	add    %ecx,%eax
    4abb:	0f b6 00             	movzbl (%eax),%eax
    4abe:	0f b6 c0             	movzbl %al,%eax
    4ac1:	c1 e0 18             	shl    $0x18,%eax
    4ac4:	89 c3                	mov    %eax,%ebx
    4ac6:	8b 45 08             	mov    0x8(%ebp),%eax
    4ac9:	8b 40 0c             	mov    0xc(%eax),%eax
    4acc:	83 e0 07             	and    $0x7,%eax
    4acf:	b9 08 00 00 00       	mov    $0x8,%ecx
    4ad4:	29 c1                	sub    %eax,%ecx
    4ad6:	89 c8                	mov    %ecx,%eax
    4ad8:	89 c1                	mov    %eax,%ecx
    4ada:	d3 e3                	shl    %cl,%ebx
    4adc:	89 d8                	mov    %ebx,%eax
    4ade:	09 c2                	or     %eax,%edx
    4ae0:	8b 45 08             	mov    0x8(%ebp),%eax
    4ae3:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    4ae6:	b8 01 00 00 00       	mov    $0x1,%eax
    4aeb:	e9 f7 00 00 00       	jmp    4be7 <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    4af0:	8b 45 08             	mov    0x8(%ebp),%eax
    4af3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    4afa:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4afd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b00:	39 c2                	cmp    %eax,%edx
    4b02:	73 1e                	jae    4b22 <ensureBits32+0x122>
    4b04:	8b 45 08             	mov    0x8(%ebp),%eax
    4b07:	8b 50 10             	mov    0x10(%eax),%edx
    4b0a:	8b 45 08             	mov    0x8(%ebp),%eax
    4b0d:	8b 08                	mov    (%eax),%ecx
    4b0f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4b12:	01 c8                	add    %ecx,%eax
    4b14:	0f b6 00             	movzbl (%eax),%eax
    4b17:	0f b6 c0             	movzbl %al,%eax
    4b1a:	09 c2                	or     %eax,%edx
    4b1c:	8b 45 08             	mov    0x8(%ebp),%eax
    4b1f:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    4b22:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4b25:	8d 50 01             	lea    0x1(%eax),%edx
    4b28:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b2b:	39 c2                	cmp    %eax,%edx
    4b2d:	73 24                	jae    4b53 <ensureBits32+0x153>
    4b2f:	8b 45 08             	mov    0x8(%ebp),%eax
    4b32:	8b 50 10             	mov    0x10(%eax),%edx
    4b35:	8b 45 08             	mov    0x8(%ebp),%eax
    4b38:	8b 00                	mov    (%eax),%eax
    4b3a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4b3d:	83 c1 01             	add    $0x1,%ecx
    4b40:	01 c8                	add    %ecx,%eax
    4b42:	0f b6 00             	movzbl (%eax),%eax
    4b45:	0f b6 c0             	movzbl %al,%eax
    4b48:	c1 e0 08             	shl    $0x8,%eax
    4b4b:	09 c2                	or     %eax,%edx
    4b4d:	8b 45 08             	mov    0x8(%ebp),%eax
    4b50:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    4b53:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4b56:	8d 50 02             	lea    0x2(%eax),%edx
    4b59:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b5c:	39 c2                	cmp    %eax,%edx
    4b5e:	73 24                	jae    4b84 <ensureBits32+0x184>
    4b60:	8b 45 08             	mov    0x8(%ebp),%eax
    4b63:	8b 50 10             	mov    0x10(%eax),%edx
    4b66:	8b 45 08             	mov    0x8(%ebp),%eax
    4b69:	8b 00                	mov    (%eax),%eax
    4b6b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4b6e:	83 c1 02             	add    $0x2,%ecx
    4b71:	01 c8                	add    %ecx,%eax
    4b73:	0f b6 00             	movzbl (%eax),%eax
    4b76:	0f b6 c0             	movzbl %al,%eax
    4b79:	c1 e0 10             	shl    $0x10,%eax
    4b7c:	09 c2                	or     %eax,%edx
    4b7e:	8b 45 08             	mov    0x8(%ebp),%eax
    4b81:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    4b84:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4b87:	8d 50 03             	lea    0x3(%eax),%edx
    4b8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b8d:	39 c2                	cmp    %eax,%edx
    4b8f:	73 24                	jae    4bb5 <ensureBits32+0x1b5>
    4b91:	8b 45 08             	mov    0x8(%ebp),%eax
    4b94:	8b 50 10             	mov    0x10(%eax),%edx
    4b97:	8b 45 08             	mov    0x8(%ebp),%eax
    4b9a:	8b 00                	mov    (%eax),%eax
    4b9c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4b9f:	83 c1 03             	add    $0x3,%ecx
    4ba2:	01 c8                	add    %ecx,%eax
    4ba4:	0f b6 00             	movzbl (%eax),%eax
    4ba7:	0f b6 c0             	movzbl %al,%eax
    4baa:	c1 e0 18             	shl    $0x18,%eax
    4bad:	09 c2                	or     %eax,%edx
    4baf:	8b 45 08             	mov    0x8(%ebp),%eax
    4bb2:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4bb5:	8b 45 08             	mov    0x8(%ebp),%eax
    4bb8:	8b 50 10             	mov    0x10(%eax),%edx
    4bbb:	8b 45 08             	mov    0x8(%ebp),%eax
    4bbe:	8b 40 0c             	mov    0xc(%eax),%eax
    4bc1:	83 e0 07             	and    $0x7,%eax
    4bc4:	89 c1                	mov    %eax,%ecx
    4bc6:	d3 ea                	shr    %cl,%edx
    4bc8:	8b 45 08             	mov    0x8(%ebp),%eax
    4bcb:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4bce:	8b 45 08             	mov    0x8(%ebp),%eax
    4bd1:	8b 50 0c             	mov    0xc(%eax),%edx
    4bd4:	8b 45 0c             	mov    0xc(%ebp),%eax
    4bd7:	01 c2                	add    %eax,%edx
    4bd9:	8b 45 08             	mov    0x8(%ebp),%eax
    4bdc:	8b 40 08             	mov    0x8(%eax),%eax
    4bdf:	39 c2                	cmp    %eax,%edx
    4be1:	0f 9e c0             	setle  %al
    4be4:	0f b6 c0             	movzbl %al,%eax
  }
}
    4be7:	83 c4 10             	add    $0x10,%esp
    4bea:	5b                   	pop    %ebx
    4beb:	5d                   	pop    %ebp
    4bec:	c3                   	ret    

00004bed <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    4bed:	55                   	push   %ebp
    4bee:	89 e5                	mov    %esp,%ebp
    4bf0:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    4bf1:	8b 45 08             	mov    0x8(%ebp),%eax
    4bf4:	8b 50 10             	mov    0x10(%eax),%edx
    4bf7:	8b 45 0c             	mov    0xc(%ebp),%eax
    4bfa:	bb 01 00 00 00       	mov    $0x1,%ebx
    4bff:	89 c1                	mov    %eax,%ecx
    4c01:	d3 e3                	shl    %cl,%ebx
    4c03:	89 d8                	mov    %ebx,%eax
    4c05:	83 e8 01             	sub    $0x1,%eax
    4c08:	21 d0                	and    %edx,%eax
}
    4c0a:	5b                   	pop    %ebx
    4c0b:	5d                   	pop    %ebp
    4c0c:	c3                   	ret    

00004c0d <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    4c0d:	55                   	push   %ebp
    4c0e:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    4c10:	8b 45 08             	mov    0x8(%ebp),%eax
    4c13:	8b 50 10             	mov    0x10(%eax),%edx
    4c16:	8b 45 0c             	mov    0xc(%ebp),%eax
    4c19:	89 c1                	mov    %eax,%ecx
    4c1b:	d3 ea                	shr    %cl,%edx
    4c1d:	8b 45 08             	mov    0x8(%ebp),%eax
    4c20:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    4c23:	8b 45 08             	mov    0x8(%ebp),%eax
    4c26:	8b 50 0c             	mov    0xc(%eax),%edx
    4c29:	8b 45 0c             	mov    0xc(%ebp),%eax
    4c2c:	01 c2                	add    %eax,%edx
    4c2e:	8b 45 08             	mov    0x8(%ebp),%eax
    4c31:	89 50 0c             	mov    %edx,0xc(%eax)
}
    4c34:	90                   	nop
    4c35:	5d                   	pop    %ebp
    4c36:	c3                   	ret    

00004c37 <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    4c37:	55                   	push   %ebp
    4c38:	89 e5                	mov    %esp,%ebp
    4c3a:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    4c3d:	ff 75 0c             	pushl  0xc(%ebp)
    4c40:	ff 75 08             	pushl  0x8(%ebp)
    4c43:	e8 a5 ff ff ff       	call   4bed <peekBits>
    4c48:	83 c4 08             	add    $0x8,%esp
    4c4b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    4c4e:	ff 75 0c             	pushl  0xc(%ebp)
    4c51:	ff 75 08             	pushl  0x8(%ebp)
    4c54:	e8 b4 ff ff ff       	call   4c0d <advanceBits>
    4c59:	83 c4 08             	add    $0x8,%esp
  return result;
    4c5c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    4c5f:	c9                   	leave  
    4c60:	c3                   	ret    

00004c61 <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    4c61:	55                   	push   %ebp
    4c62:	89 e5                	mov    %esp,%ebp
    4c64:	53                   	push   %ebx
    4c65:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    4c68:	ff 75 0c             	pushl  0xc(%ebp)
    4c6b:	ff 75 08             	pushl  0x8(%ebp)
    4c6e:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4c71:	50                   	push   %eax
    4c72:	e8 97 f9 ff ff       	call   460e <LodePNGBitReader_init>
    4c77:	83 c4 0c             	add    $0xc,%esp
    4c7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    4c7d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    4c81:	74 0a                	je     4c8d <lode_png_test_bitreader+0x2c>
    4c83:	b8 00 00 00 00       	mov    $0x0,%eax
    4c88:	e9 c3 00 00 00       	jmp    4d50 <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    4c8d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4c94:	e9 a6 00 00 00       	jmp    4d3f <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    4c99:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4c9c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4ca3:	8b 45 14             	mov    0x14(%ebp),%eax
    4ca6:	01 d0                	add    %edx,%eax
    4ca8:	8b 00                	mov    (%eax),%eax
    4caa:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    4cad:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    4cb1:	7e 14                	jle    4cc7 <lode_png_test_bitreader+0x66>
    4cb3:	ff 75 ec             	pushl  -0x14(%ebp)
    4cb6:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4cb9:	50                   	push   %eax
    4cba:	e8 41 fd ff ff       	call   4a00 <ensureBits32>
    4cbf:	83 c4 08             	add    $0x8,%esp
    4cc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4cc5:	eb 46                	jmp    4d0d <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    4cc7:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    4ccb:	7e 14                	jle    4ce1 <lode_png_test_bitreader+0x80>
    4ccd:	ff 75 ec             	pushl  -0x14(%ebp)
    4cd0:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4cd3:	50                   	push   %eax
    4cd4:	e8 ae fb ff ff       	call   4887 <ensureBits25>
    4cd9:	83 c4 08             	add    $0x8,%esp
    4cdc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4cdf:	eb 2c                	jmp    4d0d <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    4ce1:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    4ce5:	7e 14                	jle    4cfb <lode_png_test_bitreader+0x9a>
    4ce7:	ff 75 ec             	pushl  -0x14(%ebp)
    4cea:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4ced:	50                   	push   %eax
    4cee:	e8 68 fa ff ff       	call   475b <ensureBits17>
    4cf3:	83 c4 08             	add    $0x8,%esp
    4cf6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4cf9:	eb 12                	jmp    4d0d <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    4cfb:	ff 75 ec             	pushl  -0x14(%ebp)
    4cfe:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4d01:	50                   	push   %eax
    4d02:	e8 78 f9 ff ff       	call   467f <ensureBits9>
    4d07:	83 c4 08             	add    $0x8,%esp
    4d0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    4d0d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4d11:	75 07                	jne    4d1a <lode_png_test_bitreader+0xb9>
    4d13:	b8 00 00 00 00       	mov    $0x0,%eax
    4d18:	eb 36                	jmp    4d50 <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    4d1a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4d1d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4d24:	8b 45 18             	mov    0x18(%ebp),%eax
    4d27:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    4d2a:	ff 75 ec             	pushl  -0x14(%ebp)
    4d2d:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4d30:	50                   	push   %eax
    4d31:	e8 01 ff ff ff       	call   4c37 <readBits>
    4d36:	83 c4 08             	add    $0x8,%esp
    4d39:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    4d3b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4d3f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4d42:	3b 45 10             	cmp    0x10(%ebp),%eax
    4d45:	0f 8c 4e ff ff ff    	jl     4c99 <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    4d4b:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4d50:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4d53:	c9                   	leave  
    4d54:	c3                   	ret    

00004d55 <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    4d55:	55                   	push   %ebp
    4d56:	89 e5                	mov    %esp,%ebp
    4d58:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    4d5b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    4d62:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    4d69:	eb 27                	jmp    4d92 <reverseBits+0x3d>
    4d6b:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d6e:	2b 45 fc             	sub    -0x4(%ebp),%eax
    4d71:	83 e8 01             	sub    $0x1,%eax
    4d74:	8b 55 08             	mov    0x8(%ebp),%edx
    4d77:	89 c1                	mov    %eax,%ecx
    4d79:	d3 ea                	shr    %cl,%edx
    4d7b:	89 d0                	mov    %edx,%eax
    4d7d:	83 e0 01             	and    $0x1,%eax
    4d80:	89 c2                	mov    %eax,%edx
    4d82:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4d85:	89 c1                	mov    %eax,%ecx
    4d87:	d3 e2                	shl    %cl,%edx
    4d89:	89 d0                	mov    %edx,%eax
    4d8b:	09 45 f8             	or     %eax,-0x8(%ebp)
    4d8e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    4d92:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4d95:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4d98:	72 d1                	jb     4d6b <reverseBits+0x16>
  return result;
    4d9a:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    4d9d:	c9                   	leave  
    4d9e:	c3                   	ret    

00004d9f <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    4d9f:	55                   	push   %ebp
    4da0:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    4da2:	8b 45 08             	mov    0x8(%ebp),%eax
    4da5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    4dab:	8b 45 08             	mov    0x8(%ebp),%eax
    4dae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    4db5:	8b 45 08             	mov    0x8(%ebp),%eax
    4db8:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    4dbf:	8b 45 08             	mov    0x8(%ebp),%eax
    4dc2:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    4dc9:	90                   	nop
    4dca:	5d                   	pop    %ebp
    4dcb:	c3                   	ret    

00004dcc <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    4dcc:	55                   	push   %ebp
    4dcd:	89 e5                	mov    %esp,%ebp
    4dcf:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    4dd2:	8b 45 08             	mov    0x8(%ebp),%eax
    4dd5:	8b 00                	mov    (%eax),%eax
    4dd7:	83 ec 0c             	sub    $0xc,%esp
    4dda:	50                   	push   %eax
    4ddb:	e8 ec f0 ff ff       	call   3ecc <lodepng_free>
    4de0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    4de3:	8b 45 08             	mov    0x8(%ebp),%eax
    4de6:	8b 40 04             	mov    0x4(%eax),%eax
    4de9:	83 ec 0c             	sub    $0xc,%esp
    4dec:	50                   	push   %eax
    4ded:	e8 da f0 ff ff       	call   3ecc <lodepng_free>
    4df2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    4df5:	8b 45 08             	mov    0x8(%ebp),%eax
    4df8:	8b 40 10             	mov    0x10(%eax),%eax
    4dfb:	83 ec 0c             	sub    $0xc,%esp
    4dfe:	50                   	push   %eax
    4dff:	e8 c8 f0 ff ff       	call   3ecc <lodepng_free>
    4e04:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    4e07:	8b 45 08             	mov    0x8(%ebp),%eax
    4e0a:	8b 40 14             	mov    0x14(%eax),%eax
    4e0d:	83 ec 0c             	sub    $0xc,%esp
    4e10:	50                   	push   %eax
    4e11:	e8 b6 f0 ff ff       	call   3ecc <lodepng_free>
    4e16:	83 c4 10             	add    $0x10,%esp
}
    4e19:	90                   	nop
    4e1a:	c9                   	leave  
    4e1b:	c3                   	ret    

00004e1c <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    4e1c:	55                   	push   %ebp
    4e1d:	89 e5                	mov    %esp,%ebp
    4e1f:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    4e22:	a1 08 c2 01 00       	mov    0x1c208,%eax
    4e27:	c1 e0 02             	shl    $0x2,%eax
    4e2a:	83 ec 0c             	sub    $0xc,%esp
    4e2d:	50                   	push   %eax
    4e2e:	e8 78 f0 ff ff       	call   3eab <lodepng_malloc>
    4e33:	83 c4 10             	add    $0x10,%esp
    4e36:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    4e39:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    4e3d:	75 0a                	jne    4e49 <HuffmanTree_makeTable+0x2d>
    4e3f:	b8 53 00 00 00       	mov    $0x53,%eax
    4e44:	e9 61 04 00 00       	jmp    52aa <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    4e49:	a1 08 c2 01 00       	mov    0x1c208,%eax
    4e4e:	c1 e0 02             	shl    $0x2,%eax
    4e51:	83 ec 04             	sub    $0x4,%esp
    4e54:	50                   	push   %eax
    4e55:	6a 00                	push   $0x0
    4e57:	ff 75 dc             	pushl  -0x24(%ebp)
    4e5a:	e8 bd f0 ff ff       	call   3f1c <lodepng_memset>
    4e5f:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    4e62:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4e69:	eb 7d                	jmp    4ee8 <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    4e6b:	8b 45 08             	mov    0x8(%ebp),%eax
    4e6e:	8b 00                	mov    (%eax),%eax
    4e70:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4e73:	c1 e2 02             	shl    $0x2,%edx
    4e76:	01 d0                	add    %edx,%eax
    4e78:	8b 00                	mov    (%eax),%eax
    4e7a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    4e7d:	8b 45 08             	mov    0x8(%ebp),%eax
    4e80:	8b 40 04             	mov    0x4(%eax),%eax
    4e83:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4e86:	c1 e2 02             	shl    $0x2,%edx
    4e89:	01 d0                	add    %edx,%eax
    4e8b:	8b 00                	mov    (%eax),%eax
    4e8d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    4e90:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    4e94:	76 4d                	jbe    4ee3 <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    4e96:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4e99:	83 e8 09             	sub    $0x9,%eax
    4e9c:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4e9f:	89 c1                	mov    %eax,%ecx
    4ea1:	d3 ea                	shr    %cl,%edx
    4ea3:	89 d0                	mov    %edx,%eax
    4ea5:	83 ec 08             	sub    $0x8,%esp
    4ea8:	6a 09                	push   $0x9
    4eaa:	50                   	push   %eax
    4eab:	e8 a5 fe ff ff       	call   4d55 <reverseBits>
    4eb0:	83 c4 10             	add    $0x10,%esp
    4eb3:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    4eb6:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4eb9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4ec0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4ec3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    4ec6:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4ec9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4ed0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4ed3:	01 d0                	add    %edx,%eax
    4ed5:	8b 10                	mov    (%eax),%edx
    4ed7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4eda:	39 c2                	cmp    %eax,%edx
    4edc:	0f 43 c2             	cmovae %edx,%eax
    4edf:	89 01                	mov    %eax,(%ecx)
    4ee1:	eb 01                	jmp    4ee4 <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    4ee3:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    4ee4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4ee8:	8b 45 08             	mov    0x8(%ebp),%eax
    4eeb:	8b 50 0c             	mov    0xc(%eax),%edx
    4eee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4ef1:	39 c2                	cmp    %eax,%edx
    4ef3:	0f 87 72 ff ff ff    	ja     4e6b <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    4ef9:	a1 08 c2 01 00       	mov    0x1c208,%eax
    4efe:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    4f01:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4f08:	eb 35                	jmp    4f3f <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    4f0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f0d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4f14:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4f17:	01 d0                	add    %edx,%eax
    4f19:	8b 00                	mov    (%eax),%eax
    4f1b:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    4f1e:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    4f22:	76 17                	jbe    4f3b <HuffmanTree_makeTable+0x11f>
    4f24:	8b 45 cc             	mov    -0x34(%ebp),%eax
    4f27:	83 e8 09             	sub    $0x9,%eax
    4f2a:	ba 01 00 00 00       	mov    $0x1,%edx
    4f2f:	89 c1                	mov    %eax,%ecx
    4f31:	d3 e2                	shl    %cl,%edx
    4f33:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4f36:	01 d0                	add    %edx,%eax
    4f38:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    4f3b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4f3f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4f42:	a1 08 c2 01 00       	mov    0x1c208,%eax
    4f47:	39 c2                	cmp    %eax,%edx
    4f49:	72 bf                	jb     4f0a <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    4f4b:	83 ec 0c             	sub    $0xc,%esp
    4f4e:	ff 75 e8             	pushl  -0x18(%ebp)
    4f51:	e8 55 ef ff ff       	call   3eab <lodepng_malloc>
    4f56:	83 c4 10             	add    $0x10,%esp
    4f59:	89 c2                	mov    %eax,%edx
    4f5b:	8b 45 08             	mov    0x8(%ebp),%eax
    4f5e:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    4f61:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4f64:	01 c0                	add    %eax,%eax
    4f66:	83 ec 0c             	sub    $0xc,%esp
    4f69:	50                   	push   %eax
    4f6a:	e8 3c ef ff ff       	call   3eab <lodepng_malloc>
    4f6f:	83 c4 10             	add    $0x10,%esp
    4f72:	89 c2                	mov    %eax,%edx
    4f74:	8b 45 08             	mov    0x8(%ebp),%eax
    4f77:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    4f7a:	8b 45 08             	mov    0x8(%ebp),%eax
    4f7d:	8b 40 10             	mov    0x10(%eax),%eax
    4f80:	85 c0                	test   %eax,%eax
    4f82:	74 0a                	je     4f8e <HuffmanTree_makeTable+0x172>
    4f84:	8b 45 08             	mov    0x8(%ebp),%eax
    4f87:	8b 40 14             	mov    0x14(%eax),%eax
    4f8a:	85 c0                	test   %eax,%eax
    4f8c:	75 18                	jne    4fa6 <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    4f8e:	83 ec 0c             	sub    $0xc,%esp
    4f91:	ff 75 dc             	pushl  -0x24(%ebp)
    4f94:	e8 33 ef ff ff       	call   3ecc <lodepng_free>
    4f99:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    4f9c:	b8 53 00 00 00       	mov    $0x53,%eax
    4fa1:	e9 04 03 00 00       	jmp    52aa <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    4fa6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4fad:	eb 12                	jmp    4fc1 <HuffmanTree_makeTable+0x1a5>
    4faf:	8b 45 08             	mov    0x8(%ebp),%eax
    4fb2:	8b 50 10             	mov    0x10(%eax),%edx
    4fb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4fb8:	01 d0                	add    %edx,%eax
    4fba:	c6 00 10             	movb   $0x10,(%eax)
    4fbd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4fc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4fc4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4fc7:	7c e6                	jl     4faf <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    4fc9:	a1 08 c2 01 00       	mov    0x1c208,%eax
    4fce:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    4fd1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4fd8:	eb 5b                	jmp    5035 <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    4fda:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4fdd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4fe4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4fe7:	01 d0                	add    %edx,%eax
    4fe9:	8b 00                	mov    (%eax),%eax
    4feb:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    4fee:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    4ff2:	76 3c                	jbe    5030 <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    4ff4:	8b 45 08             	mov    0x8(%ebp),%eax
    4ff7:	8b 50 10             	mov    0x10(%eax),%edx
    4ffa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4ffd:	01 d0                	add    %edx,%eax
    4fff:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5002:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    5004:	8b 45 08             	mov    0x8(%ebp),%eax
    5007:	8b 40 14             	mov    0x14(%eax),%eax
    500a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    500d:	01 d2                	add    %edx,%edx
    500f:	01 d0                	add    %edx,%eax
    5011:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5014:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    5017:	8b 45 c8             	mov    -0x38(%ebp),%eax
    501a:	83 e8 09             	sub    $0x9,%eax
    501d:	ba 01 00 00 00       	mov    $0x1,%edx
    5022:	89 c1                	mov    %eax,%ecx
    5024:	d3 e2                	shl    %cl,%edx
    5026:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5029:	01 d0                	add    %edx,%eax
    502b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    502e:	eb 01                	jmp    5031 <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    5030:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    5031:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5035:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5038:	a1 08 c2 01 00       	mov    0x1c208,%eax
    503d:	39 c2                	cmp    %eax,%edx
    503f:	72 99                	jb     4fda <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    5041:	83 ec 0c             	sub    $0xc,%esp
    5044:	ff 75 dc             	pushl  -0x24(%ebp)
    5047:	e8 80 ee ff ff       	call   3ecc <lodepng_free>
    504c:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    504f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    5056:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    505d:	e9 9d 01 00 00       	jmp    51ff <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    5062:	8b 45 08             	mov    0x8(%ebp),%eax
    5065:	8b 40 04             	mov    0x4(%eax),%eax
    5068:	8b 55 f4             	mov    -0xc(%ebp),%edx
    506b:	c1 e2 02             	shl    $0x2,%edx
    506e:	01 d0                	add    %edx,%eax
    5070:	8b 00                	mov    (%eax),%eax
    5072:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    5075:	8b 45 08             	mov    0x8(%ebp),%eax
    5078:	8b 00                	mov    (%eax),%eax
    507a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    507d:	c1 e2 02             	shl    $0x2,%edx
    5080:	01 d0                	add    %edx,%eax
    5082:	8b 00                	mov    (%eax),%eax
    5084:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    5087:	83 ec 08             	sub    $0x8,%esp
    508a:	ff 75 c4             	pushl  -0x3c(%ebp)
    508d:	ff 75 c0             	pushl  -0x40(%ebp)
    5090:	e8 c0 fc ff ff       	call   4d55 <reverseBits>
    5095:	83 c4 10             	add    $0x10,%esp
    5098:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    509b:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    509f:	0f 84 55 01 00 00    	je     51fa <HuffmanTree_makeTable+0x3de>
    numpresent++;
    50a5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    50a9:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    50ad:	0f 87 81 00 00 00    	ja     5134 <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    50b3:	b8 09 00 00 00       	mov    $0x9,%eax
    50b8:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    50bb:	ba 01 00 00 00       	mov    $0x1,%edx
    50c0:	89 c1                	mov    %eax,%ecx
    50c2:	d3 e2                	shl    %cl,%edx
    50c4:	89 d0                	mov    %edx,%eax
    50c6:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    50c9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    50d0:	eb 55                	jmp    5127 <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    50d2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    50d5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    50d8:	89 c1                	mov    %eax,%ecx
    50da:	d3 e2                	shl    %cl,%edx
    50dc:	89 d0                	mov    %edx,%eax
    50de:	0b 45 bc             	or     -0x44(%ebp),%eax
    50e1:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    50e4:	8b 45 08             	mov    0x8(%ebp),%eax
    50e7:	8b 50 10             	mov    0x10(%eax),%edx
    50ea:	8b 45 98             	mov    -0x68(%ebp),%eax
    50ed:	01 d0                	add    %edx,%eax
    50ef:	0f b6 00             	movzbl (%eax),%eax
    50f2:	3c 10                	cmp    $0x10,%al
    50f4:	74 0a                	je     5100 <HuffmanTree_makeTable+0x2e4>
    50f6:	b8 37 00 00 00       	mov    $0x37,%eax
    50fb:	e9 aa 01 00 00       	jmp    52aa <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    5100:	8b 45 08             	mov    0x8(%ebp),%eax
    5103:	8b 50 10             	mov    0x10(%eax),%edx
    5106:	8b 45 98             	mov    -0x68(%ebp),%eax
    5109:	01 d0                	add    %edx,%eax
    510b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    510e:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    5110:	8b 45 08             	mov    0x8(%ebp),%eax
    5113:	8b 40 14             	mov    0x14(%eax),%eax
    5116:	8b 55 98             	mov    -0x68(%ebp),%edx
    5119:	01 d2                	add    %edx,%edx
    511b:	01 d0                	add    %edx,%eax
    511d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5120:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    5123:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    5127:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    512a:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    512d:	72 a3                	jb     50d2 <HuffmanTree_makeTable+0x2b6>
    512f:	e9 c7 00 00 00       	jmp    51fb <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    5134:	a1 0c c2 01 00       	mov    0x1c20c,%eax
    5139:	23 45 bc             	and    -0x44(%ebp),%eax
    513c:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    513f:	8b 45 08             	mov    0x8(%ebp),%eax
    5142:	8b 50 10             	mov    0x10(%eax),%edx
    5145:	8b 45 b8             	mov    -0x48(%ebp),%eax
    5148:	01 d0                	add    %edx,%eax
    514a:	0f b6 00             	movzbl (%eax),%eax
    514d:	0f b6 c0             	movzbl %al,%eax
    5150:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    5153:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    5156:	83 e8 09             	sub    $0x9,%eax
    5159:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    515c:	8b 45 08             	mov    0x8(%ebp),%eax
    515f:	8b 40 14             	mov    0x14(%eax),%eax
    5162:	8b 55 b8             	mov    -0x48(%ebp),%edx
    5165:	01 d2                	add    %edx,%edx
    5167:	01 d0                	add    %edx,%eax
    5169:	0f b7 00             	movzwl (%eax),%eax
    516c:	0f b7 c0             	movzwl %ax,%eax
    516f:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    5172:	8b 45 b0             	mov    -0x50(%ebp),%eax
    5175:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    5178:	83 c0 09             	add    $0x9,%eax
    517b:	ba 01 00 00 00       	mov    $0x1,%edx
    5180:	89 c1                	mov    %eax,%ecx
    5182:	d3 e2                	shl    %cl,%edx
    5184:	89 d0                	mov    %edx,%eax
    5186:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    5189:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    518c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    518f:	73 0a                	jae    519b <HuffmanTree_makeTable+0x37f>
    5191:	b8 37 00 00 00       	mov    $0x37,%eax
    5196:	e9 0f 01 00 00       	jmp    52aa <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    519b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    51a2:	eb 4c                	jmp    51f0 <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    51a4:	8b 45 bc             	mov    -0x44(%ebp),%eax
    51a7:	c1 e8 09             	shr    $0x9,%eax
    51aa:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    51ad:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    51b0:	83 e8 09             	sub    $0x9,%eax
    51b3:	8b 55 e0             	mov    -0x20(%ebp),%edx
    51b6:	89 c1                	mov    %eax,%ecx
    51b8:	d3 e2                	shl    %cl,%edx
    51ba:	89 d0                	mov    %edx,%eax
    51bc:	0b 45 a4             	or     -0x5c(%ebp),%eax
    51bf:	89 c2                	mov    %eax,%edx
    51c1:	8b 45 ac             	mov    -0x54(%ebp),%eax
    51c4:	01 d0                	add    %edx,%eax
    51c6:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    51c9:	8b 45 08             	mov    0x8(%ebp),%eax
    51cc:	8b 50 10             	mov    0x10(%eax),%edx
    51cf:	8b 45 a0             	mov    -0x60(%ebp),%eax
    51d2:	01 d0                	add    %edx,%eax
    51d4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    51d7:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    51d9:	8b 45 08             	mov    0x8(%ebp),%eax
    51dc:	8b 40 14             	mov    0x14(%eax),%eax
    51df:	8b 55 a0             	mov    -0x60(%ebp),%edx
    51e2:	01 d2                	add    %edx,%edx
    51e4:	01 d0                	add    %edx,%eax
    51e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    51e9:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    51ec:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    51f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    51f3:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    51f6:	72 ac                	jb     51a4 <HuffmanTree_makeTable+0x388>
    51f8:	eb 01                	jmp    51fb <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    51fa:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    51fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    51ff:	8b 45 08             	mov    0x8(%ebp),%eax
    5202:	8b 50 0c             	mov    0xc(%eax),%edx
    5205:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5208:	39 c2                	cmp    %eax,%edx
    520a:	0f 87 52 fe ff ff    	ja     5062 <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    5210:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    5214:	7f 61                	jg     5277 <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    5216:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    521d:	eb 4e                	jmp    526d <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    521f:	8b 45 08             	mov    0x8(%ebp),%eax
    5222:	8b 50 10             	mov    0x10(%eax),%edx
    5225:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5228:	01 d0                	add    %edx,%eax
    522a:	0f b6 00             	movzbl (%eax),%eax
    522d:	3c 10                	cmp    $0x10,%al
    522f:	75 38                	jne    5269 <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    5231:	8b 45 08             	mov    0x8(%ebp),%eax
    5234:	8b 50 10             	mov    0x10(%eax),%edx
    5237:	8b 45 f4             	mov    -0xc(%ebp),%eax
    523a:	01 d0                	add    %edx,%eax
    523c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    523f:	8b 15 08 c2 01 00    	mov    0x1c208,%edx
    5245:	39 d1                	cmp    %edx,%ecx
    5247:	73 07                	jae    5250 <HuffmanTree_makeTable+0x434>
    5249:	ba 01 00 00 00       	mov    $0x1,%edx
    524e:	eb 05                	jmp    5255 <HuffmanTree_makeTable+0x439>
    5250:	ba 0a 00 00 00       	mov    $0xa,%edx
    5255:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    5257:	8b 45 08             	mov    0x8(%ebp),%eax
    525a:	8b 40 14             	mov    0x14(%eax),%eax
    525d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5260:	01 d2                	add    %edx,%edx
    5262:	01 d0                	add    %edx,%eax
    5264:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    5269:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    526d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5270:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    5273:	7c aa                	jl     521f <HuffmanTree_makeTable+0x403>
    5275:	eb 2e                	jmp    52a5 <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    5277:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    527e:	eb 1d                	jmp    529d <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    5280:	8b 45 08             	mov    0x8(%ebp),%eax
    5283:	8b 50 10             	mov    0x10(%eax),%edx
    5286:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5289:	01 d0                	add    %edx,%eax
    528b:	0f b6 00             	movzbl (%eax),%eax
    528e:	3c 10                	cmp    $0x10,%al
    5290:	75 07                	jne    5299 <HuffmanTree_makeTable+0x47d>
    5292:	b8 37 00 00 00       	mov    $0x37,%eax
    5297:	eb 11                	jmp    52aa <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    5299:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    529d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    52a0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    52a3:	7c db                	jl     5280 <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    52a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    52aa:	c9                   	leave  
    52ab:	c3                   	ret    

000052ac <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    52ac:	55                   	push   %ebp
    52ad:	89 e5                	mov    %esp,%ebp
    52af:	56                   	push   %esi
    52b0:	53                   	push   %ebx
    52b1:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    52b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    52bb:	8b 45 08             	mov    0x8(%ebp),%eax
    52be:	8b 40 0c             	mov    0xc(%eax),%eax
    52c1:	c1 e0 02             	shl    $0x2,%eax
    52c4:	83 ec 0c             	sub    $0xc,%esp
    52c7:	50                   	push   %eax
    52c8:	e8 de eb ff ff       	call   3eab <lodepng_malloc>
    52cd:	83 c4 10             	add    $0x10,%esp
    52d0:	89 c2                	mov    %eax,%edx
    52d2:	8b 45 08             	mov    0x8(%ebp),%eax
    52d5:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    52d7:	8b 45 08             	mov    0x8(%ebp),%eax
    52da:	8b 40 08             	mov    0x8(%eax),%eax
    52dd:	83 c0 01             	add    $0x1,%eax
    52e0:	c1 e0 02             	shl    $0x2,%eax
    52e3:	83 ec 0c             	sub    $0xc,%esp
    52e6:	50                   	push   %eax
    52e7:	e8 bf eb ff ff       	call   3eab <lodepng_malloc>
    52ec:	83 c4 10             	add    $0x10,%esp
    52ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    52f2:	8b 45 08             	mov    0x8(%ebp),%eax
    52f5:	8b 40 08             	mov    0x8(%eax),%eax
    52f8:	83 c0 01             	add    $0x1,%eax
    52fb:	c1 e0 02             	shl    $0x2,%eax
    52fe:	83 ec 0c             	sub    $0xc,%esp
    5301:	50                   	push   %eax
    5302:	e8 a4 eb ff ff       	call   3eab <lodepng_malloc>
    5307:	83 c4 10             	add    $0x10,%esp
    530a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    530d:	8b 45 08             	mov    0x8(%ebp),%eax
    5310:	8b 00                	mov    (%eax),%eax
    5312:	85 c0                	test   %eax,%eax
    5314:	74 0c                	je     5322 <HuffmanTree_makeFromLengths2+0x76>
    5316:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    531a:	74 06                	je     5322 <HuffmanTree_makeFromLengths2+0x76>
    531c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5320:	75 07                	jne    5329 <HuffmanTree_makeFromLengths2+0x7d>
    5322:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    5329:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    532d:	0f 85 7d 01 00 00    	jne    54b0 <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    5333:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    533a:	eb 2c                	jmp    5368 <HuffmanTree_makeFromLengths2+0xbc>
    533c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    533f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5346:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5349:	01 c2                	add    %eax,%edx
    534b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    534e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    5355:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5358:	01 c8                	add    %ecx,%eax
    535a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5360:	8b 00                	mov    (%eax),%eax
    5362:	89 02                	mov    %eax,(%edx)
    5364:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5368:	8b 45 08             	mov    0x8(%ebp),%eax
    536b:	8b 40 08             	mov    0x8(%eax),%eax
    536e:	83 c0 01             	add    $0x1,%eax
    5371:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5374:	75 c6                	jne    533c <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    5376:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    537d:	eb 27                	jmp    53a6 <HuffmanTree_makeFromLengths2+0xfa>
    537f:	8b 45 08             	mov    0x8(%ebp),%eax
    5382:	8b 40 04             	mov    0x4(%eax),%eax
    5385:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5388:	c1 e2 02             	shl    $0x2,%edx
    538b:	01 d0                	add    %edx,%eax
    538d:	8b 00                	mov    (%eax),%eax
    538f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5396:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5399:	01 d0                	add    %edx,%eax
    539b:	8b 10                	mov    (%eax),%edx
    539d:	83 c2 01             	add    $0x1,%edx
    53a0:	89 10                	mov    %edx,(%eax)
    53a2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    53a6:	8b 45 08             	mov    0x8(%ebp),%eax
    53a9:	8b 40 0c             	mov    0xc(%eax),%eax
    53ac:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    53af:	75 ce                	jne    537f <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    53b1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    53b8:	eb 47                	jmp    5401 <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    53ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
    53bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    53c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    53c7:	01 d0                	add    %edx,%eax
    53c9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    53cc:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    53d2:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    53d9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    53dc:	01 ca                	add    %ecx,%edx
    53de:	8b 0a                	mov    (%edx),%ecx
    53e0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    53e3:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    53e9:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    53f0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    53f3:	01 da                	add    %ebx,%edx
    53f5:	8b 12                	mov    (%edx),%edx
    53f7:	01 ca                	add    %ecx,%edx
    53f9:	01 d2                	add    %edx,%edx
    53fb:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    53fd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5401:	8b 45 08             	mov    0x8(%ebp),%eax
    5404:	8b 40 08             	mov    0x8(%eax),%eax
    5407:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    540a:	73 ae                	jae    53ba <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    540c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    5413:	e9 89 00 00 00       	jmp    54a1 <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    5418:	8b 45 08             	mov    0x8(%ebp),%eax
    541b:	8b 40 04             	mov    0x4(%eax),%eax
    541e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5421:	c1 e2 02             	shl    $0x2,%edx
    5424:	01 d0                	add    %edx,%eax
    5426:	8b 00                	mov    (%eax),%eax
    5428:	85 c0                	test   %eax,%eax
    542a:	74 71                	je     549d <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    542c:	8b 45 08             	mov    0x8(%ebp),%eax
    542f:	8b 00                	mov    (%eax),%eax
    5431:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5434:	c1 e2 02             	shl    $0x2,%edx
    5437:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    543a:	8b 45 08             	mov    0x8(%ebp),%eax
    543d:	8b 40 04             	mov    0x4(%eax),%eax
    5440:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5443:	c1 e2 02             	shl    $0x2,%edx
    5446:	01 d0                	add    %edx,%eax
    5448:	8b 00                	mov    (%eax),%eax
    544a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5451:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5454:	01 c2                	add    %eax,%edx
    5456:	8b 02                	mov    (%edx),%eax
    5458:	8d 48 01             	lea    0x1(%eax),%ecx
    545b:	89 0a                	mov    %ecx,(%edx)
    545d:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    545f:	8b 45 08             	mov    0x8(%ebp),%eax
    5462:	8b 00                	mov    (%eax),%eax
    5464:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5467:	c1 e2 02             	shl    $0x2,%edx
    546a:	01 c2                	add    %eax,%edx
    546c:	8b 45 08             	mov    0x8(%ebp),%eax
    546f:	8b 00                	mov    (%eax),%eax
    5471:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    5474:	c1 e1 02             	shl    $0x2,%ecx
    5477:	01 c8                	add    %ecx,%eax
    5479:	8b 18                	mov    (%eax),%ebx
    547b:	8b 45 08             	mov    0x8(%ebp),%eax
    547e:	8b 40 04             	mov    0x4(%eax),%eax
    5481:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    5484:	c1 e1 02             	shl    $0x2,%ecx
    5487:	01 c8                	add    %ecx,%eax
    5489:	8b 00                	mov    (%eax),%eax
    548b:	be 01 00 00 00       	mov    $0x1,%esi
    5490:	89 c1                	mov    %eax,%ecx
    5492:	d3 e6                	shl    %cl,%esi
    5494:	89 f0                	mov    %esi,%eax
    5496:	83 e8 01             	sub    $0x1,%eax
    5499:	21 d8                	and    %ebx,%eax
    549b:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    549d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    54a1:	8b 45 08             	mov    0x8(%ebp),%eax
    54a4:	8b 40 0c             	mov    0xc(%eax),%eax
    54a7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    54aa:	0f 85 68 ff ff ff    	jne    5418 <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    54b0:	83 ec 0c             	sub    $0xc,%esp
    54b3:	ff 75 e8             	pushl  -0x18(%ebp)
    54b6:	e8 11 ea ff ff       	call   3ecc <lodepng_free>
    54bb:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    54be:	83 ec 0c             	sub    $0xc,%esp
    54c1:	ff 75 e4             	pushl  -0x1c(%ebp)
    54c4:	e8 03 ea ff ff       	call   3ecc <lodepng_free>
    54c9:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    54cc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    54d0:	75 11                	jne    54e3 <HuffmanTree_makeFromLengths2+0x237>
    54d2:	83 ec 0c             	sub    $0xc,%esp
    54d5:	ff 75 08             	pushl  0x8(%ebp)
    54d8:	e8 3f f9 ff ff       	call   4e1c <HuffmanTree_makeTable>
    54dd:	83 c4 10             	add    $0x10,%esp
    54e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    54e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    54e6:	8d 65 f8             	lea    -0x8(%ebp),%esp
    54e9:	5b                   	pop    %ebx
    54ea:	5e                   	pop    %esi
    54eb:	5d                   	pop    %ebp
    54ec:	c3                   	ret    

000054ed <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    54ed:	55                   	push   %ebp
    54ee:	89 e5                	mov    %esp,%ebp
    54f0:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    54f3:	8b 45 10             	mov    0x10(%ebp),%eax
    54f6:	c1 e0 02             	shl    $0x2,%eax
    54f9:	83 ec 0c             	sub    $0xc,%esp
    54fc:	50                   	push   %eax
    54fd:	e8 a9 e9 ff ff       	call   3eab <lodepng_malloc>
    5502:	83 c4 10             	add    $0x10,%esp
    5505:	89 c2                	mov    %eax,%edx
    5507:	8b 45 08             	mov    0x8(%ebp),%eax
    550a:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    550d:	8b 45 08             	mov    0x8(%ebp),%eax
    5510:	8b 40 04             	mov    0x4(%eax),%eax
    5513:	85 c0                	test   %eax,%eax
    5515:	75 07                	jne    551e <HuffmanTree_makeFromLengths+0x31>
    5517:	b8 53 00 00 00       	mov    $0x53,%eax
    551c:	eb 56                	jmp    5574 <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    551e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5525:	eb 25                	jmp    554c <HuffmanTree_makeFromLengths+0x5f>
    5527:	8b 45 08             	mov    0x8(%ebp),%eax
    552a:	8b 40 04             	mov    0x4(%eax),%eax
    552d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    5530:	c1 e2 02             	shl    $0x2,%edx
    5533:	01 c2                	add    %eax,%edx
    5535:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5538:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    553f:	8b 45 0c             	mov    0xc(%ebp),%eax
    5542:	01 c8                	add    %ecx,%eax
    5544:	8b 00                	mov    (%eax),%eax
    5546:	89 02                	mov    %eax,(%edx)
    5548:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    554c:	8b 45 10             	mov    0x10(%ebp),%eax
    554f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    5552:	75 d3                	jne    5527 <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    5554:	8b 55 10             	mov    0x10(%ebp),%edx
    5557:	8b 45 08             	mov    0x8(%ebp),%eax
    555a:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    555d:	8b 45 08             	mov    0x8(%ebp),%eax
    5560:	8b 55 14             	mov    0x14(%ebp),%edx
    5563:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    5566:	83 ec 0c             	sub    $0xc,%esp
    5569:	ff 75 08             	pushl  0x8(%ebp)
    556c:	e8 3b fd ff ff       	call   52ac <HuffmanTree_makeFromLengths2>
    5571:	83 c4 10             	add    $0x10,%esp
}
    5574:	c9                   	leave  
    5575:	c3                   	ret    

00005576 <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    5576:	55                   	push   %ebp
    5577:	89 e5                	mov    %esp,%ebp
    5579:	53                   	push   %ebx
    557a:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    557d:	8b 45 08             	mov    0x8(%ebp),%eax
    5580:	8b 50 0c             	mov    0xc(%eax),%edx
    5583:	8b 45 08             	mov    0x8(%ebp),%eax
    5586:	8b 40 08             	mov    0x8(%eax),%eax
    5589:	39 c2                	cmp    %eax,%edx
    558b:	0f 82 0b 01 00 00    	jb     569c <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    5591:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    5598:	eb 19                	jmp    55b3 <bpmnode_create+0x3d>
    559a:	8b 45 08             	mov    0x8(%ebp),%eax
    559d:	8b 40 04             	mov    0x4(%eax),%eax
    55a0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    55a3:	c1 e2 04             	shl    $0x4,%edx
    55a6:	01 d0                	add    %edx,%eax
    55a8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    55af:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    55b3:	8b 45 08             	mov    0x8(%ebp),%eax
    55b6:	8b 00                	mov    (%eax),%eax
    55b8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    55bb:	75 dd                	jne    559a <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    55bd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    55c4:	eb 60                	jmp    5626 <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    55c6:	8b 45 08             	mov    0x8(%ebp),%eax
    55c9:	8b 40 18             	mov    0x18(%eax),%eax
    55cc:	8b 55 f8             	mov    -0x8(%ebp),%edx
    55cf:	c1 e2 02             	shl    $0x2,%edx
    55d2:	01 d0                	add    %edx,%eax
    55d4:	8b 00                	mov    (%eax),%eax
    55d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    55d9:	eb 13                	jmp    55ee <bpmnode_create+0x78>
    55db:	8b 45 f4             	mov    -0xc(%ebp),%eax
    55de:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    55e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    55e8:	8b 40 08             	mov    0x8(%eax),%eax
    55eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    55ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    55f2:	75 e7                	jne    55db <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    55f4:	8b 45 08             	mov    0x8(%ebp),%eax
    55f7:	8b 40 1c             	mov    0x1c(%eax),%eax
    55fa:	8b 55 f8             	mov    -0x8(%ebp),%edx
    55fd:	c1 e2 02             	shl    $0x2,%edx
    5600:	01 d0                	add    %edx,%eax
    5602:	8b 00                	mov    (%eax),%eax
    5604:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5607:	eb 13                	jmp    561c <bpmnode_create+0xa6>
    5609:	8b 45 f4             	mov    -0xc(%ebp),%eax
    560c:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    5613:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5616:	8b 40 08             	mov    0x8(%eax),%eax
    5619:	89 45 f4             	mov    %eax,-0xc(%ebp)
    561c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5620:	75 e7                	jne    5609 <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    5622:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    5626:	8b 45 08             	mov    0x8(%ebp),%eax
    5629:	8b 40 14             	mov    0x14(%eax),%eax
    562c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    562f:	75 95                	jne    55c6 <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    5631:	8b 45 08             	mov    0x8(%ebp),%eax
    5634:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    563b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    5642:	eb 44                	jmp    5688 <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    5644:	8b 45 08             	mov    0x8(%ebp),%eax
    5647:	8b 40 04             	mov    0x4(%eax),%eax
    564a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    564d:	c1 e2 04             	shl    $0x4,%edx
    5650:	01 d0                	add    %edx,%eax
    5652:	8b 40 0c             	mov    0xc(%eax),%eax
    5655:	85 c0                	test   %eax,%eax
    5657:	75 2b                	jne    5684 <bpmnode_create+0x10e>
    5659:	8b 45 08             	mov    0x8(%ebp),%eax
    565c:	8b 58 10             	mov    0x10(%eax),%ebx
    565f:	8b 45 08             	mov    0x8(%ebp),%eax
    5662:	8b 40 08             	mov    0x8(%eax),%eax
    5665:	8d 48 01             	lea    0x1(%eax),%ecx
    5668:	8b 55 08             	mov    0x8(%ebp),%edx
    566b:	89 4a 08             	mov    %ecx,0x8(%edx)
    566e:	c1 e0 02             	shl    $0x2,%eax
    5671:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    5674:	8b 45 08             	mov    0x8(%ebp),%eax
    5677:	8b 40 04             	mov    0x4(%eax),%eax
    567a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    567d:	c1 e1 04             	shl    $0x4,%ecx
    5680:	01 c8                	add    %ecx,%eax
    5682:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    5684:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    5688:	8b 45 08             	mov    0x8(%ebp),%eax
    568b:	8b 00                	mov    (%eax),%eax
    568d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5690:	75 b2                	jne    5644 <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    5692:	8b 45 08             	mov    0x8(%ebp),%eax
    5695:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    569c:	8b 45 08             	mov    0x8(%ebp),%eax
    569f:	8b 58 10             	mov    0x10(%eax),%ebx
    56a2:	8b 45 08             	mov    0x8(%ebp),%eax
    56a5:	8b 40 0c             	mov    0xc(%eax),%eax
    56a8:	8d 48 01             	lea    0x1(%eax),%ecx
    56ab:	8b 55 08             	mov    0x8(%ebp),%edx
    56ae:	89 4a 0c             	mov    %ecx,0xc(%edx)
    56b1:	c1 e0 02             	shl    $0x2,%eax
    56b4:	01 d8                	add    %ebx,%eax
    56b6:	8b 00                	mov    (%eax),%eax
    56b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    56bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    56be:	8b 55 0c             	mov    0xc(%ebp),%edx
    56c1:	89 10                	mov    %edx,(%eax)
  result->index = index;
    56c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    56c6:	8b 55 10             	mov    0x10(%ebp),%edx
    56c9:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    56cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    56cf:	8b 55 14             	mov    0x14(%ebp),%edx
    56d2:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    56d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    56d8:	83 c4 10             	add    $0x10,%esp
    56db:	5b                   	pop    %ebx
    56dc:	5d                   	pop    %ebp
    56dd:	c3                   	ret    

000056de <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    56de:	55                   	push   %ebp
    56df:	89 e5                	mov    %esp,%ebp
    56e1:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    56e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    56e7:	c1 e0 04             	shl    $0x4,%eax
    56ea:	83 ec 0c             	sub    $0xc,%esp
    56ed:	50                   	push   %eax
    56ee:	e8 b8 e7 ff ff       	call   3eab <lodepng_malloc>
    56f3:	83 c4 10             	add    $0x10,%esp
    56f6:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    56f9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    5700:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    5707:	e9 41 01 00 00       	jmp    584d <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    570c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    570f:	83 e0 01             	and    $0x1,%eax
    5712:	85 c0                	test   %eax,%eax
    5714:	74 05                	je     571b <bpmnode_sort+0x3d>
    5716:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5719:	eb 03                	jmp    571e <bpmnode_sort+0x40>
    571b:	8b 45 08             	mov    0x8(%ebp),%eax
    571e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    5721:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5724:	83 e0 01             	and    $0x1,%eax
    5727:	85 c0                	test   %eax,%eax
    5729:	74 05                	je     5730 <bpmnode_sort+0x52>
    572b:	8b 45 08             	mov    0x8(%ebp),%eax
    572e:	eb 03                	jmp    5733 <bpmnode_sort+0x55>
    5730:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5733:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    5736:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    573d:	e9 f8 00 00 00       	jmp    583a <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    5742:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5745:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5748:	01 c2                	add    %eax,%edx
    574a:	8b 45 0c             	mov    0xc(%ebp),%eax
    574d:	39 c2                	cmp    %eax,%edx
    574f:	0f 4e c2             	cmovle %edx,%eax
    5752:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    5755:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5758:	8d 14 00             	lea    (%eax,%eax,1),%edx
    575b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    575e:	01 c2                	add    %eax,%edx
    5760:	8b 45 0c             	mov    0xc(%ebp),%eax
    5763:	39 c2                	cmp    %eax,%edx
    5765:	0f 4e c2             	cmovle %edx,%eax
    5768:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    576b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    576e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5771:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5774:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    5777:	8b 45 ec             	mov    -0x14(%ebp),%eax
    577a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    577d:	e9 a4 00 00 00       	jmp    5826 <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    5782:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5785:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    5788:	7d 62                	jge    57ec <bpmnode_sort+0x10e>
    578a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    578d:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    5790:	7d 22                	jge    57b4 <bpmnode_sort+0xd6>
    5792:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5795:	c1 e0 04             	shl    $0x4,%eax
    5798:	89 c2                	mov    %eax,%edx
    579a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    579d:	01 d0                	add    %edx,%eax
    579f:	8b 10                	mov    (%eax),%edx
    57a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    57a4:	c1 e0 04             	shl    $0x4,%eax
    57a7:	89 c1                	mov    %eax,%ecx
    57a9:	8b 45 d8             	mov    -0x28(%ebp),%eax
    57ac:	01 c8                	add    %ecx,%eax
    57ae:	8b 00                	mov    (%eax),%eax
    57b0:	39 c2                	cmp    %eax,%edx
    57b2:	7f 38                	jg     57ec <bpmnode_sort+0x10e>
    57b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    57b7:	c1 e0 04             	shl    $0x4,%eax
    57ba:	89 c2                	mov    %eax,%edx
    57bc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    57bf:	01 d0                	add    %edx,%eax
    57c1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    57c4:	8d 4a 01             	lea    0x1(%edx),%ecx
    57c7:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    57ca:	89 d1                	mov    %edx,%ecx
    57cc:	c1 e1 04             	shl    $0x4,%ecx
    57cf:	8b 55 d8             	mov    -0x28(%ebp),%edx
    57d2:	01 ca                	add    %ecx,%edx
    57d4:	8b 0a                	mov    (%edx),%ecx
    57d6:	89 08                	mov    %ecx,(%eax)
    57d8:	8b 4a 04             	mov    0x4(%edx),%ecx
    57db:	89 48 04             	mov    %ecx,0x4(%eax)
    57de:	8b 4a 08             	mov    0x8(%edx),%ecx
    57e1:	89 48 08             	mov    %ecx,0x8(%eax)
    57e4:	8b 52 0c             	mov    0xc(%edx),%edx
    57e7:	89 50 0c             	mov    %edx,0xc(%eax)
    57ea:	eb 36                	jmp    5822 <bpmnode_sort+0x144>
        else b[k] = a[j++];
    57ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
    57ef:	c1 e0 04             	shl    $0x4,%eax
    57f2:	89 c2                	mov    %eax,%edx
    57f4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    57f7:	01 d0                	add    %edx,%eax
    57f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    57fc:	8d 4a 01             	lea    0x1(%edx),%ecx
    57ff:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    5802:	89 d1                	mov    %edx,%ecx
    5804:	c1 e1 04             	shl    $0x4,%ecx
    5807:	8b 55 d8             	mov    -0x28(%ebp),%edx
    580a:	01 ca                	add    %ecx,%edx
    580c:	8b 0a                	mov    (%edx),%ecx
    580e:	89 08                	mov    %ecx,(%eax)
    5810:	8b 4a 04             	mov    0x4(%edx),%ecx
    5813:	89 48 04             	mov    %ecx,0x4(%eax)
    5816:	8b 4a 08             	mov    0x8(%edx),%ecx
    5819:	89 48 08             	mov    %ecx,0x8(%eax)
    581c:	8b 52 0c             	mov    0xc(%edx),%edx
    581f:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    5822:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5826:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5829:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    582c:	0f 8c 50 ff ff ff    	jl     5782 <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    5832:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5835:	01 c0                	add    %eax,%eax
    5837:	01 45 ec             	add    %eax,-0x14(%ebp)
    583a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    583d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    5840:	0f 8c fc fe ff ff    	jl     5742 <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    5846:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    584a:	d1 65 f4             	shll   -0xc(%ebp)
    584d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5850:	3b 45 0c             	cmp    0xc(%ebp),%eax
    5853:	0f 8c b3 fe ff ff    	jl     570c <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    5859:	8b 45 f0             	mov    -0x10(%ebp),%eax
    585c:	83 e0 01             	and    $0x1,%eax
    585f:	85 c0                	test   %eax,%eax
    5861:	74 18                	je     587b <bpmnode_sort+0x19d>
    5863:	8b 45 0c             	mov    0xc(%ebp),%eax
    5866:	c1 e0 04             	shl    $0x4,%eax
    5869:	83 ec 04             	sub    $0x4,%esp
    586c:	50                   	push   %eax
    586d:	ff 75 dc             	pushl  -0x24(%ebp)
    5870:	ff 75 08             	pushl  0x8(%ebp)
    5873:	e8 71 e6 ff ff       	call   3ee9 <lodepng_memcpy>
    5878:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    587b:	83 ec 0c             	sub    $0xc,%esp
    587e:	ff 75 dc             	pushl  -0x24(%ebp)
    5881:	e8 46 e6 ff ff       	call   3ecc <lodepng_free>
    5886:	83 c4 10             	add    $0x10,%esp
}
    5889:	90                   	nop
    588a:	c9                   	leave  
    588b:	c3                   	ret    

0000588c <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    588c:	55                   	push   %ebp
    588d:	89 e5                	mov    %esp,%ebp
    588f:	56                   	push   %esi
    5890:	53                   	push   %ebx
    5891:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    5894:	8b 45 08             	mov    0x8(%ebp),%eax
    5897:	8b 40 1c             	mov    0x1c(%eax),%eax
    589a:	8b 55 14             	mov    0x14(%ebp),%edx
    589d:	c1 e2 02             	shl    $0x2,%edx
    58a0:	01 d0                	add    %edx,%eax
    58a2:	8b 00                	mov    (%eax),%eax
    58a4:	8b 40 04             	mov    0x4(%eax),%eax
    58a7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    58aa:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    58ae:	75 66                	jne    5916 <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    58b0:	8b 45 10             	mov    0x10(%ebp),%eax
    58b3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    58b6:	0f 83 a0 01 00 00    	jae    5a5c <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    58bc:	8b 45 08             	mov    0x8(%ebp),%eax
    58bf:	8b 40 18             	mov    0x18(%eax),%eax
    58c2:	8b 55 14             	mov    0x14(%ebp),%edx
    58c5:	c1 e2 02             	shl    $0x2,%edx
    58c8:	01 c2                	add    %eax,%edx
    58ca:	8b 45 08             	mov    0x8(%ebp),%eax
    58cd:	8b 40 1c             	mov    0x1c(%eax),%eax
    58d0:	8b 4d 14             	mov    0x14(%ebp),%ecx
    58d3:	c1 e1 02             	shl    $0x2,%ecx
    58d6:	01 c8                	add    %ecx,%eax
    58d8:	8b 00                	mov    (%eax),%eax
    58da:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    58dc:	8b 45 08             	mov    0x8(%ebp),%eax
    58df:	8b 40 1c             	mov    0x1c(%eax),%eax
    58e2:	8b 55 14             	mov    0x14(%ebp),%edx
    58e5:	c1 e2 02             	shl    $0x2,%edx
    58e8:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    58eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    58ee:	8d 50 01             	lea    0x1(%eax),%edx
    58f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    58f4:	c1 e0 04             	shl    $0x4,%eax
    58f7:	89 c1                	mov    %eax,%ecx
    58f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    58fc:	01 c8                	add    %ecx,%eax
    58fe:	8b 00                	mov    (%eax),%eax
    5900:	6a 00                	push   $0x0
    5902:	52                   	push   %edx
    5903:	50                   	push   %eax
    5904:	ff 75 08             	pushl  0x8(%ebp)
    5907:	e8 6a fc ff ff       	call   5576 <bpmnode_create>
    590c:	83 c4 10             	add    $0x10,%esp
    590f:	89 03                	mov    %eax,(%ebx)
    5911:	e9 47 01 00 00       	jmp    5a5d <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    5916:	8b 45 08             	mov    0x8(%ebp),%eax
    5919:	8b 40 18             	mov    0x18(%eax),%eax
    591c:	8b 55 14             	mov    0x14(%ebp),%edx
    591f:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5925:	c1 e2 02             	shl    $0x2,%edx
    5928:	01 d0                	add    %edx,%eax
    592a:	8b 00                	mov    (%eax),%eax
    592c:	8b 10                	mov    (%eax),%edx
    592e:	8b 45 08             	mov    0x8(%ebp),%eax
    5931:	8b 40 1c             	mov    0x1c(%eax),%eax
    5934:	8b 4d 14             	mov    0x14(%ebp),%ecx
    5937:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    593d:	c1 e1 02             	shl    $0x2,%ecx
    5940:	01 c8                	add    %ecx,%eax
    5942:	8b 00                	mov    (%eax),%eax
    5944:	8b 00                	mov    (%eax),%eax
    5946:	01 d0                	add    %edx,%eax
    5948:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    594b:	8b 45 08             	mov    0x8(%ebp),%eax
    594e:	8b 40 18             	mov    0x18(%eax),%eax
    5951:	8b 55 14             	mov    0x14(%ebp),%edx
    5954:	c1 e2 02             	shl    $0x2,%edx
    5957:	01 c2                	add    %eax,%edx
    5959:	8b 45 08             	mov    0x8(%ebp),%eax
    595c:	8b 40 1c             	mov    0x1c(%eax),%eax
    595f:	8b 4d 14             	mov    0x14(%ebp),%ecx
    5962:	c1 e1 02             	shl    $0x2,%ecx
    5965:	01 c8                	add    %ecx,%eax
    5967:	8b 00                	mov    (%eax),%eax
    5969:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    596b:	8b 45 10             	mov    0x10(%ebp),%eax
    596e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    5971:	73 60                	jae    59d3 <boundaryPM+0x147>
    5973:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5976:	c1 e0 04             	shl    $0x4,%eax
    5979:	89 c2                	mov    %eax,%edx
    597b:	8b 45 0c             	mov    0xc(%ebp),%eax
    597e:	01 d0                	add    %edx,%eax
    5980:	8b 00                	mov    (%eax),%eax
    5982:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5985:	7d 4c                	jge    59d3 <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    5987:	8b 45 08             	mov    0x8(%ebp),%eax
    598a:	8b 40 1c             	mov    0x1c(%eax),%eax
    598d:	8b 55 14             	mov    0x14(%ebp),%edx
    5990:	c1 e2 02             	shl    $0x2,%edx
    5993:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    5996:	8b 45 08             	mov    0x8(%ebp),%eax
    5999:	8b 40 1c             	mov    0x1c(%eax),%eax
    599c:	8b 55 14             	mov    0x14(%ebp),%edx
    599f:	c1 e2 02             	shl    $0x2,%edx
    59a2:	01 d0                	add    %edx,%eax
    59a4:	8b 00                	mov    (%eax),%eax
    59a6:	8b 50 08             	mov    0x8(%eax),%edx
    59a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    59ac:	8d 48 01             	lea    0x1(%eax),%ecx
    59af:	8b 45 f4             	mov    -0xc(%ebp),%eax
    59b2:	c1 e0 04             	shl    $0x4,%eax
    59b5:	89 c6                	mov    %eax,%esi
    59b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    59ba:	01 f0                	add    %esi,%eax
    59bc:	8b 00                	mov    (%eax),%eax
    59be:	52                   	push   %edx
    59bf:	51                   	push   %ecx
    59c0:	50                   	push   %eax
    59c1:	ff 75 08             	pushl  0x8(%ebp)
    59c4:	e8 ad fb ff ff       	call   5576 <bpmnode_create>
    59c9:	83 c4 10             	add    $0x10,%esp
    59cc:	89 03                	mov    %eax,(%ebx)
      return;
    59ce:	e9 8a 00 00 00       	jmp    5a5d <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    59d3:	8b 45 08             	mov    0x8(%ebp),%eax
    59d6:	8b 40 1c             	mov    0x1c(%eax),%eax
    59d9:	8b 55 14             	mov    0x14(%ebp),%edx
    59dc:	c1 e2 02             	shl    $0x2,%edx
    59df:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    59e2:	8b 45 08             	mov    0x8(%ebp),%eax
    59e5:	8b 40 1c             	mov    0x1c(%eax),%eax
    59e8:	8b 55 14             	mov    0x14(%ebp),%edx
    59eb:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    59f1:	c1 e2 02             	shl    $0x2,%edx
    59f4:	01 d0                	add    %edx,%eax
    59f6:	8b 00                	mov    (%eax),%eax
    59f8:	50                   	push   %eax
    59f9:	ff 75 f4             	pushl  -0xc(%ebp)
    59fc:	ff 75 f0             	pushl  -0x10(%ebp)
    59ff:	ff 75 08             	pushl  0x8(%ebp)
    5a02:	e8 6f fb ff ff       	call   5576 <bpmnode_create>
    5a07:	83 c4 10             	add    $0x10,%esp
    5a0a:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    5a0c:	8b 45 18             	mov    0x18(%ebp),%eax
    5a0f:	8d 50 01             	lea    0x1(%eax),%edx
    5a12:	8b 45 10             	mov    0x10(%ebp),%eax
    5a15:	83 e8 01             	sub    $0x1,%eax
    5a18:	01 c0                	add    %eax,%eax
    5a1a:	39 c2                	cmp    %eax,%edx
    5a1c:	7d 3f                	jge    5a5d <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    5a1e:	8b 45 14             	mov    0x14(%ebp),%eax
    5a21:	83 e8 01             	sub    $0x1,%eax
    5a24:	83 ec 0c             	sub    $0xc,%esp
    5a27:	ff 75 18             	pushl  0x18(%ebp)
    5a2a:	50                   	push   %eax
    5a2b:	ff 75 10             	pushl  0x10(%ebp)
    5a2e:	ff 75 0c             	pushl  0xc(%ebp)
    5a31:	ff 75 08             	pushl  0x8(%ebp)
    5a34:	e8 53 fe ff ff       	call   588c <boundaryPM>
    5a39:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    5a3c:	8b 45 14             	mov    0x14(%ebp),%eax
    5a3f:	83 e8 01             	sub    $0x1,%eax
    5a42:	83 ec 0c             	sub    $0xc,%esp
    5a45:	ff 75 18             	pushl  0x18(%ebp)
    5a48:	50                   	push   %eax
    5a49:	ff 75 10             	pushl  0x10(%ebp)
    5a4c:	ff 75 0c             	pushl  0xc(%ebp)
    5a4f:	ff 75 08             	pushl  0x8(%ebp)
    5a52:	e8 35 fe ff ff       	call   588c <boundaryPM>
    5a57:	83 c4 20             	add    $0x20,%esp
    5a5a:	eb 01                	jmp    5a5d <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    5a5c:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    5a5d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    5a60:	5b                   	pop    %ebx
    5a61:	5e                   	pop    %esi
    5a62:	5d                   	pop    %ebp
    5a63:	c3                   	ret    

00005a64 <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    5a64:	55                   	push   %ebp
    5a65:	89 e5                	mov    %esp,%ebp
    5a67:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    5a6a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    5a71:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    5a78:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    5a7c:	75 0a                	jne    5a88 <lodepng_huffman_code_lengths+0x24>
    5a7e:	b8 50 00 00 00       	mov    $0x50,%eax
    5a83:	e9 4d 03 00 00       	jmp    5dd5 <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    5a88:	8b 45 14             	mov    0x14(%ebp),%eax
    5a8b:	ba 01 00 00 00       	mov    $0x1,%edx
    5a90:	89 c1                	mov    %eax,%ecx
    5a92:	d3 e2                	shl    %cl,%edx
    5a94:	8b 45 10             	mov    0x10(%ebp),%eax
    5a97:	39 c2                	cmp    %eax,%edx
    5a99:	73 0a                	jae    5aa5 <lodepng_huffman_code_lengths+0x41>
    5a9b:	b8 50 00 00 00       	mov    $0x50,%eax
    5aa0:	e9 30 03 00 00       	jmp    5dd5 <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    5aa5:	8b 45 10             	mov    0x10(%ebp),%eax
    5aa8:	c1 e0 04             	shl    $0x4,%eax
    5aab:	83 ec 0c             	sub    $0xc,%esp
    5aae:	50                   	push   %eax
    5aaf:	e8 f7 e3 ff ff       	call   3eab <lodepng_malloc>
    5ab4:	83 c4 10             	add    $0x10,%esp
    5ab7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    5aba:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5abe:	75 0a                	jne    5aca <lodepng_huffman_code_lengths+0x66>
    5ac0:	b8 53 00 00 00       	mov    $0x53,%eax
    5ac5:	e9 0b 03 00 00       	jmp    5dd5 <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    5aca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5ad1:	eb 50                	jmp    5b23 <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    5ad3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5ad6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5add:	8b 45 0c             	mov    0xc(%ebp),%eax
    5ae0:	01 d0                	add    %edx,%eax
    5ae2:	8b 00                	mov    (%eax),%eax
    5ae4:	85 c0                	test   %eax,%eax
    5ae6:	74 37                	je     5b1f <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    5ae8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5aeb:	c1 e0 04             	shl    $0x4,%eax
    5aee:	89 c2                	mov    %eax,%edx
    5af0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5af3:	01 d0                	add    %edx,%eax
    5af5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5af8:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    5aff:	8b 55 0c             	mov    0xc(%ebp),%edx
    5b02:	01 ca                	add    %ecx,%edx
    5b04:	8b 12                	mov    (%edx),%edx
    5b06:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    5b08:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5b0b:	c1 e0 04             	shl    $0x4,%eax
    5b0e:	89 c2                	mov    %eax,%edx
    5b10:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5b13:	01 c2                	add    %eax,%edx
    5b15:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5b18:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    5b1b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    5b1f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5b23:	8b 45 10             	mov    0x10(%ebp),%eax
    5b26:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5b29:	75 a8                	jne    5ad3 <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    5b2b:	8b 45 10             	mov    0x10(%ebp),%eax
    5b2e:	c1 e0 02             	shl    $0x2,%eax
    5b31:	83 ec 04             	sub    $0x4,%esp
    5b34:	50                   	push   %eax
    5b35:	6a 00                	push   $0x0
    5b37:	ff 75 08             	pushl  0x8(%ebp)
    5b3a:	e8 dd e3 ff ff       	call   3f1c <lodepng_memset>
    5b3f:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    5b42:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5b46:	75 18                	jne    5b60 <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    5b48:	8b 45 08             	mov    0x8(%ebp),%eax
    5b4b:	83 c0 04             	add    $0x4,%eax
    5b4e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    5b54:	8b 10                	mov    (%eax),%edx
    5b56:	8b 45 08             	mov    0x8(%ebp),%eax
    5b59:	89 10                	mov    %edx,(%eax)
    5b5b:	e9 64 02 00 00       	jmp    5dc4 <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    5b60:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    5b64:	75 3e                	jne    5ba4 <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    5b66:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5b69:	8b 40 04             	mov    0x4(%eax),%eax
    5b6c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5b73:	8b 45 08             	mov    0x8(%ebp),%eax
    5b76:	01 d0                	add    %edx,%eax
    5b78:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    5b7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5b81:	8b 40 04             	mov    0x4(%eax),%eax
    5b84:	85 c0                	test   %eax,%eax
    5b86:	75 07                	jne    5b8f <lodepng_huffman_code_lengths+0x12b>
    5b88:	ba 04 00 00 00       	mov    $0x4,%edx
    5b8d:	eb 05                	jmp    5b94 <lodepng_huffman_code_lengths+0x130>
    5b8f:	ba 00 00 00 00       	mov    $0x0,%edx
    5b94:	8b 45 08             	mov    0x8(%ebp),%eax
    5b97:	01 d0                	add    %edx,%eax
    5b99:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    5b9f:	e9 20 02 00 00       	jmp    5dc4 <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    5ba4:	83 ec 08             	sub    $0x8,%esp
    5ba7:	ff 75 ec             	pushl  -0x14(%ebp)
    5baa:	ff 75 e4             	pushl  -0x1c(%ebp)
    5bad:	e8 2c fb ff ff       	call   56de <bpmnode_sort>
    5bb2:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    5bb5:	8b 45 14             	mov    0x14(%ebp),%eax
    5bb8:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    5bbb:	8b 45 14             	mov    0x14(%ebp),%eax
    5bbe:	83 c0 01             	add    $0x1,%eax
    5bc1:	0f af 45 14          	imul   0x14(%ebp),%eax
    5bc5:	01 c0                	add    %eax,%eax
    5bc7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    5bca:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    5bd1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5bd4:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    5bd7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5bda:	c1 e0 04             	shl    $0x4,%eax
    5bdd:	83 ec 0c             	sub    $0xc,%esp
    5be0:	50                   	push   %eax
    5be1:	e8 c5 e2 ff ff       	call   3eab <lodepng_malloc>
    5be6:	83 c4 10             	add    $0x10,%esp
    5be9:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    5bec:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5bef:	c1 e0 02             	shl    $0x2,%eax
    5bf2:	83 ec 0c             	sub    $0xc,%esp
    5bf5:	50                   	push   %eax
    5bf6:	e8 b0 e2 ff ff       	call   3eab <lodepng_malloc>
    5bfb:	83 c4 10             	add    $0x10,%esp
    5bfe:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5c01:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5c04:	c1 e0 02             	shl    $0x2,%eax
    5c07:	83 ec 0c             	sub    $0xc,%esp
    5c0a:	50                   	push   %eax
    5c0b:	e8 9b e2 ff ff       	call   3eab <lodepng_malloc>
    5c10:	83 c4 10             	add    $0x10,%esp
    5c13:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5c16:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5c19:	c1 e0 02             	shl    $0x2,%eax
    5c1c:	83 ec 0c             	sub    $0xc,%esp
    5c1f:	50                   	push   %eax
    5c20:	e8 86 e2 ff ff       	call   3eab <lodepng_malloc>
    5c25:	83 c4 10             	add    $0x10,%esp
    5c28:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    5c2b:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5c2e:	85 c0                	test   %eax,%eax
    5c30:	74 15                	je     5c47 <lodepng_huffman_code_lengths+0x1e3>
    5c32:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c35:	85 c0                	test   %eax,%eax
    5c37:	74 0e                	je     5c47 <lodepng_huffman_code_lengths+0x1e3>
    5c39:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5c3c:	85 c0                	test   %eax,%eax
    5c3e:	74 07                	je     5c47 <lodepng_huffman_code_lengths+0x1e3>
    5c40:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5c43:	85 c0                	test   %eax,%eax
    5c45:	75 07                	jne    5c4e <lodepng_huffman_code_lengths+0x1ea>
    5c47:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    5c4e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5c52:	0f 85 30 01 00 00    	jne    5d88 <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    5c58:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5c5f:	eb 1c                	jmp    5c7d <lodepng_huffman_code_lengths+0x219>
    5c61:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c64:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5c67:	c1 e2 02             	shl    $0x2,%edx
    5c6a:	01 d0                	add    %edx,%eax
    5c6c:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5c6f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5c72:	c1 e1 04             	shl    $0x4,%ecx
    5c75:	01 ca                	add    %ecx,%edx
    5c77:	89 10                	mov    %edx,(%eax)
    5c79:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5c7d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5c80:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5c83:	75 dc                	jne    5c61 <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    5c85:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c88:	8b 00                	mov    (%eax),%eax
    5c8a:	6a 00                	push   $0x0
    5c8c:	6a 01                	push   $0x1
    5c8e:	50                   	push   %eax
    5c8f:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5c92:	50                   	push   %eax
    5c93:	e8 de f8 ff ff       	call   5576 <bpmnode_create>
    5c98:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    5c9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c9e:	83 c0 10             	add    $0x10,%eax
    5ca1:	8b 00                	mov    (%eax),%eax
    5ca3:	6a 00                	push   $0x0
    5ca5:	6a 02                	push   $0x2
    5ca7:	50                   	push   %eax
    5ca8:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5cab:	50                   	push   %eax
    5cac:	e8 c5 f8 ff ff       	call   5576 <bpmnode_create>
    5cb1:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    5cb4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5cbb:	eb 27                	jmp    5ce4 <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    5cbd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5cc0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5cc3:	c1 e2 02             	shl    $0x2,%edx
    5cc6:	01 c2                	add    %eax,%edx
    5cc8:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5ccb:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    5ccd:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5cd0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5cd3:	c1 e2 02             	shl    $0x2,%edx
    5cd6:	01 d0                	add    %edx,%eax
    5cd8:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5cdb:	83 c2 10             	add    $0x10,%edx
    5cde:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    5ce0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5ce4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5ce7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5cea:	75 d1                	jne    5cbd <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    5cec:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    5cf3:	eb 24                	jmp    5d19 <lodepng_huffman_code_lengths+0x2b5>
    5cf5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5cf8:	8b 55 14             	mov    0x14(%ebp),%edx
    5cfb:	83 ea 01             	sub    $0x1,%edx
    5cfe:	83 ec 0c             	sub    $0xc,%esp
    5d01:	50                   	push   %eax
    5d02:	52                   	push   %edx
    5d03:	ff 75 ec             	pushl  -0x14(%ebp)
    5d06:	ff 75 e4             	pushl  -0x1c(%ebp)
    5d09:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5d0c:	50                   	push   %eax
    5d0d:	e8 7a fb ff ff       	call   588c <boundaryPM>
    5d12:	83 c4 20             	add    $0x20,%esp
    5d15:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5d19:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d1c:	83 e8 01             	sub    $0x1,%eax
    5d1f:	01 c0                	add    %eax,%eax
    5d21:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5d24:	75 cf                	jne    5cf5 <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    5d26:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5d29:	8b 55 14             	mov    0x14(%ebp),%edx
    5d2c:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5d32:	c1 e2 02             	shl    $0x2,%edx
    5d35:	01 d0                	add    %edx,%eax
    5d37:	8b 00                	mov    (%eax),%eax
    5d39:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5d3c:	eb 44                	jmp    5d82 <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    5d3e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5d45:	eb 27                	jmp    5d6e <lodepng_huffman_code_lengths+0x30a>
    5d47:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5d4a:	c1 e0 04             	shl    $0x4,%eax
    5d4d:	89 c2                	mov    %eax,%edx
    5d4f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5d52:	01 d0                	add    %edx,%eax
    5d54:	8b 40 04             	mov    0x4(%eax),%eax
    5d57:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5d5e:	8b 45 08             	mov    0x8(%ebp),%eax
    5d61:	01 d0                	add    %edx,%eax
    5d63:	8b 10                	mov    (%eax),%edx
    5d65:	83 c2 01             	add    $0x1,%edx
    5d68:	89 10                	mov    %edx,(%eax)
    5d6a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5d6e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5d71:	8b 40 04             	mov    0x4(%eax),%eax
    5d74:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5d77:	75 ce                	jne    5d47 <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    5d79:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5d7c:	8b 40 08             	mov    0x8(%eax),%eax
    5d7f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5d82:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    5d86:	75 b6                	jne    5d3e <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    5d88:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5d8b:	83 ec 0c             	sub    $0xc,%esp
    5d8e:	50                   	push   %eax
    5d8f:	e8 38 e1 ff ff       	call   3ecc <lodepng_free>
    5d94:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    5d97:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5d9a:	83 ec 0c             	sub    $0xc,%esp
    5d9d:	50                   	push   %eax
    5d9e:	e8 29 e1 ff ff       	call   3ecc <lodepng_free>
    5da3:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    5da6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5da9:	83 ec 0c             	sub    $0xc,%esp
    5dac:	50                   	push   %eax
    5dad:	e8 1a e1 ff ff       	call   3ecc <lodepng_free>
    5db2:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    5db5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5db8:	83 ec 0c             	sub    $0xc,%esp
    5dbb:	50                   	push   %eax
    5dbc:	e8 0b e1 ff ff       	call   3ecc <lodepng_free>
    5dc1:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    5dc4:	83 ec 0c             	sub    $0xc,%esp
    5dc7:	ff 75 e4             	pushl  -0x1c(%ebp)
    5dca:	e8 fd e0 ff ff       	call   3ecc <lodepng_free>
    5dcf:	83 c4 10             	add    $0x10,%esp
  return error;
    5dd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5dd5:	c9                   	leave  
    5dd6:	c3                   	ret    

00005dd7 <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    5dd7:	55                   	push   %ebp
    5dd8:	89 e5                	mov    %esp,%ebp
    5dda:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    5ddd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    5de4:	eb 04                	jmp    5dea <HuffmanTree_makeFromFrequencies+0x13>
    5de6:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    5dea:	8b 45 14             	mov    0x14(%ebp),%eax
    5ded:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5df2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5df9:	8b 45 0c             	mov    0xc(%ebp),%eax
    5dfc:	01 d0                	add    %edx,%eax
    5dfe:	8b 00                	mov    (%eax),%eax
    5e00:	85 c0                	test   %eax,%eax
    5e02:	75 08                	jne    5e0c <HuffmanTree_makeFromFrequencies+0x35>
    5e04:	8b 45 14             	mov    0x14(%ebp),%eax
    5e07:	3b 45 10             	cmp    0x10(%ebp),%eax
    5e0a:	7f da                	jg     5de6 <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    5e0c:	8b 45 14             	mov    0x14(%ebp),%eax
    5e0f:	c1 e0 02             	shl    $0x2,%eax
    5e12:	83 ec 0c             	sub    $0xc,%esp
    5e15:	50                   	push   %eax
    5e16:	e8 90 e0 ff ff       	call   3eab <lodepng_malloc>
    5e1b:	83 c4 10             	add    $0x10,%esp
    5e1e:	89 c2                	mov    %eax,%edx
    5e20:	8b 45 08             	mov    0x8(%ebp),%eax
    5e23:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    5e26:	8b 45 08             	mov    0x8(%ebp),%eax
    5e29:	8b 40 04             	mov    0x4(%eax),%eax
    5e2c:	85 c0                	test   %eax,%eax
    5e2e:	75 07                	jne    5e37 <HuffmanTree_makeFromFrequencies+0x60>
    5e30:	b8 53 00 00 00       	mov    $0x53,%eax
    5e35:	eb 47                	jmp    5e7e <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    5e37:	8b 45 08             	mov    0x8(%ebp),%eax
    5e3a:	8b 55 18             	mov    0x18(%ebp),%edx
    5e3d:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    5e40:	8b 55 14             	mov    0x14(%ebp),%edx
    5e43:	8b 45 08             	mov    0x8(%ebp),%eax
    5e46:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    5e49:	8b 45 08             	mov    0x8(%ebp),%eax
    5e4c:	8b 40 04             	mov    0x4(%eax),%eax
    5e4f:	ff 75 18             	pushl  0x18(%ebp)
    5e52:	ff 75 14             	pushl  0x14(%ebp)
    5e55:	ff 75 0c             	pushl  0xc(%ebp)
    5e58:	50                   	push   %eax
    5e59:	e8 06 fc ff ff       	call   5a64 <lodepng_huffman_code_lengths>
    5e5e:	83 c4 10             	add    $0x10,%esp
    5e61:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    5e64:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5e68:	75 11                	jne    5e7b <HuffmanTree_makeFromFrequencies+0xa4>
    5e6a:	83 ec 0c             	sub    $0xc,%esp
    5e6d:	ff 75 08             	pushl  0x8(%ebp)
    5e70:	e8 37 f4 ff ff       	call   52ac <HuffmanTree_makeFromLengths2>
    5e75:	83 c4 10             	add    $0x10,%esp
    5e78:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    5e7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5e7e:	c9                   	leave  
    5e7f:	c3                   	ret    

00005e80 <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    5e80:	55                   	push   %ebp
    5e81:	89 e5                	mov    %esp,%ebp
    5e83:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    5e86:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    5e8d:	83 ec 0c             	sub    $0xc,%esp
    5e90:	68 80 04 00 00       	push   $0x480
    5e95:	e8 11 e0 ff ff       	call   3eab <lodepng_malloc>
    5e9a:	83 c4 10             	add    $0x10,%esp
    5e9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    5ea0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5ea4:	75 0a                	jne    5eb0 <generateFixedLitLenTree+0x30>
    5ea6:	b8 53 00 00 00       	mov    $0x53,%eax
    5eab:	e9 d5 00 00 00       	jmp    5f85 <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    5eb0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5eb7:	eb 19                	jmp    5ed2 <generateFixedLitLenTree+0x52>
    5eb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5ebc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5ec3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ec6:	01 d0                	add    %edx,%eax
    5ec8:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5ece:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5ed2:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    5ed9:	76 de                	jbe    5eb9 <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    5edb:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    5ee2:	eb 19                	jmp    5efd <generateFixedLitLenTree+0x7d>
    5ee4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5ee7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5eee:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ef1:	01 d0                	add    %edx,%eax
    5ef3:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    5ef9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5efd:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    5f04:	76 de                	jbe    5ee4 <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    5f06:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    5f0d:	eb 19                	jmp    5f28 <generateFixedLitLenTree+0xa8>
    5f0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5f12:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5f19:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f1c:	01 d0                	add    %edx,%eax
    5f1e:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    5f24:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5f28:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    5f2f:	76 de                	jbe    5f0f <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    5f31:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    5f38:	eb 19                	jmp    5f53 <generateFixedLitLenTree+0xd3>
    5f3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5f3d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5f44:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f47:	01 d0                	add    %edx,%eax
    5f49:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5f4f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5f53:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    5f5a:	76 de                	jbe    5f3a <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5f5c:	6a 0f                	push   $0xf
    5f5e:	68 20 01 00 00       	push   $0x120
    5f63:	ff 75 ec             	pushl  -0x14(%ebp)
    5f66:	ff 75 08             	pushl  0x8(%ebp)
    5f69:	e8 7f f5 ff ff       	call   54ed <HuffmanTree_makeFromLengths>
    5f6e:	83 c4 10             	add    $0x10,%esp
    5f71:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    5f74:	83 ec 0c             	sub    $0xc,%esp
    5f77:	ff 75 ec             	pushl  -0x14(%ebp)
    5f7a:	e8 4d df ff ff       	call   3ecc <lodepng_free>
    5f7f:	83 c4 10             	add    $0x10,%esp
  return error;
    5f82:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    5f85:	c9                   	leave  
    5f86:	c3                   	ret    

00005f87 <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    5f87:	55                   	push   %ebp
    5f88:	89 e5                	mov    %esp,%ebp
    5f8a:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    5f8d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    5f94:	83 ec 0c             	sub    $0xc,%esp
    5f97:	68 80 00 00 00       	push   $0x80
    5f9c:	e8 0a df ff ff       	call   3eab <lodepng_malloc>
    5fa1:	83 c4 10             	add    $0x10,%esp
    5fa4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    5fa7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5fab:	75 07                	jne    5fb4 <generateFixedDistanceTree+0x2d>
    5fad:	b8 53 00 00 00       	mov    $0x53,%eax
    5fb2:	eb 4e                	jmp    6002 <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    5fb4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5fbb:	eb 19                	jmp    5fd6 <generateFixedDistanceTree+0x4f>
    5fbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5fc0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5fc7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5fca:	01 d0                	add    %edx,%eax
    5fcc:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    5fd2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5fd6:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    5fda:	75 e1                	jne    5fbd <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    5fdc:	6a 0f                	push   $0xf
    5fde:	6a 20                	push   $0x20
    5fe0:	ff 75 ec             	pushl  -0x14(%ebp)
    5fe3:	ff 75 08             	pushl  0x8(%ebp)
    5fe6:	e8 02 f5 ff ff       	call   54ed <HuffmanTree_makeFromLengths>
    5feb:	83 c4 10             	add    $0x10,%esp
    5fee:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    5ff1:	83 ec 0c             	sub    $0xc,%esp
    5ff4:	ff 75 ec             	pushl  -0x14(%ebp)
    5ff7:	e8 d0 de ff ff       	call   3ecc <lodepng_free>
    5ffc:	83 c4 10             	add    $0x10,%esp
  return error;
    5fff:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    6002:	c9                   	leave  
    6003:	c3                   	ret    

00006004 <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    6004:	55                   	push   %ebp
    6005:	89 e5                	mov    %esp,%ebp
    6007:	53                   	push   %ebx
    6008:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    600b:	6a 09                	push   $0x9
    600d:	ff 75 08             	pushl  0x8(%ebp)
    6010:	e8 d8 eb ff ff       	call   4bed <peekBits>
    6015:	83 c4 08             	add    $0x8,%esp
    6018:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    601c:	8b 45 0c             	mov    0xc(%ebp),%eax
    601f:	8b 50 10             	mov    0x10(%eax),%edx
    6022:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    6026:	01 d0                	add    %edx,%eax
    6028:	0f b6 00             	movzbl (%eax),%eax
    602b:	0f b6 c0             	movzbl %al,%eax
    602e:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    6032:	8b 45 0c             	mov    0xc(%ebp),%eax
    6035:	8b 40 14             	mov    0x14(%eax),%eax
    6038:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    603c:	01 d2                	add    %edx,%edx
    603e:	01 d0                	add    %edx,%eax
    6040:	0f b7 00             	movzwl (%eax),%eax
    6043:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    6047:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    604c:	77 16                	ja     6064 <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    604e:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    6052:	50                   	push   %eax
    6053:	ff 75 08             	pushl  0x8(%ebp)
    6056:	e8 b2 eb ff ff       	call   4c0d <advanceBits>
    605b:	83 c4 08             	add    $0x8,%esp
    return value;
    605e:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    6062:	eb 5c                	jmp    60c0 <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    6064:	6a 09                	push   $0x9
    6066:	ff 75 08             	pushl  0x8(%ebp)
    6069:	e8 9f eb ff ff       	call   4c0d <advanceBits>
    606e:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    6071:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    6075:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    6079:	83 e8 09             	sub    $0x9,%eax
    607c:	50                   	push   %eax
    607d:	ff 75 08             	pushl  0x8(%ebp)
    6080:	e8 68 eb ff ff       	call   4bed <peekBits>
    6085:	83 c4 08             	add    $0x8,%esp
    6088:	01 d8                	add    %ebx,%eax
    608a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    608d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6090:	8b 50 10             	mov    0x10(%eax),%edx
    6093:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6096:	01 d0                	add    %edx,%eax
    6098:	0f b6 00             	movzbl (%eax),%eax
    609b:	0f b6 c0             	movzbl %al,%eax
    609e:	83 e8 09             	sub    $0x9,%eax
    60a1:	50                   	push   %eax
    60a2:	ff 75 08             	pushl  0x8(%ebp)
    60a5:	e8 63 eb ff ff       	call   4c0d <advanceBits>
    60aa:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    60ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    60b0:	8b 40 14             	mov    0x14(%eax),%eax
    60b3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    60b6:	01 d2                	add    %edx,%edx
    60b8:	01 d0                	add    %edx,%eax
    60ba:	0f b7 00             	movzwl (%eax),%eax
    60bd:	0f b7 c0             	movzwl %ax,%eax
  }
}
    60c0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    60c3:	c9                   	leave  
    60c4:	c3                   	ret    

000060c5 <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    60c5:	55                   	push   %ebp
    60c6:	89 e5                	mov    %esp,%ebp
    60c8:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    60cb:	83 ec 0c             	sub    $0xc,%esp
    60ce:	ff 75 08             	pushl  0x8(%ebp)
    60d1:	e8 aa fd ff ff       	call   5e80 <generateFixedLitLenTree>
    60d6:	83 c4 10             	add    $0x10,%esp
    60d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    60dc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    60e0:	74 05                	je     60e7 <getTreeInflateFixed+0x22>
    60e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60e5:	eb 0e                	jmp    60f5 <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    60e7:	83 ec 0c             	sub    $0xc,%esp
    60ea:	ff 75 0c             	pushl  0xc(%ebp)
    60ed:	e8 95 fe ff ff       	call   5f87 <generateFixedDistanceTree>
    60f2:	83 c4 10             	add    $0x10,%esp
}
    60f5:	c9                   	leave  
    60f6:	c3                   	ret    

000060f7 <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    60f7:	55                   	push   %ebp
    60f8:	89 e5                	mov    %esp,%ebp
    60fa:	53                   	push   %ebx
    60fb:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    60fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    6105:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    610c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    6113:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    611a:	6a 0e                	push   $0xe
    611c:	ff 75 10             	pushl  0x10(%ebp)
    611f:	e8 37 e6 ff ff       	call   475b <ensureBits17>
    6124:	83 c4 08             	add    $0x8,%esp
    6127:	85 c0                	test   %eax,%eax
    6129:	75 0a                	jne    6135 <getTreeInflateDynamic+0x3e>
    612b:	b8 31 00 00 00       	mov    $0x31,%eax
    6130:	e9 ec 04 00 00       	jmp    6621 <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    6135:	6a 05                	push   $0x5
    6137:	ff 75 10             	pushl  0x10(%ebp)
    613a:	e8 f8 ea ff ff       	call   4c37 <readBits>
    613f:	83 c4 08             	add    $0x8,%esp
    6142:	05 01 01 00 00       	add    $0x101,%eax
    6147:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    614a:	6a 05                	push   $0x5
    614c:	ff 75 10             	pushl  0x10(%ebp)
    614f:	e8 e3 ea ff ff       	call   4c37 <readBits>
    6154:	83 c4 08             	add    $0x8,%esp
    6157:	83 c0 01             	add    $0x1,%eax
    615a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    615d:	6a 04                	push   $0x4
    615f:	ff 75 10             	pushl  0x10(%ebp)
    6162:	e8 d0 ea ff ff       	call   4c37 <readBits>
    6167:	83 c4 08             	add    $0x8,%esp
    616a:	83 c0 04             	add    $0x4,%eax
    616d:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    6170:	83 ec 0c             	sub    $0xc,%esp
    6173:	6a 4c                	push   $0x4c
    6175:	e8 31 dd ff ff       	call   3eab <lodepng_malloc>
    617a:	83 c4 10             	add    $0x10,%esp
    617d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    6180:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    6184:	75 0a                	jne    6190 <getTreeInflateDynamic+0x99>
    6186:	b8 53 00 00 00       	mov    $0x53,%eax
    618b:	e9 91 04 00 00       	jmp    6621 <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    6190:	83 ec 0c             	sub    $0xc,%esp
    6193:	8d 45 a8             	lea    -0x58(%ebp),%eax
    6196:	50                   	push   %eax
    6197:	e8 03 ec ff ff       	call   4d9f <HuffmanTree_init>
    619c:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    619f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    61a3:	0f 85 3c 04 00 00    	jne    65e5 <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    61a9:	8b 45 10             	mov    0x10(%ebp),%eax
    61ac:	8b 48 08             	mov    0x8(%eax),%ecx
    61af:	8b 55 d0             	mov    -0x30(%ebp),%edx
    61b2:	89 d0                	mov    %edx,%eax
    61b4:	01 c0                	add    %eax,%eax
    61b6:	01 d0                	add    %edx,%eax
    61b8:	89 c2                	mov    %eax,%edx
    61ba:	8b 45 10             	mov    0x10(%ebp),%eax
    61bd:	8b 40 0c             	mov    0xc(%eax),%eax
    61c0:	83 ec 04             	sub    $0x4,%esp
    61c3:	51                   	push   %ecx
    61c4:	52                   	push   %edx
    61c5:	50                   	push   %eax
    61c6:	e8 f7 dd ff ff       	call   3fc2 <lodepng_gtofl>
    61cb:	83 c4 10             	add    $0x10,%esp
    61ce:	85 c0                	test   %eax,%eax
    61d0:	74 0c                	je     61de <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    61d2:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    61d9:	e9 07 04 00 00       	jmp    65e5 <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    61de:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    61e5:	eb 3d                	jmp    6224 <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    61e7:	83 ec 08             	sub    $0x8,%esp
    61ea:	6a 03                	push   $0x3
    61ec:	ff 75 10             	pushl  0x10(%ebp)
    61ef:	e8 8b e4 ff ff       	call   467f <ensureBits9>
    61f4:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    61f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    61fa:	8b 04 85 80 ab 01 00 	mov    0x1ab80(,%eax,4),%eax
    6201:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6208:	8b 45 dc             	mov    -0x24(%ebp),%eax
    620b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    620e:	83 ec 08             	sub    $0x8,%esp
    6211:	6a 03                	push   $0x3
    6213:	ff 75 10             	pushl  0x10(%ebp)
    6216:	e8 1c ea ff ff       	call   4c37 <readBits>
    621b:	83 c4 10             	add    $0x10,%esp
    621e:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    6220:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    6224:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6227:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    622a:	75 bb                	jne    61e7 <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    622c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    622f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    6232:	eb 20                	jmp    6254 <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    6234:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6237:	8b 04 85 80 ab 01 00 	mov    0x1ab80(,%eax,4),%eax
    623e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6245:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6248:	01 d0                	add    %edx,%eax
    624a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    6250:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    6254:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    6258:	75 da                	jne    6234 <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    625a:	6a 07                	push   $0x7
    625c:	6a 13                	push   $0x13
    625e:	ff 75 dc             	pushl  -0x24(%ebp)
    6261:	8d 45 a8             	lea    -0x58(%ebp),%eax
    6264:	50                   	push   %eax
    6265:	e8 83 f2 ff ff       	call   54ed <HuffmanTree_makeFromLengths>
    626a:	83 c4 10             	add    $0x10,%esp
    626d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    6270:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6274:	0f 85 64 03 00 00    	jne    65de <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    627a:	83 ec 0c             	sub    $0xc,%esp
    627d:	68 80 04 00 00       	push   $0x480
    6282:	e8 24 dc ff ff       	call   3eab <lodepng_malloc>
    6287:	83 c4 10             	add    $0x10,%esp
    628a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    628d:	83 ec 0c             	sub    $0xc,%esp
    6290:	68 80 00 00 00       	push   $0x80
    6295:	e8 11 dc ff ff       	call   3eab <lodepng_malloc>
    629a:	83 c4 10             	add    $0x10,%esp
    629d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    62a0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    62a4:	74 06                	je     62ac <getTreeInflateDynamic+0x1b5>
    62a6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    62aa:	75 0c                	jne    62b8 <getTreeInflateDynamic+0x1c1>
    62ac:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    62b3:	e9 2d 03 00 00       	jmp    65e5 <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    62b8:	83 ec 04             	sub    $0x4,%esp
    62bb:	68 80 04 00 00       	push   $0x480
    62c0:	6a 00                	push   $0x0
    62c2:	ff 75 e8             	pushl  -0x18(%ebp)
    62c5:	e8 52 dc ff ff       	call   3f1c <lodepng_memset>
    62ca:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    62cd:	83 ec 04             	sub    $0x4,%esp
    62d0:	68 80 00 00 00       	push   $0x80
    62d5:	6a 00                	push   $0x0
    62d7:	ff 75 e4             	pushl  -0x1c(%ebp)
    62da:	e8 3d dc ff ff       	call   3f1c <lodepng_memset>
    62df:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    62e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    62e9:	e9 8d 02 00 00       	jmp    657b <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    62ee:	83 ec 08             	sub    $0x8,%esp
    62f1:	6a 16                	push   $0x16
    62f3:	ff 75 10             	pushl  0x10(%ebp)
    62f6:	e8 8c e5 ff ff       	call   4887 <ensureBits25>
    62fb:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    62fe:	83 ec 08             	sub    $0x8,%esp
    6301:	8d 45 a8             	lea    -0x58(%ebp),%eax
    6304:	50                   	push   %eax
    6305:	ff 75 10             	pushl  0x10(%ebp)
    6308:	e8 f7 fc ff ff       	call   6004 <huffmanDecodeSymbol>
    630d:	83 c4 10             	add    $0x10,%esp
    6310:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    6313:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    6317:	77 3e                	ja     6357 <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    6319:	8b 45 ec             	mov    -0x14(%ebp),%eax
    631c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    631f:	73 16                	jae    6337 <getTreeInflateDynamic+0x240>
    6321:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6324:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    632b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    632e:	01 c2                	add    %eax,%edx
    6330:	8b 45 cc             	mov    -0x34(%ebp),%eax
    6333:	89 02                	mov    %eax,(%edx)
    6335:	eb 17                	jmp    634e <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    6337:	8b 45 ec             	mov    -0x14(%ebp),%eax
    633a:	2b 45 d8             	sub    -0x28(%ebp),%eax
    633d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6344:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6347:	01 c2                	add    %eax,%edx
    6349:	8b 45 cc             	mov    -0x34(%ebp),%eax
    634c:	89 02                	mov    %eax,(%edx)
        ++i;
    634e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    6352:	e9 0b 02 00 00       	jmp    6562 <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    6357:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    635b:	0f 85 da 00 00 00    	jne    643b <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    6361:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    6368:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    636c:	75 0c                	jne    637a <getTreeInflateDynamic+0x283>
    636e:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    6375:	e9 12 02 00 00       	jmp    658c <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    637a:	83 ec 08             	sub    $0x8,%esp
    637d:	6a 02                	push   $0x2
    637f:	ff 75 10             	pushl  0x10(%ebp)
    6382:	e8 b0 e8 ff ff       	call   4c37 <readBits>
    6387:	83 c4 10             	add    $0x10,%esp
    638a:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    638d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6390:	83 c0 01             	add    $0x1,%eax
    6393:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6396:	76 1b                	jbe    63b3 <getTreeInflateDynamic+0x2bc>
    6398:	8b 45 ec             	mov    -0x14(%ebp),%eax
    639b:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    63a0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    63a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    63aa:	01 d0                	add    %edx,%eax
    63ac:	8b 00                	mov    (%eax),%eax
    63ae:	89 45 e0             	mov    %eax,-0x20(%ebp)
    63b1:	eb 1c                	jmp    63cf <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    63b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    63b6:	2b 45 d8             	sub    -0x28(%ebp),%eax
    63b9:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    63be:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    63c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    63c8:	01 d0                	add    %edx,%eax
    63ca:	8b 00                	mov    (%eax),%eax
    63cc:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    63cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    63d6:	eb 56                	jmp    642e <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    63d8:	8b 55 d8             	mov    -0x28(%ebp),%edx
    63db:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    63de:	01 d0                	add    %edx,%eax
    63e0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    63e3:	77 0c                	ja     63f1 <getTreeInflateDynamic+0x2fa>
    63e5:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    63ec:	e9 71 01 00 00       	jmp    6562 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    63f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    63f4:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    63f7:	73 16                	jae    640f <getTreeInflateDynamic+0x318>
    63f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    63fc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6403:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6406:	01 c2                	add    %eax,%edx
    6408:	8b 45 e0             	mov    -0x20(%ebp),%eax
    640b:	89 02                	mov    %eax,(%edx)
    640d:	eb 17                	jmp    6426 <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    640f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6412:	2b 45 d8             	sub    -0x28(%ebp),%eax
    6415:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    641c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    641f:	01 c2                	add    %eax,%edx
    6421:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6424:	89 02                	mov    %eax,(%edx)
          ++i;
    6426:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    642a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    642e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6431:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    6434:	72 a2                	jb     63d8 <getTreeInflateDynamic+0x2e1>
    6436:	e9 27 01 00 00       	jmp    6562 <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    643b:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    643f:	0f 85 88 00 00 00    	jne    64cd <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    6445:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    644c:	83 ec 08             	sub    $0x8,%esp
    644f:	6a 03                	push   $0x3
    6451:	ff 75 10             	pushl  0x10(%ebp)
    6454:	e8 de e7 ff ff       	call   4c37 <readBits>
    6459:	83 c4 10             	add    $0x10,%esp
    645c:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    645f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6466:	eb 58                	jmp    64c0 <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    6468:	8b 55 d8             	mov    -0x28(%ebp),%edx
    646b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    646e:	01 d0                	add    %edx,%eax
    6470:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6473:	77 0c                	ja     6481 <getTreeInflateDynamic+0x38a>
    6475:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    647c:	e9 e1 00 00 00       	jmp    6562 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    6481:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6484:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6487:	73 17                	jae    64a0 <getTreeInflateDynamic+0x3a9>
    6489:	8b 45 ec             	mov    -0x14(%ebp),%eax
    648c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6493:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6496:	01 d0                	add    %edx,%eax
    6498:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    649e:	eb 18                	jmp    64b8 <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    64a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    64a3:	2b 45 d8             	sub    -0x28(%ebp),%eax
    64a6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    64ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    64b0:	01 d0                	add    %edx,%eax
    64b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    64b8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    64bc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    64c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    64c3:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    64c6:	72 a0                	jb     6468 <getTreeInflateDynamic+0x371>
    64c8:	e9 95 00 00 00       	jmp    6562 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    64cd:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    64d1:	0f 85 82 00 00 00    	jne    6559 <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    64d7:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    64de:	83 ec 08             	sub    $0x8,%esp
    64e1:	6a 07                	push   $0x7
    64e3:	ff 75 10             	pushl  0x10(%ebp)
    64e6:	e8 4c e7 ff ff       	call   4c37 <readBits>
    64eb:	83 c4 10             	add    $0x10,%esp
    64ee:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    64f1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    64f8:	eb 55                	jmp    654f <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    64fa:	8b 55 d8             	mov    -0x28(%ebp),%edx
    64fd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6500:	01 d0                	add    %edx,%eax
    6502:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6505:	77 09                	ja     6510 <getTreeInflateDynamic+0x419>
    6507:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    650e:	eb 52                	jmp    6562 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    6510:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6513:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6516:	73 17                	jae    652f <getTreeInflateDynamic+0x438>
    6518:	8b 45 ec             	mov    -0x14(%ebp),%eax
    651b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6522:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6525:	01 d0                	add    %edx,%eax
    6527:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    652d:	eb 18                	jmp    6547 <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    652f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6532:	2b 45 d8             	sub    -0x28(%ebp),%eax
    6535:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    653c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    653f:	01 d0                	add    %edx,%eax
    6541:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    6547:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    654b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    654f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6552:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    6555:	72 a3                	jb     64fa <getTreeInflateDynamic+0x403>
    6557:	eb 09                	jmp    6562 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    6559:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    6560:	eb 2a                	jmp    658c <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    6562:	8b 45 10             	mov    0x10(%ebp),%eax
    6565:	8b 50 0c             	mov    0xc(%eax),%edx
    6568:	8b 45 10             	mov    0x10(%ebp),%eax
    656b:	8b 40 08             	mov    0x8(%eax),%eax
    656e:	39 c2                	cmp    %eax,%edx
    6570:	7e 09                	jle    657b <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    6572:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    6579:	eb 11                	jmp    658c <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    657b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    657e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6581:	01 d0                	add    %edx,%eax
    6583:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6586:	0f 87 62 fd ff ff    	ja     62ee <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    658c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6590:	75 4f                	jne    65e1 <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    6592:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6595:	05 00 04 00 00       	add    $0x400,%eax
    659a:	8b 00                	mov    (%eax),%eax
    659c:	85 c0                	test   %eax,%eax
    659e:	75 09                	jne    65a9 <getTreeInflateDynamic+0x4b2>
    65a0:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    65a7:	eb 3c                	jmp    65e5 <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    65a9:	6a 0f                	push   $0xf
    65ab:	68 20 01 00 00       	push   $0x120
    65b0:	ff 75 e8             	pushl  -0x18(%ebp)
    65b3:	ff 75 08             	pushl  0x8(%ebp)
    65b6:	e8 32 ef ff ff       	call   54ed <HuffmanTree_makeFromLengths>
    65bb:	83 c4 10             	add    $0x10,%esp
    65be:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    65c1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    65c5:	75 1d                	jne    65e4 <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    65c7:	6a 0f                	push   $0xf
    65c9:	6a 20                	push   $0x20
    65cb:	ff 75 e4             	pushl  -0x1c(%ebp)
    65ce:	ff 75 0c             	pushl  0xc(%ebp)
    65d1:	e8 17 ef ff ff       	call   54ed <HuffmanTree_makeFromLengths>
    65d6:	83 c4 10             	add    $0x10,%esp
    65d9:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    65dc:	eb 07                	jmp    65e5 <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    65de:	90                   	nop
    65df:	eb 04                	jmp    65e5 <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    65e1:	90                   	nop
    65e2:	eb 01                	jmp    65e5 <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    65e4:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    65e5:	83 ec 0c             	sub    $0xc,%esp
    65e8:	ff 75 dc             	pushl  -0x24(%ebp)
    65eb:	e8 dc d8 ff ff       	call   3ecc <lodepng_free>
    65f0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    65f3:	83 ec 0c             	sub    $0xc,%esp
    65f6:	ff 75 e8             	pushl  -0x18(%ebp)
    65f9:	e8 ce d8 ff ff       	call   3ecc <lodepng_free>
    65fe:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    6601:	83 ec 0c             	sub    $0xc,%esp
    6604:	ff 75 e4             	pushl  -0x1c(%ebp)
    6607:	e8 c0 d8 ff ff       	call   3ecc <lodepng_free>
    660c:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    660f:	83 ec 0c             	sub    $0xc,%esp
    6612:	8d 45 a8             	lea    -0x58(%ebp),%eax
    6615:	50                   	push   %eax
    6616:	e8 b1 e7 ff ff       	call   4dcc <HuffmanTree_cleanup>
    661b:	83 c4 10             	add    $0x10,%esp

  return error;
    661e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6621:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6624:	c9                   	leave  
    6625:	c3                   	ret    

00006626 <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    6626:	55                   	push   %ebp
    6627:	89 e5                	mov    %esp,%ebp
    6629:	53                   	push   %ebx
    662a:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    662d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    6634:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6637:	50                   	push   %eax
    6638:	e8 62 e7 ff ff       	call   4d9f <HuffmanTree_init>
    663d:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    6640:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6643:	50                   	push   %eax
    6644:	e8 56 e7 ff ff       	call   4d9f <HuffmanTree_init>
    6649:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    664c:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    6650:	75 1b                	jne    666d <inflateHuffmanBlock+0x47>
    6652:	83 ec 08             	sub    $0x8,%esp
    6655:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6658:	50                   	push   %eax
    6659:	8d 45 b8             	lea    -0x48(%ebp),%eax
    665c:	50                   	push   %eax
    665d:	e8 63 fa ff ff       	call   60c5 <getTreeInflateFixed>
    6662:	83 c4 10             	add    $0x10,%esp
    6665:	89 45 f4             	mov    %eax,-0xc(%ebp)
    6668:	e9 9a 02 00 00       	jmp    6907 <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    666d:	83 ec 04             	sub    $0x4,%esp
    6670:	ff 75 0c             	pushl  0xc(%ebp)
    6673:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6676:	50                   	push   %eax
    6677:	8d 45 b8             	lea    -0x48(%ebp),%eax
    667a:	50                   	push   %eax
    667b:	e8 77 fa ff ff       	call   60f7 <getTreeInflateDynamic>
    6680:	83 c4 10             	add    $0x10,%esp
    6683:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    6686:	e9 7c 02 00 00       	jmp    6907 <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    668b:	83 ec 08             	sub    $0x8,%esp
    668e:	6a 14                	push   $0x14
    6690:	ff 75 0c             	pushl  0xc(%ebp)
    6693:	e8 ef e1 ff ff       	call   4887 <ensureBits25>
    6698:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    669b:	83 ec 08             	sub    $0x8,%esp
    669e:	8d 45 b8             	lea    -0x48(%ebp),%eax
    66a1:	50                   	push   %eax
    66a2:	ff 75 0c             	pushl  0xc(%ebp)
    66a5:	e8 5a f9 ff ff       	call   6004 <huffmanDecodeSymbol>
    66aa:	83 c4 10             	add    $0x10,%esp
    66ad:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    66b0:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    66b7:	77 42                	ja     66fb <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    66b9:	8b 45 08             	mov    0x8(%ebp),%eax
    66bc:	8b 40 04             	mov    0x4(%eax),%eax
    66bf:	83 c0 01             	add    $0x1,%eax
    66c2:	83 ec 08             	sub    $0x8,%esp
    66c5:	50                   	push   %eax
    66c6:	ff 75 08             	pushl  0x8(%ebp)
    66c9:	e8 37 da ff ff       	call   4105 <ucvector_resize>
    66ce:	83 c4 10             	add    $0x10,%esp
    66d1:	85 c0                	test   %eax,%eax
    66d3:	75 0c                	jne    66e1 <inflateHuffmanBlock+0xbb>
    66d5:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    66dc:	e9 33 02 00 00       	jmp    6914 <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    66e1:	8b 45 08             	mov    0x8(%ebp),%eax
    66e4:	8b 10                	mov    (%eax),%edx
    66e6:	8b 45 08             	mov    0x8(%ebp),%eax
    66e9:	8b 40 04             	mov    0x4(%eax),%eax
    66ec:	83 e8 01             	sub    $0x1,%eax
    66ef:	01 d0                	add    %edx,%eax
    66f1:	8b 55 dc             	mov    -0x24(%ebp),%edx
    66f4:	88 10                	mov    %dl,(%eax)
    66f6:	e9 d9 01 00 00       	jmp    68d4 <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    66fb:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    6702:	0f 86 ba 01 00 00    	jbe    68c2 <inflateHuffmanBlock+0x29c>
    6708:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    670f:	0f 87 ad 01 00 00    	ja     68c2 <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    6715:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6718:	2d 01 01 00 00       	sub    $0x101,%eax
    671d:	8b 04 85 80 a9 01 00 	mov    0x1a980(,%eax,4),%eax
    6724:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    6727:	8b 45 dc             	mov    -0x24(%ebp),%eax
    672a:	2d 01 01 00 00       	sub    $0x101,%eax
    672f:	8b 04 85 00 aa 01 00 	mov    0x1aa00(,%eax,4),%eax
    6736:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    6739:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    673d:	74 1c                	je     675b <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    673f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6742:	83 ec 08             	sub    $0x8,%esp
    6745:	50                   	push   %eax
    6746:	ff 75 0c             	pushl  0xc(%ebp)
    6749:	e8 e9 e4 ff ff       	call   4c37 <readBits>
    674e:	83 c4 10             	add    $0x10,%esp
    6751:	89 c2                	mov    %eax,%edx
    6753:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6756:	01 d0                	add    %edx,%eax
    6758:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    675b:	83 ec 08             	sub    $0x8,%esp
    675e:	6a 1c                	push   $0x1c
    6760:	ff 75 0c             	pushl  0xc(%ebp)
    6763:	e8 98 e2 ff ff       	call   4a00 <ensureBits32>
    6768:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    676b:	83 ec 08             	sub    $0x8,%esp
    676e:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6771:	50                   	push   %eax
    6772:	ff 75 0c             	pushl  0xc(%ebp)
    6775:	e8 8a f8 ff ff       	call   6004 <huffmanDecodeSymbol>
    677a:	83 c4 10             	add    $0x10,%esp
    677d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    6780:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    6784:	76 1e                	jbe    67a4 <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    6786:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    678a:	77 0c                	ja     6798 <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    678c:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    6793:	e9 7c 01 00 00       	jmp    6914 <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    6798:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    679f:	e9 70 01 00 00       	jmp    6914 <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    67a4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    67a7:	8b 04 85 80 aa 01 00 	mov    0x1aa80(,%eax,4),%eax
    67ae:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    67b1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    67b4:	8b 04 85 00 ab 01 00 	mov    0x1ab00(,%eax,4),%eax
    67bb:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    67be:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    67c2:	74 15                	je     67d9 <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    67c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
    67c7:	83 ec 08             	sub    $0x8,%esp
    67ca:	50                   	push   %eax
    67cb:	ff 75 0c             	pushl  0xc(%ebp)
    67ce:	e8 64 e4 ff ff       	call   4c37 <readBits>
    67d3:	83 c4 10             	add    $0x10,%esp
    67d6:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    67d9:	8b 45 08             	mov    0x8(%ebp),%eax
    67dc:	8b 40 04             	mov    0x4(%eax),%eax
    67df:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    67e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    67e5:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    67e8:	76 0c                	jbe    67f6 <inflateHuffmanBlock+0x1d0>
    67ea:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    67f1:	e9 1e 01 00 00       	jmp    6914 <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    67f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    67f9:	2b 45 f0             	sub    -0x10(%ebp),%eax
    67fc:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    67ff:	8b 45 08             	mov    0x8(%ebp),%eax
    6802:	8b 50 04             	mov    0x4(%eax),%edx
    6805:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6808:	01 d0                	add    %edx,%eax
    680a:	83 ec 08             	sub    $0x8,%esp
    680d:	50                   	push   %eax
    680e:	ff 75 08             	pushl  0x8(%ebp)
    6811:	e8 ef d8 ff ff       	call   4105 <ucvector_resize>
    6816:	83 c4 10             	add    $0x10,%esp
    6819:	85 c0                	test   %eax,%eax
    681b:	75 0c                	jne    6829 <inflateHuffmanBlock+0x203>
    681d:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6824:	e9 eb 00 00 00       	jmp    6914 <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    6829:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    682c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    682f:	73 6b                	jae    689c <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    6831:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6834:	8b 55 08             	mov    0x8(%ebp),%edx
    6837:	8b 0a                	mov    (%edx),%ecx
    6839:	8b 55 e8             	mov    -0x18(%ebp),%edx
    683c:	01 d1                	add    %edx,%ecx
    683e:	8b 55 08             	mov    0x8(%ebp),%edx
    6841:	8b 1a                	mov    (%edx),%ebx
    6843:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6846:	01 da                	add    %ebx,%edx
    6848:	83 ec 04             	sub    $0x4,%esp
    684b:	50                   	push   %eax
    684c:	51                   	push   %ecx
    684d:	52                   	push   %edx
    684e:	e8 96 d6 ff ff       	call   3ee9 <lodepng_memcpy>
    6853:	83 c4 10             	add    $0x10,%esp
        start += distance;
    6856:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6859:	8b 45 f0             	mov    -0x10(%ebp),%eax
    685c:	01 d0                	add    %edx,%eax
    685e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    6861:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6864:	89 45 e0             	mov    %eax,-0x20(%ebp)
    6867:	eb 29                	jmp    6892 <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    6869:	8b 45 08             	mov    0x8(%ebp),%eax
    686c:	8b 08                	mov    (%eax),%ecx
    686e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6871:	8d 50 01             	lea    0x1(%eax),%edx
    6874:	89 55 ec             	mov    %edx,-0x14(%ebp)
    6877:	01 c1                	add    %eax,%ecx
    6879:	8b 45 08             	mov    0x8(%ebp),%eax
    687c:	8b 18                	mov    (%eax),%ebx
    687e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6881:	8d 50 01             	lea    0x1(%eax),%edx
    6884:	89 55 e8             	mov    %edx,-0x18(%ebp)
    6887:	01 d8                	add    %ebx,%eax
    6889:	0f b6 00             	movzbl (%eax),%eax
    688c:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    688e:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    6892:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6895:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    6898:	7c cf                	jl     6869 <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    689a:	eb 38                	jmp    68d4 <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    689c:	8b 45 08             	mov    0x8(%ebp),%eax
    689f:	8b 10                	mov    (%eax),%edx
    68a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    68a4:	01 c2                	add    %eax,%edx
    68a6:	8b 45 08             	mov    0x8(%ebp),%eax
    68a9:	8b 08                	mov    (%eax),%ecx
    68ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
    68ae:	01 c8                	add    %ecx,%eax
    68b0:	83 ec 04             	sub    $0x4,%esp
    68b3:	ff 75 e4             	pushl  -0x1c(%ebp)
    68b6:	52                   	push   %edx
    68b7:	50                   	push   %eax
    68b8:	e8 2c d6 ff ff       	call   3ee9 <lodepng_memcpy>
    68bd:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    68c0:	eb 12                	jmp    68d4 <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    68c2:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    68c9:	74 48                	je     6913 <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    68cb:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    68d2:	eb 40                	jmp    6914 <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    68d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    68d7:	8b 50 0c             	mov    0xc(%eax),%edx
    68da:	8b 45 0c             	mov    0xc(%ebp),%eax
    68dd:	8b 40 08             	mov    0x8(%eax),%eax
    68e0:	39 c2                	cmp    %eax,%edx
    68e2:	7e 09                	jle    68ed <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    68e4:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    68eb:	eb 27                	jmp    6914 <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    68ed:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    68f1:	74 14                	je     6907 <inflateHuffmanBlock+0x2e1>
    68f3:	8b 45 08             	mov    0x8(%ebp),%eax
    68f6:	8b 40 04             	mov    0x4(%eax),%eax
    68f9:	3b 45 14             	cmp    0x14(%ebp),%eax
    68fc:	7e 09                	jle    6907 <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    68fe:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    6905:	eb 0d                	jmp    6914 <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    6907:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    690b:	0f 84 7a fd ff ff    	je     668b <inflateHuffmanBlock+0x65>
    6911:	eb 01                	jmp    6914 <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    6913:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    6914:	83 ec 0c             	sub    $0xc,%esp
    6917:	8d 45 b8             	lea    -0x48(%ebp),%eax
    691a:	50                   	push   %eax
    691b:	e8 ac e4 ff ff       	call   4dcc <HuffmanTree_cleanup>
    6920:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    6923:	83 ec 0c             	sub    $0xc,%esp
    6926:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6929:	50                   	push   %eax
    692a:	e8 9d e4 ff ff       	call   4dcc <HuffmanTree_cleanup>
    692f:	83 c4 10             	add    $0x10,%esp

  return error;
    6932:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6935:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6938:	c9                   	leave  
    6939:	c3                   	ret    

0000693a <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    693a:	55                   	push   %ebp
    693b:	89 e5                	mov    %esp,%ebp
    693d:	53                   	push   %ebx
    693e:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    6941:	8b 45 0c             	mov    0xc(%ebp),%eax
    6944:	8b 40 04             	mov    0x4(%eax),%eax
    6947:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    694a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    6951:	8b 45 0c             	mov    0xc(%ebp),%eax
    6954:	8b 40 0c             	mov    0xc(%eax),%eax
    6957:	83 c0 07             	add    $0x7,%eax
    695a:	c1 e8 03             	shr    $0x3,%eax
    695d:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    6960:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6963:	83 c0 04             	add    $0x4,%eax
    6966:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6969:	7c 0a                	jl     6975 <inflateNoCompression+0x3b>
    696b:	b8 34 00 00 00       	mov    $0x34,%eax
    6970:	e9 01 01 00 00       	jmp    6a76 <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    6975:	8b 45 0c             	mov    0xc(%ebp),%eax
    6978:	8b 10                	mov    (%eax),%edx
    697a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    697d:	01 d0                	add    %edx,%eax
    697f:	0f b6 00             	movzbl (%eax),%eax
    6982:	0f b6 d0             	movzbl %al,%edx
    6985:	8b 45 0c             	mov    0xc(%ebp),%eax
    6988:	8b 00                	mov    (%eax),%eax
    698a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    698d:	83 c1 01             	add    $0x1,%ecx
    6990:	01 c8                	add    %ecx,%eax
    6992:	0f b6 00             	movzbl (%eax),%eax
    6995:	0f b6 c0             	movzbl %al,%eax
    6998:	c1 e0 08             	shl    $0x8,%eax
    699b:	01 d0                	add    %edx,%eax
    699d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    69a0:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    69a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    69a7:	8b 10                	mov    (%eax),%edx
    69a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    69ac:	01 d0                	add    %edx,%eax
    69ae:	0f b6 00             	movzbl (%eax),%eax
    69b1:	0f b6 d0             	movzbl %al,%edx
    69b4:	8b 45 0c             	mov    0xc(%ebp),%eax
    69b7:	8b 00                	mov    (%eax),%eax
    69b9:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    69bc:	83 c1 01             	add    $0x1,%ecx
    69bf:	01 c8                	add    %ecx,%eax
    69c1:	0f b6 00             	movzbl (%eax),%eax
    69c4:	0f b6 c0             	movzbl %al,%eax
    69c7:	c1 e0 08             	shl    $0x8,%eax
    69ca:	01 d0                	add    %edx,%eax
    69cc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    69cf:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    69d3:	8b 45 10             	mov    0x10(%ebp),%eax
    69d6:	8b 40 04             	mov    0x4(%eax),%eax
    69d9:	85 c0                	test   %eax,%eax
    69db:	75 19                	jne    69f6 <inflateNoCompression+0xbc>
    69dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
    69e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    69e3:	01 d0                	add    %edx,%eax
    69e5:	3d ff ff 00 00       	cmp    $0xffff,%eax
    69ea:	74 0a                	je     69f6 <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    69ec:	b8 15 00 00 00       	mov    $0x15,%eax
    69f1:	e9 80 00 00 00       	jmp    6a76 <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    69f6:	8b 45 08             	mov    0x8(%ebp),%eax
    69f9:	8b 40 04             	mov    0x4(%eax),%eax
    69fc:	89 c2                	mov    %eax,%edx
    69fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a01:	01 d0                	add    %edx,%eax
    6a03:	50                   	push   %eax
    6a04:	ff 75 08             	pushl  0x8(%ebp)
    6a07:	e8 f9 d6 ff ff       	call   4105 <ucvector_resize>
    6a0c:	83 c4 08             	add    $0x8,%esp
    6a0f:	85 c0                	test   %eax,%eax
    6a11:	75 07                	jne    6a1a <inflateNoCompression+0xe0>
    6a13:	b8 53 00 00 00       	mov    $0x53,%eax
    6a18:	eb 5c                	jmp    6a76 <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    6a1a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6a1d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a20:	01 c2                	add    %eax,%edx
    6a22:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6a25:	39 c2                	cmp    %eax,%edx
    6a27:	76 07                	jbe    6a30 <inflateNoCompression+0xf6>
    6a29:	b8 17 00 00 00       	mov    $0x17,%eax
    6a2e:	eb 46                	jmp    6a76 <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    6a30:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a33:	8b 55 0c             	mov    0xc(%ebp),%edx
    6a36:	8b 0a                	mov    (%edx),%ecx
    6a38:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6a3b:	01 d1                	add    %edx,%ecx
    6a3d:	8b 55 08             	mov    0x8(%ebp),%edx
    6a40:	8b 1a                	mov    (%edx),%ebx
    6a42:	8b 55 08             	mov    0x8(%ebp),%edx
    6a45:	8b 52 04             	mov    0x4(%edx),%edx
    6a48:	2b 55 ec             	sub    -0x14(%ebp),%edx
    6a4b:	01 da                	add    %ebx,%edx
    6a4d:	50                   	push   %eax
    6a4e:	51                   	push   %ecx
    6a4f:	52                   	push   %edx
    6a50:	e8 94 d4 ff ff       	call   3ee9 <lodepng_memcpy>
    6a55:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    6a58:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6a5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a5e:	01 d0                	add    %edx,%eax
    6a60:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    6a63:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6a66:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    6a6d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a70:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    6a73:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6a76:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6a79:	c9                   	leave  
    6a7a:	c3                   	ret    

00006a7b <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    6a7b:	55                   	push   %ebp
    6a7c:	89 e5                	mov    %esp,%ebp
    6a7e:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    6a81:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    6a88:	ff 75 10             	pushl  0x10(%ebp)
    6a8b:	ff 75 0c             	pushl  0xc(%ebp)
    6a8e:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6a91:	50                   	push   %eax
    6a92:	e8 77 db ff ff       	call   460e <LodePNGBitReader_init>
    6a97:	83 c4 0c             	add    $0xc,%esp
    6a9a:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    6a9d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6aa1:	0f 84 b9 00 00 00    	je     6b60 <lodepng_inflatev+0xe5>
    6aa7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6aaa:	e9 c1 00 00 00       	jmp    6b70 <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    6aaf:	6a 03                	push   $0x3
    6ab1:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6ab4:	50                   	push   %eax
    6ab5:	e8 c5 db ff ff       	call   467f <ensureBits9>
    6aba:	83 c4 08             	add    $0x8,%esp
    6abd:	85 c0                	test   %eax,%eax
    6abf:	75 0a                	jne    6acb <lodepng_inflatev+0x50>
    6ac1:	b8 34 00 00 00       	mov    $0x34,%eax
    6ac6:	e9 a5 00 00 00       	jmp    6b70 <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    6acb:	6a 01                	push   $0x1
    6acd:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6ad0:	50                   	push   %eax
    6ad1:	e8 61 e1 ff ff       	call   4c37 <readBits>
    6ad6:	83 c4 08             	add    $0x8,%esp
    6ad9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    6adc:	6a 02                	push   $0x2
    6ade:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6ae1:	50                   	push   %eax
    6ae2:	e8 50 e1 ff ff       	call   4c37 <readBits>
    6ae7:	83 c4 08             	add    $0x8,%esp
    6aea:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    6aed:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    6af1:	75 07                	jne    6afa <lodepng_inflatev+0x7f>
    6af3:	b8 14 00 00 00       	mov    $0x14,%eax
    6af8:	eb 76                	jmp    6b70 <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    6afa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    6afe:	75 17                	jne    6b17 <lodepng_inflatev+0x9c>
    6b00:	ff 75 14             	pushl  0x14(%ebp)
    6b03:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6b06:	50                   	push   %eax
    6b07:	ff 75 08             	pushl  0x8(%ebp)
    6b0a:	e8 2b fe ff ff       	call   693a <inflateNoCompression>
    6b0f:	83 c4 0c             	add    $0xc,%esp
    6b12:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6b15:	eb 1c                	jmp    6b33 <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    6b17:	8b 45 14             	mov    0x14(%ebp),%eax
    6b1a:	8b 40 08             	mov    0x8(%eax),%eax
    6b1d:	50                   	push   %eax
    6b1e:	ff 75 ec             	pushl  -0x14(%ebp)
    6b21:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6b24:	50                   	push   %eax
    6b25:	ff 75 08             	pushl  0x8(%ebp)
    6b28:	e8 f9 fa ff ff       	call   6626 <inflateHuffmanBlock>
    6b2d:	83 c4 10             	add    $0x10,%esp
    6b30:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6b33:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6b37:	75 21                	jne    6b5a <lodepng_inflatev+0xdf>
    6b39:	8b 45 14             	mov    0x14(%ebp),%eax
    6b3c:	8b 40 08             	mov    0x8(%eax),%eax
    6b3f:	85 c0                	test   %eax,%eax
    6b41:	74 17                	je     6b5a <lodepng_inflatev+0xdf>
    6b43:	8b 45 08             	mov    0x8(%ebp),%eax
    6b46:	8b 50 04             	mov    0x4(%eax),%edx
    6b49:	8b 45 14             	mov    0x14(%ebp),%eax
    6b4c:	8b 40 08             	mov    0x8(%eax),%eax
    6b4f:	39 c2                	cmp    %eax,%edx
    6b51:	7e 07                	jle    6b5a <lodepng_inflatev+0xdf>
    6b53:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    6b5a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6b5e:	75 0c                	jne    6b6c <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    6b60:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6b64:	0f 84 45 ff ff ff    	je     6aaf <lodepng_inflatev+0x34>
    6b6a:	eb 01                	jmp    6b6d <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    6b6c:	90                   	nop
  }

  return error;
    6b6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    6b70:	c9                   	leave  
    6b71:	c3                   	ret    

00006b72 <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    6b72:	55                   	push   %ebp
    6b73:	89 e5                	mov    %esp,%ebp
    6b75:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    6b78:	8b 45 0c             	mov    0xc(%ebp),%eax
    6b7b:	8b 08                	mov    (%eax),%ecx
    6b7d:	8b 45 08             	mov    0x8(%ebp),%eax
    6b80:	8b 10                	mov    (%eax),%edx
    6b82:	8d 45 e8             	lea    -0x18(%ebp),%eax
    6b85:	51                   	push   %ecx
    6b86:	52                   	push   %edx
    6b87:	50                   	push   %eax
    6b88:	e8 df d5 ff ff       	call   416c <ucvector_init>
    6b8d:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    6b90:	ff 75 18             	pushl  0x18(%ebp)
    6b93:	ff 75 14             	pushl  0x14(%ebp)
    6b96:	ff 75 10             	pushl  0x10(%ebp)
    6b99:	8d 45 e8             	lea    -0x18(%ebp),%eax
    6b9c:	50                   	push   %eax
    6b9d:	e8 d9 fe ff ff       	call   6a7b <lodepng_inflatev>
    6ba2:	83 c4 10             	add    $0x10,%esp
    6ba5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    6ba8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6bab:	8b 45 08             	mov    0x8(%ebp),%eax
    6bae:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    6bb0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6bb3:	8b 45 0c             	mov    0xc(%ebp),%eax
    6bb6:	89 10                	mov    %edx,(%eax)
  return error;
    6bb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6bbb:	c9                   	leave  
    6bbc:	c3                   	ret    

00006bbd <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    6bbd:	55                   	push   %ebp
    6bbe:	89 e5                	mov    %esp,%ebp
    6bc0:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    6bc3:	8b 45 14             	mov    0x14(%ebp),%eax
    6bc6:	8b 40 10             	mov    0x10(%eax),%eax
    6bc9:	85 c0                	test   %eax,%eax
    6bcb:	74 64                	je     6c31 <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    6bcd:	8b 45 14             	mov    0x14(%ebp),%eax
    6bd0:	8b 40 10             	mov    0x10(%eax),%eax
    6bd3:	8b 55 08             	mov    0x8(%ebp),%edx
    6bd6:	8d 4a 04             	lea    0x4(%edx),%ecx
    6bd9:	8b 55 08             	mov    0x8(%ebp),%edx
    6bdc:	83 ec 0c             	sub    $0xc,%esp
    6bdf:	ff 75 14             	pushl  0x14(%ebp)
    6be2:	ff 75 10             	pushl  0x10(%ebp)
    6be5:	ff 75 0c             	pushl  0xc(%ebp)
    6be8:	51                   	push   %ecx
    6be9:	52                   	push   %edx
    6bea:	ff d0                	call   *%eax
    6bec:	83 c4 20             	add    $0x20,%esp
    6bef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    6bf2:	8b 45 08             	mov    0x8(%ebp),%eax
    6bf5:	8b 50 04             	mov    0x4(%eax),%edx
    6bf8:	8b 45 08             	mov    0x8(%ebp),%eax
    6bfb:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    6bfe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6c02:	74 28                	je     6c2c <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    6c04:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6c0b:	8b 45 14             	mov    0x14(%ebp),%eax
    6c0e:	8b 40 08             	mov    0x8(%eax),%eax
    6c11:	85 c0                	test   %eax,%eax
    6c13:	74 17                	je     6c2c <inflatev+0x6f>
    6c15:	8b 45 08             	mov    0x8(%ebp),%eax
    6c18:	8b 50 04             	mov    0x4(%eax),%edx
    6c1b:	8b 45 14             	mov    0x14(%ebp),%eax
    6c1e:	8b 40 08             	mov    0x8(%eax),%eax
    6c21:	39 c2                	cmp    %eax,%edx
    6c23:	7e 07                	jle    6c2c <inflatev+0x6f>
    6c25:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    6c2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6c2f:	eb 14                	jmp    6c45 <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    6c31:	ff 75 14             	pushl  0x14(%ebp)
    6c34:	ff 75 10             	pushl  0x10(%ebp)
    6c37:	ff 75 0c             	pushl  0xc(%ebp)
    6c3a:	ff 75 08             	pushl  0x8(%ebp)
    6c3d:	e8 39 fe ff ff       	call   6a7b <lodepng_inflatev>
    6c42:	83 c4 10             	add    $0x10,%esp
  }
}
    6c45:	c9                   	leave  
    6c46:	c3                   	ret    

00006c47 <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    6c47:	55                   	push   %ebp
    6c48:	89 e5                	mov    %esp,%ebp
    6c4a:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    6c4d:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    6c54:	8b 45 0c             	mov    0xc(%ebp),%eax
    6c57:	83 e8 01             	sub    $0x1,%eax
    6c5a:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    6c5d:	eb 39                	jmp    6c98 <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    6c5f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6c62:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6c65:	01 d0                	add    %edx,%eax
    6c67:	d1 f8                	sar    %eax
    6c69:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    6c6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6c6f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6c76:	8b 45 08             	mov    0x8(%ebp),%eax
    6c79:	01 d0                	add    %edx,%eax
    6c7b:	8b 10                	mov    (%eax),%edx
    6c7d:	8b 45 10             	mov    0x10(%ebp),%eax
    6c80:	39 c2                	cmp    %eax,%edx
    6c82:	72 0b                	jb     6c8f <searchCodeIndex+0x48>
    6c84:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6c87:	83 e8 01             	sub    $0x1,%eax
    6c8a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    6c8d:	eb 09                	jmp    6c98 <searchCodeIndex+0x51>
    else left = mid + 1;
    6c8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6c92:	83 c0 01             	add    $0x1,%eax
    6c95:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    6c98:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6c9b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6c9e:	7e bf                	jle    6c5f <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    6ca0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6ca3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6ca6:	7d 18                	jge    6cc0 <searchCodeIndex+0x79>
    6ca8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6cab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6cb2:	8b 45 08             	mov    0x8(%ebp),%eax
    6cb5:	01 d0                	add    %edx,%eax
    6cb7:	8b 10                	mov    (%eax),%edx
    6cb9:	8b 45 10             	mov    0x10(%ebp),%eax
    6cbc:	39 c2                	cmp    %eax,%edx
    6cbe:	76 04                	jbe    6cc4 <searchCodeIndex+0x7d>
    6cc0:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    6cc4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    6cc7:	c9                   	leave  
    6cc8:	c3                   	ret    

00006cc9 <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    6cc9:	55                   	push   %ebp
    6cca:	89 e5                	mov    %esp,%ebp
    6ccc:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    6ccf:	ff 75 0c             	pushl  0xc(%ebp)
    6cd2:	6a 1d                	push   $0x1d
    6cd4:	68 80 a9 01 00       	push   $0x1a980
    6cd9:	e8 69 ff ff ff       	call   6c47 <searchCodeIndex>
    6cde:	83 c4 0c             	add    $0xc,%esp
    6ce1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    6ce4:	8b 55 0c             	mov    0xc(%ebp),%edx
    6ce7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6cea:	8b 04 85 80 a9 01 00 	mov    0x1a980(,%eax,4),%eax
    6cf1:	29 c2                	sub    %eax,%edx
    6cf3:	89 d0                	mov    %edx,%eax
    6cf5:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    6cf8:	ff 75 10             	pushl  0x10(%ebp)
    6cfb:	6a 1e                	push   $0x1e
    6cfd:	68 80 aa 01 00       	push   $0x1aa80
    6d02:	e8 40 ff ff ff       	call   6c47 <searchCodeIndex>
    6d07:	83 c4 0c             	add    $0xc,%esp
    6d0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    6d0d:	8b 55 10             	mov    0x10(%ebp),%edx
    6d10:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6d13:	8b 04 85 80 aa 01 00 	mov    0x1aa80(,%eax,4),%eax
    6d1a:	29 c2                	sub    %eax,%edx
    6d1c:	89 d0                	mov    %edx,%eax
    6d1e:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    6d21:	8b 45 08             	mov    0x8(%ebp),%eax
    6d24:	8b 40 04             	mov    0x4(%eax),%eax
    6d27:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    6d2a:	8b 45 08             	mov    0x8(%ebp),%eax
    6d2d:	8b 40 04             	mov    0x4(%eax),%eax
    6d30:	83 c0 04             	add    $0x4,%eax
    6d33:	50                   	push   %eax
    6d34:	ff 75 08             	pushl  0x8(%ebp)
    6d37:	e8 f0 d2 ff ff       	call   402c <uivector_resize>
    6d3c:	83 c4 08             	add    $0x8,%esp
    6d3f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    6d42:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    6d46:	74 57                	je     6d9f <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    6d48:	8b 45 08             	mov    0x8(%ebp),%eax
    6d4b:	8b 00                	mov    (%eax),%eax
    6d4d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6d50:	c1 e2 02             	shl    $0x2,%edx
    6d53:	01 d0                	add    %edx,%eax
    6d55:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d58:	81 c2 01 01 00 00    	add    $0x101,%edx
    6d5e:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    6d60:	8b 45 08             	mov    0x8(%ebp),%eax
    6d63:	8b 00                	mov    (%eax),%eax
    6d65:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6d68:	83 c2 01             	add    $0x1,%edx
    6d6b:	c1 e2 02             	shl    $0x2,%edx
    6d6e:	01 c2                	add    %eax,%edx
    6d70:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6d73:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    6d75:	8b 45 08             	mov    0x8(%ebp),%eax
    6d78:	8b 00                	mov    (%eax),%eax
    6d7a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6d7d:	83 c2 02             	add    $0x2,%edx
    6d80:	c1 e2 02             	shl    $0x2,%edx
    6d83:	01 c2                	add    %eax,%edx
    6d85:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6d88:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    6d8a:	8b 45 08             	mov    0x8(%ebp),%eax
    6d8d:	8b 00                	mov    (%eax),%eax
    6d8f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6d92:	83 c2 03             	add    $0x3,%edx
    6d95:	c1 e2 02             	shl    $0x2,%edx
    6d98:	01 c2                	add    %eax,%edx
    6d9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6d9d:	89 02                	mov    %eax,(%edx)
  }
}
    6d9f:	90                   	nop
    6da0:	c9                   	leave  
    6da1:	c3                   	ret    

00006da2 <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    6da2:	55                   	push   %ebp
    6da3:	89 e5                	mov    %esp,%ebp
    6da5:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    6da8:	b8 00 00 01 00       	mov    $0x10000,%eax
    6dad:	c1 e0 02             	shl    $0x2,%eax
    6db0:	83 ec 0c             	sub    $0xc,%esp
    6db3:	50                   	push   %eax
    6db4:	e8 f2 d0 ff ff       	call   3eab <lodepng_malloc>
    6db9:	83 c4 10             	add    $0x10,%esp
    6dbc:	89 c2                	mov    %eax,%edx
    6dbe:	8b 45 08             	mov    0x8(%ebp),%eax
    6dc1:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    6dc3:	8b 45 0c             	mov    0xc(%ebp),%eax
    6dc6:	c1 e0 02             	shl    $0x2,%eax
    6dc9:	83 ec 0c             	sub    $0xc,%esp
    6dcc:	50                   	push   %eax
    6dcd:	e8 d9 d0 ff ff       	call   3eab <lodepng_malloc>
    6dd2:	83 c4 10             	add    $0x10,%esp
    6dd5:	89 c2                	mov    %eax,%edx
    6dd7:	8b 45 08             	mov    0x8(%ebp),%eax
    6dda:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6ddd:	8b 45 0c             	mov    0xc(%ebp),%eax
    6de0:	01 c0                	add    %eax,%eax
    6de2:	83 ec 0c             	sub    $0xc,%esp
    6de5:	50                   	push   %eax
    6de6:	e8 c0 d0 ff ff       	call   3eab <lodepng_malloc>
    6deb:	83 c4 10             	add    $0x10,%esp
    6dee:	89 c2                	mov    %eax,%edx
    6df0:	8b 45 08             	mov    0x8(%ebp),%eax
    6df3:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6df6:	8b 45 0c             	mov    0xc(%ebp),%eax
    6df9:	01 c0                	add    %eax,%eax
    6dfb:	83 ec 0c             	sub    $0xc,%esp
    6dfe:	50                   	push   %eax
    6dff:	e8 a7 d0 ff ff       	call   3eab <lodepng_malloc>
    6e04:	83 c4 10             	add    $0x10,%esp
    6e07:	89 c2                	mov    %eax,%edx
    6e09:	8b 45 08             	mov    0x8(%ebp),%eax
    6e0c:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    6e0f:	b8 02 01 00 00       	mov    $0x102,%eax
    6e14:	83 c0 01             	add    $0x1,%eax
    6e17:	c1 e0 02             	shl    $0x2,%eax
    6e1a:	83 ec 0c             	sub    $0xc,%esp
    6e1d:	50                   	push   %eax
    6e1e:	e8 88 d0 ff ff       	call   3eab <lodepng_malloc>
    6e23:	83 c4 10             	add    $0x10,%esp
    6e26:	89 c2                	mov    %eax,%edx
    6e28:	8b 45 08             	mov    0x8(%ebp),%eax
    6e2b:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6e2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e31:	01 c0                	add    %eax,%eax
    6e33:	83 ec 0c             	sub    $0xc,%esp
    6e36:	50                   	push   %eax
    6e37:	e8 6f d0 ff ff       	call   3eab <lodepng_malloc>
    6e3c:	83 c4 10             	add    $0x10,%esp
    6e3f:	89 c2                	mov    %eax,%edx
    6e41:	8b 45 08             	mov    0x8(%ebp),%eax
    6e44:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    6e47:	8b 45 08             	mov    0x8(%ebp),%eax
    6e4a:	8b 00                	mov    (%eax),%eax
    6e4c:	85 c0                	test   %eax,%eax
    6e4e:	74 32                	je     6e82 <hash_init+0xe0>
    6e50:	8b 45 08             	mov    0x8(%ebp),%eax
    6e53:	8b 40 04             	mov    0x4(%eax),%eax
    6e56:	85 c0                	test   %eax,%eax
    6e58:	74 28                	je     6e82 <hash_init+0xe0>
    6e5a:	8b 45 08             	mov    0x8(%ebp),%eax
    6e5d:	8b 40 08             	mov    0x8(%eax),%eax
    6e60:	85 c0                	test   %eax,%eax
    6e62:	74 1e                	je     6e82 <hash_init+0xe0>
    6e64:	8b 45 08             	mov    0x8(%ebp),%eax
    6e67:	8b 40 0c             	mov    0xc(%eax),%eax
    6e6a:	85 c0                	test   %eax,%eax
    6e6c:	74 14                	je     6e82 <hash_init+0xe0>
    6e6e:	8b 45 08             	mov    0x8(%ebp),%eax
    6e71:	8b 40 10             	mov    0x10(%eax),%eax
    6e74:	85 c0                	test   %eax,%eax
    6e76:	74 0a                	je     6e82 <hash_init+0xe0>
    6e78:	8b 45 08             	mov    0x8(%ebp),%eax
    6e7b:	8b 40 14             	mov    0x14(%eax),%eax
    6e7e:	85 c0                	test   %eax,%eax
    6e80:	75 0a                	jne    6e8c <hash_init+0xea>
    return 83; /*alloc fail*/
    6e82:	b8 53 00 00 00       	mov    $0x53,%eax
    6e87:	e9 d3 00 00 00       	jmp    6f5f <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    6e8c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6e93:	eb 17                	jmp    6eac <hash_init+0x10a>
    6e95:	8b 45 08             	mov    0x8(%ebp),%eax
    6e98:	8b 00                	mov    (%eax),%eax
    6e9a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6e9d:	c1 e2 02             	shl    $0x2,%edx
    6ea0:	01 d0                	add    %edx,%eax
    6ea2:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6ea8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6eac:	b8 00 00 01 00       	mov    $0x10000,%eax
    6eb1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    6eb4:	75 df                	jne    6e95 <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    6eb6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6ebd:	eb 18                	jmp    6ed7 <hash_init+0x135>
    6ebf:	8b 45 08             	mov    0x8(%ebp),%eax
    6ec2:	8b 40 08             	mov    0x8(%eax),%eax
    6ec5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6ec8:	c1 e2 02             	shl    $0x2,%edx
    6ecb:	01 d0                	add    %edx,%eax
    6ecd:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6ed3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6ed7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6eda:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6edd:	75 e0                	jne    6ebf <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    6edf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6ee6:	eb 17                	jmp    6eff <hash_init+0x15d>
    6ee8:	8b 45 08             	mov    0x8(%ebp),%eax
    6eeb:	8b 40 04             	mov    0x4(%eax),%eax
    6eee:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6ef1:	01 d2                	add    %edx,%edx
    6ef3:	01 d0                	add    %edx,%eax
    6ef5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6ef8:	66 89 10             	mov    %dx,(%eax)
    6efb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6eff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6f02:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6f05:	75 e1                	jne    6ee8 <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    6f07:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6f0e:	eb 18                	jmp    6f28 <hash_init+0x186>
    6f10:	8b 45 08             	mov    0x8(%ebp),%eax
    6f13:	8b 40 0c             	mov    0xc(%eax),%eax
    6f16:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6f19:	c1 e2 02             	shl    $0x2,%edx
    6f1c:	01 d0                	add    %edx,%eax
    6f1e:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6f24:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6f28:	b8 02 01 00 00       	mov    $0x102,%eax
    6f2d:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    6f30:	76 de                	jbe    6f10 <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    6f32:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6f39:	eb 17                	jmp    6f52 <hash_init+0x1b0>
    6f3b:	8b 45 08             	mov    0x8(%ebp),%eax
    6f3e:	8b 40 10             	mov    0x10(%eax),%eax
    6f41:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6f44:	01 d2                	add    %edx,%edx
    6f46:	01 d0                	add    %edx,%eax
    6f48:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6f4b:	66 89 10             	mov    %dx,(%eax)
    6f4e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6f52:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6f55:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6f58:	75 e1                	jne    6f3b <hash_init+0x199>

  return 0;
    6f5a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6f5f:	c9                   	leave  
    6f60:	c3                   	ret    

00006f61 <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    6f61:	55                   	push   %ebp
    6f62:	89 e5                	mov    %esp,%ebp
    6f64:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    6f67:	8b 45 08             	mov    0x8(%ebp),%eax
    6f6a:	8b 00                	mov    (%eax),%eax
    6f6c:	83 ec 0c             	sub    $0xc,%esp
    6f6f:	50                   	push   %eax
    6f70:	e8 57 cf ff ff       	call   3ecc <lodepng_free>
    6f75:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    6f78:	8b 45 08             	mov    0x8(%ebp),%eax
    6f7b:	8b 40 08             	mov    0x8(%eax),%eax
    6f7e:	83 ec 0c             	sub    $0xc,%esp
    6f81:	50                   	push   %eax
    6f82:	e8 45 cf ff ff       	call   3ecc <lodepng_free>
    6f87:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    6f8a:	8b 45 08             	mov    0x8(%ebp),%eax
    6f8d:	8b 40 04             	mov    0x4(%eax),%eax
    6f90:	83 ec 0c             	sub    $0xc,%esp
    6f93:	50                   	push   %eax
    6f94:	e8 33 cf ff ff       	call   3ecc <lodepng_free>
    6f99:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    6f9c:	8b 45 08             	mov    0x8(%ebp),%eax
    6f9f:	8b 40 14             	mov    0x14(%eax),%eax
    6fa2:	83 ec 0c             	sub    $0xc,%esp
    6fa5:	50                   	push   %eax
    6fa6:	e8 21 cf ff ff       	call   3ecc <lodepng_free>
    6fab:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    6fae:	8b 45 08             	mov    0x8(%ebp),%eax
    6fb1:	8b 40 0c             	mov    0xc(%eax),%eax
    6fb4:	83 ec 0c             	sub    $0xc,%esp
    6fb7:	50                   	push   %eax
    6fb8:	e8 0f cf ff ff       	call   3ecc <lodepng_free>
    6fbd:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    6fc0:	8b 45 08             	mov    0x8(%ebp),%eax
    6fc3:	8b 40 10             	mov    0x10(%eax),%eax
    6fc6:	83 ec 0c             	sub    $0xc,%esp
    6fc9:	50                   	push   %eax
    6fca:	e8 fd ce ff ff       	call   3ecc <lodepng_free>
    6fcf:	83 c4 10             	add    $0x10,%esp
}
    6fd2:	90                   	nop
    6fd3:	c9                   	leave  
    6fd4:	c3                   	ret    

00006fd5 <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    6fd5:	55                   	push   %ebp
    6fd6:	89 e5                	mov    %esp,%ebp
    6fd8:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    6fdb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    6fe2:	8b 45 10             	mov    0x10(%ebp),%eax
    6fe5:	83 c0 02             	add    $0x2,%eax
    6fe8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6feb:	7d 41                	jge    702e <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    6fed:	8b 55 10             	mov    0x10(%ebp),%edx
    6ff0:	8b 45 08             	mov    0x8(%ebp),%eax
    6ff3:	01 d0                	add    %edx,%eax
    6ff5:	0f b6 00             	movzbl (%eax),%eax
    6ff8:	0f b6 c0             	movzbl %al,%eax
    6ffb:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    6ffe:	8b 45 10             	mov    0x10(%ebp),%eax
    7001:	8d 50 01             	lea    0x1(%eax),%edx
    7004:	8b 45 08             	mov    0x8(%ebp),%eax
    7007:	01 d0                	add    %edx,%eax
    7009:	0f b6 00             	movzbl (%eax),%eax
    700c:	0f b6 c0             	movzbl %al,%eax
    700f:	c1 e0 04             	shl    $0x4,%eax
    7012:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    7015:	8b 45 10             	mov    0x10(%ebp),%eax
    7018:	8d 50 02             	lea    0x2(%eax),%edx
    701b:	8b 45 08             	mov    0x8(%ebp),%eax
    701e:	01 d0                	add    %edx,%eax
    7020:	0f b6 00             	movzbl (%eax),%eax
    7023:	0f b6 c0             	movzbl %al,%eax
    7026:	c1 e0 08             	shl    $0x8,%eax
    7029:	31 45 fc             	xor    %eax,-0x4(%ebp)
    702c:	eb 51                	jmp    707f <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    702e:	8b 45 10             	mov    0x10(%ebp),%eax
    7031:	3b 45 0c             	cmp    0xc(%ebp),%eax
    7034:	7c 07                	jl     703d <getHash+0x68>
    7036:	b8 00 00 00 00       	mov    $0x0,%eax
    703b:	eb 4a                	jmp    7087 <getHash+0xb2>
    amount = size - pos;
    703d:	8b 45 0c             	mov    0xc(%ebp),%eax
    7040:	2b 45 10             	sub    0x10(%ebp),%eax
    7043:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    7046:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    704d:	eb 28                	jmp    7077 <getHash+0xa2>
    704f:	8b 55 10             	mov    0x10(%ebp),%edx
    7052:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7055:	01 d0                	add    %edx,%eax
    7057:	89 c2                	mov    %eax,%edx
    7059:	8b 45 08             	mov    0x8(%ebp),%eax
    705c:	01 d0                	add    %edx,%eax
    705e:	0f b6 00             	movzbl (%eax),%eax
    7061:	0f b6 d0             	movzbl %al,%edx
    7064:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7067:	c1 e0 03             	shl    $0x3,%eax
    706a:	89 c1                	mov    %eax,%ecx
    706c:	d3 e2                	shl    %cl,%edx
    706e:	89 d0                	mov    %edx,%eax
    7070:	31 45 fc             	xor    %eax,-0x4(%ebp)
    7073:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    7077:	8b 45 f8             	mov    -0x8(%ebp),%eax
    707a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    707d:	75 d0                	jne    704f <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    707f:	b8 ff ff 00 00       	mov    $0xffff,%eax
    7084:	23 45 fc             	and    -0x4(%ebp),%eax
}
    7087:	c9                   	leave  
    7088:	c3                   	ret    

00007089 <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    7089:	55                   	push   %ebp
    708a:	89 e5                	mov    %esp,%ebp
    708c:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    708f:	8b 55 10             	mov    0x10(%ebp),%edx
    7092:	8b 45 08             	mov    0x8(%ebp),%eax
    7095:	01 d0                	add    %edx,%eax
    7097:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    709a:	b8 02 01 00 00       	mov    $0x102,%eax
    709f:	89 c2                	mov    %eax,%edx
    70a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    70a4:	01 d0                	add    %edx,%eax
    70a6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    70a9:	8b 55 0c             	mov    0xc(%ebp),%edx
    70ac:	8b 45 08             	mov    0x8(%ebp),%eax
    70af:	01 d0                	add    %edx,%eax
    70b1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    70b4:	73 0b                	jae    70c1 <countZeros+0x38>
    70b6:	8b 55 0c             	mov    0xc(%ebp),%edx
    70b9:	8b 45 08             	mov    0x8(%ebp),%eax
    70bc:	01 d0                	add    %edx,%eax
    70be:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    70c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    70c4:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    70c7:	eb 04                	jmp    70cd <countZeros+0x44>
    70c9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    70cd:	8b 45 08             	mov    0x8(%ebp),%eax
    70d0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    70d3:	74 0a                	je     70df <countZeros+0x56>
    70d5:	8b 45 08             	mov    0x8(%ebp),%eax
    70d8:	0f b6 00             	movzbl (%eax),%eax
    70db:	84 c0                	test   %al,%al
    70dd:	74 ea                	je     70c9 <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    70df:	8b 55 08             	mov    0x8(%ebp),%edx
    70e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    70e5:	29 c2                	sub    %eax,%edx
    70e7:	89 d0                	mov    %edx,%eax
}
    70e9:	c9                   	leave  
    70ea:	c3                   	ret    

000070eb <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    70eb:	55                   	push   %ebp
    70ec:	89 e5                	mov    %esp,%ebp
    70ee:	83 ec 04             	sub    $0x4,%esp
    70f1:	8b 45 14             	mov    0x14(%ebp),%eax
    70f4:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    70f8:	8b 45 08             	mov    0x8(%ebp),%eax
    70fb:	8b 40 08             	mov    0x8(%eax),%eax
    70fe:	8b 55 0c             	mov    0xc(%ebp),%edx
    7101:	c1 e2 02             	shl    $0x2,%edx
    7104:	01 c2                	add    %eax,%edx
    7106:	8b 45 10             	mov    0x10(%ebp),%eax
    7109:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    710b:	8b 45 08             	mov    0x8(%ebp),%eax
    710e:	8b 00                	mov    (%eax),%eax
    7110:	8b 55 10             	mov    0x10(%ebp),%edx
    7113:	c1 e2 02             	shl    $0x2,%edx
    7116:	01 d0                	add    %edx,%eax
    7118:	8b 00                	mov    (%eax),%eax
    711a:	83 f8 ff             	cmp    $0xffffffff,%eax
    711d:	74 1f                	je     713e <updateHashChain+0x53>
    711f:	8b 45 08             	mov    0x8(%ebp),%eax
    7122:	8b 40 04             	mov    0x4(%eax),%eax
    7125:	8b 55 0c             	mov    0xc(%ebp),%edx
    7128:	01 d2                	add    %edx,%edx
    712a:	01 c2                	add    %eax,%edx
    712c:	8b 45 08             	mov    0x8(%ebp),%eax
    712f:	8b 00                	mov    (%eax),%eax
    7131:	8b 4d 10             	mov    0x10(%ebp),%ecx
    7134:	c1 e1 02             	shl    $0x2,%ecx
    7137:	01 c8                	add    %ecx,%eax
    7139:	8b 00                	mov    (%eax),%eax
    713b:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    713e:	8b 45 08             	mov    0x8(%ebp),%eax
    7141:	8b 00                	mov    (%eax),%eax
    7143:	8b 55 10             	mov    0x10(%ebp),%edx
    7146:	c1 e2 02             	shl    $0x2,%edx
    7149:	01 c2                	add    %eax,%edx
    714b:	8b 45 0c             	mov    0xc(%ebp),%eax
    714e:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    7150:	8b 45 08             	mov    0x8(%ebp),%eax
    7153:	8b 40 14             	mov    0x14(%eax),%eax
    7156:	8b 55 0c             	mov    0xc(%ebp),%edx
    7159:	01 d2                	add    %edx,%edx
    715b:	01 c2                	add    %eax,%edx
    715d:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    7161:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    7164:	8b 45 08             	mov    0x8(%ebp),%eax
    7167:	8b 40 0c             	mov    0xc(%eax),%eax
    716a:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    716e:	c1 e2 02             	shl    $0x2,%edx
    7171:	01 d0                	add    %edx,%eax
    7173:	8b 00                	mov    (%eax),%eax
    7175:	83 f8 ff             	cmp    $0xffffffff,%eax
    7178:	74 21                	je     719b <updateHashChain+0xb0>
    717a:	8b 45 08             	mov    0x8(%ebp),%eax
    717d:	8b 40 10             	mov    0x10(%eax),%eax
    7180:	8b 55 0c             	mov    0xc(%ebp),%edx
    7183:	01 d2                	add    %edx,%edx
    7185:	01 c2                	add    %eax,%edx
    7187:	8b 45 08             	mov    0x8(%ebp),%eax
    718a:	8b 40 0c             	mov    0xc(%eax),%eax
    718d:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    7191:	c1 e1 02             	shl    $0x2,%ecx
    7194:	01 c8                	add    %ecx,%eax
    7196:	8b 00                	mov    (%eax),%eax
    7198:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    719b:	8b 45 08             	mov    0x8(%ebp),%eax
    719e:	8b 40 0c             	mov    0xc(%eax),%eax
    71a1:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    71a5:	c1 e2 02             	shl    $0x2,%edx
    71a8:	01 c2                	add    %eax,%edx
    71aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    71ad:	89 02                	mov    %eax,(%edx)
}
    71af:	90                   	nop
    71b0:	c9                   	leave  
    71b1:	c3                   	ret    

000071b2 <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    71b2:	55                   	push   %ebp
    71b3:	89 e5                	mov    %esp,%ebp
    71b5:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    71b8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    71bf:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    71c6:	77 08                	ja     71d0 <encodeLZ77+0x1e>
    71c8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    71cb:	c1 e8 03             	shr    $0x3,%eax
    71ce:	eb 03                	jmp    71d3 <encodeLZ77+0x21>
    71d0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    71d3:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    71d6:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    71dd:	76 07                	jbe    71e6 <encodeLZ77+0x34>
    71df:	b8 02 01 00 00       	mov    $0x102,%eax
    71e4:	eb 05                	jmp    71eb <encodeLZ77+0x39>
    71e6:	b8 40 00 00 00       	mov    $0x40,%eax
    71eb:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    71ee:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    71f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    71fc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    7203:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    720a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    7211:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    7215:	74 09                	je     7220 <encodeLZ77+0x6e>
    7217:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    721e:	76 0a                	jbe    722a <encodeLZ77+0x78>
    7220:	b8 3c 00 00 00       	mov    $0x3c,%eax
    7225:	e9 e3 04 00 00       	jmp    770d <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    722a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    722d:	83 e8 01             	sub    $0x1,%eax
    7230:	23 45 1c             	and    0x1c(%ebp),%eax
    7233:	85 c0                	test   %eax,%eax
    7235:	74 0a                	je     7241 <encodeLZ77+0x8f>
    7237:	b8 5a 00 00 00       	mov    $0x5a,%eax
    723c:	e9 cc 04 00 00       	jmp    770d <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    7241:	b8 02 01 00 00       	mov    $0x102,%eax
    7246:	39 45 24             	cmp    %eax,0x24(%ebp)
    7249:	76 08                	jbe    7253 <encodeLZ77+0xa1>
    724b:	b8 02 01 00 00       	mov    $0x102,%eax
    7250:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    7253:	8b 45 14             	mov    0x14(%ebp),%eax
    7256:	89 45 fc             	mov    %eax,-0x4(%ebp)
    7259:	e9 a0 04 00 00       	jmp    76fe <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    725e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7261:	8d 50 ff             	lea    -0x1(%eax),%edx
    7264:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7267:	21 d0                	and    %edx,%eax
    7269:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    726c:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    7273:	ff 75 fc             	pushl  -0x4(%ebp)
    7276:	ff 75 18             	pushl  0x18(%ebp)
    7279:	ff 75 10             	pushl  0x10(%ebp)
    727c:	e8 54 fd ff ff       	call   6fd5 <getHash>
    7281:	83 c4 0c             	add    $0xc,%esp
    7284:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    7287:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    728b:	74 4e                	je     72db <encodeLZ77+0x129>
    728d:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    7291:	75 48                	jne    72db <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    7293:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7297:	75 16                	jne    72af <encodeLZ77+0xfd>
    7299:	ff 75 fc             	pushl  -0x4(%ebp)
    729c:	ff 75 18             	pushl  0x18(%ebp)
    729f:	ff 75 10             	pushl  0x10(%ebp)
    72a2:	e8 e2 fd ff ff       	call   7089 <countZeros>
    72a7:	83 c4 0c             	add    $0xc,%esp
    72aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
    72ad:	eb 35                	jmp    72e4 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    72af:	8b 55 fc             	mov    -0x4(%ebp),%edx
    72b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    72b5:	01 c2                	add    %eax,%edx
    72b7:	8b 45 18             	mov    0x18(%ebp),%eax
    72ba:	39 c2                	cmp    %eax,%edx
    72bc:	77 17                	ja     72d5 <encodeLZ77+0x123>
    72be:	8b 55 fc             	mov    -0x4(%ebp),%edx
    72c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    72c4:	01 d0                	add    %edx,%eax
    72c6:	8d 50 ff             	lea    -0x1(%eax),%edx
    72c9:	8b 45 10             	mov    0x10(%ebp),%eax
    72cc:	01 d0                	add    %edx,%eax
    72ce:	0f b6 00             	movzbl (%eax),%eax
    72d1:	84 c0                	test   %al,%al
    72d3:	74 0f                	je     72e4 <encodeLZ77+0x132>
    72d5:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    72d9:	eb 09                	jmp    72e4 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    72db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    72e2:	eb 01                	jmp    72e5 <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    72e4:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    72e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    72e8:	0f b7 c0             	movzwl %ax,%eax
    72eb:	50                   	push   %eax
    72ec:	ff 75 b0             	pushl  -0x50(%ebp)
    72ef:	ff 75 b4             	pushl  -0x4c(%ebp)
    72f2:	ff 75 0c             	pushl  0xc(%ebp)
    72f5:	e8 f1 fd ff ff       	call   70eb <updateHashChain>
    72fa:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    72fd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    7304:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    730b:	8b 45 0c             	mov    0xc(%ebp),%eax
    730e:	8b 40 04             	mov    0x4(%eax),%eax
    7311:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    7314:	01 d2                	add    %edx,%edx
    7316:	01 d0                	add    %edx,%eax
    7318:	0f b7 00             	movzwl (%eax),%eax
    731b:	0f b7 c0             	movzwl %ax,%eax
    731e:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    7321:	ba 02 01 00 00       	mov    $0x102,%edx
    7326:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7329:	01 c2                	add    %eax,%edx
    732b:	8b 45 18             	mov    0x18(%ebp),%eax
    732e:	39 c2                	cmp    %eax,%edx
    7330:	0f 4e c2             	cmovle %edx,%eax
    7333:	89 c2                	mov    %eax,%edx
    7335:	8b 45 10             	mov    0x10(%ebp),%eax
    7338:	01 d0                	add    %edx,%eax
    733a:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    733d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    7344:	8b 45 c8             	mov    -0x38(%ebp),%eax
    7347:	8d 50 01             	lea    0x1(%eax),%edx
    734a:	89 55 c8             	mov    %edx,-0x38(%ebp)
    734d:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    7350:	0f 83 67 01 00 00    	jae    74bd <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    7356:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7359:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    735c:	77 08                	ja     7366 <encodeLZ77+0x1b4>
    735e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7361:	2b 45 cc             	sub    -0x34(%ebp),%eax
    7364:	eb 0d                	jmp    7373 <encodeLZ77+0x1c1>
    7366:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7369:	2b 45 cc             	sub    -0x34(%ebp),%eax
    736c:	89 c2                	mov    %eax,%edx
    736e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7371:	01 d0                	add    %edx,%eax
    7373:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    7376:	8b 45 a8             	mov    -0x58(%ebp),%eax
    7379:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    737c:	0f 82 3e 01 00 00    	jb     74c0 <encodeLZ77+0x30e>
      prev_offset = current_offset;
    7382:	8b 45 a8             	mov    -0x58(%ebp),%eax
    7385:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    7388:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    738c:	0f 84 a3 00 00 00    	je     7435 <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    7392:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7395:	8b 45 10             	mov    0x10(%ebp),%eax
    7398:	01 d0                	add    %edx,%eax
    739a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    739d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    73a0:	2b 45 a8             	sub    -0x58(%ebp),%eax
    73a3:	89 c2                	mov    %eax,%edx
    73a5:	8b 45 10             	mov    0x10(%ebp),%eax
    73a8:	01 d0                	add    %edx,%eax
    73aa:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    73ad:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    73b1:	76 3a                	jbe    73ed <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    73b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    73b6:	8b 40 14             	mov    0x14(%eax),%eax
    73b9:	8b 55 cc             	mov    -0x34(%ebp),%edx
    73bc:	01 d2                	add    %edx,%edx
    73be:	01 d0                	add    %edx,%eax
    73c0:	0f b7 00             	movzwl (%eax),%eax
    73c3:	0f b7 c0             	movzwl %ax,%eax
    73c6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    73c9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    73cc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    73cf:	76 06                	jbe    73d7 <encodeLZ77+0x225>
    73d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    73d4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    73d7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    73da:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    73dd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    73e0:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    73e3:	eb 08                	jmp    73ed <encodeLZ77+0x23b>
          ++backptr;
    73e5:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    73e9:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    73ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    73f0:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    73f3:	74 10                	je     7405 <encodeLZ77+0x253>
    73f5:	8b 45 d0             	mov    -0x30(%ebp),%eax
    73f8:	0f b6 10             	movzbl (%eax),%edx
    73fb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    73fe:	0f b6 00             	movzbl (%eax),%eax
    7401:	38 c2                	cmp    %al,%dl
    7403:	74 e0                	je     73e5 <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    7405:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7408:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    740b:	8b 55 10             	mov    0x10(%ebp),%edx
    740e:	01 ca                	add    %ecx,%edx
    7410:	29 d0                	sub    %edx,%eax
    7412:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    7415:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    7418:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    741b:	76 18                	jbe    7435 <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    741d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    7420:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    7423:	8b 45 a8             	mov    -0x58(%ebp),%eax
    7426:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    7429:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    742c:	3b 45 24             	cmp    0x24(%ebp),%eax
    742f:	0f 83 8e 00 00 00    	jae    74c3 <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    7435:	8b 45 0c             	mov    0xc(%ebp),%eax
    7438:	8b 40 04             	mov    0x4(%eax),%eax
    743b:	8b 55 cc             	mov    -0x34(%ebp),%edx
    743e:	01 d2                	add    %edx,%edx
    7440:	01 d0                	add    %edx,%eax
    7442:	0f b7 00             	movzwl (%eax),%eax
    7445:	0f b7 c0             	movzwl %ax,%eax
    7448:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    744b:	74 79                	je     74c6 <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    744d:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    7451:	76 38                	jbe    748b <encodeLZ77+0x2d9>
    7453:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7456:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7459:	76 30                	jbe    748b <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    745b:	8b 45 0c             	mov    0xc(%ebp),%eax
    745e:	8b 40 10             	mov    0x10(%eax),%eax
    7461:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7464:	01 d2                	add    %edx,%edx
    7466:	01 d0                	add    %edx,%eax
    7468:	0f b7 00             	movzwl (%eax),%eax
    746b:	0f b7 c0             	movzwl %ax,%eax
    746e:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    7471:	8b 45 0c             	mov    0xc(%ebp),%eax
    7474:	8b 40 14             	mov    0x14(%eax),%eax
    7477:	8b 55 cc             	mov    -0x34(%ebp),%edx
    747a:	01 d2                	add    %edx,%edx
    747c:	01 d0                	add    %edx,%eax
    747e:	0f b7 00             	movzwl (%eax),%eax
    7481:	0f b7 c0             	movzwl %ax,%eax
    7484:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7487:	74 2f                	je     74b8 <encodeLZ77+0x306>
    7489:	eb 3f                	jmp    74ca <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    748b:	8b 45 0c             	mov    0xc(%ebp),%eax
    748e:	8b 40 04             	mov    0x4(%eax),%eax
    7491:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7494:	01 d2                	add    %edx,%edx
    7496:	01 d0                	add    %edx,%eax
    7498:	0f b7 00             	movzwl (%eax),%eax
    749b:	0f b7 c0             	movzwl %ax,%eax
    749e:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    74a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    74a4:	8b 40 08             	mov    0x8(%eax),%eax
    74a7:	8b 55 cc             	mov    -0x34(%ebp),%edx
    74aa:	c1 e2 02             	shl    $0x2,%edx
    74ad:	01 d0                	add    %edx,%eax
    74af:	8b 10                	mov    (%eax),%edx
    74b1:	8b 45 b0             	mov    -0x50(%ebp),%eax
    74b4:	39 c2                	cmp    %eax,%edx
    74b6:	75 11                	jne    74c9 <encodeLZ77+0x317>
      }
    }
    74b8:	e9 87 fe ff ff       	jmp    7344 <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    74bd:	90                   	nop
    74be:	eb 0a                	jmp    74ca <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    74c0:	90                   	nop
    74c1:	eb 07                	jmp    74ca <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    74c3:	90                   	nop
    74c4:	eb 04                	jmp    74ca <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    74c6:	90                   	nop
    74c7:	eb 01                	jmp    74ca <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    74c9:	90                   	nop
      }
    }

    if(lazymatching) {
    74ca:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    74ce:	0f 84 c8 00 00 00    	je     759c <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    74d4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    74d8:	75 30                	jne    750a <encodeLZ77+0x358>
    74da:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    74de:	76 2a                	jbe    750a <encodeLZ77+0x358>
    74e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74e3:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    74e6:	77 22                	ja     750a <encodeLZ77+0x358>
    74e8:	b8 02 01 00 00       	mov    $0x102,%eax
    74ed:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    74f0:	73 18                	jae    750a <encodeLZ77+0x358>
        lazy = 1;
    74f2:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    74f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74fc:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    74ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7502:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    7505:	e9 f0 01 00 00       	jmp    76fa <encodeLZ77+0x548>
      }
      if(lazy) {
    750a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    750e:	0f 84 88 00 00 00    	je     759c <encodeLZ77+0x3ea>
        lazy = 0;
    7514:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    751b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    751f:	75 0c                	jne    752d <encodeLZ77+0x37b>
    7521:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    7528:	e9 dd 01 00 00       	jmp    770a <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    752d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7530:	83 c0 01             	add    $0x1,%eax
    7533:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7536:	73 2d                	jae    7565 <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    7538:	8b 45 fc             	mov    -0x4(%ebp),%eax
    753b:	8d 50 ff             	lea    -0x1(%eax),%edx
    753e:	8b 45 10             	mov    0x10(%ebp),%eax
    7541:	01 d0                	add    %edx,%eax
    7543:	0f b6 00             	movzbl (%eax),%eax
    7546:	0f b6 c0             	movzbl %al,%eax
    7549:	50                   	push   %eax
    754a:	ff 75 08             	pushl  0x8(%ebp)
    754d:	e8 6f cb ff ff       	call   40c1 <uivector_push_back>
    7552:	83 c4 08             	add    $0x8,%esp
    7555:	85 c0                	test   %eax,%eax
    7557:	75 43                	jne    759c <encodeLZ77+0x3ea>
    7559:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7560:	e9 a5 01 00 00       	jmp    770a <encodeLZ77+0x558>
        } else {
          length = lazylength;
    7565:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7568:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    756b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    756e:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    7571:	8b 45 0c             	mov    0xc(%ebp),%eax
    7574:	8b 00                	mov    (%eax),%eax
    7576:	8b 55 b0             	mov    -0x50(%ebp),%edx
    7579:	c1 e2 02             	shl    $0x2,%edx
    757c:	01 d0                	add    %edx,%eax
    757e:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    7584:	8b 45 0c             	mov    0xc(%ebp),%eax
    7587:	8b 40 0c             	mov    0xc(%eax),%eax
    758a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    758d:	c1 e2 02             	shl    $0x2,%edx
    7590:	01 d0                	add    %edx,%eax
    7592:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    7598:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    759c:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    75a0:	76 14                	jbe    75b6 <encodeLZ77+0x404>
    75a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75a5:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    75a8:	76 0c                	jbe    75b6 <encodeLZ77+0x404>
    75aa:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    75b1:	e9 54 01 00 00       	jmp    770a <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    75b6:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    75ba:	77 2e                	ja     75ea <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    75bc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    75bf:	8b 45 10             	mov    0x10(%ebp),%eax
    75c2:	01 d0                	add    %edx,%eax
    75c4:	0f b6 00             	movzbl (%eax),%eax
    75c7:	0f b6 c0             	movzbl %al,%eax
    75ca:	50                   	push   %eax
    75cb:	ff 75 08             	pushl  0x8(%ebp)
    75ce:	e8 ee ca ff ff       	call   40c1 <uivector_push_back>
    75d3:	83 c4 08             	add    $0x8,%esp
    75d6:	85 c0                	test   %eax,%eax
    75d8:	0f 85 1c 01 00 00    	jne    76fa <encodeLZ77+0x548>
    75de:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    75e5:	e9 20 01 00 00       	jmp    770a <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    75ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75ed:	3b 45 20             	cmp    0x20(%ebp),%eax
    75f0:	72 0f                	jb     7601 <encodeLZ77+0x44f>
    75f2:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    75f6:	75 37                	jne    762f <encodeLZ77+0x47d>
    75f8:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    75ff:	76 2e                	jbe    762f <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    7601:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7604:	8b 45 10             	mov    0x10(%ebp),%eax
    7607:	01 d0                	add    %edx,%eax
    7609:	0f b6 00             	movzbl (%eax),%eax
    760c:	0f b6 c0             	movzbl %al,%eax
    760f:	50                   	push   %eax
    7610:	ff 75 08             	pushl  0x8(%ebp)
    7613:	e8 a9 ca ff ff       	call   40c1 <uivector_push_back>
    7618:	83 c4 08             	add    $0x8,%esp
    761b:	85 c0                	test   %eax,%eax
    761d:	0f 85 d7 00 00 00    	jne    76fa <encodeLZ77+0x548>
    7623:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    762a:	e9 db 00 00 00       	jmp    770a <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    762f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7632:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7635:	52                   	push   %edx
    7636:	50                   	push   %eax
    7637:	ff 75 08             	pushl  0x8(%ebp)
    763a:	e8 8a f6 ff ff       	call   6cc9 <addLengthDistance>
    763f:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    7642:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    7649:	e9 a0 00 00 00       	jmp    76ee <encodeLZ77+0x53c>
        ++pos;
    764e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    7652:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7655:	8d 50 ff             	lea    -0x1(%eax),%edx
    7658:	8b 45 fc             	mov    -0x4(%ebp),%eax
    765b:	21 d0                	and    %edx,%eax
    765d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    7660:	ff 75 fc             	pushl  -0x4(%ebp)
    7663:	ff 75 18             	pushl  0x18(%ebp)
    7666:	ff 75 10             	pushl  0x10(%ebp)
    7669:	e8 67 f9 ff ff       	call   6fd5 <getHash>
    766e:	83 c4 0c             	add    $0xc,%esp
    7671:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    7674:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    7678:	74 4e                	je     76c8 <encodeLZ77+0x516>
    767a:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    767e:	75 48                	jne    76c8 <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    7680:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7684:	75 16                	jne    769c <encodeLZ77+0x4ea>
    7686:	ff 75 fc             	pushl  -0x4(%ebp)
    7689:	ff 75 18             	pushl  0x18(%ebp)
    768c:	ff 75 10             	pushl  0x10(%ebp)
    768f:	e8 f5 f9 ff ff       	call   7089 <countZeros>
    7694:	83 c4 0c             	add    $0xc,%esp
    7697:	89 45 f0             	mov    %eax,-0x10(%ebp)
    769a:	eb 35                	jmp    76d1 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    769c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    769f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    76a2:	01 c2                	add    %eax,%edx
    76a4:	8b 45 18             	mov    0x18(%ebp),%eax
    76a7:	39 c2                	cmp    %eax,%edx
    76a9:	77 17                	ja     76c2 <encodeLZ77+0x510>
    76ab:	8b 55 fc             	mov    -0x4(%ebp),%edx
    76ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
    76b1:	01 d0                	add    %edx,%eax
    76b3:	8d 50 ff             	lea    -0x1(%eax),%edx
    76b6:	8b 45 10             	mov    0x10(%ebp),%eax
    76b9:	01 d0                	add    %edx,%eax
    76bb:	0f b6 00             	movzbl (%eax),%eax
    76be:	84 c0                	test   %al,%al
    76c0:	74 0f                	je     76d1 <encodeLZ77+0x51f>
    76c2:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    76c6:	eb 09                	jmp    76d1 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    76c8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    76cf:	eb 01                	jmp    76d2 <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    76d1:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    76d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    76d5:	0f b7 c0             	movzwl %ax,%eax
    76d8:	50                   	push   %eax
    76d9:	ff 75 b0             	pushl  -0x50(%ebp)
    76dc:	ff 75 b4             	pushl  -0x4c(%ebp)
    76df:	ff 75 0c             	pushl  0xc(%ebp)
    76e2:	e8 04 fa ff ff       	call   70eb <updateHashChain>
    76e7:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    76ea:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    76ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
    76f1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    76f4:	0f 82 54 ff ff ff    	jb     764e <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    76fa:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    76fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7701:	3b 45 18             	cmp    0x18(%ebp),%eax
    7704:	0f 8c 54 fb ff ff    	jl     725e <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    770a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    770d:	c9                   	leave  
    770e:	c3                   	ret    

0000770f <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    770f:	55                   	push   %ebp
    7710:	89 e5                	mov    %esp,%ebp
    7712:	53                   	push   %ebx
    7713:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    7716:	8b 45 10             	mov    0x10(%ebp),%eax
    7719:	05 fe ff 00 00       	add    $0xfffe,%eax
    771e:	ba 01 80 00 80       	mov    $0x80008001,%edx
    7723:	f7 e2                	mul    %edx
    7725:	89 d0                	mov    %edx,%eax
    7727:	c1 e8 0f             	shr    $0xf,%eax
    772a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    772d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    7734:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    773b:	e9 1b 01 00 00       	jmp    785b <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    7740:	8b 45 08             	mov    0x8(%ebp),%eax
    7743:	8b 40 04             	mov    0x4(%eax),%eax
    7746:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    7749:	8b 45 ec             	mov    -0x14(%ebp),%eax
    774c:	83 e8 01             	sub    $0x1,%eax
    774f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    7752:	0f 94 c0             	sete   %al
    7755:	0f b6 c0             	movzbl %al,%eax
    7758:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    775b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    7762:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    7769:	8b 45 10             	mov    0x10(%ebp),%eax
    776c:	2b 45 f4             	sub    -0xc(%ebp),%eax
    776f:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    7774:	77 09                	ja     777f <deflateNoCompression+0x70>
    7776:	8b 45 10             	mov    0x10(%ebp),%eax
    7779:	2b 45 f4             	sub    -0xc(%ebp),%eax
    777c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    777f:	b8 ff ff 00 00       	mov    $0xffff,%eax
    7784:	2b 45 f0             	sub    -0x10(%ebp),%eax
    7787:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    778a:	8b 45 08             	mov    0x8(%ebp),%eax
    778d:	8b 40 04             	mov    0x4(%eax),%eax
    7790:	89 c2                	mov    %eax,%edx
    7792:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7795:	01 d0                	add    %edx,%eax
    7797:	83 c0 05             	add    $0x5,%eax
    779a:	50                   	push   %eax
    779b:	ff 75 08             	pushl  0x8(%ebp)
    779e:	e8 62 c9 ff ff       	call   4105 <ucvector_resize>
    77a3:	83 c4 08             	add    $0x8,%esp
    77a6:	85 c0                	test   %eax,%eax
    77a8:	75 0a                	jne    77b4 <deflateNoCompression+0xa5>
    77aa:	b8 53 00 00 00       	mov    $0x53,%eax
    77af:	e9 b8 00 00 00       	jmp    786c <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    77b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    77b7:	89 c2                	mov    %eax,%edx
    77b9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    77bc:	83 e0 01             	and    $0x1,%eax
    77bf:	01 c0                	add    %eax,%eax
    77c1:	01 c2                	add    %eax,%edx
    77c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    77c6:	83 e0 02             	and    $0x2,%eax
    77c9:	01 c0                	add    %eax,%eax
    77cb:	01 d0                	add    %edx,%eax
    77cd:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    77d0:	8b 45 08             	mov    0x8(%ebp),%eax
    77d3:	8b 10                	mov    (%eax),%edx
    77d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    77d8:	01 c2                	add    %eax,%edx
    77da:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    77de:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    77e0:	8b 45 08             	mov    0x8(%ebp),%eax
    77e3:	8b 00                	mov    (%eax),%eax
    77e5:	8b 55 e8             	mov    -0x18(%ebp),%edx
    77e8:	83 c2 01             	add    $0x1,%edx
    77eb:	01 d0                	add    %edx,%eax
    77ed:	8b 55 f0             	mov    -0x10(%ebp),%edx
    77f0:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    77f2:	8b 45 08             	mov    0x8(%ebp),%eax
    77f5:	8b 00                	mov    (%eax),%eax
    77f7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    77fa:	83 c2 02             	add    $0x2,%edx
    77fd:	01 d0                	add    %edx,%eax
    77ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
    7802:	c1 ea 08             	shr    $0x8,%edx
    7805:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    7807:	8b 45 08             	mov    0x8(%ebp),%eax
    780a:	8b 00                	mov    (%eax),%eax
    780c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    780f:	83 c2 03             	add    $0x3,%edx
    7812:	01 d0                	add    %edx,%eax
    7814:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7817:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    7819:	8b 45 08             	mov    0x8(%ebp),%eax
    781c:	8b 00                	mov    (%eax),%eax
    781e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7821:	83 c2 04             	add    $0x4,%edx
    7824:	01 d0                	add    %edx,%eax
    7826:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7829:	c1 ea 08             	shr    $0x8,%edx
    782c:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    782e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7831:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    7834:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7837:	01 d1                	add    %edx,%ecx
    7839:	8b 55 08             	mov    0x8(%ebp),%edx
    783c:	8b 12                	mov    (%edx),%edx
    783e:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    7841:	83 c3 05             	add    $0x5,%ebx
    7844:	01 da                	add    %ebx,%edx
    7846:	50                   	push   %eax
    7847:	51                   	push   %ecx
    7848:	52                   	push   %edx
    7849:	e8 9b c6 ff ff       	call   3ee9 <lodepng_memcpy>
    784e:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    7851:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7854:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    7857:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    785b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    785e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    7861:	0f 85 d9 fe ff ff    	jne    7740 <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    7867:	b8 00 00 00 00       	mov    $0x0,%eax
}
    786c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    786f:	c9                   	leave  
    7870:	c3                   	ret    

00007871 <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    7871:	55                   	push   %ebp
    7872:	89 e5                	mov    %esp,%ebp
    7874:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    7877:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    787e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    7885:	e9 10 01 00 00       	jmp    799a <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    788a:	8b 45 0c             	mov    0xc(%ebp),%eax
    788d:	8b 00                	mov    (%eax),%eax
    788f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7892:	c1 e2 02             	shl    $0x2,%edx
    7895:	01 d0                	add    %edx,%eax
    7897:	8b 00                	mov    (%eax),%eax
    7899:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    789c:	8b 45 10             	mov    0x10(%ebp),%eax
    789f:	8b 40 04             	mov    0x4(%eax),%eax
    78a2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    78a5:	c1 e2 02             	shl    $0x2,%edx
    78a8:	01 d0                	add    %edx,%eax
    78aa:	8b 00                	mov    (%eax),%eax
    78ac:	89 c1                	mov    %eax,%ecx
    78ae:	8b 45 10             	mov    0x10(%ebp),%eax
    78b1:	8b 00                	mov    (%eax),%eax
    78b3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    78b6:	c1 e2 02             	shl    $0x2,%edx
    78b9:	01 d0                	add    %edx,%eax
    78bb:	8b 00                	mov    (%eax),%eax
    78bd:	51                   	push   %ecx
    78be:	50                   	push   %eax
    78bf:	ff 75 08             	pushl  0x8(%ebp)
    78c2:	e8 60 cc ff ff       	call   4527 <writeBitsReversed>
    78c7:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    78ca:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    78d1:	0f 86 bf 00 00 00    	jbe    7996 <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    78d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    78da:	2d 01 01 00 00       	sub    $0x101,%eax
    78df:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    78e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    78e5:	8b 04 85 00 aa 01 00 	mov    0x1aa00(,%eax,4),%eax
    78ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    78ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    78f2:	8b 00                	mov    (%eax),%eax
    78f4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    78f8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    78fb:	c1 e2 02             	shl    $0x2,%edx
    78fe:	01 d0                	add    %edx,%eax
    7900:	8b 00                	mov    (%eax),%eax
    7902:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    7905:	8b 45 0c             	mov    0xc(%ebp),%eax
    7908:	8b 00                	mov    (%eax),%eax
    790a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    790e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7911:	c1 e2 02             	shl    $0x2,%edx
    7914:	01 d0                	add    %edx,%eax
    7916:	8b 00                	mov    (%eax),%eax
    7918:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    791b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    791e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    7921:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7924:	8b 04 85 00 ab 01 00 	mov    0x1ab00(,%eax,4),%eax
    792b:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    792e:	8b 45 0c             	mov    0xc(%ebp),%eax
    7931:	8b 00                	mov    (%eax),%eax
    7933:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7937:	8b 55 fc             	mov    -0x4(%ebp),%edx
    793a:	c1 e2 02             	shl    $0x2,%edx
    793d:	01 d0                	add    %edx,%eax
    793f:	8b 00                	mov    (%eax),%eax
    7941:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    7944:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7947:	50                   	push   %eax
    7948:	ff 75 ec             	pushl  -0x14(%ebp)
    794b:	ff 75 08             	pushl  0x8(%ebp)
    794e:	e8 40 ca ff ff       	call   4393 <writeBits>
    7953:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    7956:	8b 45 14             	mov    0x14(%ebp),%eax
    7959:	8b 40 04             	mov    0x4(%eax),%eax
    795c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    795f:	c1 e2 02             	shl    $0x2,%edx
    7962:	01 d0                	add    %edx,%eax
    7964:	8b 00                	mov    (%eax),%eax
    7966:	89 c1                	mov    %eax,%ecx
    7968:	8b 45 14             	mov    0x14(%ebp),%eax
    796b:	8b 00                	mov    (%eax),%eax
    796d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7970:	c1 e2 02             	shl    $0x2,%edx
    7973:	01 d0                	add    %edx,%eax
    7975:	8b 00                	mov    (%eax),%eax
    7977:	51                   	push   %ecx
    7978:	50                   	push   %eax
    7979:	ff 75 08             	pushl  0x8(%ebp)
    797c:	e8 a6 cb ff ff       	call   4527 <writeBitsReversed>
    7981:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    7984:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7987:	50                   	push   %eax
    7988:	ff 75 dc             	pushl  -0x24(%ebp)
    798b:	ff 75 08             	pushl  0x8(%ebp)
    798e:	e8 00 ca ff ff       	call   4393 <writeBits>
    7993:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    7996:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    799a:	8b 45 0c             	mov    0xc(%ebp),%eax
    799d:	8b 40 04             	mov    0x4(%eax),%eax
    79a0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    79a3:	0f 85 e1 fe ff ff    	jne    788a <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    79a9:	90                   	nop
    79aa:	c9                   	leave  
    79ab:	c3                   	ret    

000079ac <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    79ac:	55                   	push   %ebp
    79ad:	89 e5                	mov    %esp,%ebp
    79af:	53                   	push   %ebx
    79b0:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    79b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    79bd:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    79c4:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    79cb:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    79d2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    79d9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    79e0:	8b 45 18             	mov    0x18(%ebp),%eax
    79e3:	2b 45 14             	sub    0x14(%ebp),%eax
    79e6:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    79e9:	8b 45 20             	mov    0x20(%ebp),%eax
    79ec:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    79ef:	8d 45 90             	lea    -0x70(%ebp),%eax
    79f2:	50                   	push   %eax
    79f3:	e8 a4 c6 ff ff       	call   409c <uivector_init>
    79f8:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    79fb:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7a01:	50                   	push   %eax
    7a02:	e8 98 d3 ff ff       	call   4d9f <HuffmanTree_init>
    7a07:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    7a0a:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7a10:	50                   	push   %eax
    7a11:	e8 89 d3 ff ff       	call   4d9f <HuffmanTree_init>
    7a16:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    7a19:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7a1f:	50                   	push   %eax
    7a20:	e8 7a d3 ff ff       	call   4d9f <HuffmanTree_init>
    7a25:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    7a28:	83 ec 0c             	sub    $0xc,%esp
    7a2b:	68 78 04 00 00       	push   $0x478
    7a30:	e8 76 c4 ff ff       	call   3eab <lodepng_malloc>
    7a35:	83 c4 10             	add    $0x10,%esp
    7a38:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    7a3b:	83 ec 0c             	sub    $0xc,%esp
    7a3e:	6a 78                	push   $0x78
    7a40:	e8 66 c4 ff ff       	call   3eab <lodepng_malloc>
    7a45:	83 c4 10             	add    $0x10,%esp
    7a48:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    7a4b:	83 ec 0c             	sub    $0xc,%esp
    7a4e:	6a 4c                	push   $0x4c
    7a50:	e8 56 c4 ff ff       	call   3eab <lodepng_malloc>
    7a55:	83 c4 10             	add    $0x10,%esp
    7a58:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    7a5b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    7a5f:	74 0c                	je     7a6d <deflateDynamic+0xc1>
    7a61:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    7a65:	74 06                	je     7a6d <deflateDynamic+0xc1>
    7a67:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    7a6b:	75 07                	jne    7a74 <deflateDynamic+0xc8>
    7a6d:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    7a74:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7a78:	0f 85 f6 07 00 00    	jne    8274 <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    7a7e:	83 ec 04             	sub    $0x4,%esp
    7a81:	68 78 04 00 00       	push   $0x478
    7a86:	6a 00                	push   $0x0
    7a88:	ff 75 d4             	pushl  -0x2c(%ebp)
    7a8b:	e8 8c c4 ff ff       	call   3f1c <lodepng_memset>
    7a90:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    7a93:	83 ec 04             	sub    $0x4,%esp
    7a96:	6a 78                	push   $0x78
    7a98:	6a 00                	push   $0x0
    7a9a:	ff 75 d0             	pushl  -0x30(%ebp)
    7a9d:	e8 7a c4 ff ff       	call   3f1c <lodepng_memset>
    7aa2:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    7aa5:	83 ec 04             	sub    $0x4,%esp
    7aa8:	6a 4c                	push   $0x4c
    7aaa:	6a 00                	push   $0x0
    7aac:	ff 75 cc             	pushl  -0x34(%ebp)
    7aaf:	e8 68 c4 ff ff       	call   3f1c <lodepng_memset>
    7ab4:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    7ab7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7aba:	8b 40 04             	mov    0x4(%eax),%eax
    7abd:	85 c0                	test   %eax,%eax
    7abf:	74 45                	je     7b06 <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    7ac1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7ac4:	8b 58 14             	mov    0x14(%eax),%ebx
    7ac7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7aca:	8b 48 10             	mov    0x10(%eax),%ecx
    7acd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7ad0:	8b 50 0c             	mov    0xc(%eax),%edx
    7ad3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7ad6:	8b 40 08             	mov    0x8(%eax),%eax
    7ad9:	83 ec 0c             	sub    $0xc,%esp
    7adc:	53                   	push   %ebx
    7add:	51                   	push   %ecx
    7ade:	52                   	push   %edx
    7adf:	50                   	push   %eax
    7ae0:	ff 75 18             	pushl  0x18(%ebp)
    7ae3:	ff 75 14             	pushl  0x14(%ebp)
    7ae6:	ff 75 10             	pushl  0x10(%ebp)
    7ae9:	ff 75 0c             	pushl  0xc(%ebp)
    7aec:	8d 45 90             	lea    -0x70(%ebp),%eax
    7aef:	50                   	push   %eax
    7af0:	e8 bd f6 ff ff       	call   71b2 <encodeLZ77>
    7af5:	83 c4 30             	add    $0x30,%esp
    7af8:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    7afb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7aff:	74 59                	je     7b5a <deflateDynamic+0x1ae>
    7b01:	e9 6e 07 00 00       	jmp    8274 <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    7b06:	83 ec 08             	sub    $0x8,%esp
    7b09:	ff 75 c8             	pushl  -0x38(%ebp)
    7b0c:	8d 45 90             	lea    -0x70(%ebp),%eax
    7b0f:	50                   	push   %eax
    7b10:	e8 17 c5 ff ff       	call   402c <uivector_resize>
    7b15:	83 c4 10             	add    $0x10,%esp
    7b18:	85 c0                	test   %eax,%eax
    7b1a:	75 0c                	jne    7b28 <deflateDynamic+0x17c>
    7b1c:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7b23:	e9 4c 07 00 00       	jmp    8274 <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    7b28:	8b 45 14             	mov    0x14(%ebp),%eax
    7b2b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7b2e:	eb 22                	jmp    7b52 <deflateDynamic+0x1a6>
    7b30:	8b 55 90             	mov    -0x70(%ebp),%edx
    7b33:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7b36:	2b 45 14             	sub    0x14(%ebp),%eax
    7b39:	c1 e0 02             	shl    $0x2,%eax
    7b3c:	01 c2                	add    %eax,%edx
    7b3e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7b41:	8b 45 10             	mov    0x10(%ebp),%eax
    7b44:	01 c8                	add    %ecx,%eax
    7b46:	0f b6 00             	movzbl (%eax),%eax
    7b49:	0f b6 c0             	movzbl %al,%eax
    7b4c:	89 02                	mov    %eax,(%edx)
    7b4e:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7b52:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7b55:	3b 45 18             	cmp    0x18(%ebp),%eax
    7b58:	7c d6                	jl     7b30 <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    7b5a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7b61:	eb 60                	jmp    7bc3 <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    7b63:	8b 45 90             	mov    -0x70(%ebp),%eax
    7b66:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7b69:	c1 e2 02             	shl    $0x2,%edx
    7b6c:	01 d0                	add    %edx,%eax
    7b6e:	8b 00                	mov    (%eax),%eax
    7b70:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    7b73:	8b 45 c0             	mov    -0x40(%ebp),%eax
    7b76:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7b7d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7b80:	01 d0                	add    %edx,%eax
    7b82:	8b 10                	mov    (%eax),%edx
    7b84:	83 c2 01             	add    $0x1,%edx
    7b87:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    7b89:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    7b90:	76 2d                	jbe    7bbf <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    7b92:	8b 45 90             	mov    -0x70(%ebp),%eax
    7b95:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7b98:	83 c2 02             	add    $0x2,%edx
    7b9b:	c1 e2 02             	shl    $0x2,%edx
    7b9e:	01 d0                	add    %edx,%eax
    7ba0:	8b 00                	mov    (%eax),%eax
    7ba2:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    7ba5:	8b 45 bc             	mov    -0x44(%ebp),%eax
    7ba8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7baf:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7bb2:	01 d0                	add    %edx,%eax
    7bb4:	8b 10                	mov    (%eax),%edx
    7bb6:	83 c2 01             	add    $0x1,%edx
    7bb9:	89 10                	mov    %edx,(%eax)
        i += 3;
    7bbb:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    7bbf:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7bc3:	8b 45 94             	mov    -0x6c(%ebp),%eax
    7bc6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7bc9:	75 98                	jne    7b63 <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    7bcb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7bce:	05 00 04 00 00       	add    $0x400,%eax
    7bd3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    7bd9:	83 ec 0c             	sub    $0xc,%esp
    7bdc:	6a 0f                	push   $0xf
    7bde:	68 1e 01 00 00       	push   $0x11e
    7be3:	68 01 01 00 00       	push   $0x101
    7be8:	ff 75 d4             	pushl  -0x2c(%ebp)
    7beb:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7bf1:	50                   	push   %eax
    7bf2:	e8 e0 e1 ff ff       	call   5dd7 <HuffmanTree_makeFromFrequencies>
    7bf7:	83 c4 20             	add    $0x20,%esp
    7bfa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7bfd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7c01:	0f 85 66 06 00 00    	jne    826d <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    7c07:	83 ec 0c             	sub    $0xc,%esp
    7c0a:	6a 0f                	push   $0xf
    7c0c:	6a 1e                	push   $0x1e
    7c0e:	6a 02                	push   $0x2
    7c10:	ff 75 d0             	pushl  -0x30(%ebp)
    7c13:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7c19:	50                   	push   %eax
    7c1a:	e8 b8 e1 ff ff       	call   5dd7 <HuffmanTree_makeFromFrequencies>
    7c1f:	83 c4 20             	add    $0x20,%esp
    7c22:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7c25:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7c29:	0f 85 41 06 00 00    	jne    8270 <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    7c2f:	8b 45 84             	mov    -0x7c(%ebp),%eax
    7c32:	ba 1e 01 00 00       	mov    $0x11e,%edx
    7c37:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    7c3c:	0f 47 c2             	cmova  %edx,%eax
    7c3f:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    7c42:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    7c48:	ba 1e 00 00 00       	mov    $0x1e,%edx
    7c4d:	83 f8 1e             	cmp    $0x1e,%eax
    7c50:	0f 47 c2             	cmova  %edx,%eax
    7c53:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    7c56:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7c59:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7c5c:	01 d0                	add    %edx,%eax
    7c5e:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    7c61:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7c64:	c1 e0 02             	shl    $0x2,%eax
    7c67:	83 ec 0c             	sub    $0xc,%esp
    7c6a:	50                   	push   %eax
    7c6b:	e8 3b c2 ff ff       	call   3eab <lodepng_malloc>
    7c70:	83 c4 10             	add    $0x10,%esp
    7c73:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    7c76:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7c79:	c1 e0 02             	shl    $0x2,%eax
    7c7c:	83 ec 0c             	sub    $0xc,%esp
    7c7f:	50                   	push   %eax
    7c80:	e8 26 c2 ff ff       	call   3eab <lodepng_malloc>
    7c85:	83 c4 10             	add    $0x10,%esp
    7c88:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    7c8b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7c8f:	74 06                	je     7c97 <deflateDynamic+0x2eb>
    7c91:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    7c95:	75 0c                	jne    7ca3 <deflateDynamic+0x2f7>
    7c97:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7c9e:	e9 d1 05 00 00       	jmp    8274 <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    7ca3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    7caa:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7cb1:	eb 25                	jmp    7cd8 <deflateDynamic+0x32c>
    7cb3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7cb6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7cbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7cc0:	01 c2                	add    %eax,%edx
    7cc2:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7cc8:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7ccb:	c1 e1 02             	shl    $0x2,%ecx
    7cce:	01 c8                	add    %ecx,%eax
    7cd0:	8b 00                	mov    (%eax),%eax
    7cd2:	89 02                	mov    %eax,(%edx)
    7cd4:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7cd8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7cdb:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    7cde:	75 d3                	jne    7cb3 <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    7ce0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7ce7:	eb 2a                	jmp    7d13 <deflateDynamic+0x367>
    7ce9:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7cec:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7cef:	01 d0                	add    %edx,%eax
    7cf1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7cf8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7cfb:	01 c2                	add    %eax,%edx
    7cfd:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    7d03:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7d06:	c1 e1 02             	shl    $0x2,%ecx
    7d09:	01 c8                	add    %ecx,%eax
    7d0b:	8b 00                	mov    (%eax),%eax
    7d0d:	89 02                	mov    %eax,(%edx)
    7d0f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7d13:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7d16:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    7d19:	75 ce                	jne    7ce9 <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7d1b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7d22:	e9 3b 02 00 00       	jmp    7f62 <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    7d27:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    7d2e:	eb 04                	jmp    7d34 <deflateDynamic+0x388>
    7d30:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    7d34:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7d37:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7d3a:	01 d0                	add    %edx,%eax
    7d3c:	8d 50 01             	lea    0x1(%eax),%edx
    7d3f:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7d42:	39 c2                	cmp    %eax,%edx
    7d44:	73 2e                	jae    7d74 <deflateDynamic+0x3c8>
    7d46:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7d49:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7d4c:	01 d0                	add    %edx,%eax
    7d4e:	83 c0 01             	add    $0x1,%eax
    7d51:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7d58:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7d5b:	01 d0                	add    %edx,%eax
    7d5d:	8b 10                	mov    (%eax),%edx
    7d5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7d62:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7d69:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7d6c:	01 c8                	add    %ecx,%eax
    7d6e:	8b 00                	mov    (%eax),%eax
    7d70:	39 c2                	cmp    %eax,%edx
    7d72:	74 bc                	je     7d30 <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    7d74:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7d77:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7d7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7d81:	01 d0                	add    %edx,%eax
    7d83:	8b 00                	mov    (%eax),%eax
    7d85:	85 c0                	test   %eax,%eax
    7d87:	0f 85 a9 00 00 00    	jne    7e36 <deflateDynamic+0x48a>
    7d8d:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    7d91:	0f 86 9f 00 00 00    	jbe    7e36 <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    7d97:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    7d9b:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    7d9f:	77 3a                	ja     7ddb <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    7da1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7da4:	8d 50 01             	lea    0x1(%eax),%edx
    7da7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7daa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7db1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7db4:	01 d0                	add    %edx,%eax
    7db6:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    7dbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7dbf:	8d 50 01             	lea    0x1(%eax),%edx
    7dc2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7dc5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7dcc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7dcf:	01 d0                	add    %edx,%eax
    7dd1:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7dd4:	83 ea 03             	sub    $0x3,%edx
    7dd7:	89 10                	mov    %edx,(%eax)
    7dd9:	eb 48                	jmp    7e23 <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    7ddb:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    7de2:	76 07                	jbe    7deb <deflateDynamic+0x43f>
    7de4:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    7deb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7dee:	8d 50 01             	lea    0x1(%eax),%edx
    7df1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7df4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7dfb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7dfe:	01 d0                	add    %edx,%eax
    7e00:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    7e06:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7e09:	8d 50 01             	lea    0x1(%eax),%edx
    7e0c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7e0f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7e16:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7e19:	01 d0                	add    %edx,%eax
    7e1b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7e1e:	83 ea 0b             	sub    $0xb,%edx
    7e21:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    7e23:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7e26:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7e29:	01 d0                	add    %edx,%eax
    7e2b:	83 e8 01             	sub    $0x1,%eax
    7e2e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7e31:	e9 28 01 00 00       	jmp    7f5e <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    7e36:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    7e3a:	0f 86 f6 00 00 00    	jbe    7f36 <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    7e40:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7e43:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    7e48:	f7 e2                	mul    %edx
    7e4a:	89 d0                	mov    %edx,%eax
    7e4c:	c1 e8 02             	shr    $0x2,%eax
    7e4f:	89 45 ac             	mov    %eax,-0x54(%ebp)
    7e52:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7e55:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    7e5a:	89 c8                	mov    %ecx,%eax
    7e5c:	f7 e2                	mul    %edx
    7e5e:	c1 ea 02             	shr    $0x2,%edx
    7e61:	89 d0                	mov    %edx,%eax
    7e63:	01 c0                	add    %eax,%eax
    7e65:	01 d0                	add    %edx,%eax
    7e67:	01 c0                	add    %eax,%eax
    7e69:	29 c1                	sub    %eax,%ecx
    7e6b:	89 c8                	mov    %ecx,%eax
    7e6d:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    7e70:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7e73:	8d 50 01             	lea    0x1(%eax),%edx
    7e76:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7e79:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7e80:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7e83:	01 c2                	add    %eax,%edx
    7e85:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7e88:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7e8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7e92:	01 c8                	add    %ecx,%eax
    7e94:	8b 00                	mov    (%eax),%eax
    7e96:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    7e98:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    7e9f:	eb 3a                	jmp    7edb <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7ea1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7ea4:	8d 50 01             	lea    0x1(%eax),%edx
    7ea7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7eaa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7eb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7eb4:	01 d0                	add    %edx,%eax
    7eb6:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    7ebc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7ebf:	8d 50 01             	lea    0x1(%eax),%edx
    7ec2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7ec5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7ecc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7ecf:	01 d0                	add    %edx,%eax
    7ed1:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    7ed7:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    7edb:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7ede:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    7ee1:	72 be                	jb     7ea1 <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    7ee3:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    7ee7:	76 3a                	jbe    7f23 <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7ee9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7eec:	8d 50 01             	lea    0x1(%eax),%edx
    7eef:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7ef2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7ef9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7efc:	01 d0                	add    %edx,%eax
    7efe:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    7f04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7f07:	8d 50 01             	lea    0x1(%eax),%edx
    7f0a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7f0d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7f14:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7f17:	01 d0                	add    %edx,%eax
    7f19:	8b 55 a8             	mov    -0x58(%ebp),%edx
    7f1c:	83 ea 03             	sub    $0x3,%edx
    7f1f:	89 10                	mov    %edx,(%eax)
    7f21:	eb 06                	jmp    7f29 <deflateDynamic+0x57d>
        }
        else j -= rest;
    7f23:	8b 45 a8             	mov    -0x58(%ebp),%eax
    7f26:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    7f29:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7f2c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7f2f:	01 d0                	add    %edx,%eax
    7f31:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7f34:	eb 28                	jmp    7f5e <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    7f36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7f39:	8d 50 01             	lea    0x1(%eax),%edx
    7f3c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7f3f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7f46:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7f49:	01 c2                	add    %eax,%edx
    7f4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7f4e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7f55:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7f58:	01 c8                	add    %ecx,%eax
    7f5a:	8b 00                	mov    (%eax),%eax
    7f5c:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7f5e:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7f62:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7f65:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    7f68:	0f 85 b9 fd ff ff    	jne    7d27 <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7f6e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7f75:	eb 42                	jmp    7fb9 <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    7f77:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7f7a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7f81:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7f84:	01 d0                	add    %edx,%eax
    7f86:	8b 00                	mov    (%eax),%eax
    7f88:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7f8f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7f92:	01 d0                	add    %edx,%eax
    7f94:	8b 10                	mov    (%eax),%edx
    7f96:	83 c2 01             	add    $0x1,%edx
    7f99:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    7f9b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7f9e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7fa5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7fa8:	01 d0                	add    %edx,%eax
    7faa:	8b 00                	mov    (%eax),%eax
    7fac:	83 f8 0f             	cmp    $0xf,%eax
    7faf:	76 04                	jbe    7fb5 <deflateDynamic+0x609>
    7fb1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7fb5:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7fb9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7fbc:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7fbf:	75 b6                	jne    7f77 <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    7fc1:	83 ec 0c             	sub    $0xc,%esp
    7fc4:	6a 07                	push   $0x7
    7fc6:	6a 13                	push   $0x13
    7fc8:	6a 13                	push   $0x13
    7fca:	ff 75 cc             	pushl  -0x34(%ebp)
    7fcd:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7fd3:	50                   	push   %eax
    7fd4:	e8 fe dd ff ff       	call   5dd7 <HuffmanTree_makeFromFrequencies>
    7fd9:	83 c4 20             	add    $0x20,%esp
    7fdc:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    7fdf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7fe3:	0f 85 8a 02 00 00    	jne    8273 <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    7fe9:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7ff0:	eb 04                	jmp    7ff6 <deflateDynamic+0x64a>
      numcodes_cl--;
    7ff2:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7ff6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7ff9:	83 f8 04             	cmp    $0x4,%eax
    7ffc:	76 1e                	jbe    801c <deflateDynamic+0x670>
    7ffe:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    8004:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8007:	83 ea 01             	sub    $0x1,%edx
    800a:	8b 14 95 80 ab 01 00 	mov    0x1ab80(,%edx,4),%edx
    8011:	c1 e2 02             	shl    $0x2,%edx
    8014:	01 d0                	add    %edx,%eax
    8016:	8b 00                	mov    (%eax),%eax
    8018:	85 c0                	test   %eax,%eax
    801a:	74 d6                	je     7ff2 <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    801c:	83 ec 04             	sub    $0x4,%esp
    801f:	6a 01                	push   $0x1
    8021:	ff 75 c4             	pushl  -0x3c(%ebp)
    8024:	ff 75 08             	pushl  0x8(%ebp)
    8027:	e8 67 c3 ff ff       	call   4393 <writeBits>
    802c:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    802f:	83 ec 04             	sub    $0x4,%esp
    8032:	6a 01                	push   $0x1
    8034:	6a 00                	push   $0x0
    8036:	ff 75 08             	pushl  0x8(%ebp)
    8039:	e8 55 c3 ff ff       	call   4393 <writeBits>
    803e:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    8041:	83 ec 04             	sub    $0x4,%esp
    8044:	6a 01                	push   $0x1
    8046:	6a 01                	push   $0x1
    8048:	ff 75 08             	pushl  0x8(%ebp)
    804b:	e8 43 c3 ff ff       	call   4393 <writeBits>
    8050:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    8053:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8056:	2d 01 01 00 00       	sub    $0x101,%eax
    805b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    805e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    8061:	83 e8 01             	sub    $0x1,%eax
    8064:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    8067:	8b 45 e0             	mov    -0x20(%ebp),%eax
    806a:	83 e8 04             	sub    $0x4,%eax
    806d:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    8070:	83 ec 04             	sub    $0x4,%esp
    8073:	6a 05                	push   $0x5
    8075:	ff 75 a4             	pushl  -0x5c(%ebp)
    8078:	ff 75 08             	pushl  0x8(%ebp)
    807b:	e8 13 c3 ff ff       	call   4393 <writeBits>
    8080:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    8083:	83 ec 04             	sub    $0x4,%esp
    8086:	6a 05                	push   $0x5
    8088:	ff 75 a0             	pushl  -0x60(%ebp)
    808b:	ff 75 08             	pushl  0x8(%ebp)
    808e:	e8 00 c3 ff ff       	call   4393 <writeBits>
    8093:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    8096:	83 ec 04             	sub    $0x4,%esp
    8099:	6a 04                	push   $0x4
    809b:	ff 75 9c             	pushl  -0x64(%ebp)
    809e:	ff 75 08             	pushl  0x8(%ebp)
    80a1:	e8 ed c2 ff ff       	call   4393 <writeBits>
    80a6:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    80a9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    80b0:	eb 2c                	jmp    80de <deflateDynamic+0x732>
    80b2:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    80b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    80bb:	8b 04 85 80 ab 01 00 	mov    0x1ab80(,%eax,4),%eax
    80c2:	c1 e0 02             	shl    $0x2,%eax
    80c5:	01 d0                	add    %edx,%eax
    80c7:	8b 00                	mov    (%eax),%eax
    80c9:	83 ec 04             	sub    $0x4,%esp
    80cc:	6a 03                	push   $0x3
    80ce:	50                   	push   %eax
    80cf:	ff 75 08             	pushl  0x8(%ebp)
    80d2:	e8 bc c2 ff ff       	call   4393 <writeBits>
    80d7:	83 c4 10             	add    $0x10,%esp
    80da:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    80de:	8b 45 e8             	mov    -0x18(%ebp),%eax
    80e1:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    80e4:	75 cc                	jne    80b2 <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    80e6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    80ed:	e9 0a 01 00 00       	jmp    81fc <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    80f2:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    80f8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    80fb:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    8102:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8105:	01 ca                	add    %ecx,%edx
    8107:	8b 12                	mov    (%edx),%edx
    8109:	c1 e2 02             	shl    $0x2,%edx
    810c:	01 d0                	add    %edx,%eax
    810e:	8b 00                	mov    (%eax),%eax
    8110:	89 c3                	mov    %eax,%ebx
    8112:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    8118:	8b 55 e8             	mov    -0x18(%ebp),%edx
    811b:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    8122:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8125:	01 ca                	add    %ecx,%edx
    8127:	8b 12                	mov    (%edx),%edx
    8129:	c1 e2 02             	shl    $0x2,%edx
    812c:	01 d0                	add    %edx,%eax
    812e:	8b 00                	mov    (%eax),%eax
    8130:	83 ec 04             	sub    $0x4,%esp
    8133:	53                   	push   %ebx
    8134:	50                   	push   %eax
    8135:	ff 75 08             	pushl  0x8(%ebp)
    8138:	e8 ea c3 ff ff       	call   4527 <writeBitsReversed>
    813d:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    8140:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8143:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    814a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    814d:	01 d0                	add    %edx,%eax
    814f:	8b 00                	mov    (%eax),%eax
    8151:	83 f8 10             	cmp    $0x10,%eax
    8154:	75 28                	jne    817e <deflateDynamic+0x7d2>
    8156:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    815a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    815d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8164:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8167:	01 d0                	add    %edx,%eax
    8169:	8b 00                	mov    (%eax),%eax
    816b:	83 ec 04             	sub    $0x4,%esp
    816e:	6a 02                	push   $0x2
    8170:	50                   	push   %eax
    8171:	ff 75 08             	pushl  0x8(%ebp)
    8174:	e8 1a c2 ff ff       	call   4393 <writeBits>
    8179:	83 c4 10             	add    $0x10,%esp
    817c:	eb 7a                	jmp    81f8 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    817e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8181:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8188:	8b 45 ec             	mov    -0x14(%ebp),%eax
    818b:	01 d0                	add    %edx,%eax
    818d:	8b 00                	mov    (%eax),%eax
    818f:	83 f8 11             	cmp    $0x11,%eax
    8192:	75 28                	jne    81bc <deflateDynamic+0x810>
    8194:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    8198:	8b 45 e8             	mov    -0x18(%ebp),%eax
    819b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    81a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    81a5:	01 d0                	add    %edx,%eax
    81a7:	8b 00                	mov    (%eax),%eax
    81a9:	83 ec 04             	sub    $0x4,%esp
    81ac:	6a 03                	push   $0x3
    81ae:	50                   	push   %eax
    81af:	ff 75 08             	pushl  0x8(%ebp)
    81b2:	e8 dc c1 ff ff       	call   4393 <writeBits>
    81b7:	83 c4 10             	add    $0x10,%esp
    81ba:	eb 3c                	jmp    81f8 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    81bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    81bf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    81c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    81c9:	01 d0                	add    %edx,%eax
    81cb:	8b 00                	mov    (%eax),%eax
    81cd:	83 f8 12             	cmp    $0x12,%eax
    81d0:	75 26                	jne    81f8 <deflateDynamic+0x84c>
    81d2:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    81d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    81d9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    81e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    81e3:	01 d0                	add    %edx,%eax
    81e5:	8b 00                	mov    (%eax),%eax
    81e7:	83 ec 04             	sub    $0x4,%esp
    81ea:	6a 07                	push   $0x7
    81ec:	50                   	push   %eax
    81ed:	ff 75 08             	pushl  0x8(%ebp)
    81f0:	e8 9e c1 ff ff       	call   4393 <writeBits>
    81f5:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    81f8:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    81fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    81ff:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    8202:	0f 85 ea fe ff ff    	jne    80f2 <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    8208:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    820e:	50                   	push   %eax
    820f:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    8215:	50                   	push   %eax
    8216:	8d 45 90             	lea    -0x70(%ebp),%eax
    8219:	50                   	push   %eax
    821a:	ff 75 08             	pushl  0x8(%ebp)
    821d:	e8 4f f6 ff ff       	call   7871 <writeLZ77data>
    8222:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    8225:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    822b:	05 00 04 00 00       	add    $0x400,%eax
    8230:	8b 00                	mov    (%eax),%eax
    8232:	85 c0                	test   %eax,%eax
    8234:	75 09                	jne    823f <deflateDynamic+0x893>
    8236:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    823d:	eb 35                	jmp    8274 <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    823f:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    8245:	05 00 04 00 00       	add    $0x400,%eax
    824a:	8b 00                	mov    (%eax),%eax
    824c:	89 c2                	mov    %eax,%edx
    824e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    8254:	05 00 04 00 00       	add    $0x400,%eax
    8259:	8b 00                	mov    (%eax),%eax
    825b:	83 ec 04             	sub    $0x4,%esp
    825e:	52                   	push   %edx
    825f:	50                   	push   %eax
    8260:	ff 75 08             	pushl  0x8(%ebp)
    8263:	e8 bf c2 ff ff       	call   4527 <writeBitsReversed>
    8268:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    826b:	eb 07                	jmp    8274 <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    826d:	90                   	nop
    826e:	eb 04                	jmp    8274 <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    8270:	90                   	nop
    8271:	eb 01                	jmp    8274 <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    8273:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    8274:	83 ec 0c             	sub    $0xc,%esp
    8277:	8d 45 90             	lea    -0x70(%ebp),%eax
    827a:	50                   	push   %eax
    827b:	e8 73 bd ff ff       	call   3ff3 <uivector_cleanup>
    8280:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    8283:	83 ec 0c             	sub    $0xc,%esp
    8286:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    828c:	50                   	push   %eax
    828d:	e8 3a cb ff ff       	call   4dcc <HuffmanTree_cleanup>
    8292:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    8295:	83 ec 0c             	sub    $0xc,%esp
    8298:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    829e:	50                   	push   %eax
    829f:	e8 28 cb ff ff       	call   4dcc <HuffmanTree_cleanup>
    82a4:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    82a7:	83 ec 0c             	sub    $0xc,%esp
    82aa:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    82b0:	50                   	push   %eax
    82b1:	e8 16 cb ff ff       	call   4dcc <HuffmanTree_cleanup>
    82b6:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    82b9:	83 ec 0c             	sub    $0xc,%esp
    82bc:	ff 75 d4             	pushl  -0x2c(%ebp)
    82bf:	e8 08 bc ff ff       	call   3ecc <lodepng_free>
    82c4:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    82c7:	83 ec 0c             	sub    $0xc,%esp
    82ca:	ff 75 d0             	pushl  -0x30(%ebp)
    82cd:	e8 fa bb ff ff       	call   3ecc <lodepng_free>
    82d2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    82d5:	83 ec 0c             	sub    $0xc,%esp
    82d8:	ff 75 cc             	pushl  -0x34(%ebp)
    82db:	e8 ec bb ff ff       	call   3ecc <lodepng_free>
    82e0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    82e3:	83 ec 0c             	sub    $0xc,%esp
    82e6:	ff 75 f0             	pushl  -0x10(%ebp)
    82e9:	e8 de bb ff ff       	call   3ecc <lodepng_free>
    82ee:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    82f1:	83 ec 0c             	sub    $0xc,%esp
    82f4:	ff 75 ec             	pushl  -0x14(%ebp)
    82f7:	e8 d0 bb ff ff       	call   3ecc <lodepng_free>
    82fc:	83 c4 10             	add    $0x10,%esp

  return error;
    82ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8302:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8305:	c9                   	leave  
    8306:	c3                   	ret    

00008307 <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    8307:	55                   	push   %ebp
    8308:	89 e5                	mov    %esp,%ebp
    830a:	53                   	push   %ebx
    830b:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    830e:	8b 45 20             	mov    0x20(%ebp),%eax
    8311:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    8314:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    831b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    831e:	50                   	push   %eax
    831f:	e8 7b ca ff ff       	call   4d9f <HuffmanTree_init>
    8324:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    8327:	8d 45 bc             	lea    -0x44(%ebp),%eax
    832a:	50                   	push   %eax
    832b:	e8 6f ca ff ff       	call   4d9f <HuffmanTree_init>
    8330:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    8333:	83 ec 0c             	sub    $0xc,%esp
    8336:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    8339:	50                   	push   %eax
    833a:	e8 41 db ff ff       	call   5e80 <generateFixedLitLenTree>
    833f:	83 c4 10             	add    $0x10,%esp
    8342:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    8345:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8349:	75 12                	jne    835d <deflateFixed+0x56>
    834b:	83 ec 0c             	sub    $0xc,%esp
    834e:	8d 45 bc             	lea    -0x44(%ebp),%eax
    8351:	50                   	push   %eax
    8352:	e8 30 dc ff ff       	call   5f87 <generateFixedDistanceTree>
    8357:	83 c4 10             	add    $0x10,%esp
    835a:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    835d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8361:	0f 85 3a 01 00 00    	jne    84a1 <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    8367:	83 ec 04             	sub    $0x4,%esp
    836a:	6a 01                	push   $0x1
    836c:	ff 75 ec             	pushl  -0x14(%ebp)
    836f:	ff 75 08             	pushl  0x8(%ebp)
    8372:	e8 1c c0 ff ff       	call   4393 <writeBits>
    8377:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    837a:	83 ec 04             	sub    $0x4,%esp
    837d:	6a 01                	push   $0x1
    837f:	6a 01                	push   $0x1
    8381:	ff 75 08             	pushl  0x8(%ebp)
    8384:	e8 0a c0 ff ff       	call   4393 <writeBits>
    8389:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    838c:	83 ec 04             	sub    $0x4,%esp
    838f:	6a 01                	push   $0x1
    8391:	6a 00                	push   $0x0
    8393:	ff 75 08             	pushl  0x8(%ebp)
    8396:	e8 f8 bf ff ff       	call   4393 <writeBits>
    839b:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    839e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    83a1:	8b 40 04             	mov    0x4(%eax),%eax
    83a4:	85 c0                	test   %eax,%eax
    83a6:	74 77                	je     841f <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    83a8:	83 ec 0c             	sub    $0xc,%esp
    83ab:	8d 45 b0             	lea    -0x50(%ebp),%eax
    83ae:	50                   	push   %eax
    83af:	e8 e8 bc ff ff       	call   409c <uivector_init>
    83b4:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    83b7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    83ba:	8b 58 14             	mov    0x14(%eax),%ebx
    83bd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    83c0:	8b 48 10             	mov    0x10(%eax),%ecx
    83c3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    83c6:	8b 50 0c             	mov    0xc(%eax),%edx
    83c9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    83cc:	8b 40 08             	mov    0x8(%eax),%eax
    83cf:	83 ec 0c             	sub    $0xc,%esp
    83d2:	53                   	push   %ebx
    83d3:	51                   	push   %ecx
    83d4:	52                   	push   %edx
    83d5:	50                   	push   %eax
    83d6:	ff 75 18             	pushl  0x18(%ebp)
    83d9:	ff 75 14             	pushl  0x14(%ebp)
    83dc:	ff 75 10             	pushl  0x10(%ebp)
    83df:	ff 75 0c             	pushl  0xc(%ebp)
    83e2:	8d 45 b0             	lea    -0x50(%ebp),%eax
    83e5:	50                   	push   %eax
    83e6:	e8 c7 ed ff ff       	call   71b2 <encodeLZ77>
    83eb:	83 c4 30             	add    $0x30,%esp
    83ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    83f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    83f5:	75 17                	jne    840e <deflateFixed+0x107>
    83f7:	8d 45 bc             	lea    -0x44(%ebp),%eax
    83fa:	50                   	push   %eax
    83fb:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    83fe:	50                   	push   %eax
    83ff:	8d 45 b0             	lea    -0x50(%ebp),%eax
    8402:	50                   	push   %eax
    8403:	ff 75 08             	pushl  0x8(%ebp)
    8406:	e8 66 f4 ff ff       	call   7871 <writeLZ77data>
    840b:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    840e:	83 ec 0c             	sub    $0xc,%esp
    8411:	8d 45 b0             	lea    -0x50(%ebp),%eax
    8414:	50                   	push   %eax
    8415:	e8 d9 bb ff ff       	call   3ff3 <uivector_cleanup>
    841a:	83 c4 10             	add    $0x10,%esp
    841d:	eb 56                	jmp    8475 <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    841f:	8b 45 14             	mov    0x14(%ebp),%eax
    8422:	89 45 f0             	mov    %eax,-0x10(%ebp)
    8425:	eb 46                	jmp    846d <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    8427:	8b 45 d8             	mov    -0x28(%ebp),%eax
    842a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    842d:	8b 55 10             	mov    0x10(%ebp),%edx
    8430:	01 ca                	add    %ecx,%edx
    8432:	0f b6 12             	movzbl (%edx),%edx
    8435:	0f b6 d2             	movzbl %dl,%edx
    8438:	c1 e2 02             	shl    $0x2,%edx
    843b:	01 d0                	add    %edx,%eax
    843d:	8b 00                	mov    (%eax),%eax
    843f:	89 c3                	mov    %eax,%ebx
    8441:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8444:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    8447:	8b 55 10             	mov    0x10(%ebp),%edx
    844a:	01 ca                	add    %ecx,%edx
    844c:	0f b6 12             	movzbl (%edx),%edx
    844f:	0f b6 d2             	movzbl %dl,%edx
    8452:	c1 e2 02             	shl    $0x2,%edx
    8455:	01 d0                	add    %edx,%eax
    8457:	8b 00                	mov    (%eax),%eax
    8459:	83 ec 04             	sub    $0x4,%esp
    845c:	53                   	push   %ebx
    845d:	50                   	push   %eax
    845e:	ff 75 08             	pushl  0x8(%ebp)
    8461:	e8 c1 c0 ff ff       	call   4527 <writeBitsReversed>
    8466:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    8469:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    846d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8470:	3b 45 18             	cmp    0x18(%ebp),%eax
    8473:	7c b2                	jl     8427 <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    8475:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8479:	75 26                	jne    84a1 <deflateFixed+0x19a>
    847b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    847e:	05 00 04 00 00       	add    $0x400,%eax
    8483:	8b 00                	mov    (%eax),%eax
    8485:	89 c2                	mov    %eax,%edx
    8487:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    848a:	05 00 04 00 00       	add    $0x400,%eax
    848f:	8b 00                	mov    (%eax),%eax
    8491:	83 ec 04             	sub    $0x4,%esp
    8494:	52                   	push   %edx
    8495:	50                   	push   %eax
    8496:	ff 75 08             	pushl  0x8(%ebp)
    8499:	e8 89 c0 ff ff       	call   4527 <writeBitsReversed>
    849e:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    84a1:	83 ec 0c             	sub    $0xc,%esp
    84a4:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    84a7:	50                   	push   %eax
    84a8:	e8 1f c9 ff ff       	call   4dcc <HuffmanTree_cleanup>
    84ad:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    84b0:	83 ec 0c             	sub    $0xc,%esp
    84b3:	8d 45 bc             	lea    -0x44(%ebp),%eax
    84b6:	50                   	push   %eax
    84b7:	e8 10 c9 ff ff       	call   4dcc <HuffmanTree_cleanup>
    84bc:	83 c4 10             	add    $0x10,%esp

  return error;
    84bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    84c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    84c5:	c9                   	leave  
    84c6:	c3                   	ret    

000084c7 <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    84c7:	55                   	push   %ebp
    84c8:	89 e5                	mov    %esp,%ebp
    84ca:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    84cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    84d4:	ff 75 08             	pushl  0x8(%ebp)
    84d7:	8d 45 bc             	lea    -0x44(%ebp),%eax
    84da:	50                   	push   %eax
    84db:	e8 9e be ff ff       	call   437e <LodePNGBitWriter_init>
    84e0:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    84e3:	8b 45 14             	mov    0x14(%ebp),%eax
    84e6:	8b 00                	mov    (%eax),%eax
    84e8:	83 f8 02             	cmp    $0x2,%eax
    84eb:	76 0a                	jbe    84f7 <lodepng_deflatev+0x30>
    84ed:	b8 3d 00 00 00       	mov    $0x3d,%eax
    84f2:	e9 68 01 00 00       	jmp    865f <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    84f7:	8b 45 14             	mov    0x14(%ebp),%eax
    84fa:	8b 00                	mov    (%eax),%eax
    84fc:	85 c0                	test   %eax,%eax
    84fe:	75 16                	jne    8516 <lodepng_deflatev+0x4f>
    8500:	ff 75 10             	pushl  0x10(%ebp)
    8503:	ff 75 0c             	pushl  0xc(%ebp)
    8506:	ff 75 08             	pushl  0x8(%ebp)
    8509:	e8 01 f2 ff ff       	call   770f <deflateNoCompression>
    850e:	83 c4 0c             	add    $0xc,%esp
    8511:	e9 49 01 00 00       	jmp    865f <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    8516:	8b 45 14             	mov    0x14(%ebp),%eax
    8519:	8b 00                	mov    (%eax),%eax
    851b:	83 f8 01             	cmp    $0x1,%eax
    851e:	75 08                	jne    8528 <lodepng_deflatev+0x61>
    8520:	8b 45 10             	mov    0x10(%ebp),%eax
    8523:	89 45 ec             	mov    %eax,-0x14(%ebp)
    8526:	eb 2c                	jmp    8554 <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    8528:	8b 45 10             	mov    0x10(%ebp),%eax
    852b:	c1 e8 03             	shr    $0x3,%eax
    852e:	83 c0 08             	add    $0x8,%eax
    8531:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    8534:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    853b:	7f 07                	jg     8544 <lodepng_deflatev+0x7d>
    853d:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    8544:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    854b:	7e 07                	jle    8554 <lodepng_deflatev+0x8d>
    854d:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    8554:	8b 55 10             	mov    0x10(%ebp),%edx
    8557:	8b 45 ec             	mov    -0x14(%ebp),%eax
    855a:	01 d0                	add    %edx,%eax
    855c:	83 e8 01             	sub    $0x1,%eax
    855f:	99                   	cltd   
    8560:	f7 7d ec             	idivl  -0x14(%ebp)
    8563:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    8566:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    856a:	75 07                	jne    8573 <lodepng_deflatev+0xac>
    856c:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    8573:	8b 45 14             	mov    0x14(%ebp),%eax
    8576:	8b 40 08             	mov    0x8(%eax),%eax
    8579:	83 ec 08             	sub    $0x8,%esp
    857c:	50                   	push   %eax
    857d:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    8580:	50                   	push   %eax
    8581:	e8 1c e8 ff ff       	call   6da2 <hash_init>
    8586:	83 c4 10             	add    $0x10,%esp
    8589:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    858c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8590:	0f 85 b7 00 00 00    	jne    864d <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    8596:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    859d:	e9 99 00 00 00       	jmp    863b <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    85a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    85a5:	83 e8 01             	sub    $0x1,%eax
    85a8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    85ab:	0f 94 c0             	sete   %al
    85ae:	0f b6 c0             	movzbl %al,%eax
    85b1:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    85b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    85b7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    85bb:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    85be:	8b 55 dc             	mov    -0x24(%ebp),%edx
    85c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    85c4:	01 d0                	add    %edx,%eax
    85c6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    85c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    85cc:	3b 45 10             	cmp    0x10(%ebp),%eax
    85cf:	7e 06                	jle    85d7 <lodepng_deflatev+0x110>
    85d1:	8b 45 10             	mov    0x10(%ebp),%eax
    85d4:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    85d7:	8b 45 14             	mov    0x14(%ebp),%eax
    85da:	8b 00                	mov    (%eax),%eax
    85dc:	83 f8 01             	cmp    $0x1,%eax
    85df:	75 27                	jne    8608 <lodepng_deflatev+0x141>
    85e1:	83 ec 04             	sub    $0x4,%esp
    85e4:	ff 75 e0             	pushl  -0x20(%ebp)
    85e7:	ff 75 14             	pushl  0x14(%ebp)
    85ea:	ff 75 e4             	pushl  -0x1c(%ebp)
    85ed:	ff 75 dc             	pushl  -0x24(%ebp)
    85f0:	ff 75 0c             	pushl  0xc(%ebp)
    85f3:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    85f6:	50                   	push   %eax
    85f7:	8d 45 bc             	lea    -0x44(%ebp),%eax
    85fa:	50                   	push   %eax
    85fb:	e8 07 fd ff ff       	call   8307 <deflateFixed>
    8600:	83 c4 20             	add    $0x20,%esp
    8603:	89 45 f4             	mov    %eax,-0xc(%ebp)
    8606:	eb 2f                	jmp    8637 <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    8608:	8b 45 14             	mov    0x14(%ebp),%eax
    860b:	8b 00                	mov    (%eax),%eax
    860d:	83 f8 02             	cmp    $0x2,%eax
    8610:	75 25                	jne    8637 <lodepng_deflatev+0x170>
    8612:	83 ec 04             	sub    $0x4,%esp
    8615:	ff 75 e0             	pushl  -0x20(%ebp)
    8618:	ff 75 14             	pushl  0x14(%ebp)
    861b:	ff 75 e4             	pushl  -0x1c(%ebp)
    861e:	ff 75 dc             	pushl  -0x24(%ebp)
    8621:	ff 75 0c             	pushl  0xc(%ebp)
    8624:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    8627:	50                   	push   %eax
    8628:	8d 45 bc             	lea    -0x44(%ebp),%eax
    862b:	50                   	push   %eax
    862c:	e8 7b f3 ff ff       	call   79ac <deflateDynamic>
    8631:	83 c4 20             	add    $0x20,%esp
    8634:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    8637:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    863b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    863e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    8641:	74 0a                	je     864d <lodepng_deflatev+0x186>
    8643:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8647:	0f 84 55 ff ff ff    	je     85a2 <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    864d:	83 ec 0c             	sub    $0xc,%esp
    8650:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    8653:	50                   	push   %eax
    8654:	e8 08 e9 ff ff       	call   6f61 <hash_cleanup>
    8659:	83 c4 10             	add    $0x10,%esp

  return error;
    865c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    865f:	c9                   	leave  
    8660:	c3                   	ret    

00008661 <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    8661:	55                   	push   %ebp
    8662:	89 e5                	mov    %esp,%ebp
    8664:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    8667:	8b 45 0c             	mov    0xc(%ebp),%eax
    866a:	8b 08                	mov    (%eax),%ecx
    866c:	8b 45 08             	mov    0x8(%ebp),%eax
    866f:	8b 10                	mov    (%eax),%edx
    8671:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8674:	51                   	push   %ecx
    8675:	52                   	push   %edx
    8676:	50                   	push   %eax
    8677:	e8 f0 ba ff ff       	call   416c <ucvector_init>
    867c:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    867f:	ff 75 18             	pushl  0x18(%ebp)
    8682:	ff 75 14             	pushl  0x14(%ebp)
    8685:	ff 75 10             	pushl  0x10(%ebp)
    8688:	8d 45 e8             	lea    -0x18(%ebp),%eax
    868b:	50                   	push   %eax
    868c:	e8 36 fe ff ff       	call   84c7 <lodepng_deflatev>
    8691:	83 c4 10             	add    $0x10,%esp
    8694:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    8697:	8b 55 e8             	mov    -0x18(%ebp),%edx
    869a:	8b 45 08             	mov    0x8(%ebp),%eax
    869d:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    869f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    86a2:	8b 45 0c             	mov    0xc(%ebp),%eax
    86a5:	89 10                	mov    %edx,(%eax)
  return error;
    86a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    86aa:	c9                   	leave  
    86ab:	c3                   	ret    

000086ac <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    86ac:	55                   	push   %ebp
    86ad:	89 e5                	mov    %esp,%ebp
    86af:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    86b2:	8b 45 18             	mov    0x18(%ebp),%eax
    86b5:	8b 40 1c             	mov    0x1c(%eax),%eax
    86b8:	85 c0                	test   %eax,%eax
    86ba:	74 34                	je     86f0 <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    86bc:	8b 45 18             	mov    0x18(%ebp),%eax
    86bf:	8b 40 1c             	mov    0x1c(%eax),%eax
    86c2:	83 ec 0c             	sub    $0xc,%esp
    86c5:	ff 75 18             	pushl  0x18(%ebp)
    86c8:	ff 75 14             	pushl  0x14(%ebp)
    86cb:	ff 75 10             	pushl  0x10(%ebp)
    86ce:	ff 75 0c             	pushl  0xc(%ebp)
    86d1:	ff 75 08             	pushl  0x8(%ebp)
    86d4:	ff d0                	call   *%eax
    86d6:	83 c4 20             	add    $0x20,%esp
    86d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    86dc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    86e0:	74 07                	je     86e9 <deflate+0x3d>
    86e2:	b8 6f 00 00 00       	mov    $0x6f,%eax
    86e7:	eb 21                	jmp    870a <deflate+0x5e>
    86e9:	b8 00 00 00 00       	mov    $0x0,%eax
    86ee:	eb 1a                	jmp    870a <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    86f0:	83 ec 0c             	sub    $0xc,%esp
    86f3:	ff 75 18             	pushl  0x18(%ebp)
    86f6:	ff 75 14             	pushl  0x14(%ebp)
    86f9:	ff 75 10             	pushl  0x10(%ebp)
    86fc:	ff 75 0c             	pushl  0xc(%ebp)
    86ff:	ff 75 08             	pushl  0x8(%ebp)
    8702:	e8 5a ff ff ff       	call   8661 <lodepng_deflate>
    8707:	83 c4 20             	add    $0x20,%esp
  }
}
    870a:	c9                   	leave  
    870b:	c3                   	ret    

0000870c <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    870c:	55                   	push   %ebp
    870d:	89 e5                	mov    %esp,%ebp
    870f:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    8712:	8b 45 08             	mov    0x8(%ebp),%eax
    8715:	0f b7 c0             	movzwl %ax,%eax
    8718:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    871b:	8b 45 08             	mov    0x8(%ebp),%eax
    871e:	c1 e8 10             	shr    $0x10,%eax
    8721:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    8724:	e9 82 00 00 00       	jmp    87ab <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    8729:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    872e:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    8735:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    8739:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    873c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    873f:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    8742:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8749:	eb 1c                	jmp    8767 <update_adler32+0x5b>
      s1 += (*data++);
    874b:	8b 45 0c             	mov    0xc(%ebp),%eax
    874e:	8d 50 01             	lea    0x1(%eax),%edx
    8751:	89 55 0c             	mov    %edx,0xc(%ebp)
    8754:	0f b6 00             	movzbl (%eax),%eax
    8757:	0f b6 c0             	movzbl %al,%eax
    875a:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    875d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8760:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    8763:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8767:	8b 45 f4             	mov    -0xc(%ebp),%eax
    876a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    876d:	75 dc                	jne    874b <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    876f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    8772:	ba 71 80 07 80       	mov    $0x80078071,%edx
    8777:	89 c8                	mov    %ecx,%eax
    8779:	f7 e2                	mul    %edx
    877b:	89 d0                	mov    %edx,%eax
    877d:	c1 e8 0f             	shr    $0xf,%eax
    8780:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    8786:	29 c1                	sub    %eax,%ecx
    8788:	89 c8                	mov    %ecx,%eax
    878a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    878d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    8790:	ba 71 80 07 80       	mov    $0x80078071,%edx
    8795:	89 c8                	mov    %ecx,%eax
    8797:	f7 e2                	mul    %edx
    8799:	89 d0                	mov    %edx,%eax
    879b:	c1 e8 0f             	shr    $0xf,%eax
    879e:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    87a4:	29 c1                	sub    %eax,%ecx
    87a6:	89 c8                	mov    %ecx,%eax
    87a8:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    87ab:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    87af:	0f 85 74 ff ff ff    	jne    8729 <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    87b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    87b8:	c1 e0 10             	shl    $0x10,%eax
    87bb:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    87be:	c9                   	leave  
    87bf:	c3                   	ret    

000087c0 <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    87c0:	55                   	push   %ebp
    87c1:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    87c3:	ff 75 0c             	pushl  0xc(%ebp)
    87c6:	ff 75 08             	pushl  0x8(%ebp)
    87c9:	6a 01                	push   $0x1
    87cb:	e8 3c ff ff ff       	call   870c <update_adler32>
    87d0:	83 c4 0c             	add    $0xc,%esp
}
    87d3:	c9                   	leave  
    87d4:	c3                   	ret    

000087d5 <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    87d5:	55                   	push   %ebp
    87d6:	89 e5                	mov    %esp,%ebp
    87d8:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    87db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    87e2:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    87e6:	7f 0a                	jg     87f2 <lodepng_zlib_decompressv+0x1d>
    87e8:	b8 35 00 00 00       	mov    $0x35,%eax
    87ed:	e9 27 01 00 00       	jmp    8919 <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    87f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    87f5:	0f b6 00             	movzbl (%eax),%eax
    87f8:	0f b6 c0             	movzbl %al,%eax
    87fb:	c1 e0 08             	shl    $0x8,%eax
    87fe:	89 c2                	mov    %eax,%edx
    8800:	8b 45 0c             	mov    0xc(%ebp),%eax
    8803:	83 c0 01             	add    $0x1,%eax
    8806:	0f b6 00             	movzbl (%eax),%eax
    8809:	0f b6 c0             	movzbl %al,%eax
    880c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    880f:	ba 43 08 21 84       	mov    $0x84210843,%edx
    8814:	89 c8                	mov    %ecx,%eax
    8816:	f7 ea                	imul   %edx
    8818:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    881b:	c1 f8 04             	sar    $0x4,%eax
    881e:	89 c2                	mov    %eax,%edx
    8820:	89 c8                	mov    %ecx,%eax
    8822:	c1 f8 1f             	sar    $0x1f,%eax
    8825:	29 c2                	sub    %eax,%edx
    8827:	89 d0                	mov    %edx,%eax
    8829:	89 c2                	mov    %eax,%edx
    882b:	c1 e2 05             	shl    $0x5,%edx
    882e:	29 c2                	sub    %eax,%edx
    8830:	89 c8                	mov    %ecx,%eax
    8832:	29 d0                	sub    %edx,%eax
    8834:	85 c0                	test   %eax,%eax
    8836:	74 0a                	je     8842 <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    8838:	b8 18 00 00 00       	mov    $0x18,%eax
    883d:	e9 d7 00 00 00       	jmp    8919 <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    8842:	8b 45 0c             	mov    0xc(%ebp),%eax
    8845:	0f b6 00             	movzbl (%eax),%eax
    8848:	0f b6 c0             	movzbl %al,%eax
    884b:	83 e0 0f             	and    $0xf,%eax
    884e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    8851:	8b 45 0c             	mov    0xc(%ebp),%eax
    8854:	0f b6 00             	movzbl (%eax),%eax
    8857:	c0 e8 04             	shr    $0x4,%al
    885a:	0f b6 c0             	movzbl %al,%eax
    885d:	83 e0 0f             	and    $0xf,%eax
    8860:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    8863:	8b 45 0c             	mov    0xc(%ebp),%eax
    8866:	83 c0 01             	add    $0x1,%eax
    8869:	0f b6 00             	movzbl (%eax),%eax
    886c:	c0 e8 05             	shr    $0x5,%al
    886f:	0f b6 c0             	movzbl %al,%eax
    8872:	83 e0 01             	and    $0x1,%eax
    8875:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    8878:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    887c:	75 06                	jne    8884 <lodepng_zlib_decompressv+0xaf>
    887e:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    8882:	76 0a                	jbe    888e <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    8884:	b8 19 00 00 00       	mov    $0x19,%eax
    8889:	e9 8b 00 00 00       	jmp    8919 <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    888e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    8892:	74 07                	je     889b <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    8894:	b8 1a 00 00 00       	mov    $0x1a,%eax
    8899:	eb 7e                	jmp    8919 <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    889b:	8b 45 10             	mov    0x10(%ebp),%eax
    889e:	8d 50 fe             	lea    -0x2(%eax),%edx
    88a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    88a4:	83 c0 02             	add    $0x2,%eax
    88a7:	ff 75 14             	pushl  0x14(%ebp)
    88aa:	52                   	push   %edx
    88ab:	50                   	push   %eax
    88ac:	ff 75 08             	pushl  0x8(%ebp)
    88af:	e8 09 e3 ff ff       	call   6bbd <inflatev>
    88b4:	83 c4 10             	add    $0x10,%esp
    88b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    88ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    88be:	74 05                	je     88c5 <lodepng_zlib_decompressv+0xf0>
    88c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    88c3:	eb 54                	jmp    8919 <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    88c5:	8b 45 14             	mov    0x14(%ebp),%eax
    88c8:	8b 00                	mov    (%eax),%eax
    88ca:	85 c0                	test   %eax,%eax
    88cc:	75 46                	jne    8914 <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    88ce:	8b 45 10             	mov    0x10(%ebp),%eax
    88d1:	8d 50 fc             	lea    -0x4(%eax),%edx
    88d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    88d7:	01 d0                	add    %edx,%eax
    88d9:	83 ec 0c             	sub    $0xc,%esp
    88dc:	50                   	push   %eax
    88dd:	e8 47 b9 ff ff       	call   4229 <lodepng_read32bitInt>
    88e2:	83 c4 10             	add    $0x10,%esp
    88e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    88e8:	8b 45 08             	mov    0x8(%ebp),%eax
    88eb:	8b 40 04             	mov    0x4(%eax),%eax
    88ee:	89 c2                	mov    %eax,%edx
    88f0:	8b 45 08             	mov    0x8(%ebp),%eax
    88f3:	8b 00                	mov    (%eax),%eax
    88f5:	83 ec 08             	sub    $0x8,%esp
    88f8:	52                   	push   %edx
    88f9:	50                   	push   %eax
    88fa:	e8 c1 fe ff ff       	call   87c0 <adler32>
    88ff:	83 c4 10             	add    $0x10,%esp
    8902:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    8905:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8908:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    890b:	74 07                	je     8914 <lodepng_zlib_decompressv+0x13f>
    890d:	b8 3a 00 00 00       	mov    $0x3a,%eax
    8912:	eb 05                	jmp    8919 <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    8914:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8919:	c9                   	leave  
    891a:	c3                   	ret    

0000891b <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    891b:	55                   	push   %ebp
    891c:	89 e5                	mov    %esp,%ebp
    891e:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    8921:	8b 45 0c             	mov    0xc(%ebp),%eax
    8924:	8b 08                	mov    (%eax),%ecx
    8926:	8b 45 08             	mov    0x8(%ebp),%eax
    8929:	8b 10                	mov    (%eax),%edx
    892b:	8d 45 e8             	lea    -0x18(%ebp),%eax
    892e:	51                   	push   %ecx
    892f:	52                   	push   %edx
    8930:	50                   	push   %eax
    8931:	e8 36 b8 ff ff       	call   416c <ucvector_init>
    8936:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    8939:	ff 75 18             	pushl  0x18(%ebp)
    893c:	ff 75 14             	pushl  0x14(%ebp)
    893f:	ff 75 10             	pushl  0x10(%ebp)
    8942:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8945:	50                   	push   %eax
    8946:	e8 8a fe ff ff       	call   87d5 <lodepng_zlib_decompressv>
    894b:	83 c4 10             	add    $0x10,%esp
    894e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    8951:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8954:	8b 45 08             	mov    0x8(%ebp),%eax
    8957:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8959:	8b 55 ec             	mov    -0x14(%ebp),%edx
    895c:	8b 45 0c             	mov    0xc(%ebp),%eax
    895f:	89 10                	mov    %edx,(%eax)
  return error;
    8961:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8964:	c9                   	leave  
    8965:	c3                   	ret    

00008966 <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    8966:	55                   	push   %ebp
    8967:	89 e5                	mov    %esp,%ebp
    8969:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    896c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    896f:	8b 40 0c             	mov    0xc(%eax),%eax
    8972:	85 c0                	test   %eax,%eax
    8974:	74 57                	je     89cd <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    8976:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8979:	8b 40 0c             	mov    0xc(%eax),%eax
    897c:	83 ec 0c             	sub    $0xc,%esp
    897f:	ff 75 1c             	pushl  0x1c(%ebp)
    8982:	ff 75 18             	pushl  0x18(%ebp)
    8985:	ff 75 14             	pushl  0x14(%ebp)
    8988:	ff 75 0c             	pushl  0xc(%ebp)
    898b:	ff 75 08             	pushl  0x8(%ebp)
    898e:	ff d0                	call   *%eax
    8990:	83 c4 20             	add    $0x20,%esp
    8993:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    8996:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    899a:	0f 84 98 00 00 00    	je     8a38 <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    89a0:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    89a7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    89aa:	8b 40 08             	mov    0x8(%eax),%eax
    89ad:	85 c0                	test   %eax,%eax
    89af:	0f 84 83 00 00 00    	je     8a38 <zlib_decompress+0xd2>
    89b5:	8b 45 0c             	mov    0xc(%ebp),%eax
    89b8:	8b 10                	mov    (%eax),%edx
    89ba:	8b 45 1c             	mov    0x1c(%ebp),%eax
    89bd:	8b 40 08             	mov    0x8(%eax),%eax
    89c0:	39 c2                	cmp    %eax,%edx
    89c2:	7e 74                	jle    8a38 <zlib_decompress+0xd2>
    89c4:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    89cb:	eb 6b                	jmp    8a38 <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    89cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    89d0:	8b 08                	mov    (%eax),%ecx
    89d2:	8b 45 08             	mov    0x8(%ebp),%eax
    89d5:	8b 10                	mov    (%eax),%edx
    89d7:	8d 45 e8             	lea    -0x18(%ebp),%eax
    89da:	83 ec 04             	sub    $0x4,%esp
    89dd:	51                   	push   %ecx
    89de:	52                   	push   %edx
    89df:	50                   	push   %eax
    89e0:	e8 87 b7 ff ff       	call   416c <ucvector_init>
    89e5:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    89e8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    89ec:	74 22                	je     8a10 <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    89ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    89f1:	8b 10                	mov    (%eax),%edx
    89f3:	8b 45 10             	mov    0x10(%ebp),%eax
    89f6:	01 d0                	add    %edx,%eax
    89f8:	83 ec 08             	sub    $0x8,%esp
    89fb:	50                   	push   %eax
    89fc:	8d 45 e8             	lea    -0x18(%ebp),%eax
    89ff:	50                   	push   %eax
    8a00:	e8 00 b7 ff ff       	call   4105 <ucvector_resize>
    8a05:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    8a08:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a0b:	8b 00                	mov    (%eax),%eax
    8a0d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    8a10:	ff 75 1c             	pushl  0x1c(%ebp)
    8a13:	ff 75 18             	pushl  0x18(%ebp)
    8a16:	ff 75 14             	pushl  0x14(%ebp)
    8a19:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8a1c:	50                   	push   %eax
    8a1d:	e8 b3 fd ff ff       	call   87d5 <lodepng_zlib_decompressv>
    8a22:	83 c4 10             	add    $0x10,%esp
    8a25:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    8a28:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8a2b:	8b 45 08             	mov    0x8(%ebp),%eax
    8a2e:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    8a30:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8a33:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a36:	89 10                	mov    %edx,(%eax)
  }
  return error;
    8a38:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8a3b:	c9                   	leave  
    8a3c:	c3                   	ret    

00008a3d <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    8a3d:	55                   	push   %ebp
    8a3e:	89 e5                	mov    %esp,%ebp
    8a40:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    8a43:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    8a4a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    8a51:	83 ec 0c             	sub    $0xc,%esp
    8a54:	ff 75 18             	pushl  0x18(%ebp)
    8a57:	ff 75 14             	pushl  0x14(%ebp)
    8a5a:	ff 75 10             	pushl  0x10(%ebp)
    8a5d:	8d 45 d0             	lea    -0x30(%ebp),%eax
    8a60:	50                   	push   %eax
    8a61:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    8a64:	50                   	push   %eax
    8a65:	e8 42 fc ff ff       	call   86ac <deflate>
    8a6a:	83 c4 20             	add    $0x20,%esp
    8a6d:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    8a70:	8b 45 08             	mov    0x8(%ebp),%eax
    8a73:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    8a79:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a7c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    8a82:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    8a86:	75 33                	jne    8abb <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    8a88:	8b 45 d0             	mov    -0x30(%ebp),%eax
    8a8b:	8d 50 06             	lea    0x6(%eax),%edx
    8a8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a91:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    8a93:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a96:	8b 00                	mov    (%eax),%eax
    8a98:	83 ec 0c             	sub    $0xc,%esp
    8a9b:	50                   	push   %eax
    8a9c:	e8 0a b4 ff ff       	call   3eab <lodepng_malloc>
    8aa1:	83 c4 10             	add    $0x10,%esp
    8aa4:	89 c2                	mov    %eax,%edx
    8aa6:	8b 45 08             	mov    0x8(%ebp),%eax
    8aa9:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    8aab:	8b 45 08             	mov    0x8(%ebp),%eax
    8aae:	8b 00                	mov    (%eax),%eax
    8ab0:	85 c0                	test   %eax,%eax
    8ab2:	75 07                	jne    8abb <lodepng_zlib_compress+0x7e>
    8ab4:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    8abb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    8abf:	0f 85 e2 00 00 00    	jne    8ba7 <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    8ac5:	8b 45 14             	mov    0x14(%ebp),%eax
    8ac8:	83 ec 08             	sub    $0x8,%esp
    8acb:	50                   	push   %eax
    8acc:	ff 75 10             	pushl  0x10(%ebp)
    8acf:	e8 ec fc ff ff       	call   87c0 <adler32>
    8ad4:	83 c4 10             	add    $0x10,%esp
    8ad7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    8ada:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    8ae1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    8ae8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    8aef:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8af2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8af9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8afc:	01 d0                	add    %edx,%eax
    8afe:	8d 14 00             	lea    (%eax,%eax,1),%edx
    8b01:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8b04:	01 d0                	add    %edx,%eax
    8b06:	c1 e0 05             	shl    $0x5,%eax
    8b09:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    8b0c:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    8b0f:	ba 85 10 42 08       	mov    $0x8421085,%edx
    8b14:	89 c8                	mov    %ecx,%eax
    8b16:	f7 e2                	mul    %edx
    8b18:	89 c8                	mov    %ecx,%eax
    8b1a:	29 d0                	sub    %edx,%eax
    8b1c:	d1 e8                	shr    %eax
    8b1e:	01 d0                	add    %edx,%eax
    8b20:	c1 e8 04             	shr    $0x4,%eax
    8b23:	89 c2                	mov    %eax,%edx
    8b25:	c1 e2 05             	shl    $0x5,%edx
    8b28:	29 c2                	sub    %eax,%edx
    8b2a:	89 c8                	mov    %ecx,%eax
    8b2c:	29 d0                	sub    %edx,%eax
    8b2e:	ba 1f 00 00 00       	mov    $0x1f,%edx
    8b33:	29 c2                	sub    %eax,%edx
    8b35:	89 d0                	mov    %edx,%eax
    8b37:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    8b3a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8b3d:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    8b40:	8b 45 08             	mov    0x8(%ebp),%eax
    8b43:	8b 00                	mov    (%eax),%eax
    8b45:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8b48:	c1 ea 08             	shr    $0x8,%edx
    8b4b:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    8b4d:	8b 45 08             	mov    0x8(%ebp),%eax
    8b50:	8b 00                	mov    (%eax),%eax
    8b52:	83 c0 01             	add    $0x1,%eax
    8b55:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8b58:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    8b5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8b61:	eb 1e                	jmp    8b81 <lodepng_zlib_compress+0x144>
    8b63:	8b 45 08             	mov    0x8(%ebp),%eax
    8b66:	8b 00                	mov    (%eax),%eax
    8b68:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b6b:	83 c2 02             	add    $0x2,%edx
    8b6e:	01 c2                	add    %eax,%edx
    8b70:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    8b73:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8b76:	01 c8                	add    %ecx,%eax
    8b78:	0f b6 00             	movzbl (%eax),%eax
    8b7b:	88 02                	mov    %al,(%edx)
    8b7d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8b81:	8b 45 d0             	mov    -0x30(%ebp),%eax
    8b84:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    8b87:	75 da                	jne    8b63 <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    8b89:	8b 45 08             	mov    0x8(%ebp),%eax
    8b8c:	8b 10                	mov    (%eax),%edx
    8b8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b91:	8b 00                	mov    (%eax),%eax
    8b93:	83 e8 04             	sub    $0x4,%eax
    8b96:	01 d0                	add    %edx,%eax
    8b98:	83 ec 08             	sub    $0x8,%esp
    8b9b:	ff 75 ec             	pushl  -0x14(%ebp)
    8b9e:	50                   	push   %eax
    8b9f:	e8 c8 b6 ff ff       	call   426c <lodepng_set32bitInt>
    8ba4:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    8ba7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8baa:	83 ec 0c             	sub    $0xc,%esp
    8bad:	50                   	push   %eax
    8bae:	e8 19 b3 ff ff       	call   3ecc <lodepng_free>
    8bb3:	83 c4 10             	add    $0x10,%esp
  return error;
    8bb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    8bb9:	c9                   	leave  
    8bba:	c3                   	ret    

00008bbb <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    8bbb:	55                   	push   %ebp
    8bbc:	89 e5                	mov    %esp,%ebp
    8bbe:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    8bc1:	8b 45 18             	mov    0x18(%ebp),%eax
    8bc4:	8b 40 18             	mov    0x18(%eax),%eax
    8bc7:	85 c0                	test   %eax,%eax
    8bc9:	74 34                	je     8bff <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    8bcb:	8b 45 18             	mov    0x18(%ebp),%eax
    8bce:	8b 40 18             	mov    0x18(%eax),%eax
    8bd1:	83 ec 0c             	sub    $0xc,%esp
    8bd4:	ff 75 18             	pushl  0x18(%ebp)
    8bd7:	ff 75 14             	pushl  0x14(%ebp)
    8bda:	ff 75 10             	pushl  0x10(%ebp)
    8bdd:	ff 75 0c             	pushl  0xc(%ebp)
    8be0:	ff 75 08             	pushl  0x8(%ebp)
    8be3:	ff d0                	call   *%eax
    8be5:	83 c4 20             	add    $0x20,%esp
    8be8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    8beb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8bef:	74 07                	je     8bf8 <zlib_compress+0x3d>
    8bf1:	b8 6f 00 00 00       	mov    $0x6f,%eax
    8bf6:	eb 21                	jmp    8c19 <zlib_compress+0x5e>
    8bf8:	b8 00 00 00 00       	mov    $0x0,%eax
    8bfd:	eb 1a                	jmp    8c19 <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    8bff:	83 ec 0c             	sub    $0xc,%esp
    8c02:	ff 75 18             	pushl  0x18(%ebp)
    8c05:	ff 75 14             	pushl  0x14(%ebp)
    8c08:	ff 75 10             	pushl  0x10(%ebp)
    8c0b:	ff 75 0c             	pushl  0xc(%ebp)
    8c0e:	ff 75 08             	pushl  0x8(%ebp)
    8c11:	e8 27 fe ff ff       	call   8a3d <lodepng_zlib_compress>
    8c16:	83 c4 20             	add    $0x20,%esp
  }
}
    8c19:	c9                   	leave  
    8c1a:	c3                   	ret    

00008c1b <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    8c1b:	55                   	push   %ebp
    8c1c:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    8c1e:	8b 45 08             	mov    0x8(%ebp),%eax
    8c21:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    8c27:	8b 45 08             	mov    0x8(%ebp),%eax
    8c2a:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    8c31:	8b 45 08             	mov    0x8(%ebp),%eax
    8c34:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    8c3b:	8b 45 08             	mov    0x8(%ebp),%eax
    8c3e:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    8c45:	8b 45 08             	mov    0x8(%ebp),%eax
    8c48:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    8c4f:	8b 45 08             	mov    0x8(%ebp),%eax
    8c52:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    8c59:	8b 45 08             	mov    0x8(%ebp),%eax
    8c5c:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    8c63:	8b 45 08             	mov    0x8(%ebp),%eax
    8c66:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    8c6d:	8b 45 08             	mov    0x8(%ebp),%eax
    8c70:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    8c77:	90                   	nop
    8c78:	5d                   	pop    %ebp
    8c79:	c3                   	ret    

00008c7a <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    8c7a:	55                   	push   %ebp
    8c7b:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    8c7d:	8b 45 08             	mov    0x8(%ebp),%eax
    8c80:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    8c86:	8b 45 08             	mov    0x8(%ebp),%eax
    8c89:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    8c90:	8b 45 08             	mov    0x8(%ebp),%eax
    8c93:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    8c9a:	8b 45 08             	mov    0x8(%ebp),%eax
    8c9d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    8ca4:	8b 45 08             	mov    0x8(%ebp),%eax
    8ca7:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    8cae:	8b 45 08             	mov    0x8(%ebp),%eax
    8cb1:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    8cb8:	90                   	nop
    8cb9:	5d                   	pop    %ebp
    8cba:	c3                   	ret    

00008cbb <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    8cbb:	55                   	push   %ebp
    8cbc:	89 e5                	mov    %esp,%ebp
    8cbe:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    8cc1:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    8cc8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8ccf:	eb 2a                	jmp    8cfb <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    8cd1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8cd4:	8b 45 08             	mov    0x8(%ebp),%eax
    8cd7:	01 d0                	add    %edx,%eax
    8cd9:	0f b6 00             	movzbl (%eax),%eax
    8cdc:	0f b6 c0             	movzbl %al,%eax
    8cdf:	33 45 fc             	xor    -0x4(%ebp),%eax
    8ce2:	0f b6 c0             	movzbl %al,%eax
    8ce5:	8b 04 85 a0 ef 01 00 	mov    0x1efa0(,%eax,4),%eax
    8cec:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8cef:	c1 ea 08             	shr    $0x8,%edx
    8cf2:	31 d0                	xor    %edx,%eax
    8cf4:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    8cf7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8cfb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8cfe:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8d01:	7c ce                	jl     8cd1 <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    8d03:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d06:	f7 d0                	not    %eax
}
    8d08:	c9                   	leave  
    8d09:	c3                   	ret    

00008d0a <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    8d0a:	55                   	push   %ebp
    8d0b:	89 e5                	mov    %esp,%ebp
    8d0d:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    8d10:	8b 45 08             	mov    0x8(%ebp),%eax
    8d13:	8b 00                	mov    (%eax),%eax
    8d15:	c1 f8 03             	sar    $0x3,%eax
    8d18:	89 c2                	mov    %eax,%edx
    8d1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d1d:	01 d0                	add    %edx,%eax
    8d1f:	0f b6 00             	movzbl (%eax),%eax
    8d22:	0f b6 d0             	movzbl %al,%edx
    8d25:	8b 45 08             	mov    0x8(%ebp),%eax
    8d28:	8b 00                	mov    (%eax),%eax
    8d2a:	f7 d0                	not    %eax
    8d2c:	83 e0 07             	and    $0x7,%eax
    8d2f:	89 c1                	mov    %eax,%ecx
    8d31:	d3 fa                	sar    %cl,%edx
    8d33:	89 d0                	mov    %edx,%eax
    8d35:	83 e0 01             	and    $0x1,%eax
    8d38:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    8d3b:	8b 45 08             	mov    0x8(%ebp),%eax
    8d3e:	8b 00                	mov    (%eax),%eax
    8d40:	8d 50 01             	lea    0x1(%eax),%edx
    8d43:	8b 45 08             	mov    0x8(%ebp),%eax
    8d46:	89 10                	mov    %edx,(%eax)
  return result;
    8d48:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    8d4c:	c9                   	leave  
    8d4d:	c3                   	ret    

00008d4e <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    8d4e:	55                   	push   %ebp
    8d4f:	89 e5                	mov    %esp,%ebp
    8d51:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    8d54:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    8d5b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8d62:	eb 1b                	jmp    8d7f <readBitsFromReversedStream+0x31>
    result <<= 1u;
    8d64:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    8d67:	ff 75 0c             	pushl  0xc(%ebp)
    8d6a:	ff 75 08             	pushl  0x8(%ebp)
    8d6d:	e8 98 ff ff ff       	call   8d0a <readBitFromReversedStream>
    8d72:	83 c4 08             	add    $0x8,%esp
    8d75:	0f b6 c0             	movzbl %al,%eax
    8d78:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    8d7b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8d7f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8d82:	3b 45 10             	cmp    0x10(%ebp),%eax
    8d85:	7c dd                	jl     8d64 <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    8d87:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    8d8a:	c9                   	leave  
    8d8b:	c3                   	ret    

00008d8c <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    8d8c:	55                   	push   %ebp
    8d8d:	89 e5                	mov    %esp,%ebp
    8d8f:	56                   	push   %esi
    8d90:	53                   	push   %ebx
    8d91:	83 ec 04             	sub    $0x4,%esp
    8d94:	8b 45 10             	mov    0x10(%ebp),%eax
    8d97:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    8d9a:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    8d9e:	75 3e                	jne    8dde <setBitOfReversedStream+0x52>
    8da0:	8b 45 08             	mov    0x8(%ebp),%eax
    8da3:	8b 00                	mov    (%eax),%eax
    8da5:	c1 f8 03             	sar    $0x3,%eax
    8da8:	89 c2                	mov    %eax,%edx
    8daa:	8b 45 0c             	mov    0xc(%ebp),%eax
    8dad:	01 c2                	add    %eax,%edx
    8daf:	8b 45 08             	mov    0x8(%ebp),%eax
    8db2:	8b 00                	mov    (%eax),%eax
    8db4:	c1 f8 03             	sar    $0x3,%eax
    8db7:	89 c1                	mov    %eax,%ecx
    8db9:	8b 45 0c             	mov    0xc(%ebp),%eax
    8dbc:	01 c8                	add    %ecx,%eax
    8dbe:	0f b6 18             	movzbl (%eax),%ebx
    8dc1:	8b 45 08             	mov    0x8(%ebp),%eax
    8dc4:	8b 00                	mov    (%eax),%eax
    8dc6:	f7 d0                	not    %eax
    8dc8:	83 e0 07             	and    $0x7,%eax
    8dcb:	be 01 00 00 00       	mov    $0x1,%esi
    8dd0:	89 c1                	mov    %eax,%ecx
    8dd2:	d3 e6                	shl    %cl,%esi
    8dd4:	89 f0                	mov    %esi,%eax
    8dd6:	f7 d0                	not    %eax
    8dd8:	21 d8                	and    %ebx,%eax
    8dda:	88 02                	mov    %al,(%edx)
    8ddc:	eb 3a                	jmp    8e18 <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    8dde:	8b 45 08             	mov    0x8(%ebp),%eax
    8de1:	8b 00                	mov    (%eax),%eax
    8de3:	c1 f8 03             	sar    $0x3,%eax
    8de6:	89 c2                	mov    %eax,%edx
    8de8:	8b 45 0c             	mov    0xc(%ebp),%eax
    8deb:	01 c2                	add    %eax,%edx
    8ded:	8b 45 08             	mov    0x8(%ebp),%eax
    8df0:	8b 00                	mov    (%eax),%eax
    8df2:	c1 f8 03             	sar    $0x3,%eax
    8df5:	89 c1                	mov    %eax,%ecx
    8df7:	8b 45 0c             	mov    0xc(%ebp),%eax
    8dfa:	01 c8                	add    %ecx,%eax
    8dfc:	0f b6 18             	movzbl (%eax),%ebx
    8dff:	8b 45 08             	mov    0x8(%ebp),%eax
    8e02:	8b 00                	mov    (%eax),%eax
    8e04:	f7 d0                	not    %eax
    8e06:	83 e0 07             	and    $0x7,%eax
    8e09:	be 01 00 00 00       	mov    $0x1,%esi
    8e0e:	89 c1                	mov    %eax,%ecx
    8e10:	d3 e6                	shl    %cl,%esi
    8e12:	89 f0                	mov    %esi,%eax
    8e14:	09 d8                	or     %ebx,%eax
    8e16:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    8e18:	8b 45 08             	mov    0x8(%ebp),%eax
    8e1b:	8b 00                	mov    (%eax),%eax
    8e1d:	8d 50 01             	lea    0x1(%eax),%edx
    8e20:	8b 45 08             	mov    0x8(%ebp),%eax
    8e23:	89 10                	mov    %edx,(%eax)
}
    8e25:	90                   	nop
    8e26:	83 c4 04             	add    $0x4,%esp
    8e29:	5b                   	pop    %ebx
    8e2a:	5e                   	pop    %esi
    8e2b:	5d                   	pop    %ebp
    8e2c:	c3                   	ret    

00008e2d <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    8e2d:	55                   	push   %ebp
    8e2e:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    8e30:	ff 75 08             	pushl  0x8(%ebp)
    8e33:	e8 f1 b3 ff ff       	call   4229 <lodepng_read32bitInt>
    8e38:	83 c4 04             	add    $0x4,%esp
}
    8e3b:	c9                   	leave  
    8e3c:	c3                   	ret    

00008e3d <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    8e3d:	55                   	push   %ebp
    8e3e:	89 e5                	mov    %esp,%ebp
    8e40:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    8e43:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8e4a:	eb 1c                	jmp    8e68 <lodepng_chunk_type+0x2b>
    8e4c:	8b 55 08             	mov    0x8(%ebp),%edx
    8e4f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8e52:	01 d0                	add    %edx,%eax
    8e54:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8e57:	8d 4a 04             	lea    0x4(%edx),%ecx
    8e5a:	8b 55 0c             	mov    0xc(%ebp),%edx
    8e5d:	01 ca                	add    %ecx,%edx
    8e5f:	0f b6 12             	movzbl (%edx),%edx
    8e62:	88 10                	mov    %dl,(%eax)
    8e64:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8e68:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    8e6c:	75 de                	jne    8e4c <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    8e6e:	8b 45 08             	mov    0x8(%ebp),%eax
    8e71:	83 c0 04             	add    $0x4,%eax
    8e74:	c6 00 00             	movb   $0x0,(%eax)
}
    8e77:	90                   	nop
    8e78:	c9                   	leave  
    8e79:	c3                   	ret    

00008e7a <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    8e7a:	55                   	push   %ebp
    8e7b:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    8e7d:	ff 75 0c             	pushl  0xc(%ebp)
    8e80:	e8 c2 b0 ff ff       	call   3f47 <lodepng_strlen>
    8e85:	83 c4 04             	add    $0x4,%esp
    8e88:	83 f8 04             	cmp    $0x4,%eax
    8e8b:	74 07                	je     8e94 <lodepng_chunk_type_equals+0x1a>
    8e8d:	b8 00 00 00 00       	mov    $0x0,%eax
    8e92:	eb 79                	jmp    8f0d <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    8e94:	8b 45 08             	mov    0x8(%ebp),%eax
    8e97:	83 c0 04             	add    $0x4,%eax
    8e9a:	0f b6 00             	movzbl (%eax),%eax
    8e9d:	0f b6 d0             	movzbl %al,%edx
    8ea0:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ea3:	0f b6 00             	movzbl (%eax),%eax
    8ea6:	0f be c0             	movsbl %al,%eax
    8ea9:	39 c2                	cmp    %eax,%edx
    8eab:	75 5b                	jne    8f08 <lodepng_chunk_type_equals+0x8e>
    8ead:	8b 45 08             	mov    0x8(%ebp),%eax
    8eb0:	83 c0 05             	add    $0x5,%eax
    8eb3:	0f b6 00             	movzbl (%eax),%eax
    8eb6:	0f b6 d0             	movzbl %al,%edx
    8eb9:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ebc:	83 c0 01             	add    $0x1,%eax
    8ebf:	0f b6 00             	movzbl (%eax),%eax
    8ec2:	0f be c0             	movsbl %al,%eax
    8ec5:	39 c2                	cmp    %eax,%edx
    8ec7:	75 3f                	jne    8f08 <lodepng_chunk_type_equals+0x8e>
    8ec9:	8b 45 08             	mov    0x8(%ebp),%eax
    8ecc:	83 c0 06             	add    $0x6,%eax
    8ecf:	0f b6 00             	movzbl (%eax),%eax
    8ed2:	0f b6 d0             	movzbl %al,%edx
    8ed5:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ed8:	83 c0 02             	add    $0x2,%eax
    8edb:	0f b6 00             	movzbl (%eax),%eax
    8ede:	0f be c0             	movsbl %al,%eax
    8ee1:	39 c2                	cmp    %eax,%edx
    8ee3:	75 23                	jne    8f08 <lodepng_chunk_type_equals+0x8e>
    8ee5:	8b 45 08             	mov    0x8(%ebp),%eax
    8ee8:	83 c0 07             	add    $0x7,%eax
    8eeb:	0f b6 00             	movzbl (%eax),%eax
    8eee:	0f b6 d0             	movzbl %al,%edx
    8ef1:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ef4:	83 c0 03             	add    $0x3,%eax
    8ef7:	0f b6 00             	movzbl (%eax),%eax
    8efa:	0f be c0             	movsbl %al,%eax
    8efd:	39 c2                	cmp    %eax,%edx
    8eff:	75 07                	jne    8f08 <lodepng_chunk_type_equals+0x8e>
    8f01:	b8 01 00 00 00       	mov    $0x1,%eax
    8f06:	eb 05                	jmp    8f0d <lodepng_chunk_type_equals+0x93>
    8f08:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f0d:	c9                   	leave  
    8f0e:	c3                   	ret    

00008f0f <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    8f0f:	55                   	push   %ebp
    8f10:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    8f12:	8b 45 08             	mov    0x8(%ebp),%eax
    8f15:	83 c0 04             	add    $0x4,%eax
    8f18:	0f b6 00             	movzbl (%eax),%eax
    8f1b:	0f b6 c0             	movzbl %al,%eax
    8f1e:	83 e0 20             	and    $0x20,%eax
    8f21:	85 c0                	test   %eax,%eax
    8f23:	0f 95 c0             	setne  %al
}
    8f26:	5d                   	pop    %ebp
    8f27:	c3                   	ret    

00008f28 <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    8f28:	55                   	push   %ebp
    8f29:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    8f2b:	8b 45 08             	mov    0x8(%ebp),%eax
    8f2e:	83 c0 06             	add    $0x6,%eax
    8f31:	0f b6 00             	movzbl (%eax),%eax
    8f34:	0f b6 c0             	movzbl %al,%eax
    8f37:	83 e0 20             	and    $0x20,%eax
    8f3a:	85 c0                	test   %eax,%eax
    8f3c:	0f 95 c0             	setne  %al
}
    8f3f:	5d                   	pop    %ebp
    8f40:	c3                   	ret    

00008f41 <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    8f41:	55                   	push   %ebp
    8f42:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    8f44:	8b 45 08             	mov    0x8(%ebp),%eax
    8f47:	83 c0 07             	add    $0x7,%eax
    8f4a:	0f b6 00             	movzbl (%eax),%eax
    8f4d:	0f b6 c0             	movzbl %al,%eax
    8f50:	83 e0 20             	and    $0x20,%eax
    8f53:	85 c0                	test   %eax,%eax
    8f55:	0f 95 c0             	setne  %al
}
    8f58:	5d                   	pop    %ebp
    8f59:	c3                   	ret    

00008f5a <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    8f5a:	55                   	push   %ebp
    8f5b:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    8f5d:	8b 45 08             	mov    0x8(%ebp),%eax
    8f60:	83 c0 08             	add    $0x8,%eax
}
    8f63:	5d                   	pop    %ebp
    8f64:	c3                   	ret    

00008f65 <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    8f65:	55                   	push   %ebp
    8f66:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    8f68:	8b 45 08             	mov    0x8(%ebp),%eax
    8f6b:	83 c0 08             	add    $0x8,%eax
}
    8f6e:	5d                   	pop    %ebp
    8f6f:	c3                   	ret    

00008f70 <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    8f70:	55                   	push   %ebp
    8f71:	89 e5                	mov    %esp,%ebp
    8f73:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    8f76:	ff 75 08             	pushl  0x8(%ebp)
    8f79:	e8 af fe ff ff       	call   8e2d <lodepng_chunk_length>
    8f7e:	83 c4 04             	add    $0x4,%esp
    8f81:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    8f84:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8f87:	8d 50 08             	lea    0x8(%eax),%edx
    8f8a:	8b 45 08             	mov    0x8(%ebp),%eax
    8f8d:	01 d0                	add    %edx,%eax
    8f8f:	50                   	push   %eax
    8f90:	e8 94 b2 ff ff       	call   4229 <lodepng_read32bitInt>
    8f95:	83 c4 04             	add    $0x4,%esp
    8f98:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    8f9b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8f9e:	83 c0 04             	add    $0x4,%eax
    8fa1:	89 c2                	mov    %eax,%edx
    8fa3:	8b 45 08             	mov    0x8(%ebp),%eax
    8fa6:	83 c0 04             	add    $0x4,%eax
    8fa9:	52                   	push   %edx
    8faa:	50                   	push   %eax
    8fab:	e8 0b fd ff ff       	call   8cbb <lodepng_crc32>
    8fb0:	83 c4 08             	add    $0x8,%esp
    8fb3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    8fb6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8fb9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    8fbc:	74 07                	je     8fc5 <lodepng_chunk_check_crc+0x55>
    8fbe:	b8 01 00 00 00       	mov    $0x1,%eax
    8fc3:	eb 05                	jmp    8fca <lodepng_chunk_check_crc+0x5a>
  else return 0;
    8fc5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8fca:	c9                   	leave  
    8fcb:	c3                   	ret    

00008fcc <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    8fcc:	55                   	push   %ebp
    8fcd:	89 e5                	mov    %esp,%ebp
    8fcf:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    8fd2:	ff 75 08             	pushl  0x8(%ebp)
    8fd5:	e8 53 fe ff ff       	call   8e2d <lodepng_chunk_length>
    8fda:	83 c4 04             	add    $0x4,%esp
    8fdd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    8fe0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8fe3:	83 c0 04             	add    $0x4,%eax
    8fe6:	89 c2                	mov    %eax,%edx
    8fe8:	8b 45 08             	mov    0x8(%ebp),%eax
    8feb:	83 c0 04             	add    $0x4,%eax
    8fee:	52                   	push   %edx
    8fef:	50                   	push   %eax
    8ff0:	e8 c6 fc ff ff       	call   8cbb <lodepng_crc32>
    8ff5:	83 c4 08             	add    $0x8,%esp
    8ff8:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    8ffb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8ffe:	8d 50 08             	lea    0x8(%eax),%edx
    9001:	8b 45 08             	mov    0x8(%ebp),%eax
    9004:	01 d0                	add    %edx,%eax
    9006:	ff 75 f8             	pushl  -0x8(%ebp)
    9009:	50                   	push   %eax
    900a:	e8 5d b2 ff ff       	call   426c <lodepng_set32bitInt>
    900f:	83 c4 08             	add    $0x8,%esp
}
    9012:	90                   	nop
    9013:	c9                   	leave  
    9014:	c3                   	ret    

00009015 <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    9015:	55                   	push   %ebp
    9016:	89 e5                	mov    %esp,%ebp
    9018:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    901b:	8b 45 08             	mov    0x8(%ebp),%eax
    901e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9021:	73 0f                	jae    9032 <lodepng_chunk_next+0x1d>
    9023:	8b 55 0c             	mov    0xc(%ebp),%edx
    9026:	8b 45 08             	mov    0x8(%ebp),%eax
    9029:	29 c2                	sub    %eax,%edx
    902b:	89 d0                	mov    %edx,%eax
    902d:	83 f8 0b             	cmp    $0xb,%eax
    9030:	7f 08                	jg     903a <lodepng_chunk_next+0x25>
    9032:	8b 45 0c             	mov    0xc(%ebp),%eax
    9035:	e9 af 00 00 00       	jmp    90e9 <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    903a:	8b 45 08             	mov    0x8(%ebp),%eax
    903d:	0f b6 00             	movzbl (%eax),%eax
    9040:	3c 89                	cmp    $0x89,%al
    9042:	75 63                	jne    90a7 <lodepng_chunk_next+0x92>
    9044:	8b 45 08             	mov    0x8(%ebp),%eax
    9047:	83 c0 01             	add    $0x1,%eax
    904a:	0f b6 00             	movzbl (%eax),%eax
    904d:	3c 50                	cmp    $0x50,%al
    904f:	75 56                	jne    90a7 <lodepng_chunk_next+0x92>
    9051:	8b 45 08             	mov    0x8(%ebp),%eax
    9054:	83 c0 02             	add    $0x2,%eax
    9057:	0f b6 00             	movzbl (%eax),%eax
    905a:	3c 4e                	cmp    $0x4e,%al
    905c:	75 49                	jne    90a7 <lodepng_chunk_next+0x92>
    905e:	8b 45 08             	mov    0x8(%ebp),%eax
    9061:	83 c0 03             	add    $0x3,%eax
    9064:	0f b6 00             	movzbl (%eax),%eax
    9067:	3c 47                	cmp    $0x47,%al
    9069:	75 3c                	jne    90a7 <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    906b:	8b 45 08             	mov    0x8(%ebp),%eax
    906e:	83 c0 04             	add    $0x4,%eax
    9071:	0f b6 00             	movzbl (%eax),%eax
    9074:	3c 0d                	cmp    $0xd,%al
    9076:	75 2f                	jne    90a7 <lodepng_chunk_next+0x92>
    9078:	8b 45 08             	mov    0x8(%ebp),%eax
    907b:	83 c0 05             	add    $0x5,%eax
    907e:	0f b6 00             	movzbl (%eax),%eax
    9081:	3c 0a                	cmp    $0xa,%al
    9083:	75 22                	jne    90a7 <lodepng_chunk_next+0x92>
    9085:	8b 45 08             	mov    0x8(%ebp),%eax
    9088:	83 c0 06             	add    $0x6,%eax
    908b:	0f b6 00             	movzbl (%eax),%eax
    908e:	3c 1a                	cmp    $0x1a,%al
    9090:	75 15                	jne    90a7 <lodepng_chunk_next+0x92>
    9092:	8b 45 08             	mov    0x8(%ebp),%eax
    9095:	83 c0 07             	add    $0x7,%eax
    9098:	0f b6 00             	movzbl (%eax),%eax
    909b:	3c 0a                	cmp    $0xa,%al
    909d:	75 08                	jne    90a7 <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    909f:	8b 45 08             	mov    0x8(%ebp),%eax
    90a2:	83 c0 08             	add    $0x8,%eax
    90a5:	eb 42                	jmp    90e9 <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    90a7:	ff 75 08             	pushl  0x8(%ebp)
    90aa:	e8 7e fd ff ff       	call   8e2d <lodepng_chunk_length>
    90af:	83 c4 04             	add    $0x4,%esp
    90b2:	89 c2                	mov    %eax,%edx
    90b4:	8d 45 f8             	lea    -0x8(%ebp),%eax
    90b7:	50                   	push   %eax
    90b8:	6a 0c                	push   $0xc
    90ba:	52                   	push   %edx
    90bb:	e8 af ae ff ff       	call   3f6f <lodepng_addofl>
    90c0:	83 c4 0c             	add    $0xc,%esp
    90c3:	85 c0                	test   %eax,%eax
    90c5:	74 05                	je     90cc <lodepng_chunk_next+0xb7>
    90c7:	8b 45 0c             	mov    0xc(%ebp),%eax
    90ca:	eb 1d                	jmp    90e9 <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    90cc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    90cf:	89 c2                	mov    %eax,%edx
    90d1:	8b 45 08             	mov    0x8(%ebp),%eax
    90d4:	01 d0                	add    %edx,%eax
    90d6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    90d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    90dc:	3b 45 08             	cmp    0x8(%ebp),%eax
    90df:	73 05                	jae    90e6 <lodepng_chunk_next+0xd1>
    90e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    90e4:	eb 03                	jmp    90e9 <lodepng_chunk_next+0xd4>
    return result;
    90e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    90e9:	c9                   	leave  
    90ea:	c3                   	ret    

000090eb <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    90eb:	55                   	push   %ebp
    90ec:	89 e5                	mov    %esp,%ebp
    90ee:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    90f1:	8b 45 08             	mov    0x8(%ebp),%eax
    90f4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    90f7:	73 0f                	jae    9108 <lodepng_chunk_next_const+0x1d>
    90f9:	8b 55 0c             	mov    0xc(%ebp),%edx
    90fc:	8b 45 08             	mov    0x8(%ebp),%eax
    90ff:	29 c2                	sub    %eax,%edx
    9101:	89 d0                	mov    %edx,%eax
    9103:	83 f8 0b             	cmp    $0xb,%eax
    9106:	7f 08                	jg     9110 <lodepng_chunk_next_const+0x25>
    9108:	8b 45 0c             	mov    0xc(%ebp),%eax
    910b:	e9 af 00 00 00       	jmp    91bf <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    9110:	8b 45 08             	mov    0x8(%ebp),%eax
    9113:	0f b6 00             	movzbl (%eax),%eax
    9116:	3c 89                	cmp    $0x89,%al
    9118:	75 63                	jne    917d <lodepng_chunk_next_const+0x92>
    911a:	8b 45 08             	mov    0x8(%ebp),%eax
    911d:	83 c0 01             	add    $0x1,%eax
    9120:	0f b6 00             	movzbl (%eax),%eax
    9123:	3c 50                	cmp    $0x50,%al
    9125:	75 56                	jne    917d <lodepng_chunk_next_const+0x92>
    9127:	8b 45 08             	mov    0x8(%ebp),%eax
    912a:	83 c0 02             	add    $0x2,%eax
    912d:	0f b6 00             	movzbl (%eax),%eax
    9130:	3c 4e                	cmp    $0x4e,%al
    9132:	75 49                	jne    917d <lodepng_chunk_next_const+0x92>
    9134:	8b 45 08             	mov    0x8(%ebp),%eax
    9137:	83 c0 03             	add    $0x3,%eax
    913a:	0f b6 00             	movzbl (%eax),%eax
    913d:	3c 47                	cmp    $0x47,%al
    913f:	75 3c                	jne    917d <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    9141:	8b 45 08             	mov    0x8(%ebp),%eax
    9144:	83 c0 04             	add    $0x4,%eax
    9147:	0f b6 00             	movzbl (%eax),%eax
    914a:	3c 0d                	cmp    $0xd,%al
    914c:	75 2f                	jne    917d <lodepng_chunk_next_const+0x92>
    914e:	8b 45 08             	mov    0x8(%ebp),%eax
    9151:	83 c0 05             	add    $0x5,%eax
    9154:	0f b6 00             	movzbl (%eax),%eax
    9157:	3c 0a                	cmp    $0xa,%al
    9159:	75 22                	jne    917d <lodepng_chunk_next_const+0x92>
    915b:	8b 45 08             	mov    0x8(%ebp),%eax
    915e:	83 c0 06             	add    $0x6,%eax
    9161:	0f b6 00             	movzbl (%eax),%eax
    9164:	3c 1a                	cmp    $0x1a,%al
    9166:	75 15                	jne    917d <lodepng_chunk_next_const+0x92>
    9168:	8b 45 08             	mov    0x8(%ebp),%eax
    916b:	83 c0 07             	add    $0x7,%eax
    916e:	0f b6 00             	movzbl (%eax),%eax
    9171:	3c 0a                	cmp    $0xa,%al
    9173:	75 08                	jne    917d <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    9175:	8b 45 08             	mov    0x8(%ebp),%eax
    9178:	83 c0 08             	add    $0x8,%eax
    917b:	eb 42                	jmp    91bf <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    917d:	ff 75 08             	pushl  0x8(%ebp)
    9180:	e8 a8 fc ff ff       	call   8e2d <lodepng_chunk_length>
    9185:	83 c4 04             	add    $0x4,%esp
    9188:	89 c2                	mov    %eax,%edx
    918a:	8d 45 f8             	lea    -0x8(%ebp),%eax
    918d:	50                   	push   %eax
    918e:	6a 0c                	push   $0xc
    9190:	52                   	push   %edx
    9191:	e8 d9 ad ff ff       	call   3f6f <lodepng_addofl>
    9196:	83 c4 0c             	add    $0xc,%esp
    9199:	85 c0                	test   %eax,%eax
    919b:	74 05                	je     91a2 <lodepng_chunk_next_const+0xb7>
    919d:	8b 45 0c             	mov    0xc(%ebp),%eax
    91a0:	eb 1d                	jmp    91bf <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    91a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    91a5:	89 c2                	mov    %eax,%edx
    91a7:	8b 45 08             	mov    0x8(%ebp),%eax
    91aa:	01 d0                	add    %edx,%eax
    91ac:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    91af:	8b 45 fc             	mov    -0x4(%ebp),%eax
    91b2:	3b 45 08             	cmp    0x8(%ebp),%eax
    91b5:	73 05                	jae    91bc <lodepng_chunk_next_const+0xd1>
    91b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    91ba:	eb 03                	jmp    91bf <lodepng_chunk_next_const+0xd4>
    return result;
    91bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    91bf:	c9                   	leave  
    91c0:	c3                   	ret    

000091c1 <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    91c1:	55                   	push   %ebp
    91c2:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    91c4:	8b 45 08             	mov    0x8(%ebp),%eax
    91c7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    91ca:	73 0f                	jae    91db <lodepng_chunk_find+0x1a>
    91cc:	8b 55 0c             	mov    0xc(%ebp),%edx
    91cf:	8b 45 08             	mov    0x8(%ebp),%eax
    91d2:	29 c2                	sub    %eax,%edx
    91d4:	89 d0                	mov    %edx,%eax
    91d6:	83 f8 0b             	cmp    $0xb,%eax
    91d9:	7f 07                	jg     91e2 <lodepng_chunk_find+0x21>
    91db:	b8 00 00 00 00       	mov    $0x0,%eax
    91e0:	eb 2a                	jmp    920c <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    91e2:	ff 75 10             	pushl  0x10(%ebp)
    91e5:	ff 75 08             	pushl  0x8(%ebp)
    91e8:	e8 8d fc ff ff       	call   8e7a <lodepng_chunk_type_equals>
    91ed:	83 c4 08             	add    $0x8,%esp
    91f0:	84 c0                	test   %al,%al
    91f2:	74 05                	je     91f9 <lodepng_chunk_find+0x38>
    91f4:	8b 45 08             	mov    0x8(%ebp),%eax
    91f7:	eb 13                	jmp    920c <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    91f9:	ff 75 0c             	pushl  0xc(%ebp)
    91fc:	ff 75 08             	pushl  0x8(%ebp)
    91ff:	e8 11 fe ff ff       	call   9015 <lodepng_chunk_next>
    9204:	83 c4 08             	add    $0x8,%esp
    9207:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    920a:	eb b8                	jmp    91c4 <lodepng_chunk_find+0x3>
}
    920c:	c9                   	leave  
    920d:	c3                   	ret    

0000920e <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    920e:	55                   	push   %ebp
    920f:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    9211:	8b 45 08             	mov    0x8(%ebp),%eax
    9214:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9217:	73 0f                	jae    9228 <lodepng_chunk_find_const+0x1a>
    9219:	8b 55 0c             	mov    0xc(%ebp),%edx
    921c:	8b 45 08             	mov    0x8(%ebp),%eax
    921f:	29 c2                	sub    %eax,%edx
    9221:	89 d0                	mov    %edx,%eax
    9223:	83 f8 0b             	cmp    $0xb,%eax
    9226:	7f 07                	jg     922f <lodepng_chunk_find_const+0x21>
    9228:	b8 00 00 00 00       	mov    $0x0,%eax
    922d:	eb 2a                	jmp    9259 <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    922f:	ff 75 10             	pushl  0x10(%ebp)
    9232:	ff 75 08             	pushl  0x8(%ebp)
    9235:	e8 40 fc ff ff       	call   8e7a <lodepng_chunk_type_equals>
    923a:	83 c4 08             	add    $0x8,%esp
    923d:	84 c0                	test   %al,%al
    923f:	74 05                	je     9246 <lodepng_chunk_find_const+0x38>
    9241:	8b 45 08             	mov    0x8(%ebp),%eax
    9244:	eb 13                	jmp    9259 <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    9246:	ff 75 0c             	pushl  0xc(%ebp)
    9249:	ff 75 08             	pushl  0x8(%ebp)
    924c:	e8 9a fe ff ff       	call   90eb <lodepng_chunk_next_const>
    9251:	83 c4 08             	add    $0x8,%esp
    9254:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    9257:	eb b8                	jmp    9211 <lodepng_chunk_find_const+0x3>
}
    9259:	c9                   	leave  
    925a:	c3                   	ret    

0000925b <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    925b:	55                   	push   %ebp
    925c:	89 e5                	mov    %esp,%ebp
    925e:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    9261:	ff 75 10             	pushl  0x10(%ebp)
    9264:	e8 c4 fb ff ff       	call   8e2d <lodepng_chunk_length>
    9269:	83 c4 04             	add    $0x4,%esp
    926c:	89 c2                	mov    %eax,%edx
    926e:	8d 45 f0             	lea    -0x10(%ebp),%eax
    9271:	50                   	push   %eax
    9272:	6a 0c                	push   $0xc
    9274:	52                   	push   %edx
    9275:	e8 f5 ac ff ff       	call   3f6f <lodepng_addofl>
    927a:	83 c4 0c             	add    $0xc,%esp
    927d:	85 c0                	test   %eax,%eax
    927f:	74 0a                	je     928b <lodepng_chunk_append+0x30>
    9281:	b8 4d 00 00 00       	mov    $0x4d,%eax
    9286:	e9 96 00 00 00       	jmp    9321 <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    928b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    928e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9291:	8b 00                	mov    (%eax),%eax
    9293:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    9296:	51                   	push   %ecx
    9297:	52                   	push   %edx
    9298:	50                   	push   %eax
    9299:	e8 d1 ac ff ff       	call   3f6f <lodepng_addofl>
    929e:	83 c4 0c             	add    $0xc,%esp
    92a1:	85 c0                	test   %eax,%eax
    92a3:	74 07                	je     92ac <lodepng_chunk_append+0x51>
    92a5:	b8 4d 00 00 00       	mov    $0x4d,%eax
    92aa:	eb 75                	jmp    9321 <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    92ac:	8b 55 ec             	mov    -0x14(%ebp),%edx
    92af:	8b 45 08             	mov    0x8(%ebp),%eax
    92b2:	8b 00                	mov    (%eax),%eax
    92b4:	52                   	push   %edx
    92b5:	50                   	push   %eax
    92b6:	e8 07 ac ff ff       	call   3ec2 <lodepng_realloc>
    92bb:	83 c4 08             	add    $0x8,%esp
    92be:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    92c1:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    92c5:	75 07                	jne    92ce <lodepng_chunk_append+0x73>
    92c7:	b8 53 00 00 00       	mov    $0x53,%eax
    92cc:	eb 53                	jmp    9321 <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    92ce:	8b 45 08             	mov    0x8(%ebp),%eax
    92d1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    92d4:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    92d6:	8b 55 ec             	mov    -0x14(%ebp),%edx
    92d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    92dc:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    92de:	8b 45 08             	mov    0x8(%ebp),%eax
    92e1:	8b 00                	mov    (%eax),%eax
    92e3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    92e6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    92e9:	29 d1                	sub    %edx,%ecx
    92eb:	89 ca                	mov    %ecx,%edx
    92ed:	01 d0                	add    %edx,%eax
    92ef:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    92f2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    92f9:	eb 19                	jmp    9314 <lodepng_chunk_append+0xb9>
    92fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9301:	01 c2                	add    %eax,%edx
    9303:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9306:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9309:	01 c8                	add    %ecx,%eax
    930b:	0f b6 00             	movzbl (%eax),%eax
    930e:	88 02                	mov    %al,(%edx)
    9310:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9314:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9317:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    931a:	75 df                	jne    92fb <lodepng_chunk_append+0xa0>

  return 0;
    931c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9321:	c9                   	leave  
    9322:	c3                   	ret    

00009323 <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    9323:	55                   	push   %ebp
    9324:	89 e5                	mov    %esp,%ebp
    9326:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    9329:	8b 45 0c             	mov    0xc(%ebp),%eax
    932c:	8b 40 04             	mov    0x4(%eax),%eax
    932f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    9332:	8b 55 10             	mov    0x10(%ebp),%edx
    9335:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9338:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    933b:	51                   	push   %ecx
    933c:	52                   	push   %edx
    933d:	50                   	push   %eax
    933e:	e8 2c ac ff ff       	call   3f6f <lodepng_addofl>
    9343:	83 c4 0c             	add    $0xc,%esp
    9346:	85 c0                	test   %eax,%eax
    9348:	74 07                	je     9351 <lodepng_chunk_init+0x2e>
    934a:	b8 4d 00 00 00       	mov    $0x4d,%eax
    934f:	eb 78                	jmp    93c9 <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    9351:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9354:	8d 55 fc             	lea    -0x4(%ebp),%edx
    9357:	52                   	push   %edx
    9358:	6a 0c                	push   $0xc
    935a:	50                   	push   %eax
    935b:	e8 0f ac ff ff       	call   3f6f <lodepng_addofl>
    9360:	83 c4 0c             	add    $0xc,%esp
    9363:	85 c0                	test   %eax,%eax
    9365:	74 07                	je     936e <lodepng_chunk_init+0x4b>
    9367:	b8 4d 00 00 00       	mov    $0x4d,%eax
    936c:	eb 5b                	jmp    93c9 <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    936e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9371:	50                   	push   %eax
    9372:	ff 75 0c             	pushl  0xc(%ebp)
    9375:	e8 8b ad ff ff       	call   4105 <ucvector_resize>
    937a:	83 c4 08             	add    $0x8,%esp
    937d:	85 c0                	test   %eax,%eax
    937f:	75 07                	jne    9388 <lodepng_chunk_init+0x65>
    9381:	b8 53 00 00 00       	mov    $0x53,%eax
    9386:	eb 41                	jmp    93c9 <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    9388:	8b 45 0c             	mov    0xc(%ebp),%eax
    938b:	8b 00                	mov    (%eax),%eax
    938d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9390:	2b 55 10             	sub    0x10(%ebp),%edx
    9393:	83 ea 0c             	sub    $0xc,%edx
    9396:	01 c2                	add    %eax,%edx
    9398:	8b 45 08             	mov    0x8(%ebp),%eax
    939b:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    939d:	8b 45 08             	mov    0x8(%ebp),%eax
    93a0:	8b 00                	mov    (%eax),%eax
    93a2:	ff 75 10             	pushl  0x10(%ebp)
    93a5:	50                   	push   %eax
    93a6:	e8 c1 ae ff ff       	call   426c <lodepng_set32bitInt>
    93ab:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    93ae:	8b 45 08             	mov    0x8(%ebp),%eax
    93b1:	8b 00                	mov    (%eax),%eax
    93b3:	83 c0 04             	add    $0x4,%eax
    93b6:	6a 04                	push   $0x4
    93b8:	ff 75 14             	pushl  0x14(%ebp)
    93bb:	50                   	push   %eax
    93bc:	e8 28 ab ff ff       	call   3ee9 <lodepng_memcpy>
    93c1:	83 c4 0c             	add    $0xc,%esp

  return 0;
    93c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    93c9:	c9                   	leave  
    93ca:	c3                   	ret    

000093cb <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    93cb:	55                   	push   %ebp
    93cc:	89 e5                	mov    %esp,%ebp
    93ce:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    93d1:	ff 75 10             	pushl  0x10(%ebp)
    93d4:	ff 75 0c             	pushl  0xc(%ebp)
    93d7:	ff 75 08             	pushl  0x8(%ebp)
    93da:	8d 45 f8             	lea    -0x8(%ebp),%eax
    93dd:	50                   	push   %eax
    93de:	e8 40 ff ff ff       	call   9323 <lodepng_chunk_init>
    93e3:	83 c4 10             	add    $0x10,%esp
    93e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    93e9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    93ed:	74 05                	je     93f4 <lodepng_chunk_createv+0x29>
    93ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
    93f2:	eb 27                	jmp    941b <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    93f4:	8b 45 0c             	mov    0xc(%ebp),%eax
    93f7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    93fa:	83 c2 08             	add    $0x8,%edx
    93fd:	50                   	push   %eax
    93fe:	ff 75 14             	pushl  0x14(%ebp)
    9401:	52                   	push   %edx
    9402:	e8 e2 aa ff ff       	call   3ee9 <lodepng_memcpy>
    9407:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    940a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    940d:	50                   	push   %eax
    940e:	e8 b9 fb ff ff       	call   8fcc <lodepng_chunk_generate_crc>
    9413:	83 c4 04             	add    $0x4,%esp

  return 0;
    9416:	b8 00 00 00 00       	mov    $0x0,%eax
}
    941b:	c9                   	leave  
    941c:	c3                   	ret    

0000941d <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    941d:	55                   	push   %ebp
    941e:	89 e5                	mov    %esp,%ebp
    9420:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    9423:	8b 45 0c             	mov    0xc(%ebp),%eax
    9426:	8b 08                	mov    (%eax),%ecx
    9428:	8b 45 08             	mov    0x8(%ebp),%eax
    942b:	8b 10                	mov    (%eax),%edx
    942d:	8d 45 f0             	lea    -0x10(%ebp),%eax
    9430:	51                   	push   %ecx
    9431:	52                   	push   %edx
    9432:	50                   	push   %eax
    9433:	e8 34 ad ff ff       	call   416c <ucvector_init>
    9438:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    943b:	ff 75 18             	pushl  0x18(%ebp)
    943e:	ff 75 14             	pushl  0x14(%ebp)
    9441:	ff 75 10             	pushl  0x10(%ebp)
    9444:	8d 45 f0             	lea    -0x10(%ebp),%eax
    9447:	50                   	push   %eax
    9448:	e8 7e ff ff ff       	call   93cb <lodepng_chunk_createv>
    944d:	83 c4 10             	add    $0x10,%esp
    9450:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    9453:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9456:	8b 45 08             	mov    0x8(%ebp),%eax
    9459:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    945b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    945e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9461:	89 10                	mov    %edx,(%eax)
  return error;
    9463:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    9466:	c9                   	leave  
    9467:	c3                   	ret    

00009468 <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    9468:	55                   	push   %ebp
    9469:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    946b:	8b 45 08             	mov    0x8(%ebp),%eax
    946e:	83 f8 03             	cmp    $0x3,%eax
    9471:	74 6d                	je     94e0 <checkColorValidity+0x78>
    9473:	83 f8 03             	cmp    $0x3,%eax
    9476:	77 0e                	ja     9486 <checkColorValidity+0x1e>
    9478:	85 c0                	test   %eax,%eax
    947a:	74 28                	je     94a4 <checkColorValidity+0x3c>
    947c:	83 f8 02             	cmp    $0x2,%eax
    947f:	74 4c                	je     94cd <checkColorValidity+0x65>
    9481:	e9 a6 00 00 00       	jmp    952c <checkColorValidity+0xc4>
    9486:	83 f8 06             	cmp    $0x6,%eax
    9489:	0f 84 83 00 00 00    	je     9512 <checkColorValidity+0xaa>
    948f:	3d ff 00 00 00       	cmp    $0xff,%eax
    9494:	0f 84 8b 00 00 00    	je     9525 <checkColorValidity+0xbd>
    949a:	83 f8 04             	cmp    $0x4,%eax
    949d:	74 60                	je     94ff <checkColorValidity+0x97>
    949f:	e9 88 00 00 00       	jmp    952c <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    94a4:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    94a8:	0f 84 85 00 00 00    	je     9533 <checkColorValidity+0xcb>
    94ae:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    94b2:	74 7f                	je     9533 <checkColorValidity+0xcb>
    94b4:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    94b8:	74 79                	je     9533 <checkColorValidity+0xcb>
    94ba:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    94be:	74 73                	je     9533 <checkColorValidity+0xcb>
    94c0:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    94c4:	74 6d                	je     9533 <checkColorValidity+0xcb>
    94c6:	b8 25 00 00 00       	mov    $0x25,%eax
    94cb:	eb 78                	jmp    9545 <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    94cd:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    94d1:	74 63                	je     9536 <checkColorValidity+0xce>
    94d3:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    94d7:	74 5d                	je     9536 <checkColorValidity+0xce>
    94d9:	b8 25 00 00 00       	mov    $0x25,%eax
    94de:	eb 65                	jmp    9545 <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    94e0:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    94e4:	74 53                	je     9539 <checkColorValidity+0xd1>
    94e6:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    94ea:	74 4d                	je     9539 <checkColorValidity+0xd1>
    94ec:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    94f0:	74 47                	je     9539 <checkColorValidity+0xd1>
    94f2:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    94f6:	74 41                	je     9539 <checkColorValidity+0xd1>
    94f8:	b8 25 00 00 00       	mov    $0x25,%eax
    94fd:	eb 46                	jmp    9545 <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    94ff:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    9503:	74 37                	je     953c <checkColorValidity+0xd4>
    9505:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    9509:	74 31                	je     953c <checkColorValidity+0xd4>
    950b:	b8 25 00 00 00       	mov    $0x25,%eax
    9510:	eb 33                	jmp    9545 <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    9512:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    9516:	74 27                	je     953f <checkColorValidity+0xd7>
    9518:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    951c:	74 21                	je     953f <checkColorValidity+0xd7>
    951e:	b8 25 00 00 00       	mov    $0x25,%eax
    9523:	eb 20                	jmp    9545 <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    9525:	b8 1f 00 00 00       	mov    $0x1f,%eax
    952a:	eb 19                	jmp    9545 <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    952c:	b8 1f 00 00 00       	mov    $0x1f,%eax
    9531:	eb 12                	jmp    9545 <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    9533:	90                   	nop
    9534:	eb 0a                	jmp    9540 <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    9536:	90                   	nop
    9537:	eb 07                	jmp    9540 <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    9539:	90                   	nop
    953a:	eb 04                	jmp    9540 <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    953c:	90                   	nop
    953d:	eb 01                	jmp    9540 <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    953f:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    9540:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9545:	5d                   	pop    %ebp
    9546:	c3                   	ret    

00009547 <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    9547:	55                   	push   %ebp
    9548:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    954a:	8b 45 08             	mov    0x8(%ebp),%eax
    954d:	83 f8 03             	cmp    $0x3,%eax
    9550:	74 31                	je     9583 <getNumColorChannels+0x3c>
    9552:	83 f8 03             	cmp    $0x3,%eax
    9555:	77 0b                	ja     9562 <getNumColorChannels+0x1b>
    9557:	85 c0                	test   %eax,%eax
    9559:	74 1a                	je     9575 <getNumColorChannels+0x2e>
    955b:	83 f8 02             	cmp    $0x2,%eax
    955e:	74 1c                	je     957c <getNumColorChannels+0x35>
    9560:	eb 3d                	jmp    959f <getNumColorChannels+0x58>
    9562:	83 f8 06             	cmp    $0x6,%eax
    9565:	74 2a                	je     9591 <getNumColorChannels+0x4a>
    9567:	3d ff 00 00 00       	cmp    $0xff,%eax
    956c:	74 2a                	je     9598 <getNumColorChannels+0x51>
    956e:	83 f8 04             	cmp    $0x4,%eax
    9571:	74 17                	je     958a <getNumColorChannels+0x43>
    9573:	eb 2a                	jmp    959f <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    9575:	b8 01 00 00 00       	mov    $0x1,%eax
    957a:	eb 28                	jmp    95a4 <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    957c:	b8 03 00 00 00       	mov    $0x3,%eax
    9581:	eb 21                	jmp    95a4 <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    9583:	b8 01 00 00 00       	mov    $0x1,%eax
    9588:	eb 1a                	jmp    95a4 <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    958a:	b8 02 00 00 00       	mov    $0x2,%eax
    958f:	eb 13                	jmp    95a4 <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    9591:	b8 04 00 00 00       	mov    $0x4,%eax
    9596:	eb 0c                	jmp    95a4 <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    9598:	b8 00 00 00 00       	mov    $0x0,%eax
    959d:	eb 05                	jmp    95a4 <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    959f:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    95a4:	5d                   	pop    %ebp
    95a5:	c3                   	ret    

000095a6 <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    95a6:	55                   	push   %ebp
    95a7:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    95a9:	ff 75 08             	pushl  0x8(%ebp)
    95ac:	e8 96 ff ff ff       	call   9547 <getNumColorChannels>
    95b1:	83 c4 04             	add    $0x4,%esp
    95b4:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    95b8:	c9                   	leave  
    95b9:	c3                   	ret    

000095ba <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    95ba:	55                   	push   %ebp
    95bb:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    95bd:	8b 45 08             	mov    0x8(%ebp),%eax
    95c0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    95c7:	8b 45 08             	mov    0x8(%ebp),%eax
    95ca:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    95d1:	8b 45 08             	mov    0x8(%ebp),%eax
    95d4:	8b 50 1c             	mov    0x1c(%eax),%edx
    95d7:	8b 45 08             	mov    0x8(%ebp),%eax
    95da:	89 50 18             	mov    %edx,0x18(%eax)
    95dd:	8b 45 08             	mov    0x8(%ebp),%eax
    95e0:	8b 50 18             	mov    0x18(%eax),%edx
    95e3:	8b 45 08             	mov    0x8(%ebp),%eax
    95e6:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    95e9:	8b 45 08             	mov    0x8(%ebp),%eax
    95ec:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    95f2:	8b 45 08             	mov    0x8(%ebp),%eax
    95f5:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    95fc:	8b 45 08             	mov    0x8(%ebp),%eax
    95ff:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    9606:	8b 45 08             	mov    0x8(%ebp),%eax
    9609:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    9610:	90                   	nop
    9611:	5d                   	pop    %ebp
    9612:	c3                   	ret    

00009613 <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    9613:	55                   	push   %ebp
    9614:	89 e5                	mov    %esp,%ebp
    9616:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    9619:	8b 45 08             	mov    0x8(%ebp),%eax
    961c:	8b 40 08             	mov    0x8(%eax),%eax
    961f:	85 c0                	test   %eax,%eax
    9621:	75 18                	jne    963b <lodepng_color_mode_alloc_palette+0x28>
    9623:	83 ec 0c             	sub    $0xc,%esp
    9626:	68 00 04 00 00       	push   $0x400
    962b:	e8 7b a8 ff ff       	call   3eab <lodepng_malloc>
    9630:	83 c4 10             	add    $0x10,%esp
    9633:	89 c2                	mov    %eax,%edx
    9635:	8b 45 08             	mov    0x8(%ebp),%eax
    9638:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    963b:	8b 45 08             	mov    0x8(%ebp),%eax
    963e:	8b 40 08             	mov    0x8(%eax),%eax
    9641:	85 c0                	test   %eax,%eax
    9643:	74 65                	je     96aa <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    9645:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    964c:	eb 51                	jmp    969f <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    964e:	8b 45 08             	mov    0x8(%ebp),%eax
    9651:	8b 40 08             	mov    0x8(%eax),%eax
    9654:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9657:	c1 e2 02             	shl    $0x2,%edx
    965a:	01 d0                	add    %edx,%eax
    965c:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    965f:	8b 45 08             	mov    0x8(%ebp),%eax
    9662:	8b 40 08             	mov    0x8(%eax),%eax
    9665:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9668:	c1 e2 02             	shl    $0x2,%edx
    966b:	83 c2 01             	add    $0x1,%edx
    966e:	01 d0                	add    %edx,%eax
    9670:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    9673:	8b 45 08             	mov    0x8(%ebp),%eax
    9676:	8b 40 08             	mov    0x8(%eax),%eax
    9679:	8b 55 f4             	mov    -0xc(%ebp),%edx
    967c:	c1 e2 02             	shl    $0x2,%edx
    967f:	83 c2 02             	add    $0x2,%edx
    9682:	01 d0                	add    %edx,%eax
    9684:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    9687:	8b 45 08             	mov    0x8(%ebp),%eax
    968a:	8b 40 08             	mov    0x8(%eax),%eax
    968d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9690:	c1 e2 02             	shl    $0x2,%edx
    9693:	83 c2 03             	add    $0x3,%edx
    9696:	01 d0                	add    %edx,%eax
    9698:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    969b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    969f:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    96a6:	75 a6                	jne    964e <lodepng_color_mode_alloc_palette+0x3b>
    96a8:	eb 01                	jmp    96ab <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    96aa:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    96ab:	c9                   	leave  
    96ac:	c3                   	ret    

000096ad <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    96ad:	55                   	push   %ebp
    96ae:	89 e5                	mov    %esp,%ebp
    96b0:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    96b3:	83 ec 0c             	sub    $0xc,%esp
    96b6:	ff 75 08             	pushl  0x8(%ebp)
    96b9:	e8 f3 01 00 00       	call   98b1 <lodepng_palette_clear>
    96be:	83 c4 10             	add    $0x10,%esp
}
    96c1:	90                   	nop
    96c2:	c9                   	leave  
    96c3:	c3                   	ret    

000096c4 <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    96c4:	55                   	push   %ebp
    96c5:	89 e5                	mov    %esp,%ebp
    96c7:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    96ca:	83 ec 0c             	sub    $0xc,%esp
    96cd:	ff 75 08             	pushl  0x8(%ebp)
    96d0:	e8 d8 ff ff ff       	call   96ad <lodepng_color_mode_cleanup>
    96d5:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    96d8:	83 ec 04             	sub    $0x4,%esp
    96db:	6a 20                	push   $0x20
    96dd:	ff 75 0c             	pushl  0xc(%ebp)
    96e0:	ff 75 08             	pushl  0x8(%ebp)
    96e3:	e8 01 a8 ff ff       	call   3ee9 <lodepng_memcpy>
    96e8:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    96eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    96ee:	8b 40 08             	mov    0x8(%eax),%eax
    96f1:	85 c0                	test   %eax,%eax
    96f3:	74 5a                	je     974f <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    96f5:	83 ec 0c             	sub    $0xc,%esp
    96f8:	68 00 04 00 00       	push   $0x400
    96fd:	e8 a9 a7 ff ff       	call   3eab <lodepng_malloc>
    9702:	83 c4 10             	add    $0x10,%esp
    9705:	89 c2                	mov    %eax,%edx
    9707:	8b 45 08             	mov    0x8(%ebp),%eax
    970a:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    970d:	8b 45 08             	mov    0x8(%ebp),%eax
    9710:	8b 40 08             	mov    0x8(%eax),%eax
    9713:	85 c0                	test   %eax,%eax
    9715:	75 11                	jne    9728 <lodepng_color_mode_copy+0x64>
    9717:	8b 45 0c             	mov    0xc(%ebp),%eax
    971a:	8b 40 0c             	mov    0xc(%eax),%eax
    971d:	85 c0                	test   %eax,%eax
    971f:	74 07                	je     9728 <lodepng_color_mode_copy+0x64>
    9721:	b8 53 00 00 00       	mov    $0x53,%eax
    9726:	eb 2c                	jmp    9754 <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    9728:	8b 45 0c             	mov    0xc(%ebp),%eax
    972b:	8b 40 0c             	mov    0xc(%eax),%eax
    972e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    9735:	8b 45 0c             	mov    0xc(%ebp),%eax
    9738:	8b 50 08             	mov    0x8(%eax),%edx
    973b:	8b 45 08             	mov    0x8(%ebp),%eax
    973e:	8b 40 08             	mov    0x8(%eax),%eax
    9741:	83 ec 04             	sub    $0x4,%esp
    9744:	51                   	push   %ecx
    9745:	52                   	push   %edx
    9746:	50                   	push   %eax
    9747:	e8 9d a7 ff ff       	call   3ee9 <lodepng_memcpy>
    974c:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    974f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9754:	c9                   	leave  
    9755:	c3                   	ret    

00009756 <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    9756:	55                   	push   %ebp
    9757:	89 e5                	mov    %esp,%ebp
    9759:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    975c:	8d 45 e0             	lea    -0x20(%ebp),%eax
    975f:	50                   	push   %eax
    9760:	e8 55 fe ff ff       	call   95ba <lodepng_color_mode_init>
    9765:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    9768:	8b 45 0c             	mov    0xc(%ebp),%eax
    976b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    976e:	8b 45 10             	mov    0x10(%ebp),%eax
    9771:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    9774:	8b 45 08             	mov    0x8(%ebp),%eax
    9777:	8b 55 e0             	mov    -0x20(%ebp),%edx
    977a:	89 10                	mov    %edx,(%eax)
    977c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    977f:	89 50 04             	mov    %edx,0x4(%eax)
    9782:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9785:	89 50 08             	mov    %edx,0x8(%eax)
    9788:	8b 55 ec             	mov    -0x14(%ebp),%edx
    978b:	89 50 0c             	mov    %edx,0xc(%eax)
    978e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9791:	89 50 10             	mov    %edx,0x10(%eax)
    9794:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9797:	89 50 14             	mov    %edx,0x14(%eax)
    979a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    979d:	89 50 18             	mov    %edx,0x18(%eax)
    97a0:	8b 55 fc             	mov    -0x4(%ebp),%edx
    97a3:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    97a6:	8b 45 08             	mov    0x8(%ebp),%eax
    97a9:	c9                   	leave  
    97aa:	c2 04 00             	ret    $0x4

000097ad <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    97ad:	55                   	push   %ebp
    97ae:	89 e5                	mov    %esp,%ebp
    97b0:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    97b3:	8b 45 08             	mov    0x8(%ebp),%eax
    97b6:	8b 10                	mov    (%eax),%edx
    97b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    97bb:	8b 00                	mov    (%eax),%eax
    97bd:	39 c2                	cmp    %eax,%edx
    97bf:	74 0a                	je     97cb <lodepng_color_mode_equal+0x1e>
    97c1:	b8 00 00 00 00       	mov    $0x0,%eax
    97c6:	e9 e4 00 00 00       	jmp    98af <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    97cb:	8b 45 08             	mov    0x8(%ebp),%eax
    97ce:	8b 50 04             	mov    0x4(%eax),%edx
    97d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    97d4:	8b 40 04             	mov    0x4(%eax),%eax
    97d7:	39 c2                	cmp    %eax,%edx
    97d9:	74 0a                	je     97e5 <lodepng_color_mode_equal+0x38>
    97db:	b8 00 00 00 00       	mov    $0x0,%eax
    97e0:	e9 ca 00 00 00       	jmp    98af <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    97e5:	8b 45 08             	mov    0x8(%ebp),%eax
    97e8:	8b 50 10             	mov    0x10(%eax),%edx
    97eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    97ee:	8b 40 10             	mov    0x10(%eax),%eax
    97f1:	39 c2                	cmp    %eax,%edx
    97f3:	74 0a                	je     97ff <lodepng_color_mode_equal+0x52>
    97f5:	b8 00 00 00 00       	mov    $0x0,%eax
    97fa:	e9 b0 00 00 00       	jmp    98af <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    97ff:	8b 45 08             	mov    0x8(%ebp),%eax
    9802:	8b 40 10             	mov    0x10(%eax),%eax
    9805:	85 c0                	test   %eax,%eax
    9807:	74 48                	je     9851 <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    9809:	8b 45 08             	mov    0x8(%ebp),%eax
    980c:	8b 50 14             	mov    0x14(%eax),%edx
    980f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9812:	8b 40 14             	mov    0x14(%eax),%eax
    9815:	39 c2                	cmp    %eax,%edx
    9817:	74 0a                	je     9823 <lodepng_color_mode_equal+0x76>
    9819:	b8 00 00 00 00       	mov    $0x0,%eax
    981e:	e9 8c 00 00 00       	jmp    98af <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    9823:	8b 45 08             	mov    0x8(%ebp),%eax
    9826:	8b 50 18             	mov    0x18(%eax),%edx
    9829:	8b 45 0c             	mov    0xc(%ebp),%eax
    982c:	8b 40 18             	mov    0x18(%eax),%eax
    982f:	39 c2                	cmp    %eax,%edx
    9831:	74 07                	je     983a <lodepng_color_mode_equal+0x8d>
    9833:	b8 00 00 00 00       	mov    $0x0,%eax
    9838:	eb 75                	jmp    98af <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    983a:	8b 45 08             	mov    0x8(%ebp),%eax
    983d:	8b 50 1c             	mov    0x1c(%eax),%edx
    9840:	8b 45 0c             	mov    0xc(%ebp),%eax
    9843:	8b 40 1c             	mov    0x1c(%eax),%eax
    9846:	39 c2                	cmp    %eax,%edx
    9848:	74 07                	je     9851 <lodepng_color_mode_equal+0xa4>
    984a:	b8 00 00 00 00       	mov    $0x0,%eax
    984f:	eb 5e                	jmp    98af <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    9851:	8b 45 08             	mov    0x8(%ebp),%eax
    9854:	8b 50 0c             	mov    0xc(%eax),%edx
    9857:	8b 45 0c             	mov    0xc(%ebp),%eax
    985a:	8b 40 0c             	mov    0xc(%eax),%eax
    985d:	39 c2                	cmp    %eax,%edx
    985f:	74 07                	je     9868 <lodepng_color_mode_equal+0xbb>
    9861:	b8 00 00 00 00       	mov    $0x0,%eax
    9866:	eb 47                	jmp    98af <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    9868:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    986f:	eb 2b                	jmp    989c <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    9871:	8b 45 08             	mov    0x8(%ebp),%eax
    9874:	8b 50 08             	mov    0x8(%eax),%edx
    9877:	8b 45 fc             	mov    -0x4(%ebp),%eax
    987a:	01 d0                	add    %edx,%eax
    987c:	0f b6 10             	movzbl (%eax),%edx
    987f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9882:	8b 48 08             	mov    0x8(%eax),%ecx
    9885:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9888:	01 c8                	add    %ecx,%eax
    988a:	0f b6 00             	movzbl (%eax),%eax
    988d:	38 c2                	cmp    %al,%dl
    988f:	74 07                	je     9898 <lodepng_color_mode_equal+0xeb>
    9891:	b8 00 00 00 00       	mov    $0x0,%eax
    9896:	eb 17                	jmp    98af <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    9898:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    989c:	8b 45 08             	mov    0x8(%ebp),%eax
    989f:	8b 40 0c             	mov    0xc(%eax),%eax
    98a2:	c1 e0 02             	shl    $0x2,%eax
    98a5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    98a8:	75 c7                	jne    9871 <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    98aa:	b8 01 00 00 00       	mov    $0x1,%eax
}
    98af:	c9                   	leave  
    98b0:	c3                   	ret    

000098b1 <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    98b1:	55                   	push   %ebp
    98b2:	89 e5                	mov    %esp,%ebp
    98b4:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    98b7:	8b 45 08             	mov    0x8(%ebp),%eax
    98ba:	8b 40 08             	mov    0x8(%eax),%eax
    98bd:	85 c0                	test   %eax,%eax
    98bf:	74 12                	je     98d3 <lodepng_palette_clear+0x22>
    98c1:	8b 45 08             	mov    0x8(%ebp),%eax
    98c4:	8b 40 08             	mov    0x8(%eax),%eax
    98c7:	83 ec 0c             	sub    $0xc,%esp
    98ca:	50                   	push   %eax
    98cb:	e8 fc a5 ff ff       	call   3ecc <lodepng_free>
    98d0:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    98d3:	8b 45 08             	mov    0x8(%ebp),%eax
    98d6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    98dd:	8b 45 08             	mov    0x8(%ebp),%eax
    98e0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    98e7:	90                   	nop
    98e8:	c9                   	leave  
    98e9:	c3                   	ret    

000098ea <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    98ea:	55                   	push   %ebp
    98eb:	89 e5                	mov    %esp,%ebp
    98ed:	53                   	push   %ebx
    98ee:	83 ec 14             	sub    $0x14,%esp
    98f1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    98f4:	8b 4d 10             	mov    0x10(%ebp),%ecx
    98f7:	8b 55 14             	mov    0x14(%ebp),%edx
    98fa:	8b 45 18             	mov    0x18(%ebp),%eax
    98fd:	88 5d f4             	mov    %bl,-0xc(%ebp)
    9900:	88 4d f0             	mov    %cl,-0x10(%ebp)
    9903:	88 55 ec             	mov    %dl,-0x14(%ebp)
    9906:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    9909:	8b 45 08             	mov    0x8(%ebp),%eax
    990c:	8b 40 08             	mov    0x8(%eax),%eax
    990f:	85 c0                	test   %eax,%eax
    9911:	75 22                	jne    9935 <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    9913:	83 ec 0c             	sub    $0xc,%esp
    9916:	ff 75 08             	pushl  0x8(%ebp)
    9919:	e8 f5 fc ff ff       	call   9613 <lodepng_color_mode_alloc_palette>
    991e:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    9921:	8b 45 08             	mov    0x8(%ebp),%eax
    9924:	8b 40 08             	mov    0x8(%eax),%eax
    9927:	85 c0                	test   %eax,%eax
    9929:	75 0a                	jne    9935 <lodepng_palette_add+0x4b>
    992b:	b8 53 00 00 00       	mov    $0x53,%eax
    9930:	e9 8d 00 00 00       	jmp    99c2 <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    9935:	8b 45 08             	mov    0x8(%ebp),%eax
    9938:	8b 40 0c             	mov    0xc(%eax),%eax
    993b:	3d ff 00 00 00       	cmp    $0xff,%eax
    9940:	7e 07                	jle    9949 <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    9942:	b8 6c 00 00 00       	mov    $0x6c,%eax
    9947:	eb 79                	jmp    99c2 <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    9949:	8b 45 08             	mov    0x8(%ebp),%eax
    994c:	8b 50 08             	mov    0x8(%eax),%edx
    994f:	8b 45 08             	mov    0x8(%ebp),%eax
    9952:	8b 40 0c             	mov    0xc(%eax),%eax
    9955:	c1 e0 02             	shl    $0x2,%eax
    9958:	01 c2                	add    %eax,%edx
    995a:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    995e:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    9960:	8b 45 08             	mov    0x8(%ebp),%eax
    9963:	8b 50 08             	mov    0x8(%eax),%edx
    9966:	8b 45 08             	mov    0x8(%ebp),%eax
    9969:	8b 40 0c             	mov    0xc(%eax),%eax
    996c:	c1 e0 02             	shl    $0x2,%eax
    996f:	83 c0 01             	add    $0x1,%eax
    9972:	01 c2                	add    %eax,%edx
    9974:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    9978:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    997a:	8b 45 08             	mov    0x8(%ebp),%eax
    997d:	8b 50 08             	mov    0x8(%eax),%edx
    9980:	8b 45 08             	mov    0x8(%ebp),%eax
    9983:	8b 40 0c             	mov    0xc(%eax),%eax
    9986:	c1 e0 02             	shl    $0x2,%eax
    9989:	83 c0 02             	add    $0x2,%eax
    998c:	01 c2                	add    %eax,%edx
    998e:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    9992:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    9994:	8b 45 08             	mov    0x8(%ebp),%eax
    9997:	8b 50 08             	mov    0x8(%eax),%edx
    999a:	8b 45 08             	mov    0x8(%ebp),%eax
    999d:	8b 40 0c             	mov    0xc(%eax),%eax
    99a0:	c1 e0 02             	shl    $0x2,%eax
    99a3:	83 c0 03             	add    $0x3,%eax
    99a6:	01 c2                	add    %eax,%edx
    99a8:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    99ac:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    99ae:	8b 45 08             	mov    0x8(%ebp),%eax
    99b1:	8b 40 0c             	mov    0xc(%eax),%eax
    99b4:	8d 50 01             	lea    0x1(%eax),%edx
    99b7:	8b 45 08             	mov    0x8(%ebp),%eax
    99ba:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    99bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    99c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    99c5:	c9                   	leave  
    99c6:	c3                   	ret    

000099c7 <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    99c7:	55                   	push   %ebp
    99c8:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    99ca:	8b 45 08             	mov    0x8(%ebp),%eax
    99cd:	8b 50 04             	mov    0x4(%eax),%edx
    99d0:	8b 45 08             	mov    0x8(%ebp),%eax
    99d3:	8b 00                	mov    (%eax),%eax
    99d5:	52                   	push   %edx
    99d6:	50                   	push   %eax
    99d7:	e8 ca fb ff ff       	call   95a6 <lodepng_get_bpp_lct>
    99dc:	83 c4 08             	add    $0x8,%esp
}
    99df:	c9                   	leave  
    99e0:	c3                   	ret    

000099e1 <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    99e1:	55                   	push   %ebp
    99e2:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    99e4:	8b 45 08             	mov    0x8(%ebp),%eax
    99e7:	8b 00                	mov    (%eax),%eax
    99e9:	50                   	push   %eax
    99ea:	e8 58 fb ff ff       	call   9547 <getNumColorChannels>
    99ef:	83 c4 04             	add    $0x4,%esp
}
    99f2:	c9                   	leave  
    99f3:	c3                   	ret    

000099f4 <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    99f4:	55                   	push   %ebp
    99f5:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    99f7:	8b 45 08             	mov    0x8(%ebp),%eax
    99fa:	8b 00                	mov    (%eax),%eax
    99fc:	85 c0                	test   %eax,%eax
    99fe:	74 0a                	je     9a0a <lodepng_is_greyscale_type+0x16>
    9a00:	8b 45 08             	mov    0x8(%ebp),%eax
    9a03:	8b 00                	mov    (%eax),%eax
    9a05:	83 f8 04             	cmp    $0x4,%eax
    9a08:	75 07                	jne    9a11 <lodepng_is_greyscale_type+0x1d>
    9a0a:	b8 01 00 00 00       	mov    $0x1,%eax
    9a0f:	eb 05                	jmp    9a16 <lodepng_is_greyscale_type+0x22>
    9a11:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9a16:	5d                   	pop    %ebp
    9a17:	c3                   	ret    

00009a18 <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    9a18:	55                   	push   %ebp
    9a19:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    9a1b:	8b 45 08             	mov    0x8(%ebp),%eax
    9a1e:	8b 00                	mov    (%eax),%eax
    9a20:	83 e0 04             	and    $0x4,%eax
    9a23:	85 c0                	test   %eax,%eax
    9a25:	0f 95 c0             	setne  %al
    9a28:	0f b6 c0             	movzbl %al,%eax
}
    9a2b:	5d                   	pop    %ebp
    9a2c:	c3                   	ret    

00009a2d <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    9a2d:	55                   	push   %ebp
    9a2e:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    9a30:	8b 45 08             	mov    0x8(%ebp),%eax
    9a33:	8b 00                	mov    (%eax),%eax
    9a35:	83 f8 03             	cmp    $0x3,%eax
    9a38:	0f 94 c0             	sete   %al
    9a3b:	0f b6 c0             	movzbl %al,%eax
}
    9a3e:	5d                   	pop    %ebp
    9a3f:	c3                   	ret    

00009a40 <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    9a40:	55                   	push   %ebp
    9a41:	89 e5                	mov    %esp,%ebp
    9a43:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    9a46:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9a4d:	eb 23                	jmp    9a72 <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    9a4f:	8b 45 08             	mov    0x8(%ebp),%eax
    9a52:	8b 40 08             	mov    0x8(%eax),%eax
    9a55:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9a58:	c1 e2 02             	shl    $0x2,%edx
    9a5b:	83 c2 03             	add    $0x3,%edx
    9a5e:	01 d0                	add    %edx,%eax
    9a60:	0f b6 00             	movzbl (%eax),%eax
    9a63:	3c ff                	cmp    $0xff,%al
    9a65:	74 07                	je     9a6e <lodepng_has_palette_alpha+0x2e>
    9a67:	b8 01 00 00 00       	mov    $0x1,%eax
    9a6c:	eb 14                	jmp    9a82 <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    9a6e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9a72:	8b 45 08             	mov    0x8(%ebp),%eax
    9a75:	8b 40 0c             	mov    0xc(%eax),%eax
    9a78:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    9a7b:	75 d2                	jne    9a4f <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    9a7d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9a82:	c9                   	leave  
    9a83:	c3                   	ret    

00009a84 <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    9a84:	55                   	push   %ebp
    9a85:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    9a87:	8b 45 08             	mov    0x8(%ebp),%eax
    9a8a:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    9a8d:	85 c0                	test   %eax,%eax
    9a8f:	75 1e                	jne    9aaf <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    9a91:	ff 75 08             	pushl  0x8(%ebp)
    9a94:	e8 7f ff ff ff       	call   9a18 <lodepng_is_alpha_type>
    9a99:	83 c4 04             	add    $0x4,%esp
    9a9c:	85 c0                	test   %eax,%eax
    9a9e:	75 0f                	jne    9aaf <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    9aa0:	ff 75 08             	pushl  0x8(%ebp)
    9aa3:	e8 98 ff ff ff       	call   9a40 <lodepng_has_palette_alpha>
    9aa8:	83 c4 04             	add    $0x4,%esp
    9aab:	85 c0                	test   %eax,%eax
    9aad:	74 07                	je     9ab6 <lodepng_can_have_alpha+0x32>
    9aaf:	b8 01 00 00 00       	mov    $0x1,%eax
    9ab4:	eb 05                	jmp    9abb <lodepng_can_have_alpha+0x37>
    9ab6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9abb:	c9                   	leave  
    9abc:	c3                   	ret    

00009abd <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    9abd:	55                   	push   %ebp
    9abe:	89 e5                	mov    %esp,%ebp
    9ac0:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    9ac3:	ff 75 14             	pushl  0x14(%ebp)
    9ac6:	ff 75 10             	pushl  0x10(%ebp)
    9ac9:	e8 d8 fa ff ff       	call   95a6 <lodepng_get_bpp_lct>
    9ace:	83 c4 08             	add    $0x8,%esp
    9ad1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    9ad4:	8b 55 08             	mov    0x8(%ebp),%edx
    9ad7:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ada:	0f af c2             	imul   %edx,%eax
    9add:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    9ae0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9ae3:	c1 e8 03             	shr    $0x3,%eax
    9ae6:	89 c2                	mov    %eax,%edx
    9ae8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9aeb:	0f af c2             	imul   %edx,%eax
    9aee:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9af1:	89 d1                	mov    %edx,%ecx
    9af3:	83 e1 07             	and    $0x7,%ecx
    9af6:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9af9:	0f af d1             	imul   %ecx,%edx
    9afc:	83 c2 07             	add    $0x7,%edx
    9aff:	c1 ea 03             	shr    $0x3,%edx
    9b02:	01 d0                	add    %edx,%eax
}
    9b04:	c9                   	leave  
    9b05:	c3                   	ret    

00009b06 <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    9b06:	55                   	push   %ebp
    9b07:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    9b09:	8b 45 10             	mov    0x10(%ebp),%eax
    9b0c:	8b 50 04             	mov    0x4(%eax),%edx
    9b0f:	8b 45 10             	mov    0x10(%ebp),%eax
    9b12:	8b 00                	mov    (%eax),%eax
    9b14:	52                   	push   %edx
    9b15:	50                   	push   %eax
    9b16:	ff 75 0c             	pushl  0xc(%ebp)
    9b19:	ff 75 08             	pushl  0x8(%ebp)
    9b1c:	e8 9c ff ff ff       	call   9abd <lodepng_get_raw_size_lct>
    9b21:	83 c4 10             	add    $0x10,%esp
}
    9b24:	c9                   	leave  
    9b25:	c3                   	ret    

00009b26 <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    9b26:	55                   	push   %ebp
    9b27:	89 e5                	mov    %esp,%ebp
    9b29:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    9b2c:	8b 45 08             	mov    0x8(%ebp),%eax
    9b2f:	c1 e8 03             	shr    $0x3,%eax
    9b32:	0f af 45 10          	imul   0x10(%ebp),%eax
    9b36:	8b 55 08             	mov    0x8(%ebp),%edx
    9b39:	83 e2 07             	and    $0x7,%edx
    9b3c:	0f af 55 10          	imul   0x10(%ebp),%edx
    9b40:	83 c2 07             	add    $0x7,%edx
    9b43:	c1 ea 03             	shr    $0x3,%edx
    9b46:	01 d0                	add    %edx,%eax
    9b48:	83 c0 01             	add    $0x1,%eax
    9b4b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    9b4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9b51:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    9b55:	c9                   	leave  
    9b56:	c3                   	ret    

00009b57 <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    9b57:	55                   	push   %ebp
    9b58:	89 e5                	mov    %esp,%ebp
    9b5a:	53                   	push   %ebx
    9b5b:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    9b5e:	ff 75 10             	pushl  0x10(%ebp)
    9b61:	e8 61 fe ff ff       	call   99c7 <lodepng_get_bpp>
    9b66:	83 c4 04             	add    $0x4,%esp
    9b69:	89 c3                	mov    %eax,%ebx
    9b6b:	ff 75 14             	pushl  0x14(%ebp)
    9b6e:	e8 54 fe ff ff       	call   99c7 <lodepng_get_bpp>
    9b73:	83 c4 04             	add    $0x4,%esp
    9b76:	39 c3                	cmp    %eax,%ebx
    9b78:	76 0d                	jbe    9b87 <lodepng_pixel_overflow+0x30>
    9b7a:	ff 75 10             	pushl  0x10(%ebp)
    9b7d:	e8 45 fe ff ff       	call   99c7 <lodepng_get_bpp>
    9b82:	83 c4 04             	add    $0x4,%esp
    9b85:	eb 0b                	jmp    9b92 <lodepng_pixel_overflow+0x3b>
    9b87:	ff 75 14             	pushl  0x14(%ebp)
    9b8a:	e8 38 fe ff ff       	call   99c7 <lodepng_get_bpp>
    9b8f:	83 c4 04             	add    $0x4,%esp
    9b92:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    9b95:	8b 55 0c             	mov    0xc(%ebp),%edx
    9b98:	8b 45 08             	mov    0x8(%ebp),%eax
    9b9b:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    9b9e:	51                   	push   %ecx
    9b9f:	52                   	push   %edx
    9ba0:	50                   	push   %eax
    9ba1:	e8 e9 a3 ff ff       	call   3f8f <lodepng_mulofl>
    9ba6:	83 c4 0c             	add    $0xc,%esp
    9ba9:	85 c0                	test   %eax,%eax
    9bab:	74 0a                	je     9bb7 <lodepng_pixel_overflow+0x60>
    9bad:	b8 01 00 00 00       	mov    $0x1,%eax
    9bb2:	e9 b6 00 00 00       	jmp    9c6d <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    9bb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9bba:	8d 55 f0             	lea    -0x10(%ebp),%edx
    9bbd:	52                   	push   %edx
    9bbe:	6a 08                	push   $0x8
    9bc0:	50                   	push   %eax
    9bc1:	e8 c9 a3 ff ff       	call   3f8f <lodepng_mulofl>
    9bc6:	83 c4 0c             	add    $0xc,%esp
    9bc9:	85 c0                	test   %eax,%eax
    9bcb:	74 0a                	je     9bd7 <lodepng_pixel_overflow+0x80>
    9bcd:	b8 01 00 00 00       	mov    $0x1,%eax
    9bd2:	e9 96 00 00 00       	jmp    9c6d <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    9bd7:	8b 45 08             	mov    0x8(%ebp),%eax
    9bda:	c1 e8 03             	shr    $0x3,%eax
    9bdd:	89 c2                	mov    %eax,%edx
    9bdf:	8d 45 ec             	lea    -0x14(%ebp),%eax
    9be2:	50                   	push   %eax
    9be3:	ff 75 f8             	pushl  -0x8(%ebp)
    9be6:	52                   	push   %edx
    9be7:	e8 a3 a3 ff ff       	call   3f8f <lodepng_mulofl>
    9bec:	83 c4 0c             	add    $0xc,%esp
    9bef:	85 c0                	test   %eax,%eax
    9bf1:	74 07                	je     9bfa <lodepng_pixel_overflow+0xa3>
    9bf3:	b8 01 00 00 00       	mov    $0x1,%eax
    9bf8:	eb 73                	jmp    9c6d <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    9bfa:	8b 45 08             	mov    0x8(%ebp),%eax
    9bfd:	83 e0 07             	and    $0x7,%eax
    9c00:	89 c2                	mov    %eax,%edx
    9c02:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9c05:	0f af c2             	imul   %edx,%eax
    9c08:	83 c0 07             	add    $0x7,%eax
    9c0b:	c1 e8 03             	shr    $0x3,%eax
    9c0e:	89 c1                	mov    %eax,%ecx
    9c10:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9c13:	8d 55 ec             	lea    -0x14(%ebp),%edx
    9c16:	52                   	push   %edx
    9c17:	51                   	push   %ecx
    9c18:	50                   	push   %eax
    9c19:	e8 51 a3 ff ff       	call   3f6f <lodepng_addofl>
    9c1e:	83 c4 0c             	add    $0xc,%esp
    9c21:	85 c0                	test   %eax,%eax
    9c23:	74 07                	je     9c2c <lodepng_pixel_overflow+0xd5>
    9c25:	b8 01 00 00 00       	mov    $0x1,%eax
    9c2a:	eb 41                	jmp    9c6d <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    9c2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9c2f:	8d 55 ec             	lea    -0x14(%ebp),%edx
    9c32:	52                   	push   %edx
    9c33:	6a 05                	push   $0x5
    9c35:	50                   	push   %eax
    9c36:	e8 34 a3 ff ff       	call   3f6f <lodepng_addofl>
    9c3b:	83 c4 0c             	add    $0xc,%esp
    9c3e:	85 c0                	test   %eax,%eax
    9c40:	74 07                	je     9c49 <lodepng_pixel_overflow+0xf2>
    9c42:	b8 01 00 00 00       	mov    $0x1,%eax
    9c47:	eb 24                	jmp    9c6d <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    9c49:	8b 55 0c             	mov    0xc(%ebp),%edx
    9c4c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9c4f:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    9c52:	51                   	push   %ecx
    9c53:	52                   	push   %edx
    9c54:	50                   	push   %eax
    9c55:	e8 35 a3 ff ff       	call   3f8f <lodepng_mulofl>
    9c5a:	83 c4 0c             	add    $0xc,%esp
    9c5d:	85 c0                	test   %eax,%eax
    9c5f:	74 07                	je     9c68 <lodepng_pixel_overflow+0x111>
    9c61:	b8 01 00 00 00       	mov    $0x1,%eax
    9c66:	eb 05                	jmp    9c6d <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    9c68:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9c6d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9c70:	c9                   	leave  
    9c71:	c3                   	ret    

00009c72 <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    9c72:	55                   	push   %ebp
    9c73:	89 e5                	mov    %esp,%ebp
    9c75:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    9c78:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9c7f:	eb 15                	jmp    9c96 <LodePNGUnknownChunks_init+0x24>
    9c81:	8b 45 08             	mov    0x8(%ebp),%eax
    9c84:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9c87:	83 c2 30             	add    $0x30,%edx
    9c8a:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    9c91:	00 
    9c92:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9c96:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9c9a:	75 e5                	jne    9c81 <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    9c9c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9ca3:	eb 15                	jmp    9cba <LodePNGUnknownChunks_init+0x48>
    9ca5:	8b 45 08             	mov    0x8(%ebp),%eax
    9ca8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9cab:	83 c2 34             	add    $0x34,%edx
    9cae:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    9cb5:	00 
    9cb6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9cba:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9cbe:	75 e5                	jne    9ca5 <LodePNGUnknownChunks_init+0x33>
}
    9cc0:	90                   	nop
    9cc1:	c9                   	leave  
    9cc2:	c3                   	ret    

00009cc3 <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    9cc3:	55                   	push   %ebp
    9cc4:	89 e5                	mov    %esp,%ebp
    9cc6:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    9cc9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9cd0:	eb 1d                	jmp    9cef <LodePNGUnknownChunks_cleanup+0x2c>
    9cd2:	8b 45 08             	mov    0x8(%ebp),%eax
    9cd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9cd8:	83 c2 30             	add    $0x30,%edx
    9cdb:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    9cdf:	83 ec 0c             	sub    $0xc,%esp
    9ce2:	50                   	push   %eax
    9ce3:	e8 e4 a1 ff ff       	call   3ecc <lodepng_free>
    9ce8:	83 c4 10             	add    $0x10,%esp
    9ceb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9cef:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    9cf3:	75 dd                	jne    9cd2 <LodePNGUnknownChunks_cleanup+0xf>
}
    9cf5:	90                   	nop
    9cf6:	c9                   	leave  
    9cf7:	c3                   	ret    

00009cf8 <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    9cf8:	55                   	push   %ebp
    9cf9:	89 e5                	mov    %esp,%ebp
    9cfb:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    9cfe:	83 ec 0c             	sub    $0xc,%esp
    9d01:	ff 75 08             	pushl  0x8(%ebp)
    9d04:	e8 ba ff ff ff       	call   9cc3 <LodePNGUnknownChunks_cleanup>
    9d09:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    9d0c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9d13:	e9 b7 00 00 00       	jmp    9dcf <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    9d18:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d1b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d1e:	83 c2 34             	add    $0x34,%edx
    9d21:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    9d25:	8b 45 08             	mov    0x8(%ebp),%eax
    9d28:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9d2b:	83 c1 34             	add    $0x34,%ecx
    9d2e:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    9d32:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d35:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d38:	83 c2 34             	add    $0x34,%edx
    9d3b:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9d3f:	83 ec 0c             	sub    $0xc,%esp
    9d42:	50                   	push   %eax
    9d43:	e8 63 a1 ff ff       	call   3eab <lodepng_malloc>
    9d48:	83 c4 10             	add    $0x10,%esp
    9d4b:	89 c1                	mov    %eax,%ecx
    9d4d:	8b 45 08             	mov    0x8(%ebp),%eax
    9d50:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d53:	83 c2 30             	add    $0x30,%edx
    9d56:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    9d5a:	8b 45 08             	mov    0x8(%ebp),%eax
    9d5d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d60:	83 c2 30             	add    $0x30,%edx
    9d63:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    9d67:	85 c0                	test   %eax,%eax
    9d69:	75 18                	jne    9d83 <LodePNGUnknownChunks_copy+0x8b>
    9d6b:	8b 45 08             	mov    0x8(%ebp),%eax
    9d6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d71:	83 c2 34             	add    $0x34,%edx
    9d74:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9d78:	85 c0                	test   %eax,%eax
    9d7a:	74 07                	je     9d83 <LodePNGUnknownChunks_copy+0x8b>
    9d7c:	b8 53 00 00 00       	mov    $0x53,%eax
    9d81:	eb 5b                	jmp    9dde <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    9d83:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    9d8a:	eb 2d                	jmp    9db9 <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    9d8c:	8b 45 08             	mov    0x8(%ebp),%eax
    9d8f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d92:	83 c2 30             	add    $0x30,%edx
    9d95:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    9d99:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9d9c:	01 c2                	add    %eax,%edx
    9d9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9da1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9da4:	83 c1 30             	add    $0x30,%ecx
    9da7:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    9dab:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9dae:	01 c8                	add    %ecx,%eax
    9db0:	0f b6 00             	movzbl (%eax),%eax
    9db3:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    9db5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    9db9:	8b 45 0c             	mov    0xc(%ebp),%eax
    9dbc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9dbf:	83 c2 34             	add    $0x34,%edx
    9dc2:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9dc6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    9dc9:	7f c1                	jg     9d8c <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    9dcb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9dcf:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    9dd3:	0f 85 3f ff ff ff    	jne    9d18 <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    9dd9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9dde:	c9                   	leave  
    9ddf:	c3                   	ret    

00009de0 <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    9de0:	55                   	push   %ebp
    9de1:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    9de3:	8b 45 08             	mov    0x8(%ebp),%eax
    9de6:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    9ded:	8b 45 08             	mov    0x8(%ebp),%eax
    9df0:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    9df7:	8b 45 08             	mov    0x8(%ebp),%eax
    9dfa:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    9e01:	90                   	nop
    9e02:	5d                   	pop    %ebp
    9e03:	c3                   	ret    

00009e04 <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    9e04:	55                   	push   %ebp
    9e05:	89 e5                	mov    %esp,%ebp
    9e07:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9e0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9e11:	eb 38                	jmp    9e4b <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    9e13:	8b 45 08             	mov    0x8(%ebp),%eax
    9e16:	8b 40 40             	mov    0x40(%eax),%eax
    9e19:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e1c:	c1 e2 02             	shl    $0x2,%edx
    9e1f:	01 d0                	add    %edx,%eax
    9e21:	83 ec 0c             	sub    $0xc,%esp
    9e24:	50                   	push   %eax
    9e25:	e8 75 a3 ff ff       	call   419f <string_cleanup>
    9e2a:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    9e2d:	8b 45 08             	mov    0x8(%ebp),%eax
    9e30:	8b 40 44             	mov    0x44(%eax),%eax
    9e33:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e36:	c1 e2 02             	shl    $0x2,%edx
    9e39:	01 d0                	add    %edx,%eax
    9e3b:	83 ec 0c             	sub    $0xc,%esp
    9e3e:	50                   	push   %eax
    9e3f:	e8 5b a3 ff ff       	call   419f <string_cleanup>
    9e44:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9e47:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9e4b:	8b 45 08             	mov    0x8(%ebp),%eax
    9e4e:	8b 40 3c             	mov    0x3c(%eax),%eax
    9e51:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9e54:	75 bd                	jne    9e13 <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    9e56:	8b 45 08             	mov    0x8(%ebp),%eax
    9e59:	8b 40 40             	mov    0x40(%eax),%eax
    9e5c:	83 ec 0c             	sub    $0xc,%esp
    9e5f:	50                   	push   %eax
    9e60:	e8 67 a0 ff ff       	call   3ecc <lodepng_free>
    9e65:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    9e68:	8b 45 08             	mov    0x8(%ebp),%eax
    9e6b:	8b 40 44             	mov    0x44(%eax),%eax
    9e6e:	83 ec 0c             	sub    $0xc,%esp
    9e71:	50                   	push   %eax
    9e72:	e8 55 a0 ff ff       	call   3ecc <lodepng_free>
    9e77:	83 c4 10             	add    $0x10,%esp
}
    9e7a:	90                   	nop
    9e7b:	c9                   	leave  
    9e7c:	c3                   	ret    

00009e7d <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9e7d:	55                   	push   %ebp
    9e7e:	89 e5                	mov    %esp,%ebp
    9e80:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    9e83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    9e8a:	8b 45 08             	mov    0x8(%ebp),%eax
    9e8d:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    9e94:	8b 45 08             	mov    0x8(%ebp),%eax
    9e97:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    9e9e:	8b 45 08             	mov    0x8(%ebp),%eax
    9ea1:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    9ea8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9eaf:	eb 42                	jmp    9ef3 <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    9eb1:	8b 45 0c             	mov    0xc(%ebp),%eax
    9eb4:	8b 40 44             	mov    0x44(%eax),%eax
    9eb7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9eba:	c1 e2 02             	shl    $0x2,%edx
    9ebd:	01 d0                	add    %edx,%eax
    9ebf:	8b 10                	mov    (%eax),%edx
    9ec1:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ec4:	8b 40 40             	mov    0x40(%eax),%eax
    9ec7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9eca:	c1 e1 02             	shl    $0x2,%ecx
    9ecd:	01 c8                	add    %ecx,%eax
    9ecf:	8b 00                	mov    (%eax),%eax
    9ed1:	83 ec 04             	sub    $0x4,%esp
    9ed4:	52                   	push   %edx
    9ed5:	50                   	push   %eax
    9ed6:	ff 75 08             	pushl  0x8(%ebp)
    9ed9:	e8 4d 01 00 00       	call   a02b <lodepng_add_text>
    9ede:	83 c4 10             	add    $0x10,%esp
    9ee1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9ee4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9ee8:	74 05                	je     9eef <LodePNGText_copy+0x72>
    9eea:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9eed:	eb 14                	jmp    9f03 <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    9eef:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9ef3:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ef6:	8b 40 3c             	mov    0x3c(%eax),%eax
    9ef9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9efc:	75 b3                	jne    9eb1 <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    9efe:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9f03:	c9                   	leave  
    9f04:	c3                   	ret    

00009f05 <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    9f05:	55                   	push   %ebp
    9f06:	89 e5                	mov    %esp,%ebp
    9f08:	53                   	push   %ebx
    9f09:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    9f0c:	8b 45 08             	mov    0x8(%ebp),%eax
    9f0f:	8b 40 3c             	mov    0x3c(%eax),%eax
    9f12:	83 c0 01             	add    $0x1,%eax
    9f15:	c1 e0 02             	shl    $0x2,%eax
    9f18:	89 c2                	mov    %eax,%edx
    9f1a:	8b 45 08             	mov    0x8(%ebp),%eax
    9f1d:	8b 40 40             	mov    0x40(%eax),%eax
    9f20:	52                   	push   %edx
    9f21:	50                   	push   %eax
    9f22:	e8 9b 9f ff ff       	call   3ec2 <lodepng_realloc>
    9f27:	83 c4 08             	add    $0x8,%esp
    9f2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    9f2d:	8b 45 08             	mov    0x8(%ebp),%eax
    9f30:	8b 40 3c             	mov    0x3c(%eax),%eax
    9f33:	83 c0 01             	add    $0x1,%eax
    9f36:	c1 e0 02             	shl    $0x2,%eax
    9f39:	89 c2                	mov    %eax,%edx
    9f3b:	8b 45 08             	mov    0x8(%ebp),%eax
    9f3e:	8b 40 44             	mov    0x44(%eax),%eax
    9f41:	52                   	push   %edx
    9f42:	50                   	push   %eax
    9f43:	e8 7a 9f ff ff       	call   3ec2 <lodepng_realloc>
    9f48:	83 c4 08             	add    $0x8,%esp
    9f4b:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    9f4e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9f52:	74 09                	je     9f5d <lodepng_add_text_sized+0x58>
    9f54:	8b 45 08             	mov    0x8(%ebp),%eax
    9f57:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9f5a:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    9f5d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9f61:	74 09                	je     9f6c <lodepng_add_text_sized+0x67>
    9f63:	8b 45 08             	mov    0x8(%ebp),%eax
    9f66:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f69:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    9f6c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9f70:	74 06                	je     9f78 <lodepng_add_text_sized+0x73>
    9f72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9f76:	75 0a                	jne    9f82 <lodepng_add_text_sized+0x7d>
    9f78:	b8 53 00 00 00       	mov    $0x53,%eax
    9f7d:	e9 a4 00 00 00       	jmp    a026 <lodepng_add_text_sized+0x121>

  ++info->text_num;
    9f82:	8b 45 08             	mov    0x8(%ebp),%eax
    9f85:	8b 40 3c             	mov    0x3c(%eax),%eax
    9f88:	8d 50 01             	lea    0x1(%eax),%edx
    9f8b:	8b 45 08             	mov    0x8(%ebp),%eax
    9f8e:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    9f91:	8b 45 08             	mov    0x8(%ebp),%eax
    9f94:	8b 50 40             	mov    0x40(%eax),%edx
    9f97:	8b 45 08             	mov    0x8(%ebp),%eax
    9f9a:	8b 40 3c             	mov    0x3c(%eax),%eax
    9f9d:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9fa2:	c1 e0 02             	shl    $0x2,%eax
    9fa5:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9fa8:	83 ec 0c             	sub    $0xc,%esp
    9fab:	ff 75 0c             	pushl  0xc(%ebp)
    9fae:	e8 54 a2 ff ff       	call   4207 <alloc_string>
    9fb3:	83 c4 10             	add    $0x10,%esp
    9fb6:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    9fb8:	8b 45 08             	mov    0x8(%ebp),%eax
    9fbb:	8b 50 44             	mov    0x44(%eax),%edx
    9fbe:	8b 45 08             	mov    0x8(%ebp),%eax
    9fc1:	8b 40 3c             	mov    0x3c(%eax),%eax
    9fc4:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9fc9:	c1 e0 02             	shl    $0x2,%eax
    9fcc:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9fcf:	83 ec 08             	sub    $0x8,%esp
    9fd2:	ff 75 14             	pushl  0x14(%ebp)
    9fd5:	ff 75 10             	pushl  0x10(%ebp)
    9fd8:	e8 e5 a1 ff ff       	call   41c2 <alloc_string_sized>
    9fdd:	83 c4 10             	add    $0x10,%esp
    9fe0:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    9fe2:	8b 45 08             	mov    0x8(%ebp),%eax
    9fe5:	8b 50 40             	mov    0x40(%eax),%edx
    9fe8:	8b 45 08             	mov    0x8(%ebp),%eax
    9feb:	8b 40 3c             	mov    0x3c(%eax),%eax
    9fee:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9ff3:	c1 e0 02             	shl    $0x2,%eax
    9ff6:	01 d0                	add    %edx,%eax
    9ff8:	8b 00                	mov    (%eax),%eax
    9ffa:	85 c0                	test   %eax,%eax
    9ffc:	74 1c                	je     a01a <lodepng_add_text_sized+0x115>
    9ffe:	8b 45 08             	mov    0x8(%ebp),%eax
    a001:	8b 50 44             	mov    0x44(%eax),%edx
    a004:	8b 45 08             	mov    0x8(%ebp),%eax
    a007:	8b 40 3c             	mov    0x3c(%eax),%eax
    a00a:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    a00f:	c1 e0 02             	shl    $0x2,%eax
    a012:	01 d0                	add    %edx,%eax
    a014:	8b 00                	mov    (%eax),%eax
    a016:	85 c0                	test   %eax,%eax
    a018:	75 07                	jne    a021 <lodepng_add_text_sized+0x11c>
    a01a:	b8 53 00 00 00       	mov    $0x53,%eax
    a01f:	eb 05                	jmp    a026 <lodepng_add_text_sized+0x121>

  return 0;
    a021:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a026:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a029:	c9                   	leave  
    a02a:	c3                   	ret    

0000a02b <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    a02b:	55                   	push   %ebp
    a02c:	89 e5                	mov    %esp,%ebp
    a02e:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    a031:	ff 75 10             	pushl  0x10(%ebp)
    a034:	e8 0e 9f ff ff       	call   3f47 <lodepng_strlen>
    a039:	83 c4 04             	add    $0x4,%esp
    a03c:	50                   	push   %eax
    a03d:	ff 75 10             	pushl  0x10(%ebp)
    a040:	ff 75 0c             	pushl  0xc(%ebp)
    a043:	ff 75 08             	pushl  0x8(%ebp)
    a046:	e8 ba fe ff ff       	call   9f05 <lodepng_add_text_sized>
    a04b:	83 c4 10             	add    $0x10,%esp
}
    a04e:	c9                   	leave  
    a04f:	c3                   	ret    

0000a050 <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    a050:	55                   	push   %ebp
    a051:	89 e5                	mov    %esp,%ebp
    a053:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    a056:	83 ec 0c             	sub    $0xc,%esp
    a059:	ff 75 08             	pushl  0x8(%ebp)
    a05c:	e8 a3 fd ff ff       	call   9e04 <LodePNGText_cleanup>
    a061:	83 c4 10             	add    $0x10,%esp
}
    a064:	90                   	nop
    a065:	c9                   	leave  
    a066:	c3                   	ret    

0000a067 <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    a067:	55                   	push   %ebp
    a068:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    a06a:	8b 45 08             	mov    0x8(%ebp),%eax
    a06d:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    a074:	8b 45 08             	mov    0x8(%ebp),%eax
    a077:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    a07e:	8b 45 08             	mov    0x8(%ebp),%eax
    a081:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    a088:	8b 45 08             	mov    0x8(%ebp),%eax
    a08b:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    a092:	8b 45 08             	mov    0x8(%ebp),%eax
    a095:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    a09c:	90                   	nop
    a09d:	5d                   	pop    %ebp
    a09e:	c3                   	ret    

0000a09f <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    a09f:	55                   	push   %ebp
    a0a0:	89 e5                	mov    %esp,%ebp
    a0a2:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    a0a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a0ac:	eb 6c                	jmp    a11a <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    a0ae:	8b 45 08             	mov    0x8(%ebp),%eax
    a0b1:	8b 40 4c             	mov    0x4c(%eax),%eax
    a0b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a0b7:	c1 e2 02             	shl    $0x2,%edx
    a0ba:	01 d0                	add    %edx,%eax
    a0bc:	83 ec 0c             	sub    $0xc,%esp
    a0bf:	50                   	push   %eax
    a0c0:	e8 da a0 ff ff       	call   419f <string_cleanup>
    a0c5:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    a0c8:	8b 45 08             	mov    0x8(%ebp),%eax
    a0cb:	8b 40 50             	mov    0x50(%eax),%eax
    a0ce:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a0d1:	c1 e2 02             	shl    $0x2,%edx
    a0d4:	01 d0                	add    %edx,%eax
    a0d6:	83 ec 0c             	sub    $0xc,%esp
    a0d9:	50                   	push   %eax
    a0da:	e8 c0 a0 ff ff       	call   419f <string_cleanup>
    a0df:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    a0e2:	8b 45 08             	mov    0x8(%ebp),%eax
    a0e5:	8b 40 54             	mov    0x54(%eax),%eax
    a0e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a0eb:	c1 e2 02             	shl    $0x2,%edx
    a0ee:	01 d0                	add    %edx,%eax
    a0f0:	83 ec 0c             	sub    $0xc,%esp
    a0f3:	50                   	push   %eax
    a0f4:	e8 a6 a0 ff ff       	call   419f <string_cleanup>
    a0f9:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    a0fc:	8b 45 08             	mov    0x8(%ebp),%eax
    a0ff:	8b 40 58             	mov    0x58(%eax),%eax
    a102:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a105:	c1 e2 02             	shl    $0x2,%edx
    a108:	01 d0                	add    %edx,%eax
    a10a:	83 ec 0c             	sub    $0xc,%esp
    a10d:	50                   	push   %eax
    a10e:	e8 8c a0 ff ff       	call   419f <string_cleanup>
    a113:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    a116:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a11a:	8b 45 08             	mov    0x8(%ebp),%eax
    a11d:	8b 40 48             	mov    0x48(%eax),%eax
    a120:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a123:	75 89                	jne    a0ae <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    a125:	8b 45 08             	mov    0x8(%ebp),%eax
    a128:	8b 40 4c             	mov    0x4c(%eax),%eax
    a12b:	83 ec 0c             	sub    $0xc,%esp
    a12e:	50                   	push   %eax
    a12f:	e8 98 9d ff ff       	call   3ecc <lodepng_free>
    a134:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    a137:	8b 45 08             	mov    0x8(%ebp),%eax
    a13a:	8b 40 50             	mov    0x50(%eax),%eax
    a13d:	83 ec 0c             	sub    $0xc,%esp
    a140:	50                   	push   %eax
    a141:	e8 86 9d ff ff       	call   3ecc <lodepng_free>
    a146:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    a149:	8b 45 08             	mov    0x8(%ebp),%eax
    a14c:	8b 40 54             	mov    0x54(%eax),%eax
    a14f:	83 ec 0c             	sub    $0xc,%esp
    a152:	50                   	push   %eax
    a153:	e8 74 9d ff ff       	call   3ecc <lodepng_free>
    a158:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    a15b:	8b 45 08             	mov    0x8(%ebp),%eax
    a15e:	8b 40 58             	mov    0x58(%eax),%eax
    a161:	83 ec 0c             	sub    $0xc,%esp
    a164:	50                   	push   %eax
    a165:	e8 62 9d ff ff       	call   3ecc <lodepng_free>
    a16a:	83 c4 10             	add    $0x10,%esp
}
    a16d:	90                   	nop
    a16e:	c9                   	leave  
    a16f:	c3                   	ret    

0000a170 <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    a170:	55                   	push   %ebp
    a171:	89 e5                	mov    %esp,%ebp
    a173:	56                   	push   %esi
    a174:	53                   	push   %ebx
    a175:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    a178:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    a17f:	8b 45 08             	mov    0x8(%ebp),%eax
    a182:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    a189:	8b 45 08             	mov    0x8(%ebp),%eax
    a18c:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    a193:	8b 45 08             	mov    0x8(%ebp),%eax
    a196:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    a19d:	8b 45 08             	mov    0x8(%ebp),%eax
    a1a0:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    a1a7:	8b 45 08             	mov    0x8(%ebp),%eax
    a1aa:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    a1b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a1b8:	eb 64                	jmp    a21e <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    a1ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1bd:	8b 40 58             	mov    0x58(%eax),%eax
    a1c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a1c3:	c1 e2 02             	shl    $0x2,%edx
    a1c6:	01 d0                	add    %edx,%eax
    a1c8:	8b 18                	mov    (%eax),%ebx
    a1ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1cd:	8b 40 54             	mov    0x54(%eax),%eax
    a1d0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a1d3:	c1 e2 02             	shl    $0x2,%edx
    a1d6:	01 d0                	add    %edx,%eax
    a1d8:	8b 08                	mov    (%eax),%ecx
    a1da:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1dd:	8b 40 50             	mov    0x50(%eax),%eax
    a1e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a1e3:	c1 e2 02             	shl    $0x2,%edx
    a1e6:	01 d0                	add    %edx,%eax
    a1e8:	8b 10                	mov    (%eax),%edx
    a1ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1ed:	8b 40 4c             	mov    0x4c(%eax),%eax
    a1f0:	8b 75 f4             	mov    -0xc(%ebp),%esi
    a1f3:	c1 e6 02             	shl    $0x2,%esi
    a1f6:	01 f0                	add    %esi,%eax
    a1f8:	8b 00                	mov    (%eax),%eax
    a1fa:	83 ec 0c             	sub    $0xc,%esp
    a1fd:	53                   	push   %ebx
    a1fe:	51                   	push   %ecx
    a1ff:	52                   	push   %edx
    a200:	50                   	push   %eax
    a201:	ff 75 08             	pushl  0x8(%ebp)
    a204:	e8 e4 01 00 00       	call   a3ed <lodepng_add_itext>
    a209:	83 c4 20             	add    $0x20,%esp
    a20c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    a20f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a213:	74 05                	je     a21a <LodePNGIText_copy+0xaa>
    a215:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a218:	eb 14                	jmp    a22e <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    a21a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a21e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a221:	8b 40 48             	mov    0x48(%eax),%eax
    a224:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a227:	75 91                	jne    a1ba <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    a229:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a22e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    a231:	5b                   	pop    %ebx
    a232:	5e                   	pop    %esi
    a233:	5d                   	pop    %ebp
    a234:	c3                   	ret    

0000a235 <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    a235:	55                   	push   %ebp
    a236:	89 e5                	mov    %esp,%ebp
    a238:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    a23b:	83 ec 0c             	sub    $0xc,%esp
    a23e:	ff 75 08             	pushl  0x8(%ebp)
    a241:	e8 59 fe ff ff       	call   a09f <LodePNGIText_cleanup>
    a246:	83 c4 10             	add    $0x10,%esp
}
    a249:	90                   	nop
    a24a:	c9                   	leave  
    a24b:	c3                   	ret    

0000a24c <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    a24c:	55                   	push   %ebp
    a24d:	89 e5                	mov    %esp,%ebp
    a24f:	53                   	push   %ebx
    a250:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    a253:	8b 45 08             	mov    0x8(%ebp),%eax
    a256:	8b 40 48             	mov    0x48(%eax),%eax
    a259:	83 c0 01             	add    $0x1,%eax
    a25c:	c1 e0 02             	shl    $0x2,%eax
    a25f:	89 c2                	mov    %eax,%edx
    a261:	8b 45 08             	mov    0x8(%ebp),%eax
    a264:	8b 40 4c             	mov    0x4c(%eax),%eax
    a267:	52                   	push   %edx
    a268:	50                   	push   %eax
    a269:	e8 54 9c ff ff       	call   3ec2 <lodepng_realloc>
    a26e:	83 c4 08             	add    $0x8,%esp
    a271:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    a274:	8b 45 08             	mov    0x8(%ebp),%eax
    a277:	8b 40 48             	mov    0x48(%eax),%eax
    a27a:	83 c0 01             	add    $0x1,%eax
    a27d:	c1 e0 02             	shl    $0x2,%eax
    a280:	89 c2                	mov    %eax,%edx
    a282:	8b 45 08             	mov    0x8(%ebp),%eax
    a285:	8b 40 50             	mov    0x50(%eax),%eax
    a288:	52                   	push   %edx
    a289:	50                   	push   %eax
    a28a:	e8 33 9c ff ff       	call   3ec2 <lodepng_realloc>
    a28f:	83 c4 08             	add    $0x8,%esp
    a292:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    a295:	8b 45 08             	mov    0x8(%ebp),%eax
    a298:	8b 40 48             	mov    0x48(%eax),%eax
    a29b:	83 c0 01             	add    $0x1,%eax
    a29e:	c1 e0 02             	shl    $0x2,%eax
    a2a1:	89 c2                	mov    %eax,%edx
    a2a3:	8b 45 08             	mov    0x8(%ebp),%eax
    a2a6:	8b 40 54             	mov    0x54(%eax),%eax
    a2a9:	52                   	push   %edx
    a2aa:	50                   	push   %eax
    a2ab:	e8 12 9c ff ff       	call   3ec2 <lodepng_realloc>
    a2b0:	83 c4 08             	add    $0x8,%esp
    a2b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    a2b6:	8b 45 08             	mov    0x8(%ebp),%eax
    a2b9:	8b 40 48             	mov    0x48(%eax),%eax
    a2bc:	83 c0 01             	add    $0x1,%eax
    a2bf:	c1 e0 02             	shl    $0x2,%eax
    a2c2:	89 c2                	mov    %eax,%edx
    a2c4:	8b 45 08             	mov    0x8(%ebp),%eax
    a2c7:	8b 40 58             	mov    0x58(%eax),%eax
    a2ca:	52                   	push   %edx
    a2cb:	50                   	push   %eax
    a2cc:	e8 f1 9b ff ff       	call   3ec2 <lodepng_realloc>
    a2d1:	83 c4 08             	add    $0x8,%esp
    a2d4:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    a2d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    a2db:	74 09                	je     a2e6 <lodepng_add_itext_sized+0x9a>
    a2dd:	8b 45 08             	mov    0x8(%ebp),%eax
    a2e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a2e3:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    a2e6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a2ea:	74 09                	je     a2f5 <lodepng_add_itext_sized+0xa9>
    a2ec:	8b 45 08             	mov    0x8(%ebp),%eax
    a2ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a2f2:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    a2f5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    a2f9:	74 09                	je     a304 <lodepng_add_itext_sized+0xb8>
    a2fb:	8b 45 08             	mov    0x8(%ebp),%eax
    a2fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
    a301:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    a304:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    a308:	74 09                	je     a313 <lodepng_add_itext_sized+0xc7>
    a30a:	8b 45 08             	mov    0x8(%ebp),%eax
    a30d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    a310:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    a313:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    a317:	74 12                	je     a32b <lodepng_add_itext_sized+0xdf>
    a319:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a31d:	74 0c                	je     a32b <lodepng_add_itext_sized+0xdf>
    a31f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    a323:	74 06                	je     a32b <lodepng_add_itext_sized+0xdf>
    a325:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    a329:	75 0a                	jne    a335 <lodepng_add_itext_sized+0xe9>
    a32b:	b8 53 00 00 00       	mov    $0x53,%eax
    a330:	e9 b3 00 00 00       	jmp    a3e8 <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    a335:	8b 45 08             	mov    0x8(%ebp),%eax
    a338:	8b 40 48             	mov    0x48(%eax),%eax
    a33b:	8d 50 01             	lea    0x1(%eax),%edx
    a33e:	8b 45 08             	mov    0x8(%ebp),%eax
    a341:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    a344:	8b 45 08             	mov    0x8(%ebp),%eax
    a347:	8b 50 4c             	mov    0x4c(%eax),%edx
    a34a:	8b 45 08             	mov    0x8(%ebp),%eax
    a34d:	8b 40 48             	mov    0x48(%eax),%eax
    a350:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    a355:	c1 e0 02             	shl    $0x2,%eax
    a358:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    a35b:	83 ec 0c             	sub    $0xc,%esp
    a35e:	ff 75 0c             	pushl  0xc(%ebp)
    a361:	e8 a1 9e ff ff       	call   4207 <alloc_string>
    a366:	83 c4 10             	add    $0x10,%esp
    a369:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    a36b:	8b 45 08             	mov    0x8(%ebp),%eax
    a36e:	8b 50 50             	mov    0x50(%eax),%edx
    a371:	8b 45 08             	mov    0x8(%ebp),%eax
    a374:	8b 40 48             	mov    0x48(%eax),%eax
    a377:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    a37c:	c1 e0 02             	shl    $0x2,%eax
    a37f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    a382:	83 ec 0c             	sub    $0xc,%esp
    a385:	ff 75 10             	pushl  0x10(%ebp)
    a388:	e8 7a 9e ff ff       	call   4207 <alloc_string>
    a38d:	83 c4 10             	add    $0x10,%esp
    a390:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    a392:	8b 45 08             	mov    0x8(%ebp),%eax
    a395:	8b 50 54             	mov    0x54(%eax),%edx
    a398:	8b 45 08             	mov    0x8(%ebp),%eax
    a39b:	8b 40 48             	mov    0x48(%eax),%eax
    a39e:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    a3a3:	c1 e0 02             	shl    $0x2,%eax
    a3a6:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    a3a9:	83 ec 0c             	sub    $0xc,%esp
    a3ac:	ff 75 14             	pushl  0x14(%ebp)
    a3af:	e8 53 9e ff ff       	call   4207 <alloc_string>
    a3b4:	83 c4 10             	add    $0x10,%esp
    a3b7:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    a3b9:	8b 45 08             	mov    0x8(%ebp),%eax
    a3bc:	8b 50 58             	mov    0x58(%eax),%edx
    a3bf:	8b 45 08             	mov    0x8(%ebp),%eax
    a3c2:	8b 40 48             	mov    0x48(%eax),%eax
    a3c5:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    a3ca:	c1 e0 02             	shl    $0x2,%eax
    a3cd:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    a3d0:	83 ec 08             	sub    $0x8,%esp
    a3d3:	ff 75 1c             	pushl  0x1c(%ebp)
    a3d6:	ff 75 18             	pushl  0x18(%ebp)
    a3d9:	e8 e4 9d ff ff       	call   41c2 <alloc_string_sized>
    a3de:	83 c4 10             	add    $0x10,%esp
    a3e1:	89 03                	mov    %eax,(%ebx)

  return 0;
    a3e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a3e8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a3eb:	c9                   	leave  
    a3ec:	c3                   	ret    

0000a3ed <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    a3ed:	55                   	push   %ebp
    a3ee:	89 e5                	mov    %esp,%ebp
    a3f0:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    a3f3:	ff 75 18             	pushl  0x18(%ebp)
    a3f6:	e8 4c 9b ff ff       	call   3f47 <lodepng_strlen>
    a3fb:	83 c4 04             	add    $0x4,%esp
    a3fe:	83 ec 08             	sub    $0x8,%esp
    a401:	50                   	push   %eax
    a402:	ff 75 18             	pushl  0x18(%ebp)
    a405:	ff 75 14             	pushl  0x14(%ebp)
    a408:	ff 75 10             	pushl  0x10(%ebp)
    a40b:	ff 75 0c             	pushl  0xc(%ebp)
    a40e:	ff 75 08             	pushl  0x8(%ebp)
    a411:	e8 36 fe ff ff       	call   a24c <lodepng_add_itext_sized>
    a416:	83 c4 20             	add    $0x20,%esp
}
    a419:	c9                   	leave  
    a41a:	c3                   	ret    

0000a41b <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    a41b:	55                   	push   %ebp
    a41c:	89 e5                	mov    %esp,%ebp
    a41e:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    a421:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    a425:	75 0a                	jne    a431 <lodepng_assign_icc+0x16>
    a427:	b8 64 00 00 00       	mov    $0x64,%eax
    a42c:	e9 81 00 00 00       	jmp    a4b2 <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    a431:	83 ec 0c             	sub    $0xc,%esp
    a434:	ff 75 0c             	pushl  0xc(%ebp)
    a437:	e8 cb 9d ff ff       	call   4207 <alloc_string>
    a43c:	83 c4 10             	add    $0x10,%esp
    a43f:	89 c2                	mov    %eax,%edx
    a441:	8b 45 08             	mov    0x8(%ebp),%eax
    a444:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    a44a:	8b 45 14             	mov    0x14(%ebp),%eax
    a44d:	83 ec 0c             	sub    $0xc,%esp
    a450:	50                   	push   %eax
    a451:	e8 55 9a ff ff       	call   3eab <lodepng_malloc>
    a456:	83 c4 10             	add    $0x10,%esp
    a459:	89 c2                	mov    %eax,%edx
    a45b:	8b 45 08             	mov    0x8(%ebp),%eax
    a45e:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    a464:	8b 45 08             	mov    0x8(%ebp),%eax
    a467:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    a46d:	85 c0                	test   %eax,%eax
    a46f:	74 0d                	je     a47e <lodepng_assign_icc+0x63>
    a471:	8b 45 08             	mov    0x8(%ebp),%eax
    a474:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    a47a:	85 c0                	test   %eax,%eax
    a47c:	75 07                	jne    a485 <lodepng_assign_icc+0x6a>
    a47e:	b8 53 00 00 00       	mov    $0x53,%eax
    a483:	eb 2d                	jmp    a4b2 <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    a485:	8b 55 14             	mov    0x14(%ebp),%edx
    a488:	8b 45 08             	mov    0x8(%ebp),%eax
    a48b:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    a491:	83 ec 04             	sub    $0x4,%esp
    a494:	52                   	push   %edx
    a495:	ff 75 10             	pushl  0x10(%ebp)
    a498:	50                   	push   %eax
    a499:	e8 4b 9a ff ff       	call   3ee9 <lodepng_memcpy>
    a49e:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    a4a1:	8b 45 08             	mov    0x8(%ebp),%eax
    a4a4:	8b 55 14             	mov    0x14(%ebp),%edx
    a4a7:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    a4ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a4b2:	c9                   	leave  
    a4b3:	c3                   	ret    

0000a4b4 <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    a4b4:	55                   	push   %ebp
    a4b5:	89 e5                	mov    %esp,%ebp
    a4b7:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    a4ba:	8b 45 08             	mov    0x8(%ebp),%eax
    a4bd:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    a4c3:	85 c0                	test   %eax,%eax
    a4c5:	74 0e                	je     a4d5 <lodepng_set_icc+0x21>
    a4c7:	83 ec 0c             	sub    $0xc,%esp
    a4ca:	ff 75 08             	pushl  0x8(%ebp)
    a4cd:	e8 26 00 00 00       	call   a4f8 <lodepng_clear_icc>
    a4d2:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    a4d5:	8b 45 08             	mov    0x8(%ebp),%eax
    a4d8:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    a4df:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    a4e2:	ff 75 14             	pushl  0x14(%ebp)
    a4e5:	ff 75 10             	pushl  0x10(%ebp)
    a4e8:	ff 75 0c             	pushl  0xc(%ebp)
    a4eb:	ff 75 08             	pushl  0x8(%ebp)
    a4ee:	e8 28 ff ff ff       	call   a41b <lodepng_assign_icc>
    a4f3:	83 c4 10             	add    $0x10,%esp
}
    a4f6:	c9                   	leave  
    a4f7:	c3                   	ret    

0000a4f8 <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    a4f8:	55                   	push   %ebp
    a4f9:	89 e5                	mov    %esp,%ebp
    a4fb:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    a4fe:	8b 45 08             	mov    0x8(%ebp),%eax
    a501:	05 c0 00 00 00       	add    $0xc0,%eax
    a506:	83 ec 0c             	sub    $0xc,%esp
    a509:	50                   	push   %eax
    a50a:	e8 90 9c ff ff       	call   419f <string_cleanup>
    a50f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    a512:	8b 45 08             	mov    0x8(%ebp),%eax
    a515:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    a51b:	83 ec 0c             	sub    $0xc,%esp
    a51e:	50                   	push   %eax
    a51f:	e8 a8 99 ff ff       	call   3ecc <lodepng_free>
    a524:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    a527:	8b 45 08             	mov    0x8(%ebp),%eax
    a52a:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    a531:	00 00 00 
  info->iccp_profile_size = 0;
    a534:	8b 45 08             	mov    0x8(%ebp),%eax
    a537:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    a53e:	00 00 00 
  info->iccp_defined = 0;
    a541:	8b 45 08             	mov    0x8(%ebp),%eax
    a544:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    a54b:	00 00 00 
}
    a54e:	90                   	nop
    a54f:	c9                   	leave  
    a550:	c3                   	ret    

0000a551 <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    a551:	55                   	push   %ebp
    a552:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    a554:	8b 45 08             	mov    0x8(%ebp),%eax
    a557:	83 c0 0c             	add    $0xc,%eax
    a55a:	50                   	push   %eax
    a55b:	e8 5a f0 ff ff       	call   95ba <lodepng_color_mode_init>
    a560:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    a563:	8b 45 08             	mov    0x8(%ebp),%eax
    a566:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    a56d:	8b 45 08             	mov    0x8(%ebp),%eax
    a570:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    a576:	8b 45 08             	mov    0x8(%ebp),%eax
    a579:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    a580:	8b 45 08             	mov    0x8(%ebp),%eax
    a583:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    a58a:	8b 45 08             	mov    0x8(%ebp),%eax
    a58d:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    a594:	8b 45 08             	mov    0x8(%ebp),%eax
    a597:	8b 50 38             	mov    0x38(%eax),%edx
    a59a:	8b 45 08             	mov    0x8(%ebp),%eax
    a59d:	89 50 34             	mov    %edx,0x34(%eax)
    a5a0:	8b 45 08             	mov    0x8(%ebp),%eax
    a5a3:	8b 50 34             	mov    0x34(%eax),%edx
    a5a6:	8b 45 08             	mov    0x8(%ebp),%eax
    a5a9:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    a5ac:	ff 75 08             	pushl  0x8(%ebp)
    a5af:	e8 2c f8 ff ff       	call   9de0 <LodePNGText_init>
    a5b4:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    a5b7:	ff 75 08             	pushl  0x8(%ebp)
    a5ba:	e8 a8 fa ff ff       	call   a067 <LodePNGIText_init>
    a5bf:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    a5c2:	8b 45 08             	mov    0x8(%ebp),%eax
    a5c5:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    a5cc:	8b 45 08             	mov    0x8(%ebp),%eax
    a5cf:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    a5d6:	8b 45 08             	mov    0x8(%ebp),%eax
    a5d9:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    a5e0:	00 00 00 
  info->chrm_defined = 0;
    a5e3:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e6:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    a5ed:	00 00 00 
  info->srgb_defined = 0;
    a5f0:	8b 45 08             	mov    0x8(%ebp),%eax
    a5f3:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    a5fa:	00 00 00 
  info->iccp_defined = 0;
    a5fd:	8b 45 08             	mov    0x8(%ebp),%eax
    a600:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    a607:	00 00 00 
  info->iccp_name = NULL;
    a60a:	8b 45 08             	mov    0x8(%ebp),%eax
    a60d:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    a614:	00 00 00 
  info->iccp_profile = NULL;
    a617:	8b 45 08             	mov    0x8(%ebp),%eax
    a61a:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    a621:	00 00 00 

  LodePNGUnknownChunks_init(info);
    a624:	ff 75 08             	pushl  0x8(%ebp)
    a627:	e8 46 f6 ff ff       	call   9c72 <LodePNGUnknownChunks_init>
    a62c:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    a62f:	90                   	nop
    a630:	c9                   	leave  
    a631:	c3                   	ret    

0000a632 <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    a632:	55                   	push   %ebp
    a633:	89 e5                	mov    %esp,%ebp
    a635:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    a638:	8b 45 08             	mov    0x8(%ebp),%eax
    a63b:	83 c0 0c             	add    $0xc,%eax
    a63e:	83 ec 0c             	sub    $0xc,%esp
    a641:	50                   	push   %eax
    a642:	e8 66 f0 ff ff       	call   96ad <lodepng_color_mode_cleanup>
    a647:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    a64a:	83 ec 0c             	sub    $0xc,%esp
    a64d:	ff 75 08             	pushl  0x8(%ebp)
    a650:	e8 af f7 ff ff       	call   9e04 <LodePNGText_cleanup>
    a655:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    a658:	83 ec 0c             	sub    $0xc,%esp
    a65b:	ff 75 08             	pushl  0x8(%ebp)
    a65e:	e8 3c fa ff ff       	call   a09f <LodePNGIText_cleanup>
    a663:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    a666:	83 ec 0c             	sub    $0xc,%esp
    a669:	ff 75 08             	pushl  0x8(%ebp)
    a66c:	e8 87 fe ff ff       	call   a4f8 <lodepng_clear_icc>
    a671:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    a674:	83 ec 0c             	sub    $0xc,%esp
    a677:	ff 75 08             	pushl  0x8(%ebp)
    a67a:	e8 44 f6 ff ff       	call   9cc3 <LodePNGUnknownChunks_cleanup>
    a67f:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    a682:	90                   	nop
    a683:	c9                   	leave  
    a684:	c3                   	ret    

0000a685 <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    a685:	55                   	push   %ebp
    a686:	89 e5                	mov    %esp,%ebp
    a688:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    a68b:	83 ec 0c             	sub    $0xc,%esp
    a68e:	ff 75 08             	pushl  0x8(%ebp)
    a691:	e8 9c ff ff ff       	call   a632 <lodepng_info_cleanup>
    a696:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    a699:	83 ec 04             	sub    $0x4,%esp
    a69c:	68 e4 00 00 00       	push   $0xe4
    a6a1:	ff 75 0c             	pushl  0xc(%ebp)
    a6a4:	ff 75 08             	pushl  0x8(%ebp)
    a6a7:	e8 3d 98 ff ff       	call   3ee9 <lodepng_memcpy>
    a6ac:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    a6af:	8b 45 08             	mov    0x8(%ebp),%eax
    a6b2:	83 c0 0c             	add    $0xc,%eax
    a6b5:	83 ec 0c             	sub    $0xc,%esp
    a6b8:	50                   	push   %eax
    a6b9:	e8 fc ee ff ff       	call   95ba <lodepng_color_mode_init>
    a6be:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    a6c1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6c4:	8d 50 0c             	lea    0xc(%eax),%edx
    a6c7:	8b 45 08             	mov    0x8(%ebp),%eax
    a6ca:	83 c0 0c             	add    $0xc,%eax
    a6cd:	83 ec 08             	sub    $0x8,%esp
    a6d0:	52                   	push   %edx
    a6d1:	50                   	push   %eax
    a6d2:	e8 ed ef ff ff       	call   96c4 <lodepng_color_mode_copy>
    a6d7:	83 c4 10             	add    $0x10,%esp
    a6da:	89 45 f4             	mov    %eax,-0xc(%ebp)
    a6dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    a6e1:	74 08                	je     a6eb <lodepng_info_copy+0x66>
    a6e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a6e6:	e9 b7 00 00 00       	jmp    a7a2 <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    a6eb:	83 ec 08             	sub    $0x8,%esp
    a6ee:	ff 75 0c             	pushl  0xc(%ebp)
    a6f1:	ff 75 08             	pushl  0x8(%ebp)
    a6f4:	e8 84 f7 ff ff       	call   9e7d <LodePNGText_copy>
    a6f9:	83 c4 10             	add    $0x10,%esp
    a6fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    a6ff:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a703:	74 08                	je     a70d <lodepng_info_copy+0x88>
    a705:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a708:	e9 95 00 00 00       	jmp    a7a2 <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    a70d:	83 ec 08             	sub    $0x8,%esp
    a710:	ff 75 0c             	pushl  0xc(%ebp)
    a713:	ff 75 08             	pushl  0x8(%ebp)
    a716:	e8 55 fa ff ff       	call   a170 <LodePNGIText_copy>
    a71b:	83 c4 10             	add    $0x10,%esp
    a71e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    a721:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    a725:	74 05                	je     a72c <lodepng_info_copy+0xa7>
    a727:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a72a:	eb 76                	jmp    a7a2 <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    a72c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a72f:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    a735:	85 c0                	test   %eax,%eax
    a737:	74 37                	je     a770 <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    a739:	8b 45 0c             	mov    0xc(%ebp),%eax
    a73c:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    a742:	8b 45 0c             	mov    0xc(%ebp),%eax
    a745:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    a74b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a74e:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    a754:	51                   	push   %ecx
    a755:	52                   	push   %edx
    a756:	50                   	push   %eax
    a757:	ff 75 08             	pushl  0x8(%ebp)
    a75a:	e8 bc fc ff ff       	call   a41b <lodepng_assign_icc>
    a75f:	83 c4 10             	add    $0x10,%esp
    a762:	89 45 e8             	mov    %eax,-0x18(%ebp)
    a765:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    a769:	74 05                	je     a770 <lodepng_info_copy+0xeb>
    a76b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a76e:	eb 32                	jmp    a7a2 <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    a770:	83 ec 0c             	sub    $0xc,%esp
    a773:	ff 75 08             	pushl  0x8(%ebp)
    a776:	e8 f7 f4 ff ff       	call   9c72 <LodePNGUnknownChunks_init>
    a77b:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    a77e:	83 ec 08             	sub    $0x8,%esp
    a781:	ff 75 0c             	pushl  0xc(%ebp)
    a784:	ff 75 08             	pushl  0x8(%ebp)
    a787:	e8 6c f5 ff ff       	call   9cf8 <LodePNGUnknownChunks_copy>
    a78c:	83 c4 10             	add    $0x10,%esp
    a78f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    a792:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    a796:	74 05                	je     a79d <lodepng_info_copy+0x118>
    a798:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a79b:	eb 05                	jmp    a7a2 <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    a79d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a7a2:	c9                   	leave  
    a7a3:	c3                   	ret    

0000a7a4 <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    a7a4:	55                   	push   %ebp
    a7a5:	89 e5                	mov    %esp,%ebp
    a7a7:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    a7aa:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    a7ae:	74 14                	je     a7c4 <addColorBits+0x20>
    a7b0:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    a7b4:	75 07                	jne    a7bd <addColorBits+0x19>
    a7b6:	b8 03 00 00 00       	mov    $0x3,%eax
    a7bb:	eb 0c                	jmp    a7c9 <addColorBits+0x25>
    a7bd:	b8 01 00 00 00       	mov    $0x1,%eax
    a7c2:	eb 05                	jmp    a7c9 <addColorBits+0x25>
    a7c4:	b8 07 00 00 00       	mov    $0x7,%eax
    a7c9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    a7cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7cf:	23 45 fc             	and    -0x4(%ebp),%eax
    a7d2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    a7d5:	8b 45 10             	mov    0x10(%ebp),%eax
    a7d8:	ba 01 00 00 00       	mov    $0x1,%edx
    a7dd:	89 c1                	mov    %eax,%ecx
    a7df:	d3 e2                	shl    %cl,%edx
    a7e1:	89 d0                	mov    %edx,%eax
    a7e3:	83 e8 01             	sub    $0x1,%eax
    a7e6:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    a7e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a7ec:	2b 45 f8             	sub    -0x8(%ebp),%eax
    a7ef:	0f af 45 10          	imul   0x10(%ebp),%eax
    a7f3:	89 c1                	mov    %eax,%ecx
    a7f5:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    a7f8:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a7fc:	75 18                	jne    a816 <addColorBits+0x72>
    a7fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    a801:	0f af 45 10          	imul   0x10(%ebp),%eax
    a805:	c1 e8 03             	shr    $0x3,%eax
    a808:	89 c2                	mov    %eax,%edx
    a80a:	8b 45 08             	mov    0x8(%ebp),%eax
    a80d:	01 d0                	add    %edx,%eax
    a80f:	8b 55 14             	mov    0x14(%ebp),%edx
    a812:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    a814:	eb 1e                	jmp    a834 <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    a816:	8b 45 0c             	mov    0xc(%ebp),%eax
    a819:	0f af 45 10          	imul   0x10(%ebp),%eax
    a81d:	c1 e8 03             	shr    $0x3,%eax
    a820:	8b 55 08             	mov    0x8(%ebp),%edx
    a823:	01 c2                	add    %eax,%edx
    a825:	8b 4d 08             	mov    0x8(%ebp),%ecx
    a828:	01 c8                	add    %ecx,%eax
    a82a:	0f b6 08             	movzbl (%eax),%ecx
    a82d:	8b 45 14             	mov    0x14(%ebp),%eax
    a830:	09 c8                	or     %ecx,%eax
    a832:	88 02                	mov    %al,(%edx)
}
    a834:	90                   	nop
    a835:	c9                   	leave  
    a836:	c3                   	ret    

0000a837 <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    a837:	55                   	push   %ebp
    a838:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    a83a:	8b 45 08             	mov    0x8(%ebp),%eax
    a83d:	6a 40                	push   $0x40
    a83f:	6a 00                	push   $0x0
    a841:	50                   	push   %eax
    a842:	e8 d5 96 ff ff       	call   3f1c <lodepng_memset>
    a847:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    a84a:	8b 45 08             	mov    0x8(%ebp),%eax
    a84d:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    a854:	90                   	nop
    a855:	c9                   	leave  
    a856:	c3                   	ret    

0000a857 <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    a857:	55                   	push   %ebp
    a858:	89 e5                	mov    %esp,%ebp
    a85a:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    a85d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a864:	eb 3b                	jmp    a8a1 <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    a866:	8b 45 08             	mov    0x8(%ebp),%eax
    a869:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a86c:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a86f:	85 c0                	test   %eax,%eax
    a871:	74 2a                	je     a89d <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    a873:	8b 45 08             	mov    0x8(%ebp),%eax
    a876:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a879:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a87c:	83 ec 0c             	sub    $0xc,%esp
    a87f:	50                   	push   %eax
    a880:	e8 d2 ff ff ff       	call   a857 <color_tree_cleanup>
    a885:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    a888:	8b 45 08             	mov    0x8(%ebp),%eax
    a88b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a88e:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a891:	83 ec 0c             	sub    $0xc,%esp
    a894:	50                   	push   %eax
    a895:	e8 32 96 ff ff       	call   3ecc <lodepng_free>
    a89a:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    a89d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a8a1:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    a8a5:	75 bf                	jne    a866 <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    a8a7:	90                   	nop
    a8a8:	c9                   	leave  
    a8a9:	c3                   	ret    

0000a8aa <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a8aa:	55                   	push   %ebp
    a8ab:	89 e5                	mov    %esp,%ebp
    a8ad:	53                   	push   %ebx
    a8ae:	83 ec 20             	sub    $0x20,%esp
    a8b1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a8b4:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a8b7:	8b 55 14             	mov    0x14(%ebp),%edx
    a8ba:	8b 45 18             	mov    0x18(%ebp),%eax
    a8bd:	88 5d e8             	mov    %bl,-0x18(%ebp)
    a8c0:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    a8c3:	88 55 e0             	mov    %dl,-0x20(%ebp)
    a8c6:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    a8c9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    a8d0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    a8d7:	eb 76                	jmp    a94f <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    a8d9:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a8dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a8e0:	89 c1                	mov    %eax,%ecx
    a8e2:	d3 fa                	sar    %cl,%edx
    a8e4:	89 d0                	mov    %edx,%eax
    a8e6:	83 e0 01             	and    $0x1,%eax
    a8e9:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a8ec:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a8f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a8f3:	89 c1                	mov    %eax,%ecx
    a8f5:	d3 fa                	sar    %cl,%edx
    a8f7:	89 d0                	mov    %edx,%eax
    a8f9:	83 e0 01             	and    $0x1,%eax
    a8fc:	01 d8                	add    %ebx,%eax
    a8fe:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a901:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a905:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a908:	89 c1                	mov    %eax,%ecx
    a90a:	d3 fa                	sar    %cl,%edx
    a90c:	89 d0                	mov    %edx,%eax
    a90e:	83 e0 01             	and    $0x1,%eax
    a911:	01 d8                	add    %ebx,%eax
    a913:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a916:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a91a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a91d:	89 c1                	mov    %eax,%ecx
    a91f:	d3 fa                	sar    %cl,%edx
    a921:	89 d0                	mov    %edx,%eax
    a923:	83 e0 01             	and    $0x1,%eax
    a926:	01 d8                	add    %ebx,%eax
    a928:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    a92b:	8b 45 08             	mov    0x8(%ebp),%eax
    a92e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a931:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a934:	85 c0                	test   %eax,%eax
    a936:	75 07                	jne    a93f <color_tree_get+0x95>
    a938:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a93d:	eb 2a                	jmp    a969 <color_tree_get+0xbf>
    else tree = tree->children[i];
    a93f:	8b 45 08             	mov    0x8(%ebp),%eax
    a942:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a945:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a948:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    a94b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    a94f:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    a953:	7e 84                	jle    a8d9 <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    a955:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    a959:	74 08                	je     a963 <color_tree_get+0xb9>
    a95b:	8b 45 08             	mov    0x8(%ebp),%eax
    a95e:	8b 40 40             	mov    0x40(%eax),%eax
    a961:	eb 05                	jmp    a968 <color_tree_get+0xbe>
    a963:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a968:	90                   	nop
}
    a969:	83 c4 20             	add    $0x20,%esp
    a96c:	5b                   	pop    %ebx
    a96d:	5d                   	pop    %ebp
    a96e:	c3                   	ret    

0000a96f <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a96f:	55                   	push   %ebp
    a970:	89 e5                	mov    %esp,%ebp
    a972:	53                   	push   %ebx
    a973:	83 ec 10             	sub    $0x10,%esp
    a976:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a979:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a97c:	8b 55 14             	mov    0x14(%ebp),%edx
    a97f:	8b 45 18             	mov    0x18(%ebp),%eax
    a982:	88 5d f8             	mov    %bl,-0x8(%ebp)
    a985:	88 4d f4             	mov    %cl,-0xc(%ebp)
    a988:	88 55 f0             	mov    %dl,-0x10(%ebp)
    a98b:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    a98e:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    a992:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    a996:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    a99a:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    a99e:	53                   	push   %ebx
    a99f:	51                   	push   %ecx
    a9a0:	52                   	push   %edx
    a9a1:	50                   	push   %eax
    a9a2:	ff 75 08             	pushl  0x8(%ebp)
    a9a5:	e8 00 ff ff ff       	call   a8aa <color_tree_get>
    a9aa:	83 c4 14             	add    $0x14,%esp
    a9ad:	f7 d0                	not    %eax
    a9af:	c1 e8 1f             	shr    $0x1f,%eax
    a9b2:	0f b6 c0             	movzbl %al,%eax
}
    a9b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a9b8:	c9                   	leave  
    a9b9:	c3                   	ret    

0000a9ba <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    a9ba:	55                   	push   %ebp
    a9bb:	89 e5                	mov    %esp,%ebp
    a9bd:	53                   	push   %ebx
    a9be:	83 ec 24             	sub    $0x24,%esp
    a9c1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a9c4:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a9c7:	8b 55 14             	mov    0x14(%ebp),%edx
    a9ca:	8b 45 18             	mov    0x18(%ebp),%eax
    a9cd:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    a9d0:	88 4d e0             	mov    %cl,-0x20(%ebp)
    a9d3:	88 55 dc             	mov    %dl,-0x24(%ebp)
    a9d6:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    a9d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a9e0:	e9 b0 00 00 00       	jmp    aa95 <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    a9e5:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a9e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a9ec:	89 c1                	mov    %eax,%ecx
    a9ee:	d3 fa                	sar    %cl,%edx
    a9f0:	89 d0                	mov    %edx,%eax
    a9f2:	83 e0 01             	and    $0x1,%eax
    a9f5:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a9f8:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a9fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a9ff:	89 c1                	mov    %eax,%ecx
    aa01:	d3 fa                	sar    %cl,%edx
    aa03:	89 d0                	mov    %edx,%eax
    aa05:	83 e0 01             	and    $0x1,%eax
    aa08:	01 d8                	add    %ebx,%eax
    aa0a:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    aa0d:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    aa11:	8b 45 f4             	mov    -0xc(%ebp),%eax
    aa14:	89 c1                	mov    %eax,%ecx
    aa16:	d3 fa                	sar    %cl,%edx
    aa18:	89 d0                	mov    %edx,%eax
    aa1a:	83 e0 01             	and    $0x1,%eax
    aa1d:	01 d8                	add    %ebx,%eax
    aa1f:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    aa22:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    aa26:	8b 45 f4             	mov    -0xc(%ebp),%eax
    aa29:	89 c1                	mov    %eax,%ecx
    aa2b:	d3 fa                	sar    %cl,%edx
    aa2d:	89 d0                	mov    %edx,%eax
    aa2f:	83 e0 01             	and    $0x1,%eax
    aa32:	01 d8                	add    %ebx,%eax
    aa34:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    aa37:	8b 45 08             	mov    0x8(%ebp),%eax
    aa3a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    aa3d:	8b 04 90             	mov    (%eax,%edx,4),%eax
    aa40:	85 c0                	test   %eax,%eax
    aa42:	75 41                	jne    aa85 <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    aa44:	83 ec 0c             	sub    $0xc,%esp
    aa47:	6a 44                	push   $0x44
    aa49:	e8 5d 94 ff ff       	call   3eab <lodepng_malloc>
    aa4e:	83 c4 10             	add    $0x10,%esp
    aa51:	89 c1                	mov    %eax,%ecx
    aa53:	8b 45 08             	mov    0x8(%ebp),%eax
    aa56:	8b 55 f0             	mov    -0x10(%ebp),%edx
    aa59:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    aa5c:	8b 45 08             	mov    0x8(%ebp),%eax
    aa5f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    aa62:	8b 04 90             	mov    (%eax,%edx,4),%eax
    aa65:	85 c0                	test   %eax,%eax
    aa67:	75 07                	jne    aa70 <color_tree_add+0xb6>
    aa69:	b8 53 00 00 00       	mov    $0x53,%eax
    aa6e:	eb 3d                	jmp    aaad <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    aa70:	8b 45 08             	mov    0x8(%ebp),%eax
    aa73:	8b 55 f0             	mov    -0x10(%ebp),%edx
    aa76:	8b 04 90             	mov    (%eax,%edx,4),%eax
    aa79:	83 ec 0c             	sub    $0xc,%esp
    aa7c:	50                   	push   %eax
    aa7d:	e8 b5 fd ff ff       	call   a837 <color_tree_init>
    aa82:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    aa85:	8b 45 08             	mov    0x8(%ebp),%eax
    aa88:	8b 55 f0             	mov    -0x10(%ebp),%edx
    aa8b:	8b 04 90             	mov    (%eax,%edx,4),%eax
    aa8e:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    aa91:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    aa95:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    aa99:	0f 8e 46 ff ff ff    	jle    a9e5 <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    aa9f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aaa2:	8b 45 08             	mov    0x8(%ebp),%eax
    aaa5:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    aaa8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    aaad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    aab0:	c9                   	leave  
    aab1:	c3                   	ret    

0000aab2 <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    aab2:	55                   	push   %ebp
    aab3:	89 e5                	mov    %esp,%ebp
    aab5:	53                   	push   %ebx
    aab6:	83 ec 20             	sub    $0x20,%esp
    aab9:	8b 5d 18             	mov    0x18(%ebp),%ebx
    aabc:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    aabf:	8b 55 20             	mov    0x20(%ebp),%edx
    aac2:	8b 45 24             	mov    0x24(%ebp),%eax
    aac5:	88 5d e8             	mov    %bl,-0x18(%ebp)
    aac8:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    aacb:	88 55 e0             	mov    %dl,-0x20(%ebp)
    aace:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    aad1:	8b 45 10             	mov    0x10(%ebp),%eax
    aad4:	8b 00                	mov    (%eax),%eax
    aad6:	85 c0                	test   %eax,%eax
    aad8:	0f 85 ad 00 00 00    	jne    ab8b <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    aade:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    aae2:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    aae5:	8b 45 10             	mov    0x10(%ebp),%eax
    aae8:	8b 40 04             	mov    0x4(%eax),%eax
    aaeb:	83 f8 08             	cmp    $0x8,%eax
    aaee:	75 13                	jne    ab03 <rgba8ToPixel+0x51>
    aaf0:	8b 55 0c             	mov    0xc(%ebp),%edx
    aaf3:	8b 45 08             	mov    0x8(%ebp),%eax
    aaf6:	01 c2                	add    %eax,%edx
    aaf8:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    aafc:	88 02                	mov    %al,(%edx)
    aafe:	e9 b4 03 00 00       	jmp    aeb7 <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    ab03:	8b 45 10             	mov    0x10(%ebp),%eax
    ab06:	8b 40 04             	mov    0x4(%eax),%eax
    ab09:	83 f8 10             	cmp    $0x10,%eax
    ab0c:	75 2a                	jne    ab38 <rgba8ToPixel+0x86>
    ab0e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab11:	01 c0                	add    %eax,%eax
    ab13:	89 c2                	mov    %eax,%edx
    ab15:	8b 45 08             	mov    0x8(%ebp),%eax
    ab18:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    ab1b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab1e:	01 c0                	add    %eax,%eax
    ab20:	8d 50 01             	lea    0x1(%eax),%edx
    ab23:	8b 45 08             	mov    0x8(%ebp),%eax
    ab26:	01 d0                	add    %edx,%eax
    ab28:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    ab2c:	88 10                	mov    %dl,(%eax)
    ab2e:	0f b6 00             	movzbl (%eax),%eax
    ab31:	88 01                	mov    %al,(%ecx)
    ab33:	e9 7f 03 00 00       	jmp    aeb7 <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    ab38:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    ab3c:	8b 45 10             	mov    0x10(%ebp),%eax
    ab3f:	8b 40 04             	mov    0x4(%eax),%eax
    ab42:	b9 08 00 00 00       	mov    $0x8,%ecx
    ab47:	29 c1                	sub    %eax,%ecx
    ab49:	89 c8                	mov    %ecx,%eax
    ab4b:	89 c1                	mov    %eax,%ecx
    ab4d:	d3 ea                	shr    %cl,%edx
    ab4f:	89 d0                	mov    %edx,%eax
    ab51:	89 c2                	mov    %eax,%edx
    ab53:	8b 45 10             	mov    0x10(%ebp),%eax
    ab56:	8b 40 04             	mov    0x4(%eax),%eax
    ab59:	bb 01 00 00 00       	mov    $0x1,%ebx
    ab5e:	89 c1                	mov    %eax,%ecx
    ab60:	d3 e3                	shl    %cl,%ebx
    ab62:	89 d8                	mov    %ebx,%eax
    ab64:	83 e8 01             	sub    $0x1,%eax
    ab67:	21 d0                	and    %edx,%eax
    ab69:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    ab6c:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    ab70:	8b 45 10             	mov    0x10(%ebp),%eax
    ab73:	8b 40 04             	mov    0x4(%eax),%eax
    ab76:	52                   	push   %edx
    ab77:	50                   	push   %eax
    ab78:	ff 75 0c             	pushl  0xc(%ebp)
    ab7b:	ff 75 08             	pushl  0x8(%ebp)
    ab7e:	e8 21 fc ff ff       	call   a7a4 <addColorBits>
    ab83:	83 c4 10             	add    $0x10,%esp
    ab86:	e9 2c 03 00 00       	jmp    aeb7 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    ab8b:	8b 45 10             	mov    0x10(%ebp),%eax
    ab8e:	8b 00                	mov    (%eax),%eax
    ab90:	83 f8 02             	cmp    $0x2,%eax
    ab93:	0f 85 ee 00 00 00    	jne    ac87 <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    ab99:	8b 45 10             	mov    0x10(%ebp),%eax
    ab9c:	8b 40 04             	mov    0x4(%eax),%eax
    ab9f:	83 f8 08             	cmp    $0x8,%eax
    aba2:	75 49                	jne    abed <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    aba4:	8b 55 0c             	mov    0xc(%ebp),%edx
    aba7:	89 d0                	mov    %edx,%eax
    aba9:	01 c0                	add    %eax,%eax
    abab:	01 d0                	add    %edx,%eax
    abad:	89 c2                	mov    %eax,%edx
    abaf:	8b 45 08             	mov    0x8(%ebp),%eax
    abb2:	01 c2                	add    %eax,%edx
    abb4:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    abb8:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    abba:	8b 55 0c             	mov    0xc(%ebp),%edx
    abbd:	89 d0                	mov    %edx,%eax
    abbf:	01 c0                	add    %eax,%eax
    abc1:	01 d0                	add    %edx,%eax
    abc3:	8d 50 01             	lea    0x1(%eax),%edx
    abc6:	8b 45 08             	mov    0x8(%ebp),%eax
    abc9:	01 c2                	add    %eax,%edx
    abcb:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    abcf:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    abd1:	8b 55 0c             	mov    0xc(%ebp),%edx
    abd4:	89 d0                	mov    %edx,%eax
    abd6:	01 c0                	add    %eax,%eax
    abd8:	01 d0                	add    %edx,%eax
    abda:	8d 50 02             	lea    0x2(%eax),%edx
    abdd:	8b 45 08             	mov    0x8(%ebp),%eax
    abe0:	01 c2                	add    %eax,%edx
    abe2:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    abe6:	88 02                	mov    %al,(%edx)
    abe8:	e9 ca 02 00 00       	jmp    aeb7 <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    abed:	8b 55 0c             	mov    0xc(%ebp),%edx
    abf0:	89 d0                	mov    %edx,%eax
    abf2:	01 c0                	add    %eax,%eax
    abf4:	01 d0                	add    %edx,%eax
    abf6:	01 c0                	add    %eax,%eax
    abf8:	89 c2                	mov    %eax,%edx
    abfa:	8b 45 08             	mov    0x8(%ebp),%eax
    abfd:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    ac00:	8b 55 0c             	mov    0xc(%ebp),%edx
    ac03:	89 d0                	mov    %edx,%eax
    ac05:	01 c0                	add    %eax,%eax
    ac07:	01 d0                	add    %edx,%eax
    ac09:	01 c0                	add    %eax,%eax
    ac0b:	8d 50 01             	lea    0x1(%eax),%edx
    ac0e:	8b 45 08             	mov    0x8(%ebp),%eax
    ac11:	01 d0                	add    %edx,%eax
    ac13:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    ac17:	88 10                	mov    %dl,(%eax)
    ac19:	0f b6 00             	movzbl (%eax),%eax
    ac1c:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    ac1e:	8b 55 0c             	mov    0xc(%ebp),%edx
    ac21:	89 d0                	mov    %edx,%eax
    ac23:	01 c0                	add    %eax,%eax
    ac25:	01 d0                	add    %edx,%eax
    ac27:	01 c0                	add    %eax,%eax
    ac29:	8d 50 02             	lea    0x2(%eax),%edx
    ac2c:	8b 45 08             	mov    0x8(%ebp),%eax
    ac2f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    ac32:	8b 55 0c             	mov    0xc(%ebp),%edx
    ac35:	89 d0                	mov    %edx,%eax
    ac37:	01 c0                	add    %eax,%eax
    ac39:	01 d0                	add    %edx,%eax
    ac3b:	01 c0                	add    %eax,%eax
    ac3d:	8d 50 03             	lea    0x3(%eax),%edx
    ac40:	8b 45 08             	mov    0x8(%ebp),%eax
    ac43:	01 d0                	add    %edx,%eax
    ac45:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    ac49:	88 10                	mov    %dl,(%eax)
    ac4b:	0f b6 00             	movzbl (%eax),%eax
    ac4e:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    ac50:	8b 55 0c             	mov    0xc(%ebp),%edx
    ac53:	89 d0                	mov    %edx,%eax
    ac55:	01 c0                	add    %eax,%eax
    ac57:	01 d0                	add    %edx,%eax
    ac59:	01 c0                	add    %eax,%eax
    ac5b:	8d 50 04             	lea    0x4(%eax),%edx
    ac5e:	8b 45 08             	mov    0x8(%ebp),%eax
    ac61:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    ac64:	8b 55 0c             	mov    0xc(%ebp),%edx
    ac67:	89 d0                	mov    %edx,%eax
    ac69:	01 c0                	add    %eax,%eax
    ac6b:	01 d0                	add    %edx,%eax
    ac6d:	01 c0                	add    %eax,%eax
    ac6f:	8d 50 05             	lea    0x5(%eax),%edx
    ac72:	8b 45 08             	mov    0x8(%ebp),%eax
    ac75:	01 d0                	add    %edx,%eax
    ac77:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    ac7b:	88 10                	mov    %dl,(%eax)
    ac7d:	0f b6 00             	movzbl (%eax),%eax
    ac80:	88 01                	mov    %al,(%ecx)
    ac82:	e9 30 02 00 00       	jmp    aeb7 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    ac87:	8b 45 10             	mov    0x10(%ebp),%eax
    ac8a:	8b 00                	mov    (%eax),%eax
    ac8c:	83 f8 03             	cmp    $0x3,%eax
    ac8f:	75 6d                	jne    acfe <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    ac91:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    ac95:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    ac99:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    ac9d:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    aca1:	53                   	push   %ebx
    aca2:	51                   	push   %ecx
    aca3:	52                   	push   %edx
    aca4:	50                   	push   %eax
    aca5:	ff 75 14             	pushl  0x14(%ebp)
    aca8:	e8 fd fb ff ff       	call   a8aa <color_tree_get>
    acad:	83 c4 14             	add    $0x14,%esp
    acb0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    acb3:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    acb7:	79 0a                	jns    acc3 <rgba8ToPixel+0x211>
    acb9:	b8 52 00 00 00       	mov    $0x52,%eax
    acbe:	e9 f9 01 00 00       	jmp    aebc <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    acc3:	8b 45 10             	mov    0x10(%ebp),%eax
    acc6:	8b 40 04             	mov    0x4(%eax),%eax
    acc9:	83 f8 08             	cmp    $0x8,%eax
    accc:	75 12                	jne    ace0 <rgba8ToPixel+0x22e>
    acce:	8b 55 0c             	mov    0xc(%ebp),%edx
    acd1:	8b 45 08             	mov    0x8(%ebp),%eax
    acd4:	01 d0                	add    %edx,%eax
    acd6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    acd9:	88 10                	mov    %dl,(%eax)
    acdb:	e9 d7 01 00 00       	jmp    aeb7 <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    ace0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ace3:	8b 45 10             	mov    0x10(%ebp),%eax
    ace6:	8b 40 04             	mov    0x4(%eax),%eax
    ace9:	52                   	push   %edx
    acea:	50                   	push   %eax
    aceb:	ff 75 0c             	pushl  0xc(%ebp)
    acee:	ff 75 08             	pushl  0x8(%ebp)
    acf1:	e8 ae fa ff ff       	call   a7a4 <addColorBits>
    acf6:	83 c4 10             	add    $0x10,%esp
    acf9:	e9 b9 01 00 00       	jmp    aeb7 <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    acfe:	8b 45 10             	mov    0x10(%ebp),%eax
    ad01:	8b 00                	mov    (%eax),%eax
    ad03:	83 f8 04             	cmp    $0x4,%eax
    ad06:	0f 85 9f 00 00 00    	jne    adab <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    ad0c:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    ad10:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    ad13:	8b 45 10             	mov    0x10(%ebp),%eax
    ad16:	8b 40 04             	mov    0x4(%eax),%eax
    ad19:	83 f8 08             	cmp    $0x8,%eax
    ad1c:	75 2a                	jne    ad48 <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    ad1e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad21:	01 c0                	add    %eax,%eax
    ad23:	89 c2                	mov    %eax,%edx
    ad25:	8b 45 08             	mov    0x8(%ebp),%eax
    ad28:	01 c2                	add    %eax,%edx
    ad2a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    ad2e:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    ad30:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad33:	01 c0                	add    %eax,%eax
    ad35:	8d 50 01             	lea    0x1(%eax),%edx
    ad38:	8b 45 08             	mov    0x8(%ebp),%eax
    ad3b:	01 c2                	add    %eax,%edx
    ad3d:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    ad41:	88 02                	mov    %al,(%edx)
    ad43:	e9 6f 01 00 00       	jmp    aeb7 <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    ad48:	8b 45 10             	mov    0x10(%ebp),%eax
    ad4b:	8b 40 04             	mov    0x4(%eax),%eax
    ad4e:	83 f8 10             	cmp    $0x10,%eax
    ad51:	0f 85 60 01 00 00    	jne    aeb7 <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    ad57:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad5a:	c1 e0 02             	shl    $0x2,%eax
    ad5d:	89 c2                	mov    %eax,%edx
    ad5f:	8b 45 08             	mov    0x8(%ebp),%eax
    ad62:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    ad65:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad68:	c1 e0 02             	shl    $0x2,%eax
    ad6b:	8d 50 01             	lea    0x1(%eax),%edx
    ad6e:	8b 45 08             	mov    0x8(%ebp),%eax
    ad71:	01 d0                	add    %edx,%eax
    ad73:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    ad77:	88 10                	mov    %dl,(%eax)
    ad79:	0f b6 00             	movzbl (%eax),%eax
    ad7c:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    ad7e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad81:	c1 e0 02             	shl    $0x2,%eax
    ad84:	8d 50 02             	lea    0x2(%eax),%edx
    ad87:	8b 45 08             	mov    0x8(%ebp),%eax
    ad8a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    ad8d:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad90:	c1 e0 02             	shl    $0x2,%eax
    ad93:	8d 50 03             	lea    0x3(%eax),%edx
    ad96:	8b 45 08             	mov    0x8(%ebp),%eax
    ad99:	01 d0                	add    %edx,%eax
    ad9b:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    ad9f:	88 10                	mov    %dl,(%eax)
    ada1:	0f b6 00             	movzbl (%eax),%eax
    ada4:	88 01                	mov    %al,(%ecx)
    ada6:	e9 0c 01 00 00       	jmp    aeb7 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    adab:	8b 45 10             	mov    0x10(%ebp),%eax
    adae:	8b 00                	mov    (%eax),%eax
    adb0:	83 f8 06             	cmp    $0x6,%eax
    adb3:	0f 85 fe 00 00 00    	jne    aeb7 <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    adb9:	8b 45 10             	mov    0x10(%ebp),%eax
    adbc:	8b 40 04             	mov    0x4(%eax),%eax
    adbf:	83 f8 08             	cmp    $0x8,%eax
    adc2:	75 54                	jne    ae18 <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    adc4:	8b 45 0c             	mov    0xc(%ebp),%eax
    adc7:	c1 e0 02             	shl    $0x2,%eax
    adca:	89 c2                	mov    %eax,%edx
    adcc:	8b 45 08             	mov    0x8(%ebp),%eax
    adcf:	01 c2                	add    %eax,%edx
    add1:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    add5:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    add7:	8b 45 0c             	mov    0xc(%ebp),%eax
    adda:	c1 e0 02             	shl    $0x2,%eax
    addd:	8d 50 01             	lea    0x1(%eax),%edx
    ade0:	8b 45 08             	mov    0x8(%ebp),%eax
    ade3:	01 c2                	add    %eax,%edx
    ade5:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    ade9:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    adeb:	8b 45 0c             	mov    0xc(%ebp),%eax
    adee:	c1 e0 02             	shl    $0x2,%eax
    adf1:	8d 50 02             	lea    0x2(%eax),%edx
    adf4:	8b 45 08             	mov    0x8(%ebp),%eax
    adf7:	01 c2                	add    %eax,%edx
    adf9:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    adfd:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    adff:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae02:	c1 e0 02             	shl    $0x2,%eax
    ae05:	8d 50 03             	lea    0x3(%eax),%edx
    ae08:	8b 45 08             	mov    0x8(%ebp),%eax
    ae0b:	01 c2                	add    %eax,%edx
    ae0d:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    ae11:	88 02                	mov    %al,(%edx)
    ae13:	e9 9f 00 00 00       	jmp    aeb7 <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    ae18:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae1b:	c1 e0 03             	shl    $0x3,%eax
    ae1e:	89 c2                	mov    %eax,%edx
    ae20:	8b 45 08             	mov    0x8(%ebp),%eax
    ae23:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    ae26:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae29:	c1 e0 03             	shl    $0x3,%eax
    ae2c:	8d 50 01             	lea    0x1(%eax),%edx
    ae2f:	8b 45 08             	mov    0x8(%ebp),%eax
    ae32:	01 d0                	add    %edx,%eax
    ae34:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    ae38:	88 10                	mov    %dl,(%eax)
    ae3a:	0f b6 00             	movzbl (%eax),%eax
    ae3d:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    ae3f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae42:	c1 e0 03             	shl    $0x3,%eax
    ae45:	8d 50 02             	lea    0x2(%eax),%edx
    ae48:	8b 45 08             	mov    0x8(%ebp),%eax
    ae4b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    ae4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae51:	c1 e0 03             	shl    $0x3,%eax
    ae54:	8d 50 03             	lea    0x3(%eax),%edx
    ae57:	8b 45 08             	mov    0x8(%ebp),%eax
    ae5a:	01 d0                	add    %edx,%eax
    ae5c:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    ae60:	88 10                	mov    %dl,(%eax)
    ae62:	0f b6 00             	movzbl (%eax),%eax
    ae65:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    ae67:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae6a:	c1 e0 03             	shl    $0x3,%eax
    ae6d:	8d 50 04             	lea    0x4(%eax),%edx
    ae70:	8b 45 08             	mov    0x8(%ebp),%eax
    ae73:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    ae76:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae79:	c1 e0 03             	shl    $0x3,%eax
    ae7c:	8d 50 05             	lea    0x5(%eax),%edx
    ae7f:	8b 45 08             	mov    0x8(%ebp),%eax
    ae82:	01 d0                	add    %edx,%eax
    ae84:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    ae88:	88 10                	mov    %dl,(%eax)
    ae8a:	0f b6 00             	movzbl (%eax),%eax
    ae8d:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    ae8f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae92:	c1 e0 03             	shl    $0x3,%eax
    ae95:	8d 50 06             	lea    0x6(%eax),%edx
    ae98:	8b 45 08             	mov    0x8(%ebp),%eax
    ae9b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    ae9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    aea1:	c1 e0 03             	shl    $0x3,%eax
    aea4:	8d 50 07             	lea    0x7(%eax),%edx
    aea7:	8b 45 08             	mov    0x8(%ebp),%eax
    aeaa:	01 d0                	add    %edx,%eax
    aeac:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    aeb0:	88 10                	mov    %dl,(%eax)
    aeb2:	0f b6 00             	movzbl (%eax),%eax
    aeb5:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    aeb7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    aebc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    aebf:	c9                   	leave  
    aec0:	c3                   	ret    

0000aec1 <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    aec1:	55                   	push   %ebp
    aec2:	89 e5                	mov    %esp,%ebp
    aec4:	53                   	push   %ebx
    aec5:	83 ec 20             	sub    $0x20,%esp
    aec8:	8b 5d 14             	mov    0x14(%ebp),%ebx
    aecb:	8b 4d 18             	mov    0x18(%ebp),%ecx
    aece:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aed1:	8b 45 20             	mov    0x20(%ebp),%eax
    aed4:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    aed8:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    aedc:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    aee0:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    aee4:	8b 45 10             	mov    0x10(%ebp),%eax
    aee7:	8b 00                	mov    (%eax),%eax
    aee9:	85 c0                	test   %eax,%eax
    aeeb:	75 36                	jne    af23 <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    aeed:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    aef1:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    aef5:	8b 45 0c             	mov    0xc(%ebp),%eax
    aef8:	01 c0                	add    %eax,%eax
    aefa:	89 c2                	mov    %eax,%edx
    aefc:	8b 45 08             	mov    0x8(%ebp),%eax
    aeff:	01 d0                	add    %edx,%eax
    af01:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    af05:	66 c1 ea 08          	shr    $0x8,%dx
    af09:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    af0b:	8b 45 0c             	mov    0xc(%ebp),%eax
    af0e:	01 c0                	add    %eax,%eax
    af10:	8d 50 01             	lea    0x1(%eax),%edx
    af13:	8b 45 08             	mov    0x8(%ebp),%eax
    af16:	01 d0                	add    %edx,%eax
    af18:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    af1c:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    af1e:	e9 df 01 00 00       	jmp    b102 <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    af23:	8b 45 10             	mov    0x10(%ebp),%eax
    af26:	8b 00                	mov    (%eax),%eax
    af28:	83 f8 02             	cmp    $0x2,%eax
    af2b:	0f 85 a6 00 00 00    	jne    afd7 <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    af31:	8b 55 0c             	mov    0xc(%ebp),%edx
    af34:	89 d0                	mov    %edx,%eax
    af36:	01 c0                	add    %eax,%eax
    af38:	01 d0                	add    %edx,%eax
    af3a:	01 c0                	add    %eax,%eax
    af3c:	89 c2                	mov    %eax,%edx
    af3e:	8b 45 08             	mov    0x8(%ebp),%eax
    af41:	01 d0                	add    %edx,%eax
    af43:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    af47:	66 c1 ea 08          	shr    $0x8,%dx
    af4b:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    af4d:	8b 55 0c             	mov    0xc(%ebp),%edx
    af50:	89 d0                	mov    %edx,%eax
    af52:	01 c0                	add    %eax,%eax
    af54:	01 d0                	add    %edx,%eax
    af56:	01 c0                	add    %eax,%eax
    af58:	8d 50 01             	lea    0x1(%eax),%edx
    af5b:	8b 45 08             	mov    0x8(%ebp),%eax
    af5e:	01 d0                	add    %edx,%eax
    af60:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    af64:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    af66:	8b 55 0c             	mov    0xc(%ebp),%edx
    af69:	89 d0                	mov    %edx,%eax
    af6b:	01 c0                	add    %eax,%eax
    af6d:	01 d0                	add    %edx,%eax
    af6f:	01 c0                	add    %eax,%eax
    af71:	8d 50 02             	lea    0x2(%eax),%edx
    af74:	8b 45 08             	mov    0x8(%ebp),%eax
    af77:	01 d0                	add    %edx,%eax
    af79:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    af7d:	66 c1 ea 08          	shr    $0x8,%dx
    af81:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    af83:	8b 55 0c             	mov    0xc(%ebp),%edx
    af86:	89 d0                	mov    %edx,%eax
    af88:	01 c0                	add    %eax,%eax
    af8a:	01 d0                	add    %edx,%eax
    af8c:	01 c0                	add    %eax,%eax
    af8e:	8d 50 03             	lea    0x3(%eax),%edx
    af91:	8b 45 08             	mov    0x8(%ebp),%eax
    af94:	01 d0                	add    %edx,%eax
    af96:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    af9a:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    af9c:	8b 55 0c             	mov    0xc(%ebp),%edx
    af9f:	89 d0                	mov    %edx,%eax
    afa1:	01 c0                	add    %eax,%eax
    afa3:	01 d0                	add    %edx,%eax
    afa5:	01 c0                	add    %eax,%eax
    afa7:	8d 50 04             	lea    0x4(%eax),%edx
    afaa:	8b 45 08             	mov    0x8(%ebp),%eax
    afad:	01 d0                	add    %edx,%eax
    afaf:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    afb3:	66 c1 ea 08          	shr    $0x8,%dx
    afb7:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    afb9:	8b 55 0c             	mov    0xc(%ebp),%edx
    afbc:	89 d0                	mov    %edx,%eax
    afbe:	01 c0                	add    %eax,%eax
    afc0:	01 d0                	add    %edx,%eax
    afc2:	01 c0                	add    %eax,%eax
    afc4:	8d 50 05             	lea    0x5(%eax),%edx
    afc7:	8b 45 08             	mov    0x8(%ebp),%eax
    afca:	01 d0                	add    %edx,%eax
    afcc:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    afd0:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    afd2:	e9 2b 01 00 00       	jmp    b102 <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    afd7:	8b 45 10             	mov    0x10(%ebp),%eax
    afda:	8b 00                	mov    (%eax),%eax
    afdc:	83 f8 04             	cmp    $0x4,%eax
    afdf:	75 64                	jne    b045 <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    afe1:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    afe5:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    afe9:	8b 45 0c             	mov    0xc(%ebp),%eax
    afec:	c1 e0 02             	shl    $0x2,%eax
    afef:	89 c2                	mov    %eax,%edx
    aff1:	8b 45 08             	mov    0x8(%ebp),%eax
    aff4:	01 d0                	add    %edx,%eax
    aff6:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    affa:	66 c1 ea 08          	shr    $0x8,%dx
    affe:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    b000:	8b 45 0c             	mov    0xc(%ebp),%eax
    b003:	c1 e0 02             	shl    $0x2,%eax
    b006:	8d 50 01             	lea    0x1(%eax),%edx
    b009:	8b 45 08             	mov    0x8(%ebp),%eax
    b00c:	01 d0                	add    %edx,%eax
    b00e:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    b012:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    b014:	8b 45 0c             	mov    0xc(%ebp),%eax
    b017:	c1 e0 02             	shl    $0x2,%eax
    b01a:	8d 50 02             	lea    0x2(%eax),%edx
    b01d:	8b 45 08             	mov    0x8(%ebp),%eax
    b020:	01 d0                	add    %edx,%eax
    b022:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    b026:	66 c1 ea 08          	shr    $0x8,%dx
    b02a:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    b02c:	8b 45 0c             	mov    0xc(%ebp),%eax
    b02f:	c1 e0 02             	shl    $0x2,%eax
    b032:	8d 50 03             	lea    0x3(%eax),%edx
    b035:	8b 45 08             	mov    0x8(%ebp),%eax
    b038:	01 d0                	add    %edx,%eax
    b03a:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    b03e:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    b040:	e9 bd 00 00 00       	jmp    b102 <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    b045:	8b 45 10             	mov    0x10(%ebp),%eax
    b048:	8b 00                	mov    (%eax),%eax
    b04a:	83 f8 06             	cmp    $0x6,%eax
    b04d:	0f 85 af 00 00 00    	jne    b102 <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    b053:	8b 45 0c             	mov    0xc(%ebp),%eax
    b056:	c1 e0 03             	shl    $0x3,%eax
    b059:	89 c2                	mov    %eax,%edx
    b05b:	8b 45 08             	mov    0x8(%ebp),%eax
    b05e:	01 d0                	add    %edx,%eax
    b060:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    b064:	66 c1 ea 08          	shr    $0x8,%dx
    b068:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    b06a:	8b 45 0c             	mov    0xc(%ebp),%eax
    b06d:	c1 e0 03             	shl    $0x3,%eax
    b070:	8d 50 01             	lea    0x1(%eax),%edx
    b073:	8b 45 08             	mov    0x8(%ebp),%eax
    b076:	01 d0                	add    %edx,%eax
    b078:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    b07c:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    b07e:	8b 45 0c             	mov    0xc(%ebp),%eax
    b081:	c1 e0 03             	shl    $0x3,%eax
    b084:	8d 50 02             	lea    0x2(%eax),%edx
    b087:	8b 45 08             	mov    0x8(%ebp),%eax
    b08a:	01 d0                	add    %edx,%eax
    b08c:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    b090:	66 c1 ea 08          	shr    $0x8,%dx
    b094:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    b096:	8b 45 0c             	mov    0xc(%ebp),%eax
    b099:	c1 e0 03             	shl    $0x3,%eax
    b09c:	8d 50 03             	lea    0x3(%eax),%edx
    b09f:	8b 45 08             	mov    0x8(%ebp),%eax
    b0a2:	01 d0                	add    %edx,%eax
    b0a4:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    b0a8:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    b0aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    b0ad:	c1 e0 03             	shl    $0x3,%eax
    b0b0:	8d 50 04             	lea    0x4(%eax),%edx
    b0b3:	8b 45 08             	mov    0x8(%ebp),%eax
    b0b6:	01 d0                	add    %edx,%eax
    b0b8:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    b0bc:	66 c1 ea 08          	shr    $0x8,%dx
    b0c0:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    b0c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    b0c5:	c1 e0 03             	shl    $0x3,%eax
    b0c8:	8d 50 05             	lea    0x5(%eax),%edx
    b0cb:	8b 45 08             	mov    0x8(%ebp),%eax
    b0ce:	01 d0                	add    %edx,%eax
    b0d0:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    b0d4:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    b0d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    b0d9:	c1 e0 03             	shl    $0x3,%eax
    b0dc:	8d 50 06             	lea    0x6(%eax),%edx
    b0df:	8b 45 08             	mov    0x8(%ebp),%eax
    b0e2:	01 d0                	add    %edx,%eax
    b0e4:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    b0e8:	66 c1 ea 08          	shr    $0x8,%dx
    b0ec:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    b0ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    b0f1:	c1 e0 03             	shl    $0x3,%eax
    b0f4:	8d 50 07             	lea    0x7(%eax),%edx
    b0f7:	8b 45 08             	mov    0x8(%ebp),%eax
    b0fa:	01 d0                	add    %edx,%eax
    b0fc:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    b100:	88 10                	mov    %dl,(%eax)
  }
}
    b102:	90                   	nop
    b103:	83 c4 20             	add    $0x20,%esp
    b106:	5b                   	pop    %ebx
    b107:	5d                   	pop    %ebp
    b108:	c3                   	ret    

0000b109 <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    b109:	55                   	push   %ebp
    b10a:	89 e5                	mov    %esp,%ebp
    b10c:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    b10f:	8b 45 20             	mov    0x20(%ebp),%eax
    b112:	8b 00                	mov    (%eax),%eax
    b114:	85 c0                	test   %eax,%eax
    b116:	0f 85 8c 01 00 00    	jne    b2a8 <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    b11c:	8b 45 20             	mov    0x20(%ebp),%eax
    b11f:	8b 40 04             	mov    0x4(%eax),%eax
    b122:	83 f8 08             	cmp    $0x8,%eax
    b125:	75 59                	jne    b180 <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    b127:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b12a:	8b 45 18             	mov    0x18(%ebp),%eax
    b12d:	01 d0                	add    %edx,%eax
    b12f:	0f b6 10             	movzbl (%eax),%edx
    b132:	8b 45 10             	mov    0x10(%ebp),%eax
    b135:	88 10                	mov    %dl,(%eax)
    b137:	8b 45 10             	mov    0x10(%ebp),%eax
    b13a:	0f b6 10             	movzbl (%eax),%edx
    b13d:	8b 45 0c             	mov    0xc(%ebp),%eax
    b140:	88 10                	mov    %dl,(%eax)
    b142:	8b 45 0c             	mov    0xc(%ebp),%eax
    b145:	0f b6 10             	movzbl (%eax),%edx
    b148:	8b 45 08             	mov    0x8(%ebp),%eax
    b14b:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    b14d:	8b 45 20             	mov    0x20(%ebp),%eax
    b150:	8b 40 10             	mov    0x10(%eax),%eax
    b153:	85 c0                	test   %eax,%eax
    b155:	74 1e                	je     b175 <getPixelColorRGBA8+0x6c>
    b157:	8b 45 08             	mov    0x8(%ebp),%eax
    b15a:	0f b6 00             	movzbl (%eax),%eax
    b15d:	0f b6 d0             	movzbl %al,%edx
    b160:	8b 45 20             	mov    0x20(%ebp),%eax
    b163:	8b 40 14             	mov    0x14(%eax),%eax
    b166:	39 c2                	cmp    %eax,%edx
    b168:	75 0b                	jne    b175 <getPixelColorRGBA8+0x6c>
    b16a:	8b 45 14             	mov    0x14(%ebp),%eax
    b16d:	c6 00 00             	movb   $0x0,(%eax)
    b170:	e9 5e 05 00 00       	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    b175:	8b 45 14             	mov    0x14(%ebp),%eax
    b178:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b17b:	e9 53 05 00 00       	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    b180:	8b 45 20             	mov    0x20(%ebp),%eax
    b183:	8b 40 04             	mov    0x4(%eax),%eax
    b186:	83 f8 10             	cmp    $0x10,%eax
    b189:	0f 85 80 00 00 00    	jne    b20f <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    b18f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b192:	01 c0                	add    %eax,%eax
    b194:	89 c2                	mov    %eax,%edx
    b196:	8b 45 18             	mov    0x18(%ebp),%eax
    b199:	01 d0                	add    %edx,%eax
    b19b:	0f b6 10             	movzbl (%eax),%edx
    b19e:	8b 45 10             	mov    0x10(%ebp),%eax
    b1a1:	88 10                	mov    %dl,(%eax)
    b1a3:	8b 45 10             	mov    0x10(%ebp),%eax
    b1a6:	0f b6 10             	movzbl (%eax),%edx
    b1a9:	8b 45 0c             	mov    0xc(%ebp),%eax
    b1ac:	88 10                	mov    %dl,(%eax)
    b1ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    b1b1:	0f b6 10             	movzbl (%eax),%edx
    b1b4:	8b 45 08             	mov    0x8(%ebp),%eax
    b1b7:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    b1b9:	8b 45 20             	mov    0x20(%ebp),%eax
    b1bc:	8b 40 10             	mov    0x10(%eax),%eax
    b1bf:	85 c0                	test   %eax,%eax
    b1c1:	74 41                	je     b204 <getPixelColorRGBA8+0xfb>
    b1c3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b1c6:	01 c0                	add    %eax,%eax
    b1c8:	89 c2                	mov    %eax,%edx
    b1ca:	8b 45 18             	mov    0x18(%ebp),%eax
    b1cd:	01 d0                	add    %edx,%eax
    b1cf:	0f b6 00             	movzbl (%eax),%eax
    b1d2:	0f b6 c0             	movzbl %al,%eax
    b1d5:	c1 e0 08             	shl    $0x8,%eax
    b1d8:	89 c2                	mov    %eax,%edx
    b1da:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b1dd:	01 c0                	add    %eax,%eax
    b1df:	8d 48 01             	lea    0x1(%eax),%ecx
    b1e2:	8b 45 18             	mov    0x18(%ebp),%eax
    b1e5:	01 c8                	add    %ecx,%eax
    b1e7:	0f b6 00             	movzbl (%eax),%eax
    b1ea:	0f b6 c0             	movzbl %al,%eax
    b1ed:	01 c2                	add    %eax,%edx
    b1ef:	8b 45 20             	mov    0x20(%ebp),%eax
    b1f2:	8b 40 14             	mov    0x14(%eax),%eax
    b1f5:	39 c2                	cmp    %eax,%edx
    b1f7:	75 0b                	jne    b204 <getPixelColorRGBA8+0xfb>
    b1f9:	8b 45 14             	mov    0x14(%ebp),%eax
    b1fc:	c6 00 00             	movb   $0x0,(%eax)
    b1ff:	e9 cf 04 00 00       	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    b204:	8b 45 14             	mov    0x14(%ebp),%eax
    b207:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b20a:	e9 c4 04 00 00       	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b20f:	8b 45 20             	mov    0x20(%ebp),%eax
    b212:	8b 40 04             	mov    0x4(%eax),%eax
    b215:	ba 01 00 00 00       	mov    $0x1,%edx
    b21a:	89 c1                	mov    %eax,%ecx
    b21c:	d3 e2                	shl    %cl,%edx
    b21e:	89 d0                	mov    %edx,%eax
    b220:	83 e8 01             	sub    $0x1,%eax
    b223:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    b226:	8b 45 20             	mov    0x20(%ebp),%eax
    b229:	8b 50 04             	mov    0x4(%eax),%edx
    b22c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b22f:	0f af c2             	imul   %edx,%eax
    b232:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b235:	8b 45 20             	mov    0x20(%ebp),%eax
    b238:	8b 40 04             	mov    0x4(%eax),%eax
    b23b:	50                   	push   %eax
    b23c:	ff 75 18             	pushl  0x18(%ebp)
    b23f:	8d 45 f0             	lea    -0x10(%ebp),%eax
    b242:	50                   	push   %eax
    b243:	e8 06 db ff ff       	call   8d4e <readBitsFromReversedStream>
    b248:	83 c4 0c             	add    $0xc,%esp
    b24b:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    b24e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    b251:	89 d0                	mov    %edx,%eax
    b253:	c1 e0 08             	shl    $0x8,%eax
    b256:	29 d0                	sub    %edx,%eax
    b258:	ba 00 00 00 00       	mov    $0x0,%edx
    b25d:	f7 75 f8             	divl   -0x8(%ebp)
    b260:	89 c2                	mov    %eax,%edx
    b262:	8b 45 10             	mov    0x10(%ebp),%eax
    b265:	88 10                	mov    %dl,(%eax)
    b267:	8b 45 10             	mov    0x10(%ebp),%eax
    b26a:	0f b6 10             	movzbl (%eax),%edx
    b26d:	8b 45 0c             	mov    0xc(%ebp),%eax
    b270:	88 10                	mov    %dl,(%eax)
    b272:	8b 45 0c             	mov    0xc(%ebp),%eax
    b275:	0f b6 10             	movzbl (%eax),%edx
    b278:	8b 45 08             	mov    0x8(%ebp),%eax
    b27b:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    b27d:	8b 45 20             	mov    0x20(%ebp),%eax
    b280:	8b 40 10             	mov    0x10(%eax),%eax
    b283:	85 c0                	test   %eax,%eax
    b285:	74 16                	je     b29d <getPixelColorRGBA8+0x194>
    b287:	8b 45 20             	mov    0x20(%ebp),%eax
    b28a:	8b 40 14             	mov    0x14(%eax),%eax
    b28d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    b290:	75 0b                	jne    b29d <getPixelColorRGBA8+0x194>
    b292:	8b 45 14             	mov    0x14(%ebp),%eax
    b295:	c6 00 00             	movb   $0x0,(%eax)
    b298:	e9 36 04 00 00       	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    b29d:	8b 45 14             	mov    0x14(%ebp),%eax
    b2a0:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b2a3:	e9 2b 04 00 00       	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    b2a8:	8b 45 20             	mov    0x20(%ebp),%eax
    b2ab:	8b 00                	mov    (%eax),%eax
    b2ad:	83 f8 02             	cmp    $0x2,%eax
    b2b0:	0f 85 f5 01 00 00    	jne    b4ab <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    b2b6:	8b 45 20             	mov    0x20(%ebp),%eax
    b2b9:	8b 40 04             	mov    0x4(%eax),%eax
    b2bc:	83 f8 08             	cmp    $0x8,%eax
    b2bf:	0f 85 a3 00 00 00    	jne    b368 <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    b2c5:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b2c8:	89 d0                	mov    %edx,%eax
    b2ca:	01 c0                	add    %eax,%eax
    b2cc:	01 d0                	add    %edx,%eax
    b2ce:	89 c2                	mov    %eax,%edx
    b2d0:	8b 45 18             	mov    0x18(%ebp),%eax
    b2d3:	01 d0                	add    %edx,%eax
    b2d5:	0f b6 10             	movzbl (%eax),%edx
    b2d8:	8b 45 08             	mov    0x8(%ebp),%eax
    b2db:	88 10                	mov    %dl,(%eax)
    b2dd:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b2e0:	89 d0                	mov    %edx,%eax
    b2e2:	01 c0                	add    %eax,%eax
    b2e4:	01 d0                	add    %edx,%eax
    b2e6:	8d 50 01             	lea    0x1(%eax),%edx
    b2e9:	8b 45 18             	mov    0x18(%ebp),%eax
    b2ec:	01 d0                	add    %edx,%eax
    b2ee:	0f b6 10             	movzbl (%eax),%edx
    b2f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    b2f4:	88 10                	mov    %dl,(%eax)
    b2f6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b2f9:	89 d0                	mov    %edx,%eax
    b2fb:	01 c0                	add    %eax,%eax
    b2fd:	01 d0                	add    %edx,%eax
    b2ff:	8d 50 02             	lea    0x2(%eax),%edx
    b302:	8b 45 18             	mov    0x18(%ebp),%eax
    b305:	01 d0                	add    %edx,%eax
    b307:	0f b6 10             	movzbl (%eax),%edx
    b30a:	8b 45 10             	mov    0x10(%ebp),%eax
    b30d:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    b30f:	8b 45 20             	mov    0x20(%ebp),%eax
    b312:	8b 40 10             	mov    0x10(%eax),%eax
    b315:	85 c0                	test   %eax,%eax
    b317:	74 44                	je     b35d <getPixelColorRGBA8+0x254>
    b319:	8b 45 08             	mov    0x8(%ebp),%eax
    b31c:	0f b6 00             	movzbl (%eax),%eax
    b31f:	0f b6 d0             	movzbl %al,%edx
    b322:	8b 45 20             	mov    0x20(%ebp),%eax
    b325:	8b 40 14             	mov    0x14(%eax),%eax
    b328:	39 c2                	cmp    %eax,%edx
    b32a:	75 31                	jne    b35d <getPixelColorRGBA8+0x254>
    b32c:	8b 45 0c             	mov    0xc(%ebp),%eax
    b32f:	0f b6 00             	movzbl (%eax),%eax
    b332:	0f b6 d0             	movzbl %al,%edx
    b335:	8b 45 20             	mov    0x20(%ebp),%eax
    b338:	8b 40 18             	mov    0x18(%eax),%eax
    b33b:	39 c2                	cmp    %eax,%edx
    b33d:	75 1e                	jne    b35d <getPixelColorRGBA8+0x254>
    b33f:	8b 45 10             	mov    0x10(%ebp),%eax
    b342:	0f b6 00             	movzbl (%eax),%eax
    b345:	0f b6 d0             	movzbl %al,%edx
    b348:	8b 45 20             	mov    0x20(%ebp),%eax
    b34b:	8b 40 1c             	mov    0x1c(%eax),%eax
    b34e:	39 c2                	cmp    %eax,%edx
    b350:	75 0b                	jne    b35d <getPixelColorRGBA8+0x254>
    b352:	8b 45 14             	mov    0x14(%ebp),%eax
    b355:	c6 00 00             	movb   $0x0,(%eax)
    b358:	e9 76 03 00 00       	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    b35d:	8b 45 14             	mov    0x14(%ebp),%eax
    b360:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b363:	e9 6b 03 00 00       	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    b368:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b36b:	89 d0                	mov    %edx,%eax
    b36d:	01 c0                	add    %eax,%eax
    b36f:	01 d0                	add    %edx,%eax
    b371:	01 c0                	add    %eax,%eax
    b373:	89 c2                	mov    %eax,%edx
    b375:	8b 45 18             	mov    0x18(%ebp),%eax
    b378:	01 d0                	add    %edx,%eax
    b37a:	0f b6 10             	movzbl (%eax),%edx
    b37d:	8b 45 08             	mov    0x8(%ebp),%eax
    b380:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    b382:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b385:	89 d0                	mov    %edx,%eax
    b387:	01 c0                	add    %eax,%eax
    b389:	01 d0                	add    %edx,%eax
    b38b:	01 c0                	add    %eax,%eax
    b38d:	8d 50 02             	lea    0x2(%eax),%edx
    b390:	8b 45 18             	mov    0x18(%ebp),%eax
    b393:	01 d0                	add    %edx,%eax
    b395:	0f b6 10             	movzbl (%eax),%edx
    b398:	8b 45 0c             	mov    0xc(%ebp),%eax
    b39b:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    b39d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b3a0:	89 d0                	mov    %edx,%eax
    b3a2:	01 c0                	add    %eax,%eax
    b3a4:	01 d0                	add    %edx,%eax
    b3a6:	01 c0                	add    %eax,%eax
    b3a8:	8d 50 04             	lea    0x4(%eax),%edx
    b3ab:	8b 45 18             	mov    0x18(%ebp),%eax
    b3ae:	01 d0                	add    %edx,%eax
    b3b0:	0f b6 10             	movzbl (%eax),%edx
    b3b3:	8b 45 10             	mov    0x10(%ebp),%eax
    b3b6:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b3b8:	8b 45 20             	mov    0x20(%ebp),%eax
    b3bb:	8b 40 10             	mov    0x10(%eax),%eax
    b3be:	85 c0                	test   %eax,%eax
    b3c0:	0f 84 da 00 00 00    	je     b4a0 <getPixelColorRGBA8+0x397>
    b3c6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b3c9:	89 d0                	mov    %edx,%eax
    b3cb:	01 c0                	add    %eax,%eax
    b3cd:	01 d0                	add    %edx,%eax
    b3cf:	01 c0                	add    %eax,%eax
    b3d1:	89 c2                	mov    %eax,%edx
    b3d3:	8b 45 18             	mov    0x18(%ebp),%eax
    b3d6:	01 d0                	add    %edx,%eax
    b3d8:	0f b6 00             	movzbl (%eax),%eax
    b3db:	0f b6 c0             	movzbl %al,%eax
    b3de:	c1 e0 08             	shl    $0x8,%eax
    b3e1:	89 c1                	mov    %eax,%ecx
    b3e3:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b3e6:	89 d0                	mov    %edx,%eax
    b3e8:	01 c0                	add    %eax,%eax
    b3ea:	01 d0                	add    %edx,%eax
    b3ec:	01 c0                	add    %eax,%eax
    b3ee:	8d 50 01             	lea    0x1(%eax),%edx
    b3f1:	8b 45 18             	mov    0x18(%ebp),%eax
    b3f4:	01 d0                	add    %edx,%eax
    b3f6:	0f b6 00             	movzbl (%eax),%eax
    b3f9:	0f b6 c0             	movzbl %al,%eax
    b3fc:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b3ff:	8b 45 20             	mov    0x20(%ebp),%eax
    b402:	8b 40 14             	mov    0x14(%eax),%eax
    b405:	39 c2                	cmp    %eax,%edx
    b407:	0f 85 93 00 00 00    	jne    b4a0 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b40d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b410:	89 d0                	mov    %edx,%eax
    b412:	01 c0                	add    %eax,%eax
    b414:	01 d0                	add    %edx,%eax
    b416:	01 c0                	add    %eax,%eax
    b418:	8d 50 02             	lea    0x2(%eax),%edx
    b41b:	8b 45 18             	mov    0x18(%ebp),%eax
    b41e:	01 d0                	add    %edx,%eax
    b420:	0f b6 00             	movzbl (%eax),%eax
    b423:	0f b6 c0             	movzbl %al,%eax
    b426:	c1 e0 08             	shl    $0x8,%eax
    b429:	89 c1                	mov    %eax,%ecx
    b42b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b42e:	89 d0                	mov    %edx,%eax
    b430:	01 c0                	add    %eax,%eax
    b432:	01 d0                	add    %edx,%eax
    b434:	01 c0                	add    %eax,%eax
    b436:	8d 50 03             	lea    0x3(%eax),%edx
    b439:	8b 45 18             	mov    0x18(%ebp),%eax
    b43c:	01 d0                	add    %edx,%eax
    b43e:	0f b6 00             	movzbl (%eax),%eax
    b441:	0f b6 c0             	movzbl %al,%eax
    b444:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b447:	8b 45 20             	mov    0x20(%ebp),%eax
    b44a:	8b 40 18             	mov    0x18(%eax),%eax
    b44d:	39 c2                	cmp    %eax,%edx
    b44f:	75 4f                	jne    b4a0 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    b451:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b454:	89 d0                	mov    %edx,%eax
    b456:	01 c0                	add    %eax,%eax
    b458:	01 d0                	add    %edx,%eax
    b45a:	01 c0                	add    %eax,%eax
    b45c:	8d 50 04             	lea    0x4(%eax),%edx
    b45f:	8b 45 18             	mov    0x18(%ebp),%eax
    b462:	01 d0                	add    %edx,%eax
    b464:	0f b6 00             	movzbl (%eax),%eax
    b467:	0f b6 c0             	movzbl %al,%eax
    b46a:	c1 e0 08             	shl    $0x8,%eax
    b46d:	89 c1                	mov    %eax,%ecx
    b46f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b472:	89 d0                	mov    %edx,%eax
    b474:	01 c0                	add    %eax,%eax
    b476:	01 d0                	add    %edx,%eax
    b478:	01 c0                	add    %eax,%eax
    b47a:	8d 50 05             	lea    0x5(%eax),%edx
    b47d:	8b 45 18             	mov    0x18(%ebp),%eax
    b480:	01 d0                	add    %edx,%eax
    b482:	0f b6 00             	movzbl (%eax),%eax
    b485:	0f b6 c0             	movzbl %al,%eax
    b488:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b48b:	8b 45 20             	mov    0x20(%ebp),%eax
    b48e:	8b 40 1c             	mov    0x1c(%eax),%eax
    b491:	39 c2                	cmp    %eax,%edx
    b493:	75 0b                	jne    b4a0 <getPixelColorRGBA8+0x397>
    b495:	8b 45 14             	mov    0x14(%ebp),%eax
    b498:	c6 00 00             	movb   $0x0,(%eax)
    b49b:	e9 33 02 00 00       	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    b4a0:	8b 45 14             	mov    0x14(%ebp),%eax
    b4a3:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b4a6:	e9 28 02 00 00       	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b4ab:	8b 45 20             	mov    0x20(%ebp),%eax
    b4ae:	8b 00                	mov    (%eax),%eax
    b4b0:	83 f8 03             	cmp    $0x3,%eax
    b4b3:	0f 85 ac 00 00 00    	jne    b565 <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    b4b9:	8b 45 20             	mov    0x20(%ebp),%eax
    b4bc:	8b 40 04             	mov    0x4(%eax),%eax
    b4bf:	83 f8 08             	cmp    $0x8,%eax
    b4c2:	75 13                	jne    b4d7 <getPixelColorRGBA8+0x3ce>
    b4c4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b4c7:	8b 45 18             	mov    0x18(%ebp),%eax
    b4ca:	01 d0                	add    %edx,%eax
    b4cc:	0f b6 00             	movzbl (%eax),%eax
    b4cf:	0f b6 c0             	movzbl %al,%eax
    b4d2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    b4d5:	eb 28                	jmp    b4ff <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    b4d7:	8b 45 20             	mov    0x20(%ebp),%eax
    b4da:	8b 50 04             	mov    0x4(%eax),%edx
    b4dd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b4e0:	0f af c2             	imul   %edx,%eax
    b4e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b4e6:	8b 45 20             	mov    0x20(%ebp),%eax
    b4e9:	8b 40 04             	mov    0x4(%eax),%eax
    b4ec:	50                   	push   %eax
    b4ed:	ff 75 18             	pushl  0x18(%ebp)
    b4f0:	8d 45 ec             	lea    -0x14(%ebp),%eax
    b4f3:	50                   	push   %eax
    b4f4:	e8 55 d8 ff ff       	call   8d4e <readBitsFromReversedStream>
    b4f9:	83 c4 0c             	add    $0xc,%esp
    b4fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    b4ff:	8b 45 20             	mov    0x20(%ebp),%eax
    b502:	8b 40 08             	mov    0x8(%eax),%eax
    b505:	8b 55 fc             	mov    -0x4(%ebp),%edx
    b508:	c1 e2 02             	shl    $0x2,%edx
    b50b:	01 d0                	add    %edx,%eax
    b50d:	0f b6 10             	movzbl (%eax),%edx
    b510:	8b 45 08             	mov    0x8(%ebp),%eax
    b513:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    b515:	8b 45 20             	mov    0x20(%ebp),%eax
    b518:	8b 40 08             	mov    0x8(%eax),%eax
    b51b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    b51e:	c1 e2 02             	shl    $0x2,%edx
    b521:	83 c2 01             	add    $0x1,%edx
    b524:	01 d0                	add    %edx,%eax
    b526:	0f b6 10             	movzbl (%eax),%edx
    b529:	8b 45 0c             	mov    0xc(%ebp),%eax
    b52c:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    b52e:	8b 45 20             	mov    0x20(%ebp),%eax
    b531:	8b 40 08             	mov    0x8(%eax),%eax
    b534:	8b 55 fc             	mov    -0x4(%ebp),%edx
    b537:	c1 e2 02             	shl    $0x2,%edx
    b53a:	83 c2 02             	add    $0x2,%edx
    b53d:	01 d0                	add    %edx,%eax
    b53f:	0f b6 10             	movzbl (%eax),%edx
    b542:	8b 45 10             	mov    0x10(%ebp),%eax
    b545:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    b547:	8b 45 20             	mov    0x20(%ebp),%eax
    b54a:	8b 40 08             	mov    0x8(%eax),%eax
    b54d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    b550:	c1 e2 02             	shl    $0x2,%edx
    b553:	83 c2 03             	add    $0x3,%edx
    b556:	01 d0                	add    %edx,%eax
    b558:	0f b6 10             	movzbl (%eax),%edx
    b55b:	8b 45 14             	mov    0x14(%ebp),%eax
    b55e:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b560:	e9 6e 01 00 00       	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b565:	8b 45 20             	mov    0x20(%ebp),%eax
    b568:	8b 00                	mov    (%eax),%eax
    b56a:	83 f8 04             	cmp    $0x4,%eax
    b56d:	0f 85 95 00 00 00    	jne    b608 <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    b573:	8b 45 20             	mov    0x20(%ebp),%eax
    b576:	8b 40 04             	mov    0x4(%eax),%eax
    b579:	83 f8 08             	cmp    $0x8,%eax
    b57c:	75 44                	jne    b5c2 <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    b57e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b581:	01 c0                	add    %eax,%eax
    b583:	89 c2                	mov    %eax,%edx
    b585:	8b 45 18             	mov    0x18(%ebp),%eax
    b588:	01 d0                	add    %edx,%eax
    b58a:	0f b6 10             	movzbl (%eax),%edx
    b58d:	8b 45 10             	mov    0x10(%ebp),%eax
    b590:	88 10                	mov    %dl,(%eax)
    b592:	8b 45 10             	mov    0x10(%ebp),%eax
    b595:	0f b6 10             	movzbl (%eax),%edx
    b598:	8b 45 0c             	mov    0xc(%ebp),%eax
    b59b:	88 10                	mov    %dl,(%eax)
    b59d:	8b 45 0c             	mov    0xc(%ebp),%eax
    b5a0:	0f b6 10             	movzbl (%eax),%edx
    b5a3:	8b 45 08             	mov    0x8(%ebp),%eax
    b5a6:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    b5a8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b5ab:	01 c0                	add    %eax,%eax
    b5ad:	8d 50 01             	lea    0x1(%eax),%edx
    b5b0:	8b 45 18             	mov    0x18(%ebp),%eax
    b5b3:	01 d0                	add    %edx,%eax
    b5b5:	0f b6 10             	movzbl (%eax),%edx
    b5b8:	8b 45 14             	mov    0x14(%ebp),%eax
    b5bb:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b5bd:	e9 11 01 00 00       	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    b5c2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b5c5:	c1 e0 02             	shl    $0x2,%eax
    b5c8:	89 c2                	mov    %eax,%edx
    b5ca:	8b 45 18             	mov    0x18(%ebp),%eax
    b5cd:	01 d0                	add    %edx,%eax
    b5cf:	0f b6 10             	movzbl (%eax),%edx
    b5d2:	8b 45 10             	mov    0x10(%ebp),%eax
    b5d5:	88 10                	mov    %dl,(%eax)
    b5d7:	8b 45 10             	mov    0x10(%ebp),%eax
    b5da:	0f b6 10             	movzbl (%eax),%edx
    b5dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    b5e0:	88 10                	mov    %dl,(%eax)
    b5e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    b5e5:	0f b6 10             	movzbl (%eax),%edx
    b5e8:	8b 45 08             	mov    0x8(%ebp),%eax
    b5eb:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    b5ed:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b5f0:	c1 e0 02             	shl    $0x2,%eax
    b5f3:	8d 50 02             	lea    0x2(%eax),%edx
    b5f6:	8b 45 18             	mov    0x18(%ebp),%eax
    b5f9:	01 d0                	add    %edx,%eax
    b5fb:	0f b6 10             	movzbl (%eax),%edx
    b5fe:	8b 45 14             	mov    0x14(%ebp),%eax
    b601:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b603:	e9 cb 00 00 00       	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    b608:	8b 45 20             	mov    0x20(%ebp),%eax
    b60b:	8b 00                	mov    (%eax),%eax
    b60d:	83 f8 06             	cmp    $0x6,%eax
    b610:	0f 85 bd 00 00 00    	jne    b6d3 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    b616:	8b 45 20             	mov    0x20(%ebp),%eax
    b619:	8b 40 04             	mov    0x4(%eax),%eax
    b61c:	83 f8 08             	cmp    $0x8,%eax
    b61f:	75 59                	jne    b67a <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    b621:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b624:	c1 e0 02             	shl    $0x2,%eax
    b627:	89 c2                	mov    %eax,%edx
    b629:	8b 45 18             	mov    0x18(%ebp),%eax
    b62c:	01 d0                	add    %edx,%eax
    b62e:	0f b6 10             	movzbl (%eax),%edx
    b631:	8b 45 08             	mov    0x8(%ebp),%eax
    b634:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    b636:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b639:	c1 e0 02             	shl    $0x2,%eax
    b63c:	8d 50 01             	lea    0x1(%eax),%edx
    b63f:	8b 45 18             	mov    0x18(%ebp),%eax
    b642:	01 d0                	add    %edx,%eax
    b644:	0f b6 10             	movzbl (%eax),%edx
    b647:	8b 45 0c             	mov    0xc(%ebp),%eax
    b64a:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    b64c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b64f:	c1 e0 02             	shl    $0x2,%eax
    b652:	8d 50 02             	lea    0x2(%eax),%edx
    b655:	8b 45 18             	mov    0x18(%ebp),%eax
    b658:	01 d0                	add    %edx,%eax
    b65a:	0f b6 10             	movzbl (%eax),%edx
    b65d:	8b 45 10             	mov    0x10(%ebp),%eax
    b660:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    b662:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b665:	c1 e0 02             	shl    $0x2,%eax
    b668:	8d 50 03             	lea    0x3(%eax),%edx
    b66b:	8b 45 18             	mov    0x18(%ebp),%eax
    b66e:	01 d0                	add    %edx,%eax
    b670:	0f b6 10             	movzbl (%eax),%edx
    b673:	8b 45 14             	mov    0x14(%ebp),%eax
    b676:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    b678:	eb 59                	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    b67a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b67d:	c1 e0 03             	shl    $0x3,%eax
    b680:	89 c2                	mov    %eax,%edx
    b682:	8b 45 18             	mov    0x18(%ebp),%eax
    b685:	01 d0                	add    %edx,%eax
    b687:	0f b6 10             	movzbl (%eax),%edx
    b68a:	8b 45 08             	mov    0x8(%ebp),%eax
    b68d:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    b68f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b692:	c1 e0 03             	shl    $0x3,%eax
    b695:	8d 50 02             	lea    0x2(%eax),%edx
    b698:	8b 45 18             	mov    0x18(%ebp),%eax
    b69b:	01 d0                	add    %edx,%eax
    b69d:	0f b6 10             	movzbl (%eax),%edx
    b6a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    b6a3:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    b6a5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b6a8:	c1 e0 03             	shl    $0x3,%eax
    b6ab:	8d 50 04             	lea    0x4(%eax),%edx
    b6ae:	8b 45 18             	mov    0x18(%ebp),%eax
    b6b1:	01 d0                	add    %edx,%eax
    b6b3:	0f b6 10             	movzbl (%eax),%edx
    b6b6:	8b 45 10             	mov    0x10(%ebp),%eax
    b6b9:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    b6bb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b6be:	c1 e0 03             	shl    $0x3,%eax
    b6c1:	8d 50 06             	lea    0x6(%eax),%edx
    b6c4:	8b 45 18             	mov    0x18(%ebp),%eax
    b6c7:	01 d0                	add    %edx,%eax
    b6c9:	0f b6 10             	movzbl (%eax),%edx
    b6cc:	8b 45 14             	mov    0x14(%ebp),%eax
    b6cf:	88 10                	mov    %dl,(%eax)
    }
  }
}
    b6d1:	eb 00                	jmp    b6d3 <getPixelColorRGBA8+0x5ca>
    b6d3:	90                   	nop
    b6d4:	c9                   	leave  
    b6d5:	c3                   	ret    

0000b6d6 <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    b6d6:	55                   	push   %ebp
    b6d7:	89 e5                	mov    %esp,%ebp
    b6d9:	53                   	push   %ebx
    b6da:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    b6dd:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b6e4:	8b 45 14             	mov    0x14(%ebp),%eax
    b6e7:	8b 00                	mov    (%eax),%eax
    b6e9:	85 c0                	test   %eax,%eax
    b6eb:	0f 85 14 02 00 00    	jne    b905 <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    b6f1:	8b 45 14             	mov    0x14(%ebp),%eax
    b6f4:	8b 40 04             	mov    0x4(%eax),%eax
    b6f7:	83 f8 08             	cmp    $0x8,%eax
    b6fa:	0f 85 a0 00 00 00    	jne    b7a0 <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b700:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b707:	eb 39                	jmp    b742 <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b709:	8b 45 08             	mov    0x8(%ebp),%eax
    b70c:	83 c0 01             	add    $0x1,%eax
    b70f:	8b 55 08             	mov    0x8(%ebp),%edx
    b712:	83 c2 02             	add    $0x2,%edx
    b715:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b718:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b71b:	01 d9                	add    %ebx,%ecx
    b71d:	0f b6 09             	movzbl (%ecx),%ecx
    b720:	88 0a                	mov    %cl,(%edx)
    b722:	0f b6 12             	movzbl (%edx),%edx
    b725:	88 10                	mov    %dl,(%eax)
    b727:	0f b6 10             	movzbl (%eax),%edx
    b72a:	8b 45 08             	mov    0x8(%ebp),%eax
    b72d:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    b72f:	8b 45 08             	mov    0x8(%ebp),%eax
    b732:	83 c0 03             	add    $0x3,%eax
    b735:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b738:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b73c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b73f:	01 45 08             	add    %eax,0x8(%ebp)
    b742:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b745:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b748:	75 bf                	jne    b709 <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    b74a:	8b 45 14             	mov    0x14(%ebp),%eax
    b74d:	8b 40 10             	mov    0x10(%eax),%eax
    b750:	85 c0                	test   %eax,%eax
    b752:	0f 84 48 06 00 00    	je     bda0 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    b758:	8b 45 0c             	mov    0xc(%ebp),%eax
    b75b:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    b75f:	f7 d8                	neg    %eax
    b761:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b764:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b76b:	eb 26                	jmp    b793 <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    b76d:	8b 45 08             	mov    0x8(%ebp),%eax
    b770:	0f b6 00             	movzbl (%eax),%eax
    b773:	0f b6 d0             	movzbl %al,%edx
    b776:	8b 45 14             	mov    0x14(%ebp),%eax
    b779:	8b 40 14             	mov    0x14(%eax),%eax
    b77c:	39 c2                	cmp    %eax,%edx
    b77e:	75 09                	jne    b789 <getPixelColorsRGBA8+0xb3>
    b780:	8b 45 08             	mov    0x8(%ebp),%eax
    b783:	83 c0 03             	add    $0x3,%eax
    b786:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b789:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b78d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b790:	01 45 08             	add    %eax,0x8(%ebp)
    b793:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b796:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b799:	75 d2                	jne    b76d <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b79b:	e9 00 06 00 00       	jmp    bda0 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    b7a0:	8b 45 14             	mov    0x14(%ebp),%eax
    b7a3:	8b 40 04             	mov    0x4(%eax),%eax
    b7a6:	83 f8 10             	cmp    $0x10,%eax
    b7a9:	0f 85 a5 00 00 00    	jne    b854 <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b7af:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b7b6:	e9 88 00 00 00       	jmp    b843 <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b7bb:	8b 45 08             	mov    0x8(%ebp),%eax
    b7be:	83 c0 01             	add    $0x1,%eax
    b7c1:	8b 55 08             	mov    0x8(%ebp),%edx
    b7c4:	83 c2 02             	add    $0x2,%edx
    b7c7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b7ca:	01 c9                	add    %ecx,%ecx
    b7cc:	89 cb                	mov    %ecx,%ebx
    b7ce:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b7d1:	01 d9                	add    %ebx,%ecx
    b7d3:	0f b6 09             	movzbl (%ecx),%ecx
    b7d6:	88 0a                	mov    %cl,(%edx)
    b7d8:	0f b6 12             	movzbl (%edx),%edx
    b7db:	88 10                	mov    %dl,(%eax)
    b7dd:	0f b6 10             	movzbl (%eax),%edx
    b7e0:	8b 45 08             	mov    0x8(%ebp),%eax
    b7e3:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    b7e5:	8b 45 08             	mov    0x8(%ebp),%eax
    b7e8:	8d 50 03             	lea    0x3(%eax),%edx
    b7eb:	8b 45 14             	mov    0x14(%ebp),%eax
    b7ee:	8b 40 10             	mov    0x10(%eax),%eax
    b7f1:	85 c0                	test   %eax,%eax
    b7f3:	74 3d                	je     b832 <getPixelColorsRGBA8+0x15c>
    b7f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b7f8:	01 c0                	add    %eax,%eax
    b7fa:	89 c1                	mov    %eax,%ecx
    b7fc:	8b 45 10             	mov    0x10(%ebp),%eax
    b7ff:	01 c8                	add    %ecx,%eax
    b801:	0f b6 00             	movzbl (%eax),%eax
    b804:	0f b6 c0             	movzbl %al,%eax
    b807:	c1 e0 08             	shl    $0x8,%eax
    b80a:	89 c1                	mov    %eax,%ecx
    b80c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b80f:	01 c0                	add    %eax,%eax
    b811:	8d 58 01             	lea    0x1(%eax),%ebx
    b814:	8b 45 10             	mov    0x10(%ebp),%eax
    b817:	01 d8                	add    %ebx,%eax
    b819:	0f b6 00             	movzbl (%eax),%eax
    b81c:	0f b6 c0             	movzbl %al,%eax
    b81f:	01 c1                	add    %eax,%ecx
    b821:	8b 45 14             	mov    0x14(%ebp),%eax
    b824:	8b 40 14             	mov    0x14(%eax),%eax
    b827:	39 c1                	cmp    %eax,%ecx
    b829:	75 07                	jne    b832 <getPixelColorsRGBA8+0x15c>
    b82b:	b8 00 00 00 00       	mov    $0x0,%eax
    b830:	eb 05                	jmp    b837 <getPixelColorsRGBA8+0x161>
    b832:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b837:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b839:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b83d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b840:	01 45 08             	add    %eax,0x8(%ebp)
    b843:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b846:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b849:	0f 85 6c ff ff ff    	jne    b7bb <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b84f:	e9 4c 05 00 00       	jmp    bda0 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b854:	8b 45 14             	mov    0x14(%ebp),%eax
    b857:	8b 40 04             	mov    0x4(%eax),%eax
    b85a:	ba 01 00 00 00       	mov    $0x1,%edx
    b85f:	89 c1                	mov    %eax,%ecx
    b861:	d3 e2                	shl    %cl,%edx
    b863:	89 d0                	mov    %edx,%eax
    b865:	83 e8 01             	sub    $0x1,%eax
    b868:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b86b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b872:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b879:	eb 79                	jmp    b8f4 <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b87b:	8b 45 14             	mov    0x14(%ebp),%eax
    b87e:	8b 40 04             	mov    0x4(%eax),%eax
    b881:	50                   	push   %eax
    b882:	ff 75 10             	pushl  0x10(%ebp)
    b885:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b888:	50                   	push   %eax
    b889:	e8 c0 d4 ff ff       	call   8d4e <readBitsFromReversedStream>
    b88e:	83 c4 0c             	add    $0xc,%esp
    b891:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b894:	8b 45 08             	mov    0x8(%ebp),%eax
    b897:	8d 48 01             	lea    0x1(%eax),%ecx
    b89a:	8b 45 08             	mov    0x8(%ebp),%eax
    b89d:	8d 58 02             	lea    0x2(%eax),%ebx
    b8a0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b8a3:	89 d0                	mov    %edx,%eax
    b8a5:	c1 e0 08             	shl    $0x8,%eax
    b8a8:	29 d0                	sub    %edx,%eax
    b8aa:	ba 00 00 00 00       	mov    $0x0,%edx
    b8af:	f7 75 f0             	divl   -0x10(%ebp)
    b8b2:	88 03                	mov    %al,(%ebx)
    b8b4:	0f b6 03             	movzbl (%ebx),%eax
    b8b7:	88 01                	mov    %al,(%ecx)
    b8b9:	0f b6 11             	movzbl (%ecx),%edx
    b8bc:	8b 45 08             	mov    0x8(%ebp),%eax
    b8bf:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    b8c1:	8b 45 08             	mov    0x8(%ebp),%eax
    b8c4:	8d 50 03             	lea    0x3(%eax),%edx
    b8c7:	8b 45 14             	mov    0x14(%ebp),%eax
    b8ca:	8b 40 10             	mov    0x10(%eax),%eax
    b8cd:	85 c0                	test   %eax,%eax
    b8cf:	74 12                	je     b8e3 <getPixelColorsRGBA8+0x20d>
    b8d1:	8b 45 14             	mov    0x14(%ebp),%eax
    b8d4:	8b 40 14             	mov    0x14(%eax),%eax
    b8d7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    b8da:	75 07                	jne    b8e3 <getPixelColorsRGBA8+0x20d>
    b8dc:	b8 00 00 00 00       	mov    $0x0,%eax
    b8e1:	eb 05                	jmp    b8e8 <getPixelColorsRGBA8+0x212>
    b8e3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b8e8:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b8ea:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b8ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b8f1:	01 45 08             	add    %eax,0x8(%ebp)
    b8f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b8f7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b8fa:	0f 85 7b ff ff ff    	jne    b87b <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b900:	e9 9b 04 00 00       	jmp    bda0 <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b905:	8b 45 14             	mov    0x14(%ebp),%eax
    b908:	8b 00                	mov    (%eax),%eax
    b90a:	83 f8 02             	cmp    $0x2,%eax
    b90d:	0f 85 41 02 00 00    	jne    bb54 <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    b913:	8b 45 14             	mov    0x14(%ebp),%eax
    b916:	8b 40 04             	mov    0x4(%eax),%eax
    b919:	83 f8 08             	cmp    $0x8,%eax
    b91c:	0f 85 c4 00 00 00    	jne    b9e6 <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b922:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b929:	eb 31                	jmp    b95c <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    b92b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b92e:	89 d0                	mov    %edx,%eax
    b930:	01 c0                	add    %eax,%eax
    b932:	01 d0                	add    %edx,%eax
    b934:	89 c2                	mov    %eax,%edx
    b936:	8b 45 10             	mov    0x10(%ebp),%eax
    b939:	01 d0                	add    %edx,%eax
    b93b:	6a 03                	push   $0x3
    b93d:	50                   	push   %eax
    b93e:	ff 75 08             	pushl  0x8(%ebp)
    b941:	e8 a3 85 ff ff       	call   3ee9 <lodepng_memcpy>
    b946:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    b949:	8b 45 08             	mov    0x8(%ebp),%eax
    b94c:	83 c0 03             	add    $0x3,%eax
    b94f:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b952:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b956:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b959:	01 45 08             	add    %eax,0x8(%ebp)
    b95c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b95f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b962:	75 c7                	jne    b92b <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    b964:	8b 45 14             	mov    0x14(%ebp),%eax
    b967:	8b 40 10             	mov    0x10(%eax),%eax
    b96a:	85 c0                	test   %eax,%eax
    b96c:	0f 84 2e 04 00 00    	je     bda0 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    b972:	8b 45 0c             	mov    0xc(%ebp),%eax
    b975:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    b979:	f7 d8                	neg    %eax
    b97b:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b97e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b985:	eb 52                	jmp    b9d9 <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    b987:	8b 45 08             	mov    0x8(%ebp),%eax
    b98a:	0f b6 00             	movzbl (%eax),%eax
    b98d:	0f b6 d0             	movzbl %al,%edx
    b990:	8b 45 14             	mov    0x14(%ebp),%eax
    b993:	8b 40 14             	mov    0x14(%eax),%eax
    b996:	39 c2                	cmp    %eax,%edx
    b998:	75 35                	jne    b9cf <getPixelColorsRGBA8+0x2f9>
    b99a:	8b 45 08             	mov    0x8(%ebp),%eax
    b99d:	83 c0 01             	add    $0x1,%eax
    b9a0:	0f b6 00             	movzbl (%eax),%eax
    b9a3:	0f b6 d0             	movzbl %al,%edx
    b9a6:	8b 45 14             	mov    0x14(%ebp),%eax
    b9a9:	8b 40 18             	mov    0x18(%eax),%eax
    b9ac:	39 c2                	cmp    %eax,%edx
    b9ae:	75 1f                	jne    b9cf <getPixelColorsRGBA8+0x2f9>
    b9b0:	8b 45 08             	mov    0x8(%ebp),%eax
    b9b3:	83 c0 02             	add    $0x2,%eax
    b9b6:	0f b6 00             	movzbl (%eax),%eax
    b9b9:	0f b6 d0             	movzbl %al,%edx
    b9bc:	8b 45 14             	mov    0x14(%ebp),%eax
    b9bf:	8b 40 1c             	mov    0x1c(%eax),%eax
    b9c2:	39 c2                	cmp    %eax,%edx
    b9c4:	75 09                	jne    b9cf <getPixelColorsRGBA8+0x2f9>
    b9c6:	8b 45 08             	mov    0x8(%ebp),%eax
    b9c9:	83 c0 03             	add    $0x3,%eax
    b9cc:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b9cf:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b9d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b9d6:	01 45 08             	add    %eax,0x8(%ebp)
    b9d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b9dc:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b9df:	75 a6                	jne    b987 <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b9e1:	e9 ba 03 00 00       	jmp    bda0 <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b9e6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b9ed:	e9 51 01 00 00       	jmp    bb43 <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    b9f2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b9f5:	89 d0                	mov    %edx,%eax
    b9f7:	01 c0                	add    %eax,%eax
    b9f9:	01 d0                	add    %edx,%eax
    b9fb:	01 c0                	add    %eax,%eax
    b9fd:	89 c2                	mov    %eax,%edx
    b9ff:	8b 45 10             	mov    0x10(%ebp),%eax
    ba02:	01 d0                	add    %edx,%eax
    ba04:	0f b6 10             	movzbl (%eax),%edx
    ba07:	8b 45 08             	mov    0x8(%ebp),%eax
    ba0a:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    ba0c:	8b 45 08             	mov    0x8(%ebp),%eax
    ba0f:	8d 48 01             	lea    0x1(%eax),%ecx
    ba12:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ba15:	89 d0                	mov    %edx,%eax
    ba17:	01 c0                	add    %eax,%eax
    ba19:	01 d0                	add    %edx,%eax
    ba1b:	01 c0                	add    %eax,%eax
    ba1d:	8d 50 02             	lea    0x2(%eax),%edx
    ba20:	8b 45 10             	mov    0x10(%ebp),%eax
    ba23:	01 d0                	add    %edx,%eax
    ba25:	0f b6 00             	movzbl (%eax),%eax
    ba28:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    ba2a:	8b 45 08             	mov    0x8(%ebp),%eax
    ba2d:	8d 48 02             	lea    0x2(%eax),%ecx
    ba30:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ba33:	89 d0                	mov    %edx,%eax
    ba35:	01 c0                	add    %eax,%eax
    ba37:	01 d0                	add    %edx,%eax
    ba39:	01 c0                	add    %eax,%eax
    ba3b:	8d 50 04             	lea    0x4(%eax),%edx
    ba3e:	8b 45 10             	mov    0x10(%ebp),%eax
    ba41:	01 d0                	add    %edx,%eax
    ba43:	0f b6 00             	movzbl (%eax),%eax
    ba46:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    ba48:	8b 45 08             	mov    0x8(%ebp),%eax
    ba4b:	8d 48 03             	lea    0x3(%eax),%ecx
    ba4e:	8b 45 14             	mov    0x14(%ebp),%eax
    ba51:	8b 40 10             	mov    0x10(%eax),%eax
    ba54:	85 c0                	test   %eax,%eax
    ba56:	0f 84 d6 00 00 00    	je     bb32 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    ba5c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ba5f:	89 d0                	mov    %edx,%eax
    ba61:	01 c0                	add    %eax,%eax
    ba63:	01 d0                	add    %edx,%eax
    ba65:	01 c0                	add    %eax,%eax
    ba67:	89 c2                	mov    %eax,%edx
    ba69:	8b 45 10             	mov    0x10(%ebp),%eax
    ba6c:	01 d0                	add    %edx,%eax
    ba6e:	0f b6 00             	movzbl (%eax),%eax
    ba71:	0f b6 c0             	movzbl %al,%eax
    ba74:	c1 e0 08             	shl    $0x8,%eax
    ba77:	89 c3                	mov    %eax,%ebx
    ba79:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ba7c:	89 d0                	mov    %edx,%eax
    ba7e:	01 c0                	add    %eax,%eax
    ba80:	01 d0                	add    %edx,%eax
    ba82:	01 c0                	add    %eax,%eax
    ba84:	8d 50 01             	lea    0x1(%eax),%edx
    ba87:	8b 45 10             	mov    0x10(%ebp),%eax
    ba8a:	01 d0                	add    %edx,%eax
    ba8c:	0f b6 00             	movzbl (%eax),%eax
    ba8f:	0f b6 c0             	movzbl %al,%eax
    ba92:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    ba95:	8b 45 14             	mov    0x14(%ebp),%eax
    ba98:	8b 40 14             	mov    0x14(%eax),%eax
    ba9b:	39 c2                	cmp    %eax,%edx
    ba9d:	0f 85 8f 00 00 00    	jne    bb32 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    baa3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    baa6:	89 d0                	mov    %edx,%eax
    baa8:	01 c0                	add    %eax,%eax
    baaa:	01 d0                	add    %edx,%eax
    baac:	01 c0                	add    %eax,%eax
    baae:	8d 50 02             	lea    0x2(%eax),%edx
    bab1:	8b 45 10             	mov    0x10(%ebp),%eax
    bab4:	01 d0                	add    %edx,%eax
    bab6:	0f b6 00             	movzbl (%eax),%eax
    bab9:	0f b6 c0             	movzbl %al,%eax
    babc:	c1 e0 08             	shl    $0x8,%eax
    babf:	89 c3                	mov    %eax,%ebx
    bac1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bac4:	89 d0                	mov    %edx,%eax
    bac6:	01 c0                	add    %eax,%eax
    bac8:	01 d0                	add    %edx,%eax
    baca:	01 c0                	add    %eax,%eax
    bacc:	8d 50 03             	lea    0x3(%eax),%edx
    bacf:	8b 45 10             	mov    0x10(%ebp),%eax
    bad2:	01 d0                	add    %edx,%eax
    bad4:	0f b6 00             	movzbl (%eax),%eax
    bad7:	0f b6 c0             	movzbl %al,%eax
    bada:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    badd:	8b 45 14             	mov    0x14(%ebp),%eax
    bae0:	8b 40 18             	mov    0x18(%eax),%eax
    bae3:	39 c2                	cmp    %eax,%edx
    bae5:	75 4b                	jne    bb32 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    bae7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    baea:	89 d0                	mov    %edx,%eax
    baec:	01 c0                	add    %eax,%eax
    baee:	01 d0                	add    %edx,%eax
    baf0:	01 c0                	add    %eax,%eax
    baf2:	8d 50 04             	lea    0x4(%eax),%edx
    baf5:	8b 45 10             	mov    0x10(%ebp),%eax
    baf8:	01 d0                	add    %edx,%eax
    bafa:	0f b6 00             	movzbl (%eax),%eax
    bafd:	0f b6 c0             	movzbl %al,%eax
    bb00:	c1 e0 08             	shl    $0x8,%eax
    bb03:	89 c3                	mov    %eax,%ebx
    bb05:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bb08:	89 d0                	mov    %edx,%eax
    bb0a:	01 c0                	add    %eax,%eax
    bb0c:	01 d0                	add    %edx,%eax
    bb0e:	01 c0                	add    %eax,%eax
    bb10:	8d 50 05             	lea    0x5(%eax),%edx
    bb13:	8b 45 10             	mov    0x10(%ebp),%eax
    bb16:	01 d0                	add    %edx,%eax
    bb18:	0f b6 00             	movzbl (%eax),%eax
    bb1b:	0f b6 c0             	movzbl %al,%eax
    bb1e:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    bb21:	8b 45 14             	mov    0x14(%ebp),%eax
    bb24:	8b 40 1c             	mov    0x1c(%eax),%eax
    bb27:	39 c2                	cmp    %eax,%edx
    bb29:	75 07                	jne    bb32 <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    bb2b:	b8 00 00 00 00       	mov    $0x0,%eax
    bb30:	eb 05                	jmp    bb37 <getPixelColorsRGBA8+0x461>
    bb32:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    bb37:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bb39:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bb3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bb40:	01 45 08             	add    %eax,0x8(%ebp)
    bb43:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bb46:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bb49:	0f 85 a3 fe ff ff    	jne    b9f2 <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    bb4f:	e9 4c 02 00 00       	jmp    bda0 <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    bb54:	8b 45 14             	mov    0x14(%ebp),%eax
    bb57:	8b 00                	mov    (%eax),%eax
    bb59:	83 f8 03             	cmp    $0x3,%eax
    bb5c:	0f 85 b4 00 00 00    	jne    bc16 <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    bb62:	8b 45 14             	mov    0x14(%ebp),%eax
    bb65:	8b 40 04             	mov    0x4(%eax),%eax
    bb68:	83 f8 08             	cmp    $0x8,%eax
    bb6b:	75 4d                	jne    bbba <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bb6d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bb74:	eb 37                	jmp    bbad <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    bb76:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bb79:	8b 45 10             	mov    0x10(%ebp),%eax
    bb7c:	01 d0                	add    %edx,%eax
    bb7e:	0f b6 00             	movzbl (%eax),%eax
    bb81:	0f b6 c0             	movzbl %al,%eax
    bb84:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    bb87:	8b 45 14             	mov    0x14(%ebp),%eax
    bb8a:	8b 40 08             	mov    0x8(%eax),%eax
    bb8d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    bb90:	c1 e2 02             	shl    $0x2,%edx
    bb93:	01 d0                	add    %edx,%eax
    bb95:	6a 04                	push   $0x4
    bb97:	50                   	push   %eax
    bb98:	ff 75 08             	pushl  0x8(%ebp)
    bb9b:	e8 49 83 ff ff       	call   3ee9 <lodepng_memcpy>
    bba0:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bba3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bbaa:	01 45 08             	add    %eax,0x8(%ebp)
    bbad:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bbb0:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bbb3:	75 c1                	jne    bb76 <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    bbb5:	e9 e6 01 00 00       	jmp    bda0 <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    bbba:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bbc1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bbc8:	eb 3f                	jmp    bc09 <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    bbca:	8b 45 14             	mov    0x14(%ebp),%eax
    bbcd:	8b 40 04             	mov    0x4(%eax),%eax
    bbd0:	50                   	push   %eax
    bbd1:	ff 75 10             	pushl  0x10(%ebp)
    bbd4:	8d 45 dc             	lea    -0x24(%ebp),%eax
    bbd7:	50                   	push   %eax
    bbd8:	e8 71 d1 ff ff       	call   8d4e <readBitsFromReversedStream>
    bbdd:	83 c4 0c             	add    $0xc,%esp
    bbe0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    bbe3:	8b 45 14             	mov    0x14(%ebp),%eax
    bbe6:	8b 40 08             	mov    0x8(%eax),%eax
    bbe9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bbec:	c1 e2 02             	shl    $0x2,%edx
    bbef:	01 d0                	add    %edx,%eax
    bbf1:	6a 04                	push   $0x4
    bbf3:	50                   	push   %eax
    bbf4:	ff 75 08             	pushl  0x8(%ebp)
    bbf7:	e8 ed 82 ff ff       	call   3ee9 <lodepng_memcpy>
    bbfc:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bbff:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bc03:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bc06:	01 45 08             	add    %eax,0x8(%ebp)
    bc09:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bc0c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bc0f:	75 b9                	jne    bbca <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    bc11:	e9 8a 01 00 00       	jmp    bda0 <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    bc16:	8b 45 14             	mov    0x14(%ebp),%eax
    bc19:	8b 00                	mov    (%eax),%eax
    bc1b:	83 f8 04             	cmp    $0x4,%eax
    bc1e:	0f 85 d1 00 00 00    	jne    bcf5 <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    bc24:	8b 45 14             	mov    0x14(%ebp),%eax
    bc27:	8b 40 04             	mov    0x4(%eax),%eax
    bc2a:	83 f8 08             	cmp    $0x8,%eax
    bc2d:	75 62                	jne    bc91 <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bc2f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bc36:	eb 4c                	jmp    bc84 <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    bc38:	8b 45 08             	mov    0x8(%ebp),%eax
    bc3b:	83 c0 01             	add    $0x1,%eax
    bc3e:	8b 55 08             	mov    0x8(%ebp),%edx
    bc41:	83 c2 02             	add    $0x2,%edx
    bc44:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    bc47:	01 c9                	add    %ecx,%ecx
    bc49:	89 cb                	mov    %ecx,%ebx
    bc4b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    bc4e:	01 d9                	add    %ebx,%ecx
    bc50:	0f b6 09             	movzbl (%ecx),%ecx
    bc53:	88 0a                	mov    %cl,(%edx)
    bc55:	0f b6 12             	movzbl (%edx),%edx
    bc58:	88 10                	mov    %dl,(%eax)
    bc5a:	0f b6 10             	movzbl (%eax),%edx
    bc5d:	8b 45 08             	mov    0x8(%ebp),%eax
    bc60:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    bc62:	8b 45 08             	mov    0x8(%ebp),%eax
    bc65:	8d 50 03             	lea    0x3(%eax),%edx
    bc68:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bc6b:	01 c0                	add    %eax,%eax
    bc6d:	8d 48 01             	lea    0x1(%eax),%ecx
    bc70:	8b 45 10             	mov    0x10(%ebp),%eax
    bc73:	01 c8                	add    %ecx,%eax
    bc75:	0f b6 00             	movzbl (%eax),%eax
    bc78:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bc7a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bc7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bc81:	01 45 08             	add    %eax,0x8(%ebp)
    bc84:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bc87:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bc8a:	75 ac                	jne    bc38 <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    bc8c:	e9 0f 01 00 00       	jmp    bda0 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bc91:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bc98:	eb 4e                	jmp    bce8 <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    bc9a:	8b 45 08             	mov    0x8(%ebp),%eax
    bc9d:	83 c0 01             	add    $0x1,%eax
    bca0:	8b 55 08             	mov    0x8(%ebp),%edx
    bca3:	83 c2 02             	add    $0x2,%edx
    bca6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    bca9:	c1 e1 02             	shl    $0x2,%ecx
    bcac:	89 cb                	mov    %ecx,%ebx
    bcae:	8b 4d 10             	mov    0x10(%ebp),%ecx
    bcb1:	01 d9                	add    %ebx,%ecx
    bcb3:	0f b6 09             	movzbl (%ecx),%ecx
    bcb6:	88 0a                	mov    %cl,(%edx)
    bcb8:	0f b6 12             	movzbl (%edx),%edx
    bcbb:	88 10                	mov    %dl,(%eax)
    bcbd:	0f b6 10             	movzbl (%eax),%edx
    bcc0:	8b 45 08             	mov    0x8(%ebp),%eax
    bcc3:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    bcc5:	8b 45 08             	mov    0x8(%ebp),%eax
    bcc8:	8d 50 03             	lea    0x3(%eax),%edx
    bccb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bcce:	c1 e0 02             	shl    $0x2,%eax
    bcd1:	8d 48 02             	lea    0x2(%eax),%ecx
    bcd4:	8b 45 10             	mov    0x10(%ebp),%eax
    bcd7:	01 c8                	add    %ecx,%eax
    bcd9:	0f b6 00             	movzbl (%eax),%eax
    bcdc:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bcde:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bce5:	01 45 08             	add    %eax,0x8(%ebp)
    bce8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bceb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bcee:	75 aa                	jne    bc9a <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    bcf0:	e9 ab 00 00 00       	jmp    bda0 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    bcf5:	8b 45 14             	mov    0x14(%ebp),%eax
    bcf8:	8b 00                	mov    (%eax),%eax
    bcfa:	83 f8 06             	cmp    $0x6,%eax
    bcfd:	0f 85 9d 00 00 00    	jne    bda0 <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    bd03:	8b 45 14             	mov    0x14(%ebp),%eax
    bd06:	8b 40 04             	mov    0x4(%eax),%eax
    bd09:	83 f8 08             	cmp    $0x8,%eax
    bd0c:	75 17                	jne    bd25 <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    bd0e:	8b 45 0c             	mov    0xc(%ebp),%eax
    bd11:	c1 e0 02             	shl    $0x2,%eax
    bd14:	50                   	push   %eax
    bd15:	ff 75 10             	pushl  0x10(%ebp)
    bd18:	ff 75 08             	pushl  0x8(%ebp)
    bd1b:	e8 c9 81 ff ff       	call   3ee9 <lodepng_memcpy>
    bd20:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    bd23:	eb 7b                	jmp    bda0 <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bd25:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bd2c:	eb 6a                	jmp    bd98 <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    bd2e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bd31:	c1 e0 03             	shl    $0x3,%eax
    bd34:	89 c2                	mov    %eax,%edx
    bd36:	8b 45 10             	mov    0x10(%ebp),%eax
    bd39:	01 d0                	add    %edx,%eax
    bd3b:	0f b6 10             	movzbl (%eax),%edx
    bd3e:	8b 45 08             	mov    0x8(%ebp),%eax
    bd41:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    bd43:	8b 45 08             	mov    0x8(%ebp),%eax
    bd46:	8d 50 01             	lea    0x1(%eax),%edx
    bd49:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bd4c:	c1 e0 03             	shl    $0x3,%eax
    bd4f:	8d 48 02             	lea    0x2(%eax),%ecx
    bd52:	8b 45 10             	mov    0x10(%ebp),%eax
    bd55:	01 c8                	add    %ecx,%eax
    bd57:	0f b6 00             	movzbl (%eax),%eax
    bd5a:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    bd5c:	8b 45 08             	mov    0x8(%ebp),%eax
    bd5f:	8d 50 02             	lea    0x2(%eax),%edx
    bd62:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bd65:	c1 e0 03             	shl    $0x3,%eax
    bd68:	8d 48 04             	lea    0x4(%eax),%ecx
    bd6b:	8b 45 10             	mov    0x10(%ebp),%eax
    bd6e:	01 c8                	add    %ecx,%eax
    bd70:	0f b6 00             	movzbl (%eax),%eax
    bd73:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    bd75:	8b 45 08             	mov    0x8(%ebp),%eax
    bd78:	8d 50 03             	lea    0x3(%eax),%edx
    bd7b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bd7e:	c1 e0 03             	shl    $0x3,%eax
    bd81:	8d 48 06             	lea    0x6(%eax),%ecx
    bd84:	8b 45 10             	mov    0x10(%ebp),%eax
    bd87:	01 c8                	add    %ecx,%eax
    bd89:	0f b6 00             	movzbl (%eax),%eax
    bd8c:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bd8e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bd92:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bd95:	01 45 08             	add    %eax,0x8(%ebp)
    bd98:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bd9b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bd9e:	75 8e                	jne    bd2e <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    bda0:	90                   	nop
    bda1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    bda4:	c9                   	leave  
    bda5:	c3                   	ret    

0000bda6 <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    bda6:	55                   	push   %ebp
    bda7:	89 e5                	mov    %esp,%ebp
    bda9:	53                   	push   %ebx
    bdaa:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    bdad:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    bdb4:	8b 45 14             	mov    0x14(%ebp),%eax
    bdb7:	8b 00                	mov    (%eax),%eax
    bdb9:	85 c0                	test   %eax,%eax
    bdbb:	0f 85 2a 01 00 00    	jne    beeb <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    bdc1:	8b 45 14             	mov    0x14(%ebp),%eax
    bdc4:	8b 40 04             	mov    0x4(%eax),%eax
    bdc7:	83 f8 08             	cmp    $0x8,%eax
    bdca:	75 46                	jne    be12 <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bdcc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bdd3:	eb 30                	jmp    be05 <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    bdd5:	8b 45 08             	mov    0x8(%ebp),%eax
    bdd8:	83 c0 01             	add    $0x1,%eax
    bddb:	8b 55 08             	mov    0x8(%ebp),%edx
    bdde:	83 c2 02             	add    $0x2,%edx
    bde1:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    bde4:	8b 4d 10             	mov    0x10(%ebp),%ecx
    bde7:	01 d9                	add    %ebx,%ecx
    bde9:	0f b6 09             	movzbl (%ecx),%ecx
    bdec:	88 0a                	mov    %cl,(%edx)
    bdee:	0f b6 12             	movzbl (%edx),%edx
    bdf1:	88 10                	mov    %dl,(%eax)
    bdf3:	0f b6 10             	movzbl (%eax),%edx
    bdf6:	8b 45 08             	mov    0x8(%ebp),%eax
    bdf9:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bdfb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bdff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    be02:	01 45 08             	add    %eax,0x8(%ebp)
    be05:	8b 45 f8             	mov    -0x8(%ebp),%eax
    be08:	3b 45 0c             	cmp    0xc(%ebp),%eax
    be0b:	75 c8                	jne    bdd5 <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    be0d:	e9 a8 03 00 00       	jmp    c1ba <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    be12:	8b 45 14             	mov    0x14(%ebp),%eax
    be15:	8b 40 04             	mov    0x4(%eax),%eax
    be18:	83 f8 10             	cmp    $0x10,%eax
    be1b:	75 4a                	jne    be67 <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    be1d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    be24:	eb 34                	jmp    be5a <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    be26:	8b 45 08             	mov    0x8(%ebp),%eax
    be29:	83 c0 01             	add    $0x1,%eax
    be2c:	8b 55 08             	mov    0x8(%ebp),%edx
    be2f:	83 c2 02             	add    $0x2,%edx
    be32:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    be35:	01 c9                	add    %ecx,%ecx
    be37:	89 cb                	mov    %ecx,%ebx
    be39:	8b 4d 10             	mov    0x10(%ebp),%ecx
    be3c:	01 d9                	add    %ebx,%ecx
    be3e:	0f b6 09             	movzbl (%ecx),%ecx
    be41:	88 0a                	mov    %cl,(%edx)
    be43:	0f b6 12             	movzbl (%edx),%edx
    be46:	88 10                	mov    %dl,(%eax)
    be48:	0f b6 10             	movzbl (%eax),%edx
    be4b:	8b 45 08             	mov    0x8(%ebp),%eax
    be4e:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    be50:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    be54:	8b 45 f4             	mov    -0xc(%ebp),%eax
    be57:	01 45 08             	add    %eax,0x8(%ebp)
    be5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    be5d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    be60:	75 c4                	jne    be26 <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    be62:	e9 53 03 00 00       	jmp    c1ba <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    be67:	8b 45 14             	mov    0x14(%ebp),%eax
    be6a:	8b 40 04             	mov    0x4(%eax),%eax
    be6d:	ba 01 00 00 00       	mov    $0x1,%edx
    be72:	89 c1                	mov    %eax,%ecx
    be74:	d3 e2                	shl    %cl,%edx
    be76:	89 d0                	mov    %edx,%eax
    be78:	83 e8 01             	sub    $0x1,%eax
    be7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    be7e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    be85:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    be8c:	eb 50                	jmp    bede <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    be8e:	8b 45 14             	mov    0x14(%ebp),%eax
    be91:	8b 40 04             	mov    0x4(%eax),%eax
    be94:	50                   	push   %eax
    be95:	ff 75 10             	pushl  0x10(%ebp)
    be98:	8d 45 e0             	lea    -0x20(%ebp),%eax
    be9b:	50                   	push   %eax
    be9c:	e8 ad ce ff ff       	call   8d4e <readBitsFromReversedStream>
    bea1:	83 c4 0c             	add    $0xc,%esp
    bea4:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    bea7:	8b 45 08             	mov    0x8(%ebp),%eax
    beaa:	8d 48 01             	lea    0x1(%eax),%ecx
    bead:	8b 45 08             	mov    0x8(%ebp),%eax
    beb0:	8d 58 02             	lea    0x2(%eax),%ebx
    beb3:	8b 55 ec             	mov    -0x14(%ebp),%edx
    beb6:	89 d0                	mov    %edx,%eax
    beb8:	c1 e0 08             	shl    $0x8,%eax
    bebb:	29 d0                	sub    %edx,%eax
    bebd:	ba 00 00 00 00       	mov    $0x0,%edx
    bec2:	f7 75 f0             	divl   -0x10(%ebp)
    bec5:	88 03                	mov    %al,(%ebx)
    bec7:	0f b6 03             	movzbl (%ebx),%eax
    beca:	88 01                	mov    %al,(%ecx)
    becc:	0f b6 11             	movzbl (%ecx),%edx
    becf:	8b 45 08             	mov    0x8(%ebp),%eax
    bed2:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bed4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bed8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bedb:	01 45 08             	add    %eax,0x8(%ebp)
    bede:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bee1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bee4:	75 a8                	jne    be8e <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bee6:	e9 cf 02 00 00       	jmp    c1ba <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    beeb:	8b 45 14             	mov    0x14(%ebp),%eax
    beee:	8b 00                	mov    (%eax),%eax
    bef0:	83 f8 02             	cmp    $0x2,%eax
    bef3:	0f 85 9e 00 00 00    	jne    bf97 <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    bef9:	8b 45 14             	mov    0x14(%ebp),%eax
    befc:	8b 40 04             	mov    0x4(%eax),%eax
    beff:	83 f8 08             	cmp    $0x8,%eax
    bf02:	75 1d                	jne    bf21 <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    bf04:	8b 55 0c             	mov    0xc(%ebp),%edx
    bf07:	89 d0                	mov    %edx,%eax
    bf09:	01 c0                	add    %eax,%eax
    bf0b:	01 d0                	add    %edx,%eax
    bf0d:	50                   	push   %eax
    bf0e:	ff 75 10             	pushl  0x10(%ebp)
    bf11:	ff 75 08             	pushl  0x8(%ebp)
    bf14:	e8 d0 7f ff ff       	call   3ee9 <lodepng_memcpy>
    bf19:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bf1c:	e9 99 02 00 00       	jmp    c1ba <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bf21:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bf28:	eb 60                	jmp    bf8a <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    bf2a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bf2d:	89 d0                	mov    %edx,%eax
    bf2f:	01 c0                	add    %eax,%eax
    bf31:	01 d0                	add    %edx,%eax
    bf33:	01 c0                	add    %eax,%eax
    bf35:	89 c2                	mov    %eax,%edx
    bf37:	8b 45 10             	mov    0x10(%ebp),%eax
    bf3a:	01 d0                	add    %edx,%eax
    bf3c:	0f b6 10             	movzbl (%eax),%edx
    bf3f:	8b 45 08             	mov    0x8(%ebp),%eax
    bf42:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    bf44:	8b 45 08             	mov    0x8(%ebp),%eax
    bf47:	8d 48 01             	lea    0x1(%eax),%ecx
    bf4a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bf4d:	89 d0                	mov    %edx,%eax
    bf4f:	01 c0                	add    %eax,%eax
    bf51:	01 d0                	add    %edx,%eax
    bf53:	01 c0                	add    %eax,%eax
    bf55:	8d 50 02             	lea    0x2(%eax),%edx
    bf58:	8b 45 10             	mov    0x10(%ebp),%eax
    bf5b:	01 d0                	add    %edx,%eax
    bf5d:	0f b6 00             	movzbl (%eax),%eax
    bf60:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    bf62:	8b 45 08             	mov    0x8(%ebp),%eax
    bf65:	8d 48 02             	lea    0x2(%eax),%ecx
    bf68:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bf6b:	89 d0                	mov    %edx,%eax
    bf6d:	01 c0                	add    %eax,%eax
    bf6f:	01 d0                	add    %edx,%eax
    bf71:	01 c0                	add    %eax,%eax
    bf73:	8d 50 04             	lea    0x4(%eax),%edx
    bf76:	8b 45 10             	mov    0x10(%ebp),%eax
    bf79:	01 d0                	add    %edx,%eax
    bf7b:	0f b6 00             	movzbl (%eax),%eax
    bf7e:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bf80:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bf84:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf87:	01 45 08             	add    %eax,0x8(%ebp)
    bf8a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf8d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bf90:	75 98                	jne    bf2a <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bf92:	e9 23 02 00 00       	jmp    c1ba <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    bf97:	8b 45 14             	mov    0x14(%ebp),%eax
    bf9a:	8b 00                	mov    (%eax),%eax
    bf9c:	83 f8 03             	cmp    $0x3,%eax
    bf9f:	0f 85 b4 00 00 00    	jne    c059 <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    bfa5:	8b 45 14             	mov    0x14(%ebp),%eax
    bfa8:	8b 40 04             	mov    0x4(%eax),%eax
    bfab:	83 f8 08             	cmp    $0x8,%eax
    bfae:	75 4d                	jne    bffd <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bfb0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bfb7:	eb 37                	jmp    bff0 <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    bfb9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bfbc:	8b 45 10             	mov    0x10(%ebp),%eax
    bfbf:	01 d0                	add    %edx,%eax
    bfc1:	0f b6 00             	movzbl (%eax),%eax
    bfc4:	0f b6 c0             	movzbl %al,%eax
    bfc7:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    bfca:	8b 45 14             	mov    0x14(%ebp),%eax
    bfcd:	8b 40 08             	mov    0x8(%eax),%eax
    bfd0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    bfd3:	c1 e2 02             	shl    $0x2,%edx
    bfd6:	01 d0                	add    %edx,%eax
    bfd8:	6a 03                	push   $0x3
    bfda:	50                   	push   %eax
    bfdb:	ff 75 08             	pushl  0x8(%ebp)
    bfde:	e8 06 7f ff ff       	call   3ee9 <lodepng_memcpy>
    bfe3:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    bfe6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bfea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bfed:	01 45 08             	add    %eax,0x8(%ebp)
    bff0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bff3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bff6:	75 c1                	jne    bfb9 <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    bff8:	e9 bd 01 00 00       	jmp    c1ba <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    bffd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c004:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c00b:	eb 3f                	jmp    c04c <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    c00d:	8b 45 14             	mov    0x14(%ebp),%eax
    c010:	8b 40 04             	mov    0x4(%eax),%eax
    c013:	50                   	push   %eax
    c014:	ff 75 10             	pushl  0x10(%ebp)
    c017:	8d 45 dc             	lea    -0x24(%ebp),%eax
    c01a:	50                   	push   %eax
    c01b:	e8 2e cd ff ff       	call   8d4e <readBitsFromReversedStream>
    c020:	83 c4 0c             	add    $0xc,%esp
    c023:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    c026:	8b 45 14             	mov    0x14(%ebp),%eax
    c029:	8b 40 08             	mov    0x8(%eax),%eax
    c02c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c02f:	c1 e2 02             	shl    $0x2,%edx
    c032:	01 d0                	add    %edx,%eax
    c034:	6a 03                	push   $0x3
    c036:	50                   	push   %eax
    c037:	ff 75 08             	pushl  0x8(%ebp)
    c03a:	e8 aa 7e ff ff       	call   3ee9 <lodepng_memcpy>
    c03f:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c042:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c046:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c049:	01 45 08             	add    %eax,0x8(%ebp)
    c04c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c04f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c052:	75 b9                	jne    c00d <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c054:	e9 61 01 00 00       	jmp    c1ba <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    c059:	8b 45 14             	mov    0x14(%ebp),%eax
    c05c:	8b 00                	mov    (%eax),%eax
    c05e:	83 f8 04             	cmp    $0x4,%eax
    c061:	0f 85 a0 00 00 00    	jne    c107 <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    c067:	8b 45 14             	mov    0x14(%ebp),%eax
    c06a:	8b 40 04             	mov    0x4(%eax),%eax
    c06d:	83 f8 08             	cmp    $0x8,%eax
    c070:	75 4a                	jne    c0bc <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c072:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c079:	eb 34                	jmp    c0af <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    c07b:	8b 45 08             	mov    0x8(%ebp),%eax
    c07e:	83 c0 01             	add    $0x1,%eax
    c081:	8b 55 08             	mov    0x8(%ebp),%edx
    c084:	83 c2 02             	add    $0x2,%edx
    c087:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    c08a:	01 c9                	add    %ecx,%ecx
    c08c:	89 cb                	mov    %ecx,%ebx
    c08e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c091:	01 d9                	add    %ebx,%ecx
    c093:	0f b6 09             	movzbl (%ecx),%ecx
    c096:	88 0a                	mov    %cl,(%edx)
    c098:	0f b6 12             	movzbl (%edx),%edx
    c09b:	88 10                	mov    %dl,(%eax)
    c09d:	0f b6 10             	movzbl (%eax),%edx
    c0a0:	8b 45 08             	mov    0x8(%ebp),%eax
    c0a3:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c0a5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c0a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c0ac:	01 45 08             	add    %eax,0x8(%ebp)
    c0af:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c0b2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c0b5:	75 c4                	jne    c07b <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c0b7:	e9 fe 00 00 00       	jmp    c1ba <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c0bc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c0c3:	eb 35                	jmp    c0fa <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    c0c5:	8b 45 08             	mov    0x8(%ebp),%eax
    c0c8:	83 c0 01             	add    $0x1,%eax
    c0cb:	8b 55 08             	mov    0x8(%ebp),%edx
    c0ce:	83 c2 02             	add    $0x2,%edx
    c0d1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    c0d4:	c1 e1 02             	shl    $0x2,%ecx
    c0d7:	89 cb                	mov    %ecx,%ebx
    c0d9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c0dc:	01 d9                	add    %ebx,%ecx
    c0de:	0f b6 09             	movzbl (%ecx),%ecx
    c0e1:	88 0a                	mov    %cl,(%edx)
    c0e3:	0f b6 12             	movzbl (%edx),%edx
    c0e6:	88 10                	mov    %dl,(%eax)
    c0e8:	0f b6 10             	movzbl (%eax),%edx
    c0eb:	8b 45 08             	mov    0x8(%ebp),%eax
    c0ee:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c0f0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c0f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c0f7:	01 45 08             	add    %eax,0x8(%ebp)
    c0fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c0fd:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c100:	75 c3                	jne    c0c5 <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c102:	e9 b3 00 00 00       	jmp    c1ba <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    c107:	8b 45 14             	mov    0x14(%ebp),%eax
    c10a:	8b 00                	mov    (%eax),%eax
    c10c:	83 f8 06             	cmp    $0x6,%eax
    c10f:	0f 85 a5 00 00 00    	jne    c1ba <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    c115:	8b 45 14             	mov    0x14(%ebp),%eax
    c118:	8b 40 04             	mov    0x4(%eax),%eax
    c11b:	83 f8 08             	cmp    $0x8,%eax
    c11e:	75 38                	jne    c158 <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c120:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c127:	eb 25                	jmp    c14e <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    c129:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c12c:	c1 e0 02             	shl    $0x2,%eax
    c12f:	89 c2                	mov    %eax,%edx
    c131:	8b 45 10             	mov    0x10(%ebp),%eax
    c134:	01 d0                	add    %edx,%eax
    c136:	6a 03                	push   $0x3
    c138:	50                   	push   %eax
    c139:	ff 75 08             	pushl  0x8(%ebp)
    c13c:	e8 a8 7d ff ff       	call   3ee9 <lodepng_memcpy>
    c141:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c144:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c148:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c14b:	01 45 08             	add    %eax,0x8(%ebp)
    c14e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c151:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c154:	75 d3                	jne    c129 <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c156:	eb 62                	jmp    c1ba <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c158:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c15f:	eb 51                	jmp    c1b2 <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    c161:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c164:	c1 e0 03             	shl    $0x3,%eax
    c167:	89 c2                	mov    %eax,%edx
    c169:	8b 45 10             	mov    0x10(%ebp),%eax
    c16c:	01 d0                	add    %edx,%eax
    c16e:	0f b6 10             	movzbl (%eax),%edx
    c171:	8b 45 08             	mov    0x8(%ebp),%eax
    c174:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    c176:	8b 45 08             	mov    0x8(%ebp),%eax
    c179:	8d 50 01             	lea    0x1(%eax),%edx
    c17c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c17f:	c1 e0 03             	shl    $0x3,%eax
    c182:	8d 48 02             	lea    0x2(%eax),%ecx
    c185:	8b 45 10             	mov    0x10(%ebp),%eax
    c188:	01 c8                	add    %ecx,%eax
    c18a:	0f b6 00             	movzbl (%eax),%eax
    c18d:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    c18f:	8b 45 08             	mov    0x8(%ebp),%eax
    c192:	8d 50 02             	lea    0x2(%eax),%edx
    c195:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c198:	c1 e0 03             	shl    $0x3,%eax
    c19b:	8d 48 04             	lea    0x4(%eax),%ecx
    c19e:	8b 45 10             	mov    0x10(%ebp),%eax
    c1a1:	01 c8                	add    %ecx,%eax
    c1a3:	0f b6 00             	movzbl (%eax),%eax
    c1a6:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    c1a8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    c1ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c1af:	01 45 08             	add    %eax,0x8(%ebp)
    c1b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c1b5:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c1b8:	75 a7                	jne    c161 <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    c1ba:	90                   	nop
    c1bb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    c1be:	c9                   	leave  
    c1bf:	c3                   	ret    

0000c1c0 <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    c1c0:	55                   	push   %ebp
    c1c1:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    c1c3:	8b 45 20             	mov    0x20(%ebp),%eax
    c1c6:	8b 00                	mov    (%eax),%eax
    c1c8:	85 c0                	test   %eax,%eax
    c1ca:	0f 85 a4 00 00 00    	jne    c274 <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    c1d0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c1d3:	01 c0                	add    %eax,%eax
    c1d5:	89 c2                	mov    %eax,%edx
    c1d7:	8b 45 18             	mov    0x18(%ebp),%eax
    c1da:	01 d0                	add    %edx,%eax
    c1dc:	0f b6 00             	movzbl (%eax),%eax
    c1df:	0f b6 c0             	movzbl %al,%eax
    c1e2:	c1 e0 08             	shl    $0x8,%eax
    c1e5:	89 c2                	mov    %eax,%edx
    c1e7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c1ea:	01 c0                	add    %eax,%eax
    c1ec:	8d 48 01             	lea    0x1(%eax),%ecx
    c1ef:	8b 45 18             	mov    0x18(%ebp),%eax
    c1f2:	01 c8                	add    %ecx,%eax
    c1f4:	0f b6 00             	movzbl (%eax),%eax
    c1f7:	0f b6 c0             	movzbl %al,%eax
    c1fa:	01 c2                	add    %eax,%edx
    c1fc:	8b 45 10             	mov    0x10(%ebp),%eax
    c1ff:	66 89 10             	mov    %dx,(%eax)
    c202:	8b 45 10             	mov    0x10(%ebp),%eax
    c205:	0f b7 10             	movzwl (%eax),%edx
    c208:	8b 45 0c             	mov    0xc(%ebp),%eax
    c20b:	66 89 10             	mov    %dx,(%eax)
    c20e:	8b 45 0c             	mov    0xc(%ebp),%eax
    c211:	0f b7 10             	movzwl (%eax),%edx
    c214:	8b 45 08             	mov    0x8(%ebp),%eax
    c217:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    c21a:	8b 45 20             	mov    0x20(%ebp),%eax
    c21d:	8b 40 10             	mov    0x10(%eax),%eax
    c220:	85 c0                	test   %eax,%eax
    c222:	74 43                	je     c267 <getPixelColorRGBA16+0xa7>
    c224:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c227:	01 c0                	add    %eax,%eax
    c229:	89 c2                	mov    %eax,%edx
    c22b:	8b 45 18             	mov    0x18(%ebp),%eax
    c22e:	01 d0                	add    %edx,%eax
    c230:	0f b6 00             	movzbl (%eax),%eax
    c233:	0f b6 c0             	movzbl %al,%eax
    c236:	c1 e0 08             	shl    $0x8,%eax
    c239:	89 c2                	mov    %eax,%edx
    c23b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c23e:	01 c0                	add    %eax,%eax
    c240:	8d 48 01             	lea    0x1(%eax),%ecx
    c243:	8b 45 18             	mov    0x18(%ebp),%eax
    c246:	01 c8                	add    %ecx,%eax
    c248:	0f b6 00             	movzbl (%eax),%eax
    c24b:	0f b6 c0             	movzbl %al,%eax
    c24e:	01 c2                	add    %eax,%edx
    c250:	8b 45 20             	mov    0x20(%ebp),%eax
    c253:	8b 40 14             	mov    0x14(%eax),%eax
    c256:	39 c2                	cmp    %eax,%edx
    c258:	75 0d                	jne    c267 <getPixelColorRGBA16+0xa7>
    c25a:	8b 45 14             	mov    0x14(%ebp),%eax
    c25d:	66 c7 00 00 00       	movw   $0x0,(%eax)
    c262:	e9 48 03 00 00       	jmp    c5af <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    c267:	8b 45 14             	mov    0x14(%ebp),%eax
    c26a:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    c26f:	e9 3b 03 00 00       	jmp    c5af <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    c274:	8b 45 20             	mov    0x20(%ebp),%eax
    c277:	8b 00                	mov    (%eax),%eax
    c279:	83 f8 02             	cmp    $0x2,%eax
    c27c:	0f 85 b6 01 00 00    	jne    c438 <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    c282:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c285:	89 d0                	mov    %edx,%eax
    c287:	01 c0                	add    %eax,%eax
    c289:	01 d0                	add    %edx,%eax
    c28b:	01 c0                	add    %eax,%eax
    c28d:	89 c2                	mov    %eax,%edx
    c28f:	8b 45 18             	mov    0x18(%ebp),%eax
    c292:	01 d0                	add    %edx,%eax
    c294:	0f b6 00             	movzbl (%eax),%eax
    c297:	0f b6 c0             	movzbl %al,%eax
    c29a:	c1 e0 08             	shl    $0x8,%eax
    c29d:	89 c1                	mov    %eax,%ecx
    c29f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c2a2:	89 d0                	mov    %edx,%eax
    c2a4:	01 c0                	add    %eax,%eax
    c2a6:	01 d0                	add    %edx,%eax
    c2a8:	01 c0                	add    %eax,%eax
    c2aa:	8d 50 01             	lea    0x1(%eax),%edx
    c2ad:	8b 45 18             	mov    0x18(%ebp),%eax
    c2b0:	01 d0                	add    %edx,%eax
    c2b2:	0f b6 00             	movzbl (%eax),%eax
    c2b5:	0f b6 c0             	movzbl %al,%eax
    c2b8:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    c2bb:	8b 45 08             	mov    0x8(%ebp),%eax
    c2be:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    c2c1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c2c4:	89 d0                	mov    %edx,%eax
    c2c6:	01 c0                	add    %eax,%eax
    c2c8:	01 d0                	add    %edx,%eax
    c2ca:	01 c0                	add    %eax,%eax
    c2cc:	8d 50 02             	lea    0x2(%eax),%edx
    c2cf:	8b 45 18             	mov    0x18(%ebp),%eax
    c2d2:	01 d0                	add    %edx,%eax
    c2d4:	0f b6 00             	movzbl (%eax),%eax
    c2d7:	0f b6 c0             	movzbl %al,%eax
    c2da:	c1 e0 08             	shl    $0x8,%eax
    c2dd:	89 c1                	mov    %eax,%ecx
    c2df:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c2e2:	89 d0                	mov    %edx,%eax
    c2e4:	01 c0                	add    %eax,%eax
    c2e6:	01 d0                	add    %edx,%eax
    c2e8:	01 c0                	add    %eax,%eax
    c2ea:	8d 50 03             	lea    0x3(%eax),%edx
    c2ed:	8b 45 18             	mov    0x18(%ebp),%eax
    c2f0:	01 d0                	add    %edx,%eax
    c2f2:	0f b6 00             	movzbl (%eax),%eax
    c2f5:	0f b6 c0             	movzbl %al,%eax
    c2f8:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    c2fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    c2fe:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    c301:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c304:	89 d0                	mov    %edx,%eax
    c306:	01 c0                	add    %eax,%eax
    c308:	01 d0                	add    %edx,%eax
    c30a:	01 c0                	add    %eax,%eax
    c30c:	8d 50 04             	lea    0x4(%eax),%edx
    c30f:	8b 45 18             	mov    0x18(%ebp),%eax
    c312:	01 d0                	add    %edx,%eax
    c314:	0f b6 00             	movzbl (%eax),%eax
    c317:	0f b6 c0             	movzbl %al,%eax
    c31a:	c1 e0 08             	shl    $0x8,%eax
    c31d:	89 c1                	mov    %eax,%ecx
    c31f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c322:	89 d0                	mov    %edx,%eax
    c324:	01 c0                	add    %eax,%eax
    c326:	01 d0                	add    %edx,%eax
    c328:	01 c0                	add    %eax,%eax
    c32a:	8d 50 05             	lea    0x5(%eax),%edx
    c32d:	8b 45 18             	mov    0x18(%ebp),%eax
    c330:	01 d0                	add    %edx,%eax
    c332:	0f b6 00             	movzbl (%eax),%eax
    c335:	0f b6 c0             	movzbl %al,%eax
    c338:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    c33b:	8b 45 10             	mov    0x10(%ebp),%eax
    c33e:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    c341:	8b 45 20             	mov    0x20(%ebp),%eax
    c344:	8b 40 10             	mov    0x10(%eax),%eax
    c347:	85 c0                	test   %eax,%eax
    c349:	0f 84 dc 00 00 00    	je     c42b <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    c34f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c352:	89 d0                	mov    %edx,%eax
    c354:	01 c0                	add    %eax,%eax
    c356:	01 d0                	add    %edx,%eax
    c358:	01 c0                	add    %eax,%eax
    c35a:	89 c2                	mov    %eax,%edx
    c35c:	8b 45 18             	mov    0x18(%ebp),%eax
    c35f:	01 d0                	add    %edx,%eax
    c361:	0f b6 00             	movzbl (%eax),%eax
    c364:	0f b6 c0             	movzbl %al,%eax
    c367:	c1 e0 08             	shl    $0x8,%eax
    c36a:	89 c1                	mov    %eax,%ecx
    c36c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c36f:	89 d0                	mov    %edx,%eax
    c371:	01 c0                	add    %eax,%eax
    c373:	01 d0                	add    %edx,%eax
    c375:	01 c0                	add    %eax,%eax
    c377:	8d 50 01             	lea    0x1(%eax),%edx
    c37a:	8b 45 18             	mov    0x18(%ebp),%eax
    c37d:	01 d0                	add    %edx,%eax
    c37f:	0f b6 00             	movzbl (%eax),%eax
    c382:	0f b6 c0             	movzbl %al,%eax
    c385:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    c388:	8b 45 20             	mov    0x20(%ebp),%eax
    c38b:	8b 40 14             	mov    0x14(%eax),%eax
    c38e:	39 c2                	cmp    %eax,%edx
    c390:	0f 85 95 00 00 00    	jne    c42b <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    c396:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c399:	89 d0                	mov    %edx,%eax
    c39b:	01 c0                	add    %eax,%eax
    c39d:	01 d0                	add    %edx,%eax
    c39f:	01 c0                	add    %eax,%eax
    c3a1:	8d 50 02             	lea    0x2(%eax),%edx
    c3a4:	8b 45 18             	mov    0x18(%ebp),%eax
    c3a7:	01 d0                	add    %edx,%eax
    c3a9:	0f b6 00             	movzbl (%eax),%eax
    c3ac:	0f b6 c0             	movzbl %al,%eax
    c3af:	c1 e0 08             	shl    $0x8,%eax
    c3b2:	89 c1                	mov    %eax,%ecx
    c3b4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c3b7:	89 d0                	mov    %edx,%eax
    c3b9:	01 c0                	add    %eax,%eax
    c3bb:	01 d0                	add    %edx,%eax
    c3bd:	01 c0                	add    %eax,%eax
    c3bf:	8d 50 03             	lea    0x3(%eax),%edx
    c3c2:	8b 45 18             	mov    0x18(%ebp),%eax
    c3c5:	01 d0                	add    %edx,%eax
    c3c7:	0f b6 00             	movzbl (%eax),%eax
    c3ca:	0f b6 c0             	movzbl %al,%eax
    c3cd:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    c3d0:	8b 45 20             	mov    0x20(%ebp),%eax
    c3d3:	8b 40 18             	mov    0x18(%eax),%eax
    c3d6:	39 c2                	cmp    %eax,%edx
    c3d8:	75 51                	jne    c42b <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    c3da:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c3dd:	89 d0                	mov    %edx,%eax
    c3df:	01 c0                	add    %eax,%eax
    c3e1:	01 d0                	add    %edx,%eax
    c3e3:	01 c0                	add    %eax,%eax
    c3e5:	8d 50 04             	lea    0x4(%eax),%edx
    c3e8:	8b 45 18             	mov    0x18(%ebp),%eax
    c3eb:	01 d0                	add    %edx,%eax
    c3ed:	0f b6 00             	movzbl (%eax),%eax
    c3f0:	0f b6 c0             	movzbl %al,%eax
    c3f3:	c1 e0 08             	shl    $0x8,%eax
    c3f6:	89 c1                	mov    %eax,%ecx
    c3f8:	8b 55 1c             	mov    0x1c(%ebp),%edx
    c3fb:	89 d0                	mov    %edx,%eax
    c3fd:	01 c0                	add    %eax,%eax
    c3ff:	01 d0                	add    %edx,%eax
    c401:	01 c0                	add    %eax,%eax
    c403:	8d 50 05             	lea    0x5(%eax),%edx
    c406:	8b 45 18             	mov    0x18(%ebp),%eax
    c409:	01 d0                	add    %edx,%eax
    c40b:	0f b6 00             	movzbl (%eax),%eax
    c40e:	0f b6 c0             	movzbl %al,%eax
    c411:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    c414:	8b 45 20             	mov    0x20(%ebp),%eax
    c417:	8b 40 1c             	mov    0x1c(%eax),%eax
    c41a:	39 c2                	cmp    %eax,%edx
    c41c:	75 0d                	jne    c42b <getPixelColorRGBA16+0x26b>
    c41e:	8b 45 14             	mov    0x14(%ebp),%eax
    c421:	66 c7 00 00 00       	movw   $0x0,(%eax)
    c426:	e9 84 01 00 00       	jmp    c5af <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    c42b:	8b 45 14             	mov    0x14(%ebp),%eax
    c42e:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    c433:	e9 77 01 00 00       	jmp    c5af <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    c438:	8b 45 20             	mov    0x20(%ebp),%eax
    c43b:	8b 00                	mov    (%eax),%eax
    c43d:	83 f8 04             	cmp    $0x4,%eax
    c440:	0f 85 86 00 00 00    	jne    c4cc <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    c446:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c449:	c1 e0 02             	shl    $0x2,%eax
    c44c:	89 c2                	mov    %eax,%edx
    c44e:	8b 45 18             	mov    0x18(%ebp),%eax
    c451:	01 d0                	add    %edx,%eax
    c453:	0f b6 00             	movzbl (%eax),%eax
    c456:	0f b6 c0             	movzbl %al,%eax
    c459:	c1 e0 08             	shl    $0x8,%eax
    c45c:	89 c2                	mov    %eax,%edx
    c45e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c461:	c1 e0 02             	shl    $0x2,%eax
    c464:	8d 48 01             	lea    0x1(%eax),%ecx
    c467:	8b 45 18             	mov    0x18(%ebp),%eax
    c46a:	01 c8                	add    %ecx,%eax
    c46c:	0f b6 00             	movzbl (%eax),%eax
    c46f:	0f b6 c0             	movzbl %al,%eax
    c472:	01 c2                	add    %eax,%edx
    c474:	8b 45 10             	mov    0x10(%ebp),%eax
    c477:	66 89 10             	mov    %dx,(%eax)
    c47a:	8b 45 10             	mov    0x10(%ebp),%eax
    c47d:	0f b7 10             	movzwl (%eax),%edx
    c480:	8b 45 0c             	mov    0xc(%ebp),%eax
    c483:	66 89 10             	mov    %dx,(%eax)
    c486:	8b 45 0c             	mov    0xc(%ebp),%eax
    c489:	0f b7 10             	movzwl (%eax),%edx
    c48c:	8b 45 08             	mov    0x8(%ebp),%eax
    c48f:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    c492:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c495:	c1 e0 02             	shl    $0x2,%eax
    c498:	8d 50 02             	lea    0x2(%eax),%edx
    c49b:	8b 45 18             	mov    0x18(%ebp),%eax
    c49e:	01 d0                	add    %edx,%eax
    c4a0:	0f b6 00             	movzbl (%eax),%eax
    c4a3:	0f b6 c0             	movzbl %al,%eax
    c4a6:	c1 e0 08             	shl    $0x8,%eax
    c4a9:	89 c2                	mov    %eax,%edx
    c4ab:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c4ae:	c1 e0 02             	shl    $0x2,%eax
    c4b1:	8d 48 03             	lea    0x3(%eax),%ecx
    c4b4:	8b 45 18             	mov    0x18(%ebp),%eax
    c4b7:	01 c8                	add    %ecx,%eax
    c4b9:	0f b6 00             	movzbl (%eax),%eax
    c4bc:	0f b6 c0             	movzbl %al,%eax
    c4bf:	01 c2                	add    %eax,%edx
    c4c1:	8b 45 14             	mov    0x14(%ebp),%eax
    c4c4:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    c4c7:	e9 e3 00 00 00       	jmp    c5af <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    c4cc:	8b 45 20             	mov    0x20(%ebp),%eax
    c4cf:	8b 00                	mov    (%eax),%eax
    c4d1:	83 f8 06             	cmp    $0x6,%eax
    c4d4:	0f 85 d5 00 00 00    	jne    c5af <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    c4da:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c4dd:	c1 e0 03             	shl    $0x3,%eax
    c4e0:	89 c2                	mov    %eax,%edx
    c4e2:	8b 45 18             	mov    0x18(%ebp),%eax
    c4e5:	01 d0                	add    %edx,%eax
    c4e7:	0f b6 00             	movzbl (%eax),%eax
    c4ea:	0f b6 c0             	movzbl %al,%eax
    c4ed:	c1 e0 08             	shl    $0x8,%eax
    c4f0:	89 c2                	mov    %eax,%edx
    c4f2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c4f5:	c1 e0 03             	shl    $0x3,%eax
    c4f8:	8d 48 01             	lea    0x1(%eax),%ecx
    c4fb:	8b 45 18             	mov    0x18(%ebp),%eax
    c4fe:	01 c8                	add    %ecx,%eax
    c500:	0f b6 00             	movzbl (%eax),%eax
    c503:	0f b6 c0             	movzbl %al,%eax
    c506:	01 c2                	add    %eax,%edx
    c508:	8b 45 08             	mov    0x8(%ebp),%eax
    c50b:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    c50e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c511:	c1 e0 03             	shl    $0x3,%eax
    c514:	8d 50 02             	lea    0x2(%eax),%edx
    c517:	8b 45 18             	mov    0x18(%ebp),%eax
    c51a:	01 d0                	add    %edx,%eax
    c51c:	0f b6 00             	movzbl (%eax),%eax
    c51f:	0f b6 c0             	movzbl %al,%eax
    c522:	c1 e0 08             	shl    $0x8,%eax
    c525:	89 c2                	mov    %eax,%edx
    c527:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c52a:	c1 e0 03             	shl    $0x3,%eax
    c52d:	8d 48 03             	lea    0x3(%eax),%ecx
    c530:	8b 45 18             	mov    0x18(%ebp),%eax
    c533:	01 c8                	add    %ecx,%eax
    c535:	0f b6 00             	movzbl (%eax),%eax
    c538:	0f b6 c0             	movzbl %al,%eax
    c53b:	01 c2                	add    %eax,%edx
    c53d:	8b 45 0c             	mov    0xc(%ebp),%eax
    c540:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    c543:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c546:	c1 e0 03             	shl    $0x3,%eax
    c549:	8d 50 04             	lea    0x4(%eax),%edx
    c54c:	8b 45 18             	mov    0x18(%ebp),%eax
    c54f:	01 d0                	add    %edx,%eax
    c551:	0f b6 00             	movzbl (%eax),%eax
    c554:	0f b6 c0             	movzbl %al,%eax
    c557:	c1 e0 08             	shl    $0x8,%eax
    c55a:	89 c2                	mov    %eax,%edx
    c55c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c55f:	c1 e0 03             	shl    $0x3,%eax
    c562:	8d 48 05             	lea    0x5(%eax),%ecx
    c565:	8b 45 18             	mov    0x18(%ebp),%eax
    c568:	01 c8                	add    %ecx,%eax
    c56a:	0f b6 00             	movzbl (%eax),%eax
    c56d:	0f b6 c0             	movzbl %al,%eax
    c570:	01 c2                	add    %eax,%edx
    c572:	8b 45 10             	mov    0x10(%ebp),%eax
    c575:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    c578:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c57b:	c1 e0 03             	shl    $0x3,%eax
    c57e:	8d 50 06             	lea    0x6(%eax),%edx
    c581:	8b 45 18             	mov    0x18(%ebp),%eax
    c584:	01 d0                	add    %edx,%eax
    c586:	0f b6 00             	movzbl (%eax),%eax
    c589:	0f b6 c0             	movzbl %al,%eax
    c58c:	c1 e0 08             	shl    $0x8,%eax
    c58f:	89 c2                	mov    %eax,%edx
    c591:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c594:	c1 e0 03             	shl    $0x3,%eax
    c597:	8d 48 07             	lea    0x7(%eax),%ecx
    c59a:	8b 45 18             	mov    0x18(%ebp),%eax
    c59d:	01 c8                	add    %ecx,%eax
    c59f:	0f b6 00             	movzbl (%eax),%eax
    c5a2:	0f b6 c0             	movzbl %al,%eax
    c5a5:	01 c2                	add    %eax,%edx
    c5a7:	8b 45 14             	mov    0x14(%ebp),%eax
    c5aa:	66 89 10             	mov    %dx,(%eax)
  }
}
    c5ad:	eb 00                	jmp    c5af <getPixelColorRGBA16+0x3ef>
    c5af:	90                   	nop
    c5b0:	5d                   	pop    %ebp
    c5b1:	c3                   	ret    

0000c5b2 <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    c5b2:	55                   	push   %ebp
    c5b3:	89 e5                	mov    %esp,%ebp
    c5b5:	56                   	push   %esi
    c5b6:	53                   	push   %ebx
    c5b7:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c5ba:	8b 55 18             	mov    0x18(%ebp),%edx
    c5bd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c5c0:	0f af c2             	imul   %edx,%eax
    c5c3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    c5c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    c5cd:	8b 45 14             	mov    0x14(%ebp),%eax
    c5d0:	8b 00                	mov    (%eax),%eax
    c5d2:	83 f8 03             	cmp    $0x3,%eax
    c5d5:	75 14                	jne    c5eb <lodepng_convert+0x39>
    c5d7:	8b 45 14             	mov    0x14(%ebp),%eax
    c5da:	8b 40 08             	mov    0x8(%eax),%eax
    c5dd:	85 c0                	test   %eax,%eax
    c5df:	75 0a                	jne    c5eb <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    c5e1:	b8 6b 00 00 00       	mov    $0x6b,%eax
    c5e6:	e9 19 03 00 00       	jmp    c904 <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    c5eb:	ff 75 14             	pushl  0x14(%ebp)
    c5ee:	ff 75 10             	pushl  0x10(%ebp)
    c5f1:	e8 b7 d1 ff ff       	call   97ad <lodepng_color_mode_equal>
    c5f6:	83 c4 08             	add    $0x8,%esp
    c5f9:	85 c0                	test   %eax,%eax
    c5fb:	74 2f                	je     c62c <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    c5fd:	ff 75 14             	pushl  0x14(%ebp)
    c600:	ff 75 1c             	pushl  0x1c(%ebp)
    c603:	ff 75 18             	pushl  0x18(%ebp)
    c606:	e8 fb d4 ff ff       	call   9b06 <lodepng_get_raw_size>
    c60b:	83 c4 0c             	add    $0xc,%esp
    c60e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    c611:	ff 75 dc             	pushl  -0x24(%ebp)
    c614:	ff 75 0c             	pushl  0xc(%ebp)
    c617:	ff 75 08             	pushl  0x8(%ebp)
    c61a:	e8 ca 78 ff ff       	call   3ee9 <lodepng_memcpy>
    c61f:	83 c4 0c             	add    $0xc,%esp
    return 0;
    c622:	b8 00 00 00 00       	mov    $0x0,%eax
    c627:	e9 d8 02 00 00       	jmp    c904 <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    c62c:	8b 45 10             	mov    0x10(%ebp),%eax
    c62f:	8b 00                	mov    (%eax),%eax
    c631:	83 f8 03             	cmp    $0x3,%eax
    c634:	0f 85 16 01 00 00    	jne    c750 <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    c63a:	8b 45 10             	mov    0x10(%ebp),%eax
    c63d:	8b 40 0c             	mov    0xc(%eax),%eax
    c640:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    c643:	8b 45 10             	mov    0x10(%ebp),%eax
    c646:	8b 40 08             	mov    0x8(%eax),%eax
    c649:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    c64c:	8b 45 10             	mov    0x10(%ebp),%eax
    c64f:	8b 40 04             	mov    0x4(%eax),%eax
    c652:	ba 01 00 00 00       	mov    $0x1,%edx
    c657:	89 c1                	mov    %eax,%ecx
    c659:	d3 e2                	shl    %cl,%edx
    c65b:	89 d0                	mov    %edx,%eax
    c65d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    c660:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c664:	75 5b                	jne    c6c1 <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    c666:	8b 45 14             	mov    0x14(%ebp),%eax
    c669:	8b 40 0c             	mov    0xc(%eax),%eax
    c66c:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    c66f:	8b 45 14             	mov    0x14(%ebp),%eax
    c672:	8b 40 08             	mov    0x8(%eax),%eax
    c675:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    c678:	8b 45 14             	mov    0x14(%ebp),%eax
    c67b:	8b 00                	mov    (%eax),%eax
    c67d:	83 f8 03             	cmp    $0x3,%eax
    c680:	75 3f                	jne    c6c1 <lodepng_convert+0x10f>
    c682:	8b 45 14             	mov    0x14(%ebp),%eax
    c685:	8b 50 04             	mov    0x4(%eax),%edx
    c688:	8b 45 10             	mov    0x10(%ebp),%eax
    c68b:	8b 40 04             	mov    0x4(%eax),%eax
    c68e:	39 c2                	cmp    %eax,%edx
    c690:	75 2f                	jne    c6c1 <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    c692:	ff 75 14             	pushl  0x14(%ebp)
    c695:	ff 75 1c             	pushl  0x1c(%ebp)
    c698:	ff 75 18             	pushl  0x18(%ebp)
    c69b:	e8 66 d4 ff ff       	call   9b06 <lodepng_get_raw_size>
    c6a0:	83 c4 0c             	add    $0xc,%esp
    c6a3:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    c6a6:	ff 75 d8             	pushl  -0x28(%ebp)
    c6a9:	ff 75 0c             	pushl  0xc(%ebp)
    c6ac:	ff 75 08             	pushl  0x8(%ebp)
    c6af:	e8 35 78 ff ff       	call   3ee9 <lodepng_memcpy>
    c6b4:	83 c4 0c             	add    $0xc,%esp
        return 0;
    c6b7:	b8 00 00 00 00       	mov    $0x0,%eax
    c6bc:	e9 43 02 00 00       	jmp    c904 <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    c6c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c6c4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    c6c7:	7d 06                	jge    c6cf <lodepng_convert+0x11d>
    c6c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c6cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    c6cf:	8d 45 90             	lea    -0x70(%ebp),%eax
    c6d2:	50                   	push   %eax
    c6d3:	e8 5f e1 ff ff       	call   a837 <color_tree_init>
    c6d8:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    c6db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c6e2:	eb 61                	jmp    c745 <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    c6e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c6e7:	c1 e0 02             	shl    $0x2,%eax
    c6ea:	89 c2                	mov    %eax,%edx
    c6ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c6ef:	01 d0                	add    %edx,%eax
    c6f1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    c6f4:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c6f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c6fa:	83 c0 03             	add    $0x3,%eax
    c6fd:	0f b6 00             	movzbl (%eax),%eax
    c700:	0f b6 d8             	movzbl %al,%ebx
    c703:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c706:	83 c0 02             	add    $0x2,%eax
    c709:	0f b6 00             	movzbl (%eax),%eax
    c70c:	0f b6 c8             	movzbl %al,%ecx
    c70f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c712:	83 c0 01             	add    $0x1,%eax
    c715:	0f b6 00             	movzbl (%eax),%eax
    c718:	0f b6 d0             	movzbl %al,%edx
    c71b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c71e:	0f b6 00             	movzbl (%eax),%eax
    c721:	0f b6 c0             	movzbl %al,%eax
    c724:	83 ec 08             	sub    $0x8,%esp
    c727:	56                   	push   %esi
    c728:	53                   	push   %ebx
    c729:	51                   	push   %ecx
    c72a:	52                   	push   %edx
    c72b:	50                   	push   %eax
    c72c:	8d 45 90             	lea    -0x70(%ebp),%eax
    c72f:	50                   	push   %eax
    c730:	e8 85 e2 ff ff       	call   a9ba <color_tree_add>
    c735:	83 c4 20             	add    $0x20,%esp
    c738:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    c73b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c73f:	75 0e                	jne    c74f <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    c741:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c745:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c748:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    c74b:	75 97                	jne    c6e4 <lodepng_convert+0x132>
    c74d:	eb 01                	jmp    c750 <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    c74f:	90                   	nop
    }
  }

  if(!error) {
    c750:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c754:	0f 85 8e 01 00 00    	jne    c8e8 <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    c75a:	8b 45 14             	mov    0x14(%ebp),%eax
    c75d:	8b 40 04             	mov    0x4(%eax),%eax
    c760:	83 f8 10             	cmp    $0x10,%eax
    c763:	0f 85 99 00 00 00    	jne    c802 <lodepng_convert+0x250>
    c769:	8b 45 10             	mov    0x10(%ebp),%eax
    c76c:	8b 40 04             	mov    0x4(%eax),%eax
    c76f:	83 f8 10             	cmp    $0x10,%eax
    c772:	0f 85 8a 00 00 00    	jne    c802 <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    c778:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c77f:	eb 74                	jmp    c7f5 <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    c781:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    c787:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    c78d:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    c793:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c799:	83 ec 04             	sub    $0x4,%esp
    c79c:	ff 75 14             	pushl  0x14(%ebp)
    c79f:	ff 75 f4             	pushl  -0xc(%ebp)
    c7a2:	ff 75 0c             	pushl  0xc(%ebp)
    c7a5:	8d 45 88             	lea    -0x78(%ebp),%eax
    c7a8:	50                   	push   %eax
    c7a9:	8d 45 8a             	lea    -0x76(%ebp),%eax
    c7ac:	50                   	push   %eax
    c7ad:	8d 45 8c             	lea    -0x74(%ebp),%eax
    c7b0:	50                   	push   %eax
    c7b1:	8d 45 8e             	lea    -0x72(%ebp),%eax
    c7b4:	50                   	push   %eax
    c7b5:	e8 06 fa ff ff       	call   c1c0 <getPixelColorRGBA16>
    c7ba:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    c7bd:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    c7c1:	0f b7 d8             	movzwl %ax,%ebx
    c7c4:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    c7c8:	0f b7 c8             	movzwl %ax,%ecx
    c7cb:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    c7cf:	0f b7 d0             	movzwl %ax,%edx
    c7d2:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    c7d6:	0f b7 c0             	movzwl %ax,%eax
    c7d9:	83 ec 04             	sub    $0x4,%esp
    c7dc:	53                   	push   %ebx
    c7dd:	51                   	push   %ecx
    c7de:	52                   	push   %edx
    c7df:	50                   	push   %eax
    c7e0:	ff 75 10             	pushl  0x10(%ebp)
    c7e3:	ff 75 f4             	pushl  -0xc(%ebp)
    c7e6:	ff 75 08             	pushl  0x8(%ebp)
    c7e9:	e8 d3 e6 ff ff       	call   aec1 <rgba16ToPixel>
    c7ee:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    c7f1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c7f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c7f8:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    c7fb:	75 84                	jne    c781 <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    c7fd:	e9 e6 00 00 00       	jmp    c8e8 <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    c802:	8b 45 10             	mov    0x10(%ebp),%eax
    c805:	8b 40 04             	mov    0x4(%eax),%eax
    c808:	83 f8 08             	cmp    $0x8,%eax
    c80b:	75 23                	jne    c830 <lodepng_convert+0x27e>
    c80d:	8b 45 10             	mov    0x10(%ebp),%eax
    c810:	8b 00                	mov    (%eax),%eax
    c812:	83 f8 06             	cmp    $0x6,%eax
    c815:	75 19                	jne    c830 <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    c817:	ff 75 14             	pushl  0x14(%ebp)
    c81a:	ff 75 0c             	pushl  0xc(%ebp)
    c81d:	ff 75 e0             	pushl  -0x20(%ebp)
    c820:	ff 75 08             	pushl  0x8(%ebp)
    c823:	e8 ae ee ff ff       	call   b6d6 <getPixelColorsRGBA8>
    c828:	83 c4 10             	add    $0x10,%esp
    c82b:	e9 b8 00 00 00       	jmp    c8e8 <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    c830:	8b 45 10             	mov    0x10(%ebp),%eax
    c833:	8b 40 04             	mov    0x4(%eax),%eax
    c836:	83 f8 08             	cmp    $0x8,%eax
    c839:	75 23                	jne    c85e <lodepng_convert+0x2ac>
    c83b:	8b 45 10             	mov    0x10(%ebp),%eax
    c83e:	8b 00                	mov    (%eax),%eax
    c840:	83 f8 02             	cmp    $0x2,%eax
    c843:	75 19                	jne    c85e <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    c845:	ff 75 14             	pushl  0x14(%ebp)
    c848:	ff 75 0c             	pushl  0xc(%ebp)
    c84b:	ff 75 e0             	pushl  -0x20(%ebp)
    c84e:	ff 75 08             	pushl  0x8(%ebp)
    c851:	e8 50 f5 ff ff       	call   bda6 <getPixelColorsRGB8>
    c856:	83 c4 10             	add    $0x10,%esp
    c859:	e9 8a 00 00 00       	jmp    c8e8 <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    c85e:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    c862:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    c866:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    c86a:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    c86e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c875:	eb 66                	jmp    c8dd <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c877:	83 ec 04             	sub    $0x4,%esp
    c87a:	ff 75 14             	pushl  0x14(%ebp)
    c87d:	ff 75 f4             	pushl  -0xc(%ebp)
    c880:	ff 75 0c             	pushl  0xc(%ebp)
    c883:	8d 45 84             	lea    -0x7c(%ebp),%eax
    c886:	50                   	push   %eax
    c887:	8d 45 85             	lea    -0x7b(%ebp),%eax
    c88a:	50                   	push   %eax
    c88b:	8d 45 86             	lea    -0x7a(%ebp),%eax
    c88e:	50                   	push   %eax
    c88f:	8d 45 87             	lea    -0x79(%ebp),%eax
    c892:	50                   	push   %eax
    c893:	e8 71 e8 ff ff       	call   b109 <getPixelColorRGBA8>
    c898:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    c89b:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    c89f:	0f b6 d8             	movzbl %al,%ebx
    c8a2:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    c8a6:	0f b6 c8             	movzbl %al,%ecx
    c8a9:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    c8ad:	0f b6 d0             	movzbl %al,%edx
    c8b0:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    c8b4:	0f b6 c0             	movzbl %al,%eax
    c8b7:	53                   	push   %ebx
    c8b8:	51                   	push   %ecx
    c8b9:	52                   	push   %edx
    c8ba:	50                   	push   %eax
    c8bb:	8d 45 90             	lea    -0x70(%ebp),%eax
    c8be:	50                   	push   %eax
    c8bf:	ff 75 10             	pushl  0x10(%ebp)
    c8c2:	ff 75 f4             	pushl  -0xc(%ebp)
    c8c5:	ff 75 08             	pushl  0x8(%ebp)
    c8c8:	e8 e5 e1 ff ff       	call   aab2 <rgba8ToPixel>
    c8cd:	83 c4 20             	add    $0x20,%esp
    c8d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    c8d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c8d7:	75 0e                	jne    c8e7 <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    c8d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c8dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c8e0:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    c8e3:	75 92                	jne    c877 <lodepng_convert+0x2c5>
    c8e5:	eb 01                	jmp    c8e8 <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    c8e7:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    c8e8:	8b 45 10             	mov    0x10(%ebp),%eax
    c8eb:	8b 00                	mov    (%eax),%eax
    c8ed:	83 f8 03             	cmp    $0x3,%eax
    c8f0:	75 0f                	jne    c901 <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    c8f2:	83 ec 0c             	sub    $0xc,%esp
    c8f5:	8d 45 90             	lea    -0x70(%ebp),%eax
    c8f8:	50                   	push   %eax
    c8f9:	e8 59 df ff ff       	call   a857 <color_tree_cleanup>
    c8fe:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    c901:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    c904:	8d 65 f8             	lea    -0x8(%ebp),%esp
    c907:	5b                   	pop    %ebx
    c908:	5e                   	pop    %esi
    c909:	5d                   	pop    %ebp
    c90a:	c3                   	ret    

0000c90b <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    c90b:	55                   	push   %ebp
    c90c:	89 e5                	mov    %esp,%ebp
    c90e:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    c911:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    c918:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c91f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    c926:	8b 45 24             	mov    0x24(%ebp),%eax
    c929:	8b 40 04             	mov    0x4(%eax),%eax
    c92c:	ba 01 00 00 00       	mov    $0x1,%edx
    c931:	89 c1                	mov    %eax,%ecx
    c933:	d3 e2                	shl    %cl,%edx
    c935:	89 d0                	mov    %edx,%eax
    c937:	8d 48 ff             	lea    -0x1(%eax),%ecx
    c93a:	b8 ff ff 00 00       	mov    $0xffff,%eax
    c93f:	ba 00 00 00 00       	mov    $0x0,%edx
    c944:	f7 f1                	div    %ecx
    c946:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    c949:	8b 45 20             	mov    0x20(%ebp),%eax
    c94c:	8b 40 04             	mov    0x4(%eax),%eax
    c94f:	ba 10 00 00 00       	mov    $0x10,%edx
    c954:	29 c2                	sub    %eax,%edx
    c956:	89 d0                	mov    %edx,%eax
    c958:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    c95b:	8b 45 24             	mov    0x24(%ebp),%eax
    c95e:	8b 00                	mov    (%eax),%eax
    c960:	85 c0                	test   %eax,%eax
    c962:	74 0a                	je     c96e <lodepng_convert_rgb+0x63>
    c964:	8b 45 24             	mov    0x24(%ebp),%eax
    c967:	8b 00                	mov    (%eax),%eax
    c969:	83 f8 04             	cmp    $0x4,%eax
    c96c:	75 1b                	jne    c989 <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    c96e:	8b 45 14             	mov    0x14(%ebp),%eax
    c971:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c975:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c978:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c97b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    c97e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c981:	89 45 fc             	mov    %eax,-0x4(%ebp)
    c984:	e9 c2 00 00 00       	jmp    ca4b <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    c989:	8b 45 24             	mov    0x24(%ebp),%eax
    c98c:	8b 00                	mov    (%eax),%eax
    c98e:	83 f8 02             	cmp    $0x2,%eax
    c991:	74 0a                	je     c99d <lodepng_convert_rgb+0x92>
    c993:	8b 45 24             	mov    0x24(%ebp),%eax
    c996:	8b 00                	mov    (%eax),%eax
    c998:	83 f8 06             	cmp    $0x6,%eax
    c99b:	75 23                	jne    c9c0 <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    c99d:	8b 45 14             	mov    0x14(%ebp),%eax
    c9a0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c9a4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    c9a7:	8b 45 18             	mov    0x18(%ebp),%eax
    c9aa:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c9ae:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    c9b1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c9b4:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c9b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c9bb:	e9 8b 00 00 00       	jmp    ca4b <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    c9c0:	8b 45 24             	mov    0x24(%ebp),%eax
    c9c3:	8b 00                	mov    (%eax),%eax
    c9c5:	83 f8 03             	cmp    $0x3,%eax
    c9c8:	75 77                	jne    ca41 <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    c9ca:	8b 45 24             	mov    0x24(%ebp),%eax
    c9cd:	8b 40 0c             	mov    0xc(%eax),%eax
    c9d0:	3b 45 14             	cmp    0x14(%ebp),%eax
    c9d3:	77 0a                	ja     c9df <lodepng_convert_rgb+0xd4>
    c9d5:	b8 52 00 00 00       	mov    $0x52,%eax
    c9da:	e9 cb 01 00 00       	jmp    cbaa <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    c9df:	8b 45 24             	mov    0x24(%ebp),%eax
    c9e2:	8b 40 08             	mov    0x8(%eax),%eax
    c9e5:	8b 55 14             	mov    0x14(%ebp),%edx
    c9e8:	c1 e2 02             	shl    $0x2,%edx
    c9eb:	01 d0                	add    %edx,%eax
    c9ed:	0f b6 00             	movzbl (%eax),%eax
    c9f0:	0f b6 d0             	movzbl %al,%edx
    c9f3:	89 d0                	mov    %edx,%eax
    c9f5:	c1 e0 08             	shl    $0x8,%eax
    c9f8:	01 d0                	add    %edx,%eax
    c9fa:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    c9fd:	8b 45 24             	mov    0x24(%ebp),%eax
    ca00:	8b 40 08             	mov    0x8(%eax),%eax
    ca03:	8b 55 14             	mov    0x14(%ebp),%edx
    ca06:	c1 e2 02             	shl    $0x2,%edx
    ca09:	83 c2 01             	add    $0x1,%edx
    ca0c:	01 d0                	add    %edx,%eax
    ca0e:	0f b6 00             	movzbl (%eax),%eax
    ca11:	0f b6 d0             	movzbl %al,%edx
    ca14:	89 d0                	mov    %edx,%eax
    ca16:	c1 e0 08             	shl    $0x8,%eax
    ca19:	01 d0                	add    %edx,%eax
    ca1b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    ca1e:	8b 45 24             	mov    0x24(%ebp),%eax
    ca21:	8b 40 08             	mov    0x8(%eax),%eax
    ca24:	8b 55 14             	mov    0x14(%ebp),%edx
    ca27:	c1 e2 02             	shl    $0x2,%edx
    ca2a:	83 c2 02             	add    $0x2,%edx
    ca2d:	01 d0                	add    %edx,%eax
    ca2f:	0f b6 00             	movzbl (%eax),%eax
    ca32:	0f b6 d0             	movzbl %al,%edx
    ca35:	89 d0                	mov    %edx,%eax
    ca37:	c1 e0 08             	shl    $0x8,%eax
    ca3a:	01 d0                	add    %edx,%eax
    ca3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ca3f:	eb 0a                	jmp    ca4b <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    ca41:	b8 1f 00 00 00       	mov    $0x1f,%eax
    ca46:	e9 5f 01 00 00       	jmp    cbaa <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    ca4b:	8b 45 20             	mov    0x20(%ebp),%eax
    ca4e:	8b 00                	mov    (%eax),%eax
    ca50:	85 c0                	test   %eax,%eax
    ca52:	74 0a                	je     ca5e <lodepng_convert_rgb+0x153>
    ca54:	8b 45 20             	mov    0x20(%ebp),%eax
    ca57:	8b 00                	mov    (%eax),%eax
    ca59:	83 f8 04             	cmp    $0x4,%eax
    ca5c:	75 14                	jne    ca72 <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    ca5e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ca61:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ca64:	89 c1                	mov    %eax,%ecx
    ca66:	d3 ea                	shr    %cl,%edx
    ca68:	8b 45 08             	mov    0x8(%ebp),%eax
    ca6b:	89 10                	mov    %edx,(%eax)
    ca6d:	e9 33 01 00 00       	jmp    cba5 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    ca72:	8b 45 20             	mov    0x20(%ebp),%eax
    ca75:	8b 00                	mov    (%eax),%eax
    ca77:	83 f8 02             	cmp    $0x2,%eax
    ca7a:	74 0a                	je     ca86 <lodepng_convert_rgb+0x17b>
    ca7c:	8b 45 20             	mov    0x20(%ebp),%eax
    ca7f:	8b 00                	mov    (%eax),%eax
    ca81:	83 f8 06             	cmp    $0x6,%eax
    ca84:	75 32                	jne    cab8 <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    ca86:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ca89:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ca8c:	89 c1                	mov    %eax,%ecx
    ca8e:	d3 ea                	shr    %cl,%edx
    ca90:	8b 45 08             	mov    0x8(%ebp),%eax
    ca93:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    ca95:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ca98:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ca9b:	89 c1                	mov    %eax,%ecx
    ca9d:	d3 ea                	shr    %cl,%edx
    ca9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    caa2:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    caa4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    caa7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    caaa:	89 c1                	mov    %eax,%ecx
    caac:	d3 ea                	shr    %cl,%edx
    caae:	8b 45 10             	mov    0x10(%ebp),%eax
    cab1:	89 10                	mov    %edx,(%eax)
    cab3:	e9 ed 00 00 00       	jmp    cba5 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    cab8:	8b 45 20             	mov    0x20(%ebp),%eax
    cabb:	8b 00                	mov    (%eax),%eax
    cabd:	83 f8 03             	cmp    $0x3,%eax
    cac0:	0f 85 d8 00 00 00    	jne    cb9e <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    cac6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    cac9:	c1 e8 08             	shr    $0x8,%eax
    cacc:	89 c2                	mov    %eax,%edx
    cace:	8b 45 fc             	mov    -0x4(%ebp),%eax
    cad1:	0f b6 c0             	movzbl %al,%eax
    cad4:	39 c2                	cmp    %eax,%edx
    cad6:	75 24                	jne    cafc <lodepng_convert_rgb+0x1f1>
    cad8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cadb:	c1 e8 08             	shr    $0x8,%eax
    cade:	89 c2                	mov    %eax,%edx
    cae0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cae3:	0f b6 c0             	movzbl %al,%eax
    cae6:	39 c2                	cmp    %eax,%edx
    cae8:	75 12                	jne    cafc <lodepng_convert_rgb+0x1f1>
    caea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    caed:	c1 e8 08             	shr    $0x8,%eax
    caf0:	89 c2                	mov    %eax,%edx
    caf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    caf5:	0f b6 c0             	movzbl %al,%eax
    caf8:	39 c2                	cmp    %eax,%edx
    cafa:	74 0a                	je     cb06 <lodepng_convert_rgb+0x1fb>
    cafc:	b8 52 00 00 00       	mov    $0x52,%eax
    cb01:	e9 a4 00 00 00       	jmp    cbaa <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    cb06:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    cb0d:	eb 79                	jmp    cb88 <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    cb0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cb12:	c1 e0 02             	shl    $0x2,%eax
    cb15:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    cb18:	8b 45 fc             	mov    -0x4(%ebp),%eax
    cb1b:	c1 e8 08             	shr    $0x8,%eax
    cb1e:	89 c1                	mov    %eax,%ecx
    cb20:	8b 45 20             	mov    0x20(%ebp),%eax
    cb23:	8b 50 08             	mov    0x8(%eax),%edx
    cb26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    cb29:	01 d0                	add    %edx,%eax
    cb2b:	0f b6 00             	movzbl (%eax),%eax
    cb2e:	0f b6 c0             	movzbl %al,%eax
    cb31:	39 c1                	cmp    %eax,%ecx
    cb33:	75 4f                	jne    cb84 <lodepng_convert_rgb+0x279>
    cb35:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cb38:	c1 e8 08             	shr    $0x8,%eax
    cb3b:	89 c1                	mov    %eax,%ecx
    cb3d:	8b 45 20             	mov    0x20(%ebp),%eax
    cb40:	8b 40 08             	mov    0x8(%eax),%eax
    cb43:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    cb46:	83 c2 01             	add    $0x1,%edx
    cb49:	01 d0                	add    %edx,%eax
    cb4b:	0f b6 00             	movzbl (%eax),%eax
    cb4e:	0f b6 c0             	movzbl %al,%eax
    cb51:	39 c1                	cmp    %eax,%ecx
    cb53:	75 2f                	jne    cb84 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    cb55:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cb58:	c1 e8 08             	shr    $0x8,%eax
    cb5b:	89 c1                	mov    %eax,%ecx
    cb5d:	8b 45 20             	mov    0x20(%ebp),%eax
    cb60:	8b 40 08             	mov    0x8(%eax),%eax
    cb63:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    cb66:	83 c2 02             	add    $0x2,%edx
    cb69:	01 d0                	add    %edx,%eax
    cb6b:	0f b6 00             	movzbl (%eax),%eax
    cb6e:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    cb71:	39 c1                	cmp    %eax,%ecx
    cb73:	75 0f                	jne    cb84 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    cb75:	8b 45 08             	mov    0x8(%ebp),%eax
    cb78:	8b 55 f0             	mov    -0x10(%ebp),%edx
    cb7b:	89 10                	mov    %edx,(%eax)
        return 0;
    cb7d:	b8 00 00 00 00       	mov    $0x0,%eax
    cb82:	eb 26                	jmp    cbaa <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    cb84:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    cb88:	8b 45 20             	mov    0x20(%ebp),%eax
    cb8b:	8b 40 0c             	mov    0xc(%eax),%eax
    cb8e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    cb91:	0f 87 78 ff ff ff    	ja     cb0f <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    cb97:	b8 52 00 00 00       	mov    $0x52,%eax
    cb9c:	eb 0c                	jmp    cbaa <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    cb9e:	b8 1f 00 00 00       	mov    $0x1f,%eax
    cba3:	eb 05                	jmp    cbaa <lodepng_convert_rgb+0x29f>
  }

  return 0;
    cba5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    cbaa:	c9                   	leave  
    cbab:	c3                   	ret    

0000cbac <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    cbac:	55                   	push   %ebp
    cbad:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    cbaf:	8b 45 08             	mov    0x8(%ebp),%eax
    cbb2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    cbb8:	8b 45 08             	mov    0x8(%ebp),%eax
    cbbb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    cbc2:	8b 45 08             	mov    0x8(%ebp),%eax
    cbc5:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    cbcb:	8b 45 08             	mov    0x8(%ebp),%eax
    cbce:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    cbd2:	8b 45 08             	mov    0x8(%ebp),%eax
    cbd5:	66 89 50 0a          	mov    %dx,0xa(%eax)
    cbd9:	8b 45 08             	mov    0x8(%ebp),%eax
    cbdc:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cbe0:	8b 45 08             	mov    0x8(%ebp),%eax
    cbe3:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    cbe7:	8b 45 08             	mov    0x8(%ebp),%eax
    cbea:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    cbf1:	8b 45 08             	mov    0x8(%ebp),%eax
    cbf4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    cbfb:	8b 45 08             	mov    0x8(%ebp),%eax
    cbfe:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    cc05:	00 00 00 
  stats->numpixels = 0;
    cc08:	8b 45 08             	mov    0x8(%ebp),%eax
    cc0b:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    cc12:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    cc15:	8b 45 08             	mov    0x8(%ebp),%eax
    cc18:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    cc1f:	00 00 00 
  stats->allow_greyscale = 1;
    cc22:	8b 45 08             	mov    0x8(%ebp),%eax
    cc25:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    cc2c:	00 00 00 
}
    cc2f:	90                   	nop
    cc30:	5d                   	pop    %ebp
    cc31:	c3                   	ret    

0000cc32 <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    cc32:	55                   	push   %ebp
    cc33:	89 e5                	mov    %esp,%ebp
    cc35:	53                   	push   %ebx
    cc36:	83 ec 04             	sub    $0x4,%esp
    cc39:	8b 45 08             	mov    0x8(%ebp),%eax
    cc3c:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    cc3f:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    cc43:	74 06                	je     cc4b <getValueRequiredBits+0x19>
    cc45:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    cc49:	75 07                	jne    cc52 <getValueRequiredBits+0x20>
    cc4b:	b8 01 00 00 00       	mov    $0x1,%eax
    cc50:	eb 6b                	jmp    ccbd <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    cc52:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    cc56:	0f b6 d9             	movzbl %cl,%ebx
    cc59:	89 da                	mov    %ebx,%edx
    cc5b:	89 d0                	mov    %edx,%eax
    cc5d:	c1 e0 04             	shl    $0x4,%eax
    cc60:	89 c2                	mov    %eax,%edx
    cc62:	89 d0                	mov    %edx,%eax
    cc64:	c1 e0 04             	shl    $0x4,%eax
    cc67:	29 d0                	sub    %edx,%eax
    cc69:	01 d8                	add    %ebx,%eax
    cc6b:	66 c1 e8 08          	shr    $0x8,%ax
    cc6f:	c0 e8 04             	shr    $0x4,%al
    cc72:	89 c2                	mov    %eax,%edx
    cc74:	c1 e2 04             	shl    $0x4,%edx
    cc77:	01 c2                	add    %eax,%edx
    cc79:	89 c8                	mov    %ecx,%eax
    cc7b:	29 d0                	sub    %edx,%eax
    cc7d:	84 c0                	test   %al,%al
    cc7f:	75 37                	jne    ccb8 <getValueRequiredBits+0x86>
    cc81:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    cc85:	0f b6 d1             	movzbl %cl,%edx
    cc88:	89 d0                	mov    %edx,%eax
    cc8a:	01 c0                	add    %eax,%eax
    cc8c:	01 d0                	add    %edx,%eax
    cc8e:	c1 e0 06             	shl    $0x6,%eax
    cc91:	01 d0                	add    %edx,%eax
    cc93:	66 c1 e8 08          	shr    $0x8,%ax
    cc97:	c0 e8 06             	shr    $0x6,%al
    cc9a:	ba 55 00 00 00       	mov    $0x55,%edx
    cc9f:	0f af c2             	imul   %edx,%eax
    cca2:	29 c1                	sub    %eax,%ecx
    cca4:	89 c8                	mov    %ecx,%eax
    cca6:	84 c0                	test   %al,%al
    cca8:	75 07                	jne    ccb1 <getValueRequiredBits+0x7f>
    ccaa:	b8 02 00 00 00       	mov    $0x2,%eax
    ccaf:	eb 0c                	jmp    ccbd <getValueRequiredBits+0x8b>
    ccb1:	b8 04 00 00 00       	mov    $0x4,%eax
    ccb6:	eb 05                	jmp    ccbd <getValueRequiredBits+0x8b>
  return 8;
    ccb8:	b8 08 00 00 00       	mov    $0x8,%eax
}
    ccbd:	83 c4 04             	add    $0x4,%esp
    ccc0:	5b                   	pop    %ebx
    ccc1:	5d                   	pop    %ebp
    ccc2:	c3                   	ret    

0000ccc3 <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    ccc3:	55                   	push   %ebp
    ccc4:	89 e5                	mov    %esp,%ebp
    ccc6:	56                   	push   %esi
    ccc7:	53                   	push   %ebx
    ccc8:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    ccce:	8b 55 10             	mov    0x10(%ebp),%edx
    ccd1:	8b 45 14             	mov    0x14(%ebp),%eax
    ccd4:	0f af c2             	imul   %edx,%eax
    ccd7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    ccda:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    cce1:	ff 75 18             	pushl  0x18(%ebp)
    cce4:	e8 0b cd ff ff       	call   99f4 <lodepng_is_greyscale_type>
    cce9:	83 c4 04             	add    $0x4,%esp
    ccec:	85 c0                	test   %eax,%eax
    ccee:	0f 95 c0             	setne  %al
    ccf1:	0f b6 c0             	movzbl %al,%eax
    ccf4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    ccf7:	ff 75 18             	pushl  0x18(%ebp)
    ccfa:	e8 85 cd ff ff       	call   9a84 <lodepng_can_have_alpha>
    ccff:	83 c4 04             	add    $0x4,%esp
    cd02:	85 c0                	test   %eax,%eax
    cd04:	0f 94 c0             	sete   %al
    cd07:	0f b6 c0             	movzbl %al,%eax
    cd0a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    cd0d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    cd14:	ff 75 18             	pushl  0x18(%ebp)
    cd17:	e8 ab cc ff ff       	call   99c7 <lodepng_get_bpp>
    cd1c:	83 c4 04             	add    $0x4,%esp
    cd1f:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    cd22:	8b 45 08             	mov    0x8(%ebp),%eax
    cd25:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cd2b:	83 f8 01             	cmp    $0x1,%eax
    cd2e:	75 0d                	jne    cd3d <lodepng_compute_color_stats+0x7a>
    cd30:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    cd34:	75 07                	jne    cd3d <lodepng_compute_color_stats+0x7a>
    cd36:	b8 01 00 00 00       	mov    $0x1,%eax
    cd3b:	eb 05                	jmp    cd42 <lodepng_compute_color_stats+0x7f>
    cd3d:	b8 00 00 00 00       	mov    $0x0,%eax
    cd42:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    cd45:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    cd4c:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    cd53:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    cd57:	77 26                	ja     cd7f <lodepng_compute_color_stats+0xbc>
    cd59:	8b 45 08             	mov    0x8(%ebp),%eax
    cd5c:	8b 50 14             	mov    0x14(%eax),%edx
    cd5f:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cd62:	bb 01 00 00 00       	mov    $0x1,%ebx
    cd67:	89 c1                	mov    %eax,%ecx
    cd69:	d3 e3                	shl    %cl,%ebx
    cd6b:	89 d8                	mov    %ebx,%eax
    cd6d:	01 d0                	add    %edx,%eax
    cd6f:	ba 01 01 00 00       	mov    $0x101,%edx
    cd74:	3d 01 01 00 00       	cmp    $0x101,%eax
    cd79:	0f 47 c2             	cmova  %edx,%eax
    cd7c:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    cd7f:	8b 45 08             	mov    0x8(%ebp),%eax
    cd82:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    cd88:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cd8b:	01 c2                	add    %eax,%edx
    cd8d:	8b 45 08             	mov    0x8(%ebp),%eax
    cd90:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    cd96:	8b 45 08             	mov    0x8(%ebp),%eax
    cd99:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    cd9f:	85 c0                	test   %eax,%eax
    cda1:	75 07                	jne    cdaa <lodepng_compute_color_stats+0xe7>
    cda3:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    cdaa:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cdb0:	50                   	push   %eax
    cdb1:	e8 81 da ff ff       	call   a837 <color_tree_init>
    cdb6:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    cdb9:	8b 45 08             	mov    0x8(%ebp),%eax
    cdbc:	8b 40 10             	mov    0x10(%eax),%eax
    cdbf:	85 c0                	test   %eax,%eax
    cdc1:	74 07                	je     cdca <lodepng_compute_color_stats+0x107>
    cdc3:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    cdca:	8b 45 08             	mov    0x8(%ebp),%eax
    cdcd:	8b 00                	mov    (%eax),%eax
    cdcf:	85 c0                	test   %eax,%eax
    cdd1:	74 07                	je     cdda <lodepng_compute_color_stats+0x117>
    cdd3:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    cdda:	8b 45 08             	mov    0x8(%ebp),%eax
    cddd:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cde3:	83 f8 10             	cmp    $0x10,%eax
    cde6:	75 07                	jne    cdef <lodepng_compute_color_stats+0x12c>
    cde8:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    cdef:	8b 45 08             	mov    0x8(%ebp),%eax
    cdf2:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cdf8:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    cdfb:	72 07                	jb     ce04 <lodepng_compute_color_stats+0x141>
    cdfd:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    ce04:	8b 45 08             	mov    0x8(%ebp),%eax
    ce07:	8b 40 14             	mov    0x14(%eax),%eax
    ce0a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ce0d:	72 07                	jb     ce16 <lodepng_compute_color_stats+0x153>
    ce0f:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    ce16:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ce1a:	0f 85 82 00 00 00    	jne    cea2 <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    ce20:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ce27:	eb 6c                	jmp    ce95 <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    ce29:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ce2c:	c1 e0 02             	shl    $0x2,%eax
    ce2f:	8d 50 10             	lea    0x10(%eax),%edx
    ce32:	8b 45 08             	mov    0x8(%ebp),%eax
    ce35:	01 d0                	add    %edx,%eax
    ce37:	83 c0 08             	add    $0x8,%eax
    ce3a:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    ce3d:	8b 75 f4             	mov    -0xc(%ebp),%esi
    ce40:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce43:	83 c0 03             	add    $0x3,%eax
    ce46:	0f b6 00             	movzbl (%eax),%eax
    ce49:	0f b6 d8             	movzbl %al,%ebx
    ce4c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce4f:	83 c0 02             	add    $0x2,%eax
    ce52:	0f b6 00             	movzbl (%eax),%eax
    ce55:	0f b6 c8             	movzbl %al,%ecx
    ce58:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce5b:	83 c0 01             	add    $0x1,%eax
    ce5e:	0f b6 00             	movzbl (%eax),%eax
    ce61:	0f b6 d0             	movzbl %al,%edx
    ce64:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce67:	0f b6 00             	movzbl (%eax),%eax
    ce6a:	0f b6 c0             	movzbl %al,%eax
    ce6d:	83 ec 08             	sub    $0x8,%esp
    ce70:	56                   	push   %esi
    ce71:	53                   	push   %ebx
    ce72:	51                   	push   %ecx
    ce73:	52                   	push   %edx
    ce74:	50                   	push   %eax
    ce75:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    ce7b:	50                   	push   %eax
    ce7c:	e8 39 db ff ff       	call   a9ba <color_tree_add>
    ce81:	83 c4 20             	add    $0x20,%esp
    ce84:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    ce87:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ce8b:	0f 85 22 09 00 00    	jne    d7b3 <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    ce91:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ce95:	8b 45 08             	mov    0x8(%ebp),%eax
    ce98:	8b 50 14             	mov    0x14(%eax),%edx
    ce9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ce9e:	39 c2                	cmp    %eax,%edx
    cea0:	77 87                	ja     ce29 <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    cea2:	8b 45 18             	mov    0x18(%ebp),%eax
    cea5:	8b 40 04             	mov    0x4(%eax),%eax
    cea8:	83 f8 10             	cmp    $0x10,%eax
    ceab:	0f 85 1e 01 00 00    	jne    cfcf <lodepng_compute_color_stats+0x30c>
    ceb1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    ceb5:	0f 85 14 01 00 00    	jne    cfcf <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    cebb:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    cec2:	00 00 
    cec4:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    cecb:	00 00 
    cecd:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    ced4:	00 00 
    ced6:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    cedd:	00 00 
    for(i = 0; i != numpixels; ++i) {
    cedf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cee6:	e9 d8 00 00 00       	jmp    cfc3 <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    ceeb:	83 ec 04             	sub    $0x4,%esp
    ceee:	ff 75 18             	pushl  0x18(%ebp)
    cef1:	ff 75 f4             	pushl  -0xc(%ebp)
    cef4:	ff 75 0c             	pushl  0xc(%ebp)
    cef7:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    cefd:	50                   	push   %eax
    cefe:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    cf04:	50                   	push   %eax
    cf05:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    cf0b:	50                   	push   %eax
    cf0c:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    cf12:	50                   	push   %eax
    cf13:	e8 a8 f2 ff ff       	call   c1c0 <getPixelColorRGBA16>
    cf18:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    cf1b:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    cf22:	66 c1 e8 08          	shr    $0x8,%ax
    cf26:	89 c2                	mov    %eax,%edx
    cf28:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    cf2f:	31 d0                	xor    %edx,%eax
    cf31:	0f b7 c0             	movzwl %ax,%eax
    cf34:	0f b6 c0             	movzbl %al,%eax
    cf37:	85 c0                	test   %eax,%eax
    cf39:	75 60                	jne    cf9b <lodepng_compute_color_stats+0x2d8>
    cf3b:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    cf42:	66 c1 e8 08          	shr    $0x8,%ax
    cf46:	89 c2                	mov    %eax,%edx
    cf48:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    cf4f:	31 d0                	xor    %edx,%eax
    cf51:	0f b7 c0             	movzwl %ax,%eax
    cf54:	0f b6 c0             	movzbl %al,%eax
    cf57:	85 c0                	test   %eax,%eax
    cf59:	75 40                	jne    cf9b <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    cf5b:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    cf62:	66 c1 e8 08          	shr    $0x8,%ax
    cf66:	89 c2                	mov    %eax,%edx
    cf68:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    cf6f:	31 d0                	xor    %edx,%eax
    cf71:	0f b7 c0             	movzwl %ax,%eax
    cf74:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    cf77:	85 c0                	test   %eax,%eax
    cf79:	75 20                	jne    cf9b <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    cf7b:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    cf82:	66 c1 e8 08          	shr    $0x8,%ax
    cf86:	89 c2                	mov    %eax,%edx
    cf88:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    cf8f:	31 d0                	xor    %edx,%eax
    cf91:	0f b7 c0             	movzwl %ax,%eax
    cf94:	0f b6 c0             	movzbl %al,%eax
    cf97:	85 c0                	test   %eax,%eax
    cf99:	74 24                	je     cfbf <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    cf9b:	8b 45 08             	mov    0x8(%ebp),%eax
    cf9e:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    cfa5:	00 00 00 
        sixteen = 1;
    cfa8:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    cfaf:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    cfb6:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    cfbd:	eb 10                	jmp    cfcf <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    cfbf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cfc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cfc6:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cfc9:	0f 85 1c ff ff ff    	jne    ceeb <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    cfcf:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    cfd3:	0f 84 bd 02 00 00    	je     d296 <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    cfd9:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    cfe0:	00 00 
    cfe2:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    cfe9:	00 00 
    cfeb:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    cff2:	00 00 
    cff4:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    cffb:	00 00 

    for(i = 0; i != numpixels; ++i) {
    cffd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d004:	e9 b1 01 00 00       	jmp    d1ba <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    d009:	83 ec 04             	sub    $0x4,%esp
    d00c:	ff 75 18             	pushl  0x18(%ebp)
    d00f:	ff 75 f4             	pushl  -0xc(%ebp)
    d012:	ff 75 0c             	pushl  0xc(%ebp)
    d015:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    d01b:	50                   	push   %eax
    d01c:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    d022:	50                   	push   %eax
    d023:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    d029:	50                   	push   %eax
    d02a:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    d030:	50                   	push   %eax
    d031:	e8 8a f1 ff ff       	call   c1c0 <getPixelColorRGBA16>
    d036:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    d039:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d03d:	75 36                	jne    d075 <lodepng_compute_color_stats+0x3b2>
    d03f:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    d046:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    d04d:	66 39 c2             	cmp    %ax,%dx
    d050:	75 13                	jne    d065 <lodepng_compute_color_stats+0x3a2>
    d052:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    d059:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    d060:	66 39 c2             	cmp    %ax,%dx
    d063:	74 10                	je     d075 <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    d065:	8b 45 08             	mov    0x8(%ebp),%eax
    d068:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    d06e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    d075:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d079:	0f 85 1f 01 00 00    	jne    d19e <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    d07f:	8b 45 08             	mov    0x8(%ebp),%eax
    d082:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    d086:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    d08d:	66 39 c2             	cmp    %ax,%dx
    d090:	75 2d                	jne    d0bf <lodepng_compute_color_stats+0x3fc>
    d092:	8b 45 08             	mov    0x8(%ebp),%eax
    d095:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    d099:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    d0a0:	66 39 c2             	cmp    %ax,%dx
    d0a3:	75 1a                	jne    d0bf <lodepng_compute_color_stats+0x3fc>
    d0a5:	8b 45 08             	mov    0x8(%ebp),%eax
    d0a8:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    d0ac:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    d0b3:	66 39 c2             	cmp    %ax,%dx
    d0b6:	75 07                	jne    d0bf <lodepng_compute_color_stats+0x3fc>
    d0b8:	b8 01 00 00 00       	mov    $0x1,%eax
    d0bd:	eb 05                	jmp    d0c4 <lodepng_compute_color_stats+0x401>
    d0bf:	b8 00 00 00 00       	mov    $0x0,%eax
    d0c4:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    d0c7:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    d0ce:	66 83 f8 ff          	cmp    $0xffff,%ax
    d0d2:	74 3c                	je     d110 <lodepng_compute_color_stats+0x44d>
    d0d4:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    d0db:	66 85 c0             	test   %ax,%ax
    d0de:	75 10                	jne    d0f0 <lodepng_compute_color_stats+0x42d>
    d0e0:	8b 45 08             	mov    0x8(%ebp),%eax
    d0e3:	8b 40 04             	mov    0x4(%eax),%eax
    d0e6:	85 c0                	test   %eax,%eax
    d0e8:	74 26                	je     d110 <lodepng_compute_color_stats+0x44d>
    d0ea:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    d0ee:	75 20                	jne    d110 <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    d0f0:	8b 45 08             	mov    0x8(%ebp),%eax
    d0f3:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    d0fa:	8b 45 08             	mov    0x8(%ebp),%eax
    d0fd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    d104:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    d10b:	e9 8e 00 00 00       	jmp    d19e <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    d110:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    d117:	66 85 c0             	test   %ax,%ax
    d11a:	75 4a                	jne    d166 <lodepng_compute_color_stats+0x4a3>
    d11c:	8b 45 08             	mov    0x8(%ebp),%eax
    d11f:	8b 40 10             	mov    0x10(%eax),%eax
    d122:	85 c0                	test   %eax,%eax
    d124:	75 40                	jne    d166 <lodepng_compute_color_stats+0x4a3>
    d126:	8b 45 08             	mov    0x8(%ebp),%eax
    d129:	8b 40 04             	mov    0x4(%eax),%eax
    d12c:	85 c0                	test   %eax,%eax
    d12e:	75 36                	jne    d166 <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    d130:	8b 45 08             	mov    0x8(%ebp),%eax
    d133:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    d13a:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    d141:	8b 45 08             	mov    0x8(%ebp),%eax
    d144:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    d148:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    d14f:	8b 45 08             	mov    0x8(%ebp),%eax
    d152:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    d156:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    d15d:	8b 45 08             	mov    0x8(%ebp),%eax
    d160:	66 89 50 0c          	mov    %dx,0xc(%eax)
    d164:	eb 38                	jmp    d19e <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    d166:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    d16d:	66 83 f8 ff          	cmp    $0xffff,%ax
    d171:	75 2b                	jne    d19e <lodepng_compute_color_stats+0x4db>
    d173:	8b 45 08             	mov    0x8(%ebp),%eax
    d176:	8b 40 04             	mov    0x4(%eax),%eax
    d179:	85 c0                	test   %eax,%eax
    d17b:	74 21                	je     d19e <lodepng_compute_color_stats+0x4db>
    d17d:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    d181:	74 1b                	je     d19e <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    d183:	8b 45 08             	mov    0x8(%ebp),%eax
    d186:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    d18d:	8b 45 08             	mov    0x8(%ebp),%eax
    d190:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    d197:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    d19e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d1a2:	74 12                	je     d1b6 <lodepng_compute_color_stats+0x4f3>
    d1a4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d1a8:	74 0c                	je     d1b6 <lodepng_compute_color_stats+0x4f3>
    d1aa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d1ae:	74 06                	je     d1b6 <lodepng_compute_color_stats+0x4f3>
    d1b0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d1b4:	75 12                	jne    d1c8 <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    d1b6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d1ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1bd:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    d1c0:	0f 85 43 fe ff ff    	jne    d009 <lodepng_compute_color_stats+0x346>
    d1c6:	eb 01                	jmp    d1c9 <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    d1c8:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    d1c9:	8b 45 08             	mov    0x8(%ebp),%eax
    d1cc:	8b 40 04             	mov    0x4(%eax),%eax
    d1cf:	85 c0                	test   %eax,%eax
    d1d1:	0f 84 e0 05 00 00    	je     d7b7 <lodepng_compute_color_stats+0xaf4>
    d1d7:	8b 45 08             	mov    0x8(%ebp),%eax
    d1da:	8b 40 10             	mov    0x10(%eax),%eax
    d1dd:	85 c0                	test   %eax,%eax
    d1df:	0f 85 d2 05 00 00    	jne    d7b7 <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    d1e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d1ec:	e9 94 00 00 00       	jmp    d285 <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    d1f1:	83 ec 04             	sub    $0x4,%esp
    d1f4:	ff 75 18             	pushl  0x18(%ebp)
    d1f7:	ff 75 f4             	pushl  -0xc(%ebp)
    d1fa:	ff 75 0c             	pushl  0xc(%ebp)
    d1fd:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    d203:	50                   	push   %eax
    d204:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    d20a:	50                   	push   %eax
    d20b:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    d211:	50                   	push   %eax
    d212:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    d218:	50                   	push   %eax
    d219:	e8 a2 ef ff ff       	call   c1c0 <getPixelColorRGBA16>
    d21e:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    d221:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    d228:	66 85 c0             	test   %ax,%ax
    d22b:	74 54                	je     d281 <lodepng_compute_color_stats+0x5be>
    d22d:	8b 45 08             	mov    0x8(%ebp),%eax
    d230:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    d234:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    d23b:	66 39 c2             	cmp    %ax,%dx
    d23e:	75 41                	jne    d281 <lodepng_compute_color_stats+0x5be>
    d240:	8b 45 08             	mov    0x8(%ebp),%eax
    d243:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    d247:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    d24e:	66 39 c2             	cmp    %ax,%dx
    d251:	75 2e                	jne    d281 <lodepng_compute_color_stats+0x5be>
    d253:	8b 45 08             	mov    0x8(%ebp),%eax
    d256:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    d25a:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    d261:	66 39 c2             	cmp    %ax,%dx
    d264:	75 1b                	jne    d281 <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    d266:	8b 45 08             	mov    0x8(%ebp),%eax
    d269:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    d270:	8b 45 08             	mov    0x8(%ebp),%eax
    d273:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    d27a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    d281:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d285:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d288:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    d28b:	0f 85 60 ff ff ff    	jne    d1f1 <lodepng_compute_color_stats+0x52e>
    d291:	e9 21 05 00 00       	jmp    d7b7 <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    d296:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    d29d:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    d2a4:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    d2ab:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    d2b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d2b9:	e9 ab 03 00 00       	jmp    d669 <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    d2be:	83 ec 04             	sub    $0x4,%esp
    d2c1:	ff 75 18             	pushl  0x18(%ebp)
    d2c4:	ff 75 f4             	pushl  -0xc(%ebp)
    d2c7:	ff 75 0c             	pushl  0xc(%ebp)
    d2ca:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    d2d0:	50                   	push   %eax
    d2d1:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    d2d7:	50                   	push   %eax
    d2d8:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    d2de:	50                   	push   %eax
    d2df:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    d2e5:	50                   	push   %eax
    d2e6:	e8 1e de ff ff       	call   b109 <getPixelColorRGBA8>
    d2eb:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    d2ee:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d2f2:	75 41                	jne    d335 <lodepng_compute_color_stats+0x672>
    d2f4:	8b 45 08             	mov    0x8(%ebp),%eax
    d2f7:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d2fd:	83 f8 07             	cmp    $0x7,%eax
    d300:	77 33                	ja     d335 <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    d302:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d309:	0f b6 c0             	movzbl %al,%eax
    d30c:	83 ec 0c             	sub    $0xc,%esp
    d30f:	50                   	push   %eax
    d310:	e8 1d f9 ff ff       	call   cc32 <getValueRequiredBits>
    d315:	83 c4 10             	add    $0x10,%esp
    d318:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    d31b:	8b 45 08             	mov    0x8(%ebp),%eax
    d31e:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d324:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    d327:	73 0c                	jae    d335 <lodepng_compute_color_stats+0x672>
    d329:	8b 45 08             	mov    0x8(%ebp),%eax
    d32c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    d32f:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    d335:	8b 45 08             	mov    0x8(%ebp),%eax
    d338:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d33e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    d341:	0f 93 c0             	setae  %al
    d344:	0f b6 c0             	movzbl %al,%eax
    d347:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    d34a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d34e:	75 4f                	jne    d39f <lodepng_compute_color_stats+0x6dc>
    d350:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    d357:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d35e:	38 c2                	cmp    %al,%dl
    d360:	75 12                	jne    d374 <lodepng_compute_color_stats+0x6b1>
    d362:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    d369:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d370:	38 c2                	cmp    %al,%dl
    d372:	74 2b                	je     d39f <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    d374:	8b 45 08             	mov    0x8(%ebp),%eax
    d377:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    d37d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    d384:	8b 45 08             	mov    0x8(%ebp),%eax
    d387:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d38d:	83 f8 07             	cmp    $0x7,%eax
    d390:	77 0d                	ja     d39f <lodepng_compute_color_stats+0x6dc>
    d392:	8b 45 08             	mov    0x8(%ebp),%eax
    d395:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    d39c:	00 00 00 
      }

      if(!alpha_done) {
    d39f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d3a3:	0f 85 65 01 00 00    	jne    d50e <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    d3a9:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d3b0:	0f b6 d0             	movzbl %al,%edx
    d3b3:	8b 45 08             	mov    0x8(%ebp),%eax
    d3b6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d3ba:	66 39 c2             	cmp    %ax,%dx
    d3bd:	75 33                	jne    d3f2 <lodepng_compute_color_stats+0x72f>
    d3bf:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d3c6:	0f b6 d0             	movzbl %al,%edx
    d3c9:	8b 45 08             	mov    0x8(%ebp),%eax
    d3cc:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d3d0:	66 39 c2             	cmp    %ax,%dx
    d3d3:	75 1d                	jne    d3f2 <lodepng_compute_color_stats+0x72f>
    d3d5:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d3dc:	0f b6 d0             	movzbl %al,%edx
    d3df:	8b 45 08             	mov    0x8(%ebp),%eax
    d3e2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d3e6:	66 39 c2             	cmp    %ax,%dx
    d3e9:	75 07                	jne    d3f2 <lodepng_compute_color_stats+0x72f>
    d3eb:	b8 01 00 00 00       	mov    $0x1,%eax
    d3f0:	eb 05                	jmp    d3f7 <lodepng_compute_color_stats+0x734>
    d3f2:	b8 00 00 00 00       	mov    $0x0,%eax
    d3f7:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    d3fa:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d401:	3c ff                	cmp    $0xff,%al
    d403:	74 5a                	je     d45f <lodepng_compute_color_stats+0x79c>
    d405:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d40c:	84 c0                	test   %al,%al
    d40e:	75 10                	jne    d420 <lodepng_compute_color_stats+0x75d>
    d410:	8b 45 08             	mov    0x8(%ebp),%eax
    d413:	8b 40 04             	mov    0x4(%eax),%eax
    d416:	85 c0                	test   %eax,%eax
    d418:	74 45                	je     d45f <lodepng_compute_color_stats+0x79c>
    d41a:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    d41e:	75 3f                	jne    d45f <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    d420:	8b 45 08             	mov    0x8(%ebp),%eax
    d423:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    d42a:	8b 45 08             	mov    0x8(%ebp),%eax
    d42d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    d434:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    d43b:	8b 45 08             	mov    0x8(%ebp),%eax
    d43e:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d444:	83 f8 07             	cmp    $0x7,%eax
    d447:	0f 87 c1 00 00 00    	ja     d50e <lodepng_compute_color_stats+0x84b>
    d44d:	8b 45 08             	mov    0x8(%ebp),%eax
    d450:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    d457:	00 00 00 
    d45a:	e9 af 00 00 00       	jmp    d50e <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    d45f:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d466:	84 c0                	test   %al,%al
    d468:	75 53                	jne    d4bd <lodepng_compute_color_stats+0x7fa>
    d46a:	8b 45 08             	mov    0x8(%ebp),%eax
    d46d:	8b 40 10             	mov    0x10(%eax),%eax
    d470:	85 c0                	test   %eax,%eax
    d472:	75 49                	jne    d4bd <lodepng_compute_color_stats+0x7fa>
    d474:	8b 45 08             	mov    0x8(%ebp),%eax
    d477:	8b 40 04             	mov    0x4(%eax),%eax
    d47a:	85 c0                	test   %eax,%eax
    d47c:	75 3f                	jne    d4bd <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    d47e:	8b 45 08             	mov    0x8(%ebp),%eax
    d481:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    d488:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d48f:	0f b6 d0             	movzbl %al,%edx
    d492:	8b 45 08             	mov    0x8(%ebp),%eax
    d495:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    d499:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d4a0:	0f b6 d0             	movzbl %al,%edx
    d4a3:	8b 45 08             	mov    0x8(%ebp),%eax
    d4a6:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    d4aa:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d4b1:	0f b6 d0             	movzbl %al,%edx
    d4b4:	8b 45 08             	mov    0x8(%ebp),%eax
    d4b7:	66 89 50 0c          	mov    %dx,0xc(%eax)
    d4bb:	eb 51                	jmp    d50e <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    d4bd:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d4c4:	3c ff                	cmp    $0xff,%al
    d4c6:	75 46                	jne    d50e <lodepng_compute_color_stats+0x84b>
    d4c8:	8b 45 08             	mov    0x8(%ebp),%eax
    d4cb:	8b 40 04             	mov    0x4(%eax),%eax
    d4ce:	85 c0                	test   %eax,%eax
    d4d0:	74 3c                	je     d50e <lodepng_compute_color_stats+0x84b>
    d4d2:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    d4d6:	74 36                	je     d50e <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    d4d8:	8b 45 08             	mov    0x8(%ebp),%eax
    d4db:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    d4e2:	8b 45 08             	mov    0x8(%ebp),%eax
    d4e5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    d4ec:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    d4f3:	8b 45 08             	mov    0x8(%ebp),%eax
    d4f6:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d4fc:	83 f8 07             	cmp    $0x7,%eax
    d4ff:	77 0d                	ja     d50e <lodepng_compute_color_stats+0x84b>
    d501:	8b 45 08             	mov    0x8(%ebp),%eax
    d504:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    d50b:	00 00 00 
        }
      }

      if(!numcolors_done) {
    d50e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d512:	0f 85 35 01 00 00    	jne    d64d <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    d518:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d51f:	0f b6 d8             	movzbl %al,%ebx
    d522:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d529:	0f b6 c8             	movzbl %al,%ecx
    d52c:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d533:	0f b6 d0             	movzbl %al,%edx
    d536:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d53d:	0f b6 c0             	movzbl %al,%eax
    d540:	83 ec 0c             	sub    $0xc,%esp
    d543:	53                   	push   %ebx
    d544:	51                   	push   %ecx
    d545:	52                   	push   %edx
    d546:	50                   	push   %eax
    d547:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    d54d:	50                   	push   %eax
    d54e:	e8 1c d4 ff ff       	call   a96f <color_tree_has>
    d553:	83 c4 20             	add    $0x20,%esp
    d556:	85 c0                	test   %eax,%eax
    d558:	0f 85 ef 00 00 00    	jne    d64d <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    d55e:	8b 45 08             	mov    0x8(%ebp),%eax
    d561:	8b 70 14             	mov    0x14(%eax),%esi
    d564:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d56b:	0f b6 d8             	movzbl %al,%ebx
    d56e:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d575:	0f b6 c8             	movzbl %al,%ecx
    d578:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d57f:	0f b6 d0             	movzbl %al,%edx
    d582:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d589:	0f b6 c0             	movzbl %al,%eax
    d58c:	83 ec 08             	sub    $0x8,%esp
    d58f:	56                   	push   %esi
    d590:	53                   	push   %ebx
    d591:	51                   	push   %ecx
    d592:	52                   	push   %edx
    d593:	50                   	push   %eax
    d594:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    d59a:	50                   	push   %eax
    d59b:	e8 1a d4 ff ff       	call   a9ba <color_tree_add>
    d5a0:	83 c4 20             	add    $0x20,%esp
    d5a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    d5a6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d5aa:	0f 85 06 02 00 00    	jne    d7b6 <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    d5b0:	8b 45 08             	mov    0x8(%ebp),%eax
    d5b3:	8b 40 14             	mov    0x14(%eax),%eax
    d5b6:	3d ff 00 00 00       	cmp    $0xff,%eax
    d5bb:	77 6f                	ja     d62c <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    d5bd:	8b 45 08             	mov    0x8(%ebp),%eax
    d5c0:	83 c0 18             	add    $0x18,%eax
    d5c3:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    d5c6:	8b 45 08             	mov    0x8(%ebp),%eax
    d5c9:	8b 40 14             	mov    0x14(%eax),%eax
    d5cc:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    d5cf:	8b 45 b8             	mov    -0x48(%ebp),%eax
    d5d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d5d9:	8b 45 bc             	mov    -0x44(%ebp),%eax
    d5dc:	01 c2                	add    %eax,%edx
    d5de:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d5e5:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    d5e7:	8b 45 b8             	mov    -0x48(%ebp),%eax
    d5ea:	c1 e0 02             	shl    $0x2,%eax
    d5ed:	8d 50 01             	lea    0x1(%eax),%edx
    d5f0:	8b 45 bc             	mov    -0x44(%ebp),%eax
    d5f3:	01 c2                	add    %eax,%edx
    d5f5:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d5fc:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    d5fe:	8b 45 b8             	mov    -0x48(%ebp),%eax
    d601:	c1 e0 02             	shl    $0x2,%eax
    d604:	8d 50 02             	lea    0x2(%eax),%edx
    d607:	8b 45 bc             	mov    -0x44(%ebp),%eax
    d60a:	01 c2                	add    %eax,%edx
    d60c:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d613:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    d615:	8b 45 b8             	mov    -0x48(%ebp),%eax
    d618:	c1 e0 02             	shl    $0x2,%eax
    d61b:	8d 50 03             	lea    0x3(%eax),%edx
    d61e:	8b 45 bc             	mov    -0x44(%ebp),%eax
    d621:	01 c2                	add    %eax,%edx
    d623:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d62a:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    d62c:	8b 45 08             	mov    0x8(%ebp),%eax
    d62f:	8b 40 14             	mov    0x14(%eax),%eax
    d632:	8d 50 01             	lea    0x1(%eax),%edx
    d635:	8b 45 08             	mov    0x8(%ebp),%eax
    d638:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    d63b:	8b 45 08             	mov    0x8(%ebp),%eax
    d63e:	8b 40 14             	mov    0x14(%eax),%eax
    d641:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    d644:	0f 93 c0             	setae  %al
    d647:	0f b6 c0             	movzbl %al,%eax
    d64a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    d64d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d651:	74 12                	je     d665 <lodepng_compute_color_stats+0x9a2>
    d653:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d657:	74 0c                	je     d665 <lodepng_compute_color_stats+0x9a2>
    d659:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d65d:	74 06                	je     d665 <lodepng_compute_color_stats+0x9a2>
    d65f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d663:	75 12                	jne    d677 <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    d665:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d669:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d66c:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    d66f:	0f 85 49 fc ff ff    	jne    d2be <lodepng_compute_color_stats+0x5fb>
    d675:	eb 01                	jmp    d678 <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    d677:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    d678:	8b 45 08             	mov    0x8(%ebp),%eax
    d67b:	8b 40 04             	mov    0x4(%eax),%eax
    d67e:	85 c0                	test   %eax,%eax
    d680:	0f 84 dd 00 00 00    	je     d763 <lodepng_compute_color_stats+0xaa0>
    d686:	8b 45 08             	mov    0x8(%ebp),%eax
    d689:	8b 40 10             	mov    0x10(%eax),%eax
    d68c:	85 c0                	test   %eax,%eax
    d68e:	0f 85 cf 00 00 00    	jne    d763 <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    d694:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d69b:	e9 b7 00 00 00       	jmp    d757 <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    d6a0:	83 ec 04             	sub    $0x4,%esp
    d6a3:	ff 75 18             	pushl  0x18(%ebp)
    d6a6:	ff 75 f4             	pushl  -0xc(%ebp)
    d6a9:	ff 75 0c             	pushl  0xc(%ebp)
    d6ac:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    d6b2:	50                   	push   %eax
    d6b3:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    d6b9:	50                   	push   %eax
    d6ba:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    d6c0:	50                   	push   %eax
    d6c1:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    d6c7:	50                   	push   %eax
    d6c8:	e8 3c da ff ff       	call   b109 <getPixelColorRGBA8>
    d6cd:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    d6d0:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    d6d7:	84 c0                	test   %al,%al
    d6d9:	74 78                	je     d753 <lodepng_compute_color_stats+0xa90>
    d6db:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    d6e2:	0f b6 d0             	movzbl %al,%edx
    d6e5:	8b 45 08             	mov    0x8(%ebp),%eax
    d6e8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d6ec:	66 39 c2             	cmp    %ax,%dx
    d6ef:	75 62                	jne    d753 <lodepng_compute_color_stats+0xa90>
    d6f1:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    d6f8:	0f b6 d0             	movzbl %al,%edx
    d6fb:	8b 45 08             	mov    0x8(%ebp),%eax
    d6fe:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d702:	66 39 c2             	cmp    %ax,%dx
    d705:	75 4c                	jne    d753 <lodepng_compute_color_stats+0xa90>
    d707:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    d70e:	0f b6 d0             	movzbl %al,%edx
    d711:	8b 45 08             	mov    0x8(%ebp),%eax
    d714:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d718:	66 39 c2             	cmp    %ax,%dx
    d71b:	75 36                	jne    d753 <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    d71d:	8b 45 08             	mov    0x8(%ebp),%eax
    d720:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    d727:	8b 45 08             	mov    0x8(%ebp),%eax
    d72a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    d731:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    d738:	8b 45 08             	mov    0x8(%ebp),%eax
    d73b:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d741:	83 f8 07             	cmp    $0x7,%eax
    d744:	77 0d                	ja     d753 <lodepng_compute_color_stats+0xa90>
    d746:	8b 45 08             	mov    0x8(%ebp),%eax
    d749:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    d750:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    d753:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d757:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d75a:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    d75d:	0f 85 3d ff ff ff    	jne    d6a0 <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    d763:	8b 45 08             	mov    0x8(%ebp),%eax
    d766:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    d76a:	8b 45 08             	mov    0x8(%ebp),%eax
    d76d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d771:	c1 e0 08             	shl    $0x8,%eax
    d774:	01 c2                	add    %eax,%edx
    d776:	8b 45 08             	mov    0x8(%ebp),%eax
    d779:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    d77d:	8b 45 08             	mov    0x8(%ebp),%eax
    d780:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    d784:	8b 45 08             	mov    0x8(%ebp),%eax
    d787:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d78b:	c1 e0 08             	shl    $0x8,%eax
    d78e:	01 c2                	add    %eax,%edx
    d790:	8b 45 08             	mov    0x8(%ebp),%eax
    d793:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    d797:	8b 45 08             	mov    0x8(%ebp),%eax
    d79a:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    d79e:	8b 45 08             	mov    0x8(%ebp),%eax
    d7a1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d7a5:	c1 e0 08             	shl    $0x8,%eax
    d7a8:	01 c2                	add    %eax,%edx
    d7aa:	8b 45 08             	mov    0x8(%ebp),%eax
    d7ad:	66 89 50 0c          	mov    %dx,0xc(%eax)
    d7b1:	eb 04                	jmp    d7b7 <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    d7b3:	90                   	nop
    d7b4:	eb 01                	jmp    d7b7 <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    d7b6:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    d7b7:	83 ec 0c             	sub    $0xc,%esp
    d7ba:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    d7c0:	50                   	push   %eax
    d7c1:	e8 91 d0 ff ff       	call   a857 <color_tree_cleanup>
    d7c6:	83 c4 10             	add    $0x10,%esp
  return error;
    d7c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    d7cc:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d7cf:	5b                   	pop    %ebx
    d7d0:	5e                   	pop    %esi
    d7d1:	5d                   	pop    %ebp
    d7d2:	c3                   	ret    

0000d7d3 <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    d7d3:	55                   	push   %ebp
    d7d4:	89 e5                	mov    %esp,%ebp
    d7d6:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    d7d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    d7e0:	8d 45 cc             	lea    -0x34(%ebp),%eax
    d7e3:	50                   	push   %eax
    d7e4:	e8 d1 bd ff ff       	call   95ba <lodepng_color_mode_init>
    d7e9:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    d7ec:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7ef:	c1 e8 08             	shr    $0x8,%eax
    d7f2:	88 45 ec             	mov    %al,-0x14(%ebp)
    d7f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7f8:	88 45 ed             	mov    %al,-0x13(%ebp)
    d7fb:	8b 45 10             	mov    0x10(%ebp),%eax
    d7fe:	c1 e8 08             	shr    $0x8,%eax
    d801:	88 45 ee             	mov    %al,-0x12(%ebp)
    d804:	8b 45 10             	mov    0x10(%ebp),%eax
    d807:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    d80a:	8b 45 14             	mov    0x14(%ebp),%eax
    d80d:	c1 e8 08             	shr    $0x8,%eax
    d810:	88 45 f0             	mov    %al,-0x10(%ebp)
    d813:	8b 45 14             	mov    0x14(%ebp),%eax
    d816:	88 45 f1             	mov    %al,-0xf(%ebp)
    d819:	8b 45 18             	mov    0x18(%ebp),%eax
    d81c:	c1 e8 08             	shr    $0x8,%eax
    d81f:	88 45 f2             	mov    %al,-0xe(%ebp)
    d822:	8b 45 18             	mov    0x18(%ebp),%eax
    d825:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    d828:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    d82f:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    d836:	83 ec 0c             	sub    $0xc,%esp
    d839:	8d 45 cc             	lea    -0x34(%ebp),%eax
    d83c:	50                   	push   %eax
    d83d:	6a 01                	push   $0x1
    d83f:	6a 01                	push   $0x1
    d841:	8d 45 ec             	lea    -0x14(%ebp),%eax
    d844:	50                   	push   %eax
    d845:	ff 75 08             	pushl  0x8(%ebp)
    d848:	e8 76 f4 ff ff       	call   ccc3 <lodepng_compute_color_stats>
    d84d:	83 c4 20             	add    $0x20,%esp
    d850:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    d853:	83 ec 0c             	sub    $0xc,%esp
    d856:	8d 45 cc             	lea    -0x34(%ebp),%eax
    d859:	50                   	push   %eax
    d85a:	e8 4e be ff ff       	call   96ad <lodepng_color_mode_cleanup>
    d85f:	83 c4 10             	add    $0x10,%esp
  return error;
    d862:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d865:	c9                   	leave  
    d866:	c3                   	ret    

0000d867 <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    d867:	55                   	push   %ebp
    d868:	89 e5                	mov    %esp,%ebp
    d86a:	56                   	push   %esi
    d86b:	53                   	push   %ebx
    d86c:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    d86f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    d876:	8b 45 10             	mov    0x10(%ebp),%eax
    d879:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    d87f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    d882:	8b 45 10             	mov    0x10(%ebp),%eax
    d885:	8b 40 10             	mov    0x10(%eax),%eax
    d888:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    d88b:	8b 45 10             	mov    0x10(%ebp),%eax
    d88e:	8b 40 04             	mov    0x4(%eax),%eax
    d891:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    d894:	8b 45 10             	mov    0x10(%ebp),%eax
    d897:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d89d:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    d8a0:	8b 45 08             	mov    0x8(%ebp),%eax
    d8a3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    d8aa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d8ae:	74 21                	je     d8d1 <auto_choose_color+0x6a>
    d8b0:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    d8b4:	7f 1b                	jg     d8d1 <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    d8b6:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    d8bd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    d8c4:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    d8c8:	77 07                	ja     d8d1 <auto_choose_color+0x6a>
    d8ca:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    d8d1:	8b 45 10             	mov    0x10(%ebp),%eax
    d8d4:	8b 00                	mov    (%eax),%eax
    d8d6:	85 c0                	test   %eax,%eax
    d8d8:	0f 94 c0             	sete   %al
    d8db:	0f b6 c0             	movzbl %al,%eax
    d8de:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    d8e1:	8b 45 10             	mov    0x10(%ebp),%eax
    d8e4:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    d8ea:	85 c0                	test   %eax,%eax
    d8ec:	75 07                	jne    d8f5 <auto_choose_color+0x8e>
    d8ee:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    d8f5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d8f9:	75 0d                	jne    d908 <auto_choose_color+0xa1>
    d8fb:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    d8ff:	77 07                	ja     d908 <auto_choose_color+0xa1>
    d901:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    d908:	8b 45 10             	mov    0x10(%ebp),%eax
    d90b:	8b 40 14             	mov    0x14(%eax),%eax
    d90e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    d911:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    d915:	7e 21                	jle    d938 <auto_choose_color+0xd1>
    d917:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    d91b:	7e 14                	jle    d931 <auto_choose_color+0xca>
    d91d:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    d921:	7f 07                	jg     d92a <auto_choose_color+0xc3>
    d923:	b8 04 00 00 00       	mov    $0x4,%eax
    d928:	eb 13                	jmp    d93d <auto_choose_color+0xd6>
    d92a:	b8 08 00 00 00       	mov    $0x8,%eax
    d92f:	eb 0c                	jmp    d93d <auto_choose_color+0xd6>
    d931:	b8 02 00 00 00       	mov    $0x2,%eax
    d936:	eb 05                	jmp    d93d <auto_choose_color+0xd6>
    d938:	b8 01 00 00 00       	mov    $0x1,%eax
    d93d:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    d940:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    d947:	7f 13                	jg     d95c <auto_choose_color+0xf5>
    d949:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    d94d:	77 0d                	ja     d95c <auto_choose_color+0xf5>
    d94f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    d953:	74 07                	je     d95c <auto_choose_color+0xf5>
    d955:	b8 01 00 00 00       	mov    $0x1,%eax
    d95a:	eb 05                	jmp    d961 <auto_choose_color+0xfa>
    d95c:	b8 00 00 00 00       	mov    $0x0,%eax
    d961:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    d964:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d967:	01 c0                	add    %eax,%eax
    d969:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    d96c:	7e 07                	jle    d975 <auto_choose_color+0x10e>
    d96e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    d975:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d979:	74 15                	je     d990 <auto_choose_color+0x129>
    d97b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d97f:	75 0f                	jne    d990 <auto_choose_color+0x129>
    d981:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d984:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    d987:	77 07                	ja     d990 <auto_choose_color+0x129>
    d989:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    d990:	8b 45 10             	mov    0x10(%ebp),%eax
    d993:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    d999:	85 c0                	test   %eax,%eax
    d99b:	75 07                	jne    d9a4 <auto_choose_color+0x13d>
    d99d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    d9a4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d9a8:	0f 84 0a 01 00 00    	je     dab8 <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    d9ae:	8b 45 10             	mov    0x10(%ebp),%eax
    d9b1:	83 c0 18             	add    $0x18,%eax
    d9b4:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    d9b7:	83 ec 0c             	sub    $0xc,%esp
    d9ba:	ff 75 08             	pushl  0x8(%ebp)
    d9bd:	e8 ef be ff ff       	call   98b1 <lodepng_palette_clear>
    d9c2:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    d9c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    d9cc:	eb 6e                	jmp    da3c <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    d9ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d9d1:	c1 e0 02             	shl    $0x2,%eax
    d9d4:	8d 50 03             	lea    0x3(%eax),%edx
    d9d7:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d9da:	01 d0                	add    %edx,%eax
    d9dc:	0f b6 00             	movzbl (%eax),%eax
    d9df:	0f b6 d8             	movzbl %al,%ebx
    d9e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d9e5:	c1 e0 02             	shl    $0x2,%eax
    d9e8:	8d 50 02             	lea    0x2(%eax),%edx
    d9eb:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d9ee:	01 d0                	add    %edx,%eax
    d9f0:	0f b6 00             	movzbl (%eax),%eax
    d9f3:	0f b6 c8             	movzbl %al,%ecx
    d9f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d9f9:	c1 e0 02             	shl    $0x2,%eax
    d9fc:	8d 50 01             	lea    0x1(%eax),%edx
    d9ff:	8b 45 cc             	mov    -0x34(%ebp),%eax
    da02:	01 d0                	add    %edx,%eax
    da04:	0f b6 00             	movzbl (%eax),%eax
    da07:	0f b6 d0             	movzbl %al,%edx
    da0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    da0d:	c1 e0 02             	shl    $0x2,%eax
    da10:	89 c6                	mov    %eax,%esi
    da12:	8b 45 cc             	mov    -0x34(%ebp),%eax
    da15:	01 f0                	add    %esi,%eax
    da17:	0f b6 00             	movzbl (%eax),%eax
    da1a:	0f b6 c0             	movzbl %al,%eax
    da1d:	83 ec 0c             	sub    $0xc,%esp
    da20:	53                   	push   %ebx
    da21:	51                   	push   %ecx
    da22:	52                   	push   %edx
    da23:	50                   	push   %eax
    da24:	ff 75 08             	pushl  0x8(%ebp)
    da27:	e8 be be ff ff       	call   98ea <lodepng_palette_add>
    da2c:	83 c4 20             	add    $0x20,%esp
    da2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    da32:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    da36:	75 13                	jne    da4b <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    da38:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    da3c:	8b 45 10             	mov    0x10(%ebp),%eax
    da3f:	8b 50 14             	mov    0x14(%eax),%edx
    da42:	8b 45 f0             	mov    -0x10(%ebp),%eax
    da45:	39 c2                	cmp    %eax,%edx
    da47:	75 85                	jne    d9ce <auto_choose_color+0x167>
    da49:	eb 01                	jmp    da4c <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    da4b:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    da4c:	8b 45 08             	mov    0x8(%ebp),%eax
    da4f:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    da55:	8b 45 08             	mov    0x8(%ebp),%eax
    da58:	8b 55 d0             	mov    -0x30(%ebp),%edx
    da5b:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    da5e:	8b 45 0c             	mov    0xc(%ebp),%eax
    da61:	8b 00                	mov    (%eax),%eax
    da63:	83 f8 03             	cmp    $0x3,%eax
    da66:	0f 85 ec 00 00 00    	jne    db58 <auto_choose_color+0x2f1>
    da6c:	8b 45 0c             	mov    0xc(%ebp),%eax
    da6f:	8b 50 0c             	mov    0xc(%eax),%edx
    da72:	8b 45 08             	mov    0x8(%ebp),%eax
    da75:	8b 40 0c             	mov    0xc(%eax),%eax
    da78:	39 c2                	cmp    %eax,%edx
    da7a:	0f 8c d8 00 00 00    	jl     db58 <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    da80:	8b 45 0c             	mov    0xc(%ebp),%eax
    da83:	8b 50 04             	mov    0x4(%eax),%edx
    da86:	8b 45 08             	mov    0x8(%ebp),%eax
    da89:	8b 40 04             	mov    0x4(%eax),%eax
    da8c:	39 c2                	cmp    %eax,%edx
    da8e:	0f 85 c4 00 00 00    	jne    db58 <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    da94:	83 ec 0c             	sub    $0xc,%esp
    da97:	ff 75 08             	pushl  0x8(%ebp)
    da9a:	e8 0e bc ff ff       	call   96ad <lodepng_color_mode_cleanup>
    da9f:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    daa2:	83 ec 08             	sub    $0x8,%esp
    daa5:	ff 75 0c             	pushl  0xc(%ebp)
    daa8:	ff 75 08             	pushl  0x8(%ebp)
    daab:	e8 14 bc ff ff       	call   96c4 <lodepng_color_mode_copy>
    dab0:	83 c4 10             	add    $0x10,%esp
    dab3:	e9 a0 00 00 00       	jmp    db58 <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    dab8:	8b 45 08             	mov    0x8(%ebp),%eax
    dabb:	8b 55 dc             	mov    -0x24(%ebp),%edx
    dabe:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    dac1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    dac5:	74 14                	je     dadb <auto_choose_color+0x274>
    dac7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    dacb:	74 07                	je     dad4 <auto_choose_color+0x26d>
    dacd:	b8 04 00 00 00       	mov    $0x4,%eax
    dad2:	eb 19                	jmp    daed <auto_choose_color+0x286>
    dad4:	b8 06 00 00 00       	mov    $0x6,%eax
    dad9:	eb 12                	jmp    daed <auto_choose_color+0x286>
    dadb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    dadf:	74 07                	je     dae8 <auto_choose_color+0x281>
    dae1:	b8 00 00 00 00       	mov    $0x0,%eax
    dae6:	eb 05                	jmp    daed <auto_choose_color+0x286>
    dae8:	b8 02 00 00 00       	mov    $0x2,%eax
    daed:	8b 55 08             	mov    0x8(%ebp),%edx
    daf0:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    daf2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    daf6:	74 60                	je     db58 <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    daf8:	8b 45 08             	mov    0x8(%ebp),%eax
    dafb:	8b 40 04             	mov    0x4(%eax),%eax
    dafe:	ba 01 00 00 00       	mov    $0x1,%edx
    db03:	89 c1                	mov    %eax,%ecx
    db05:	d3 e2                	shl    %cl,%edx
    db07:	89 d0                	mov    %edx,%eax
    db09:	83 e8 01             	sub    $0x1,%eax
    db0c:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    db0f:	8b 45 10             	mov    0x10(%ebp),%eax
    db12:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    db16:	0f b7 c0             	movzwl %ax,%eax
    db19:	23 45 c8             	and    -0x38(%ebp),%eax
    db1c:	89 c2                	mov    %eax,%edx
    db1e:	8b 45 08             	mov    0x8(%ebp),%eax
    db21:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    db24:	8b 45 10             	mov    0x10(%ebp),%eax
    db27:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    db2b:	0f b7 c0             	movzwl %ax,%eax
    db2e:	23 45 c8             	and    -0x38(%ebp),%eax
    db31:	89 c2                	mov    %eax,%edx
    db33:	8b 45 08             	mov    0x8(%ebp),%eax
    db36:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    db39:	8b 45 10             	mov    0x10(%ebp),%eax
    db3c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    db40:	0f b7 c0             	movzwl %ax,%eax
    db43:	23 45 c8             	and    -0x38(%ebp),%eax
    db46:	89 c2                	mov    %eax,%edx
    db48:	8b 45 08             	mov    0x8(%ebp),%eax
    db4b:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    db4e:	8b 45 08             	mov    0x8(%ebp),%eax
    db51:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    db58:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    db5b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    db5e:	5b                   	pop    %ebx
    db5f:	5e                   	pop    %esi
    db60:	5d                   	pop    %ebp
    db61:	c3                   	ret    

0000db62 <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    db62:	55                   	push   %ebp
    db63:	89 e5                	mov    %esp,%ebp
    db65:	83 ec 1c             	sub    $0x1c,%esp
    db68:	8b 4d 08             	mov    0x8(%ebp),%ecx
    db6b:	8b 55 0c             	mov    0xc(%ebp),%edx
    db6e:	8b 45 10             	mov    0x10(%ebp),%eax
    db71:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    db75:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    db79:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    db7d:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    db81:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    db85:	29 c2                	sub    %eax,%edx
    db87:	89 d0                	mov    %edx,%eax
    db89:	99                   	cltd   
    db8a:	31 d0                	xor    %edx,%eax
    db8c:	29 d0                	sub    %edx,%eax
    db8e:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    db92:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    db96:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    db9a:	29 c2                	sub    %eax,%edx
    db9c:	89 d0                	mov    %edx,%eax
    db9e:	99                   	cltd   
    db9f:	31 d0                	xor    %edx,%eax
    dba1:	29 d0                	sub    %edx,%eax
    dba3:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    dba7:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    dbab:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    dbaf:	01 c2                	add    %eax,%edx
    dbb1:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    dbb5:	29 c2                	sub    %eax,%edx
    dbb7:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    dbbb:	29 c2                	sub    %eax,%edx
    dbbd:	89 d0                	mov    %edx,%eax
    dbbf:	99                   	cltd   
    dbc0:	31 d0                	xor    %edx,%eax
    dbc2:	29 d0                	sub    %edx,%eax
    dbc4:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    dbc8:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    dbcc:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    dbd0:	7d 10                	jge    dbe2 <paethPredictor+0x80>
    dbd2:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    dbd6:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    dbda:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    dbde:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    dbe2:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    dbe6:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    dbea:	7d 06                	jge    dbf2 <paethPredictor+0x90>
    dbec:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    dbf0:	eb 04                	jmp    dbf6 <paethPredictor+0x94>
    dbf2:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    dbf6:	c9                   	leave  
    dbf7:	c3                   	ret    

0000dbf8 <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    dbf8:	55                   	push   %ebp
    dbf9:	89 e5                	mov    %esp,%ebp
    dbfb:	56                   	push   %esi
    dbfc:	53                   	push   %ebx
    dbfd:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    dc00:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dc07:	e9 e2 00 00 00       	jmp    dcee <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    dc0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc0f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dc16:	8b 45 08             	mov    0x8(%ebp),%eax
    dc19:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    dc1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc1f:	8b 14 85 54 ac 01 00 	mov    0x1ac54(,%eax,4),%edx
    dc26:	8b 45 1c             	mov    0x1c(%ebp),%eax
    dc29:	01 c2                	add    %eax,%edx
    dc2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc2e:	8b 04 85 1c ac 01 00 	mov    0x1ac1c(,%eax,4),%eax
    dc35:	29 c2                	sub    %eax,%edx
    dc37:	89 d0                	mov    %edx,%eax
    dc39:	8d 58 ff             	lea    -0x1(%eax),%ebx
    dc3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc3f:	8b 34 85 54 ac 01 00 	mov    0x1ac54(,%eax,4),%esi
    dc46:	89 d8                	mov    %ebx,%eax
    dc48:	ba 00 00 00 00       	mov    $0x0,%edx
    dc4d:	f7 f6                	div    %esi
    dc4f:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    dc51:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc54:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dc5b:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc5e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    dc61:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc64:	8b 14 85 70 ac 01 00 	mov    0x1ac70(,%eax,4),%edx
    dc6b:	8b 45 20             	mov    0x20(%ebp),%eax
    dc6e:	01 c2                	add    %eax,%edx
    dc70:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc73:	8b 04 85 38 ac 01 00 	mov    0x1ac38(,%eax,4),%eax
    dc7a:	29 c2                	sub    %eax,%edx
    dc7c:	89 d0                	mov    %edx,%eax
    dc7e:	8d 58 ff             	lea    -0x1(%eax),%ebx
    dc81:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc84:	8b 34 85 70 ac 01 00 	mov    0x1ac70(,%eax,4),%esi
    dc8b:	89 d8                	mov    %ebx,%eax
    dc8d:	ba 00 00 00 00       	mov    $0x0,%edx
    dc92:	f7 f6                	div    %esi
    dc94:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    dc96:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc99:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dca0:	8b 45 08             	mov    0x8(%ebp),%eax
    dca3:	01 d0                	add    %edx,%eax
    dca5:	8b 00                	mov    (%eax),%eax
    dca7:	85 c0                	test   %eax,%eax
    dca9:	75 15                	jne    dcc0 <Adam7_getpassvalues+0xc8>
    dcab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcae:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dcb5:	8b 45 0c             	mov    0xc(%ebp),%eax
    dcb8:	01 d0                	add    %edx,%eax
    dcba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    dcc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcc3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dcca:	8b 45 0c             	mov    0xc(%ebp),%eax
    dccd:	01 d0                	add    %edx,%eax
    dccf:	8b 00                	mov    (%eax),%eax
    dcd1:	85 c0                	test   %eax,%eax
    dcd3:	75 15                	jne    dcea <Adam7_getpassvalues+0xf2>
    dcd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcd8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dcdf:	8b 45 08             	mov    0x8(%ebp),%eax
    dce2:	01 d0                	add    %edx,%eax
    dce4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    dcea:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dcee:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    dcf2:	0f 85 14 ff ff ff    	jne    dc0c <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    dcf8:	8b 45 18             	mov    0x18(%ebp),%eax
    dcfb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    dd01:	8b 45 18             	mov    0x18(%ebp),%eax
    dd04:	8b 10                	mov    (%eax),%edx
    dd06:	8b 45 14             	mov    0x14(%ebp),%eax
    dd09:	89 10                	mov    %edx,(%eax)
    dd0b:	8b 45 14             	mov    0x14(%ebp),%eax
    dd0e:	8b 10                	mov    (%eax),%edx
    dd10:	8b 45 10             	mov    0x10(%ebp),%eax
    dd13:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    dd15:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dd1c:	e9 40 01 00 00       	jmp    de61 <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    dd21:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd24:	83 c0 01             	add    $0x1,%eax
    dd27:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dd2e:	8b 45 10             	mov    0x10(%ebp),%eax
    dd31:	01 c2                	add    %eax,%edx
    dd33:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd36:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    dd3d:	8b 45 10             	mov    0x10(%ebp),%eax
    dd40:	01 c8                	add    %ecx,%eax
    dd42:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    dd44:	89 c6                	mov    %eax,%esi
    dd46:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd49:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    dd50:	8b 45 08             	mov    0x8(%ebp),%eax
    dd53:	01 c8                	add    %ecx,%eax
    dd55:	8b 00                	mov    (%eax),%eax
    dd57:	85 c0                	test   %eax,%eax
    dd59:	74 49                	je     dda4 <Adam7_getpassvalues+0x1ac>
    dd5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd5e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    dd65:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd68:	01 c8                	add    %ecx,%eax
    dd6a:	8b 00                	mov    (%eax),%eax
    dd6c:	85 c0                	test   %eax,%eax
    dd6e:	74 34                	je     dda4 <Adam7_getpassvalues+0x1ac>
    dd70:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd73:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    dd7a:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd7d:	01 c8                	add    %ecx,%eax
    dd7f:	8b 08                	mov    (%eax),%ecx
    dd81:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd84:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    dd8b:	8b 45 08             	mov    0x8(%ebp),%eax
    dd8e:	01 d8                	add    %ebx,%eax
    dd90:	8b 00                	mov    (%eax),%eax
    dd92:	0f af 45 24          	imul   0x24(%ebp),%eax
    dd96:	83 c0 07             	add    $0x7,%eax
    dd99:	c1 e8 03             	shr    $0x3,%eax
    dd9c:	83 c0 01             	add    $0x1,%eax
    dd9f:	0f af c1             	imul   %ecx,%eax
    dda2:	eb 05                	jmp    dda9 <Adam7_getpassvalues+0x1b1>
    dda4:	b8 00 00 00 00       	mov    $0x0,%eax
    dda9:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    ddab:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    ddad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddb0:	83 c0 01             	add    $0x1,%eax
    ddb3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ddba:	8b 45 14             	mov    0x14(%ebp),%eax
    ddbd:	01 c2                	add    %eax,%edx
    ddbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddc2:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    ddc9:	8b 45 14             	mov    0x14(%ebp),%eax
    ddcc:	01 c8                	add    %ecx,%eax
    ddce:	8b 00                	mov    (%eax),%eax
    ddd0:	89 c6                	mov    %eax,%esi
    ddd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddd5:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    dddc:	8b 45 0c             	mov    0xc(%ebp),%eax
    dddf:	01 c8                	add    %ecx,%eax
    dde1:	8b 08                	mov    (%eax),%ecx
    dde3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dde6:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    dded:	8b 45 08             	mov    0x8(%ebp),%eax
    ddf0:	01 d8                	add    %ebx,%eax
    ddf2:	8b 00                	mov    (%eax),%eax
    ddf4:	0f af 45 24          	imul   0x24(%ebp),%eax
    ddf8:	83 c0 07             	add    $0x7,%eax
    ddfb:	c1 e8 03             	shr    $0x3,%eax
    ddfe:	0f af c1             	imul   %ecx,%eax
    de01:	01 f0                	add    %esi,%eax
    de03:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    de05:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de08:	83 c0 01             	add    $0x1,%eax
    de0b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    de12:	8b 45 18             	mov    0x18(%ebp),%eax
    de15:	01 c2                	add    %eax,%edx
    de17:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de1a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    de21:	8b 45 18             	mov    0x18(%ebp),%eax
    de24:	01 c8                	add    %ecx,%eax
    de26:	8b 00                	mov    (%eax),%eax
    de28:	89 c6                	mov    %eax,%esi
    de2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de2d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    de34:	8b 45 0c             	mov    0xc(%ebp),%eax
    de37:	01 c8                	add    %ecx,%eax
    de39:	8b 08                	mov    (%eax),%ecx
    de3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de3e:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    de45:	8b 45 08             	mov    0x8(%ebp),%eax
    de48:	01 d8                	add    %ebx,%eax
    de4a:	8b 00                	mov    (%eax),%eax
    de4c:	0f af c1             	imul   %ecx,%eax
    de4f:	0f af 45 24          	imul   0x24(%ebp),%eax
    de53:	83 c0 07             	add    $0x7,%eax
    de56:	c1 e8 03             	shr    $0x3,%eax
    de59:	01 f0                	add    %esi,%eax
    de5b:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    de5d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    de61:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    de65:	0f 85 b6 fe ff ff    	jne    dd21 <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    de6b:	90                   	nop
    de6c:	83 c4 10             	add    $0x10,%esp
    de6f:	5b                   	pop    %ebx
    de70:	5e                   	pop    %esi
    de71:	5d                   	pop    %ebp
    de72:	c3                   	ret    

0000de73 <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    de73:	55                   	push   %ebp
    de74:	89 e5                	mov    %esp,%ebp
    de76:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    de79:	8b 45 10             	mov    0x10(%ebp),%eax
    de7c:	05 98 00 00 00       	add    $0x98,%eax
    de81:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    de84:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    de88:	74 06                	je     de90 <lodepng_inspect+0x1d>
    de8a:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    de8e:	75 17                	jne    dea7 <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    de90:	8b 45 10             	mov    0x10(%ebp),%eax
    de93:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    de9a:	00 00 00 
    de9d:	b8 30 00 00 00       	mov    $0x30,%eax
    dea2:	e9 ce 02 00 00       	jmp    e175 <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    dea7:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    deab:	7f 17                	jg     dec4 <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    dead:	8b 45 10             	mov    0x10(%ebp),%eax
    deb0:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    deb7:	00 00 00 
    deba:	b8 1b 00 00 00       	mov    $0x1b,%eax
    debf:	e9 b1 02 00 00       	jmp    e175 <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    dec4:	83 ec 0c             	sub    $0xc,%esp
    dec7:	ff 75 f4             	pushl  -0xc(%ebp)
    deca:	e8 63 c7 ff ff       	call   a632 <lodepng_info_cleanup>
    decf:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    ded2:	83 ec 0c             	sub    $0xc,%esp
    ded5:	ff 75 f4             	pushl  -0xc(%ebp)
    ded8:	e8 74 c6 ff ff       	call   a551 <lodepng_info_init>
    dedd:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    dee0:	8b 45 14             	mov    0x14(%ebp),%eax
    dee3:	0f b6 00             	movzbl (%eax),%eax
    dee6:	3c 89                	cmp    $0x89,%al
    dee8:	75 5b                	jne    df45 <lodepng_inspect+0xd2>
    deea:	8b 45 14             	mov    0x14(%ebp),%eax
    deed:	83 c0 01             	add    $0x1,%eax
    def0:	0f b6 00             	movzbl (%eax),%eax
    def3:	3c 50                	cmp    $0x50,%al
    def5:	75 4e                	jne    df45 <lodepng_inspect+0xd2>
    def7:	8b 45 14             	mov    0x14(%ebp),%eax
    defa:	83 c0 02             	add    $0x2,%eax
    defd:	0f b6 00             	movzbl (%eax),%eax
    df00:	3c 4e                	cmp    $0x4e,%al
    df02:	75 41                	jne    df45 <lodepng_inspect+0xd2>
    df04:	8b 45 14             	mov    0x14(%ebp),%eax
    df07:	83 c0 03             	add    $0x3,%eax
    df0a:	0f b6 00             	movzbl (%eax),%eax
    df0d:	3c 47                	cmp    $0x47,%al
    df0f:	75 34                	jne    df45 <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    df11:	8b 45 14             	mov    0x14(%ebp),%eax
    df14:	83 c0 04             	add    $0x4,%eax
    df17:	0f b6 00             	movzbl (%eax),%eax
    df1a:	3c 0d                	cmp    $0xd,%al
    df1c:	75 27                	jne    df45 <lodepng_inspect+0xd2>
    df1e:	8b 45 14             	mov    0x14(%ebp),%eax
    df21:	83 c0 05             	add    $0x5,%eax
    df24:	0f b6 00             	movzbl (%eax),%eax
    df27:	3c 0a                	cmp    $0xa,%al
    df29:	75 1a                	jne    df45 <lodepng_inspect+0xd2>
    df2b:	8b 45 14             	mov    0x14(%ebp),%eax
    df2e:	83 c0 06             	add    $0x6,%eax
    df31:	0f b6 00             	movzbl (%eax),%eax
    df34:	3c 1a                	cmp    $0x1a,%al
    df36:	75 0d                	jne    df45 <lodepng_inspect+0xd2>
    df38:	8b 45 14             	mov    0x14(%ebp),%eax
    df3b:	83 c0 07             	add    $0x7,%eax
    df3e:	0f b6 00             	movzbl (%eax),%eax
    df41:	3c 0a                	cmp    $0xa,%al
    df43:	74 17                	je     df5c <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    df45:	8b 45 10             	mov    0x10(%ebp),%eax
    df48:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    df4f:	00 00 00 
    df52:	b8 1c 00 00 00       	mov    $0x1c,%eax
    df57:	e9 19 02 00 00       	jmp    e175 <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    df5c:	8b 45 14             	mov    0x14(%ebp),%eax
    df5f:	83 c0 08             	add    $0x8,%eax
    df62:	83 ec 0c             	sub    $0xc,%esp
    df65:	50                   	push   %eax
    df66:	e8 c2 ae ff ff       	call   8e2d <lodepng_chunk_length>
    df6b:	83 c4 10             	add    $0x10,%esp
    df6e:	83 f8 0d             	cmp    $0xd,%eax
    df71:	74 17                	je     df8a <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    df73:	8b 45 10             	mov    0x10(%ebp),%eax
    df76:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    df7d:	00 00 00 
    df80:	b8 5e 00 00 00       	mov    $0x5e,%eax
    df85:	e9 eb 01 00 00       	jmp    e175 <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    df8a:	8b 45 14             	mov    0x14(%ebp),%eax
    df8d:	83 c0 08             	add    $0x8,%eax
    df90:	83 ec 08             	sub    $0x8,%esp
    df93:	68 8c ac 01 00       	push   $0x1ac8c
    df98:	50                   	push   %eax
    df99:	e8 dc ae ff ff       	call   8e7a <lodepng_chunk_type_equals>
    df9e:	83 c4 10             	add    $0x10,%esp
    dfa1:	84 c0                	test   %al,%al
    dfa3:	75 17                	jne    dfbc <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    dfa5:	8b 45 10             	mov    0x10(%ebp),%eax
    dfa8:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    dfaf:	00 00 00 
    dfb2:	b8 1d 00 00 00       	mov    $0x1d,%eax
    dfb7:	e9 b9 01 00 00       	jmp    e175 <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    dfbc:	8b 45 14             	mov    0x14(%ebp),%eax
    dfbf:	83 c0 10             	add    $0x10,%eax
    dfc2:	83 ec 0c             	sub    $0xc,%esp
    dfc5:	50                   	push   %eax
    dfc6:	e8 5e 62 ff ff       	call   4229 <lodepng_read32bitInt>
    dfcb:	83 c4 10             	add    $0x10,%esp
    dfce:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    dfd1:	8b 45 14             	mov    0x14(%ebp),%eax
    dfd4:	83 c0 14             	add    $0x14,%eax
    dfd7:	83 ec 0c             	sub    $0xc,%esp
    dfda:	50                   	push   %eax
    dfdb:	e8 49 62 ff ff       	call   4229 <lodepng_read32bitInt>
    dfe0:	83 c4 10             	add    $0x10,%esp
    dfe3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    dfe6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    dfea:	74 08                	je     dff4 <lodepng_inspect+0x181>
    dfec:	8b 45 08             	mov    0x8(%ebp),%eax
    dfef:	8b 55 f0             	mov    -0x10(%ebp),%edx
    dff2:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    dff4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    dff8:	74 08                	je     e002 <lodepng_inspect+0x18f>
    dffa:	8b 45 0c             	mov    0xc(%ebp),%eax
    dffd:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e000:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    e002:	8b 45 14             	mov    0x14(%ebp),%eax
    e005:	83 c0 18             	add    $0x18,%eax
    e008:	0f b6 00             	movzbl (%eax),%eax
    e00b:	0f b6 d0             	movzbl %al,%edx
    e00e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e011:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    e014:	8b 45 14             	mov    0x14(%ebp),%eax
    e017:	83 c0 19             	add    $0x19,%eax
    e01a:	0f b6 00             	movzbl (%eax),%eax
    e01d:	0f b6 d0             	movzbl %al,%edx
    e020:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e023:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    e026:	8b 45 14             	mov    0x14(%ebp),%eax
    e029:	83 c0 1a             	add    $0x1a,%eax
    e02c:	0f b6 00             	movzbl (%eax),%eax
    e02f:	0f b6 d0             	movzbl %al,%edx
    e032:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e035:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    e037:	8b 45 14             	mov    0x14(%ebp),%eax
    e03a:	83 c0 1b             	add    $0x1b,%eax
    e03d:	0f b6 00             	movzbl (%eax),%eax
    e040:	0f b6 d0             	movzbl %al,%edx
    e043:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e046:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    e049:	8b 45 14             	mov    0x14(%ebp),%eax
    e04c:	83 c0 1c             	add    $0x1c,%eax
    e04f:	0f b6 00             	movzbl (%eax),%eax
    e052:	0f b6 d0             	movzbl %al,%edx
    e055:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e058:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    e05b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e05f:	74 06                	je     e067 <lodepng_inspect+0x1f4>
    e061:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e065:	75 17                	jne    e07e <lodepng_inspect+0x20b>
    e067:	8b 45 10             	mov    0x10(%ebp),%eax
    e06a:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    e071:	00 00 00 
    e074:	b8 5d 00 00 00       	mov    $0x5d,%eax
    e079:	e9 f7 00 00 00       	jmp    e175 <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    e07e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e081:	8b 50 10             	mov    0x10(%eax),%edx
    e084:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e087:	8b 40 0c             	mov    0xc(%eax),%eax
    e08a:	83 ec 08             	sub    $0x8,%esp
    e08d:	52                   	push   %edx
    e08e:	50                   	push   %eax
    e08f:	e8 d4 b3 ff ff       	call   9468 <checkColorValidity>
    e094:	83 c4 10             	add    $0x10,%esp
    e097:	89 c2                	mov    %eax,%edx
    e099:	8b 45 10             	mov    0x10(%ebp),%eax
    e09c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    e0a2:	8b 45 10             	mov    0x10(%ebp),%eax
    e0a5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    e0ab:	85 c0                	test   %eax,%eax
    e0ad:	74 0e                	je     e0bd <lodepng_inspect+0x24a>
    e0af:	8b 45 10             	mov    0x10(%ebp),%eax
    e0b2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    e0b8:	e9 b8 00 00 00       	jmp    e175 <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    e0bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e0c0:	8b 00                	mov    (%eax),%eax
    e0c2:	85 c0                	test   %eax,%eax
    e0c4:	74 17                	je     e0dd <lodepng_inspect+0x26a>
    e0c6:	8b 45 10             	mov    0x10(%ebp),%eax
    e0c9:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    e0d0:	00 00 00 
    e0d3:	b8 20 00 00 00       	mov    $0x20,%eax
    e0d8:	e9 98 00 00 00       	jmp    e175 <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    e0dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e0e0:	8b 40 04             	mov    0x4(%eax),%eax
    e0e3:	85 c0                	test   %eax,%eax
    e0e5:	74 14                	je     e0fb <lodepng_inspect+0x288>
    e0e7:	8b 45 10             	mov    0x10(%ebp),%eax
    e0ea:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    e0f1:	00 00 00 
    e0f4:	b8 21 00 00 00       	mov    $0x21,%eax
    e0f9:	eb 7a                	jmp    e175 <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    e0fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e0fe:	8b 40 08             	mov    0x8(%eax),%eax
    e101:	83 f8 01             	cmp    $0x1,%eax
    e104:	76 14                	jbe    e11a <lodepng_inspect+0x2a7>
    e106:	8b 45 10             	mov    0x10(%ebp),%eax
    e109:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    e110:	00 00 00 
    e113:	b8 22 00 00 00       	mov    $0x22,%eax
    e118:	eb 5b                	jmp    e175 <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    e11a:	8b 45 10             	mov    0x10(%ebp),%eax
    e11d:	8b 40 18             	mov    0x18(%eax),%eax
    e120:	85 c0                	test   %eax,%eax
    e122:	75 48                	jne    e16c <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    e124:	8b 45 14             	mov    0x14(%ebp),%eax
    e127:	83 c0 1d             	add    $0x1d,%eax
    e12a:	83 ec 0c             	sub    $0xc,%esp
    e12d:	50                   	push   %eax
    e12e:	e8 f6 60 ff ff       	call   4229 <lodepng_read32bitInt>
    e133:	83 c4 10             	add    $0x10,%esp
    e136:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    e139:	8b 45 14             	mov    0x14(%ebp),%eax
    e13c:	83 c0 0c             	add    $0xc,%eax
    e13f:	83 ec 08             	sub    $0x8,%esp
    e142:	6a 11                	push   $0x11
    e144:	50                   	push   %eax
    e145:	e8 71 ab ff ff       	call   8cbb <lodepng_crc32>
    e14a:	83 c4 10             	add    $0x10,%esp
    e14d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    e150:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e153:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    e156:	74 14                	je     e16c <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    e158:	8b 45 10             	mov    0x10(%ebp),%eax
    e15b:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    e162:	00 00 00 
    e165:	b8 39 00 00 00       	mov    $0x39,%eax
    e16a:	eb 09                	jmp    e175 <lodepng_inspect+0x302>
    }
  }

  return state->error;
    e16c:	8b 45 10             	mov    0x10(%ebp),%eax
    e16f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    e175:	c9                   	leave  
    e176:	c3                   	ret    

0000e177 <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    e177:	55                   	push   %ebp
    e178:	89 e5                	mov    %esp,%ebp
    e17a:	56                   	push   %esi
    e17b:	53                   	push   %ebx
    e17c:	83 ec 44             	sub    $0x44,%esp
    e17f:	8b 45 18             	mov    0x18(%ebp),%eax
    e182:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    e185:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    e189:	83 f8 04             	cmp    $0x4,%eax
    e18c:	0f 87 81 07 00 00    	ja     e913 <unfilterScanline+0x79c>
    e192:	8b 04 85 94 ac 01 00 	mov    0x1ac94(,%eax,4),%eax
    e199:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    e19b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e1a2:	eb 19                	jmp    e1bd <unfilterScanline+0x46>
    e1a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e1a7:	8b 45 08             	mov    0x8(%ebp),%eax
    e1aa:	01 c2                	add    %eax,%edx
    e1ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e1af:	8b 45 0c             	mov    0xc(%ebp),%eax
    e1b2:	01 c8                	add    %ecx,%eax
    e1b4:	0f b6 00             	movzbl (%eax),%eax
    e1b7:	88 02                	mov    %al,(%edx)
    e1b9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e1bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1c0:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e1c3:	75 df                	jne    e1a4 <unfilterScanline+0x2d>
      break;
    e1c5:	e9 50 07 00 00       	jmp    e91a <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    e1ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e1d1:	eb 19                	jmp    e1ec <unfilterScanline+0x75>
    e1d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e1d6:	8b 45 08             	mov    0x8(%ebp),%eax
    e1d9:	01 c2                	add    %eax,%edx
    e1db:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e1de:	8b 45 0c             	mov    0xc(%ebp),%eax
    e1e1:	01 c8                	add    %ecx,%eax
    e1e3:	0f b6 00             	movzbl (%eax),%eax
    e1e6:	88 02                	mov    %al,(%edx)
    e1e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e1ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e1ef:	3b 45 14             	cmp    0x14(%ebp),%eax
    e1f2:	75 df                	jne    e1d3 <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    e1f4:	8b 45 14             	mov    0x14(%ebp),%eax
    e1f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e1fa:	eb 2b                	jmp    e227 <unfilterScanline+0xb0>
    e1fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e1ff:	8b 45 08             	mov    0x8(%ebp),%eax
    e202:	01 c2                	add    %eax,%edx
    e204:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e207:	8b 45 0c             	mov    0xc(%ebp),%eax
    e20a:	01 c8                	add    %ecx,%eax
    e20c:	0f b6 08             	movzbl (%eax),%ecx
    e20f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e212:	2b 45 14             	sub    0x14(%ebp),%eax
    e215:	89 c3                	mov    %eax,%ebx
    e217:	8b 45 08             	mov    0x8(%ebp),%eax
    e21a:	01 d8                	add    %ebx,%eax
    e21c:	0f b6 00             	movzbl (%eax),%eax
    e21f:	01 c8                	add    %ecx,%eax
    e221:	88 02                	mov    %al,(%edx)
    e223:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e227:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e22a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e22d:	7c cd                	jl     e1fc <unfilterScanline+0x85>
      break;
    e22f:	e9 e6 06 00 00       	jmp    e91a <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    e234:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    e238:	74 3c                	je     e276 <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    e23a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e241:	eb 26                	jmp    e269 <unfilterScanline+0xf2>
    e243:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e246:	8b 45 08             	mov    0x8(%ebp),%eax
    e249:	01 d0                	add    %edx,%eax
    e24b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e24e:	8b 55 0c             	mov    0xc(%ebp),%edx
    e251:	01 ca                	add    %ecx,%edx
    e253:	0f b6 0a             	movzbl (%edx),%ecx
    e256:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    e259:	8b 55 10             	mov    0x10(%ebp),%edx
    e25c:	01 da                	add    %ebx,%edx
    e25e:	0f b6 12             	movzbl (%edx),%edx
    e261:	01 ca                	add    %ecx,%edx
    e263:	88 10                	mov    %dl,(%eax)
    e265:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e269:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e26c:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e26f:	75 d2                	jne    e243 <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    e271:	e9 a4 06 00 00       	jmp    e91a <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    e276:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e27d:	eb 19                	jmp    e298 <unfilterScanline+0x121>
    e27f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e282:	8b 45 08             	mov    0x8(%ebp),%eax
    e285:	01 c2                	add    %eax,%edx
    e287:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e28a:	8b 45 0c             	mov    0xc(%ebp),%eax
    e28d:	01 c8                	add    %ecx,%eax
    e28f:	0f b6 00             	movzbl (%eax),%eax
    e292:	88 02                	mov    %al,(%edx)
    e294:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e298:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e29b:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e29e:	75 df                	jne    e27f <unfilterScanline+0x108>
      }
      break;
    e2a0:	e9 75 06 00 00       	jmp    e91a <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    e2a5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    e2a9:	0f 84 8e 00 00 00    	je     e33d <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    e2af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e2b6:	eb 28                	jmp    e2e0 <unfilterScanline+0x169>
    e2b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e2bb:	8b 45 08             	mov    0x8(%ebp),%eax
    e2be:	01 d0                	add    %edx,%eax
    e2c0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e2c3:	8b 55 0c             	mov    0xc(%ebp),%edx
    e2c6:	01 ca                	add    %ecx,%edx
    e2c8:	0f b6 12             	movzbl (%edx),%edx
    e2cb:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    e2ce:	8b 4d 10             	mov    0x10(%ebp),%ecx
    e2d1:	01 d9                	add    %ebx,%ecx
    e2d3:	0f b6 09             	movzbl (%ecx),%ecx
    e2d6:	d0 e9                	shr    %cl
    e2d8:	01 ca                	add    %ecx,%edx
    e2da:	88 10                	mov    %dl,(%eax)
    e2dc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e2e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e2e3:	3b 45 14             	cmp    0x14(%ebp),%eax
    e2e6:	75 d0                	jne    e2b8 <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    e2e8:	8b 45 14             	mov    0x14(%ebp),%eax
    e2eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e2ee:	eb 40                	jmp    e330 <unfilterScanline+0x1b9>
    e2f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e2f3:	8b 45 08             	mov    0x8(%ebp),%eax
    e2f6:	01 c2                	add    %eax,%edx
    e2f8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e2fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    e2fe:	01 c8                	add    %ecx,%eax
    e300:	0f b6 08             	movzbl (%eax),%ecx
    e303:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e306:	2b 45 14             	sub    0x14(%ebp),%eax
    e309:	89 c3                	mov    %eax,%ebx
    e30b:	8b 45 08             	mov    0x8(%ebp),%eax
    e30e:	01 d8                	add    %ebx,%eax
    e310:	0f b6 00             	movzbl (%eax),%eax
    e313:	0f b6 d8             	movzbl %al,%ebx
    e316:	8b 75 f4             	mov    -0xc(%ebp),%esi
    e319:	8b 45 10             	mov    0x10(%ebp),%eax
    e31c:	01 f0                	add    %esi,%eax
    e31e:	0f b6 00             	movzbl (%eax),%eax
    e321:	0f b6 c0             	movzbl %al,%eax
    e324:	01 d8                	add    %ebx,%eax
    e326:	d1 f8                	sar    %eax
    e328:	01 c8                	add    %ecx,%eax
    e32a:	88 02                	mov    %al,(%edx)
    e32c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e330:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e333:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e336:	7c b8                	jl     e2f0 <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    e338:	e9 dd 05 00 00       	jmp    e91a <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    e33d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e344:	eb 19                	jmp    e35f <unfilterScanline+0x1e8>
    e346:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e349:	8b 45 08             	mov    0x8(%ebp),%eax
    e34c:	01 c2                	add    %eax,%edx
    e34e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e351:	8b 45 0c             	mov    0xc(%ebp),%eax
    e354:	01 c8                	add    %ecx,%eax
    e356:	0f b6 00             	movzbl (%eax),%eax
    e359:	88 02                	mov    %al,(%edx)
    e35b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e35f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e362:	3b 45 14             	cmp    0x14(%ebp),%eax
    e365:	75 df                	jne    e346 <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    e367:	8b 45 14             	mov    0x14(%ebp),%eax
    e36a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e36d:	eb 2d                	jmp    e39c <unfilterScanline+0x225>
    e36f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e372:	8b 45 08             	mov    0x8(%ebp),%eax
    e375:	01 c2                	add    %eax,%edx
    e377:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e37a:	8b 45 0c             	mov    0xc(%ebp),%eax
    e37d:	01 c8                	add    %ecx,%eax
    e37f:	0f b6 08             	movzbl (%eax),%ecx
    e382:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e385:	2b 45 14             	sub    0x14(%ebp),%eax
    e388:	89 c3                	mov    %eax,%ebx
    e38a:	8b 45 08             	mov    0x8(%ebp),%eax
    e38d:	01 d8                	add    %ebx,%eax
    e38f:	0f b6 00             	movzbl (%eax),%eax
    e392:	d0 e8                	shr    %al
    e394:	01 c8                	add    %ecx,%eax
    e396:	88 02                	mov    %al,(%edx)
    e398:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e39c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e39f:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e3a2:	7c cb                	jl     e36f <unfilterScanline+0x1f8>
      }
      break;
    e3a4:	e9 71 05 00 00       	jmp    e91a <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    e3a9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    e3ad:	0f 84 f9 04 00 00    	je     e8ac <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    e3b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e3ba:	eb 26                	jmp    e3e2 <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    e3bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e3bf:	8b 45 08             	mov    0x8(%ebp),%eax
    e3c2:	01 d0                	add    %edx,%eax
    e3c4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e3c7:	8b 55 0c             	mov    0xc(%ebp),%edx
    e3ca:	01 ca                	add    %ecx,%edx
    e3cc:	0f b6 0a             	movzbl (%edx),%ecx
    e3cf:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    e3d2:	8b 55 10             	mov    0x10(%ebp),%edx
    e3d5:	01 da                	add    %ebx,%edx
    e3d7:	0f b6 12             	movzbl (%edx),%edx
    e3da:	01 ca                	add    %ecx,%edx
    e3dc:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    e3de:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e3e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3e5:	3b 45 14             	cmp    0x14(%ebp),%eax
    e3e8:	75 d2                	jne    e3bc <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    e3ea:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    e3ee:	0f 8e db 01 00 00    	jle    e5cf <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    e3f4:	e9 c2 01 00 00       	jmp    e5bb <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    e3f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3fc:	2b 45 14             	sub    0x14(%ebp),%eax
    e3ff:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    e402:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e405:	8b 45 0c             	mov    0xc(%ebp),%eax
    e408:	01 d0                	add    %edx,%eax
    e40a:	0f b6 00             	movzbl (%eax),%eax
    e40d:	88 45 ef             	mov    %al,-0x11(%ebp)
    e410:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e413:	8d 50 01             	lea    0x1(%eax),%edx
    e416:	8b 45 0c             	mov    0xc(%ebp),%eax
    e419:	01 d0                	add    %edx,%eax
    e41b:	0f b6 00             	movzbl (%eax),%eax
    e41e:	88 45 ee             	mov    %al,-0x12(%ebp)
    e421:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e424:	8d 50 02             	lea    0x2(%eax),%edx
    e427:	8b 45 0c             	mov    0xc(%ebp),%eax
    e42a:	01 d0                	add    %edx,%eax
    e42c:	0f b6 00             	movzbl (%eax),%eax
    e42f:	88 45 ed             	mov    %al,-0x13(%ebp)
    e432:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e435:	8d 50 03             	lea    0x3(%eax),%edx
    e438:	8b 45 0c             	mov    0xc(%ebp),%eax
    e43b:	01 d0                	add    %edx,%eax
    e43d:	0f b6 00             	movzbl (%eax),%eax
    e440:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    e443:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e446:	8b 45 08             	mov    0x8(%ebp),%eax
    e449:	01 d0                	add    %edx,%eax
    e44b:	0f b6 00             	movzbl (%eax),%eax
    e44e:	88 45 eb             	mov    %al,-0x15(%ebp)
    e451:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e454:	8d 50 01             	lea    0x1(%eax),%edx
    e457:	8b 45 08             	mov    0x8(%ebp),%eax
    e45a:	01 d0                	add    %edx,%eax
    e45c:	0f b6 00             	movzbl (%eax),%eax
    e45f:	88 45 ea             	mov    %al,-0x16(%ebp)
    e462:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e465:	8d 50 02             	lea    0x2(%eax),%edx
    e468:	8b 45 08             	mov    0x8(%ebp),%eax
    e46b:	01 d0                	add    %edx,%eax
    e46d:	0f b6 00             	movzbl (%eax),%eax
    e470:	88 45 e9             	mov    %al,-0x17(%ebp)
    e473:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e476:	8d 50 03             	lea    0x3(%eax),%edx
    e479:	8b 45 08             	mov    0x8(%ebp),%eax
    e47c:	01 d0                	add    %edx,%eax
    e47e:	0f b6 00             	movzbl (%eax),%eax
    e481:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    e484:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e487:	8b 45 10             	mov    0x10(%ebp),%eax
    e48a:	01 d0                	add    %edx,%eax
    e48c:	0f b6 00             	movzbl (%eax),%eax
    e48f:	88 45 e7             	mov    %al,-0x19(%ebp)
    e492:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e495:	8d 50 01             	lea    0x1(%eax),%edx
    e498:	8b 45 10             	mov    0x10(%ebp),%eax
    e49b:	01 d0                	add    %edx,%eax
    e49d:	0f b6 00             	movzbl (%eax),%eax
    e4a0:	88 45 e6             	mov    %al,-0x1a(%ebp)
    e4a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e4a6:	8d 50 02             	lea    0x2(%eax),%edx
    e4a9:	8b 45 10             	mov    0x10(%ebp),%eax
    e4ac:	01 d0                	add    %edx,%eax
    e4ae:	0f b6 00             	movzbl (%eax),%eax
    e4b1:	88 45 e5             	mov    %al,-0x1b(%ebp)
    e4b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e4b7:	8d 50 03             	lea    0x3(%eax),%edx
    e4ba:	8b 45 10             	mov    0x10(%ebp),%eax
    e4bd:	01 d0                	add    %edx,%eax
    e4bf:	0f b6 00             	movzbl (%eax),%eax
    e4c2:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    e4c5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e4c8:	8b 45 10             	mov    0x10(%ebp),%eax
    e4cb:	01 d0                	add    %edx,%eax
    e4cd:	0f b6 00             	movzbl (%eax),%eax
    e4d0:	88 45 e3             	mov    %al,-0x1d(%ebp)
    e4d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e4d6:	8d 50 01             	lea    0x1(%eax),%edx
    e4d9:	8b 45 10             	mov    0x10(%ebp),%eax
    e4dc:	01 d0                	add    %edx,%eax
    e4de:	0f b6 00             	movzbl (%eax),%eax
    e4e1:	88 45 e2             	mov    %al,-0x1e(%ebp)
    e4e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e4e7:	8d 50 02             	lea    0x2(%eax),%edx
    e4ea:	8b 45 10             	mov    0x10(%ebp),%eax
    e4ed:	01 d0                	add    %edx,%eax
    e4ef:	0f b6 00             	movzbl (%eax),%eax
    e4f2:	88 45 e1             	mov    %al,-0x1f(%ebp)
    e4f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e4f8:	8d 50 03             	lea    0x3(%eax),%edx
    e4fb:	8b 45 10             	mov    0x10(%ebp),%eax
    e4fe:	01 d0                	add    %edx,%eax
    e500:	0f b6 00             	movzbl (%eax),%eax
    e503:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    e506:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e509:	8b 45 08             	mov    0x8(%ebp),%eax
    e50c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e50f:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    e513:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    e517:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    e51b:	51                   	push   %ecx
    e51c:	52                   	push   %edx
    e51d:	50                   	push   %eax
    e51e:	e8 3f f6 ff ff       	call   db62 <paethPredictor>
    e523:	83 c4 0c             	add    $0xc,%esp
    e526:	89 c2                	mov    %eax,%edx
    e528:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    e52c:	01 d0                	add    %edx,%eax
    e52e:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    e530:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e533:	8d 50 01             	lea    0x1(%eax),%edx
    e536:	8b 45 08             	mov    0x8(%ebp),%eax
    e539:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e53c:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    e540:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    e544:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    e548:	51                   	push   %ecx
    e549:	52                   	push   %edx
    e54a:	50                   	push   %eax
    e54b:	e8 12 f6 ff ff       	call   db62 <paethPredictor>
    e550:	83 c4 0c             	add    $0xc,%esp
    e553:	89 c2                	mov    %eax,%edx
    e555:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    e559:	01 d0                	add    %edx,%eax
    e55b:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    e55d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e560:	8d 50 02             	lea    0x2(%eax),%edx
    e563:	8b 45 08             	mov    0x8(%ebp),%eax
    e566:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e569:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    e56d:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    e571:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    e575:	51                   	push   %ecx
    e576:	52                   	push   %edx
    e577:	50                   	push   %eax
    e578:	e8 e5 f5 ff ff       	call   db62 <paethPredictor>
    e57d:	83 c4 0c             	add    $0xc,%esp
    e580:	89 c2                	mov    %eax,%edx
    e582:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    e586:	01 d0                	add    %edx,%eax
    e588:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    e58a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e58d:	8d 50 03             	lea    0x3(%eax),%edx
    e590:	8b 45 08             	mov    0x8(%ebp),%eax
    e593:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e596:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    e59a:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    e59e:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    e5a2:	51                   	push   %ecx
    e5a3:	52                   	push   %edx
    e5a4:	50                   	push   %eax
    e5a5:	e8 b8 f5 ff ff       	call   db62 <paethPredictor>
    e5aa:	83 c4 0c             	add    $0xc,%esp
    e5ad:	89 c2                	mov    %eax,%edx
    e5af:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    e5b3:	01 d0                	add    %edx,%eax
    e5b5:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    e5b7:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    e5bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e5be:	83 c0 03             	add    $0x3,%eax
    e5c1:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e5c4:	0f 8c 2f fe ff ff    	jl     e3f9 <unfilterScanline+0x282>
    e5ca:	e9 d3 02 00 00       	jmp    e8a2 <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    e5cf:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    e5d3:	0f 8e 6a 01 00 00    	jle    e743 <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    e5d9:	e9 51 01 00 00       	jmp    e72f <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    e5de:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e5e1:	2b 45 14             	sub    0x14(%ebp),%eax
    e5e4:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    e5e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e5ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5ed:	01 d0                	add    %edx,%eax
    e5ef:	0f b6 00             	movzbl (%eax),%eax
    e5f2:	88 45 db             	mov    %al,-0x25(%ebp)
    e5f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e5f8:	8d 50 01             	lea    0x1(%eax),%edx
    e5fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5fe:	01 d0                	add    %edx,%eax
    e600:	0f b6 00             	movzbl (%eax),%eax
    e603:	88 45 da             	mov    %al,-0x26(%ebp)
    e606:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e609:	8d 50 02             	lea    0x2(%eax),%edx
    e60c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e60f:	01 d0                	add    %edx,%eax
    e611:	0f b6 00             	movzbl (%eax),%eax
    e614:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    e617:	8b 55 dc             	mov    -0x24(%ebp),%edx
    e61a:	8b 45 08             	mov    0x8(%ebp),%eax
    e61d:	01 d0                	add    %edx,%eax
    e61f:	0f b6 00             	movzbl (%eax),%eax
    e622:	88 45 d8             	mov    %al,-0x28(%ebp)
    e625:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e628:	8d 50 01             	lea    0x1(%eax),%edx
    e62b:	8b 45 08             	mov    0x8(%ebp),%eax
    e62e:	01 d0                	add    %edx,%eax
    e630:	0f b6 00             	movzbl (%eax),%eax
    e633:	88 45 d7             	mov    %al,-0x29(%ebp)
    e636:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e639:	8d 50 02             	lea    0x2(%eax),%edx
    e63c:	8b 45 08             	mov    0x8(%ebp),%eax
    e63f:	01 d0                	add    %edx,%eax
    e641:	0f b6 00             	movzbl (%eax),%eax
    e644:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    e647:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e64a:	8b 45 10             	mov    0x10(%ebp),%eax
    e64d:	01 d0                	add    %edx,%eax
    e64f:	0f b6 00             	movzbl (%eax),%eax
    e652:	88 45 d5             	mov    %al,-0x2b(%ebp)
    e655:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e658:	8d 50 01             	lea    0x1(%eax),%edx
    e65b:	8b 45 10             	mov    0x10(%ebp),%eax
    e65e:	01 d0                	add    %edx,%eax
    e660:	0f b6 00             	movzbl (%eax),%eax
    e663:	88 45 d4             	mov    %al,-0x2c(%ebp)
    e666:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e669:	8d 50 02             	lea    0x2(%eax),%edx
    e66c:	8b 45 10             	mov    0x10(%ebp),%eax
    e66f:	01 d0                	add    %edx,%eax
    e671:	0f b6 00             	movzbl (%eax),%eax
    e674:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    e677:	8b 55 dc             	mov    -0x24(%ebp),%edx
    e67a:	8b 45 10             	mov    0x10(%ebp),%eax
    e67d:	01 d0                	add    %edx,%eax
    e67f:	0f b6 00             	movzbl (%eax),%eax
    e682:	88 45 d2             	mov    %al,-0x2e(%ebp)
    e685:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e688:	8d 50 01             	lea    0x1(%eax),%edx
    e68b:	8b 45 10             	mov    0x10(%ebp),%eax
    e68e:	01 d0                	add    %edx,%eax
    e690:	0f b6 00             	movzbl (%eax),%eax
    e693:	88 45 d1             	mov    %al,-0x2f(%ebp)
    e696:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e699:	8d 50 02             	lea    0x2(%eax),%edx
    e69c:	8b 45 10             	mov    0x10(%ebp),%eax
    e69f:	01 d0                	add    %edx,%eax
    e6a1:	0f b6 00             	movzbl (%eax),%eax
    e6a4:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    e6a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e6aa:	8b 45 08             	mov    0x8(%ebp),%eax
    e6ad:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e6b0:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    e6b4:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    e6b8:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    e6bc:	51                   	push   %ecx
    e6bd:	52                   	push   %edx
    e6be:	50                   	push   %eax
    e6bf:	e8 9e f4 ff ff       	call   db62 <paethPredictor>
    e6c4:	83 c4 0c             	add    $0xc,%esp
    e6c7:	89 c2                	mov    %eax,%edx
    e6c9:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    e6cd:	01 d0                	add    %edx,%eax
    e6cf:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    e6d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e6d4:	8d 50 01             	lea    0x1(%eax),%edx
    e6d7:	8b 45 08             	mov    0x8(%ebp),%eax
    e6da:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e6dd:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    e6e1:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    e6e5:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    e6e9:	51                   	push   %ecx
    e6ea:	52                   	push   %edx
    e6eb:	50                   	push   %eax
    e6ec:	e8 71 f4 ff ff       	call   db62 <paethPredictor>
    e6f1:	83 c4 0c             	add    $0xc,%esp
    e6f4:	89 c2                	mov    %eax,%edx
    e6f6:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    e6fa:	01 d0                	add    %edx,%eax
    e6fc:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    e6fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e701:	8d 50 02             	lea    0x2(%eax),%edx
    e704:	8b 45 08             	mov    0x8(%ebp),%eax
    e707:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e70a:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    e70e:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    e712:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    e716:	51                   	push   %ecx
    e717:	52                   	push   %edx
    e718:	50                   	push   %eax
    e719:	e8 44 f4 ff ff       	call   db62 <paethPredictor>
    e71e:	83 c4 0c             	add    $0xc,%esp
    e721:	89 c2                	mov    %eax,%edx
    e723:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    e727:	01 d0                	add    %edx,%eax
    e729:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    e72b:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    e72f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e732:	83 c0 02             	add    $0x2,%eax
    e735:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e738:	0f 8c a0 fe ff ff    	jl     e5de <unfilterScanline+0x467>
    e73e:	e9 5f 01 00 00       	jmp    e8a2 <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    e743:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    e747:	0f 8e 55 01 00 00    	jle    e8a2 <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    e74d:	e9 e0 00 00 00       	jmp    e832 <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    e752:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e755:	2b 45 14             	sub    0x14(%ebp),%eax
    e758:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    e75b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e75e:	8b 45 0c             	mov    0xc(%ebp),%eax
    e761:	01 d0                	add    %edx,%eax
    e763:	0f b6 00             	movzbl (%eax),%eax
    e766:	88 45 cb             	mov    %al,-0x35(%ebp)
    e769:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e76c:	8d 50 01             	lea    0x1(%eax),%edx
    e76f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e772:	01 d0                	add    %edx,%eax
    e774:	0f b6 00             	movzbl (%eax),%eax
    e777:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    e77a:	8b 55 cc             	mov    -0x34(%ebp),%edx
    e77d:	8b 45 08             	mov    0x8(%ebp),%eax
    e780:	01 d0                	add    %edx,%eax
    e782:	0f b6 00             	movzbl (%eax),%eax
    e785:	88 45 c9             	mov    %al,-0x37(%ebp)
    e788:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e78b:	8d 50 01             	lea    0x1(%eax),%edx
    e78e:	8b 45 08             	mov    0x8(%ebp),%eax
    e791:	01 d0                	add    %edx,%eax
    e793:	0f b6 00             	movzbl (%eax),%eax
    e796:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    e799:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e79c:	8b 45 10             	mov    0x10(%ebp),%eax
    e79f:	01 d0                	add    %edx,%eax
    e7a1:	0f b6 00             	movzbl (%eax),%eax
    e7a4:	88 45 c7             	mov    %al,-0x39(%ebp)
    e7a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e7aa:	8d 50 01             	lea    0x1(%eax),%edx
    e7ad:	8b 45 10             	mov    0x10(%ebp),%eax
    e7b0:	01 d0                	add    %edx,%eax
    e7b2:	0f b6 00             	movzbl (%eax),%eax
    e7b5:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    e7b8:	8b 55 cc             	mov    -0x34(%ebp),%edx
    e7bb:	8b 45 10             	mov    0x10(%ebp),%eax
    e7be:	01 d0                	add    %edx,%eax
    e7c0:	0f b6 00             	movzbl (%eax),%eax
    e7c3:	88 45 c5             	mov    %al,-0x3b(%ebp)
    e7c6:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e7c9:	8d 50 01             	lea    0x1(%eax),%edx
    e7cc:	8b 45 10             	mov    0x10(%ebp),%eax
    e7cf:	01 d0                	add    %edx,%eax
    e7d1:	0f b6 00             	movzbl (%eax),%eax
    e7d4:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    e7d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e7da:	8b 45 08             	mov    0x8(%ebp),%eax
    e7dd:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e7e0:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    e7e4:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    e7e8:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    e7ec:	51                   	push   %ecx
    e7ed:	52                   	push   %edx
    e7ee:	50                   	push   %eax
    e7ef:	e8 6e f3 ff ff       	call   db62 <paethPredictor>
    e7f4:	83 c4 0c             	add    $0xc,%esp
    e7f7:	89 c2                	mov    %eax,%edx
    e7f9:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    e7fd:	01 d0                	add    %edx,%eax
    e7ff:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    e801:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e804:	8d 50 01             	lea    0x1(%eax),%edx
    e807:	8b 45 08             	mov    0x8(%ebp),%eax
    e80a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e80d:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    e811:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    e815:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    e819:	51                   	push   %ecx
    e81a:	52                   	push   %edx
    e81b:	50                   	push   %eax
    e81c:	e8 41 f3 ff ff       	call   db62 <paethPredictor>
    e821:	83 c4 0c             	add    $0xc,%esp
    e824:	89 c2                	mov    %eax,%edx
    e826:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    e82a:	01 d0                	add    %edx,%eax
    e82c:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    e82e:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    e832:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e835:	83 c0 01             	add    $0x1,%eax
    e838:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e83b:	0f 8c 11 ff ff ff    	jl     e752 <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    e841:	eb 5f                	jmp    e8a2 <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    e843:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e846:	8b 45 08             	mov    0x8(%ebp),%eax
    e849:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e84c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e84f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e852:	01 d0                	add    %edx,%eax
    e854:	0f b6 00             	movzbl (%eax),%eax
    e857:	88 45 b7             	mov    %al,-0x49(%ebp)
    e85a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e85d:	2b 45 14             	sub    0x14(%ebp),%eax
    e860:	89 c2                	mov    %eax,%edx
    e862:	8b 45 10             	mov    0x10(%ebp),%eax
    e865:	01 d0                	add    %edx,%eax
    e867:	0f b6 00             	movzbl (%eax),%eax
    e86a:	0f b6 c8             	movzbl %al,%ecx
    e86d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e870:	8b 45 10             	mov    0x10(%ebp),%eax
    e873:	01 d0                	add    %edx,%eax
    e875:	0f b6 00             	movzbl (%eax),%eax
    e878:	0f b6 d0             	movzbl %al,%edx
    e87b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e87e:	2b 45 14             	sub    0x14(%ebp),%eax
    e881:	89 c6                	mov    %eax,%esi
    e883:	8b 45 08             	mov    0x8(%ebp),%eax
    e886:	01 f0                	add    %esi,%eax
    e888:	0f b6 00             	movzbl (%eax),%eax
    e88b:	0f b6 c0             	movzbl %al,%eax
    e88e:	51                   	push   %ecx
    e88f:	52                   	push   %edx
    e890:	50                   	push   %eax
    e891:	e8 cc f2 ff ff       	call   db62 <paethPredictor>
    e896:	83 c4 0c             	add    $0xc,%esp
    e899:	02 45 b7             	add    -0x49(%ebp),%al
    e89c:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    e89e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e8a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e8a5:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e8a8:	75 99                	jne    e843 <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    e8aa:	eb 6e                	jmp    e91a <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    e8ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e8b3:	eb 19                	jmp    e8ce <unfilterScanline+0x757>
          recon[i] = scanline[i];
    e8b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e8b8:	8b 45 08             	mov    0x8(%ebp),%eax
    e8bb:	01 c2                	add    %eax,%edx
    e8bd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e8c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    e8c3:	01 c8                	add    %ecx,%eax
    e8c5:	0f b6 00             	movzbl (%eax),%eax
    e8c8:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    e8ca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e8ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e8d1:	3b 45 14             	cmp    0x14(%ebp),%eax
    e8d4:	75 df                	jne    e8b5 <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    e8d6:	8b 45 14             	mov    0x14(%ebp),%eax
    e8d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e8dc:	eb 2b                	jmp    e909 <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    e8de:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e8e1:	8b 45 08             	mov    0x8(%ebp),%eax
    e8e4:	01 c2                	add    %eax,%edx
    e8e6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e8e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    e8ec:	01 c8                	add    %ecx,%eax
    e8ee:	0f b6 08             	movzbl (%eax),%ecx
    e8f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e8f4:	2b 45 14             	sub    0x14(%ebp),%eax
    e8f7:	89 c3                	mov    %eax,%ebx
    e8f9:	8b 45 08             	mov    0x8(%ebp),%eax
    e8fc:	01 d8                	add    %ebx,%eax
    e8fe:	0f b6 00             	movzbl (%eax),%eax
    e901:	01 c8                	add    %ecx,%eax
    e903:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    e905:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e909:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e90c:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e90f:	7c cd                	jl     e8de <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    e911:	eb 07                	jmp    e91a <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    e913:	b8 24 00 00 00       	mov    $0x24,%eax
    e918:	eb 05                	jmp    e91f <unfilterScanline+0x7a8>
  }
  return 0;
    e91a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e91f:	8d 65 f8             	lea    -0x8(%ebp),%esp
    e922:	5b                   	pop    %ebx
    e923:	5e                   	pop    %esi
    e924:	5d                   	pop    %ebp
    e925:	c3                   	ret    

0000e926 <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    e926:	55                   	push   %ebp
    e927:	89 e5                	mov    %esp,%ebp
    e929:	53                   	push   %ebx
    e92a:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    e92d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    e934:	8b 45 18             	mov    0x18(%ebp),%eax
    e937:	83 c0 07             	add    $0x7,%eax
    e93a:	c1 e8 03             	shr    $0x3,%eax
    e93d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    e940:	ff 75 18             	pushl  0x18(%ebp)
    e943:	6a 01                	push   $0x1
    e945:	ff 75 10             	pushl  0x10(%ebp)
    e948:	e8 d9 b1 ff ff       	call   9b26 <lodepng_get_raw_size_idat>
    e94d:	83 c4 0c             	add    $0xc,%esp
    e950:	83 e8 01             	sub    $0x1,%eax
    e953:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    e956:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e95d:	eb 6d                	jmp    e9cc <unfilter+0xa6>
    size_t outindex = linebytes * y;
    e95f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e962:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e966:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    e969:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e96c:	83 c0 01             	add    $0x1,%eax
    e96f:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e973:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    e976:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e979:	8b 45 0c             	mov    0xc(%ebp),%eax
    e97c:	01 d0                	add    %edx,%eax
    e97e:	0f b6 00             	movzbl (%eax),%eax
    e981:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    e984:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    e988:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e98b:	8d 4a 01             	lea    0x1(%edx),%ecx
    e98e:	8b 55 0c             	mov    0xc(%ebp),%edx
    e991:	01 d1                	add    %edx,%ecx
    e993:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    e996:	8b 55 08             	mov    0x8(%ebp),%edx
    e999:	01 da                	add    %ebx,%edx
    e99b:	ff 75 ec             	pushl  -0x14(%ebp)
    e99e:	50                   	push   %eax
    e99f:	ff 75 f0             	pushl  -0x10(%ebp)
    e9a2:	ff 75 f4             	pushl  -0xc(%ebp)
    e9a5:	51                   	push   %ecx
    e9a6:	52                   	push   %edx
    e9a7:	e8 cb f7 ff ff       	call   e177 <unfilterScanline>
    e9ac:	83 c4 18             	add    $0x18,%esp
    e9af:	89 45 dc             	mov    %eax,-0x24(%ebp)
    e9b2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    e9b6:	74 05                	je     e9bd <unfilter+0x97>
    e9b8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e9bb:	eb 1c                	jmp    e9d9 <unfilter+0xb3>

    prevline = &out[outindex];
    e9bd:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e9c0:	8b 45 08             	mov    0x8(%ebp),%eax
    e9c3:	01 d0                	add    %edx,%eax
    e9c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    e9c8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e9cc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e9cf:	3b 45 14             	cmp    0x14(%ebp),%eax
    e9d2:	72 8b                	jb     e95f <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    e9d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e9d9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    e9dc:	c9                   	leave  
    e9dd:	c3                   	ret    

0000e9de <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    e9de:	55                   	push   %ebp
    e9df:	89 e5                	mov    %esp,%ebp
    e9e1:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e9e7:	ff 75 18             	pushl  0x18(%ebp)
    e9ea:	ff 75 14             	pushl  0x14(%ebp)
    e9ed:	ff 75 10             	pushl  0x10(%ebp)
    e9f0:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    e9f6:	50                   	push   %eax
    e9f7:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    e9fd:	50                   	push   %eax
    e9fe:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    ea04:	50                   	push   %eax
    ea05:	8d 45 94             	lea    -0x6c(%ebp),%eax
    ea08:	50                   	push   %eax
    ea09:	8d 45 b0             	lea    -0x50(%ebp),%eax
    ea0c:	50                   	push   %eax
    ea0d:	e8 e6 f1 ff ff       	call   dbf8 <Adam7_getpassvalues>
    ea12:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    ea15:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    ea19:	0f 86 0a 01 00 00    	jbe    eb29 <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    ea1f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    ea26:	e9 ef 00 00 00       	jmp    eb1a <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    ea2b:	8b 45 18             	mov    0x18(%ebp),%eax
    ea2e:	c1 e8 03             	shr    $0x3,%eax
    ea31:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    ea34:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ea3b:	e9 c6 00 00 00       	jmp    eb06 <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    ea40:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ea47:	e9 a6 00 00 00       	jmp    eaf2 <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    ea4c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ea4f:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    ea56:	89 c1                	mov    %eax,%ecx
    ea58:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ea5b:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    ea5f:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    ea63:	89 c2                	mov    %eax,%edx
    ea65:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ea68:	01 c2                	add    %eax,%edx
    ea6a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ea6d:	0f af c2             	imul   %edx,%eax
    ea70:	01 c8                	add    %ecx,%eax
    ea72:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    ea75:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ea78:	8b 14 85 38 ac 01 00 	mov    0x1ac38(,%eax,4),%edx
    ea7f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ea82:	8b 04 85 70 ac 01 00 	mov    0x1ac70(,%eax,4),%eax
    ea89:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    ea8d:	01 d0                	add    %edx,%eax
    ea8f:	0f af 45 10          	imul   0x10(%ebp),%eax
    ea93:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    ea95:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ea98:	8b 04 85 54 ac 01 00 	mov    0x1ac54(,%eax,4),%eax
    ea9f:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    eaa3:	01 c2                	add    %eax,%edx
    eaa5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    eaa8:	8b 04 85 1c ac 01 00 	mov    0x1ac1c(,%eax,4),%eax
    eaaf:	01 c2                	add    %eax,%edx
    eab1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    eab4:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    eab7:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    eaba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    eac1:	eb 23                	jmp    eae6 <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    eac3:	8b 55 d8             	mov    -0x28(%ebp),%edx
    eac6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eac9:	01 c2                	add    %eax,%edx
    eacb:	8b 45 08             	mov    0x8(%ebp),%eax
    eace:	01 c2                	add    %eax,%edx
    ead0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    ead3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ead6:	01 c1                	add    %eax,%ecx
    ead8:	8b 45 0c             	mov    0xc(%ebp),%eax
    eadb:	01 c8                	add    %ecx,%eax
    eadd:	0f b6 00             	movzbl (%eax),%eax
    eae0:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    eae2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    eae6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    eae9:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    eaec:	72 d5                	jb     eac3 <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    eaee:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    eaf2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    eaf5:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    eaf9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    eafc:	0f 87 4a ff ff ff    	ja     ea4c <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    eb02:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    eb06:	8b 45 fc             	mov    -0x4(%ebp),%eax
    eb09:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    eb0d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    eb10:	0f 87 2a ff ff ff    	ja     ea40 <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    eb16:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    eb1a:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    eb1e:	0f 85 07 ff ff ff    	jne    ea2b <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    eb24:	e9 22 01 00 00       	jmp    ec4b <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    eb29:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    eb30:	e9 0c 01 00 00       	jmp    ec41 <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    eb35:	8b 45 fc             	mov    -0x4(%ebp),%eax
    eb38:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    eb3c:	0f af 45 18          	imul   0x18(%ebp),%eax
    eb40:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    eb43:	8b 45 18             	mov    0x18(%ebp),%eax
    eb46:	0f af 45 10          	imul   0x10(%ebp),%eax
    eb4a:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    eb4d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    eb54:	e9 d4 00 00 00       	jmp    ec2d <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    eb59:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    eb60:	e9 b4 00 00 00       	jmp    ec19 <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    eb65:	8b 45 fc             	mov    -0x4(%ebp),%eax
    eb68:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    eb6f:	c1 e0 03             	shl    $0x3,%eax
    eb72:	89 c1                	mov    %eax,%ecx
    eb74:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eb77:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    eb7b:	89 c2                	mov    %eax,%edx
    eb7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb80:	0f af 45 18          	imul   0x18(%ebp),%eax
    eb84:	01 d0                	add    %edx,%eax
    eb86:	01 c8                	add    %ecx,%eax
    eb88:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    eb8e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    eb91:	8b 14 85 38 ac 01 00 	mov    0x1ac38(,%eax,4),%edx
    eb98:	8b 45 fc             	mov    -0x4(%ebp),%eax
    eb9b:	8b 04 85 70 ac 01 00 	mov    0x1ac70(,%eax,4),%eax
    eba2:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    eba6:	01 d0                	add    %edx,%eax
    eba8:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    ebac:	89 c2                	mov    %eax,%edx
    ebae:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ebb1:	8b 0c 85 1c ac 01 00 	mov    0x1ac1c(,%eax,4),%ecx
    ebb8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ebbb:	8b 04 85 54 ac 01 00 	mov    0x1ac54(,%eax,4),%eax
    ebc2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    ebc6:	01 c8                	add    %ecx,%eax
    ebc8:	0f af 45 18          	imul   0x18(%ebp),%eax
    ebcc:	01 d0                	add    %edx,%eax
    ebce:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    ebd4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    ebdb:	eb 30                	jmp    ec0d <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    ebdd:	ff 75 0c             	pushl  0xc(%ebp)
    ebe0:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    ebe6:	50                   	push   %eax
    ebe7:	e8 1e a1 ff ff       	call   8d0a <readBitFromReversedStream>
    ebec:	83 c4 08             	add    $0x8,%esp
    ebef:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    ebf2:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    ebf6:	50                   	push   %eax
    ebf7:	ff 75 08             	pushl  0x8(%ebp)
    ebfa:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    ec00:	50                   	push   %eax
    ec01:	e8 86 a1 ff ff       	call   8d8c <setBitOfReversedStream>
    ec06:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    ec09:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    ec0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ec10:	3b 45 18             	cmp    0x18(%ebp),%eax
    ec13:	72 c8                	jb     ebdd <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    ec15:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ec19:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ec1c:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    ec20:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    ec23:	0f 87 3c ff ff ff    	ja     eb65 <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    ec29:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    ec2d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ec30:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    ec34:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    ec37:	0f 87 1c ff ff ff    	ja     eb59 <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    ec3d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    ec41:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    ec45:	0f 85 ea fe ff ff    	jne    eb35 <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    ec4b:	90                   	nop
    ec4c:	c9                   	leave  
    ec4d:	c3                   	ret    

0000ec4e <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    ec4e:	55                   	push   %ebp
    ec4f:	89 e5                	mov    %esp,%ebp
    ec51:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    ec54:	8b 45 14             	mov    0x14(%ebp),%eax
    ec57:	2b 45 10             	sub    0x10(%ebp),%eax
    ec5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    ec5d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    ec64:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    ec6b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    ec72:	eb 4a                	jmp    ecbe <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    ec74:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ec7b:	eb 2a                	jmp    eca7 <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    ec7d:	ff 75 0c             	pushl  0xc(%ebp)
    ec80:	8d 45 ec             	lea    -0x14(%ebp),%eax
    ec83:	50                   	push   %eax
    ec84:	e8 81 a0 ff ff       	call   8d0a <readBitFromReversedStream>
    ec89:	83 c4 08             	add    $0x8,%esp
    ec8c:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    ec8f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    ec93:	50                   	push   %eax
    ec94:	ff 75 08             	pushl  0x8(%ebp)
    ec97:	8d 45 e8             	lea    -0x18(%ebp),%eax
    ec9a:	50                   	push   %eax
    ec9b:	e8 ec a0 ff ff       	call   8d8c <setBitOfReversedStream>
    eca0:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    eca3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    eca7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ecaa:	3b 45 10             	cmp    0x10(%ebp),%eax
    ecad:	7c ce                	jl     ec7d <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    ecaf:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ecb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ecb5:	01 d0                	add    %edx,%eax
    ecb7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    ecba:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    ecbe:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ecc1:	3b 45 18             	cmp    0x18(%ebp),%eax
    ecc4:	72 ae                	jb     ec74 <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    ecc6:	90                   	nop
    ecc7:	c9                   	leave  
    ecc8:	c3                   	ret    

0000ecc9 <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    ecc9:	55                   	push   %ebp
    ecca:	89 e5                	mov    %esp,%ebp
    eccc:	57                   	push   %edi
    eccd:	56                   	push   %esi
    ecce:	53                   	push   %ebx
    eccf:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    ecd5:	8b 45 18             	mov    0x18(%ebp),%eax
    ecd8:	83 c0 0c             	add    $0xc,%eax
    ecdb:	50                   	push   %eax
    ecdc:	e8 e6 ac ff ff       	call   99c7 <lodepng_get_bpp>
    ece1:	83 c4 04             	add    $0x4,%esp
    ece4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    ece7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    eceb:	75 0a                	jne    ecf7 <postProcessScanlines+0x2e>
    eced:	b8 1f 00 00 00       	mov    $0x1f,%eax
    ecf2:	e9 c3 01 00 00       	jmp    eeba <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    ecf7:	8b 45 18             	mov    0x18(%ebp),%eax
    ecfa:	8b 40 08             	mov    0x8(%eax),%eax
    ecfd:	85 c0                	test   %eax,%eax
    ecff:	0f 85 a8 00 00 00    	jne    edad <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    ed05:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    ed09:	77 76                	ja     ed81 <postProcessScanlines+0xb8>
    ed0b:	8b 45 10             	mov    0x10(%ebp),%eax
    ed0e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    ed12:	89 c2                	mov    %eax,%edx
    ed14:	8b 45 10             	mov    0x10(%ebp),%eax
    ed17:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    ed1b:	83 c0 07             	add    $0x7,%eax
    ed1e:	c1 e8 03             	shr    $0x3,%eax
    ed21:	c1 e0 03             	shl    $0x3,%eax
    ed24:	39 c2                	cmp    %eax,%edx
    ed26:	74 59                	je     ed81 <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    ed28:	ff 75 ec             	pushl  -0x14(%ebp)
    ed2b:	ff 75 14             	pushl  0x14(%ebp)
    ed2e:	ff 75 10             	pushl  0x10(%ebp)
    ed31:	ff 75 0c             	pushl  0xc(%ebp)
    ed34:	ff 75 0c             	pushl  0xc(%ebp)
    ed37:	e8 ea fb ff ff       	call   e926 <unfilter>
    ed3c:	83 c4 14             	add    $0x14,%esp
    ed3f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    ed42:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ed46:	74 08                	je     ed50 <postProcessScanlines+0x87>
    ed48:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ed4b:	e9 6a 01 00 00       	jmp    eeba <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    ed50:	8b 45 10             	mov    0x10(%ebp),%eax
    ed53:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    ed57:	83 c0 07             	add    $0x7,%eax
    ed5a:	c1 e8 03             	shr    $0x3,%eax
    ed5d:	c1 e0 03             	shl    $0x3,%eax
    ed60:	89 c2                	mov    %eax,%edx
    ed62:	8b 45 10             	mov    0x10(%ebp),%eax
    ed65:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    ed69:	ff 75 14             	pushl  0x14(%ebp)
    ed6c:	52                   	push   %edx
    ed6d:	50                   	push   %eax
    ed6e:	ff 75 0c             	pushl  0xc(%ebp)
    ed71:	ff 75 08             	pushl  0x8(%ebp)
    ed74:	e8 d5 fe ff ff       	call   ec4e <removePaddingBits>
    ed79:	83 c4 14             	add    $0x14,%esp
    ed7c:	e9 34 01 00 00       	jmp    eeb5 <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    ed81:	ff 75 ec             	pushl  -0x14(%ebp)
    ed84:	ff 75 14             	pushl  0x14(%ebp)
    ed87:	ff 75 10             	pushl  0x10(%ebp)
    ed8a:	ff 75 0c             	pushl  0xc(%ebp)
    ed8d:	ff 75 08             	pushl  0x8(%ebp)
    ed90:	e8 91 fb ff ff       	call   e926 <unfilter>
    ed95:	83 c4 14             	add    $0x14,%esp
    ed98:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    ed9b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ed9f:	0f 84 10 01 00 00    	je     eeb5 <postProcessScanlines+0x1ec>
    eda5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    eda8:	e9 0d 01 00 00       	jmp    eeba <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    edad:	ff 75 ec             	pushl  -0x14(%ebp)
    edb0:	ff 75 14             	pushl  0x14(%ebp)
    edb3:	ff 75 10             	pushl  0x10(%ebp)
    edb6:	8d 45 88             	lea    -0x78(%ebp),%eax
    edb9:	50                   	push   %eax
    edba:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    edc0:	50                   	push   %eax
    edc1:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    edc7:	50                   	push   %eax
    edc8:	8d 45 a8             	lea    -0x58(%ebp),%eax
    edcb:	50                   	push   %eax
    edcc:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    edcf:	50                   	push   %eax
    edd0:	e8 23 ee ff ff       	call   dbf8 <Adam7_getpassvalues>
    edd5:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    edd8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    eddf:	e9 b0 00 00 00       	jmp    ee94 <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    ede4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ede7:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    edeb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    edee:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    edf2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    edf5:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    edfc:	89 cb                	mov    %ecx,%ebx
    edfe:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    ee01:	01 cb                	add    %ecx,%ebx
    ee03:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    ee06:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    ee0d:	89 ce                	mov    %ecx,%esi
    ee0f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    ee12:	01 f1                	add    %esi,%ecx
    ee14:	ff 75 ec             	pushl  -0x14(%ebp)
    ee17:	52                   	push   %edx
    ee18:	50                   	push   %eax
    ee19:	53                   	push   %ebx
    ee1a:	51                   	push   %ecx
    ee1b:	e8 06 fb ff ff       	call   e926 <unfilter>
    ee20:	83 c4 14             	add    $0x14,%esp
    ee23:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ee26:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ee2a:	74 08                	je     ee34 <postProcessScanlines+0x16b>
    ee2c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ee2f:	e9 86 00 00 00       	jmp    eeba <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    ee34:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    ee38:	77 56                	ja     ee90 <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    ee3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ee3d:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    ee41:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ee44:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    ee48:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    ee4c:	83 c2 07             	add    $0x7,%edx
    ee4f:	c1 ea 03             	shr    $0x3,%edx
    ee52:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    ee55:	89 d6                	mov    %edx,%esi
    ee57:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ee5a:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    ee5e:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    ee62:	89 d3                	mov    %edx,%ebx
    ee64:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ee67:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    ee6e:	89 d1                	mov    %edx,%ecx
    ee70:	8b 55 0c             	mov    0xc(%ebp),%edx
    ee73:	01 d1                	add    %edx,%ecx
    ee75:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ee78:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    ee7c:	89 d7                	mov    %edx,%edi
    ee7e:	8b 55 0c             	mov    0xc(%ebp),%edx
    ee81:	01 fa                	add    %edi,%edx
    ee83:	50                   	push   %eax
    ee84:	56                   	push   %esi
    ee85:	53                   	push   %ebx
    ee86:	51                   	push   %ecx
    ee87:	52                   	push   %edx
    ee88:	e8 c1 fd ff ff       	call   ec4e <removePaddingBits>
    ee8d:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    ee90:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ee94:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    ee98:	0f 85 46 ff ff ff    	jne    ede4 <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    ee9e:	ff 75 ec             	pushl  -0x14(%ebp)
    eea1:	ff 75 14             	pushl  0x14(%ebp)
    eea4:	ff 75 10             	pushl  0x10(%ebp)
    eea7:	ff 75 0c             	pushl  0xc(%ebp)
    eeaa:	ff 75 08             	pushl  0x8(%ebp)
    eead:	e8 2c fb ff ff       	call   e9de <Adam7_deinterlace>
    eeb2:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    eeb5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    eeba:	8d 65 f4             	lea    -0xc(%ebp),%esp
    eebd:	5b                   	pop    %ebx
    eebe:	5e                   	pop    %esi
    eebf:	5f                   	pop    %edi
    eec0:	5d                   	pop    %ebp
    eec1:	c3                   	ret    

0000eec2 <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    eec2:	55                   	push   %ebp
    eec3:	89 e5                	mov    %esp,%ebp
    eec5:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    eec8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    eecf:	8b 45 10             	mov    0x10(%ebp),%eax
    eed2:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    eed7:	f7 e2                	mul    %edx
    eed9:	89 d0                	mov    %edx,%eax
    eedb:	d1 e8                	shr    %eax
    eedd:	89 c2                	mov    %eax,%edx
    eedf:	8b 45 08             	mov    0x8(%ebp),%eax
    eee2:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    eee5:	8b 45 08             	mov    0x8(%ebp),%eax
    eee8:	8b 40 0c             	mov    0xc(%eax),%eax
    eeeb:	85 c0                	test   %eax,%eax
    eeed:	74 0d                	je     eefc <readChunk_PLTE+0x3a>
    eeef:	8b 45 08             	mov    0x8(%ebp),%eax
    eef2:	8b 40 0c             	mov    0xc(%eax),%eax
    eef5:	3d 00 01 00 00       	cmp    $0x100,%eax
    eefa:	7e 0a                	jle    ef06 <readChunk_PLTE+0x44>
    eefc:	b8 26 00 00 00       	mov    $0x26,%eax
    ef01:	e9 da 00 00 00       	jmp    efe0 <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    ef06:	83 ec 0c             	sub    $0xc,%esp
    ef09:	ff 75 08             	pushl  0x8(%ebp)
    ef0c:	e8 02 a7 ff ff       	call   9613 <lodepng_color_mode_alloc_palette>
    ef11:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    ef14:	8b 45 08             	mov    0x8(%ebp),%eax
    ef17:	8b 40 08             	mov    0x8(%eax),%eax
    ef1a:	85 c0                	test   %eax,%eax
    ef1c:	75 1e                	jne    ef3c <readChunk_PLTE+0x7a>
    ef1e:	8b 45 08             	mov    0x8(%ebp),%eax
    ef21:	8b 40 0c             	mov    0xc(%eax),%eax
    ef24:	85 c0                	test   %eax,%eax
    ef26:	74 14                	je     ef3c <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    ef28:	8b 45 08             	mov    0x8(%ebp),%eax
    ef2b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    ef32:	b8 53 00 00 00       	mov    $0x53,%eax
    ef37:	e9 a4 00 00 00       	jmp    efe0 <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    ef3c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ef43:	e9 84 00 00 00       	jmp    efcc <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    ef48:	8b 45 08             	mov    0x8(%ebp),%eax
    ef4b:	8b 40 08             	mov    0x8(%eax),%eax
    ef4e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ef51:	c1 e2 02             	shl    $0x2,%edx
    ef54:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    ef57:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ef5a:	8d 50 01             	lea    0x1(%eax),%edx
    ef5d:	89 55 f4             	mov    %edx,-0xc(%ebp)
    ef60:	8b 55 0c             	mov    0xc(%ebp),%edx
    ef63:	01 d0                	add    %edx,%eax
    ef65:	0f b6 00             	movzbl (%eax),%eax
    ef68:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    ef6a:	8b 45 08             	mov    0x8(%ebp),%eax
    ef6d:	8b 40 08             	mov    0x8(%eax),%eax
    ef70:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ef73:	c1 e2 02             	shl    $0x2,%edx
    ef76:	83 c2 01             	add    $0x1,%edx
    ef79:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    ef7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ef7f:	8d 50 01             	lea    0x1(%eax),%edx
    ef82:	89 55 f4             	mov    %edx,-0xc(%ebp)
    ef85:	8b 55 0c             	mov    0xc(%ebp),%edx
    ef88:	01 d0                	add    %edx,%eax
    ef8a:	0f b6 00             	movzbl (%eax),%eax
    ef8d:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    ef8f:	8b 45 08             	mov    0x8(%ebp),%eax
    ef92:	8b 40 08             	mov    0x8(%eax),%eax
    ef95:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ef98:	c1 e2 02             	shl    $0x2,%edx
    ef9b:	83 c2 02             	add    $0x2,%edx
    ef9e:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    efa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    efa4:	8d 50 01             	lea    0x1(%eax),%edx
    efa7:	89 55 f4             	mov    %edx,-0xc(%ebp)
    efaa:	8b 55 0c             	mov    0xc(%ebp),%edx
    efad:	01 d0                	add    %edx,%eax
    efaf:	0f b6 00             	movzbl (%eax),%eax
    efb2:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    efb4:	8b 45 08             	mov    0x8(%ebp),%eax
    efb7:	8b 40 08             	mov    0x8(%eax),%eax
    efba:	8b 55 f0             	mov    -0x10(%ebp),%edx
    efbd:	c1 e2 02             	shl    $0x2,%edx
    efc0:	83 c2 03             	add    $0x3,%edx
    efc3:	01 d0                	add    %edx,%eax
    efc5:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    efc8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    efcc:	8b 45 08             	mov    0x8(%ebp),%eax
    efcf:	8b 40 0c             	mov    0xc(%eax),%eax
    efd2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    efd5:	0f 85 6d ff ff ff    	jne    ef48 <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    efdb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    efe0:	c9                   	leave  
    efe1:	c3                   	ret    

0000efe2 <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    efe2:	55                   	push   %ebp
    efe3:	89 e5                	mov    %esp,%ebp
    efe5:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    efe8:	8b 45 08             	mov    0x8(%ebp),%eax
    efeb:	8b 00                	mov    (%eax),%eax
    efed:	83 f8 03             	cmp    $0x3,%eax
    eff0:	75 4d                	jne    f03f <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    eff2:	8b 45 08             	mov    0x8(%ebp),%eax
    eff5:	8b 40 0c             	mov    0xc(%eax),%eax
    eff8:	3b 45 10             	cmp    0x10(%ebp),%eax
    effb:	7d 0a                	jge    f007 <readChunk_tRNS+0x25>
    effd:	b8 27 00 00 00       	mov    $0x27,%eax
    f002:	e9 3c 01 00 00       	jmp    f143 <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    f007:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    f00e:	eb 22                	jmp    f032 <readChunk_tRNS+0x50>
    f010:	8b 45 08             	mov    0x8(%ebp),%eax
    f013:	8b 40 08             	mov    0x8(%eax),%eax
    f016:	8b 55 fc             	mov    -0x4(%ebp),%edx
    f019:	c1 e2 02             	shl    $0x2,%edx
    f01c:	83 c2 03             	add    $0x3,%edx
    f01f:	01 c2                	add    %eax,%edx
    f021:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    f024:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f027:	01 c8                	add    %ecx,%eax
    f029:	0f b6 00             	movzbl (%eax),%eax
    f02c:	88 02                	mov    %al,(%edx)
    f02e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    f032:	8b 45 10             	mov    0x10(%ebp),%eax
    f035:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    f038:	75 d6                	jne    f010 <readChunk_tRNS+0x2e>
    f03a:	e9 ff 00 00 00       	jmp    f13e <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    f03f:	8b 45 08             	mov    0x8(%ebp),%eax
    f042:	8b 00                	mov    (%eax),%eax
    f044:	85 c0                	test   %eax,%eax
    f046:	75 59                	jne    f0a1 <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    f048:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    f04c:	74 0a                	je     f058 <readChunk_tRNS+0x76>
    f04e:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f053:	e9 eb 00 00 00       	jmp    f143 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    f058:	8b 45 08             	mov    0x8(%ebp),%eax
    f05b:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    f062:	8b 45 0c             	mov    0xc(%ebp),%eax
    f065:	0f b6 00             	movzbl (%eax),%eax
    f068:	0f b6 c0             	movzbl %al,%eax
    f06b:	c1 e0 08             	shl    $0x8,%eax
    f06e:	89 c2                	mov    %eax,%edx
    f070:	8b 45 0c             	mov    0xc(%ebp),%eax
    f073:	83 c0 01             	add    $0x1,%eax
    f076:	0f b6 00             	movzbl (%eax),%eax
    f079:	0f b6 c0             	movzbl %al,%eax
    f07c:	01 c2                	add    %eax,%edx
    f07e:	8b 45 08             	mov    0x8(%ebp),%eax
    f081:	89 50 1c             	mov    %edx,0x1c(%eax)
    f084:	8b 45 08             	mov    0x8(%ebp),%eax
    f087:	8b 50 1c             	mov    0x1c(%eax),%edx
    f08a:	8b 45 08             	mov    0x8(%ebp),%eax
    f08d:	89 50 18             	mov    %edx,0x18(%eax)
    f090:	8b 45 08             	mov    0x8(%ebp),%eax
    f093:	8b 50 18             	mov    0x18(%eax),%edx
    f096:	8b 45 08             	mov    0x8(%ebp),%eax
    f099:	89 50 14             	mov    %edx,0x14(%eax)
    f09c:	e9 9d 00 00 00       	jmp    f13e <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    f0a1:	8b 45 08             	mov    0x8(%ebp),%eax
    f0a4:	8b 00                	mov    (%eax),%eax
    f0a6:	83 f8 02             	cmp    $0x2,%eax
    f0a9:	0f 85 88 00 00 00    	jne    f137 <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    f0af:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    f0b3:	74 0a                	je     f0bf <readChunk_tRNS+0xdd>
    f0b5:	b8 29 00 00 00       	mov    $0x29,%eax
    f0ba:	e9 84 00 00 00       	jmp    f143 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    f0bf:	8b 45 08             	mov    0x8(%ebp),%eax
    f0c2:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    f0c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0cc:	0f b6 00             	movzbl (%eax),%eax
    f0cf:	0f b6 c0             	movzbl %al,%eax
    f0d2:	c1 e0 08             	shl    $0x8,%eax
    f0d5:	89 c2                	mov    %eax,%edx
    f0d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0da:	83 c0 01             	add    $0x1,%eax
    f0dd:	0f b6 00             	movzbl (%eax),%eax
    f0e0:	0f b6 c0             	movzbl %al,%eax
    f0e3:	01 c2                	add    %eax,%edx
    f0e5:	8b 45 08             	mov    0x8(%ebp),%eax
    f0e8:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    f0eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0ee:	83 c0 02             	add    $0x2,%eax
    f0f1:	0f b6 00             	movzbl (%eax),%eax
    f0f4:	0f b6 c0             	movzbl %al,%eax
    f0f7:	c1 e0 08             	shl    $0x8,%eax
    f0fa:	89 c2                	mov    %eax,%edx
    f0fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0ff:	83 c0 03             	add    $0x3,%eax
    f102:	0f b6 00             	movzbl (%eax),%eax
    f105:	0f b6 c0             	movzbl %al,%eax
    f108:	01 c2                	add    %eax,%edx
    f10a:	8b 45 08             	mov    0x8(%ebp),%eax
    f10d:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    f110:	8b 45 0c             	mov    0xc(%ebp),%eax
    f113:	83 c0 04             	add    $0x4,%eax
    f116:	0f b6 00             	movzbl (%eax),%eax
    f119:	0f b6 c0             	movzbl %al,%eax
    f11c:	c1 e0 08             	shl    $0x8,%eax
    f11f:	89 c2                	mov    %eax,%edx
    f121:	8b 45 0c             	mov    0xc(%ebp),%eax
    f124:	83 c0 05             	add    $0x5,%eax
    f127:	0f b6 00             	movzbl (%eax),%eax
    f12a:	0f b6 c0             	movzbl %al,%eax
    f12d:	01 c2                	add    %eax,%edx
    f12f:	8b 45 08             	mov    0x8(%ebp),%eax
    f132:	89 50 1c             	mov    %edx,0x1c(%eax)
    f135:	eb 07                	jmp    f13e <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    f137:	b8 2a 00 00 00       	mov    $0x2a,%eax
    f13c:	eb 05                	jmp    f143 <readChunk_tRNS+0x161>

  return 0; /* OK */
    f13e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f143:	c9                   	leave  
    f144:	c3                   	ret    

0000f145 <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f145:	55                   	push   %ebp
    f146:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    f148:	8b 45 08             	mov    0x8(%ebp),%eax
    f14b:	8b 40 0c             	mov    0xc(%eax),%eax
    f14e:	83 f8 03             	cmp    $0x3,%eax
    f151:	75 63                	jne    f1b6 <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    f153:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f157:	74 0a                	je     f163 <readChunk_bKGD+0x1e>
    f159:	b8 2b 00 00 00       	mov    $0x2b,%eax
    f15e:	e9 63 01 00 00       	jmp    f2c6 <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    f163:	8b 45 0c             	mov    0xc(%ebp),%eax
    f166:	0f b6 00             	movzbl (%eax),%eax
    f169:	0f b6 d0             	movzbl %al,%edx
    f16c:	8b 45 08             	mov    0x8(%ebp),%eax
    f16f:	8b 40 18             	mov    0x18(%eax),%eax
    f172:	39 c2                	cmp    %eax,%edx
    f174:	7c 0a                	jl     f180 <readChunk_bKGD+0x3b>
    f176:	b8 67 00 00 00       	mov    $0x67,%eax
    f17b:	e9 46 01 00 00       	jmp    f2c6 <readChunk_bKGD+0x181>

    info->background_defined = 1;
    f180:	8b 45 08             	mov    0x8(%ebp),%eax
    f183:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    f18a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f18d:	0f b6 00             	movzbl (%eax),%eax
    f190:	0f b6 d0             	movzbl %al,%edx
    f193:	8b 45 08             	mov    0x8(%ebp),%eax
    f196:	89 50 38             	mov    %edx,0x38(%eax)
    f199:	8b 45 08             	mov    0x8(%ebp),%eax
    f19c:	8b 50 38             	mov    0x38(%eax),%edx
    f19f:	8b 45 08             	mov    0x8(%ebp),%eax
    f1a2:	89 50 34             	mov    %edx,0x34(%eax)
    f1a5:	8b 45 08             	mov    0x8(%ebp),%eax
    f1a8:	8b 50 34             	mov    0x34(%eax),%edx
    f1ab:	8b 45 08             	mov    0x8(%ebp),%eax
    f1ae:	89 50 30             	mov    %edx,0x30(%eax)
    f1b1:	e9 0b 01 00 00       	jmp    f2c1 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    f1b6:	8b 45 08             	mov    0x8(%ebp),%eax
    f1b9:	8b 40 0c             	mov    0xc(%eax),%eax
    f1bc:	85 c0                	test   %eax,%eax
    f1be:	74 0b                	je     f1cb <readChunk_bKGD+0x86>
    f1c0:	8b 45 08             	mov    0x8(%ebp),%eax
    f1c3:	8b 40 0c             	mov    0xc(%eax),%eax
    f1c6:	83 f8 04             	cmp    $0x4,%eax
    f1c9:	75 59                	jne    f224 <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    f1cb:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    f1cf:	74 0a                	je     f1db <readChunk_bKGD+0x96>
    f1d1:	b8 2c 00 00 00       	mov    $0x2c,%eax
    f1d6:	e9 eb 00 00 00       	jmp    f2c6 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    f1db:	8b 45 08             	mov    0x8(%ebp),%eax
    f1de:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    f1e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1e8:	0f b6 00             	movzbl (%eax),%eax
    f1eb:	0f b6 c0             	movzbl %al,%eax
    f1ee:	c1 e0 08             	shl    $0x8,%eax
    f1f1:	89 c2                	mov    %eax,%edx
    f1f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1f6:	83 c0 01             	add    $0x1,%eax
    f1f9:	0f b6 00             	movzbl (%eax),%eax
    f1fc:	0f b6 c0             	movzbl %al,%eax
    f1ff:	01 c2                	add    %eax,%edx
    f201:	8b 45 08             	mov    0x8(%ebp),%eax
    f204:	89 50 38             	mov    %edx,0x38(%eax)
    f207:	8b 45 08             	mov    0x8(%ebp),%eax
    f20a:	8b 50 38             	mov    0x38(%eax),%edx
    f20d:	8b 45 08             	mov    0x8(%ebp),%eax
    f210:	89 50 34             	mov    %edx,0x34(%eax)
    f213:	8b 45 08             	mov    0x8(%ebp),%eax
    f216:	8b 50 34             	mov    0x34(%eax),%edx
    f219:	8b 45 08             	mov    0x8(%ebp),%eax
    f21c:	89 50 30             	mov    %edx,0x30(%eax)
    f21f:	e9 9d 00 00 00       	jmp    f2c1 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    f224:	8b 45 08             	mov    0x8(%ebp),%eax
    f227:	8b 40 0c             	mov    0xc(%eax),%eax
    f22a:	83 f8 02             	cmp    $0x2,%eax
    f22d:	74 0f                	je     f23e <readChunk_bKGD+0xf9>
    f22f:	8b 45 08             	mov    0x8(%ebp),%eax
    f232:	8b 40 0c             	mov    0xc(%eax),%eax
    f235:	83 f8 06             	cmp    $0x6,%eax
    f238:	0f 85 83 00 00 00    	jne    f2c1 <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    f23e:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    f242:	74 07                	je     f24b <readChunk_bKGD+0x106>
    f244:	b8 2d 00 00 00       	mov    $0x2d,%eax
    f249:	eb 7b                	jmp    f2c6 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    f24b:	8b 45 08             	mov    0x8(%ebp),%eax
    f24e:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    f255:	8b 45 0c             	mov    0xc(%ebp),%eax
    f258:	0f b6 00             	movzbl (%eax),%eax
    f25b:	0f b6 c0             	movzbl %al,%eax
    f25e:	c1 e0 08             	shl    $0x8,%eax
    f261:	89 c2                	mov    %eax,%edx
    f263:	8b 45 0c             	mov    0xc(%ebp),%eax
    f266:	83 c0 01             	add    $0x1,%eax
    f269:	0f b6 00             	movzbl (%eax),%eax
    f26c:	0f b6 c0             	movzbl %al,%eax
    f26f:	01 c2                	add    %eax,%edx
    f271:	8b 45 08             	mov    0x8(%ebp),%eax
    f274:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    f277:	8b 45 0c             	mov    0xc(%ebp),%eax
    f27a:	83 c0 02             	add    $0x2,%eax
    f27d:	0f b6 00             	movzbl (%eax),%eax
    f280:	0f b6 c0             	movzbl %al,%eax
    f283:	c1 e0 08             	shl    $0x8,%eax
    f286:	89 c2                	mov    %eax,%edx
    f288:	8b 45 0c             	mov    0xc(%ebp),%eax
    f28b:	83 c0 03             	add    $0x3,%eax
    f28e:	0f b6 00             	movzbl (%eax),%eax
    f291:	0f b6 c0             	movzbl %al,%eax
    f294:	01 c2                	add    %eax,%edx
    f296:	8b 45 08             	mov    0x8(%ebp),%eax
    f299:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    f29c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f29f:	83 c0 04             	add    $0x4,%eax
    f2a2:	0f b6 00             	movzbl (%eax),%eax
    f2a5:	0f b6 c0             	movzbl %al,%eax
    f2a8:	c1 e0 08             	shl    $0x8,%eax
    f2ab:	89 c2                	mov    %eax,%edx
    f2ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2b0:	83 c0 05             	add    $0x5,%eax
    f2b3:	0f b6 00             	movzbl (%eax),%eax
    f2b6:	0f b6 c0             	movzbl %al,%eax
    f2b9:	01 c2                	add    %eax,%edx
    f2bb:	8b 45 08             	mov    0x8(%ebp),%eax
    f2be:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    f2c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f2c6:	5d                   	pop    %ebp
    f2c7:	c3                   	ret    

0000f2c8 <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f2c8:	55                   	push   %ebp
    f2c9:	89 e5                	mov    %esp,%ebp
    f2cb:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    f2ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    f2d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f2dc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    f2e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f2e7:	0f 85 06 01 00 00    	jne    f3f3 <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    f2ed:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    f2f4:	eb 04                	jmp    f2fa <readChunk_tEXt+0x32>
    f2f6:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    f2fa:	8b 45 10             	mov    0x10(%ebp),%eax
    f2fd:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f300:	73 0f                	jae    f311 <readChunk_tEXt+0x49>
    f302:	8b 55 0c             	mov    0xc(%ebp),%edx
    f305:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f308:	01 d0                	add    %edx,%eax
    f30a:	0f b6 00             	movzbl (%eax),%eax
    f30d:	84 c0                	test   %al,%al
    f30f:	75 e5                	jne    f2f6 <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    f311:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    f315:	74 06                	je     f31d <readChunk_tEXt+0x55>
    f317:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    f31b:	76 0c                	jbe    f329 <readChunk_tEXt+0x61>
    f31d:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    f324:	e9 ca 00 00 00       	jmp    f3f3 <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    f329:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f32c:	83 c0 01             	add    $0x1,%eax
    f32f:	83 ec 0c             	sub    $0xc,%esp
    f332:	50                   	push   %eax
    f333:	e8 73 4b ff ff       	call   3eab <lodepng_malloc>
    f338:	83 c4 10             	add    $0x10,%esp
    f33b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    f33e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f342:	75 0c                	jne    f350 <readChunk_tEXt+0x88>
    f344:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f34b:	e9 a3 00 00 00       	jmp    f3f3 <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    f350:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f353:	83 ec 04             	sub    $0x4,%esp
    f356:	50                   	push   %eax
    f357:	ff 75 0c             	pushl  0xc(%ebp)
    f35a:	ff 75 f0             	pushl  -0x10(%ebp)
    f35d:	e8 87 4b ff ff       	call   3ee9 <lodepng_memcpy>
    f362:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    f365:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f368:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f36b:	01 d0                	add    %edx,%eax
    f36d:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    f370:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f373:	83 c0 01             	add    $0x1,%eax
    f376:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    f379:	8b 45 10             	mov    0x10(%ebp),%eax
    f37c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    f37f:	72 08                	jb     f389 <readChunk_tEXt+0xc1>
    f381:	8b 45 10             	mov    0x10(%ebp),%eax
    f384:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    f387:	eb 05                	jmp    f38e <readChunk_tEXt+0xc6>
    f389:	b8 00 00 00 00       	mov    $0x0,%eax
    f38e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    f391:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f394:	83 c0 01             	add    $0x1,%eax
    f397:	83 ec 0c             	sub    $0xc,%esp
    f39a:	50                   	push   %eax
    f39b:	e8 0b 4b ff ff       	call   3eab <lodepng_malloc>
    f3a0:	83 c4 10             	add    $0x10,%esp
    f3a3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    f3a6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f3aa:	75 09                	jne    f3b5 <readChunk_tEXt+0xed>
    f3ac:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f3b3:	eb 3e                	jmp    f3f3 <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    f3b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f3b8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    f3bb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f3be:	01 ca                	add    %ecx,%edx
    f3c0:	83 ec 04             	sub    $0x4,%esp
    f3c3:	50                   	push   %eax
    f3c4:	52                   	push   %edx
    f3c5:	ff 75 ec             	pushl  -0x14(%ebp)
    f3c8:	e8 1c 4b ff ff       	call   3ee9 <lodepng_memcpy>
    f3cd:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    f3d0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f3d3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f3d6:	01 d0                	add    %edx,%eax
    f3d8:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    f3db:	83 ec 04             	sub    $0x4,%esp
    f3de:	ff 75 ec             	pushl  -0x14(%ebp)
    f3e1:	ff 75 f0             	pushl  -0x10(%ebp)
    f3e4:	ff 75 08             	pushl  0x8(%ebp)
    f3e7:	e8 3f ac ff ff       	call   a02b <lodepng_add_text>
    f3ec:	83 c4 10             	add    $0x10,%esp
    f3ef:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    f3f2:	90                   	nop
  }

  lodepng_free(key);
    f3f3:	83 ec 0c             	sub    $0xc,%esp
    f3f6:	ff 75 f0             	pushl  -0x10(%ebp)
    f3f9:	e8 ce 4a ff ff       	call   3ecc <lodepng_free>
    f3fe:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    f401:	83 ec 0c             	sub    $0xc,%esp
    f404:	ff 75 ec             	pushl  -0x14(%ebp)
    f407:	e8 c0 4a ff ff       	call   3ecc <lodepng_free>
    f40c:	83 c4 10             	add    $0x10,%esp

  return error;
    f40f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f412:	c9                   	leave  
    f413:	c3                   	ret    

0000f414 <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f414:	55                   	push   %ebp
    f415:	89 e5                	mov    %esp,%ebp
    f417:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    f41a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f421:	8b 45 0c             	mov    0xc(%ebp),%eax
    f424:	8b 10                	mov    (%eax),%edx
    f426:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f429:	8b 50 04             	mov    0x4(%eax),%edx
    f42c:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f42f:	8b 50 08             	mov    0x8(%eax),%edx
    f432:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f435:	8b 50 0c             	mov    0xc(%eax),%edx
    f438:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f43b:	8b 50 10             	mov    0x10(%eax),%edx
    f43e:	89 55 e0             	mov    %edx,-0x20(%ebp)
    f441:	8b 40 14             	mov    0x14(%eax),%eax
    f444:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    f447:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    f44e:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    f455:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    f45c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f460:	0f 85 48 01 00 00    	jne    f5ae <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f466:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f46d:	eb 04                	jmp    f473 <readChunk_zTXt+0x5f>
    f46f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f473:	8b 45 14             	mov    0x14(%ebp),%eax
    f476:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    f479:	73 0f                	jae    f48a <readChunk_zTXt+0x76>
    f47b:	8b 55 10             	mov    0x10(%ebp),%edx
    f47e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f481:	01 d0                	add    %edx,%eax
    f483:	0f b6 00             	movzbl (%eax),%eax
    f486:	84 c0                	test   %al,%al
    f488:	75 e5                	jne    f46f <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    f48a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f48d:	8d 50 02             	lea    0x2(%eax),%edx
    f490:	8b 45 14             	mov    0x14(%ebp),%eax
    f493:	39 c2                	cmp    %eax,%edx
    f495:	72 0c                	jb     f4a3 <readChunk_zTXt+0x8f>
    f497:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    f49e:	e9 0b 01 00 00       	jmp    f5ae <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    f4a3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f4a7:	74 06                	je     f4af <readChunk_zTXt+0x9b>
    f4a9:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    f4ad:	76 0c                	jbe    f4bb <readChunk_zTXt+0xa7>
    f4af:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    f4b6:	e9 f3 00 00 00       	jmp    f5ae <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    f4bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f4be:	83 c0 01             	add    $0x1,%eax
    f4c1:	83 ec 0c             	sub    $0xc,%esp
    f4c4:	50                   	push   %eax
    f4c5:	e8 e1 49 ff ff       	call   3eab <lodepng_malloc>
    f4ca:	83 c4 10             	add    $0x10,%esp
    f4cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    f4d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f4d4:	75 0c                	jne    f4e2 <readChunk_zTXt+0xce>
    f4d6:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f4dd:	e9 cc 00 00 00       	jmp    f5ae <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    f4e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f4e5:	83 ec 04             	sub    $0x4,%esp
    f4e8:	50                   	push   %eax
    f4e9:	ff 75 10             	pushl  0x10(%ebp)
    f4ec:	ff 75 ec             	pushl  -0x14(%ebp)
    f4ef:	e8 f5 49 ff ff       	call   3ee9 <lodepng_memcpy>
    f4f4:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    f4f7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f4fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f4fd:	01 d0                	add    %edx,%eax
    f4ff:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    f502:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f505:	8d 50 01             	lea    0x1(%eax),%edx
    f508:	8b 45 10             	mov    0x10(%ebp),%eax
    f50b:	01 d0                	add    %edx,%eax
    f50d:	0f b6 00             	movzbl (%eax),%eax
    f510:	84 c0                	test   %al,%al
    f512:	74 0c                	je     f520 <readChunk_zTXt+0x10c>
    f514:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    f51b:	e9 8e 00 00 00       	jmp    f5ae <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    f520:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f523:	83 c0 02             	add    $0x2,%eax
    f526:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    f529:	8b 45 14             	mov    0x14(%ebp),%eax
    f52c:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f52f:	76 09                	jbe    f53a <readChunk_zTXt+0x126>
    f531:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    f538:	eb 74                	jmp    f5ae <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    f53a:	8b 45 14             	mov    0x14(%ebp),%eax
    f53d:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f540:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    f543:	8b 45 0c             	mov    0xc(%ebp),%eax
    f546:	8b 40 30             	mov    0x30(%eax),%eax
    f549:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    f54c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f54f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f552:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f555:	01 d1                	add    %edx,%ecx
    f557:	83 ec 08             	sub    $0x8,%esp
    f55a:	8d 55 d0             	lea    -0x30(%ebp),%edx
    f55d:	52                   	push   %edx
    f55e:	50                   	push   %eax
    f55f:	51                   	push   %ecx
    f560:	6a 00                	push   $0x0
    f562:	8d 45 c8             	lea    -0x38(%ebp),%eax
    f565:	50                   	push   %eax
    f566:	8d 45 cc             	lea    -0x34(%ebp),%eax
    f569:	50                   	push   %eax
    f56a:	e8 f7 93 ff ff       	call   8966 <zlib_decompress>
    f56f:	83 c4 20             	add    $0x20,%esp
    f572:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    f575:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f579:	74 11                	je     f58c <readChunk_zTXt+0x178>
    f57b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f57e:	8b 45 c8             	mov    -0x38(%ebp),%eax
    f581:	39 c2                	cmp    %eax,%edx
    f583:	7d 07                	jge    f58c <readChunk_zTXt+0x178>
    f585:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    f58c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f590:	75 1b                	jne    f5ad <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    f592:	8b 55 c8             	mov    -0x38(%ebp),%edx
    f595:	8b 45 cc             	mov    -0x34(%ebp),%eax
    f598:	52                   	push   %edx
    f599:	50                   	push   %eax
    f59a:	ff 75 ec             	pushl  -0x14(%ebp)
    f59d:	ff 75 08             	pushl  0x8(%ebp)
    f5a0:	e8 60 a9 ff ff       	call   9f05 <lodepng_add_text_sized>
    f5a5:	83 c4 10             	add    $0x10,%esp
    f5a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    f5ab:	eb 01                	jmp    f5ae <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    f5ad:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    f5ae:	83 ec 0c             	sub    $0xc,%esp
    f5b1:	ff 75 ec             	pushl  -0x14(%ebp)
    f5b4:	e8 13 49 ff ff       	call   3ecc <lodepng_free>
    f5b9:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    f5bc:	8b 45 cc             	mov    -0x34(%ebp),%eax
    f5bf:	83 ec 0c             	sub    $0xc,%esp
    f5c2:	50                   	push   %eax
    f5c3:	e8 04 49 ff ff       	call   3ecc <lodepng_free>
    f5c8:	83 c4 10             	add    $0x10,%esp

  return error;
    f5cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f5ce:	c9                   	leave  
    f5cf:	c3                   	ret    

0000f5d0 <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f5d0:	55                   	push   %ebp
    f5d1:	89 e5                	mov    %esp,%ebp
    f5d3:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    f5d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f5dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5e0:	8b 10                	mov    (%eax),%edx
    f5e2:	89 55 c0             	mov    %edx,-0x40(%ebp)
    f5e5:	8b 50 04             	mov    0x4(%eax),%edx
    f5e8:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    f5eb:	8b 50 08             	mov    0x8(%eax),%edx
    f5ee:	89 55 c8             	mov    %edx,-0x38(%ebp)
    f5f1:	8b 50 0c             	mov    0xc(%eax),%edx
    f5f4:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f5f7:	8b 50 10             	mov    0x10(%eax),%edx
    f5fa:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f5fd:	8b 40 14             	mov    0x14(%eax),%eax
    f600:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    f603:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    f60a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    f611:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    f618:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f61c:	0f 85 d5 02 00 00    	jne    f8f7 <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    f622:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    f626:	7f 0c                	jg     f634 <readChunk_iTXt+0x64>
    f628:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    f62f:	e9 c3 02 00 00       	jmp    f8f7 <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f634:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f63b:	eb 04                	jmp    f641 <readChunk_iTXt+0x71>
    f63d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f641:	8b 45 14             	mov    0x14(%ebp),%eax
    f644:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f647:	73 0f                	jae    f658 <readChunk_iTXt+0x88>
    f649:	8b 55 10             	mov    0x10(%ebp),%edx
    f64c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f64f:	01 d0                	add    %edx,%eax
    f651:	0f b6 00             	movzbl (%eax),%eax
    f654:	84 c0                	test   %al,%al
    f656:	75 e5                	jne    f63d <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    f658:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f65b:	8d 50 03             	lea    0x3(%eax),%edx
    f65e:	8b 45 14             	mov    0x14(%ebp),%eax
    f661:	39 c2                	cmp    %eax,%edx
    f663:	72 0c                	jb     f671 <readChunk_iTXt+0xa1>
    f665:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    f66c:	e9 86 02 00 00       	jmp    f8f7 <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    f671:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f675:	74 06                	je     f67d <readChunk_iTXt+0xad>
    f677:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f67b:	76 0c                	jbe    f689 <readChunk_iTXt+0xb9>
    f67d:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    f684:	e9 6e 02 00 00       	jmp    f8f7 <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    f689:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f68c:	83 c0 01             	add    $0x1,%eax
    f68f:	83 ec 0c             	sub    $0xc,%esp
    f692:	50                   	push   %eax
    f693:	e8 13 48 ff ff       	call   3eab <lodepng_malloc>
    f698:	83 c4 10             	add    $0x10,%esp
    f69b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    f69e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    f6a2:	75 0c                	jne    f6b0 <readChunk_iTXt+0xe0>
    f6a4:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f6ab:	e9 47 02 00 00       	jmp    f8f7 <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    f6b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f6b3:	83 ec 04             	sub    $0x4,%esp
    f6b6:	50                   	push   %eax
    f6b7:	ff 75 10             	pushl  0x10(%ebp)
    f6ba:	ff 75 e8             	pushl  -0x18(%ebp)
    f6bd:	e8 27 48 ff ff       	call   3ee9 <lodepng_memcpy>
    f6c2:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    f6c5:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f6c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f6cb:	01 d0                	add    %edx,%eax
    f6cd:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    f6d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f6d3:	8d 50 01             	lea    0x1(%eax),%edx
    f6d6:	8b 45 10             	mov    0x10(%ebp),%eax
    f6d9:	01 d0                	add    %edx,%eax
    f6db:	0f b6 00             	movzbl (%eax),%eax
    f6de:	0f b6 c0             	movzbl %al,%eax
    f6e1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    f6e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f6e7:	8d 50 02             	lea    0x2(%eax),%edx
    f6ea:	8b 45 10             	mov    0x10(%ebp),%eax
    f6ed:	01 d0                	add    %edx,%eax
    f6ef:	0f b6 00             	movzbl (%eax),%eax
    f6f2:	84 c0                	test   %al,%al
    f6f4:	74 0c                	je     f702 <readChunk_iTXt+0x132>
    f6f6:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    f6fd:	e9 f5 01 00 00       	jmp    f8f7 <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    f702:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f705:	83 c0 03             	add    $0x3,%eax
    f708:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    f70b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    f712:	8b 45 d8             	mov    -0x28(%ebp),%eax
    f715:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f718:	eb 08                	jmp    f722 <readChunk_iTXt+0x152>
    f71a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f71e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f722:	8b 45 14             	mov    0x14(%ebp),%eax
    f725:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    f728:	73 0f                	jae    f739 <readChunk_iTXt+0x169>
    f72a:	8b 55 10             	mov    0x10(%ebp),%edx
    f72d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f730:	01 d0                	add    %edx,%eax
    f732:	0f b6 00             	movzbl (%eax),%eax
    f735:	84 c0                	test   %al,%al
    f737:	75 e1                	jne    f71a <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    f739:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f73c:	83 c0 01             	add    $0x1,%eax
    f73f:	83 ec 0c             	sub    $0xc,%esp
    f742:	50                   	push   %eax
    f743:	e8 63 47 ff ff       	call   3eab <lodepng_malloc>
    f748:	83 c4 10             	add    $0x10,%esp
    f74b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    f74e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    f752:	75 0c                	jne    f760 <readChunk_iTXt+0x190>
    f754:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f75b:	e9 97 01 00 00       	jmp    f8f7 <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    f760:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f763:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f766:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f769:	01 ca                	add    %ecx,%edx
    f76b:	83 ec 04             	sub    $0x4,%esp
    f76e:	50                   	push   %eax
    f76f:	52                   	push   %edx
    f770:	ff 75 e4             	pushl  -0x1c(%ebp)
    f773:	e8 71 47 ff ff       	call   3ee9 <lodepng_memcpy>
    f778:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    f77b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f77e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f781:	01 d0                	add    %edx,%eax
    f783:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    f786:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f789:	8b 45 d8             	mov    -0x28(%ebp),%eax
    f78c:	01 d0                	add    %edx,%eax
    f78e:	83 c0 01             	add    $0x1,%eax
    f791:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    f794:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    f79b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    f79e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f7a1:	eb 08                	jmp    f7ab <readChunk_iTXt+0x1db>
    f7a3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f7a7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f7ab:	8b 45 14             	mov    0x14(%ebp),%eax
    f7ae:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    f7b1:	73 0f                	jae    f7c2 <readChunk_iTXt+0x1f2>
    f7b3:	8b 55 10             	mov    0x10(%ebp),%edx
    f7b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f7b9:	01 d0                	add    %edx,%eax
    f7bb:	0f b6 00             	movzbl (%eax),%eax
    f7be:	84 c0                	test   %al,%al
    f7c0:	75 e1                	jne    f7a3 <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    f7c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f7c5:	83 c0 01             	add    $0x1,%eax
    f7c8:	83 ec 0c             	sub    $0xc,%esp
    f7cb:	50                   	push   %eax
    f7cc:	e8 da 46 ff ff       	call   3eab <lodepng_malloc>
    f7d1:	83 c4 10             	add    $0x10,%esp
    f7d4:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    f7d7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    f7db:	75 0c                	jne    f7e9 <readChunk_iTXt+0x219>
    f7dd:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f7e4:	e9 0e 01 00 00       	jmp    f8f7 <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    f7e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f7ec:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f7ef:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f7f2:	01 ca                	add    %ecx,%edx
    f7f4:	83 ec 04             	sub    $0x4,%esp
    f7f7:	50                   	push   %eax
    f7f8:	52                   	push   %edx
    f7f9:	ff 75 e0             	pushl  -0x20(%ebp)
    f7fc:	e8 e8 46 ff ff       	call   3ee9 <lodepng_memcpy>
    f801:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    f804:	8b 55 e0             	mov    -0x20(%ebp),%edx
    f807:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f80a:	01 d0                	add    %edx,%eax
    f80c:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    f80f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f812:	8b 45 d8             	mov    -0x28(%ebp),%eax
    f815:	01 d0                	add    %edx,%eax
    f817:	83 c0 01             	add    $0x1,%eax
    f81a:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    f81d:	8b 45 14             	mov    0x14(%ebp),%eax
    f820:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    f823:	72 08                	jb     f82d <readChunk_iTXt+0x25d>
    f825:	8b 45 14             	mov    0x14(%ebp),%eax
    f828:	2b 45 d8             	sub    -0x28(%ebp),%eax
    f82b:	eb 05                	jmp    f832 <readChunk_iTXt+0x262>
    f82d:	b8 00 00 00 00       	mov    $0x0,%eax
    f832:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    f835:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    f839:	0f 84 90 00 00 00    	je     f8cf <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    f83f:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    f846:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    f84d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f850:	8b 40 30             	mov    0x30(%eax),%eax
    f853:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    f856:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f859:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f85c:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f85f:	01 d1                	add    %edx,%ecx
    f861:	83 ec 08             	sub    $0x8,%esp
    f864:	8d 55 c0             	lea    -0x40(%ebp),%edx
    f867:	52                   	push   %edx
    f868:	50                   	push   %eax
    f869:	51                   	push   %ecx
    f86a:	6a 00                	push   $0x0
    f86c:	8d 45 b8             	lea    -0x48(%ebp),%eax
    f86f:	50                   	push   %eax
    f870:	8d 45 bc             	lea    -0x44(%ebp),%eax
    f873:	50                   	push   %eax
    f874:	e8 ed 90 ff ff       	call   8966 <zlib_decompress>
    f879:	83 c4 20             	add    $0x20,%esp
    f87c:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    f87f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f883:	74 11                	je     f896 <readChunk_iTXt+0x2c6>
    f885:	8b 55 c8             	mov    -0x38(%ebp),%edx
    f888:	8b 45 b8             	mov    -0x48(%ebp),%eax
    f88b:	39 c2                	cmp    %eax,%edx
    f88d:	7d 07                	jge    f896 <readChunk_iTXt+0x2c6>
    f88f:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    f896:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f89a:	75 22                	jne    f8be <readChunk_iTXt+0x2ee>
    f89c:	8b 55 b8             	mov    -0x48(%ebp),%edx
    f89f:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f8a2:	83 ec 08             	sub    $0x8,%esp
    f8a5:	52                   	push   %edx
    f8a6:	50                   	push   %eax
    f8a7:	ff 75 e0             	pushl  -0x20(%ebp)
    f8aa:	ff 75 e4             	pushl  -0x1c(%ebp)
    f8ad:	ff 75 e8             	pushl  -0x18(%ebp)
    f8b0:	ff 75 08             	pushl  0x8(%ebp)
    f8b3:	e8 94 a9 ff ff       	call   a24c <lodepng_add_itext_sized>
    f8b8:	83 c4 20             	add    $0x20,%esp
    f8bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    f8be:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f8c1:	83 ec 0c             	sub    $0xc,%esp
    f8c4:	50                   	push   %eax
    f8c5:	e8 02 46 ff ff       	call   3ecc <lodepng_free>
    f8ca:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    f8cd:	eb 27                	jmp    f8f6 <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    f8cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f8d2:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f8d5:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f8d8:	01 ca                	add    %ecx,%edx
    f8da:	83 ec 08             	sub    $0x8,%esp
    f8dd:	50                   	push   %eax
    f8de:	52                   	push   %edx
    f8df:	ff 75 e0             	pushl  -0x20(%ebp)
    f8e2:	ff 75 e4             	pushl  -0x1c(%ebp)
    f8e5:	ff 75 e8             	pushl  -0x18(%ebp)
    f8e8:	ff 75 08             	pushl  0x8(%ebp)
    f8eb:	e8 5c a9 ff ff       	call   a24c <lodepng_add_itext_sized>
    f8f0:	83 c4 20             	add    $0x20,%esp
    f8f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    f8f6:	90                   	nop
  }

  lodepng_free(key);
    f8f7:	83 ec 0c             	sub    $0xc,%esp
    f8fa:	ff 75 e8             	pushl  -0x18(%ebp)
    f8fd:	e8 ca 45 ff ff       	call   3ecc <lodepng_free>
    f902:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    f905:	83 ec 0c             	sub    $0xc,%esp
    f908:	ff 75 e4             	pushl  -0x1c(%ebp)
    f90b:	e8 bc 45 ff ff       	call   3ecc <lodepng_free>
    f910:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    f913:	83 ec 0c             	sub    $0xc,%esp
    f916:	ff 75 e0             	pushl  -0x20(%ebp)
    f919:	e8 ae 45 ff ff       	call   3ecc <lodepng_free>
    f91e:	83 c4 10             	add    $0x10,%esp

  return error;
    f921:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f924:	c9                   	leave  
    f925:	c3                   	ret    

0000f926 <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f926:	55                   	push   %ebp
    f927:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    f929:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    f92d:	74 0a                	je     f939 <readChunk_tIME+0x13>
    f92f:	b8 49 00 00 00       	mov    $0x49,%eax
    f934:	e9 8b 00 00 00       	jmp    f9c4 <readChunk_tIME+0x9e>

  info->time_defined = 1;
    f939:	8b 45 08             	mov    0x8(%ebp),%eax
    f93c:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    f943:	8b 45 0c             	mov    0xc(%ebp),%eax
    f946:	0f b6 00             	movzbl (%eax),%eax
    f949:	0f b6 c0             	movzbl %al,%eax
    f94c:	c1 e0 08             	shl    $0x8,%eax
    f94f:	89 c2                	mov    %eax,%edx
    f951:	8b 45 0c             	mov    0xc(%ebp),%eax
    f954:	83 c0 01             	add    $0x1,%eax
    f957:	0f b6 00             	movzbl (%eax),%eax
    f95a:	0f b6 c0             	movzbl %al,%eax
    f95d:	01 c2                	add    %eax,%edx
    f95f:	8b 45 08             	mov    0x8(%ebp),%eax
    f962:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    f965:	8b 45 0c             	mov    0xc(%ebp),%eax
    f968:	83 c0 02             	add    $0x2,%eax
    f96b:	0f b6 00             	movzbl (%eax),%eax
    f96e:	0f b6 d0             	movzbl %al,%edx
    f971:	8b 45 08             	mov    0x8(%ebp),%eax
    f974:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    f977:	8b 45 0c             	mov    0xc(%ebp),%eax
    f97a:	83 c0 03             	add    $0x3,%eax
    f97d:	0f b6 00             	movzbl (%eax),%eax
    f980:	0f b6 d0             	movzbl %al,%edx
    f983:	8b 45 08             	mov    0x8(%ebp),%eax
    f986:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    f989:	8b 45 0c             	mov    0xc(%ebp),%eax
    f98c:	83 c0 04             	add    $0x4,%eax
    f98f:	0f b6 00             	movzbl (%eax),%eax
    f992:	0f b6 d0             	movzbl %al,%edx
    f995:	8b 45 08             	mov    0x8(%ebp),%eax
    f998:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    f99b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f99e:	83 c0 05             	add    $0x5,%eax
    f9a1:	0f b6 00             	movzbl (%eax),%eax
    f9a4:	0f b6 d0             	movzbl %al,%edx
    f9a7:	8b 45 08             	mov    0x8(%ebp),%eax
    f9aa:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    f9ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    f9b0:	83 c0 06             	add    $0x6,%eax
    f9b3:	0f b6 00             	movzbl (%eax),%eax
    f9b6:	0f b6 d0             	movzbl %al,%edx
    f9b9:	8b 45 08             	mov    0x8(%ebp),%eax
    f9bc:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    f9bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f9c4:	5d                   	pop    %ebp
    f9c5:	c3                   	ret    

0000f9c6 <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f9c6:	55                   	push   %ebp
    f9c7:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    f9c9:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    f9cd:	74 0a                	je     f9d9 <readChunk_pHYs+0x13>
    f9cf:	b8 4a 00 00 00       	mov    $0x4a,%eax
    f9d4:	e9 ba 00 00 00       	jmp    fa93 <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    f9d9:	8b 45 08             	mov    0x8(%ebp),%eax
    f9dc:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    f9e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f9e6:	0f b6 00             	movzbl (%eax),%eax
    f9e9:	0f b6 c0             	movzbl %al,%eax
    f9ec:	c1 e0 08             	shl    $0x8,%eax
    f9ef:	89 c2                	mov    %eax,%edx
    f9f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    f9f4:	83 c0 01             	add    $0x1,%eax
    f9f7:	0f b6 00             	movzbl (%eax),%eax
    f9fa:	0f b6 c0             	movzbl %al,%eax
    f9fd:	01 d0                	add    %edx,%eax
    f9ff:	c1 e0 08             	shl    $0x8,%eax
    fa02:	89 c2                	mov    %eax,%edx
    fa04:	8b 45 0c             	mov    0xc(%ebp),%eax
    fa07:	83 c0 02             	add    $0x2,%eax
    fa0a:	0f b6 00             	movzbl (%eax),%eax
    fa0d:	0f b6 c0             	movzbl %al,%eax
    fa10:	01 d0                	add    %edx,%eax
    fa12:	c1 e0 08             	shl    $0x8,%eax
    fa15:	89 c2                	mov    %eax,%edx
    fa17:	8b 45 0c             	mov    0xc(%ebp),%eax
    fa1a:	83 c0 03             	add    $0x3,%eax
    fa1d:	0f b6 00             	movzbl (%eax),%eax
    fa20:	0f b6 c0             	movzbl %al,%eax
    fa23:	01 c2                	add    %eax,%edx
    fa25:	8b 45 08             	mov    0x8(%ebp),%eax
    fa28:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    fa2b:	8b 45 0c             	mov    0xc(%ebp),%eax
    fa2e:	83 c0 04             	add    $0x4,%eax
    fa31:	0f b6 00             	movzbl (%eax),%eax
    fa34:	0f b6 c0             	movzbl %al,%eax
    fa37:	c1 e0 08             	shl    $0x8,%eax
    fa3a:	89 c2                	mov    %eax,%edx
    fa3c:	8b 45 0c             	mov    0xc(%ebp),%eax
    fa3f:	83 c0 05             	add    $0x5,%eax
    fa42:	0f b6 00             	movzbl (%eax),%eax
    fa45:	0f b6 c0             	movzbl %al,%eax
    fa48:	01 d0                	add    %edx,%eax
    fa4a:	c1 e0 08             	shl    $0x8,%eax
    fa4d:	89 c2                	mov    %eax,%edx
    fa4f:	8b 45 0c             	mov    0xc(%ebp),%eax
    fa52:	83 c0 06             	add    $0x6,%eax
    fa55:	0f b6 00             	movzbl (%eax),%eax
    fa58:	0f b6 c0             	movzbl %al,%eax
    fa5b:	01 d0                	add    %edx,%eax
    fa5d:	c1 e0 08             	shl    $0x8,%eax
    fa60:	89 c2                	mov    %eax,%edx
    fa62:	8b 45 0c             	mov    0xc(%ebp),%eax
    fa65:	83 c0 07             	add    $0x7,%eax
    fa68:	0f b6 00             	movzbl (%eax),%eax
    fa6b:	0f b6 c0             	movzbl %al,%eax
    fa6e:	01 c2                	add    %eax,%edx
    fa70:	8b 45 08             	mov    0x8(%ebp),%eax
    fa73:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    fa79:	8b 45 0c             	mov    0xc(%ebp),%eax
    fa7c:	83 c0 08             	add    $0x8,%eax
    fa7f:	0f b6 00             	movzbl (%eax),%eax
    fa82:	0f b6 d0             	movzbl %al,%edx
    fa85:	8b 45 08             	mov    0x8(%ebp),%eax
    fa88:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    fa8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fa93:	5d                   	pop    %ebp
    fa94:	c3                   	ret    

0000fa95 <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    fa95:	55                   	push   %ebp
    fa96:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    fa98:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    fa9c:	74 07                	je     faa5 <readChunk_gAMA+0x10>
    fa9e:	b8 60 00 00 00       	mov    $0x60,%eax
    faa3:	eb 5d                	jmp    fb02 <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    faa5:	8b 45 08             	mov    0x8(%ebp),%eax
    faa8:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    faaf:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    fab2:	8b 45 0c             	mov    0xc(%ebp),%eax
    fab5:	0f b6 00             	movzbl (%eax),%eax
    fab8:	0f b6 c0             	movzbl %al,%eax
    fabb:	c1 e0 08             	shl    $0x8,%eax
    fabe:	89 c2                	mov    %eax,%edx
    fac0:	8b 45 0c             	mov    0xc(%ebp),%eax
    fac3:	83 c0 01             	add    $0x1,%eax
    fac6:	0f b6 00             	movzbl (%eax),%eax
    fac9:	0f b6 c0             	movzbl %al,%eax
    facc:	01 d0                	add    %edx,%eax
    face:	c1 e0 08             	shl    $0x8,%eax
    fad1:	89 c2                	mov    %eax,%edx
    fad3:	8b 45 0c             	mov    0xc(%ebp),%eax
    fad6:	83 c0 02             	add    $0x2,%eax
    fad9:	0f b6 00             	movzbl (%eax),%eax
    fadc:	0f b6 c0             	movzbl %al,%eax
    fadf:	01 d0                	add    %edx,%eax
    fae1:	c1 e0 08             	shl    $0x8,%eax
    fae4:	89 c2                	mov    %eax,%edx
    fae6:	8b 45 0c             	mov    0xc(%ebp),%eax
    fae9:	83 c0 03             	add    $0x3,%eax
    faec:	0f b6 00             	movzbl (%eax),%eax
    faef:	0f b6 c0             	movzbl %al,%eax
    faf2:	01 c2                	add    %eax,%edx
    faf4:	8b 45 08             	mov    0x8(%ebp),%eax
    faf7:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    fafd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fb02:	5d                   	pop    %ebp
    fb03:	c3                   	ret    

0000fb04 <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    fb04:	55                   	push   %ebp
    fb05:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    fb07:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    fb0b:	74 0a                	je     fb17 <readChunk_cHRM+0x13>
    fb0d:	b8 61 00 00 00       	mov    $0x61,%eax
    fb12:	e9 7f 02 00 00       	jmp    fd96 <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    fb17:	8b 45 08             	mov    0x8(%ebp),%eax
    fb1a:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    fb21:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    fb24:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb27:	0f b6 00             	movzbl (%eax),%eax
    fb2a:	0f b6 c0             	movzbl %al,%eax
    fb2d:	c1 e0 08             	shl    $0x8,%eax
    fb30:	89 c2                	mov    %eax,%edx
    fb32:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb35:	83 c0 01             	add    $0x1,%eax
    fb38:	0f b6 00             	movzbl (%eax),%eax
    fb3b:	0f b6 c0             	movzbl %al,%eax
    fb3e:	01 d0                	add    %edx,%eax
    fb40:	c1 e0 08             	shl    $0x8,%eax
    fb43:	89 c2                	mov    %eax,%edx
    fb45:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb48:	83 c0 02             	add    $0x2,%eax
    fb4b:	0f b6 00             	movzbl (%eax),%eax
    fb4e:	0f b6 c0             	movzbl %al,%eax
    fb51:	01 d0                	add    %edx,%eax
    fb53:	c1 e0 08             	shl    $0x8,%eax
    fb56:	89 c2                	mov    %eax,%edx
    fb58:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb5b:	83 c0 03             	add    $0x3,%eax
    fb5e:	0f b6 00             	movzbl (%eax),%eax
    fb61:	0f b6 c0             	movzbl %al,%eax
    fb64:	01 c2                	add    %eax,%edx
    fb66:	8b 45 08             	mov    0x8(%ebp),%eax
    fb69:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    fb6f:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb72:	83 c0 04             	add    $0x4,%eax
    fb75:	0f b6 00             	movzbl (%eax),%eax
    fb78:	0f b6 c0             	movzbl %al,%eax
    fb7b:	c1 e0 08             	shl    $0x8,%eax
    fb7e:	89 c2                	mov    %eax,%edx
    fb80:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb83:	83 c0 05             	add    $0x5,%eax
    fb86:	0f b6 00             	movzbl (%eax),%eax
    fb89:	0f b6 c0             	movzbl %al,%eax
    fb8c:	01 d0                	add    %edx,%eax
    fb8e:	c1 e0 08             	shl    $0x8,%eax
    fb91:	89 c2                	mov    %eax,%edx
    fb93:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb96:	83 c0 06             	add    $0x6,%eax
    fb99:	0f b6 00             	movzbl (%eax),%eax
    fb9c:	0f b6 c0             	movzbl %al,%eax
    fb9f:	01 d0                	add    %edx,%eax
    fba1:	c1 e0 08             	shl    $0x8,%eax
    fba4:	89 c2                	mov    %eax,%edx
    fba6:	8b 45 0c             	mov    0xc(%ebp),%eax
    fba9:	83 c0 07             	add    $0x7,%eax
    fbac:	0f b6 00             	movzbl (%eax),%eax
    fbaf:	0f b6 c0             	movzbl %al,%eax
    fbb2:	01 c2                	add    %eax,%edx
    fbb4:	8b 45 08             	mov    0x8(%ebp),%eax
    fbb7:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    fbbd:	8b 45 0c             	mov    0xc(%ebp),%eax
    fbc0:	83 c0 08             	add    $0x8,%eax
    fbc3:	0f b6 00             	movzbl (%eax),%eax
    fbc6:	0f b6 c0             	movzbl %al,%eax
    fbc9:	c1 e0 08             	shl    $0x8,%eax
    fbcc:	89 c2                	mov    %eax,%edx
    fbce:	8b 45 0c             	mov    0xc(%ebp),%eax
    fbd1:	83 c0 09             	add    $0x9,%eax
    fbd4:	0f b6 00             	movzbl (%eax),%eax
    fbd7:	0f b6 c0             	movzbl %al,%eax
    fbda:	01 d0                	add    %edx,%eax
    fbdc:	c1 e0 08             	shl    $0x8,%eax
    fbdf:	89 c2                	mov    %eax,%edx
    fbe1:	8b 45 0c             	mov    0xc(%ebp),%eax
    fbe4:	83 c0 0a             	add    $0xa,%eax
    fbe7:	0f b6 00             	movzbl (%eax),%eax
    fbea:	0f b6 c0             	movzbl %al,%eax
    fbed:	01 d0                	add    %edx,%eax
    fbef:	c1 e0 08             	shl    $0x8,%eax
    fbf2:	89 c2                	mov    %eax,%edx
    fbf4:	8b 45 0c             	mov    0xc(%ebp),%eax
    fbf7:	83 c0 0b             	add    $0xb,%eax
    fbfa:	0f b6 00             	movzbl (%eax),%eax
    fbfd:	0f b6 c0             	movzbl %al,%eax
    fc00:	01 c2                	add    %eax,%edx
    fc02:	8b 45 08             	mov    0x8(%ebp),%eax
    fc05:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    fc0b:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc0e:	83 c0 0c             	add    $0xc,%eax
    fc11:	0f b6 00             	movzbl (%eax),%eax
    fc14:	0f b6 c0             	movzbl %al,%eax
    fc17:	c1 e0 08             	shl    $0x8,%eax
    fc1a:	89 c2                	mov    %eax,%edx
    fc1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc1f:	83 c0 0d             	add    $0xd,%eax
    fc22:	0f b6 00             	movzbl (%eax),%eax
    fc25:	0f b6 c0             	movzbl %al,%eax
    fc28:	01 d0                	add    %edx,%eax
    fc2a:	c1 e0 08             	shl    $0x8,%eax
    fc2d:	89 c2                	mov    %eax,%edx
    fc2f:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc32:	83 c0 0e             	add    $0xe,%eax
    fc35:	0f b6 00             	movzbl (%eax),%eax
    fc38:	0f b6 c0             	movzbl %al,%eax
    fc3b:	01 d0                	add    %edx,%eax
    fc3d:	c1 e0 08             	shl    $0x8,%eax
    fc40:	89 c2                	mov    %eax,%edx
    fc42:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc45:	83 c0 0f             	add    $0xf,%eax
    fc48:	0f b6 00             	movzbl (%eax),%eax
    fc4b:	0f b6 c0             	movzbl %al,%eax
    fc4e:	01 c2                	add    %eax,%edx
    fc50:	8b 45 08             	mov    0x8(%ebp),%eax
    fc53:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    fc59:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc5c:	83 c0 10             	add    $0x10,%eax
    fc5f:	0f b6 00             	movzbl (%eax),%eax
    fc62:	0f b6 c0             	movzbl %al,%eax
    fc65:	c1 e0 08             	shl    $0x8,%eax
    fc68:	89 c2                	mov    %eax,%edx
    fc6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc6d:	83 c0 11             	add    $0x11,%eax
    fc70:	0f b6 00             	movzbl (%eax),%eax
    fc73:	0f b6 c0             	movzbl %al,%eax
    fc76:	01 d0                	add    %edx,%eax
    fc78:	c1 e0 08             	shl    $0x8,%eax
    fc7b:	89 c2                	mov    %eax,%edx
    fc7d:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc80:	83 c0 12             	add    $0x12,%eax
    fc83:	0f b6 00             	movzbl (%eax),%eax
    fc86:	0f b6 c0             	movzbl %al,%eax
    fc89:	01 d0                	add    %edx,%eax
    fc8b:	c1 e0 08             	shl    $0x8,%eax
    fc8e:	89 c2                	mov    %eax,%edx
    fc90:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc93:	83 c0 13             	add    $0x13,%eax
    fc96:	0f b6 00             	movzbl (%eax),%eax
    fc99:	0f b6 c0             	movzbl %al,%eax
    fc9c:	01 c2                	add    %eax,%edx
    fc9e:	8b 45 08             	mov    0x8(%ebp),%eax
    fca1:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    fca7:	8b 45 0c             	mov    0xc(%ebp),%eax
    fcaa:	83 c0 14             	add    $0x14,%eax
    fcad:	0f b6 00             	movzbl (%eax),%eax
    fcb0:	0f b6 c0             	movzbl %al,%eax
    fcb3:	c1 e0 08             	shl    $0x8,%eax
    fcb6:	89 c2                	mov    %eax,%edx
    fcb8:	8b 45 0c             	mov    0xc(%ebp),%eax
    fcbb:	83 c0 15             	add    $0x15,%eax
    fcbe:	0f b6 00             	movzbl (%eax),%eax
    fcc1:	0f b6 c0             	movzbl %al,%eax
    fcc4:	01 d0                	add    %edx,%eax
    fcc6:	c1 e0 08             	shl    $0x8,%eax
    fcc9:	89 c2                	mov    %eax,%edx
    fccb:	8b 45 0c             	mov    0xc(%ebp),%eax
    fcce:	83 c0 16             	add    $0x16,%eax
    fcd1:	0f b6 00             	movzbl (%eax),%eax
    fcd4:	0f b6 c0             	movzbl %al,%eax
    fcd7:	01 d0                	add    %edx,%eax
    fcd9:	c1 e0 08             	shl    $0x8,%eax
    fcdc:	89 c2                	mov    %eax,%edx
    fcde:	8b 45 0c             	mov    0xc(%ebp),%eax
    fce1:	83 c0 17             	add    $0x17,%eax
    fce4:	0f b6 00             	movzbl (%eax),%eax
    fce7:	0f b6 c0             	movzbl %al,%eax
    fcea:	01 c2                	add    %eax,%edx
    fcec:	8b 45 08             	mov    0x8(%ebp),%eax
    fcef:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    fcf5:	8b 45 0c             	mov    0xc(%ebp),%eax
    fcf8:	83 c0 18             	add    $0x18,%eax
    fcfb:	0f b6 00             	movzbl (%eax),%eax
    fcfe:	0f b6 c0             	movzbl %al,%eax
    fd01:	c1 e0 08             	shl    $0x8,%eax
    fd04:	89 c2                	mov    %eax,%edx
    fd06:	8b 45 0c             	mov    0xc(%ebp),%eax
    fd09:	83 c0 19             	add    $0x19,%eax
    fd0c:	0f b6 00             	movzbl (%eax),%eax
    fd0f:	0f b6 c0             	movzbl %al,%eax
    fd12:	01 d0                	add    %edx,%eax
    fd14:	c1 e0 08             	shl    $0x8,%eax
    fd17:	89 c2                	mov    %eax,%edx
    fd19:	8b 45 0c             	mov    0xc(%ebp),%eax
    fd1c:	83 c0 1a             	add    $0x1a,%eax
    fd1f:	0f b6 00             	movzbl (%eax),%eax
    fd22:	0f b6 c0             	movzbl %al,%eax
    fd25:	01 d0                	add    %edx,%eax
    fd27:	c1 e0 08             	shl    $0x8,%eax
    fd2a:	89 c2                	mov    %eax,%edx
    fd2c:	8b 45 0c             	mov    0xc(%ebp),%eax
    fd2f:	83 c0 1b             	add    $0x1b,%eax
    fd32:	0f b6 00             	movzbl (%eax),%eax
    fd35:	0f b6 c0             	movzbl %al,%eax
    fd38:	01 c2                	add    %eax,%edx
    fd3a:	8b 45 08             	mov    0x8(%ebp),%eax
    fd3d:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    fd43:	8b 45 0c             	mov    0xc(%ebp),%eax
    fd46:	83 c0 1c             	add    $0x1c,%eax
    fd49:	0f b6 00             	movzbl (%eax),%eax
    fd4c:	0f b6 c0             	movzbl %al,%eax
    fd4f:	c1 e0 08             	shl    $0x8,%eax
    fd52:	89 c2                	mov    %eax,%edx
    fd54:	8b 45 0c             	mov    0xc(%ebp),%eax
    fd57:	83 c0 1d             	add    $0x1d,%eax
    fd5a:	0f b6 00             	movzbl (%eax),%eax
    fd5d:	0f b6 c0             	movzbl %al,%eax
    fd60:	01 d0                	add    %edx,%eax
    fd62:	c1 e0 08             	shl    $0x8,%eax
    fd65:	89 c2                	mov    %eax,%edx
    fd67:	8b 45 0c             	mov    0xc(%ebp),%eax
    fd6a:	83 c0 1e             	add    $0x1e,%eax
    fd6d:	0f b6 00             	movzbl (%eax),%eax
    fd70:	0f b6 c0             	movzbl %al,%eax
    fd73:	01 d0                	add    %edx,%eax
    fd75:	c1 e0 08             	shl    $0x8,%eax
    fd78:	89 c2                	mov    %eax,%edx
    fd7a:	8b 45 0c             	mov    0xc(%ebp),%eax
    fd7d:	83 c0 1f             	add    $0x1f,%eax
    fd80:	0f b6 00             	movzbl (%eax),%eax
    fd83:	0f b6 c0             	movzbl %al,%eax
    fd86:	01 c2                	add    %eax,%edx
    fd88:	8b 45 08             	mov    0x8(%ebp),%eax
    fd8b:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    fd91:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fd96:	5d                   	pop    %ebp
    fd97:	c3                   	ret    

0000fd98 <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    fd98:	55                   	push   %ebp
    fd99:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    fd9b:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    fd9f:	74 07                	je     fda8 <readChunk_sRGB+0x10>
    fda1:	b8 62 00 00 00       	mov    $0x62,%eax
    fda6:	eb 24                	jmp    fdcc <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    fda8:	8b 45 08             	mov    0x8(%ebp),%eax
    fdab:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    fdb2:	00 00 00 
  info->srgb_intent = data[0];
    fdb5:	8b 45 0c             	mov    0xc(%ebp),%eax
    fdb8:	0f b6 00             	movzbl (%eax),%eax
    fdbb:	0f b6 d0             	movzbl %al,%edx
    fdbe:	8b 45 08             	mov    0x8(%ebp),%eax
    fdc1:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    fdc7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fdcc:	5d                   	pop    %ebp
    fdcd:	c3                   	ret    

0000fdce <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    fdce:	55                   	push   %ebp
    fdcf:	89 e5                	mov    %esp,%ebp
    fdd1:	53                   	push   %ebx
    fdd2:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    fdd5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    fddc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    fde3:	8b 45 0c             	mov    0xc(%ebp),%eax
    fde6:	8b 10                	mov    (%eax),%edx
    fde8:	89 55 cc             	mov    %edx,-0x34(%ebp)
    fdeb:	8b 50 04             	mov    0x4(%eax),%edx
    fdee:	89 55 d0             	mov    %edx,-0x30(%ebp)
    fdf1:	8b 50 08             	mov    0x8(%eax),%edx
    fdf4:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    fdf7:	8b 50 0c             	mov    0xc(%eax),%edx
    fdfa:	89 55 d8             	mov    %edx,-0x28(%ebp)
    fdfd:	8b 50 10             	mov    0x10(%eax),%edx
    fe00:	89 55 dc             	mov    %edx,-0x24(%ebp)
    fe03:	8b 40 14             	mov    0x14(%eax),%eax
    fe06:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    fe09:	8b 45 08             	mov    0x8(%ebp),%eax
    fe0c:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    fe13:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    fe16:	8b 45 08             	mov    0x8(%ebp),%eax
    fe19:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    fe1f:	85 c0                	test   %eax,%eax
    fe21:	74 0e                	je     fe31 <readChunk_iCCP+0x63>
    fe23:	83 ec 0c             	sub    $0xc,%esp
    fe26:	ff 75 08             	pushl  0x8(%ebp)
    fe29:	e8 ca a6 ff ff       	call   a4f8 <lodepng_clear_icc>
    fe2e:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    fe31:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    fe38:	eb 04                	jmp    fe3e <readChunk_iCCP+0x70>
    fe3a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    fe3e:	8b 45 14             	mov    0x14(%ebp),%eax
    fe41:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    fe44:	73 0f                	jae    fe55 <readChunk_iCCP+0x87>
    fe46:	8b 55 10             	mov    0x10(%ebp),%edx
    fe49:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fe4c:	01 d0                	add    %edx,%eax
    fe4e:	0f b6 00             	movzbl (%eax),%eax
    fe51:	84 c0                	test   %al,%al
    fe53:	75 e5                	jne    fe3a <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    fe55:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fe58:	8d 50 02             	lea    0x2(%eax),%edx
    fe5b:	8b 45 14             	mov    0x14(%ebp),%eax
    fe5e:	39 c2                	cmp    %eax,%edx
    fe60:	72 0a                	jb     fe6c <readChunk_iCCP+0x9e>
    fe62:	b8 4b 00 00 00       	mov    $0x4b,%eax
    fe67:	e9 46 01 00 00       	jmp    ffb2 <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    fe6c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    fe70:	74 06                	je     fe78 <readChunk_iCCP+0xaa>
    fe72:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    fe76:	76 0a                	jbe    fe82 <readChunk_iCCP+0xb4>
    fe78:	b8 59 00 00 00       	mov    $0x59,%eax
    fe7d:	e9 30 01 00 00       	jmp    ffb2 <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    fe82:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fe85:	83 c0 01             	add    $0x1,%eax
    fe88:	83 ec 0c             	sub    $0xc,%esp
    fe8b:	50                   	push   %eax
    fe8c:	e8 1a 40 ff ff       	call   3eab <lodepng_malloc>
    fe91:	83 c4 10             	add    $0x10,%esp
    fe94:	89 c2                	mov    %eax,%edx
    fe96:	8b 45 08             	mov    0x8(%ebp),%eax
    fe99:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    fe9f:	8b 45 08             	mov    0x8(%ebp),%eax
    fea2:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    fea8:	85 c0                	test   %eax,%eax
    feaa:	75 0a                	jne    feb6 <readChunk_iCCP+0xe8>
    feac:	b8 53 00 00 00       	mov    $0x53,%eax
    feb1:	e9 fc 00 00 00       	jmp    ffb2 <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    feb6:	8b 45 08             	mov    0x8(%ebp),%eax
    feb9:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    febf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fec2:	01 d0                	add    %edx,%eax
    fec4:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    fec7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    fece:	eb 1f                	jmp    feef <readChunk_iCCP+0x121>
    fed0:	8b 45 08             	mov    0x8(%ebp),%eax
    fed3:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    fed9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fedc:	01 d0                	add    %edx,%eax
    fede:	8b 4d 10             	mov    0x10(%ebp),%ecx
    fee1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fee4:	01 ca                	add    %ecx,%edx
    fee6:	0f b6 12             	movzbl (%edx),%edx
    fee9:	88 10                	mov    %dl,(%eax)
    feeb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    feef:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fef2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    fef5:	75 d9                	jne    fed0 <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    fef7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fefa:	8d 50 01             	lea    0x1(%eax),%edx
    fefd:	8b 45 10             	mov    0x10(%ebp),%eax
    ff00:	01 d0                	add    %edx,%eax
    ff02:	0f b6 00             	movzbl (%eax),%eax
    ff05:	84 c0                	test   %al,%al
    ff07:	74 0a                	je     ff13 <readChunk_iCCP+0x145>
    ff09:	b8 48 00 00 00       	mov    $0x48,%eax
    ff0e:	e9 9f 00 00 00       	jmp    ffb2 <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    ff13:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ff16:	83 c0 02             	add    $0x2,%eax
    ff19:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    ff1c:	8b 45 14             	mov    0x14(%ebp),%eax
    ff1f:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    ff22:	76 0a                	jbe    ff2e <readChunk_iCCP+0x160>
    ff24:	b8 4b 00 00 00       	mov    $0x4b,%eax
    ff29:	e9 84 00 00 00       	jmp    ffb2 <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    ff2e:	8b 45 14             	mov    0x14(%ebp),%eax
    ff31:	2b 45 e8             	sub    -0x18(%ebp),%eax
    ff34:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    ff37:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff3a:	8b 40 34             	mov    0x34(%eax),%eax
    ff3d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    ff40:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ff43:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ff46:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ff49:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    ff4c:	8b 55 08             	mov    0x8(%ebp),%edx
    ff4f:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    ff55:	83 ec 08             	sub    $0x8,%esp
    ff58:	8d 55 cc             	lea    -0x34(%ebp),%edx
    ff5b:	52                   	push   %edx
    ff5c:	50                   	push   %eax
    ff5d:	53                   	push   %ebx
    ff5e:	6a 00                	push   $0x0
    ff60:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    ff63:	50                   	push   %eax
    ff64:	51                   	push   %ecx
    ff65:	e8 fc 89 ff ff       	call   8966 <zlib_decompress>
    ff6a:	83 c4 20             	add    $0x20,%esp
    ff6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    ff70:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ff74:	74 11                	je     ff87 <readChunk_iCCP+0x1b9>
    ff76:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    ff79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ff7c:	39 c2                	cmp    %eax,%edx
    ff7e:	7d 07                	jge    ff87 <readChunk_iCCP+0x1b9>
    ff80:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    ff87:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ff8a:	89 c2                	mov    %eax,%edx
    ff8c:	8b 45 08             	mov    0x8(%ebp),%eax
    ff8f:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    ff95:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ff99:	75 14                	jne    ffaf <readChunk_iCCP+0x1e1>
    ff9b:	8b 45 08             	mov    0x8(%ebp),%eax
    ff9e:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    ffa4:	85 c0                	test   %eax,%eax
    ffa6:	75 07                	jne    ffaf <readChunk_iCCP+0x1e1>
    ffa8:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    ffaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ffb2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    ffb5:	c9                   	leave  
    ffb6:	c3                   	ret    

0000ffb7 <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    ffb7:	55                   	push   %ebp
    ffb8:	89 e5                	mov    %esp,%ebp
    ffba:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    ffbd:	8b 55 0c             	mov    0xc(%ebp),%edx
    ffc0:	8b 45 10             	mov    0x10(%ebp),%eax
    ffc3:	01 d0                	add    %edx,%eax
    ffc5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    ffc8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    ffcf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    ffd6:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffd9:	83 c0 04             	add    $0x4,%eax
    ffdc:	3b 45 14             	cmp    0x14(%ebp),%eax
    ffdf:	7e 0a                	jle    ffeb <lodepng_inspect_chunk+0x34>
    ffe1:	b8 1e 00 00 00       	mov    $0x1e,%eax
    ffe6:	e9 43 03 00 00       	jmp    1032e <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    ffeb:	ff 75 ec             	pushl  -0x14(%ebp)
    ffee:	e8 3a 8e ff ff       	call   8e2d <lodepng_chunk_length>
    fff3:	83 c4 04             	add    $0x4,%esp
    fff6:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    fff9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fffc:	85 c0                	test   %eax,%eax
    fffe:	79 0a                	jns    1000a <lodepng_inspect_chunk+0x53>
   10000:	b8 3f 00 00 00       	mov    $0x3f,%eax
   10005:	e9 24 03 00 00       	jmp    1032e <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
   1000a:	ff 75 ec             	pushl  -0x14(%ebp)
   1000d:	e8 53 8f ff ff       	call   8f65 <lodepng_chunk_data_const>
   10012:	83 c4 04             	add    $0x4,%esp
   10015:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
   10018:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1001b:	8d 50 04             	lea    0x4(%eax),%edx
   1001e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10021:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   10024:	8b 55 14             	mov    0x14(%ebp),%edx
   10027:	8b 45 10             	mov    0x10(%ebp),%eax
   1002a:	01 d0                	add    %edx,%eax
   1002c:	39 c1                	cmp    %eax,%ecx
   1002e:	76 0a                	jbe    1003a <lodepng_inspect_chunk+0x83>
   10030:	b8 1e 00 00 00       	mov    $0x1e,%eax
   10035:	e9 f4 02 00 00       	jmp    1032e <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
   1003a:	68 a8 ac 01 00       	push   $0x1aca8
   1003f:	ff 75 ec             	pushl  -0x14(%ebp)
   10042:	e8 33 8e ff ff       	call   8e7a <lodepng_chunk_type_equals>
   10047:	83 c4 08             	add    $0x8,%esp
   1004a:	84 c0                	test   %al,%al
   1004c:	74 24                	je     10072 <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
   1004e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10051:	8b 55 08             	mov    0x8(%ebp),%edx
   10054:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   1005a:	83 ec 04             	sub    $0x4,%esp
   1005d:	50                   	push   %eax
   1005e:	ff 75 e4             	pushl  -0x1c(%ebp)
   10061:	52                   	push   %edx
   10062:	e8 5b ee ff ff       	call   eec2 <readChunk_PLTE>
   10067:	83 c4 10             	add    $0x10,%esp
   1006a:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1006d:	e9 8a 02 00 00       	jmp    102fc <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
   10072:	83 ec 08             	sub    $0x8,%esp
   10075:	68 ad ac 01 00       	push   $0x1acad
   1007a:	ff 75 ec             	pushl  -0x14(%ebp)
   1007d:	e8 f8 8d ff ff       	call   8e7a <lodepng_chunk_type_equals>
   10082:	83 c4 10             	add    $0x10,%esp
   10085:	84 c0                	test   %al,%al
   10087:	74 24                	je     100ad <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
   10089:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1008c:	8b 55 08             	mov    0x8(%ebp),%edx
   1008f:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   10095:	83 ec 04             	sub    $0x4,%esp
   10098:	50                   	push   %eax
   10099:	ff 75 e4             	pushl  -0x1c(%ebp)
   1009c:	52                   	push   %edx
   1009d:	e8 40 ef ff ff       	call   efe2 <readChunk_tRNS>
   100a2:	83 c4 10             	add    $0x10,%esp
   100a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
   100a8:	e9 4f 02 00 00       	jmp    102fc <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
   100ad:	83 ec 08             	sub    $0x8,%esp
   100b0:	68 b2 ac 01 00       	push   $0x1acb2
   100b5:	ff 75 ec             	pushl  -0x14(%ebp)
   100b8:	e8 bd 8d ff ff       	call   8e7a <lodepng_chunk_type_equals>
   100bd:	83 c4 10             	add    $0x10,%esp
   100c0:	84 c0                	test   %al,%al
   100c2:	74 24                	je     100e8 <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
   100c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   100c7:	8b 55 08             	mov    0x8(%ebp),%edx
   100ca:	81 c2 98 00 00 00    	add    $0x98,%edx
   100d0:	83 ec 04             	sub    $0x4,%esp
   100d3:	50                   	push   %eax
   100d4:	ff 75 e4             	pushl  -0x1c(%ebp)
   100d7:	52                   	push   %edx
   100d8:	e8 68 f0 ff ff       	call   f145 <readChunk_bKGD>
   100dd:	83 c4 10             	add    $0x10,%esp
   100e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
   100e3:	e9 14 02 00 00       	jmp    102fc <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
   100e8:	83 ec 08             	sub    $0x8,%esp
   100eb:	68 b7 ac 01 00       	push   $0x1acb7
   100f0:	ff 75 ec             	pushl  -0x14(%ebp)
   100f3:	e8 82 8d ff ff       	call   8e7a <lodepng_chunk_type_equals>
   100f8:	83 c4 10             	add    $0x10,%esp
   100fb:	84 c0                	test   %al,%al
   100fd:	74 24                	je     10123 <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
   100ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10102:	8b 55 08             	mov    0x8(%ebp),%edx
   10105:	81 c2 98 00 00 00    	add    $0x98,%edx
   1010b:	83 ec 04             	sub    $0x4,%esp
   1010e:	50                   	push   %eax
   1010f:	ff 75 e4             	pushl  -0x1c(%ebp)
   10112:	52                   	push   %edx
   10113:	e8 b0 f1 ff ff       	call   f2c8 <readChunk_tEXt>
   10118:	83 c4 10             	add    $0x10,%esp
   1011b:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1011e:	e9 d9 01 00 00       	jmp    102fc <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
   10123:	83 ec 08             	sub    $0x8,%esp
   10126:	68 bc ac 01 00       	push   $0x1acbc
   1012b:	ff 75 ec             	pushl  -0x14(%ebp)
   1012e:	e8 47 8d ff ff       	call   8e7a <lodepng_chunk_type_equals>
   10133:	83 c4 10             	add    $0x10,%esp
   10136:	84 c0                	test   %al,%al
   10138:	74 25                	je     1015f <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
   1013a:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1013d:	8b 45 08             	mov    0x8(%ebp),%eax
   10140:	8b 4d 08             	mov    0x8(%ebp),%ecx
   10143:	81 c1 98 00 00 00    	add    $0x98,%ecx
   10149:	52                   	push   %edx
   1014a:	ff 75 e4             	pushl  -0x1c(%ebp)
   1014d:	50                   	push   %eax
   1014e:	51                   	push   %ecx
   1014f:	e8 c0 f2 ff ff       	call   f414 <readChunk_zTXt>
   10154:	83 c4 10             	add    $0x10,%esp
   10157:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1015a:	e9 9d 01 00 00       	jmp    102fc <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
   1015f:	83 ec 08             	sub    $0x8,%esp
   10162:	68 c1 ac 01 00       	push   $0x1acc1
   10167:	ff 75 ec             	pushl  -0x14(%ebp)
   1016a:	e8 0b 8d ff ff       	call   8e7a <lodepng_chunk_type_equals>
   1016f:	83 c4 10             	add    $0x10,%esp
   10172:	84 c0                	test   %al,%al
   10174:	74 25                	je     1019b <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
   10176:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10179:	8b 45 08             	mov    0x8(%ebp),%eax
   1017c:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1017f:	81 c1 98 00 00 00    	add    $0x98,%ecx
   10185:	52                   	push   %edx
   10186:	ff 75 e4             	pushl  -0x1c(%ebp)
   10189:	50                   	push   %eax
   1018a:	51                   	push   %ecx
   1018b:	e8 40 f4 ff ff       	call   f5d0 <readChunk_iTXt>
   10190:	83 c4 10             	add    $0x10,%esp
   10193:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10196:	e9 61 01 00 00       	jmp    102fc <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
   1019b:	83 ec 08             	sub    $0x8,%esp
   1019e:	68 c6 ac 01 00       	push   $0x1acc6
   101a3:	ff 75 ec             	pushl  -0x14(%ebp)
   101a6:	e8 cf 8c ff ff       	call   8e7a <lodepng_chunk_type_equals>
   101ab:	83 c4 10             	add    $0x10,%esp
   101ae:	84 c0                	test   %al,%al
   101b0:	74 24                	je     101d6 <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
   101b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   101b5:	8b 55 08             	mov    0x8(%ebp),%edx
   101b8:	81 c2 98 00 00 00    	add    $0x98,%edx
   101be:	83 ec 04             	sub    $0x4,%esp
   101c1:	50                   	push   %eax
   101c2:	ff 75 e4             	pushl  -0x1c(%ebp)
   101c5:	52                   	push   %edx
   101c6:	e8 5b f7 ff ff       	call   f926 <readChunk_tIME>
   101cb:	83 c4 10             	add    $0x10,%esp
   101ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
   101d1:	e9 26 01 00 00       	jmp    102fc <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
   101d6:	83 ec 08             	sub    $0x8,%esp
   101d9:	68 cb ac 01 00       	push   $0x1accb
   101de:	ff 75 ec             	pushl  -0x14(%ebp)
   101e1:	e8 94 8c ff ff       	call   8e7a <lodepng_chunk_type_equals>
   101e6:	83 c4 10             	add    $0x10,%esp
   101e9:	84 c0                	test   %al,%al
   101eb:	74 24                	je     10211 <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
   101ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
   101f0:	8b 55 08             	mov    0x8(%ebp),%edx
   101f3:	81 c2 98 00 00 00    	add    $0x98,%edx
   101f9:	83 ec 04             	sub    $0x4,%esp
   101fc:	50                   	push   %eax
   101fd:	ff 75 e4             	pushl  -0x1c(%ebp)
   10200:	52                   	push   %edx
   10201:	e8 c0 f7 ff ff       	call   f9c6 <readChunk_pHYs>
   10206:	83 c4 10             	add    $0x10,%esp
   10209:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1020c:	e9 eb 00 00 00       	jmp    102fc <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
   10211:	83 ec 08             	sub    $0x8,%esp
   10214:	68 d0 ac 01 00       	push   $0x1acd0
   10219:	ff 75 ec             	pushl  -0x14(%ebp)
   1021c:	e8 59 8c ff ff       	call   8e7a <lodepng_chunk_type_equals>
   10221:	83 c4 10             	add    $0x10,%esp
   10224:	84 c0                	test   %al,%al
   10226:	74 24                	je     1024c <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
   10228:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1022b:	8b 55 08             	mov    0x8(%ebp),%edx
   1022e:	81 c2 98 00 00 00    	add    $0x98,%edx
   10234:	83 ec 04             	sub    $0x4,%esp
   10237:	50                   	push   %eax
   10238:	ff 75 e4             	pushl  -0x1c(%ebp)
   1023b:	52                   	push   %edx
   1023c:	e8 54 f8 ff ff       	call   fa95 <readChunk_gAMA>
   10241:	83 c4 10             	add    $0x10,%esp
   10244:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10247:	e9 b0 00 00 00       	jmp    102fc <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   1024c:	83 ec 08             	sub    $0x8,%esp
   1024f:	68 d5 ac 01 00       	push   $0x1acd5
   10254:	ff 75 ec             	pushl  -0x14(%ebp)
   10257:	e8 1e 8c ff ff       	call   8e7a <lodepng_chunk_type_equals>
   1025c:	83 c4 10             	add    $0x10,%esp
   1025f:	84 c0                	test   %al,%al
   10261:	74 21                	je     10284 <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
   10263:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10266:	8b 55 08             	mov    0x8(%ebp),%edx
   10269:	81 c2 98 00 00 00    	add    $0x98,%edx
   1026f:	83 ec 04             	sub    $0x4,%esp
   10272:	50                   	push   %eax
   10273:	ff 75 e4             	pushl  -0x1c(%ebp)
   10276:	52                   	push   %edx
   10277:	e8 88 f8 ff ff       	call   fb04 <readChunk_cHRM>
   1027c:	83 c4 10             	add    $0x10,%esp
   1027f:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10282:	eb 78                	jmp    102fc <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   10284:	83 ec 08             	sub    $0x8,%esp
   10287:	68 da ac 01 00       	push   $0x1acda
   1028c:	ff 75 ec             	pushl  -0x14(%ebp)
   1028f:	e8 e6 8b ff ff       	call   8e7a <lodepng_chunk_type_equals>
   10294:	83 c4 10             	add    $0x10,%esp
   10297:	84 c0                	test   %al,%al
   10299:	74 21                	je     102bc <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
   1029b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1029e:	8b 55 08             	mov    0x8(%ebp),%edx
   102a1:	81 c2 98 00 00 00    	add    $0x98,%edx
   102a7:	83 ec 04             	sub    $0x4,%esp
   102aa:	50                   	push   %eax
   102ab:	ff 75 e4             	pushl  -0x1c(%ebp)
   102ae:	52                   	push   %edx
   102af:	e8 e4 fa ff ff       	call   fd98 <readChunk_sRGB>
   102b4:	83 c4 10             	add    $0x10,%esp
   102b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
   102ba:	eb 40                	jmp    102fc <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   102bc:	83 ec 08             	sub    $0x8,%esp
   102bf:	68 df ac 01 00       	push   $0x1acdf
   102c4:	ff 75 ec             	pushl  -0x14(%ebp)
   102c7:	e8 ae 8b ff ff       	call   8e7a <lodepng_chunk_type_equals>
   102cc:	83 c4 10             	add    $0x10,%esp
   102cf:	84 c0                	test   %al,%al
   102d1:	74 22                	je     102f5 <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   102d3:	8b 55 e8             	mov    -0x18(%ebp),%edx
   102d6:	8b 45 08             	mov    0x8(%ebp),%eax
   102d9:	8b 4d 08             	mov    0x8(%ebp),%ecx
   102dc:	81 c1 98 00 00 00    	add    $0x98,%ecx
   102e2:	52                   	push   %edx
   102e3:	ff 75 e4             	pushl  -0x1c(%ebp)
   102e6:	50                   	push   %eax
   102e7:	51                   	push   %ecx
   102e8:	e8 e1 fa ff ff       	call   fdce <readChunk_iCCP>
   102ed:	83 c4 10             	add    $0x10,%esp
   102f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
   102f3:	eb 07                	jmp    102fc <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
   102f5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
   102fc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10300:	75 29                	jne    1032b <lodepng_inspect_chunk+0x374>
   10302:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10306:	75 23                	jne    1032b <lodepng_inspect_chunk+0x374>
   10308:	8b 45 08             	mov    0x8(%ebp),%eax
   1030b:	8b 40 18             	mov    0x18(%eax),%eax
   1030e:	85 c0                	test   %eax,%eax
   10310:	75 19                	jne    1032b <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
   10312:	83 ec 0c             	sub    $0xc,%esp
   10315:	ff 75 ec             	pushl  -0x14(%ebp)
   10318:	e8 53 8c ff ff       	call   8f70 <lodepng_chunk_check_crc>
   1031d:	83 c4 10             	add    $0x10,%esp
   10320:	85 c0                	test   %eax,%eax
   10322:	74 07                	je     1032b <lodepng_inspect_chunk+0x374>
   10324:	b8 39 00 00 00       	mov    $0x39,%eax
   10329:	eb 03                	jmp    1032e <lodepng_inspect_chunk+0x377>
  }

  return error;
   1032b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   1032e:	c9                   	leave  
   1032f:	c3                   	ret    

00010330 <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
   10330:	55                   	push   %ebp
   10331:	89 e5                	mov    %esp,%ebp
   10333:	56                   	push   %esi
   10334:	53                   	push   %ebx
   10335:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
   10338:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
   1033c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
   10343:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
   1034a:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   10351:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
   10358:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
   1035f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
   10366:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
   1036d:	8b 45 08             	mov    0x8(%ebp),%eax
   10370:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   10376:	8b 45 10             	mov    0x10(%ebp),%eax
   10379:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1037f:	8b 45 10             	mov    0x10(%ebp),%eax
   10382:	8b 10                	mov    (%eax),%edx
   10384:	8b 45 0c             	mov    0xc(%ebp),%eax
   10387:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
   10389:	83 ec 0c             	sub    $0xc,%esp
   1038c:	ff 75 1c             	pushl  0x1c(%ebp)
   1038f:	ff 75 18             	pushl  0x18(%ebp)
   10392:	ff 75 14             	pushl  0x14(%ebp)
   10395:	ff 75 10             	pushl  0x10(%ebp)
   10398:	ff 75 0c             	pushl  0xc(%ebp)
   1039b:	e8 d3 da ff ff       	call   de73 <lodepng_inspect>
   103a0:	83 c4 20             	add    $0x20,%esp
   103a3:	89 c2                	mov    %eax,%edx
   103a5:	8b 45 14             	mov    0x14(%ebp),%eax
   103a8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
   103ae:	8b 45 14             	mov    0x14(%ebp),%eax
   103b1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   103b7:	85 c0                	test   %eax,%eax
   103b9:	0f 85 24 0a 00 00    	jne    10de3 <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
   103bf:	8b 45 14             	mov    0x14(%ebp),%eax
   103c2:	8d 58 78             	lea    0x78(%eax),%ebx
   103c5:	8b 45 14             	mov    0x14(%ebp),%eax
   103c8:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   103ce:	8b 45 10             	mov    0x10(%ebp),%eax
   103d1:	8b 10                	mov    (%eax),%edx
   103d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   103d6:	8b 00                	mov    (%eax),%eax
   103d8:	53                   	push   %ebx
   103d9:	51                   	push   %ecx
   103da:	52                   	push   %edx
   103db:	50                   	push   %eax
   103dc:	e8 76 97 ff ff       	call   9b57 <lodepng_pixel_overflow>
   103e1:	83 c4 10             	add    $0x10,%esp
   103e4:	85 c0                	test   %eax,%eax
   103e6:	74 12                	je     103fa <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
   103e8:	8b 45 14             	mov    0x14(%ebp),%eax
   103eb:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
   103f2:	00 00 00 
   103f5:	e9 ea 09 00 00       	jmp    10de4 <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
   103fa:	83 ec 0c             	sub    $0xc,%esp
   103fd:	ff 75 1c             	pushl  0x1c(%ebp)
   10400:	e8 a6 3a ff ff       	call   3eab <lodepng_malloc>
   10405:	83 c4 10             	add    $0x10,%esp
   10408:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
   1040b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1040f:	75 12                	jne    10423 <decodeGeneric+0xf3>
   10411:	8b 45 14             	mov    0x14(%ebp),%eax
   10414:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   1041b:	00 00 00 
   1041e:	e9 c1 09 00 00       	jmp    10de4 <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
   10423:	8b 45 18             	mov    0x18(%ebp),%eax
   10426:	83 c0 21             	add    $0x21,%eax
   10429:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   1042c:	e9 81 06 00 00       	jmp    10ab2 <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
   10431:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10434:	8b 45 18             	mov    0x18(%ebp),%eax
   10437:	29 c2                	sub    %eax,%edx
   10439:	89 d0                	mov    %edx,%eax
   1043b:	83 c0 0c             	add    $0xc,%eax
   1043e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   10441:	7f 08                	jg     1044b <decodeGeneric+0x11b>
   10443:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10446:	3b 45 18             	cmp    0x18(%ebp),%eax
   10449:	73 20                	jae    1046b <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   1044b:	8b 45 14             	mov    0x14(%ebp),%eax
   1044e:	8b 40 20             	mov    0x20(%eax),%eax
   10451:	85 c0                	test   %eax,%eax
   10453:	0f 85 72 06 00 00    	jne    10acb <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
   10459:	8b 45 14             	mov    0x14(%ebp),%eax
   1045c:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
   10463:	00 00 00 
   10466:	e9 6a 06 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
   1046b:	83 ec 0c             	sub    $0xc,%esp
   1046e:	ff 75 f0             	pushl  -0x10(%ebp)
   10471:	e8 b7 89 ff ff       	call   8e2d <lodepng_chunk_length>
   10476:	83 c4 10             	add    $0x10,%esp
   10479:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
   1047c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1047f:	85 c0                	test   %eax,%eax
   10481:	79 20                	jns    104a3 <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   10483:	8b 45 14             	mov    0x14(%ebp),%eax
   10486:	8b 40 20             	mov    0x20(%eax),%eax
   10489:	85 c0                	test   %eax,%eax
   1048b:	0f 85 3d 06 00 00    	jne    10ace <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
   10491:	8b 45 14             	mov    0x14(%ebp),%eax
   10494:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
   1049b:	00 00 00 
   1049e:	e9 32 06 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
   104a3:	8b 55 f0             	mov    -0x10(%ebp),%edx
   104a6:	8b 45 18             	mov    0x18(%ebp),%eax
   104a9:	29 c2                	sub    %eax,%edx
   104ab:	89 d0                	mov    %edx,%eax
   104ad:	89 c2                	mov    %eax,%edx
   104af:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   104b2:	01 d0                	add    %edx,%eax
   104b4:	83 c0 0c             	add    $0xc,%eax
   104b7:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   104ba:	7f 10                	jg     104cc <decodeGeneric+0x19c>
   104bc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   104bf:	8d 50 0c             	lea    0xc(%eax),%edx
   104c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   104c5:	01 d0                	add    %edx,%eax
   104c7:	3b 45 18             	cmp    0x18(%ebp),%eax
   104ca:	73 12                	jae    104de <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
   104cc:	8b 45 14             	mov    0x14(%ebp),%eax
   104cf:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
   104d6:	00 00 00 
   104d9:	e9 f7 05 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
   104de:	83 ec 0c             	sub    $0xc,%esp
   104e1:	ff 75 f0             	pushl  -0x10(%ebp)
   104e4:	e8 7c 8a ff ff       	call   8f65 <lodepng_chunk_data_const>
   104e9:	83 c4 10             	add    $0x10,%esp
   104ec:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
   104ef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
   104f6:	83 ec 08             	sub    $0x8,%esp
   104f9:	68 e4 ac 01 00       	push   $0x1ace4
   104fe:	ff 75 f0             	pushl  -0x10(%ebp)
   10501:	e8 74 89 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   10506:	83 c4 10             	add    $0x10,%esp
   10509:	84 c0                	test   %al,%al
   1050b:	74 79                	je     10586 <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
   1050d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10510:	83 ec 04             	sub    $0x4,%esp
   10513:	8d 55 bc             	lea    -0x44(%ebp),%edx
   10516:	52                   	push   %edx
   10517:	50                   	push   %eax
   10518:	ff 75 ec             	pushl  -0x14(%ebp)
   1051b:	e8 4f 3a ff ff       	call   3f6f <lodepng_addofl>
   10520:	83 c4 10             	add    $0x10,%esp
   10523:	85 c0                	test   %eax,%eax
   10525:	74 12                	je     10539 <decodeGeneric+0x209>
   10527:	8b 45 14             	mov    0x14(%ebp),%eax
   1052a:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
   10531:	00 00 00 
   10534:	e9 9c 05 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
   10539:	8b 45 bc             	mov    -0x44(%ebp),%eax
   1053c:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   1053f:	7e 13                	jle    10554 <decodeGeneric+0x224>
   10541:	8b 45 14             	mov    0x14(%ebp),%eax
   10544:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
   1054b:	00 00 00 
   1054e:	90                   	nop
   1054f:	e9 81 05 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
   10554:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10557:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   1055a:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1055d:	01 ca                	add    %ecx,%edx
   1055f:	83 ec 04             	sub    $0x4,%esp
   10562:	50                   	push   %eax
   10563:	ff 75 d0             	pushl  -0x30(%ebp)
   10566:	52                   	push   %edx
   10567:	e8 7d 39 ff ff       	call   3ee9 <lodepng_memcpy>
   1056c:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
   1056f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10572:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10575:	01 d0                	add    %edx,%eax
   10577:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
   1057a:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
   10581:	e9 db 04 00 00       	jmp    10a61 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
   10586:	83 ec 08             	sub    $0x8,%esp
   10589:	68 e9 ac 01 00       	push   $0x1ace9
   1058e:	ff 75 f0             	pushl  -0x10(%ebp)
   10591:	e8 e4 88 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   10596:	83 c4 10             	add    $0x10,%esp
   10599:	84 c0                	test   %al,%al
   1059b:	74 09                	je     105a6 <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
   1059d:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
   105a1:	e9 bb 04 00 00       	jmp    10a61 <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
   105a6:	83 ec 08             	sub    $0x8,%esp
   105a9:	68 a8 ac 01 00       	push   $0x1aca8
   105ae:	ff 75 f0             	pushl  -0x10(%ebp)
   105b1:	e8 c4 88 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   105b6:	83 c4 10             	add    $0x10,%esp
   105b9:	84 c0                	test   %al,%al
   105bb:	74 44                	je     10601 <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
   105bd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   105c0:	8b 55 14             	mov    0x14(%ebp),%edx
   105c3:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   105c9:	83 ec 04             	sub    $0x4,%esp
   105cc:	50                   	push   %eax
   105cd:	ff 75 d0             	pushl  -0x30(%ebp)
   105d0:	52                   	push   %edx
   105d1:	e8 ec e8 ff ff       	call   eec2 <readChunk_PLTE>
   105d6:	83 c4 10             	add    $0x10,%esp
   105d9:	89 c2                	mov    %eax,%edx
   105db:	8b 45 14             	mov    0x14(%ebp),%eax
   105de:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   105e4:	8b 45 14             	mov    0x14(%ebp),%eax
   105e7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   105ed:	85 c0                	test   %eax,%eax
   105ef:	0f 85 dc 04 00 00    	jne    10ad1 <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
   105f5:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
   105fc:	e9 60 04 00 00       	jmp    10a61 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
   10601:	83 ec 08             	sub    $0x8,%esp
   10604:	68 ad ac 01 00       	push   $0x1acad
   10609:	ff 75 f0             	pushl  -0x10(%ebp)
   1060c:	e8 69 88 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   10611:	83 c4 10             	add    $0x10,%esp
   10614:	84 c0                	test   %al,%al
   10616:	74 3d                	je     10655 <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
   10618:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1061b:	8b 55 14             	mov    0x14(%ebp),%edx
   1061e:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   10624:	83 ec 04             	sub    $0x4,%esp
   10627:	50                   	push   %eax
   10628:	ff 75 d0             	pushl  -0x30(%ebp)
   1062b:	52                   	push   %edx
   1062c:	e8 b1 e9 ff ff       	call   efe2 <readChunk_tRNS>
   10631:	83 c4 10             	add    $0x10,%esp
   10634:	89 c2                	mov    %eax,%edx
   10636:	8b 45 14             	mov    0x14(%ebp),%eax
   10639:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   1063f:	8b 45 14             	mov    0x14(%ebp),%eax
   10642:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10648:	85 c0                	test   %eax,%eax
   1064a:	0f 84 11 04 00 00    	je     10a61 <decodeGeneric+0x731>
   10650:	e9 80 04 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
   10655:	83 ec 08             	sub    $0x8,%esp
   10658:	68 b2 ac 01 00       	push   $0x1acb2
   1065d:	ff 75 f0             	pushl  -0x10(%ebp)
   10660:	e8 15 88 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   10665:	83 c4 10             	add    $0x10,%esp
   10668:	84 c0                	test   %al,%al
   1066a:	74 3d                	je     106a9 <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
   1066c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1066f:	8b 55 14             	mov    0x14(%ebp),%edx
   10672:	81 c2 98 00 00 00    	add    $0x98,%edx
   10678:	83 ec 04             	sub    $0x4,%esp
   1067b:	50                   	push   %eax
   1067c:	ff 75 d0             	pushl  -0x30(%ebp)
   1067f:	52                   	push   %edx
   10680:	e8 c0 ea ff ff       	call   f145 <readChunk_bKGD>
   10685:	83 c4 10             	add    $0x10,%esp
   10688:	89 c2                	mov    %eax,%edx
   1068a:	8b 45 14             	mov    0x14(%ebp),%eax
   1068d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10693:	8b 45 14             	mov    0x14(%ebp),%eax
   10696:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1069c:	85 c0                	test   %eax,%eax
   1069e:	0f 84 bd 03 00 00    	je     10a61 <decodeGeneric+0x731>
   106a4:	e9 2c 04 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
   106a9:	83 ec 08             	sub    $0x8,%esp
   106ac:	68 b7 ac 01 00       	push   $0x1acb7
   106b1:	ff 75 f0             	pushl  -0x10(%ebp)
   106b4:	e8 c1 87 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   106b9:	83 c4 10             	add    $0x10,%esp
   106bc:	84 c0                	test   %al,%al
   106be:	74 4b                	je     1070b <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
   106c0:	8b 45 14             	mov    0x14(%ebp),%eax
   106c3:	8b 40 28             	mov    0x28(%eax),%eax
   106c6:	85 c0                	test   %eax,%eax
   106c8:	0f 84 93 03 00 00    	je     10a61 <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
   106ce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   106d1:	8b 55 14             	mov    0x14(%ebp),%edx
   106d4:	81 c2 98 00 00 00    	add    $0x98,%edx
   106da:	83 ec 04             	sub    $0x4,%esp
   106dd:	50                   	push   %eax
   106de:	ff 75 d0             	pushl  -0x30(%ebp)
   106e1:	52                   	push   %edx
   106e2:	e8 e1 eb ff ff       	call   f2c8 <readChunk_tEXt>
   106e7:	83 c4 10             	add    $0x10,%esp
   106ea:	89 c2                	mov    %eax,%edx
   106ec:	8b 45 14             	mov    0x14(%ebp),%eax
   106ef:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   106f5:	8b 45 14             	mov    0x14(%ebp),%eax
   106f8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   106fe:	85 c0                	test   %eax,%eax
   10700:	0f 84 5b 03 00 00    	je     10a61 <decodeGeneric+0x731>
   10706:	e9 ca 03 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
   1070b:	83 ec 08             	sub    $0x8,%esp
   1070e:	68 bc ac 01 00       	push   $0x1acbc
   10713:	ff 75 f0             	pushl  -0x10(%ebp)
   10716:	e8 5f 87 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   1071b:	83 c4 10             	add    $0x10,%esp
   1071e:	84 c0                	test   %al,%al
   10720:	74 4c                	je     1076e <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
   10722:	8b 45 14             	mov    0x14(%ebp),%eax
   10725:	8b 40 28             	mov    0x28(%eax),%eax
   10728:	85 c0                	test   %eax,%eax
   1072a:	0f 84 31 03 00 00    	je     10a61 <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
   10730:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   10733:	8b 45 14             	mov    0x14(%ebp),%eax
   10736:	8b 4d 14             	mov    0x14(%ebp),%ecx
   10739:	81 c1 98 00 00 00    	add    $0x98,%ecx
   1073f:	52                   	push   %edx
   10740:	ff 75 d0             	pushl  -0x30(%ebp)
   10743:	50                   	push   %eax
   10744:	51                   	push   %ecx
   10745:	e8 ca ec ff ff       	call   f414 <readChunk_zTXt>
   1074a:	83 c4 10             	add    $0x10,%esp
   1074d:	89 c2                	mov    %eax,%edx
   1074f:	8b 45 14             	mov    0x14(%ebp),%eax
   10752:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   10758:	8b 45 14             	mov    0x14(%ebp),%eax
   1075b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10761:	85 c0                	test   %eax,%eax
   10763:	0f 84 f8 02 00 00    	je     10a61 <decodeGeneric+0x731>
   10769:	e9 67 03 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
   1076e:	83 ec 08             	sub    $0x8,%esp
   10771:	68 c1 ac 01 00       	push   $0x1acc1
   10776:	ff 75 f0             	pushl  -0x10(%ebp)
   10779:	e8 fc 86 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   1077e:	83 c4 10             	add    $0x10,%esp
   10781:	84 c0                	test   %al,%al
   10783:	74 4c                	je     107d1 <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
   10785:	8b 45 14             	mov    0x14(%ebp),%eax
   10788:	8b 40 28             	mov    0x28(%eax),%eax
   1078b:	85 c0                	test   %eax,%eax
   1078d:	0f 84 ce 02 00 00    	je     10a61 <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
   10793:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   10796:	8b 45 14             	mov    0x14(%ebp),%eax
   10799:	8b 4d 14             	mov    0x14(%ebp),%ecx
   1079c:	81 c1 98 00 00 00    	add    $0x98,%ecx
   107a2:	52                   	push   %edx
   107a3:	ff 75 d0             	pushl  -0x30(%ebp)
   107a6:	50                   	push   %eax
   107a7:	51                   	push   %ecx
   107a8:	e8 23 ee ff ff       	call   f5d0 <readChunk_iTXt>
   107ad:	83 c4 10             	add    $0x10,%esp
   107b0:	89 c2                	mov    %eax,%edx
   107b2:	8b 45 14             	mov    0x14(%ebp),%eax
   107b5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   107bb:	8b 45 14             	mov    0x14(%ebp),%eax
   107be:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   107c4:	85 c0                	test   %eax,%eax
   107c6:	0f 84 95 02 00 00    	je     10a61 <decodeGeneric+0x731>
   107cc:	e9 04 03 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
   107d1:	83 ec 08             	sub    $0x8,%esp
   107d4:	68 c6 ac 01 00       	push   $0x1acc6
   107d9:	ff 75 f0             	pushl  -0x10(%ebp)
   107dc:	e8 99 86 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   107e1:	83 c4 10             	add    $0x10,%esp
   107e4:	84 c0                	test   %al,%al
   107e6:	74 3d                	je     10825 <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
   107e8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   107eb:	8b 55 14             	mov    0x14(%ebp),%edx
   107ee:	81 c2 98 00 00 00    	add    $0x98,%edx
   107f4:	83 ec 04             	sub    $0x4,%esp
   107f7:	50                   	push   %eax
   107f8:	ff 75 d0             	pushl  -0x30(%ebp)
   107fb:	52                   	push   %edx
   107fc:	e8 25 f1 ff ff       	call   f926 <readChunk_tIME>
   10801:	83 c4 10             	add    $0x10,%esp
   10804:	89 c2                	mov    %eax,%edx
   10806:	8b 45 14             	mov    0x14(%ebp),%eax
   10809:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   1080f:	8b 45 14             	mov    0x14(%ebp),%eax
   10812:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10818:	85 c0                	test   %eax,%eax
   1081a:	0f 84 41 02 00 00    	je     10a61 <decodeGeneric+0x731>
   10820:	e9 b0 02 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
   10825:	83 ec 08             	sub    $0x8,%esp
   10828:	68 cb ac 01 00       	push   $0x1accb
   1082d:	ff 75 f0             	pushl  -0x10(%ebp)
   10830:	e8 45 86 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   10835:	83 c4 10             	add    $0x10,%esp
   10838:	84 c0                	test   %al,%al
   1083a:	74 3d                	je     10879 <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
   1083c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1083f:	8b 55 14             	mov    0x14(%ebp),%edx
   10842:	81 c2 98 00 00 00    	add    $0x98,%edx
   10848:	83 ec 04             	sub    $0x4,%esp
   1084b:	50                   	push   %eax
   1084c:	ff 75 d0             	pushl  -0x30(%ebp)
   1084f:	52                   	push   %edx
   10850:	e8 71 f1 ff ff       	call   f9c6 <readChunk_pHYs>
   10855:	83 c4 10             	add    $0x10,%esp
   10858:	89 c2                	mov    %eax,%edx
   1085a:	8b 45 14             	mov    0x14(%ebp),%eax
   1085d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10863:	8b 45 14             	mov    0x14(%ebp),%eax
   10866:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1086c:	85 c0                	test   %eax,%eax
   1086e:	0f 84 ed 01 00 00    	je     10a61 <decodeGeneric+0x731>
   10874:	e9 5c 02 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
   10879:	83 ec 08             	sub    $0x8,%esp
   1087c:	68 d0 ac 01 00       	push   $0x1acd0
   10881:	ff 75 f0             	pushl  -0x10(%ebp)
   10884:	e8 f1 85 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   10889:	83 c4 10             	add    $0x10,%esp
   1088c:	84 c0                	test   %al,%al
   1088e:	74 3d                	je     108cd <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
   10890:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10893:	8b 55 14             	mov    0x14(%ebp),%edx
   10896:	81 c2 98 00 00 00    	add    $0x98,%edx
   1089c:	83 ec 04             	sub    $0x4,%esp
   1089f:	50                   	push   %eax
   108a0:	ff 75 d0             	pushl  -0x30(%ebp)
   108a3:	52                   	push   %edx
   108a4:	e8 ec f1 ff ff       	call   fa95 <readChunk_gAMA>
   108a9:	83 c4 10             	add    $0x10,%esp
   108ac:	89 c2                	mov    %eax,%edx
   108ae:	8b 45 14             	mov    0x14(%ebp),%eax
   108b1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   108b7:	8b 45 14             	mov    0x14(%ebp),%eax
   108ba:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   108c0:	85 c0                	test   %eax,%eax
   108c2:	0f 84 99 01 00 00    	je     10a61 <decodeGeneric+0x731>
   108c8:	e9 08 02 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   108cd:	83 ec 08             	sub    $0x8,%esp
   108d0:	68 d5 ac 01 00       	push   $0x1acd5
   108d5:	ff 75 f0             	pushl  -0x10(%ebp)
   108d8:	e8 9d 85 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   108dd:	83 c4 10             	add    $0x10,%esp
   108e0:	84 c0                	test   %al,%al
   108e2:	74 3d                	je     10921 <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
   108e4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   108e7:	8b 55 14             	mov    0x14(%ebp),%edx
   108ea:	81 c2 98 00 00 00    	add    $0x98,%edx
   108f0:	83 ec 04             	sub    $0x4,%esp
   108f3:	50                   	push   %eax
   108f4:	ff 75 d0             	pushl  -0x30(%ebp)
   108f7:	52                   	push   %edx
   108f8:	e8 07 f2 ff ff       	call   fb04 <readChunk_cHRM>
   108fd:	83 c4 10             	add    $0x10,%esp
   10900:	89 c2                	mov    %eax,%edx
   10902:	8b 45 14             	mov    0x14(%ebp),%eax
   10905:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   1090b:	8b 45 14             	mov    0x14(%ebp),%eax
   1090e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10914:	85 c0                	test   %eax,%eax
   10916:	0f 84 45 01 00 00    	je     10a61 <decodeGeneric+0x731>
   1091c:	e9 b4 01 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   10921:	83 ec 08             	sub    $0x8,%esp
   10924:	68 da ac 01 00       	push   $0x1acda
   10929:	ff 75 f0             	pushl  -0x10(%ebp)
   1092c:	e8 49 85 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   10931:	83 c4 10             	add    $0x10,%esp
   10934:	84 c0                	test   %al,%al
   10936:	74 3d                	je     10975 <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
   10938:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1093b:	8b 55 14             	mov    0x14(%ebp),%edx
   1093e:	81 c2 98 00 00 00    	add    $0x98,%edx
   10944:	83 ec 04             	sub    $0x4,%esp
   10947:	50                   	push   %eax
   10948:	ff 75 d0             	pushl  -0x30(%ebp)
   1094b:	52                   	push   %edx
   1094c:	e8 47 f4 ff ff       	call   fd98 <readChunk_sRGB>
   10951:	83 c4 10             	add    $0x10,%esp
   10954:	89 c2                	mov    %eax,%edx
   10956:	8b 45 14             	mov    0x14(%ebp),%eax
   10959:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   1095f:	8b 45 14             	mov    0x14(%ebp),%eax
   10962:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10968:	85 c0                	test   %eax,%eax
   1096a:	0f 84 f1 00 00 00    	je     10a61 <decodeGeneric+0x731>
   10970:	e9 60 01 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   10975:	83 ec 08             	sub    $0x8,%esp
   10978:	68 df ac 01 00       	push   $0x1acdf
   1097d:	ff 75 f0             	pushl  -0x10(%ebp)
   10980:	e8 f5 84 ff ff       	call   8e7a <lodepng_chunk_type_equals>
   10985:	83 c4 10             	add    $0x10,%esp
   10988:	84 c0                	test   %al,%al
   1098a:	74 3e                	je     109ca <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   1098c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   1098f:	8b 45 14             	mov    0x14(%ebp),%eax
   10992:	8b 4d 14             	mov    0x14(%ebp),%ecx
   10995:	81 c1 98 00 00 00    	add    $0x98,%ecx
   1099b:	52                   	push   %edx
   1099c:	ff 75 d0             	pushl  -0x30(%ebp)
   1099f:	50                   	push   %eax
   109a0:	51                   	push   %ecx
   109a1:	e8 28 f4 ff ff       	call   fdce <readChunk_iCCP>
   109a6:	83 c4 10             	add    $0x10,%esp
   109a9:	89 c2                	mov    %eax,%edx
   109ab:	8b 45 14             	mov    0x14(%ebp),%eax
   109ae:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   109b4:	8b 45 14             	mov    0x14(%ebp),%eax
   109b7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   109bd:	85 c0                	test   %eax,%eax
   109bf:	0f 84 9c 00 00 00    	je     10a61 <decodeGeneric+0x731>
   109c5:	e9 0b 01 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
   109ca:	8b 45 14             	mov    0x14(%ebp),%eax
   109cd:	8b 40 1c             	mov    0x1c(%eax),%eax
   109d0:	85 c0                	test   %eax,%eax
   109d2:	75 24                	jne    109f8 <decodeGeneric+0x6c8>
   109d4:	83 ec 0c             	sub    $0xc,%esp
   109d7:	ff 75 f0             	pushl  -0x10(%ebp)
   109da:	e8 30 85 ff ff       	call   8f0f <lodepng_chunk_ancillary>
   109df:	83 c4 10             	add    $0x10,%esp
   109e2:	84 c0                	test   %al,%al
   109e4:	75 12                	jne    109f8 <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
   109e6:	8b 45 14             	mov    0x14(%ebp),%eax
   109e9:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
   109f0:	00 00 00 
   109f3:	e9 dd 00 00 00       	jmp    10ad5 <decodeGeneric+0x7a5>
      }

      unknown = 1;
   109f8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
   109ff:	8b 45 14             	mov    0x14(%ebp),%eax
   10a02:	8b 40 2c             	mov    0x2c(%eax),%eax
   10a05:	85 c0                	test   %eax,%eax
   10a07:	74 58                	je     10a61 <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
   10a09:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10a0c:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
   10a0f:	83 c0 58             	add    $0x58,%eax
   10a12:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10a19:	8b 45 14             	mov    0x14(%ebp),%eax
   10a1c:	01 d0                	add    %edx,%eax
   10a1e:	8d 50 10             	lea    0x10(%eax),%edx
   10a21:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10a24:	83 e8 01             	sub    $0x1,%eax
   10a27:	83 c0 54             	add    $0x54,%eax
   10a2a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   10a31:	8b 45 14             	mov    0x14(%ebp),%eax
   10a34:	01 c8                	add    %ecx,%eax
   10a36:	83 c0 14             	add    $0x14,%eax
   10a39:	83 ec 04             	sub    $0x4,%esp
   10a3c:	ff 75 f0             	pushl  -0x10(%ebp)
   10a3f:	52                   	push   %edx
   10a40:	50                   	push   %eax
   10a41:	e8 15 88 ff ff       	call   925b <lodepng_chunk_append>
   10a46:	83 c4 10             	add    $0x10,%esp
   10a49:	89 c2                	mov    %eax,%edx
   10a4b:	8b 45 14             	mov    0x14(%ebp),%eax
   10a4e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   10a54:	8b 45 14             	mov    0x14(%ebp),%eax
   10a57:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10a5d:	85 c0                	test   %eax,%eax
   10a5f:	75 73                	jne    10ad4 <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
   10a61:	8b 45 14             	mov    0x14(%ebp),%eax
   10a64:	8b 40 18             	mov    0x18(%eax),%eax
   10a67:	85 c0                	test   %eax,%eax
   10a69:	75 27                	jne    10a92 <decodeGeneric+0x762>
   10a6b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10a6f:	75 21                	jne    10a92 <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
   10a71:	83 ec 0c             	sub    $0xc,%esp
   10a74:	ff 75 f0             	pushl  -0x10(%ebp)
   10a77:	e8 f4 84 ff ff       	call   8f70 <lodepng_chunk_check_crc>
   10a7c:	83 c4 10             	add    $0x10,%esp
   10a7f:	85 c0                	test   %eax,%eax
   10a81:	74 0f                	je     10a92 <decodeGeneric+0x762>
   10a83:	8b 45 14             	mov    0x14(%ebp),%eax
   10a86:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
   10a8d:	00 00 00 
   10a90:	eb 43                	jmp    10ad5 <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
   10a92:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   10a96:	75 1a                	jne    10ab2 <decodeGeneric+0x782>
   10a98:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10a9b:	8b 45 18             	mov    0x18(%ebp),%eax
   10a9e:	01 d0                	add    %edx,%eax
   10aa0:	83 ec 08             	sub    $0x8,%esp
   10aa3:	50                   	push   %eax
   10aa4:	ff 75 f0             	pushl  -0x10(%ebp)
   10aa7:	e8 3f 86 ff ff       	call   90eb <lodepng_chunk_next_const>
   10aac:	83 c4 10             	add    $0x10,%esp
   10aaf:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   10ab2:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   10ab6:	75 1d                	jne    10ad5 <decodeGeneric+0x7a5>
   10ab8:	8b 45 14             	mov    0x14(%ebp),%eax
   10abb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10ac1:	85 c0                	test   %eax,%eax
   10ac3:	0f 84 68 f9 ff ff    	je     10431 <decodeGeneric+0x101>
   10ac9:	eb 0a                	jmp    10ad5 <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   10acb:	90                   	nop
   10acc:	eb 07                	jmp    10ad5 <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   10ace:	90                   	nop
   10acf:	eb 04                	jmp    10ad5 <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
   10ad1:	90                   	nop
   10ad2:	eb 01                	jmp    10ad5 <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   10ad4:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
   10ad5:	8b 45 14             	mov    0x14(%ebp),%eax
   10ad8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10ade:	85 c0                	test   %eax,%eax
   10ae0:	75 28                	jne    10b0a <decodeGeneric+0x7da>
   10ae2:	8b 45 14             	mov    0x14(%ebp),%eax
   10ae5:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   10aeb:	83 f8 03             	cmp    $0x3,%eax
   10aee:	75 1a                	jne    10b0a <decodeGeneric+0x7da>
   10af0:	8b 45 14             	mov    0x14(%ebp),%eax
   10af3:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10af9:	85 c0                	test   %eax,%eax
   10afb:	75 0d                	jne    10b0a <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   10afd:	8b 45 14             	mov    0x14(%ebp),%eax
   10b00:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   10b07:	00 00 00 
  }

  if(!state->error) {
   10b0a:	8b 45 14             	mov    0x14(%ebp),%eax
   10b0d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10b13:	85 c0                	test   %eax,%eax
   10b15:	0f 85 d2 01 00 00    	jne    10ced <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   10b1b:	8b 45 14             	mov    0x14(%ebp),%eax
   10b1e:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   10b24:	85 c0                	test   %eax,%eax
   10b26:	75 3a                	jne    10b62 <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   10b28:	8b 45 14             	mov    0x14(%ebp),%eax
   10b2b:	05 a4 00 00 00       	add    $0xa4,%eax
   10b30:	83 ec 0c             	sub    $0xc,%esp
   10b33:	50                   	push   %eax
   10b34:	e8 8e 8e ff ff       	call   99c7 <lodepng_get_bpp>
   10b39:	83 c4 10             	add    $0x10,%esp
   10b3c:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   10b3f:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   10b42:	8b 45 10             	mov    0x10(%ebp),%eax
   10b45:	8b 10                	mov    (%eax),%edx
   10b47:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b4a:	8b 00                	mov    (%eax),%eax
   10b4c:	83 ec 04             	sub    $0x4,%esp
   10b4f:	51                   	push   %ecx
   10b50:	52                   	push   %edx
   10b51:	50                   	push   %eax
   10b52:	e8 cf 8f ff ff       	call   9b26 <lodepng_get_raw_size_idat>
   10b57:	83 c4 10             	add    $0x10,%esp
   10b5a:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10b5d:	e9 60 01 00 00       	jmp    10cc2 <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   10b62:	8b 45 14             	mov    0x14(%ebp),%eax
   10b65:	05 a4 00 00 00       	add    $0xa4,%eax
   10b6a:	83 ec 0c             	sub    $0xc,%esp
   10b6d:	50                   	push   %eax
   10b6e:	e8 54 8e ff ff       	call   99c7 <lodepng_get_bpp>
   10b73:	83 c4 10             	add    $0x10,%esp
   10b76:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   10b79:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   10b80:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10b83:	8b 55 10             	mov    0x10(%ebp),%edx
   10b86:	8b 12                	mov    (%edx),%edx
   10b88:	83 c2 07             	add    $0x7,%edx
   10b8b:	89 d1                	mov    %edx,%ecx
   10b8d:	c1 e9 03             	shr    $0x3,%ecx
   10b90:	8b 55 0c             	mov    0xc(%ebp),%edx
   10b93:	8b 12                	mov    (%edx),%edx
   10b95:	83 c2 07             	add    $0x7,%edx
   10b98:	c1 ea 03             	shr    $0x3,%edx
   10b9b:	83 ec 04             	sub    $0x4,%esp
   10b9e:	50                   	push   %eax
   10b9f:	51                   	push   %ecx
   10ba0:	52                   	push   %edx
   10ba1:	e8 80 8f ff ff       	call   9b26 <lodepng_get_raw_size_idat>
   10ba6:	83 c4 10             	add    $0x10,%esp
   10ba9:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   10bac:	8b 45 0c             	mov    0xc(%ebp),%eax
   10baf:	8b 00                	mov    (%eax),%eax
   10bb1:	83 f8 04             	cmp    $0x4,%eax
   10bb4:	76 2c                	jbe    10be2 <decodeGeneric+0x8b2>
   10bb6:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10bb9:	8b 55 10             	mov    0x10(%ebp),%edx
   10bbc:	8b 12                	mov    (%edx),%edx
   10bbe:	83 c2 07             	add    $0x7,%edx
   10bc1:	89 d1                	mov    %edx,%ecx
   10bc3:	c1 e9 03             	shr    $0x3,%ecx
   10bc6:	8b 55 0c             	mov    0xc(%ebp),%edx
   10bc9:	8b 12                	mov    (%edx),%edx
   10bcb:	83 c2 03             	add    $0x3,%edx
   10bce:	c1 ea 03             	shr    $0x3,%edx
   10bd1:	83 ec 04             	sub    $0x4,%esp
   10bd4:	50                   	push   %eax
   10bd5:	51                   	push   %ecx
   10bd6:	52                   	push   %edx
   10bd7:	e8 4a 8f ff ff       	call   9b26 <lodepng_get_raw_size_idat>
   10bdc:	83 c4 10             	add    $0x10,%esp
   10bdf:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   10be2:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10be5:	8b 55 10             	mov    0x10(%ebp),%edx
   10be8:	8b 12                	mov    (%edx),%edx
   10bea:	83 c2 03             	add    $0x3,%edx
   10bed:	89 d1                	mov    %edx,%ecx
   10bef:	c1 e9 03             	shr    $0x3,%ecx
   10bf2:	8b 55 0c             	mov    0xc(%ebp),%edx
   10bf5:	8b 12                	mov    (%edx),%edx
   10bf7:	83 c2 03             	add    $0x3,%edx
   10bfa:	c1 ea 02             	shr    $0x2,%edx
   10bfd:	83 ec 04             	sub    $0x4,%esp
   10c00:	50                   	push   %eax
   10c01:	51                   	push   %ecx
   10c02:	52                   	push   %edx
   10c03:	e8 1e 8f ff ff       	call   9b26 <lodepng_get_raw_size_idat>
   10c08:	83 c4 10             	add    $0x10,%esp
   10c0b:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   10c0e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c11:	8b 00                	mov    (%eax),%eax
   10c13:	83 f8 02             	cmp    $0x2,%eax
   10c16:	76 2c                	jbe    10c44 <decodeGeneric+0x914>
   10c18:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10c1b:	8b 55 10             	mov    0x10(%ebp),%edx
   10c1e:	8b 12                	mov    (%edx),%edx
   10c20:	83 c2 03             	add    $0x3,%edx
   10c23:	89 d1                	mov    %edx,%ecx
   10c25:	c1 e9 02             	shr    $0x2,%ecx
   10c28:	8b 55 0c             	mov    0xc(%ebp),%edx
   10c2b:	8b 12                	mov    (%edx),%edx
   10c2d:	83 c2 01             	add    $0x1,%edx
   10c30:	c1 ea 02             	shr    $0x2,%edx
   10c33:	83 ec 04             	sub    $0x4,%esp
   10c36:	50                   	push   %eax
   10c37:	51                   	push   %ecx
   10c38:	52                   	push   %edx
   10c39:	e8 e8 8e ff ff       	call   9b26 <lodepng_get_raw_size_idat>
   10c3e:	83 c4 10             	add    $0x10,%esp
   10c41:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   10c44:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10c47:	8b 55 10             	mov    0x10(%ebp),%edx
   10c4a:	8b 12                	mov    (%edx),%edx
   10c4c:	83 c2 01             	add    $0x1,%edx
   10c4f:	89 d1                	mov    %edx,%ecx
   10c51:	c1 e9 02             	shr    $0x2,%ecx
   10c54:	8b 55 0c             	mov    0xc(%ebp),%edx
   10c57:	8b 12                	mov    (%edx),%edx
   10c59:	83 c2 01             	add    $0x1,%edx
   10c5c:	d1 ea                	shr    %edx
   10c5e:	83 ec 04             	sub    $0x4,%esp
   10c61:	50                   	push   %eax
   10c62:	51                   	push   %ecx
   10c63:	52                   	push   %edx
   10c64:	e8 bd 8e ff ff       	call   9b26 <lodepng_get_raw_size_idat>
   10c69:	83 c4 10             	add    $0x10,%esp
   10c6c:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   10c6f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c72:	8b 00                	mov    (%eax),%eax
   10c74:	83 f8 01             	cmp    $0x1,%eax
   10c77:	76 27                	jbe    10ca0 <decodeGeneric+0x970>
   10c79:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10c7c:	8b 55 10             	mov    0x10(%ebp),%edx
   10c7f:	8b 12                	mov    (%edx),%edx
   10c81:	83 c2 01             	add    $0x1,%edx
   10c84:	89 d1                	mov    %edx,%ecx
   10c86:	d1 e9                	shr    %ecx
   10c88:	8b 55 0c             	mov    0xc(%ebp),%edx
   10c8b:	8b 12                	mov    (%edx),%edx
   10c8d:	d1 ea                	shr    %edx
   10c8f:	83 ec 04             	sub    $0x4,%esp
   10c92:	50                   	push   %eax
   10c93:	51                   	push   %ecx
   10c94:	52                   	push   %edx
   10c95:	e8 8c 8e ff ff       	call   9b26 <lodepng_get_raw_size_idat>
   10c9a:	83 c4 10             	add    $0x10,%esp
   10c9d:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   10ca0:	8b 55 c8             	mov    -0x38(%ebp),%edx
   10ca3:	8b 45 10             	mov    0x10(%ebp),%eax
   10ca6:	8b 00                	mov    (%eax),%eax
   10ca8:	d1 e8                	shr    %eax
   10caa:	89 c1                	mov    %eax,%ecx
   10cac:	8b 45 0c             	mov    0xc(%ebp),%eax
   10caf:	8b 00                	mov    (%eax),%eax
   10cb1:	83 ec 04             	sub    $0x4,%esp
   10cb4:	52                   	push   %edx
   10cb5:	51                   	push   %ecx
   10cb6:	50                   	push   %eax
   10cb7:	e8 6a 8e ff ff       	call   9b26 <lodepng_get_raw_size_idat>
   10cbc:	83 c4 10             	add    $0x10,%esp
   10cbf:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   10cc2:	8b 45 14             	mov    0x14(%ebp),%eax
   10cc5:	83 ec 08             	sub    $0x8,%esp
   10cc8:	50                   	push   %eax
   10cc9:	ff 75 ec             	pushl  -0x14(%ebp)
   10ccc:	ff 75 d8             	pushl  -0x28(%ebp)
   10ccf:	ff 75 e8             	pushl  -0x18(%ebp)
   10cd2:	8d 45 c0             	lea    -0x40(%ebp),%eax
   10cd5:	50                   	push   %eax
   10cd6:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   10cd9:	50                   	push   %eax
   10cda:	e8 87 7c ff ff       	call   8966 <zlib_decompress>
   10cdf:	83 c4 20             	add    $0x20,%esp
   10ce2:	89 c2                	mov    %eax,%edx
   10ce4:	8b 45 14             	mov    0x14(%ebp),%eax
   10ce7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   10ced:	8b 45 14             	mov    0x14(%ebp),%eax
   10cf0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10cf6:	85 c0                	test   %eax,%eax
   10cf8:	75 15                	jne    10d0f <decodeGeneric+0x9df>
   10cfa:	8b 45 c0             	mov    -0x40(%ebp),%eax
   10cfd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   10d00:	74 0d                	je     10d0f <decodeGeneric+0x9df>
   10d02:	8b 45 14             	mov    0x14(%ebp),%eax
   10d05:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   10d0c:	00 00 00 
  lodepng_free(idat);
   10d0f:	83 ec 0c             	sub    $0xc,%esp
   10d12:	ff 75 d8             	pushl  -0x28(%ebp)
   10d15:	e8 b2 31 ff ff       	call   3ecc <lodepng_free>
   10d1a:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   10d1d:	8b 45 14             	mov    0x14(%ebp),%eax
   10d20:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10d26:	85 c0                	test   %eax,%eax
   10d28:	75 4f                	jne    10d79 <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   10d2a:	8b 45 14             	mov    0x14(%ebp),%eax
   10d2d:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   10d33:	8b 45 10             	mov    0x10(%ebp),%eax
   10d36:	8b 10                	mov    (%eax),%edx
   10d38:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d3b:	8b 00                	mov    (%eax),%eax
   10d3d:	83 ec 04             	sub    $0x4,%esp
   10d40:	51                   	push   %ecx
   10d41:	52                   	push   %edx
   10d42:	50                   	push   %eax
   10d43:	e8 be 8d ff ff       	call   9b06 <lodepng_get_raw_size>
   10d48:	83 c4 10             	add    $0x10,%esp
   10d4b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10d4e:	83 ec 0c             	sub    $0xc,%esp
   10d51:	ff 75 e4             	pushl  -0x1c(%ebp)
   10d54:	e8 52 31 ff ff       	call   3eab <lodepng_malloc>
   10d59:	83 c4 10             	add    $0x10,%esp
   10d5c:	89 c2                	mov    %eax,%edx
   10d5e:	8b 45 08             	mov    0x8(%ebp),%eax
   10d61:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   10d63:	8b 45 08             	mov    0x8(%ebp),%eax
   10d66:	8b 00                	mov    (%eax),%eax
   10d68:	85 c0                	test   %eax,%eax
   10d6a:	75 0d                	jne    10d79 <decodeGeneric+0xa49>
   10d6c:	8b 45 14             	mov    0x14(%ebp),%eax
   10d6f:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   10d76:	00 00 00 
  }
  if(!state->error) {
   10d79:	8b 45 14             	mov    0x14(%ebp),%eax
   10d7c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10d82:	85 c0                	test   %eax,%eax
   10d84:	75 4c                	jne    10dd2 <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   10d86:	8b 45 08             	mov    0x8(%ebp),%eax
   10d89:	8b 00                	mov    (%eax),%eax
   10d8b:	83 ec 04             	sub    $0x4,%esp
   10d8e:	ff 75 e4             	pushl  -0x1c(%ebp)
   10d91:	6a 00                	push   $0x0
   10d93:	50                   	push   %eax
   10d94:	e8 83 31 ff ff       	call   3f1c <lodepng_memset>
   10d99:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   10d9c:	8b 45 14             	mov    0x14(%ebp),%eax
   10d9f:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   10da5:	8b 45 10             	mov    0x10(%ebp),%eax
   10da8:	8b 18                	mov    (%eax),%ebx
   10daa:	8b 45 0c             	mov    0xc(%ebp),%eax
   10dad:	8b 08                	mov    (%eax),%ecx
   10daf:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   10db2:	8b 45 08             	mov    0x8(%ebp),%eax
   10db5:	8b 00                	mov    (%eax),%eax
   10db7:	83 ec 0c             	sub    $0xc,%esp
   10dba:	56                   	push   %esi
   10dbb:	53                   	push   %ebx
   10dbc:	51                   	push   %ecx
   10dbd:	52                   	push   %edx
   10dbe:	50                   	push   %eax
   10dbf:	e8 05 df ff ff       	call   ecc9 <postProcessScanlines>
   10dc4:	83 c4 20             	add    $0x20,%esp
   10dc7:	89 c2                	mov    %eax,%edx
   10dc9:	8b 45 14             	mov    0x14(%ebp),%eax
   10dcc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   10dd2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10dd5:	83 ec 0c             	sub    $0xc,%esp
   10dd8:	50                   	push   %eax
   10dd9:	e8 ee 30 ff ff       	call   3ecc <lodepng_free>
   10dde:	83 c4 10             	add    $0x10,%esp
   10de1:	eb 01                	jmp    10de4 <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   10de3:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   10de4:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10de7:	5b                   	pop    %ebx
   10de8:	5e                   	pop    %esi
   10de9:	5d                   	pop    %ebp
   10dea:	c3                   	ret    

00010deb <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   10deb:	55                   	push   %ebp
   10dec:	89 e5                	mov    %esp,%ebp
   10dee:	56                   	push   %esi
   10def:	53                   	push   %ebx
   10df0:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   10df3:	8b 45 08             	mov    0x8(%ebp),%eax
   10df6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   10dfc:	83 ec 08             	sub    $0x8,%esp
   10dff:	ff 75 1c             	pushl  0x1c(%ebp)
   10e02:	ff 75 18             	pushl  0x18(%ebp)
   10e05:	ff 75 14             	pushl  0x14(%ebp)
   10e08:	ff 75 10             	pushl  0x10(%ebp)
   10e0b:	ff 75 0c             	pushl  0xc(%ebp)
   10e0e:	ff 75 08             	pushl  0x8(%ebp)
   10e11:	e8 1a f5 ff ff       	call   10330 <decodeGeneric>
   10e16:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   10e19:	8b 45 14             	mov    0x14(%ebp),%eax
   10e1c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10e22:	85 c0                	test   %eax,%eax
   10e24:	74 0e                	je     10e34 <lodepng_decode+0x49>
   10e26:	8b 45 14             	mov    0x14(%ebp),%eax
   10e29:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10e2f:	e9 55 01 00 00       	jmp    10f89 <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   10e34:	8b 45 14             	mov    0x14(%ebp),%eax
   10e37:	8b 40 24             	mov    0x24(%eax),%eax
   10e3a:	85 c0                	test   %eax,%eax
   10e3c:	74 20                	je     10e5e <lodepng_decode+0x73>
   10e3e:	8b 45 14             	mov    0x14(%ebp),%eax
   10e41:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   10e47:	8b 45 14             	mov    0x14(%ebp),%eax
   10e4a:	83 c0 78             	add    $0x78,%eax
   10e4d:	83 ec 08             	sub    $0x8,%esp
   10e50:	52                   	push   %edx
   10e51:	50                   	push   %eax
   10e52:	e8 56 89 ff ff       	call   97ad <lodepng_color_mode_equal>
   10e57:	83 c4 10             	add    $0x10,%esp
   10e5a:	85 c0                	test   %eax,%eax
   10e5c:	74 54                	je     10eb2 <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   10e5e:	8b 45 14             	mov    0x14(%ebp),%eax
   10e61:	8b 40 24             	mov    0x24(%eax),%eax
   10e64:	85 c0                	test   %eax,%eax
   10e66:	0f 85 13 01 00 00    	jne    10f7f <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   10e6c:	8b 45 14             	mov    0x14(%ebp),%eax
   10e6f:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   10e75:	8b 45 14             	mov    0x14(%ebp),%eax
   10e78:	83 c0 78             	add    $0x78,%eax
   10e7b:	83 ec 08             	sub    $0x8,%esp
   10e7e:	52                   	push   %edx
   10e7f:	50                   	push   %eax
   10e80:	e8 3f 88 ff ff       	call   96c4 <lodepng_color_mode_copy>
   10e85:	83 c4 10             	add    $0x10,%esp
   10e88:	89 c2                	mov    %eax,%edx
   10e8a:	8b 45 14             	mov    0x14(%ebp),%eax
   10e8d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   10e93:	8b 45 14             	mov    0x14(%ebp),%eax
   10e96:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10e9c:	85 c0                	test   %eax,%eax
   10e9e:	0f 84 db 00 00 00    	je     10f7f <lodepng_decode+0x194>
   10ea4:	8b 45 14             	mov    0x14(%ebp),%eax
   10ea7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10ead:	e9 d7 00 00 00       	jmp    10f89 <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   10eb2:	8b 45 08             	mov    0x8(%ebp),%eax
   10eb5:	8b 00                	mov    (%eax),%eax
   10eb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   10eba:	8b 45 14             	mov    0x14(%ebp),%eax
   10ebd:	8b 40 78             	mov    0x78(%eax),%eax
   10ec0:	83 f8 02             	cmp    $0x2,%eax
   10ec3:	74 20                	je     10ee5 <lodepng_decode+0xfa>
   10ec5:	8b 45 14             	mov    0x14(%ebp),%eax
   10ec8:	8b 40 78             	mov    0x78(%eax),%eax
   10ecb:	83 f8 06             	cmp    $0x6,%eax
   10ece:	74 15                	je     10ee5 <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   10ed0:	8b 45 14             	mov    0x14(%ebp),%eax
   10ed3:	8b 40 7c             	mov    0x7c(%eax),%eax
   10ed6:	83 f8 08             	cmp    $0x8,%eax
   10ed9:	74 0a                	je     10ee5 <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   10edb:	b8 38 00 00 00       	mov    $0x38,%eax
   10ee0:	e9 a4 00 00 00       	jmp    10f89 <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   10ee5:	8b 45 14             	mov    0x14(%ebp),%eax
   10ee8:	8d 48 78             	lea    0x78(%eax),%ecx
   10eeb:	8b 45 10             	mov    0x10(%ebp),%eax
   10eee:	8b 10                	mov    (%eax),%edx
   10ef0:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ef3:	8b 00                	mov    (%eax),%eax
   10ef5:	83 ec 04             	sub    $0x4,%esp
   10ef8:	51                   	push   %ecx
   10ef9:	52                   	push   %edx
   10efa:	50                   	push   %eax
   10efb:	e8 06 8c ff ff       	call   9b06 <lodepng_get_raw_size>
   10f00:	83 c4 10             	add    $0x10,%esp
   10f03:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10f06:	83 ec 0c             	sub    $0xc,%esp
   10f09:	ff 75 f0             	pushl  -0x10(%ebp)
   10f0c:	e8 9a 2f ff ff       	call   3eab <lodepng_malloc>
   10f11:	83 c4 10             	add    $0x10,%esp
   10f14:	89 c2                	mov    %eax,%edx
   10f16:	8b 45 08             	mov    0x8(%ebp),%eax
   10f19:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   10f1b:	8b 45 08             	mov    0x8(%ebp),%eax
   10f1e:	8b 00                	mov    (%eax),%eax
   10f20:	85 c0                	test   %eax,%eax
   10f22:	75 0f                	jne    10f33 <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   10f24:	8b 45 14             	mov    0x14(%ebp),%eax
   10f27:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   10f2e:	00 00 00 
   10f31:	eb 3c                	jmp    10f6f <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   10f33:	8b 45 10             	mov    0x10(%ebp),%eax
   10f36:	8b 08                	mov    (%eax),%ecx
   10f38:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f3b:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   10f3d:	8b 45 14             	mov    0x14(%ebp),%eax
   10f40:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   10f46:	8b 45 14             	mov    0x14(%ebp),%eax
   10f49:	8d 58 78             	lea    0x78(%eax),%ebx
   10f4c:	8b 45 08             	mov    0x8(%ebp),%eax
   10f4f:	8b 00                	mov    (%eax),%eax
   10f51:	83 ec 08             	sub    $0x8,%esp
   10f54:	51                   	push   %ecx
   10f55:	52                   	push   %edx
   10f56:	56                   	push   %esi
   10f57:	53                   	push   %ebx
   10f58:	ff 75 f4             	pushl  -0xc(%ebp)
   10f5b:	50                   	push   %eax
   10f5c:	e8 51 b6 ff ff       	call   c5b2 <lodepng_convert>
   10f61:	83 c4 20             	add    $0x20,%esp
   10f64:	89 c2                	mov    %eax,%edx
   10f66:	8b 45 14             	mov    0x14(%ebp),%eax
   10f69:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   10f6f:	83 ec 0c             	sub    $0xc,%esp
   10f72:	ff 75 f4             	pushl  -0xc(%ebp)
   10f75:	e8 52 2f ff ff       	call   3ecc <lodepng_free>
   10f7a:	83 c4 10             	add    $0x10,%esp
   10f7d:	eb 01                	jmp    10f80 <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   10f7f:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   10f80:	8b 45 14             	mov    0x14(%ebp),%eax
   10f83:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   10f89:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10f8c:	5b                   	pop    %ebx
   10f8d:	5e                   	pop    %esi
   10f8e:	5d                   	pop    %ebp
   10f8f:	c3                   	ret    

00010f90 <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   10f90:	55                   	push   %ebp
   10f91:	89 e5                	mov    %esp,%ebp
   10f93:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   10f99:	83 ec 0c             	sub    $0xc,%esp
   10f9c:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10fa2:	50                   	push   %eax
   10fa3:	e8 d9 01 00 00       	call   11181 <lodepng_state_init>
   10fa8:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   10fab:	8b 45 1c             	mov    0x1c(%ebp),%eax
   10fae:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   10fb4:	8b 45 20             	mov    0x20(%ebp),%eax
   10fb7:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   10fbd:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   10fc4:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   10fc7:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   10fce:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   10fd1:	83 ec 08             	sub    $0x8,%esp
   10fd4:	ff 75 18             	pushl  0x18(%ebp)
   10fd7:	ff 75 14             	pushl  0x14(%ebp)
   10fda:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10fe0:	50                   	push   %eax
   10fe1:	ff 75 10             	pushl  0x10(%ebp)
   10fe4:	ff 75 0c             	pushl  0xc(%ebp)
   10fe7:	ff 75 08             	pushl  0x8(%ebp)
   10fea:	e8 fc fd ff ff       	call   10deb <lodepng_decode>
   10fef:	83 c4 20             	add    $0x20,%esp
   10ff2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   10ff5:	83 ec 0c             	sub    $0xc,%esp
   10ff8:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10ffe:	50                   	push   %eax
   10fff:	e8 d7 01 00 00       	call   111db <lodepng_state_cleanup>
   11004:	83 c4 10             	add    $0x10,%esp
  return error;
   11007:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1100a:	c9                   	leave  
   1100b:	c3                   	ret    

0001100c <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   1100c:	55                   	push   %ebp
   1100d:	89 e5                	mov    %esp,%ebp
   1100f:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   11012:	83 ec 04             	sub    $0x4,%esp
   11015:	6a 08                	push   $0x8
   11017:	6a 06                	push   $0x6
   11019:	ff 75 18             	pushl  0x18(%ebp)
   1101c:	ff 75 14             	pushl  0x14(%ebp)
   1101f:	ff 75 10             	pushl  0x10(%ebp)
   11022:	ff 75 0c             	pushl  0xc(%ebp)
   11025:	ff 75 08             	pushl  0x8(%ebp)
   11028:	e8 63 ff ff ff       	call   10f90 <lodepng_decode_memory>
   1102d:	83 c4 20             	add    $0x20,%esp
}
   11030:	c9                   	leave  
   11031:	c3                   	ret    

00011032 <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   11032:	55                   	push   %ebp
   11033:	89 e5                	mov    %esp,%ebp
   11035:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   11038:	83 ec 04             	sub    $0x4,%esp
   1103b:	6a 08                	push   $0x8
   1103d:	6a 02                	push   $0x2
   1103f:	ff 75 18             	pushl  0x18(%ebp)
   11042:	ff 75 14             	pushl  0x14(%ebp)
   11045:	ff 75 10             	pushl  0x10(%ebp)
   11048:	ff 75 0c             	pushl  0xc(%ebp)
   1104b:	ff 75 08             	pushl  0x8(%ebp)
   1104e:	e8 3d ff ff ff       	call   10f90 <lodepng_decode_memory>
   11053:	83 c4 20             	add    $0x20,%esp
}
   11056:	c9                   	leave  
   11057:	c3                   	ret    

00011058 <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   11058:	55                   	push   %ebp
   11059:	89 e5                	mov    %esp,%ebp
   1105b:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   1105e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   11065:	8b 45 08             	mov    0x8(%ebp),%eax
   11068:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   1106e:	8b 45 10             	mov    0x10(%ebp),%eax
   11071:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   11077:	8b 45 10             	mov    0x10(%ebp),%eax
   1107a:	8b 10                	mov    (%eax),%edx
   1107c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1107f:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   11081:	83 ec 04             	sub    $0x4,%esp
   11084:	ff 75 14             	pushl  0x14(%ebp)
   11087:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1108a:	50                   	push   %eax
   1108b:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1108e:	50                   	push   %eax
   1108f:	e8 70 32 ff ff       	call   4304 <lodepng_load_file>
   11094:	83 c4 10             	add    $0x10,%esp
   11097:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   1109a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1109e:	75 25                	jne    110c5 <lodepng_decode_file+0x6d>
   110a0:	8b 55 ec             	mov    -0x14(%ebp),%edx
   110a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110a6:	83 ec 04             	sub    $0x4,%esp
   110a9:	ff 75 1c             	pushl  0x1c(%ebp)
   110ac:	ff 75 18             	pushl  0x18(%ebp)
   110af:	52                   	push   %edx
   110b0:	50                   	push   %eax
   110b1:	ff 75 10             	pushl  0x10(%ebp)
   110b4:	ff 75 0c             	pushl  0xc(%ebp)
   110b7:	ff 75 08             	pushl  0x8(%ebp)
   110ba:	e8 d1 fe ff ff       	call   10f90 <lodepng_decode_memory>
   110bf:	83 c4 20             	add    $0x20,%esp
   110c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   110c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110c8:	83 ec 0c             	sub    $0xc,%esp
   110cb:	50                   	push   %eax
   110cc:	e8 fb 2d ff ff       	call   3ecc <lodepng_free>
   110d1:	83 c4 10             	add    $0x10,%esp
  return error;
   110d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   110d7:	c9                   	leave  
   110d8:	c3                   	ret    

000110d9 <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   110d9:	55                   	push   %ebp
   110da:	89 e5                	mov    %esp,%ebp
   110dc:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   110df:	83 ec 08             	sub    $0x8,%esp
   110e2:	6a 08                	push   $0x8
   110e4:	6a 06                	push   $0x6
   110e6:	ff 75 14             	pushl  0x14(%ebp)
   110e9:	ff 75 10             	pushl  0x10(%ebp)
   110ec:	ff 75 0c             	pushl  0xc(%ebp)
   110ef:	ff 75 08             	pushl  0x8(%ebp)
   110f2:	e8 61 ff ff ff       	call   11058 <lodepng_decode_file>
   110f7:	83 c4 20             	add    $0x20,%esp
}
   110fa:	c9                   	leave  
   110fb:	c3                   	ret    

000110fc <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   110fc:	55                   	push   %ebp
   110fd:	89 e5                	mov    %esp,%ebp
   110ff:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   11102:	83 ec 08             	sub    $0x8,%esp
   11105:	6a 08                	push   $0x8
   11107:	6a 02                	push   $0x2
   11109:	ff 75 14             	pushl  0x14(%ebp)
   1110c:	ff 75 10             	pushl  0x10(%ebp)
   1110f:	ff 75 0c             	pushl  0xc(%ebp)
   11112:	ff 75 08             	pushl  0x8(%ebp)
   11115:	e8 3e ff ff ff       	call   11058 <lodepng_decode_file>
   1111a:	83 c4 20             	add    $0x20,%esp
}
   1111d:	c9                   	leave  
   1111e:	c3                   	ret    

0001111f <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   1111f:	55                   	push   %ebp
   11120:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   11122:	8b 45 08             	mov    0x8(%ebp),%eax
   11125:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   1112c:	8b 45 08             	mov    0x8(%ebp),%eax
   1112f:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   11136:	8b 45 08             	mov    0x8(%ebp),%eax
   11139:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   11140:	8b 45 08             	mov    0x8(%ebp),%eax
   11143:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   1114a:	8b 45 08             	mov    0x8(%ebp),%eax
   1114d:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   11154:	8b 45 08             	mov    0x8(%ebp),%eax
   11157:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   1115e:	8b 45 08             	mov    0x8(%ebp),%eax
   11161:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   11168:	8b 45 08             	mov    0x8(%ebp),%eax
   1116b:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   11172:	8b 45 08             	mov    0x8(%ebp),%eax
   11175:	50                   	push   %eax
   11176:	e8 ff 7a ff ff       	call   8c7a <lodepng_decompress_settings_init>
   1117b:	83 c4 04             	add    $0x4,%esp
}
   1117e:	90                   	nop
   1117f:	c9                   	leave  
   11180:	c3                   	ret    

00011181 <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   11181:	55                   	push   %ebp
   11182:	89 e5                	mov    %esp,%ebp
   11184:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   11187:	8b 45 08             	mov    0x8(%ebp),%eax
   1118a:	50                   	push   %eax
   1118b:	e8 8f ff ff ff       	call   1111f <lodepng_decoder_settings_init>
   11190:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   11193:	8b 45 08             	mov    0x8(%ebp),%eax
   11196:	83 c0 38             	add    $0x38,%eax
   11199:	83 ec 0c             	sub    $0xc,%esp
   1119c:	50                   	push   %eax
   1119d:	e8 fc 30 00 00       	call   1429e <lodepng_encoder_settings_init>
   111a2:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   111a5:	8b 45 08             	mov    0x8(%ebp),%eax
   111a8:	83 c0 78             	add    $0x78,%eax
   111ab:	83 ec 0c             	sub    $0xc,%esp
   111ae:	50                   	push   %eax
   111af:	e8 06 84 ff ff       	call   95ba <lodepng_color_mode_init>
   111b4:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   111b7:	8b 45 08             	mov    0x8(%ebp),%eax
   111ba:	05 98 00 00 00       	add    $0x98,%eax
   111bf:	83 ec 0c             	sub    $0xc,%esp
   111c2:	50                   	push   %eax
   111c3:	e8 89 93 ff ff       	call   a551 <lodepng_info_init>
   111c8:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   111cb:	8b 45 08             	mov    0x8(%ebp),%eax
   111ce:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   111d5:	00 00 00 
}
   111d8:	90                   	nop
   111d9:	c9                   	leave  
   111da:	c3                   	ret    

000111db <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   111db:	55                   	push   %ebp
   111dc:	89 e5                	mov    %esp,%ebp
   111de:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   111e1:	8b 45 08             	mov    0x8(%ebp),%eax
   111e4:	83 c0 78             	add    $0x78,%eax
   111e7:	83 ec 0c             	sub    $0xc,%esp
   111ea:	50                   	push   %eax
   111eb:	e8 bd 84 ff ff       	call   96ad <lodepng_color_mode_cleanup>
   111f0:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   111f3:	8b 45 08             	mov    0x8(%ebp),%eax
   111f6:	05 98 00 00 00       	add    $0x98,%eax
   111fb:	83 ec 0c             	sub    $0xc,%esp
   111fe:	50                   	push   %eax
   111ff:	e8 2e 94 ff ff       	call   a632 <lodepng_info_cleanup>
   11204:	83 c4 10             	add    $0x10,%esp
}
   11207:	90                   	nop
   11208:	c9                   	leave  
   11209:	c3                   	ret    

0001120a <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   1120a:	55                   	push   %ebp
   1120b:	89 e5                	mov    %esp,%ebp
   1120d:	57                   	push   %edi
   1120e:	56                   	push   %esi
   1120f:	53                   	push   %ebx
   11210:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   11213:	83 ec 0c             	sub    $0xc,%esp
   11216:	ff 75 08             	pushl  0x8(%ebp)
   11219:	e8 bd ff ff ff       	call   111db <lodepng_state_cleanup>
   1121e:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   11221:	8b 55 08             	mov    0x8(%ebp),%edx
   11224:	8b 45 0c             	mov    0xc(%ebp),%eax
   11227:	89 c3                	mov    %eax,%ebx
   11229:	b8 60 00 00 00       	mov    $0x60,%eax
   1122e:	89 d7                	mov    %edx,%edi
   11230:	89 de                	mov    %ebx,%esi
   11232:	89 c1                	mov    %eax,%ecx
   11234:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   11236:	8b 45 08             	mov    0x8(%ebp),%eax
   11239:	83 c0 78             	add    $0x78,%eax
   1123c:	83 ec 0c             	sub    $0xc,%esp
   1123f:	50                   	push   %eax
   11240:	e8 75 83 ff ff       	call   95ba <lodepng_color_mode_init>
   11245:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   11248:	8b 45 08             	mov    0x8(%ebp),%eax
   1124b:	05 98 00 00 00       	add    $0x98,%eax
   11250:	83 ec 0c             	sub    $0xc,%esp
   11253:	50                   	push   %eax
   11254:	e8 f8 92 ff ff       	call   a551 <lodepng_info_init>
   11259:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   1125c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1125f:	8d 50 78             	lea    0x78(%eax),%edx
   11262:	8b 45 08             	mov    0x8(%ebp),%eax
   11265:	83 c0 78             	add    $0x78,%eax
   11268:	83 ec 08             	sub    $0x8,%esp
   1126b:	52                   	push   %edx
   1126c:	50                   	push   %eax
   1126d:	e8 52 84 ff ff       	call   96c4 <lodepng_color_mode_copy>
   11272:	83 c4 10             	add    $0x10,%esp
   11275:	89 c2                	mov    %eax,%edx
   11277:	8b 45 08             	mov    0x8(%ebp),%eax
   1127a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   11280:	8b 45 08             	mov    0x8(%ebp),%eax
   11283:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11289:	85 c0                	test   %eax,%eax
   1128b:	75 36                	jne    112c3 <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   1128d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11290:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   11296:	8b 45 08             	mov    0x8(%ebp),%eax
   11299:	05 98 00 00 00       	add    $0x98,%eax
   1129e:	83 ec 08             	sub    $0x8,%esp
   112a1:	52                   	push   %edx
   112a2:	50                   	push   %eax
   112a3:	e8 dd 93 ff ff       	call   a685 <lodepng_info_copy>
   112a8:	83 c4 10             	add    $0x10,%esp
   112ab:	89 c2                	mov    %eax,%edx
   112ad:	8b 45 08             	mov    0x8(%ebp),%eax
   112b0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   112b6:	8b 45 08             	mov    0x8(%ebp),%eax
   112b9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   112bf:	85 c0                	test   %eax,%eax
   112c1:	eb 01                	jmp    112c4 <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   112c3:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   112c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
   112c7:	5b                   	pop    %ebx
   112c8:	5e                   	pop    %esi
   112c9:	5f                   	pop    %edi
   112ca:	5d                   	pop    %ebp
   112cb:	c3                   	ret    

000112cc <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   112cc:	55                   	push   %ebp
   112cd:	89 e5                	mov    %esp,%ebp
   112cf:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   112d2:	8b 45 08             	mov    0x8(%ebp),%eax
   112d5:	8b 40 04             	mov    0x4(%eax),%eax
   112d8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   112db:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   112df:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   112e3:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   112e7:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   112eb:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   112ef:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   112f3:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   112f7:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   112fb:	8b 45 08             	mov    0x8(%ebp),%eax
   112fe:	8b 40 04             	mov    0x4(%eax),%eax
   11301:	83 c0 08             	add    $0x8,%eax
   11304:	50                   	push   %eax
   11305:	ff 75 08             	pushl  0x8(%ebp)
   11308:	e8 f8 2d ff ff       	call   4105 <ucvector_resize>
   1130d:	83 c4 08             	add    $0x8,%esp
   11310:	85 c0                	test   %eax,%eax
   11312:	75 07                	jne    1131b <writeSignature+0x4f>
   11314:	b8 53 00 00 00       	mov    $0x53,%eax
   11319:	eb 1e                	jmp    11339 <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   1131b:	8b 45 08             	mov    0x8(%ebp),%eax
   1131e:	8b 10                	mov    (%eax),%edx
   11320:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11323:	01 c2                	add    %eax,%edx
   11325:	6a 08                	push   $0x8
   11327:	8d 45 f4             	lea    -0xc(%ebp),%eax
   1132a:	50                   	push   %eax
   1132b:	52                   	push   %edx
   1132c:	e8 b8 2b ff ff       	call   3ee9 <lodepng_memcpy>
   11331:	83 c4 0c             	add    $0xc,%esp
  return 0;
   11334:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11339:	c9                   	leave  
   1133a:	c3                   	ret    

0001133b <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   1133b:	55                   	push   %ebp
   1133c:	89 e5                	mov    %esp,%ebp
   1133e:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   11341:	68 8c ac 01 00       	push   $0x1ac8c
   11346:	6a 0d                	push   $0xd
   11348:	ff 75 08             	pushl  0x8(%ebp)
   1134b:	8d 45 f4             	lea    -0xc(%ebp),%eax
   1134e:	50                   	push   %eax
   1134f:	e8 cf 7f ff ff       	call   9323 <lodepng_chunk_init>
   11354:	83 c4 10             	add    $0x10,%esp
   11357:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1135a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1135e:	74 05                	je     11365 <addChunk_IHDR+0x2a>
   11360:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11363:	eb 6d                	jmp    113d2 <addChunk_IHDR+0x97>
  data = chunk + 8;
   11365:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11368:	83 c0 08             	add    $0x8,%eax
   1136b:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   1136e:	ff 75 0c             	pushl  0xc(%ebp)
   11371:	ff 75 f8             	pushl  -0x8(%ebp)
   11374:	e8 f3 2e ff ff       	call   426c <lodepng_set32bitInt>
   11379:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   1137c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1137f:	83 c0 04             	add    $0x4,%eax
   11382:	ff 75 10             	pushl  0x10(%ebp)
   11385:	50                   	push   %eax
   11386:	e8 e1 2e ff ff       	call   426c <lodepng_set32bitInt>
   1138b:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   1138e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11391:	83 c0 08             	add    $0x8,%eax
   11394:	8b 55 18             	mov    0x18(%ebp),%edx
   11397:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   11399:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1139c:	83 c0 09             	add    $0x9,%eax
   1139f:	8b 55 14             	mov    0x14(%ebp),%edx
   113a2:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   113a4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   113a7:	83 c0 0a             	add    $0xa,%eax
   113aa:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   113ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
   113b0:	83 c0 0b             	add    $0xb,%eax
   113b3:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   113b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   113b9:	83 c0 0c             	add    $0xc,%eax
   113bc:	8b 55 1c             	mov    0x1c(%ebp),%edx
   113bf:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   113c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113c4:	50                   	push   %eax
   113c5:	e8 02 7c ff ff       	call   8fcc <lodepng_chunk_generate_crc>
   113ca:	83 c4 04             	add    $0x4,%esp
  return 0;
   113cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
   113d2:	c9                   	leave  
   113d3:	c3                   	ret    

000113d4 <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   113d4:	55                   	push   %ebp
   113d5:	89 e5                	mov    %esp,%ebp
   113d7:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   113da:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   113e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   113e4:	8b 50 0c             	mov    0xc(%eax),%edx
   113e7:	89 d0                	mov    %edx,%eax
   113e9:	01 c0                	add    %eax,%eax
   113eb:	01 d0                	add    %edx,%eax
   113ed:	68 a8 ac 01 00       	push   $0x1aca8
   113f2:	50                   	push   %eax
   113f3:	ff 75 08             	pushl  0x8(%ebp)
   113f6:	8d 45 f0             	lea    -0x10(%ebp),%eax
   113f9:	50                   	push   %eax
   113fa:	e8 24 7f ff ff       	call   9323 <lodepng_chunk_init>
   113ff:	83 c4 10             	add    $0x10,%esp
   11402:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11405:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11409:	74 08                	je     11413 <addChunk_PLTE+0x3f>
   1140b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1140e:	e9 95 00 00 00       	jmp    114a8 <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   11413:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1141a:	eb 70                	jmp    1148c <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   1141c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   1141f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11422:	8d 50 01             	lea    0x1(%eax),%edx
   11425:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11428:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   1142b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1142e:	8b 40 08             	mov    0x8(%eax),%eax
   11431:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   11434:	c1 e1 02             	shl    $0x2,%ecx
   11437:	01 c8                	add    %ecx,%eax
   11439:	0f b6 00             	movzbl (%eax),%eax
   1143c:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   1143e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   11441:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11444:	8d 50 01             	lea    0x1(%eax),%edx
   11447:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1144a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   1144d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11450:	8b 40 08             	mov    0x8(%eax),%eax
   11453:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   11456:	c1 e1 02             	shl    $0x2,%ecx
   11459:	83 c1 01             	add    $0x1,%ecx
   1145c:	01 c8                	add    %ecx,%eax
   1145e:	0f b6 00             	movzbl (%eax),%eax
   11461:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   11463:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   11466:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11469:	8d 50 01             	lea    0x1(%eax),%edx
   1146c:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1146f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   11472:	8b 45 0c             	mov    0xc(%ebp),%eax
   11475:	8b 40 08             	mov    0x8(%eax),%eax
   11478:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   1147b:	c1 e1 02             	shl    $0x2,%ecx
   1147e:	83 c1 02             	add    $0x2,%ecx
   11481:	01 c8                	add    %ecx,%eax
   11483:	0f b6 00             	movzbl (%eax),%eax
   11486:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   11488:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1148c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1148f:	8b 40 0c             	mov    0xc(%eax),%eax
   11492:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   11495:	75 85                	jne    1141c <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   11497:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1149a:	50                   	push   %eax
   1149b:	e8 2c 7b ff ff       	call   8fcc <lodepng_chunk_generate_crc>
   114a0:	83 c4 04             	add    $0x4,%esp
  return 0;
   114a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
   114a8:	c9                   	leave  
   114a9:	c3                   	ret    

000114aa <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   114aa:	55                   	push   %ebp
   114ab:	89 e5                	mov    %esp,%ebp
   114ad:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   114b0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   114b7:	8b 45 0c             	mov    0xc(%ebp),%eax
   114ba:	8b 00                	mov    (%eax),%eax
   114bc:	83 f8 03             	cmp    $0x3,%eax
   114bf:	0f 85 ae 00 00 00    	jne    11573 <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   114c5:	8b 45 0c             	mov    0xc(%ebp),%eax
   114c8:	8b 40 0c             	mov    0xc(%eax),%eax
   114cb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   114ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   114d1:	8b 40 0c             	mov    0xc(%eax),%eax
   114d4:	89 45 fc             	mov    %eax,-0x4(%ebp)
   114d7:	eb 23                	jmp    114fc <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   114d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   114dc:	8b 40 08             	mov    0x8(%eax),%eax
   114df:	8b 55 fc             	mov    -0x4(%ebp),%edx
   114e2:	83 ea 01             	sub    $0x1,%edx
   114e5:	c1 e2 02             	shl    $0x2,%edx
   114e8:	83 c2 03             	add    $0x3,%edx
   114eb:	01 d0                	add    %edx,%eax
   114ed:	0f b6 00             	movzbl (%eax),%eax
   114f0:	3c ff                	cmp    $0xff,%al
   114f2:	75 10                	jne    11504 <addChunk_tRNS+0x5a>
      --amount;
   114f4:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   114f8:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   114fc:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11500:	75 d7                	jne    114d9 <addChunk_tRNS+0x2f>
   11502:	eb 01                	jmp    11505 <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   11504:	90                   	nop
      --amount;
    }
    if(amount) {
   11505:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   11509:	0f 84 63 01 00 00    	je     11672 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   1150f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11512:	68 ad ac 01 00       	push   $0x1acad
   11517:	50                   	push   %eax
   11518:	ff 75 08             	pushl  0x8(%ebp)
   1151b:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1151e:	50                   	push   %eax
   1151f:	e8 ff 7d ff ff       	call   9323 <lodepng_chunk_init>
   11524:	83 c4 10             	add    $0x10,%esp
   11527:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1152a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1152e:	74 08                	je     11538 <addChunk_tRNS+0x8e>
   11530:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11533:	e9 52 01 00 00       	jmp    1168a <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   11538:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1153f:	eb 25                	jmp    11566 <addChunk_tRNS+0xbc>
   11541:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11544:	8b 55 fc             	mov    -0x4(%ebp),%edx
   11547:	83 c2 08             	add    $0x8,%edx
   1154a:	01 c2                	add    %eax,%edx
   1154c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1154f:	8b 40 08             	mov    0x8(%eax),%eax
   11552:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   11555:	c1 e1 02             	shl    $0x2,%ecx
   11558:	83 c1 03             	add    $0x3,%ecx
   1155b:	01 c8                	add    %ecx,%eax
   1155d:	0f b6 00             	movzbl (%eax),%eax
   11560:	88 02                	mov    %al,(%edx)
   11562:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   11566:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11569:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   1156c:	75 d3                	jne    11541 <addChunk_tRNS+0x97>
   1156e:	e9 ff 00 00 00       	jmp    11672 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   11573:	8b 45 0c             	mov    0xc(%ebp),%eax
   11576:	8b 00                	mov    (%eax),%eax
   11578:	85 c0                	test   %eax,%eax
   1157a:	75 59                	jne    115d5 <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   1157c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1157f:	8b 40 10             	mov    0x10(%eax),%eax
   11582:	85 c0                	test   %eax,%eax
   11584:	0f 84 e8 00 00 00    	je     11672 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   1158a:	68 ad ac 01 00       	push   $0x1acad
   1158f:	6a 02                	push   $0x2
   11591:	ff 75 08             	pushl  0x8(%ebp)
   11594:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11597:	50                   	push   %eax
   11598:	e8 86 7d ff ff       	call   9323 <lodepng_chunk_init>
   1159d:	83 c4 10             	add    $0x10,%esp
   115a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
   115a3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   115a7:	74 08                	je     115b1 <addChunk_tRNS+0x107>
   115a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   115ac:	e9 d9 00 00 00       	jmp    1168a <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   115b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   115b4:	8d 50 08             	lea    0x8(%eax),%edx
   115b7:	8b 45 0c             	mov    0xc(%ebp),%eax
   115ba:	8b 40 14             	mov    0x14(%eax),%eax
   115bd:	c1 e8 08             	shr    $0x8,%eax
   115c0:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   115c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   115c5:	8d 50 09             	lea    0x9(%eax),%edx
   115c8:	8b 45 0c             	mov    0xc(%ebp),%eax
   115cb:	8b 40 14             	mov    0x14(%eax),%eax
   115ce:	88 02                	mov    %al,(%edx)
   115d0:	e9 9d 00 00 00       	jmp    11672 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   115d5:	8b 45 0c             	mov    0xc(%ebp),%eax
   115d8:	8b 00                	mov    (%eax),%eax
   115da:	83 f8 02             	cmp    $0x2,%eax
   115dd:	0f 85 8f 00 00 00    	jne    11672 <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   115e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   115e6:	8b 40 10             	mov    0x10(%eax),%eax
   115e9:	85 c0                	test   %eax,%eax
   115eb:	0f 84 81 00 00 00    	je     11672 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   115f1:	68 ad ac 01 00       	push   $0x1acad
   115f6:	6a 06                	push   $0x6
   115f8:	ff 75 08             	pushl  0x8(%ebp)
   115fb:	8d 45 e8             	lea    -0x18(%ebp),%eax
   115fe:	50                   	push   %eax
   115ff:	e8 1f 7d ff ff       	call   9323 <lodepng_chunk_init>
   11604:	83 c4 10             	add    $0x10,%esp
   11607:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1160a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1160e:	74 05                	je     11615 <addChunk_tRNS+0x16b>
   11610:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11613:	eb 75                	jmp    1168a <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   11615:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11618:	8d 50 08             	lea    0x8(%eax),%edx
   1161b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1161e:	8b 40 14             	mov    0x14(%eax),%eax
   11621:	c1 e8 08             	shr    $0x8,%eax
   11624:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   11626:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11629:	8d 50 09             	lea    0x9(%eax),%edx
   1162c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1162f:	8b 40 14             	mov    0x14(%eax),%eax
   11632:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   11634:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11637:	8d 50 0a             	lea    0xa(%eax),%edx
   1163a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1163d:	8b 40 18             	mov    0x18(%eax),%eax
   11640:	c1 e8 08             	shr    $0x8,%eax
   11643:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   11645:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11648:	8d 50 0b             	lea    0xb(%eax),%edx
   1164b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1164e:	8b 40 18             	mov    0x18(%eax),%eax
   11651:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   11653:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11656:	8d 50 0c             	lea    0xc(%eax),%edx
   11659:	8b 45 0c             	mov    0xc(%ebp),%eax
   1165c:	8b 40 1c             	mov    0x1c(%eax),%eax
   1165f:	c1 e8 08             	shr    $0x8,%eax
   11662:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   11664:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11667:	8d 50 0d             	lea    0xd(%eax),%edx
   1166a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1166d:	8b 40 1c             	mov    0x1c(%eax),%eax
   11670:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   11672:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11675:	85 c0                	test   %eax,%eax
   11677:	74 0c                	je     11685 <addChunk_tRNS+0x1db>
   11679:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1167c:	50                   	push   %eax
   1167d:	e8 4a 79 ff ff       	call   8fcc <lodepng_chunk_generate_crc>
   11682:	83 c4 04             	add    $0x4,%esp
  return 0;
   11685:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1168a:	c9                   	leave  
   1168b:	c3                   	ret    

0001168c <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   1168c:	55                   	push   %ebp
   1168d:	89 e5                	mov    %esp,%ebp
   1168f:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   11692:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   11699:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   116a0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   116a7:	83 ec 0c             	sub    $0xc,%esp
   116aa:	ff 75 14             	pushl  0x14(%ebp)
   116ad:	ff 75 10             	pushl  0x10(%ebp)
   116b0:	ff 75 0c             	pushl  0xc(%ebp)
   116b3:	8d 45 ec             	lea    -0x14(%ebp),%eax
   116b6:	50                   	push   %eax
   116b7:	8d 45 f0             	lea    -0x10(%ebp),%eax
   116ba:	50                   	push   %eax
   116bb:	e8 fb 74 ff ff       	call   8bbb <zlib_compress>
   116c0:	83 c4 20             	add    $0x20,%esp
   116c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   116c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   116ca:	75 1b                	jne    116e7 <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   116cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116cf:	8b 55 ec             	mov    -0x14(%ebp),%edx
   116d2:	50                   	push   %eax
   116d3:	68 e4 ac 01 00       	push   $0x1ace4
   116d8:	52                   	push   %edx
   116d9:	ff 75 08             	pushl  0x8(%ebp)
   116dc:	e8 ea 7c ff ff       	call   93cb <lodepng_chunk_createv>
   116e1:	83 c4 10             	add    $0x10,%esp
   116e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   116e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116ea:	83 ec 0c             	sub    $0xc,%esp
   116ed:	50                   	push   %eax
   116ee:	e8 d9 27 ff ff       	call   3ecc <lodepng_free>
   116f3:	83 c4 10             	add    $0x10,%esp
  return error;
   116f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   116f9:	c9                   	leave  
   116fa:	c3                   	ret    

000116fb <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   116fb:	55                   	push   %ebp
   116fc:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   116fe:	6a 00                	push   $0x0
   11700:	68 e9 ac 01 00       	push   $0x1ace9
   11705:	6a 00                	push   $0x0
   11707:	ff 75 08             	pushl  0x8(%ebp)
   1170a:	e8 bc 7c ff ff       	call   93cb <lodepng_chunk_createv>
   1170f:	83 c4 10             	add    $0x10,%esp
}
   11712:	c9                   	leave  
   11713:	c3                   	ret    

00011714 <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   11714:	55                   	push   %ebp
   11715:	89 e5                	mov    %esp,%ebp
   11717:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   1171a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   11721:	ff 75 0c             	pushl  0xc(%ebp)
   11724:	e8 1e 28 ff ff       	call   3f47 <lodepng_strlen>
   11729:	83 c4 04             	add    $0x4,%esp
   1172c:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1172f:	ff 75 10             	pushl  0x10(%ebp)
   11732:	e8 10 28 ff ff       	call   3f47 <lodepng_strlen>
   11737:	83 c4 04             	add    $0x4,%esp
   1173a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   1173d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11740:	8d 50 01             	lea    0x1(%eax),%edx
   11743:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11746:	01 d0                	add    %edx,%eax
   11748:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   1174b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1174f:	7e 06                	jle    11757 <addChunk_tEXt+0x43>
   11751:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   11755:	7e 07                	jle    1175e <addChunk_tEXt+0x4a>
   11757:	b8 59 00 00 00       	mov    $0x59,%eax
   1175c:	eb 74                	jmp    117d2 <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   1175e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11761:	68 b7 ac 01 00       	push   $0x1acb7
   11766:	50                   	push   %eax
   11767:	ff 75 08             	pushl  0x8(%ebp)
   1176a:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1176d:	50                   	push   %eax
   1176e:	e8 b0 7b ff ff       	call   9323 <lodepng_chunk_init>
   11773:	83 c4 10             	add    $0x10,%esp
   11776:	89 45 f0             	mov    %eax,-0x10(%ebp)
   11779:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1177d:	74 05                	je     11784 <addChunk_tEXt+0x70>
   1177f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11782:	eb 4e                	jmp    117d2 <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   11784:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11787:	83 c0 08             	add    $0x8,%eax
   1178a:	ff 75 fc             	pushl  -0x4(%ebp)
   1178d:	ff 75 0c             	pushl  0xc(%ebp)
   11790:	50                   	push   %eax
   11791:	e8 53 27 ff ff       	call   3ee9 <lodepng_memcpy>
   11796:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   11799:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1179c:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1179f:	83 c2 08             	add    $0x8,%edx
   117a2:	01 d0                	add    %edx,%eax
   117a4:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   117a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   117aa:	8b 55 fc             	mov    -0x4(%ebp),%edx
   117ad:	83 c2 09             	add    $0x9,%edx
   117b0:	01 d0                	add    %edx,%eax
   117b2:	ff 75 f8             	pushl  -0x8(%ebp)
   117b5:	ff 75 10             	pushl  0x10(%ebp)
   117b8:	50                   	push   %eax
   117b9:	e8 2b 27 ff ff       	call   3ee9 <lodepng_memcpy>
   117be:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   117c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   117c4:	50                   	push   %eax
   117c5:	e8 02 78 ff ff       	call   8fcc <lodepng_chunk_generate_crc>
   117ca:	83 c4 04             	add    $0x4,%esp
  return 0;
   117cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
   117d2:	c9                   	leave  
   117d3:	c3                   	ret    

000117d4 <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   117d4:	55                   	push   %ebp
   117d5:	89 e5                	mov    %esp,%ebp
   117d7:	53                   	push   %ebx
   117d8:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   117db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   117e2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   117e9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   117f0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   117f7:	ff 75 10             	pushl  0x10(%ebp)
   117fa:	e8 48 27 ff ff       	call   3f47 <lodepng_strlen>
   117ff:	83 c4 04             	add    $0x4,%esp
   11802:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   11805:	ff 75 0c             	pushl  0xc(%ebp)
   11808:	e8 3a 27 ff ff       	call   3f47 <lodepng_strlen>
   1180d:	83 c4 04             	add    $0x4,%esp
   11810:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11813:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11817:	7e 06                	jle    1181f <addChunk_zTXt+0x4b>
   11819:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   1181d:	7e 0a                	jle    11829 <addChunk_zTXt+0x55>
   1181f:	b8 59 00 00 00       	mov    $0x59,%eax
   11824:	e9 c8 00 00 00       	jmp    118f1 <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   11829:	83 ec 0c             	sub    $0xc,%esp
   1182c:	ff 75 14             	pushl  0x14(%ebp)
   1182f:	ff 75 f0             	pushl  -0x10(%ebp)
   11832:	ff 75 10             	pushl  0x10(%ebp)
   11835:	8d 45 dc             	lea    -0x24(%ebp),%eax
   11838:	50                   	push   %eax
   11839:	8d 45 e0             	lea    -0x20(%ebp),%eax
   1183c:	50                   	push   %eax
   1183d:	e8 79 73 ff ff       	call   8bbb <zlib_compress>
   11842:	83 c4 20             	add    $0x20,%esp
   11845:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   11848:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1184c:	75 29                	jne    11877 <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   1184e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11851:	8d 50 02             	lea    0x2(%eax),%edx
   11854:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11857:	01 d0                	add    %edx,%eax
   11859:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   1185c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1185f:	68 bc ac 01 00       	push   $0x1acbc
   11864:	50                   	push   %eax
   11865:	ff 75 08             	pushl  0x8(%ebp)
   11868:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   1186b:	50                   	push   %eax
   1186c:	e8 b2 7a ff ff       	call   9323 <lodepng_chunk_init>
   11871:	83 c4 10             	add    $0x10,%esp
   11874:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11877:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1187b:	75 62                	jne    118df <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   1187d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11880:	83 c0 08             	add    $0x8,%eax
   11883:	83 ec 04             	sub    $0x4,%esp
   11886:	ff 75 ec             	pushl  -0x14(%ebp)
   11889:	ff 75 0c             	pushl  0xc(%ebp)
   1188c:	50                   	push   %eax
   1188d:	e8 57 26 ff ff       	call   3ee9 <lodepng_memcpy>
   11892:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   11895:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11898:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1189b:	83 c2 08             	add    $0x8,%edx
   1189e:	01 d0                	add    %edx,%eax
   118a0:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   118a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   118a6:	8b 55 ec             	mov    -0x14(%ebp),%edx
   118a9:	83 c2 09             	add    $0x9,%edx
   118ac:	01 d0                	add    %edx,%eax
   118ae:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   118b1:	8b 55 dc             	mov    -0x24(%ebp),%edx
   118b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   118b7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   118ba:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   118bd:	83 c3 0a             	add    $0xa,%ebx
   118c0:	01 d9                	add    %ebx,%ecx
   118c2:	83 ec 04             	sub    $0x4,%esp
   118c5:	52                   	push   %edx
   118c6:	50                   	push   %eax
   118c7:	51                   	push   %ecx
   118c8:	e8 1c 26 ff ff       	call   3ee9 <lodepng_memcpy>
   118cd:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   118d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   118d3:	83 ec 0c             	sub    $0xc,%esp
   118d6:	50                   	push   %eax
   118d7:	e8 f0 76 ff ff       	call   8fcc <lodepng_chunk_generate_crc>
   118dc:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   118df:	8b 45 e0             	mov    -0x20(%ebp),%eax
   118e2:	83 ec 0c             	sub    $0xc,%esp
   118e5:	50                   	push   %eax
   118e6:	e8 e1 25 ff ff       	call   3ecc <lodepng_free>
   118eb:	83 c4 10             	add    $0x10,%esp
  return error;
   118ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   118f1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   118f4:	c9                   	leave  
   118f5:	c3                   	ret    

000118f6 <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   118f6:	55                   	push   %ebp
   118f7:	89 e5                	mov    %esp,%ebp
   118f9:	53                   	push   %ebx
   118fa:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   118fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11904:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   1190b:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   11912:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   11919:	ff 75 1c             	pushl  0x1c(%ebp)
   1191c:	e8 26 26 ff ff       	call   3f47 <lodepng_strlen>
   11921:	83 c4 04             	add    $0x4,%esp
   11924:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   11927:	ff 75 10             	pushl  0x10(%ebp)
   1192a:	e8 18 26 ff ff       	call   3f47 <lodepng_strlen>
   1192f:	83 c4 04             	add    $0x4,%esp
   11932:	89 45 ec             	mov    %eax,-0x14(%ebp)
   11935:	ff 75 14             	pushl  0x14(%ebp)
   11938:	e8 0a 26 ff ff       	call   3f47 <lodepng_strlen>
   1193d:	83 c4 04             	add    $0x4,%esp
   11940:	89 45 e8             	mov    %eax,-0x18(%ebp)
   11943:	ff 75 18             	pushl  0x18(%ebp)
   11946:	e8 fc 25 ff ff       	call   3f47 <lodepng_strlen>
   1194b:	83 c4 04             	add    $0x4,%esp
   1194e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11951:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11955:	7e 06                	jle    1195d <addChunk_iTXt+0x67>
   11957:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   1195b:	7e 0a                	jle    11967 <addChunk_iTXt+0x71>
   1195d:	b8 59 00 00 00       	mov    $0x59,%eax
   11962:	e9 9a 01 00 00       	jmp    11b01 <addChunk_iTXt+0x20b>

  if(compress) {
   11967:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1196b:	74 1f                	je     1198c <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   1196d:	83 ec 0c             	sub    $0xc,%esp
   11970:	ff 75 20             	pushl  0x20(%ebp)
   11973:	ff 75 f0             	pushl  -0x10(%ebp)
   11976:	ff 75 1c             	pushl  0x1c(%ebp)
   11979:	8d 45 d0             	lea    -0x30(%ebp),%eax
   1197c:	50                   	push   %eax
   1197d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   11980:	50                   	push   %eax
   11981:	e8 35 72 ff ff       	call   8bbb <zlib_compress>
   11986:	83 c4 20             	add    $0x20,%esp
   11989:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   1198c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11990:	75 44                	jne    119d6 <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   11992:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11995:	8d 50 03             	lea    0x3(%eax),%edx
   11998:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1199b:	01 d0                	add    %edx,%eax
   1199d:	8d 50 01             	lea    0x1(%eax),%edx
   119a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119a3:	01 d0                	add    %edx,%eax
   119a5:	8d 50 01             	lea    0x1(%eax),%edx
   119a8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   119ac:	74 05                	je     119b3 <addChunk_iTXt+0xbd>
   119ae:	8b 45 d0             	mov    -0x30(%ebp),%eax
   119b1:	eb 03                	jmp    119b6 <addChunk_iTXt+0xc0>
   119b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   119b6:	01 d0                	add    %edx,%eax
   119b8:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   119bb:	8b 45 e0             	mov    -0x20(%ebp),%eax
   119be:	68 c1 ac 01 00       	push   $0x1acc1
   119c3:	50                   	push   %eax
   119c4:	ff 75 08             	pushl  0x8(%ebp)
   119c7:	8d 45 d8             	lea    -0x28(%ebp),%eax
   119ca:	50                   	push   %eax
   119cb:	e8 53 79 ff ff       	call   9323 <lodepng_chunk_init>
   119d0:	83 c4 10             	add    $0x10,%esp
   119d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   119d6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   119da:	0f 85 0f 01 00 00    	jne    11aef <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   119e0:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   119e7:	8b 55 d8             	mov    -0x28(%ebp),%edx
   119ea:	8b 45 dc             	mov    -0x24(%ebp),%eax
   119ed:	01 d0                	add    %edx,%eax
   119ef:	83 ec 04             	sub    $0x4,%esp
   119f2:	ff 75 ec             	pushl  -0x14(%ebp)
   119f5:	ff 75 10             	pushl  0x10(%ebp)
   119f8:	50                   	push   %eax
   119f9:	e8 eb 24 ff ff       	call   3ee9 <lodepng_memcpy>
   119fe:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   11a01:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a04:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11a07:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11a0a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11a0d:	8d 50 01             	lea    0x1(%eax),%edx
   11a10:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11a13:	01 c8                	add    %ecx,%eax
   11a15:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   11a18:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11a1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11a1e:	8d 50 01             	lea    0x1(%eax),%edx
   11a21:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11a24:	01 c8                	add    %ecx,%eax
   11a26:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11a2a:	0f 95 c2             	setne  %dl
   11a2d:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   11a2f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11a32:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11a35:	8d 50 01             	lea    0x1(%eax),%edx
   11a38:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11a3b:	01 c8                	add    %ecx,%eax
   11a3d:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   11a40:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11a43:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11a46:	01 d0                	add    %edx,%eax
   11a48:	83 ec 04             	sub    $0x4,%esp
   11a4b:	ff 75 e8             	pushl  -0x18(%ebp)
   11a4e:	ff 75 14             	pushl  0x14(%ebp)
   11a51:	50                   	push   %eax
   11a52:	e8 92 24 ff ff       	call   3ee9 <lodepng_memcpy>
   11a57:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   11a5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11a5d:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11a60:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11a63:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11a66:	8d 50 01             	lea    0x1(%eax),%edx
   11a69:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11a6c:	01 c8                	add    %ecx,%eax
   11a6e:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   11a71:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11a74:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11a77:	01 d0                	add    %edx,%eax
   11a79:	83 ec 04             	sub    $0x4,%esp
   11a7c:	ff 75 e4             	pushl  -0x1c(%ebp)
   11a7f:	ff 75 18             	pushl  0x18(%ebp)
   11a82:	50                   	push   %eax
   11a83:	e8 61 24 ff ff       	call   3ee9 <lodepng_memcpy>
   11a88:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   11a8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a8e:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11a91:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11a94:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11a97:	8d 50 01             	lea    0x1(%eax),%edx
   11a9a:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11a9d:	01 c8                	add    %ecx,%eax
   11a9f:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   11aa2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11aa6:	74 1e                	je     11ac6 <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   11aa8:	8b 55 d0             	mov    -0x30(%ebp),%edx
   11aab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   11aae:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   11ab1:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   11ab4:	01 d9                	add    %ebx,%ecx
   11ab6:	83 ec 04             	sub    $0x4,%esp
   11ab9:	52                   	push   %edx
   11aba:	50                   	push   %eax
   11abb:	51                   	push   %ecx
   11abc:	e8 28 24 ff ff       	call   3ee9 <lodepng_memcpy>
   11ac1:	83 c4 10             	add    $0x10,%esp
   11ac4:	eb 1a                	jmp    11ae0 <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   11ac6:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11ac9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11acc:	01 d0                	add    %edx,%eax
   11ace:	83 ec 04             	sub    $0x4,%esp
   11ad1:	ff 75 f0             	pushl  -0x10(%ebp)
   11ad4:	ff 75 1c             	pushl  0x1c(%ebp)
   11ad7:	50                   	push   %eax
   11ad8:	e8 0c 24 ff ff       	call   3ee9 <lodepng_memcpy>
   11add:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   11ae0:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ae3:	83 ec 0c             	sub    $0xc,%esp
   11ae6:	50                   	push   %eax
   11ae7:	e8 e0 74 ff ff       	call   8fcc <lodepng_chunk_generate_crc>
   11aec:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11aef:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   11af2:	83 ec 0c             	sub    $0xc,%esp
   11af5:	50                   	push   %eax
   11af6:	e8 d1 23 ff ff       	call   3ecc <lodepng_free>
   11afb:	83 c4 10             	add    $0x10,%esp
  return error;
   11afe:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11b01:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11b04:	c9                   	leave  
   11b05:	c3                   	ret    

00011b06 <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   11b06:	55                   	push   %ebp
   11b07:	89 e5                	mov    %esp,%ebp
   11b09:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   11b0c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   11b13:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b16:	8b 40 0c             	mov    0xc(%eax),%eax
   11b19:	85 c0                	test   %eax,%eax
   11b1b:	74 0b                	je     11b28 <addChunk_bKGD+0x22>
   11b1d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b20:	8b 40 0c             	mov    0xc(%eax),%eax
   11b23:	83 f8 04             	cmp    $0x4,%eax
   11b26:	75 4b                	jne    11b73 <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   11b28:	68 b2 ac 01 00       	push   $0x1acb2
   11b2d:	6a 02                	push   $0x2
   11b2f:	ff 75 08             	pushl  0x8(%ebp)
   11b32:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11b35:	50                   	push   %eax
   11b36:	e8 e8 77 ff ff       	call   9323 <lodepng_chunk_init>
   11b3b:	83 c4 10             	add    $0x10,%esp
   11b3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11b41:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11b45:	74 08                	je     11b4f <addChunk_bKGD+0x49>
   11b47:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11b4a:	e9 19 01 00 00       	jmp    11c68 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   11b4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b52:	8d 50 08             	lea    0x8(%eax),%edx
   11b55:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b58:	8b 40 30             	mov    0x30(%eax),%eax
   11b5b:	c1 e8 08             	shr    $0x8,%eax
   11b5e:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   11b60:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b63:	8d 50 09             	lea    0x9(%eax),%edx
   11b66:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b69:	8b 40 30             	mov    0x30(%eax),%eax
   11b6c:	88 02                	mov    %al,(%edx)
   11b6e:	e9 dd 00 00 00       	jmp    11c50 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   11b73:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b76:	8b 40 0c             	mov    0xc(%eax),%eax
   11b79:	83 f8 02             	cmp    $0x2,%eax
   11b7c:	74 0f                	je     11b8d <addChunk_bKGD+0x87>
   11b7e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b81:	8b 40 0c             	mov    0xc(%eax),%eax
   11b84:	83 f8 06             	cmp    $0x6,%eax
   11b87:	0f 85 86 00 00 00    	jne    11c13 <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   11b8d:	68 b2 ac 01 00       	push   $0x1acb2
   11b92:	6a 06                	push   $0x6
   11b94:	ff 75 08             	pushl  0x8(%ebp)
   11b97:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11b9a:	50                   	push   %eax
   11b9b:	e8 83 77 ff ff       	call   9323 <lodepng_chunk_init>
   11ba0:	83 c4 10             	add    $0x10,%esp
   11ba3:	89 45 f8             	mov    %eax,-0x8(%ebp)
   11ba6:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   11baa:	74 08                	je     11bb4 <addChunk_bKGD+0xae>
   11bac:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11baf:	e9 b4 00 00 00       	jmp    11c68 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   11bb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11bb7:	8d 50 08             	lea    0x8(%eax),%edx
   11bba:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bbd:	8b 40 30             	mov    0x30(%eax),%eax
   11bc0:	c1 e8 08             	shr    $0x8,%eax
   11bc3:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   11bc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11bc8:	8d 50 09             	lea    0x9(%eax),%edx
   11bcb:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bce:	8b 40 30             	mov    0x30(%eax),%eax
   11bd1:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   11bd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11bd6:	8d 50 0a             	lea    0xa(%eax),%edx
   11bd9:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bdc:	8b 40 34             	mov    0x34(%eax),%eax
   11bdf:	c1 e8 08             	shr    $0x8,%eax
   11be2:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   11be4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11be7:	8d 50 0b             	lea    0xb(%eax),%edx
   11bea:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bed:	8b 40 34             	mov    0x34(%eax),%eax
   11bf0:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   11bf2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11bf5:	8d 50 0c             	lea    0xc(%eax),%edx
   11bf8:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bfb:	8b 40 38             	mov    0x38(%eax),%eax
   11bfe:	c1 e8 08             	shr    $0x8,%eax
   11c01:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   11c03:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c06:	8d 50 0d             	lea    0xd(%eax),%edx
   11c09:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c0c:	8b 40 38             	mov    0x38(%eax),%eax
   11c0f:	88 02                	mov    %al,(%edx)
   11c11:	eb 3d                	jmp    11c50 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   11c13:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c16:	8b 40 0c             	mov    0xc(%eax),%eax
   11c19:	83 f8 03             	cmp    $0x3,%eax
   11c1c:	75 32                	jne    11c50 <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   11c1e:	68 b2 ac 01 00       	push   $0x1acb2
   11c23:	6a 01                	push   $0x1
   11c25:	ff 75 08             	pushl  0x8(%ebp)
   11c28:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11c2b:	50                   	push   %eax
   11c2c:	e8 f2 76 ff ff       	call   9323 <lodepng_chunk_init>
   11c31:	83 c4 10             	add    $0x10,%esp
   11c34:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11c37:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11c3b:	74 05                	je     11c42 <addChunk_bKGD+0x13c>
   11c3d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11c40:	eb 26                	jmp    11c68 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   11c42:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c45:	8d 50 08             	lea    0x8(%eax),%edx
   11c48:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c4b:	8b 40 30             	mov    0x30(%eax),%eax
   11c4e:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   11c50:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c53:	85 c0                	test   %eax,%eax
   11c55:	74 0c                	je     11c63 <addChunk_bKGD+0x15d>
   11c57:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c5a:	50                   	push   %eax
   11c5b:	e8 6c 73 ff ff       	call   8fcc <lodepng_chunk_generate_crc>
   11c60:	83 c4 04             	add    $0x4,%esp
  return 0;
   11c63:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11c68:	c9                   	leave  
   11c69:	c3                   	ret    

00011c6a <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   11c6a:	55                   	push   %ebp
   11c6b:	89 e5                	mov    %esp,%ebp
   11c6d:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   11c70:	68 c6 ac 01 00       	push   $0x1acc6
   11c75:	6a 07                	push   $0x7
   11c77:	ff 75 08             	pushl  0x8(%ebp)
   11c7a:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11c7d:	50                   	push   %eax
   11c7e:	e8 a0 76 ff ff       	call   9323 <lodepng_chunk_init>
   11c83:	83 c4 10             	add    $0x10,%esp
   11c86:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11c89:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11c8d:	74 05                	je     11c94 <addChunk_tIME+0x2a>
   11c8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11c92:	eb 74                	jmp    11d08 <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   11c94:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11c97:	8d 50 08             	lea    0x8(%eax),%edx
   11c9a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c9d:	8b 00                	mov    (%eax),%eax
   11c9f:	c1 e8 08             	shr    $0x8,%eax
   11ca2:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   11ca4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11ca7:	8d 50 09             	lea    0x9(%eax),%edx
   11caa:	8b 45 0c             	mov    0xc(%ebp),%eax
   11cad:	8b 00                	mov    (%eax),%eax
   11caf:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   11cb1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11cb4:	8d 50 0a             	lea    0xa(%eax),%edx
   11cb7:	8b 45 0c             	mov    0xc(%ebp),%eax
   11cba:	8b 40 04             	mov    0x4(%eax),%eax
   11cbd:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   11cbf:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11cc2:	8d 50 0b             	lea    0xb(%eax),%edx
   11cc5:	8b 45 0c             	mov    0xc(%ebp),%eax
   11cc8:	8b 40 08             	mov    0x8(%eax),%eax
   11ccb:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   11ccd:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11cd0:	8d 50 0c             	lea    0xc(%eax),%edx
   11cd3:	8b 45 0c             	mov    0xc(%ebp),%eax
   11cd6:	8b 40 0c             	mov    0xc(%eax),%eax
   11cd9:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   11cdb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11cde:	8d 50 0d             	lea    0xd(%eax),%edx
   11ce1:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ce4:	8b 40 10             	mov    0x10(%eax),%eax
   11ce7:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   11ce9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11cec:	8d 50 0e             	lea    0xe(%eax),%edx
   11cef:	8b 45 0c             	mov    0xc(%ebp),%eax
   11cf2:	8b 40 14             	mov    0x14(%eax),%eax
   11cf5:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   11cf7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11cfa:	50                   	push   %eax
   11cfb:	e8 cc 72 ff ff       	call   8fcc <lodepng_chunk_generate_crc>
   11d00:	83 c4 04             	add    $0x4,%esp
  return 0;
   11d03:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11d08:	c9                   	leave  
   11d09:	c3                   	ret    

00011d0a <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   11d0a:	55                   	push   %ebp
   11d0b:	89 e5                	mov    %esp,%ebp
   11d0d:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   11d10:	68 cb ac 01 00       	push   $0x1accb
   11d15:	6a 09                	push   $0x9
   11d17:	ff 75 08             	pushl  0x8(%ebp)
   11d1a:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11d1d:	50                   	push   %eax
   11d1e:	e8 00 76 ff ff       	call   9323 <lodepng_chunk_init>
   11d23:	83 c4 10             	add    $0x10,%esp
   11d26:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11d29:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11d2d:	74 05                	je     11d34 <addChunk_pHYs+0x2a>
   11d2f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11d32:	eb 51                	jmp    11d85 <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   11d34:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d37:	8b 40 7c             	mov    0x7c(%eax),%eax
   11d3a:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11d3d:	83 c2 08             	add    $0x8,%edx
   11d40:	50                   	push   %eax
   11d41:	52                   	push   %edx
   11d42:	e8 25 25 ff ff       	call   426c <lodepng_set32bitInt>
   11d47:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   11d4a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d4d:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   11d53:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11d56:	83 c2 0c             	add    $0xc,%edx
   11d59:	50                   	push   %eax
   11d5a:	52                   	push   %edx
   11d5b:	e8 0c 25 ff ff       	call   426c <lodepng_set32bitInt>
   11d60:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   11d63:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11d66:	8d 50 10             	lea    0x10(%eax),%edx
   11d69:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d6c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   11d72:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   11d74:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11d77:	50                   	push   %eax
   11d78:	e8 4f 72 ff ff       	call   8fcc <lodepng_chunk_generate_crc>
   11d7d:	83 c4 04             	add    $0x4,%esp
  return 0;
   11d80:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11d85:	c9                   	leave  
   11d86:	c3                   	ret    

00011d87 <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   11d87:	55                   	push   %ebp
   11d88:	89 e5                	mov    %esp,%ebp
   11d8a:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   11d8d:	68 d0 ac 01 00       	push   $0x1acd0
   11d92:	6a 04                	push   $0x4
   11d94:	ff 75 08             	pushl  0x8(%ebp)
   11d97:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11d9a:	50                   	push   %eax
   11d9b:	e8 83 75 ff ff       	call   9323 <lodepng_chunk_init>
   11da0:	83 c4 10             	add    $0x10,%esp
   11da3:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11da6:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11daa:	74 05                	je     11db1 <addChunk_gAMA+0x2a>
   11dac:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11daf:	eb 2a                	jmp    11ddb <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   11db1:	8b 45 0c             	mov    0xc(%ebp),%eax
   11db4:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   11dba:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11dbd:	83 c2 08             	add    $0x8,%edx
   11dc0:	50                   	push   %eax
   11dc1:	52                   	push   %edx
   11dc2:	e8 a5 24 ff ff       	call   426c <lodepng_set32bitInt>
   11dc7:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   11dca:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11dcd:	50                   	push   %eax
   11dce:	e8 f9 71 ff ff       	call   8fcc <lodepng_chunk_generate_crc>
   11dd3:	83 c4 04             	add    $0x4,%esp
  return 0;
   11dd6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11ddb:	c9                   	leave  
   11ddc:	c3                   	ret    

00011ddd <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   11ddd:	55                   	push   %ebp
   11dde:	89 e5                	mov    %esp,%ebp
   11de0:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   11de3:	68 d5 ac 01 00       	push   $0x1acd5
   11de8:	6a 20                	push   $0x20
   11dea:	ff 75 08             	pushl  0x8(%ebp)
   11ded:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11df0:	50                   	push   %eax
   11df1:	e8 2d 75 ff ff       	call   9323 <lodepng_chunk_init>
   11df6:	83 c4 10             	add    $0x10,%esp
   11df9:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11dfc:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11e00:	74 08                	je     11e0a <addChunk_cHRM+0x2d>
   11e02:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11e05:	e9 d9 00 00 00       	jmp    11ee3 <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   11e0a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e0d:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   11e13:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11e16:	83 c2 08             	add    $0x8,%edx
   11e19:	50                   	push   %eax
   11e1a:	52                   	push   %edx
   11e1b:	e8 4c 24 ff ff       	call   426c <lodepng_set32bitInt>
   11e20:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   11e23:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e26:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   11e2c:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11e2f:	83 c2 0c             	add    $0xc,%edx
   11e32:	50                   	push   %eax
   11e33:	52                   	push   %edx
   11e34:	e8 33 24 ff ff       	call   426c <lodepng_set32bitInt>
   11e39:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   11e3c:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e3f:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   11e45:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11e48:	83 c2 10             	add    $0x10,%edx
   11e4b:	50                   	push   %eax
   11e4c:	52                   	push   %edx
   11e4d:	e8 1a 24 ff ff       	call   426c <lodepng_set32bitInt>
   11e52:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   11e55:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e58:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11e5e:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11e61:	83 c2 14             	add    $0x14,%edx
   11e64:	50                   	push   %eax
   11e65:	52                   	push   %edx
   11e66:	e8 01 24 ff ff       	call   426c <lodepng_set32bitInt>
   11e6b:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   11e6e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e71:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   11e77:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11e7a:	83 c2 18             	add    $0x18,%edx
   11e7d:	50                   	push   %eax
   11e7e:	52                   	push   %edx
   11e7f:	e8 e8 23 ff ff       	call   426c <lodepng_set32bitInt>
   11e84:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   11e87:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e8a:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   11e90:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11e93:	83 c2 1c             	add    $0x1c,%edx
   11e96:	50                   	push   %eax
   11e97:	52                   	push   %edx
   11e98:	e8 cf 23 ff ff       	call   426c <lodepng_set32bitInt>
   11e9d:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   11ea0:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ea3:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   11ea9:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11eac:	83 c2 20             	add    $0x20,%edx
   11eaf:	50                   	push   %eax
   11eb0:	52                   	push   %edx
   11eb1:	e8 b6 23 ff ff       	call   426c <lodepng_set32bitInt>
   11eb6:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   11eb9:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ebc:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   11ec2:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11ec5:	83 c2 24             	add    $0x24,%edx
   11ec8:	50                   	push   %eax
   11ec9:	52                   	push   %edx
   11eca:	e8 9d 23 ff ff       	call   426c <lodepng_set32bitInt>
   11ecf:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   11ed2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11ed5:	50                   	push   %eax
   11ed6:	e8 f1 70 ff ff       	call   8fcc <lodepng_chunk_generate_crc>
   11edb:	83 c4 04             	add    $0x4,%esp
  return 0;
   11ede:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11ee3:	c9                   	leave  
   11ee4:	c3                   	ret    

00011ee5 <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   11ee5:	55                   	push   %ebp
   11ee6:	89 e5                	mov    %esp,%ebp
   11ee8:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   11eeb:	8b 45 0c             	mov    0xc(%ebp),%eax
   11eee:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   11ef4:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   11ef7:	8d 45 ff             	lea    -0x1(%ebp),%eax
   11efa:	50                   	push   %eax
   11efb:	68 da ac 01 00       	push   $0x1acda
   11f00:	6a 01                	push   $0x1
   11f02:	ff 75 08             	pushl  0x8(%ebp)
   11f05:	e8 c1 74 ff ff       	call   93cb <lodepng_chunk_createv>
   11f0a:	83 c4 10             	add    $0x10,%esp
}
   11f0d:	c9                   	leave  
   11f0e:	c3                   	ret    

00011f0f <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   11f0f:	55                   	push   %ebp
   11f10:	89 e5                	mov    %esp,%ebp
   11f12:	53                   	push   %ebx
   11f13:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   11f16:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11f1d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   11f24:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   11f2b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   11f32:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f35:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11f3b:	50                   	push   %eax
   11f3c:	e8 06 20 ff ff       	call   3f47 <lodepng_strlen>
   11f41:	83 c4 04             	add    $0x4,%esp
   11f44:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11f47:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11f4b:	7e 06                	jle    11f53 <addChunk_iCCP+0x44>
   11f4d:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   11f51:	7e 0a                	jle    11f5d <addChunk_iCCP+0x4e>
   11f53:	b8 59 00 00 00       	mov    $0x59,%eax
   11f58:	e9 df 00 00 00       	jmp    1203c <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   11f5d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f60:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   11f66:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   11f68:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f6b:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   11f71:	83 ec 0c             	sub    $0xc,%esp
   11f74:	ff 75 10             	pushl  0x10(%ebp)
   11f77:	52                   	push   %edx
   11f78:	50                   	push   %eax
   11f79:	8d 45 e0             	lea    -0x20(%ebp),%eax
   11f7c:	50                   	push   %eax
   11f7d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   11f80:	50                   	push   %eax
   11f81:	e8 35 6c ff ff       	call   8bbb <zlib_compress>
   11f86:	83 c4 20             	add    $0x20,%esp
   11f89:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   11f8c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11f90:	75 29                	jne    11fbb <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   11f92:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11f95:	8d 50 02             	lea    0x2(%eax),%edx
   11f98:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11f9b:	01 d0                	add    %edx,%eax
   11f9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   11fa0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11fa3:	68 df ac 01 00       	push   $0x1acdf
   11fa8:	50                   	push   %eax
   11fa9:	ff 75 08             	pushl  0x8(%ebp)
   11fac:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11faf:	50                   	push   %eax
   11fb0:	e8 6e 73 ff ff       	call   9323 <lodepng_chunk_init>
   11fb5:	83 c4 10             	add    $0x10,%esp
   11fb8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11fbb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11fbf:	75 69                	jne    1202a <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   11fc1:	8b 45 0c             	mov    0xc(%ebp),%eax
   11fc4:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11fca:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11fcd:	83 c2 08             	add    $0x8,%edx
   11fd0:	83 ec 04             	sub    $0x4,%esp
   11fd3:	ff 75 f0             	pushl  -0x10(%ebp)
   11fd6:	50                   	push   %eax
   11fd7:	52                   	push   %edx
   11fd8:	e8 0c 1f ff ff       	call   3ee9 <lodepng_memcpy>
   11fdd:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   11fe0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11fe3:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11fe6:	83 c2 08             	add    $0x8,%edx
   11fe9:	01 d0                	add    %edx,%eax
   11feb:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   11fee:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11ff1:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11ff4:	83 c2 09             	add    $0x9,%edx
   11ff7:	01 d0                	add    %edx,%eax
   11ff9:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11ffc:	8b 55 e0             	mov    -0x20(%ebp),%edx
   11fff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12002:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   12005:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   12008:	83 c3 0a             	add    $0xa,%ebx
   1200b:	01 d9                	add    %ebx,%ecx
   1200d:	83 ec 04             	sub    $0x4,%esp
   12010:	52                   	push   %edx
   12011:	50                   	push   %eax
   12012:	51                   	push   %ecx
   12013:	e8 d1 1e ff ff       	call   3ee9 <lodepng_memcpy>
   12018:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   1201b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1201e:	83 ec 0c             	sub    $0xc,%esp
   12021:	50                   	push   %eax
   12022:	e8 a5 6f ff ff       	call   8fcc <lodepng_chunk_generate_crc>
   12027:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   1202a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1202d:	83 ec 0c             	sub    $0xc,%esp
   12030:	50                   	push   %eax
   12031:	e8 96 1e ff ff       	call   3ecc <lodepng_free>
   12036:	83 c4 10             	add    $0x10,%esp
  return error;
   12039:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1203c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1203f:	c9                   	leave  
   12040:	c3                   	ret    

00012041 <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   12041:	55                   	push   %ebp
   12042:	89 e5                	mov    %esp,%ebp
   12044:	56                   	push   %esi
   12045:	53                   	push   %ebx
   12046:	83 ec 14             	sub    $0x14,%esp
   12049:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1204c:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   1204f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   12053:	83 f8 04             	cmp    $0x4,%eax
   12056:	0f 87 41 03 00 00    	ja     1239d <filterScanline+0x35c>
   1205c:	8b 04 85 f0 ac 01 00 	mov    0x1acf0(,%eax,4),%eax
   12063:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   12065:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1206c:	eb 19                	jmp    12087 <filterScanline+0x46>
   1206e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12071:	8b 45 08             	mov    0x8(%ebp),%eax
   12074:	01 c2                	add    %eax,%edx
   12076:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12079:	8b 45 0c             	mov    0xc(%ebp),%eax
   1207c:	01 c8                	add    %ecx,%eax
   1207e:	0f b6 00             	movzbl (%eax),%eax
   12081:	88 02                	mov    %al,(%edx)
   12083:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12087:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1208a:	3b 45 14             	cmp    0x14(%ebp),%eax
   1208d:	75 df                	jne    1206e <filterScanline+0x2d>
      break;
   1208f:	e9 0a 03 00 00       	jmp    1239e <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   12094:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1209b:	eb 19                	jmp    120b6 <filterScanline+0x75>
   1209d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   120a0:	8b 45 08             	mov    0x8(%ebp),%eax
   120a3:	01 c2                	add    %eax,%edx
   120a5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   120a8:	8b 45 0c             	mov    0xc(%ebp),%eax
   120ab:	01 c8                	add    %ecx,%eax
   120ad:	0f b6 00             	movzbl (%eax),%eax
   120b0:	88 02                	mov    %al,(%edx)
   120b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   120b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   120b9:	3b 45 18             	cmp    0x18(%ebp),%eax
   120bc:	75 df                	jne    1209d <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   120be:	8b 45 18             	mov    0x18(%ebp),%eax
   120c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
   120c4:	eb 2d                	jmp    120f3 <filterScanline+0xb2>
   120c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   120c9:	8b 45 08             	mov    0x8(%ebp),%eax
   120cc:	01 c2                	add    %eax,%edx
   120ce:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   120d1:	8b 45 0c             	mov    0xc(%ebp),%eax
   120d4:	01 c8                	add    %ecx,%eax
   120d6:	0f b6 08             	movzbl (%eax),%ecx
   120d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   120dc:	2b 45 18             	sub    0x18(%ebp),%eax
   120df:	89 c3                	mov    %eax,%ebx
   120e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   120e4:	01 d8                	add    %ebx,%eax
   120e6:	0f b6 00             	movzbl (%eax),%eax
   120e9:	29 c1                	sub    %eax,%ecx
   120eb:	89 c8                	mov    %ecx,%eax
   120ed:	88 02                	mov    %al,(%edx)
   120ef:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   120f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   120f6:	3b 45 14             	cmp    0x14(%ebp),%eax
   120f9:	7c cb                	jl     120c6 <filterScanline+0x85>
      break;
   120fb:	e9 9e 02 00 00       	jmp    1239e <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   12100:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   12104:	74 3e                	je     12144 <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   12106:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1210d:	eb 28                	jmp    12137 <filterScanline+0xf6>
   1210f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12112:	8b 45 08             	mov    0x8(%ebp),%eax
   12115:	01 d0                	add    %edx,%eax
   12117:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1211a:	8b 55 0c             	mov    0xc(%ebp),%edx
   1211d:	01 ca                	add    %ecx,%edx
   1211f:	0f b6 0a             	movzbl (%edx),%ecx
   12122:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   12125:	8b 55 10             	mov    0x10(%ebp),%edx
   12128:	01 da                	add    %ebx,%edx
   1212a:	0f b6 12             	movzbl (%edx),%edx
   1212d:	29 d1                	sub    %edx,%ecx
   1212f:	89 ca                	mov    %ecx,%edx
   12131:	88 10                	mov    %dl,(%eax)
   12133:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12137:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1213a:	3b 45 14             	cmp    0x14(%ebp),%eax
   1213d:	75 d0                	jne    1210f <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   1213f:	e9 5a 02 00 00       	jmp    1239e <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   12144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1214b:	eb 19                	jmp    12166 <filterScanline+0x125>
   1214d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12150:	8b 45 08             	mov    0x8(%ebp),%eax
   12153:	01 c2                	add    %eax,%edx
   12155:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12158:	8b 45 0c             	mov    0xc(%ebp),%eax
   1215b:	01 c8                	add    %ecx,%eax
   1215d:	0f b6 00             	movzbl (%eax),%eax
   12160:	88 02                	mov    %al,(%edx)
   12162:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12166:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12169:	3b 45 14             	cmp    0x14(%ebp),%eax
   1216c:	75 df                	jne    1214d <filterScanline+0x10c>
      }
      break;
   1216e:	e9 2b 02 00 00       	jmp    1239e <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   12173:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   12177:	0f 84 90 00 00 00    	je     1220d <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   1217d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12184:	eb 28                	jmp    121ae <filterScanline+0x16d>
   12186:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12189:	8b 45 08             	mov    0x8(%ebp),%eax
   1218c:	01 d0                	add    %edx,%eax
   1218e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12191:	8b 55 0c             	mov    0xc(%ebp),%edx
   12194:	01 ca                	add    %ecx,%edx
   12196:	0f b6 12             	movzbl (%edx),%edx
   12199:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1219c:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1219f:	01 d9                	add    %ebx,%ecx
   121a1:	0f b6 09             	movzbl (%ecx),%ecx
   121a4:	d0 e9                	shr    %cl
   121a6:	29 ca                	sub    %ecx,%edx
   121a8:	88 10                	mov    %dl,(%eax)
   121aa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   121ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   121b1:	3b 45 18             	cmp    0x18(%ebp),%eax
   121b4:	75 d0                	jne    12186 <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   121b6:	8b 45 18             	mov    0x18(%ebp),%eax
   121b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
   121bc:	eb 42                	jmp    12200 <filterScanline+0x1bf>
   121be:	8b 55 f4             	mov    -0xc(%ebp),%edx
   121c1:	8b 45 08             	mov    0x8(%ebp),%eax
   121c4:	01 c2                	add    %eax,%edx
   121c6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   121c9:	8b 45 0c             	mov    0xc(%ebp),%eax
   121cc:	01 c8                	add    %ecx,%eax
   121ce:	0f b6 08             	movzbl (%eax),%ecx
   121d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   121d4:	2b 45 18             	sub    0x18(%ebp),%eax
   121d7:	89 c3                	mov    %eax,%ebx
   121d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   121dc:	01 d8                	add    %ebx,%eax
   121de:	0f b6 00             	movzbl (%eax),%eax
   121e1:	0f b6 d8             	movzbl %al,%ebx
   121e4:	8b 75 f4             	mov    -0xc(%ebp),%esi
   121e7:	8b 45 10             	mov    0x10(%ebp),%eax
   121ea:	01 f0                	add    %esi,%eax
   121ec:	0f b6 00             	movzbl (%eax),%eax
   121ef:	0f b6 c0             	movzbl %al,%eax
   121f2:	01 d8                	add    %ebx,%eax
   121f4:	d1 f8                	sar    %eax
   121f6:	29 c1                	sub    %eax,%ecx
   121f8:	89 c8                	mov    %ecx,%eax
   121fa:	88 02                	mov    %al,(%edx)
   121fc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12200:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12203:	3b 45 14             	cmp    0x14(%ebp),%eax
   12206:	7c b6                	jl     121be <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   12208:	e9 91 01 00 00       	jmp    1239e <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   1220d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12214:	eb 19                	jmp    1222f <filterScanline+0x1ee>
   12216:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12219:	8b 45 08             	mov    0x8(%ebp),%eax
   1221c:	01 c2                	add    %eax,%edx
   1221e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12221:	8b 45 0c             	mov    0xc(%ebp),%eax
   12224:	01 c8                	add    %ecx,%eax
   12226:	0f b6 00             	movzbl (%eax),%eax
   12229:	88 02                	mov    %al,(%edx)
   1222b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1222f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12232:	3b 45 18             	cmp    0x18(%ebp),%eax
   12235:	75 df                	jne    12216 <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   12237:	8b 45 18             	mov    0x18(%ebp),%eax
   1223a:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1223d:	eb 2f                	jmp    1226e <filterScanline+0x22d>
   1223f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12242:	8b 45 08             	mov    0x8(%ebp),%eax
   12245:	01 c2                	add    %eax,%edx
   12247:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1224a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1224d:	01 c8                	add    %ecx,%eax
   1224f:	0f b6 08             	movzbl (%eax),%ecx
   12252:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12255:	2b 45 18             	sub    0x18(%ebp),%eax
   12258:	89 c3                	mov    %eax,%ebx
   1225a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1225d:	01 d8                	add    %ebx,%eax
   1225f:	0f b6 00             	movzbl (%eax),%eax
   12262:	d0 e8                	shr    %al
   12264:	29 c1                	sub    %eax,%ecx
   12266:	89 c8                	mov    %ecx,%eax
   12268:	88 02                	mov    %al,(%edx)
   1226a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1226e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12271:	3b 45 14             	cmp    0x14(%ebp),%eax
   12274:	7c c9                	jl     1223f <filterScanline+0x1fe>
      }
      break;
   12276:	e9 23 01 00 00       	jmp    1239e <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   1227b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1227f:	0f 84 af 00 00 00    	je     12334 <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   12285:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1228c:	eb 28                	jmp    122b6 <filterScanline+0x275>
   1228e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12291:	8b 45 08             	mov    0x8(%ebp),%eax
   12294:	01 d0                	add    %edx,%eax
   12296:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12299:	8b 55 0c             	mov    0xc(%ebp),%edx
   1229c:	01 ca                	add    %ecx,%edx
   1229e:	0f b6 0a             	movzbl (%edx),%ecx
   122a1:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   122a4:	8b 55 10             	mov    0x10(%ebp),%edx
   122a7:	01 da                	add    %ebx,%edx
   122a9:	0f b6 12             	movzbl (%edx),%edx
   122ac:	29 d1                	sub    %edx,%ecx
   122ae:	89 ca                	mov    %ecx,%edx
   122b0:	88 10                	mov    %dl,(%eax)
   122b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   122b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   122b9:	3b 45 18             	cmp    0x18(%ebp),%eax
   122bc:	75 d0                	jne    1228e <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   122be:	8b 45 18             	mov    0x18(%ebp),%eax
   122c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
   122c4:	eb 64                	jmp    1232a <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   122c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   122c9:	8b 45 08             	mov    0x8(%ebp),%eax
   122cc:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   122cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
   122d2:	8b 45 0c             	mov    0xc(%ebp),%eax
   122d5:	01 d0                	add    %edx,%eax
   122d7:	0f b6 00             	movzbl (%eax),%eax
   122da:	88 45 e7             	mov    %al,-0x19(%ebp)
   122dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   122e0:	2b 45 18             	sub    0x18(%ebp),%eax
   122e3:	89 c2                	mov    %eax,%edx
   122e5:	8b 45 10             	mov    0x10(%ebp),%eax
   122e8:	01 d0                	add    %edx,%eax
   122ea:	0f b6 00             	movzbl (%eax),%eax
   122ed:	0f b6 c8             	movzbl %al,%ecx
   122f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   122f3:	8b 45 10             	mov    0x10(%ebp),%eax
   122f6:	01 d0                	add    %edx,%eax
   122f8:	0f b6 00             	movzbl (%eax),%eax
   122fb:	0f b6 d0             	movzbl %al,%edx
   122fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12301:	2b 45 18             	sub    0x18(%ebp),%eax
   12304:	89 c6                	mov    %eax,%esi
   12306:	8b 45 0c             	mov    0xc(%ebp),%eax
   12309:	01 f0                	add    %esi,%eax
   1230b:	0f b6 00             	movzbl (%eax),%eax
   1230e:	0f b6 c0             	movzbl %al,%eax
   12311:	51                   	push   %ecx
   12312:	52                   	push   %edx
   12313:	50                   	push   %eax
   12314:	e8 49 b8 ff ff       	call   db62 <paethPredictor>
   12319:	83 c4 0c             	add    $0xc,%esp
   1231c:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   12320:	29 c1                	sub    %eax,%ecx
   12322:	89 c8                	mov    %ecx,%eax
   12324:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   12326:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1232a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1232d:	3b 45 14             	cmp    0x14(%ebp),%eax
   12330:	7c 94                	jl     122c6 <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   12332:	eb 6a                	jmp    1239e <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   12334:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1233b:	eb 19                	jmp    12356 <filterScanline+0x315>
   1233d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12340:	8b 45 08             	mov    0x8(%ebp),%eax
   12343:	01 c2                	add    %eax,%edx
   12345:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12348:	8b 45 0c             	mov    0xc(%ebp),%eax
   1234b:	01 c8                	add    %ecx,%eax
   1234d:	0f b6 00             	movzbl (%eax),%eax
   12350:	88 02                	mov    %al,(%edx)
   12352:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12356:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12359:	3b 45 18             	cmp    0x18(%ebp),%eax
   1235c:	75 df                	jne    1233d <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   1235e:	8b 45 18             	mov    0x18(%ebp),%eax
   12361:	89 45 f4             	mov    %eax,-0xc(%ebp)
   12364:	eb 2d                	jmp    12393 <filterScanline+0x352>
   12366:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12369:	8b 45 08             	mov    0x8(%ebp),%eax
   1236c:	01 c2                	add    %eax,%edx
   1236e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   12371:	8b 45 0c             	mov    0xc(%ebp),%eax
   12374:	01 c8                	add    %ecx,%eax
   12376:	0f b6 08             	movzbl (%eax),%ecx
   12379:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1237c:	2b 45 18             	sub    0x18(%ebp),%eax
   1237f:	89 c3                	mov    %eax,%ebx
   12381:	8b 45 0c             	mov    0xc(%ebp),%eax
   12384:	01 d8                	add    %ebx,%eax
   12386:	0f b6 00             	movzbl (%eax),%eax
   12389:	29 c1                	sub    %eax,%ecx
   1238b:	89 c8                	mov    %ecx,%eax
   1238d:	88 02                	mov    %al,(%edx)
   1238f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12393:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12396:	3b 45 14             	cmp    0x14(%ebp),%eax
   12399:	7c cb                	jl     12366 <filterScanline+0x325>
      }
      break;
   1239b:	eb 01                	jmp    1239e <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   1239d:	90                   	nop
  }
}
   1239e:	8d 65 f8             	lea    -0x8(%ebp),%esp
   123a1:	5b                   	pop    %ebx
   123a2:	5e                   	pop    %esi
   123a3:	5d                   	pop    %ebp
   123a4:	c3                   	ret    

000123a5 <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   123a5:	55                   	push   %ebp
   123a6:	89 e5                	mov    %esp,%ebp
   123a8:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   123ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   123b2:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   123b9:	7e 08                	jle    123c3 <ilog2+0x1e>
   123bb:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   123bf:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   123c3:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   123ca:	7e 08                	jle    123d4 <ilog2+0x2f>
   123cc:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   123d0:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   123d4:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   123d8:	7e 08                	jle    123e2 <ilog2+0x3d>
   123da:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   123de:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   123e2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   123e6:	7e 08                	jle    123f0 <ilog2+0x4b>
   123e8:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   123ec:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   123f0:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   123f4:	7e 04                	jle    123fa <ilog2+0x55>
   123f6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   123fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   123fd:	c9                   	leave  
   123fe:	c3                   	ret    

000123ff <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   123ff:	55                   	push   %ebp
   12400:	89 e5                	mov    %esp,%ebp
   12402:	56                   	push   %esi
   12403:	53                   	push   %ebx
   12404:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   12407:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1240b:	75 07                	jne    12414 <ilog2i+0x15>
   1240d:	b8 00 00 00 00       	mov    $0x0,%eax
   12412:	eb 30                	jmp    12444 <ilog2i+0x45>
  l = ilog2(i);
   12414:	ff 75 08             	pushl  0x8(%ebp)
   12417:	e8 89 ff ff ff       	call   123a5 <ilog2>
   1241c:	83 c4 04             	add    $0x4,%esp
   1241f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   12422:	8b 45 08             	mov    0x8(%ebp),%eax
   12425:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   12429:	89 c3                	mov    %eax,%ebx
   1242b:	8b 55 08             	mov    0x8(%ebp),%edx
   1242e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12431:	be 01 00 00 00       	mov    $0x1,%esi
   12436:	89 c1                	mov    %eax,%ecx
   12438:	d3 e6                	shl    %cl,%esi
   1243a:	89 f0                	mov    %esi,%eax
   1243c:	29 c2                	sub    %eax,%edx
   1243e:	89 d0                	mov    %edx,%eax
   12440:	01 c0                	add    %eax,%eax
   12442:	01 d8                	add    %ebx,%eax
}
   12444:	8d 65 f8             	lea    -0x8(%ebp),%esp
   12447:	5b                   	pop    %ebx
   12448:	5e                   	pop    %esi
   12449:	5d                   	pop    %ebp
   1244a:	c3                   	ret    

0001244b <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   1244b:	55                   	push   %ebp
   1244c:	89 e5                	mov    %esp,%ebp
   1244e:	53                   	push   %ebx
   1244f:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   12455:	ff 75 18             	pushl  0x18(%ebp)
   12458:	e8 6a 75 ff ff       	call   99c7 <lodepng_get_bpp>
   1245d:	83 c4 04             	add    $0x4,%esp
   12460:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   12463:	ff 75 b8             	pushl  -0x48(%ebp)
   12466:	6a 01                	push   $0x1
   12468:	ff 75 10             	pushl  0x10(%ebp)
   1246b:	e8 b6 76 ff ff       	call   9b26 <lodepng_get_raw_size_idat>
   12470:	83 c4 0c             	add    $0xc,%esp
   12473:	83 e8 01             	sub    $0x1,%eax
   12476:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   12479:	8b 45 b8             	mov    -0x48(%ebp),%eax
   1247c:	83 c0 07             	add    $0x7,%eax
   1247f:	c1 e8 03             	shr    $0x3,%eax
   12482:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   12485:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   1248c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   12493:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12496:	8b 40 2c             	mov    0x2c(%eax),%eax
   12499:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   1249c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1249f:	8b 40 28             	mov    0x28(%eax),%eax
   124a2:	85 c0                	test   %eax,%eax
   124a4:	74 1c                	je     124c2 <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   124a6:	8b 45 18             	mov    0x18(%ebp),%eax
   124a9:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   124ab:	83 f8 03             	cmp    $0x3,%eax
   124ae:	74 0b                	je     124bb <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   124b0:	8b 45 18             	mov    0x18(%ebp),%eax
   124b3:	8b 40 04             	mov    0x4(%eax),%eax
   124b6:	83 f8 07             	cmp    $0x7,%eax
   124b9:	77 07                	ja     124c2 <filter+0x77>
   124bb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   124c2:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   124c6:	75 0a                	jne    124d2 <filter+0x87>
   124c8:	b8 1f 00 00 00       	mov    $0x1f,%eax
   124cd:	e9 5b 07 00 00       	jmp    12c2d <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   124d2:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   124d6:	77 7b                	ja     12553 <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   124d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   124db:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   124de:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   124e5:	eb 5f                	jmp    12546 <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   124e7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   124ea:	83 c0 01             	add    $0x1,%eax
   124ed:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   124f1:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   124f4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   124f7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   124fb:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   124fe:	8b 55 9c             	mov    -0x64(%ebp),%edx
   12501:	8b 45 08             	mov    0x8(%ebp),%eax
   12504:	01 c2                	add    %eax,%edx
   12506:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   1250a:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   1250c:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   12510:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   12513:	8b 55 0c             	mov    0xc(%ebp),%edx
   12516:	01 d1                	add    %edx,%ecx
   12518:	8b 55 9c             	mov    -0x64(%ebp),%edx
   1251b:	8d 5a 01             	lea    0x1(%edx),%ebx
   1251e:	8b 55 08             	mov    0x8(%ebp),%edx
   12521:	01 da                	add    %ebx,%edx
   12523:	50                   	push   %eax
   12524:	ff 75 b0             	pushl  -0x50(%ebp)
   12527:	ff 75 b4             	pushl  -0x4c(%ebp)
   1252a:	ff 75 f4             	pushl  -0xc(%ebp)
   1252d:	51                   	push   %ecx
   1252e:	52                   	push   %edx
   1252f:	e8 0d fb ff ff       	call   12041 <filterScanline>
   12534:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   12537:	8b 55 98             	mov    -0x68(%ebp),%edx
   1253a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1253d:	01 d0                	add    %edx,%eax
   1253f:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   12542:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12546:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12549:	3b 45 14             	cmp    0x14(%ebp),%eax
   1254c:	75 99                	jne    124e7 <filter+0x9c>
   1254e:	e9 d7 06 00 00       	jmp    12c2a <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   12553:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   12557:	0f 85 e3 01 00 00    	jne    12740 <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   1255d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   12564:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   12568:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   1256c:	eb 2d                	jmp    1259b <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   1256e:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   12572:	83 ec 0c             	sub    $0xc,%esp
   12575:	ff 75 b4             	pushl  -0x4c(%ebp)
   12578:	e8 2e 19 ff ff       	call   3eab <lodepng_malloc>
   1257d:	83 c4 10             	add    $0x10,%esp
   12580:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   12584:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   12588:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   1258c:	85 c0                	test   %eax,%eax
   1258e:	75 07                	jne    12597 <filter+0x14c>
   12590:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   12597:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   1259b:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   1259f:	75 cd                	jne    1256e <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   125a1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   125a5:	0f 85 6c 01 00 00    	jne    12717 <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   125ab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   125b2:	e9 54 01 00 00       	jmp    1270b <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   125b7:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   125bb:	e9 d5 00 00 00       	jmp    12695 <filter+0x24a>
          size_t sum = 0;
   125c0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   125c7:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   125cb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   125ce:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   125d2:	89 c1                	mov    %eax,%ecx
   125d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   125d7:	01 c1                	add    %eax,%ecx
   125d9:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   125dd:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   125e1:	83 ec 08             	sub    $0x8,%esp
   125e4:	52                   	push   %edx
   125e5:	ff 75 b0             	pushl  -0x50(%ebp)
   125e8:	ff 75 b4             	pushl  -0x4c(%ebp)
   125eb:	ff 75 f4             	pushl  -0xc(%ebp)
   125ee:	51                   	push   %ecx
   125ef:	50                   	push   %eax
   125f0:	e8 4c fa ff ff       	call   12041 <filterScanline>
   125f5:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   125f8:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   125fc:	75 2d                	jne    1262b <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   125fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12605:	eb 1a                	jmp    12621 <filter+0x1d6>
   12607:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   1260b:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   1260f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12612:	01 d0                	add    %edx,%eax
   12614:	0f b6 00             	movzbl (%eax),%eax
   12617:	0f b6 c0             	movzbl %al,%eax
   1261a:	01 45 d8             	add    %eax,-0x28(%ebp)
   1261d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12621:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12624:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12627:	75 de                	jne    12607 <filter+0x1bc>
   12629:	eb 4b                	jmp    12676 <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   1262b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12632:	eb 3a                	jmp    1266e <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   12634:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   12638:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   1263c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1263f:	01 d0                	add    %edx,%eax
   12641:	0f b6 00             	movzbl (%eax),%eax
   12644:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   12647:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   1264b:	84 c0                	test   %al,%al
   1264d:	78 06                	js     12655 <filter+0x20a>
   1264f:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   12653:	eb 0d                	jmp    12662 <filter+0x217>
   12655:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   12659:	ba ff 00 00 00       	mov    $0xff,%edx
   1265e:	29 c2                	sub    %eax,%edx
   12660:	89 d0                	mov    %edx,%eax
   12662:	8b 55 d8             	mov    -0x28(%ebp),%edx
   12665:	01 d0                	add    %edx,%eax
   12667:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   1266a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1266e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12671:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12674:	75 be                	jne    12634 <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   12676:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   1267a:	74 08                	je     12684 <filter+0x239>
   1267c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1267f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   12682:	7d 0d                	jge    12691 <filter+0x246>
            bestType = type;
   12684:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   12688:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   1268b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1268e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   12691:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   12695:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   12699:	0f 85 21 ff ff ff    	jne    125c0 <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   1269f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   126a2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   126a6:	89 c2                	mov    %eax,%edx
   126a8:	8b 45 0c             	mov    0xc(%ebp),%eax
   126ab:	01 d0                	add    %edx,%eax
   126ad:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   126b0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   126b3:	83 c0 01             	add    $0x1,%eax
   126b6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   126ba:	89 c2                	mov    %eax,%edx
   126bc:	8b 45 08             	mov    0x8(%ebp),%eax
   126bf:	01 c2                	add    %eax,%edx
   126c1:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   126c5:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   126c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   126ce:	eb 2f                	jmp    126ff <filter+0x2b4>
   126d0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   126d3:	83 c0 01             	add    $0x1,%eax
   126d6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   126da:	89 c2                	mov    %eax,%edx
   126dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   126df:	01 d0                	add    %edx,%eax
   126e1:	8d 50 01             	lea    0x1(%eax),%edx
   126e4:	8b 45 08             	mov    0x8(%ebp),%eax
   126e7:	01 c2                	add    %eax,%edx
   126e9:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   126ed:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   126f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   126f4:	01 c8                	add    %ecx,%eax
   126f6:	0f b6 00             	movzbl (%eax),%eax
   126f9:	88 02                	mov    %al,(%edx)
   126fb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   126ff:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12702:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12705:	75 c9                	jne    126d0 <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   12707:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1270b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1270e:	3b 45 14             	cmp    0x14(%ebp),%eax
   12711:	0f 85 a0 fe ff ff    	jne    125b7 <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12717:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   1271b:	eb 18                	jmp    12735 <filter+0x2ea>
   1271d:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   12721:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   12725:	83 ec 0c             	sub    $0xc,%esp
   12728:	50                   	push   %eax
   12729:	e8 9e 17 ff ff       	call   3ecc <lodepng_free>
   1272e:	83 c4 10             	add    $0x10,%esp
   12731:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   12735:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   12739:	75 e2                	jne    1271d <filter+0x2d2>
   1273b:	e9 ea 04 00 00       	jmp    12c2a <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   12740:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   12744:	0f 85 17 02 00 00    	jne    12961 <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   1274a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   12751:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   12758:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   1275f:	eb 33                	jmp    12794 <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   12761:	83 ec 0c             	sub    $0xc,%esp
   12764:	ff 75 b4             	pushl  -0x4c(%ebp)
   12767:	e8 3f 17 ff ff       	call   3eab <lodepng_malloc>
   1276c:	83 c4 10             	add    $0x10,%esp
   1276f:	89 c2                	mov    %eax,%edx
   12771:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12774:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   1277b:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1277e:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   12785:	85 c0                	test   %eax,%eax
   12787:	75 07                	jne    12790 <filter+0x345>
   12789:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   12790:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   12794:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   12798:	75 c7                	jne    12761 <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   1279a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1279e:	0f 85 8f 01 00 00    	jne    12933 <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   127a4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   127ab:	e9 77 01 00 00       	jmp    12927 <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   127b0:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   127b7:	e9 f4 00 00 00       	jmp    128b0 <filter+0x465>
          size_t sum = 0;
   127bc:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   127c3:	8b 45 d0             	mov    -0x30(%ebp),%eax
   127c6:	0f b6 d0             	movzbl %al,%edx
   127c9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   127cc:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   127d0:	89 c1                	mov    %eax,%ecx
   127d2:	8b 45 0c             	mov    0xc(%ebp),%eax
   127d5:	01 c1                	add    %eax,%ecx
   127d7:	8b 45 d0             	mov    -0x30(%ebp),%eax
   127da:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   127e1:	83 ec 08             	sub    $0x8,%esp
   127e4:	52                   	push   %edx
   127e5:	ff 75 b0             	pushl  -0x50(%ebp)
   127e8:	ff 75 b4             	pushl  -0x4c(%ebp)
   127eb:	ff 75 f4             	pushl  -0xc(%ebp)
   127ee:	51                   	push   %ecx
   127ef:	50                   	push   %eax
   127f0:	e8 4c f8 ff ff       	call   12041 <filterScanline>
   127f5:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   127f8:	83 ec 04             	sub    $0x4,%esp
   127fb:	68 00 04 00 00       	push   $0x400
   12800:	6a 00                	push   $0x0
   12802:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   12808:	50                   	push   %eax
   12809:	e8 0e 17 ff ff       	call   3f1c <lodepng_memset>
   1280e:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   12811:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12818:	eb 2a                	jmp    12844 <filter+0x3f9>
   1281a:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1281d:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   12824:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12827:	01 d0                	add    %edx,%eax
   12829:	0f b6 00             	movzbl (%eax),%eax
   1282c:	0f b6 c0             	movzbl %al,%eax
   1282f:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   12836:	83 c2 01             	add    $0x1,%edx
   12839:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   12840:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12844:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12847:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1284a:	75 ce                	jne    1281a <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   1284c:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1284f:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   12856:	8d 50 01             	lea    0x1(%eax),%edx
   12859:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1285c:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   12863:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1286a:	eb 1d                	jmp    12889 <filter+0x43e>
            sum += ilog2i(count[x]);
   1286c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1286f:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   12876:	83 ec 0c             	sub    $0xc,%esp
   12879:	50                   	push   %eax
   1287a:	e8 80 fb ff ff       	call   123ff <ilog2i>
   1287f:	83 c4 10             	add    $0x10,%esp
   12882:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   12885:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12889:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   12890:	75 da                	jne    1286c <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   12892:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   12896:	74 08                	je     128a0 <filter+0x455>
   12898:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1289b:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   1289e:	7e 0c                	jle    128ac <filter+0x461>
            bestType = type;
   128a0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   128a3:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   128a6:	8b 45 c8             	mov    -0x38(%ebp),%eax
   128a9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   128ac:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   128b0:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   128b4:	0f 85 02 ff ff ff    	jne    127bc <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   128ba:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   128bd:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   128c1:	89 c2                	mov    %eax,%edx
   128c3:	8b 45 0c             	mov    0xc(%ebp),%eax
   128c6:	01 d0                	add    %edx,%eax
   128c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   128cb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   128ce:	83 c0 01             	add    $0x1,%eax
   128d1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   128d5:	89 c2                	mov    %eax,%edx
   128d7:	8b 45 08             	mov    0x8(%ebp),%eax
   128da:	01 d0                	add    %edx,%eax
   128dc:	8b 55 cc             	mov    -0x34(%ebp),%edx
   128df:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   128e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   128e8:	eb 31                	jmp    1291b <filter+0x4d0>
   128ea:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   128ed:	83 c0 01             	add    $0x1,%eax
   128f0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   128f4:	89 c2                	mov    %eax,%edx
   128f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   128f9:	01 d0                	add    %edx,%eax
   128fb:	8d 50 01             	lea    0x1(%eax),%edx
   128fe:	8b 45 08             	mov    0x8(%ebp),%eax
   12901:	01 c2                	add    %eax,%edx
   12903:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12906:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   1290d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12910:	01 c8                	add    %ecx,%eax
   12912:	0f b6 00             	movzbl (%eax),%eax
   12915:	88 02                	mov    %al,(%edx)
   12917:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1291b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1291e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12921:	75 c7                	jne    128ea <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   12923:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12927:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1292a:	3b 45 14             	cmp    0x14(%ebp),%eax
   1292d:	0f 85 7d fe ff ff    	jne    127b0 <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12933:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   1293a:	eb 1a                	jmp    12956 <filter+0x50b>
   1293c:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1293f:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   12946:	83 ec 0c             	sub    $0xc,%esp
   12949:	50                   	push   %eax
   1294a:	e8 7d 15 ff ff       	call   3ecc <lodepng_free>
   1294f:	83 c4 10             	add    $0x10,%esp
   12952:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   12956:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   1295a:	75 e0                	jne    1293c <filter+0x4f1>
   1295c:	e9 c9 02 00 00       	jmp    12c2a <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   12961:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   12965:	0f 85 89 00 00 00    	jne    129f4 <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   1296b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12972:	eb 73                	jmp    129e7 <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   12974:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12977:	83 c0 01             	add    $0x1,%eax
   1297a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1297e:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   12981:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12984:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12988:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   1298b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1298e:	8b 50 30             	mov    0x30(%eax),%edx
   12991:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12994:	01 d0                	add    %edx,%eax
   12996:	0f b6 00             	movzbl (%eax),%eax
   12999:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   1299c:	8b 55 a8             	mov    -0x58(%ebp),%edx
   1299f:	8b 45 08             	mov    0x8(%ebp),%eax
   129a2:	01 c2                	add    %eax,%edx
   129a4:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   129a8:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   129aa:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   129ae:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   129b1:	8b 55 0c             	mov    0xc(%ebp),%edx
   129b4:	01 d1                	add    %edx,%ecx
   129b6:	8b 55 a8             	mov    -0x58(%ebp),%edx
   129b9:	8d 5a 01             	lea    0x1(%edx),%ebx
   129bc:	8b 55 08             	mov    0x8(%ebp),%edx
   129bf:	01 da                	add    %ebx,%edx
   129c1:	83 ec 08             	sub    $0x8,%esp
   129c4:	50                   	push   %eax
   129c5:	ff 75 b0             	pushl  -0x50(%ebp)
   129c8:	ff 75 b4             	pushl  -0x4c(%ebp)
   129cb:	ff 75 f4             	pushl  -0xc(%ebp)
   129ce:	51                   	push   %ecx
   129cf:	52                   	push   %edx
   129d0:	e8 6c f6 ff ff       	call   12041 <filterScanline>
   129d5:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   129d8:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   129db:	8b 45 0c             	mov    0xc(%ebp),%eax
   129de:	01 d0                	add    %edx,%eax
   129e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   129e3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   129e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   129ea:	3b 45 14             	cmp    0x14(%ebp),%eax
   129ed:	75 85                	jne    12974 <filter+0x529>
   129ef:	e9 36 02 00 00       	jmp    12c2a <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   129f4:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   129f8:	0f 85 25 02 00 00    	jne    12c23 <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   129fe:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   12a05:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12a0c:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   12a13:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a16:	83 ec 04             	sub    $0x4,%esp
   12a19:	6a 24                	push   $0x24
   12a1b:	50                   	push   %eax
   12a1c:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   12a22:	50                   	push   %eax
   12a23:	e8 c1 14 ff ff       	call   3ee9 <lodepng_memcpy>
   12a28:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   12a2b:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   12a32:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   12a35:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   12a3c:	00 00 00 
    zlibsettings.custom_deflate = 0;
   12a3f:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   12a46:	00 00 00 
    for(type = 0; type != 5; ++type) {
   12a49:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12a50:	eb 33                	jmp    12a85 <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   12a52:	83 ec 0c             	sub    $0xc,%esp
   12a55:	ff 75 b4             	pushl  -0x4c(%ebp)
   12a58:	e8 4e 14 ff ff       	call   3eab <lodepng_malloc>
   12a5d:	83 c4 10             	add    $0x10,%esp
   12a60:	89 c2                	mov    %eax,%edx
   12a62:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12a65:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   12a6c:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12a6f:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12a76:	85 c0                	test   %eax,%eax
   12a78:	75 07                	jne    12a81 <filter+0x636>
   12a7a:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   12a81:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12a85:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12a89:	75 c7                	jne    12a52 <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   12a8b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12a8f:	0f 85 63 01 00 00    	jne    12bf8 <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   12a95:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12a9c:	e9 4b 01 00 00       	jmp    12bec <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   12aa1:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12aa8:	e9 c8 00 00 00       	jmp    12b75 <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   12aad:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12ab0:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   12ab3:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12ab6:	0f b6 d0             	movzbl %al,%edx
   12ab9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12abc:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12ac0:	89 c1                	mov    %eax,%ecx
   12ac2:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ac5:	01 c1                	add    %eax,%ecx
   12ac7:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12aca:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12ad1:	83 ec 08             	sub    $0x8,%esp
   12ad4:	52                   	push   %edx
   12ad5:	ff 75 b0             	pushl  -0x50(%ebp)
   12ad8:	ff 75 b4             	pushl  -0x4c(%ebp)
   12adb:	ff 75 f4             	pushl  -0xc(%ebp)
   12ade:	51                   	push   %ecx
   12adf:	50                   	push   %eax
   12ae0:	e8 5c f5 ff ff       	call   12041 <filterScanline>
   12ae5:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   12ae8:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12aeb:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   12af2:	00 00 00 00 
          dummy = 0;
   12af6:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   12afd:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   12b00:	8b 55 ac             	mov    -0x54(%ebp),%edx
   12b03:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12b06:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12b0d:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   12b13:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   12b16:	c1 e3 02             	shl    $0x2,%ebx
   12b19:	01 cb                	add    %ecx,%ebx
   12b1b:	83 ec 0c             	sub    $0xc,%esp
   12b1e:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   12b24:	51                   	push   %ecx
   12b25:	52                   	push   %edx
   12b26:	50                   	push   %eax
   12b27:	53                   	push   %ebx
   12b28:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   12b2e:	50                   	push   %eax
   12b2f:	e8 87 60 ff ff       	call   8bbb <zlib_compress>
   12b34:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   12b37:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   12b3d:	83 ec 0c             	sub    $0xc,%esp
   12b40:	50                   	push   %eax
   12b41:	e8 86 13 ff ff       	call   3ecc <lodepng_free>
   12b46:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   12b49:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   12b4d:	74 0f                	je     12b5e <filter+0x713>
   12b4f:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12b52:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   12b59:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   12b5c:	7d 13                	jge    12b71 <filter+0x726>
            bestType = type;
   12b5e:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12b61:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   12b64:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12b67:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   12b6e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   12b71:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12b75:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12b79:	0f 85 2e ff ff ff    	jne    12aad <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   12b7f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12b82:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12b86:	89 c2                	mov    %eax,%edx
   12b88:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b8b:	01 d0                	add    %edx,%eax
   12b8d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   12b90:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12b93:	83 c0 01             	add    $0x1,%eax
   12b96:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12b9a:	89 c2                	mov    %eax,%edx
   12b9c:	8b 45 08             	mov    0x8(%ebp),%eax
   12b9f:	01 d0                	add    %edx,%eax
   12ba1:	8b 55 bc             	mov    -0x44(%ebp),%edx
   12ba4:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   12ba6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12bad:	eb 31                	jmp    12be0 <filter+0x795>
   12baf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12bb2:	83 c0 01             	add    $0x1,%eax
   12bb5:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12bb9:	89 c2                	mov    %eax,%edx
   12bbb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12bbe:	01 d0                	add    %edx,%eax
   12bc0:	8d 50 01             	lea    0x1(%eax),%edx
   12bc3:	8b 45 08             	mov    0x8(%ebp),%eax
   12bc6:	01 c2                	add    %eax,%edx
   12bc8:	8b 45 bc             	mov    -0x44(%ebp),%eax
   12bcb:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   12bd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12bd5:	01 c8                	add    %ecx,%eax
   12bd7:	0f b6 00             	movzbl (%eax),%eax
   12bda:	88 02                	mov    %al,(%edx)
   12bdc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12be0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12be3:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12be6:	75 c7                	jne    12baf <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   12be8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12bec:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12bef:	3b 45 14             	cmp    0x14(%ebp),%eax
   12bf2:	0f 85 a9 fe ff ff    	jne    12aa1 <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12bf8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12bff:	eb 1a                	jmp    12c1b <filter+0x7d0>
   12c01:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12c04:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12c0b:	83 ec 0c             	sub    $0xc,%esp
   12c0e:	50                   	push   %eax
   12c0f:	e8 b8 12 ff ff       	call   3ecc <lodepng_free>
   12c14:	83 c4 10             	add    $0x10,%esp
   12c17:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12c1b:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12c1f:	75 e0                	jne    12c01 <filter+0x7b6>
   12c21:	eb 07                	jmp    12c2a <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   12c23:	b8 58 00 00 00       	mov    $0x58,%eax
   12c28:	eb 03                	jmp    12c2d <filter+0x7e2>

  return error;
   12c2a:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   12c2d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12c30:	c9                   	leave  
   12c31:	c3                   	ret    

00012c32 <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   12c32:	55                   	push   %ebp
   12c33:	89 e5                	mov    %esp,%ebp
   12c35:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   12c38:	8b 45 10             	mov    0x10(%ebp),%eax
   12c3b:	2b 45 14             	sub    0x14(%ebp),%eax
   12c3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   12c41:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12c48:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   12c4f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12c56:	eb 65                	jmp    12cbd <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   12c58:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12c5f:	eb 2a                	jmp    12c8b <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   12c61:	ff 75 0c             	pushl  0xc(%ebp)
   12c64:	8d 45 e8             	lea    -0x18(%ebp),%eax
   12c67:	50                   	push   %eax
   12c68:	e8 9d 60 ff ff       	call   8d0a <readBitFromReversedStream>
   12c6d:	83 c4 08             	add    $0x8,%esp
   12c70:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   12c73:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   12c77:	50                   	push   %eax
   12c78:	ff 75 08             	pushl  0x8(%ebp)
   12c7b:	8d 45 ec             	lea    -0x14(%ebp),%eax
   12c7e:	50                   	push   %eax
   12c7f:	e8 08 61 ff ff       	call   8d8c <setBitOfReversedStream>
   12c84:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   12c87:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12c8b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12c8e:	3b 45 14             	cmp    0x14(%ebp),%eax
   12c91:	7c ce                	jl     12c61 <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   12c93:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12c9a:	eb 15                	jmp    12cb1 <addPaddingBits+0x7f>
   12c9c:	6a 00                	push   $0x0
   12c9e:	ff 75 08             	pushl  0x8(%ebp)
   12ca1:	8d 45 ec             	lea    -0x14(%ebp),%eax
   12ca4:	50                   	push   %eax
   12ca5:	e8 e2 60 ff ff       	call   8d8c <setBitOfReversedStream>
   12caa:	83 c4 0c             	add    $0xc,%esp
   12cad:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12cb1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12cb4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12cb7:	75 e3                	jne    12c9c <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   12cb9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12cbd:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12cc0:	3b 45 18             	cmp    0x18(%ebp),%eax
   12cc3:	75 93                	jne    12c58 <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   12cc5:	90                   	nop
   12cc6:	c9                   	leave  
   12cc7:	c3                   	ret    

00012cc8 <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   12cc8:	55                   	push   %ebp
   12cc9:	89 e5                	mov    %esp,%ebp
   12ccb:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   12cd1:	ff 75 18             	pushl  0x18(%ebp)
   12cd4:	ff 75 14             	pushl  0x14(%ebp)
   12cd7:	ff 75 10             	pushl  0x10(%ebp)
   12cda:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   12ce0:	50                   	push   %eax
   12ce1:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   12ce7:	50                   	push   %eax
   12ce8:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12cee:	50                   	push   %eax
   12cef:	8d 45 94             	lea    -0x6c(%ebp),%eax
   12cf2:	50                   	push   %eax
   12cf3:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12cf6:	50                   	push   %eax
   12cf7:	e8 fc ae ff ff       	call   dbf8 <Adam7_getpassvalues>
   12cfc:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   12cff:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   12d03:	0f 86 0a 01 00 00    	jbe    12e13 <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   12d09:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12d10:	e9 ef 00 00 00       	jmp    12e04 <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   12d15:	8b 45 18             	mov    0x18(%ebp),%eax
   12d18:	c1 e8 03             	shr    $0x3,%eax
   12d1b:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   12d1e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12d25:	e9 c6 00 00 00       	jmp    12df0 <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   12d2a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12d31:	e9 a6 00 00 00       	jmp    12ddc <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   12d36:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12d39:	8b 14 85 38 ac 01 00 	mov    0x1ac38(,%eax,4),%edx
   12d40:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12d43:	8b 04 85 70 ac 01 00 	mov    0x1ac70(,%eax,4),%eax
   12d4a:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   12d4e:	01 d0                	add    %edx,%eax
   12d50:	0f af 45 10          	imul   0x10(%ebp),%eax
   12d54:	89 c2                	mov    %eax,%edx
   12d56:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12d59:	8b 04 85 54 ac 01 00 	mov    0x1ac54(,%eax,4),%eax
   12d60:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   12d64:	01 c2                	add    %eax,%edx
   12d66:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12d69:	8b 04 85 1c ac 01 00 	mov    0x1ac1c(,%eax,4),%eax
   12d70:	01 c2                	add    %eax,%edx
   12d72:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12d75:	0f af c2             	imul   %edx,%eax
   12d78:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   12d7b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12d7e:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   12d85:	89 c1                	mov    %eax,%ecx
   12d87:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12d8a:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12d8e:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   12d92:	89 c2                	mov    %eax,%edx
   12d94:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12d97:	01 c2                	add    %eax,%edx
   12d99:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12d9c:	0f af c2             	imul   %edx,%eax
   12d9f:	01 c8                	add    %ecx,%eax
   12da1:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   12da4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12dab:	eb 23                	jmp    12dd0 <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   12dad:	8b 55 d8             	mov    -0x28(%ebp),%edx
   12db0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12db3:	01 c2                	add    %eax,%edx
   12db5:	8b 45 08             	mov    0x8(%ebp),%eax
   12db8:	01 c2                	add    %eax,%edx
   12dba:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   12dbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12dc0:	01 c1                	add    %eax,%ecx
   12dc2:	8b 45 0c             	mov    0xc(%ebp),%eax
   12dc5:	01 c8                	add    %ecx,%eax
   12dc7:	0f b6 00             	movzbl (%eax),%eax
   12dca:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   12dcc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12dd0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12dd3:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12dd6:	72 d5                	jb     12dad <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12dd8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12ddc:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12ddf:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12de3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   12de6:	0f 87 4a ff ff ff    	ja     12d36 <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   12dec:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12df0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12df3:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12df7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12dfa:	0f 87 2a ff ff ff    	ja     12d2a <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   12e00:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12e04:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12e08:	0f 85 07 ff ff ff    	jne    12d15 <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12e0e:	e9 22 01 00 00       	jmp    12f35 <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   12e13:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12e1a:	e9 0c 01 00 00       	jmp    12f2b <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   12e1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12e22:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12e26:	0f af 45 18          	imul   0x18(%ebp),%eax
   12e2a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   12e2d:	8b 45 18             	mov    0x18(%ebp),%eax
   12e30:	0f af 45 10          	imul   0x10(%ebp),%eax
   12e34:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   12e37:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   12e3e:	e9 d4 00 00 00       	jmp    12f17 <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   12e43:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12e4a:	e9 b4 00 00 00       	jmp    12f03 <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   12e4f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12e52:	8b 14 85 38 ac 01 00 	mov    0x1ac38(,%eax,4),%edx
   12e59:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12e5c:	8b 04 85 70 ac 01 00 	mov    0x1ac70(,%eax,4),%eax
   12e63:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   12e67:	01 d0                	add    %edx,%eax
   12e69:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   12e6d:	89 c2                	mov    %eax,%edx
   12e6f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12e72:	8b 0c 85 1c ac 01 00 	mov    0x1ac1c(,%eax,4),%ecx
   12e79:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12e7c:	8b 04 85 54 ac 01 00 	mov    0x1ac54(,%eax,4),%eax
   12e83:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12e87:	01 c8                	add    %ecx,%eax
   12e89:	0f af 45 18          	imul   0x18(%ebp),%eax
   12e8d:	01 d0                	add    %edx,%eax
   12e8f:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   12e95:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12e98:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   12e9f:	c1 e0 03             	shl    $0x3,%eax
   12ea2:	89 c1                	mov    %eax,%ecx
   12ea4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12ea7:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   12eab:	89 c2                	mov    %eax,%edx
   12ead:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12eb0:	0f af 45 18          	imul   0x18(%ebp),%eax
   12eb4:	01 d0                	add    %edx,%eax
   12eb6:	01 c8                	add    %ecx,%eax
   12eb8:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   12ebe:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   12ec5:	eb 30                	jmp    12ef7 <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   12ec7:	ff 75 0c             	pushl  0xc(%ebp)
   12eca:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   12ed0:	50                   	push   %eax
   12ed1:	e8 34 5e ff ff       	call   8d0a <readBitFromReversedStream>
   12ed6:	83 c4 08             	add    $0x8,%esp
   12ed9:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   12edc:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   12ee0:	50                   	push   %eax
   12ee1:	ff 75 08             	pushl  0x8(%ebp)
   12ee4:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   12eea:	50                   	push   %eax
   12eeb:	e8 9c 5e ff ff       	call   8d8c <setBitOfReversedStream>
   12ef0:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   12ef3:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   12ef7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12efa:	3b 45 18             	cmp    0x18(%ebp),%eax
   12efd:	72 c8                	jb     12ec7 <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12eff:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12f03:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12f06:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12f0a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   12f0d:	0f 87 3c ff ff ff    	ja     12e4f <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   12f13:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   12f17:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12f1a:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12f1e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   12f21:	0f 87 1c ff ff ff    	ja     12e43 <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   12f27:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12f2b:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12f2f:	0f 85 ea fe ff ff    	jne    12e1f <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12f35:	90                   	nop
   12f36:	c9                   	leave  
   12f37:	c3                   	ret    

00012f38 <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   12f38:	55                   	push   %ebp
   12f39:	89 e5                	mov    %esp,%ebp
   12f3b:	57                   	push   %edi
   12f3c:	56                   	push   %esi
   12f3d:	53                   	push   %ebx
   12f3e:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   12f44:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f47:	83 c0 0c             	add    $0xc,%eax
   12f4a:	50                   	push   %eax
   12f4b:	e8 77 6a ff ff       	call   99c7 <lodepng_get_bpp>
   12f50:	83 c4 04             	add    $0x4,%esp
   12f53:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   12f56:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   12f5d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f60:	8b 40 08             	mov    0x8(%eax),%eax
   12f63:	85 c0                	test   %eax,%eax
   12f65:	0f 85 49 01 00 00    	jne    130b4 <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   12f6b:	8b 45 14             	mov    0x14(%ebp),%eax
   12f6e:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12f72:	83 c0 07             	add    $0x7,%eax
   12f75:	c1 e8 03             	shr    $0x3,%eax
   12f78:	83 c0 01             	add    $0x1,%eax
   12f7b:	0f af 45 18          	imul   0x18(%ebp),%eax
   12f7f:	89 c2                	mov    %eax,%edx
   12f81:	8b 45 0c             	mov    0xc(%ebp),%eax
   12f84:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12f86:	8b 45 0c             	mov    0xc(%ebp),%eax
   12f89:	8b 00                	mov    (%eax),%eax
   12f8b:	83 ec 0c             	sub    $0xc,%esp
   12f8e:	50                   	push   %eax
   12f8f:	e8 17 0f ff ff       	call   3eab <lodepng_malloc>
   12f94:	83 c4 10             	add    $0x10,%esp
   12f97:	89 c2                	mov    %eax,%edx
   12f99:	8b 45 08             	mov    0x8(%ebp),%eax
   12f9c:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   12f9e:	8b 45 08             	mov    0x8(%ebp),%eax
   12fa1:	8b 00                	mov    (%eax),%eax
   12fa3:	85 c0                	test   %eax,%eax
   12fa5:	75 10                	jne    12fb7 <preProcessScanlines+0x7f>
   12fa7:	8b 45 0c             	mov    0xc(%ebp),%eax
   12faa:	8b 00                	mov    (%eax),%eax
   12fac:	85 c0                	test   %eax,%eax
   12fae:	74 07                	je     12fb7 <preProcessScanlines+0x7f>
   12fb0:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   12fb7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12fbb:	0f 85 fb 02 00 00    	jne    132bc <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   12fc1:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   12fc5:	0f 87 bd 00 00 00    	ja     13088 <preProcessScanlines+0x150>
   12fcb:	8b 45 14             	mov    0x14(%ebp),%eax
   12fce:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12fd2:	89 c2                	mov    %eax,%edx
   12fd4:	8b 45 14             	mov    0x14(%ebp),%eax
   12fd7:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12fdb:	83 c0 07             	add    $0x7,%eax
   12fde:	c1 e8 03             	shr    $0x3,%eax
   12fe1:	c1 e0 03             	shl    $0x3,%eax
   12fe4:	39 c2                	cmp    %eax,%edx
   12fe6:	0f 84 9c 00 00 00    	je     13088 <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   12fec:	8b 45 14             	mov    0x14(%ebp),%eax
   12fef:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12ff3:	83 c0 07             	add    $0x7,%eax
   12ff6:	c1 e8 03             	shr    $0x3,%eax
   12ff9:	0f af 45 18          	imul   0x18(%ebp),%eax
   12ffd:	83 ec 0c             	sub    $0xc,%esp
   13000:	50                   	push   %eax
   13001:	e8 a5 0e ff ff       	call   3eab <lodepng_malloc>
   13006:	83 c4 10             	add    $0x10,%esp
   13009:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   1300c:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   13010:	75 07                	jne    13019 <preProcessScanlines+0xe1>
   13012:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   13019:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1301d:	75 56                	jne    13075 <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   1301f:	8b 45 14             	mov    0x14(%ebp),%eax
   13022:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   13026:	89 c2                	mov    %eax,%edx
   13028:	8b 45 14             	mov    0x14(%ebp),%eax
   1302b:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1302f:	83 c0 07             	add    $0x7,%eax
   13032:	c1 e8 03             	shr    $0x3,%eax
   13035:	c1 e0 03             	shl    $0x3,%eax
   13038:	83 ec 0c             	sub    $0xc,%esp
   1303b:	ff 75 18             	pushl  0x18(%ebp)
   1303e:	52                   	push   %edx
   1303f:	50                   	push   %eax
   13040:	ff 75 10             	pushl  0x10(%ebp)
   13043:	ff 75 d8             	pushl  -0x28(%ebp)
   13046:	e8 e7 fb ff ff       	call   12c32 <addPaddingBits>
   1304b:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   1304e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13051:	8d 50 0c             	lea    0xc(%eax),%edx
   13054:	8b 45 08             	mov    0x8(%ebp),%eax
   13057:	8b 00                	mov    (%eax),%eax
   13059:	83 ec 08             	sub    $0x8,%esp
   1305c:	ff 75 20             	pushl  0x20(%ebp)
   1305f:	52                   	push   %edx
   13060:	ff 75 18             	pushl  0x18(%ebp)
   13063:	ff 75 14             	pushl  0x14(%ebp)
   13066:	ff 75 d8             	pushl  -0x28(%ebp)
   13069:	50                   	push   %eax
   1306a:	e8 dc f3 ff ff       	call   1244b <filter>
   1306f:	83 c4 20             	add    $0x20,%esp
   13072:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   13075:	83 ec 0c             	sub    $0xc,%esp
   13078:	ff 75 d8             	pushl  -0x28(%ebp)
   1307b:	e8 4c 0e ff ff       	call   3ecc <lodepng_free>
   13080:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   13083:	e9 34 02 00 00       	jmp    132bc <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   13088:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1308b:	8d 50 0c             	lea    0xc(%eax),%edx
   1308e:	8b 45 08             	mov    0x8(%ebp),%eax
   13091:	8b 00                	mov    (%eax),%eax
   13093:	83 ec 08             	sub    $0x8,%esp
   13096:	ff 75 20             	pushl  0x20(%ebp)
   13099:	52                   	push   %edx
   1309a:	ff 75 18             	pushl  0x18(%ebp)
   1309d:	ff 75 14             	pushl  0x14(%ebp)
   130a0:	ff 75 10             	pushl  0x10(%ebp)
   130a3:	50                   	push   %eax
   130a4:	e8 a2 f3 ff ff       	call   1244b <filter>
   130a9:	83 c4 20             	add    $0x20,%esp
   130ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   130af:	e9 08 02 00 00       	jmp    132bc <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   130b4:	ff 75 dc             	pushl  -0x24(%ebp)
   130b7:	ff 75 18             	pushl  0x18(%ebp)
   130ba:	ff 75 14             	pushl  0x14(%ebp)
   130bd:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   130c3:	50                   	push   %eax
   130c4:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   130ca:	50                   	push   %eax
   130cb:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   130d1:	50                   	push   %eax
   130d2:	8d 45 98             	lea    -0x68(%ebp),%eax
   130d5:	50                   	push   %eax
   130d6:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   130d9:	50                   	push   %eax
   130da:	e8 19 ab ff ff       	call   dbf8 <Adam7_getpassvalues>
   130df:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   130e2:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   130e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   130eb:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   130ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   130f0:	8b 00                	mov    (%eax),%eax
   130f2:	83 ec 0c             	sub    $0xc,%esp
   130f5:	50                   	push   %eax
   130f6:	e8 b0 0d ff ff       	call   3eab <lodepng_malloc>
   130fb:	83 c4 10             	add    $0x10,%esp
   130fe:	89 c2                	mov    %eax,%edx
   13100:	8b 45 08             	mov    0x8(%ebp),%eax
   13103:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   13105:	8b 45 08             	mov    0x8(%ebp),%eax
   13108:	8b 00                	mov    (%eax),%eax
   1310a:	85 c0                	test   %eax,%eax
   1310c:	75 07                	jne    13115 <preProcessScanlines+0x1dd>
   1310e:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   13115:	8b 45 94             	mov    -0x6c(%ebp),%eax
   13118:	83 ec 0c             	sub    $0xc,%esp
   1311b:	50                   	push   %eax
   1311c:	e8 8a 0d ff ff       	call   3eab <lodepng_malloc>
   13121:	83 c4 10             	add    $0x10,%esp
   13124:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   13127:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   1312b:	75 0e                	jne    1313b <preProcessScanlines+0x203>
   1312d:	8b 45 94             	mov    -0x6c(%ebp),%eax
   13130:	85 c0                	test   %eax,%eax
   13132:	74 07                	je     1313b <preProcessScanlines+0x203>
   13134:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   1313b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1313f:	0f 85 69 01 00 00    	jne    132ae <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   13145:	83 ec 0c             	sub    $0xc,%esp
   13148:	ff 75 dc             	pushl  -0x24(%ebp)
   1314b:	ff 75 18             	pushl  0x18(%ebp)
   1314e:	ff 75 14             	pushl  0x14(%ebp)
   13151:	ff 75 10             	pushl  0x10(%ebp)
   13154:	ff 75 d4             	pushl  -0x2c(%ebp)
   13157:	e8 6c fb ff ff       	call   12cc8 <Adam7_interlace>
   1315c:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   1315f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   13166:	e9 36 01 00 00       	jmp    132a1 <preProcessScanlines+0x369>
        if(bpp < 8) {
   1316b:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   1316f:	0f 87 d6 00 00 00    	ja     1324b <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   13175:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13178:	83 c0 01             	add    $0x1,%eax
   1317b:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   13182:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13185:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   1318c:	29 c2                	sub    %eax,%edx
   1318e:	89 d0                	mov    %edx,%eax
   13190:	83 ec 0c             	sub    $0xc,%esp
   13193:	50                   	push   %eax
   13194:	e8 12 0d ff ff       	call   3eab <lodepng_malloc>
   13199:	83 c4 10             	add    $0x10,%esp
   1319c:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   1319f:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   131a3:	75 0c                	jne    131b1 <preProcessScanlines+0x279>
   131a5:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   131ac:	e9 fd 00 00 00       	jmp    132ae <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   131b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   131b4:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   131b8:	8b 55 e0             	mov    -0x20(%ebp),%edx
   131bb:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   131bf:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   131c3:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   131c5:	8b 55 e0             	mov    -0x20(%ebp),%edx
   131c8:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   131cc:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   131d0:	83 c2 07             	add    $0x7,%edx
   131d3:	c1 ea 03             	shr    $0x3,%edx
   131d6:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   131d9:	89 d1                	mov    %edx,%ecx
   131db:	8b 55 e0             	mov    -0x20(%ebp),%edx
   131de:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   131e5:	89 d6                	mov    %edx,%esi
   131e7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   131ea:	01 f2                	add    %esi,%edx
   131ec:	83 ec 0c             	sub    $0xc,%esp
   131ef:	50                   	push   %eax
   131f0:	53                   	push   %ebx
   131f1:	51                   	push   %ecx
   131f2:	52                   	push   %edx
   131f3:	ff 75 d0             	pushl  -0x30(%ebp)
   131f6:	e8 37 fa ff ff       	call   12c32 <addPaddingBits>
   131fb:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   131fe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13201:	8d 58 0c             	lea    0xc(%eax),%ebx
   13204:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13207:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   1320b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1320e:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   13212:	8b 4d 08             	mov    0x8(%ebp),%ecx
   13215:	8b 31                	mov    (%ecx),%esi
   13217:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1321a:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   13221:	01 f1                	add    %esi,%ecx
   13223:	83 ec 08             	sub    $0x8,%esp
   13226:	ff 75 20             	pushl  0x20(%ebp)
   13229:	53                   	push   %ebx
   1322a:	52                   	push   %edx
   1322b:	50                   	push   %eax
   1322c:	ff 75 d0             	pushl  -0x30(%ebp)
   1322f:	51                   	push   %ecx
   13230:	e8 16 f2 ff ff       	call   1244b <filter>
   13235:	83 c4 20             	add    $0x20,%esp
   13238:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   1323b:	83 ec 0c             	sub    $0xc,%esp
   1323e:	ff 75 d0             	pushl  -0x30(%ebp)
   13241:	e8 86 0c ff ff       	call   3ecc <lodepng_free>
   13246:	83 c4 10             	add    $0x10,%esp
   13249:	eb 4c                	jmp    13297 <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   1324b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1324e:	8d 70 0c             	lea    0xc(%eax),%esi
   13251:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13254:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   13258:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1325b:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   1325f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   13262:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   13269:	89 cb                	mov    %ecx,%ebx
   1326b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   1326e:	01 cb                	add    %ecx,%ebx
   13270:	8b 4d 08             	mov    0x8(%ebp),%ecx
   13273:	8b 39                	mov    (%ecx),%edi
   13275:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   13278:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   1327f:	01 f9                	add    %edi,%ecx
   13281:	83 ec 08             	sub    $0x8,%esp
   13284:	ff 75 20             	pushl  0x20(%ebp)
   13287:	56                   	push   %esi
   13288:	52                   	push   %edx
   13289:	50                   	push   %eax
   1328a:	53                   	push   %ebx
   1328b:	51                   	push   %ecx
   1328c:	e8 ba f1 ff ff       	call   1244b <filter>
   13291:	83 c4 20             	add    $0x20,%esp
   13294:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   13297:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1329b:	75 10                	jne    132ad <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   1329d:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   132a1:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   132a5:	0f 85 c0 fe ff ff    	jne    1316b <preProcessScanlines+0x233>
   132ab:	eb 01                	jmp    132ae <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   132ad:	90                   	nop
      }
    }

    lodepng_free(adam7);
   132ae:	83 ec 0c             	sub    $0xc,%esp
   132b1:	ff 75 d4             	pushl  -0x2c(%ebp)
   132b4:	e8 13 0c ff ff       	call   3ecc <lodepng_free>
   132b9:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   132bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   132bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
   132c2:	5b                   	pop    %ebx
   132c3:	5e                   	pop    %esi
   132c4:	5f                   	pop    %edi
   132c5:	5d                   	pop    %ebp
   132c6:	c3                   	ret    

000132c7 <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   132c7:	55                   	push   %ebp
   132c8:	89 e5                	mov    %esp,%ebp
   132ca:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   132cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   132d0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   132d3:	eb 47                	jmp    1331c <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   132d5:	8b 45 08             	mov    0x8(%ebp),%eax
   132d8:	8d 50 04             	lea    0x4(%eax),%edx
   132db:	8b 45 08             	mov    0x8(%ebp),%eax
   132de:	ff 75 fc             	pushl  -0x4(%ebp)
   132e1:	52                   	push   %edx
   132e2:	50                   	push   %eax
   132e3:	e8 73 5f ff ff       	call   925b <lodepng_chunk_append>
   132e8:	83 c4 0c             	add    $0xc,%esp
   132eb:	89 45 f8             	mov    %eax,-0x8(%ebp)
   132ee:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   132f2:	74 05                	je     132f9 <addUnknownChunks+0x32>
   132f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   132f7:	eb 37                	jmp    13330 <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   132f9:	8b 45 08             	mov    0x8(%ebp),%eax
   132fc:	8b 50 04             	mov    0x4(%eax),%edx
   132ff:	8b 45 08             	mov    0x8(%ebp),%eax
   13302:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   13305:	8b 55 10             	mov    0x10(%ebp),%edx
   13308:	8b 45 0c             	mov    0xc(%ebp),%eax
   1330b:	01 d0                	add    %edx,%eax
   1330d:	50                   	push   %eax
   1330e:	ff 75 fc             	pushl  -0x4(%ebp)
   13311:	e8 ff 5c ff ff       	call   9015 <lodepng_chunk_next>
   13316:	83 c4 08             	add    $0x8,%esp
   13319:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   1331c:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1331f:	8b 45 0c             	mov    0xc(%ebp),%eax
   13322:	29 c2                	sub    %eax,%edx
   13324:	89 d0                	mov    %edx,%eax
   13326:	3b 45 10             	cmp    0x10(%ebp),%eax
   13329:	7c aa                	jl     132d5 <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   1332b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13330:	c9                   	leave  
   13331:	c3                   	ret    

00013332 <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   13332:	55                   	push   %ebp
   13333:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   13335:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   13339:	77 07                	ja     13342 <isGrayICCProfile+0x10>
   1333b:	b8 00 00 00 00       	mov    $0x0,%eax
   13340:	eb 40                	jmp    13382 <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   13342:	8b 45 08             	mov    0x8(%ebp),%eax
   13345:	83 c0 10             	add    $0x10,%eax
   13348:	0f b6 00             	movzbl (%eax),%eax
   1334b:	3c 47                	cmp    $0x47,%al
   1334d:	75 2e                	jne    1337d <isGrayICCProfile+0x4b>
   1334f:	8b 45 08             	mov    0x8(%ebp),%eax
   13352:	83 c0 11             	add    $0x11,%eax
   13355:	0f b6 00             	movzbl (%eax),%eax
   13358:	3c 52                	cmp    $0x52,%al
   1335a:	75 21                	jne    1337d <isGrayICCProfile+0x4b>
   1335c:	8b 45 08             	mov    0x8(%ebp),%eax
   1335f:	83 c0 12             	add    $0x12,%eax
   13362:	0f b6 00             	movzbl (%eax),%eax
   13365:	3c 41                	cmp    $0x41,%al
   13367:	75 14                	jne    1337d <isGrayICCProfile+0x4b>
   13369:	8b 45 08             	mov    0x8(%ebp),%eax
   1336c:	83 c0 13             	add    $0x13,%eax
   1336f:	0f b6 00             	movzbl (%eax),%eax
   13372:	3c 59                	cmp    $0x59,%al
   13374:	75 07                	jne    1337d <isGrayICCProfile+0x4b>
   13376:	b8 01 00 00 00       	mov    $0x1,%eax
   1337b:	eb 05                	jmp    13382 <isGrayICCProfile+0x50>
   1337d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13382:	5d                   	pop    %ebp
   13383:	c3                   	ret    

00013384 <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   13384:	55                   	push   %ebp
   13385:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   13387:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   1338b:	77 07                	ja     13394 <isRGBICCProfile+0x10>
   1338d:	b8 00 00 00 00       	mov    $0x0,%eax
   13392:	eb 40                	jmp    133d4 <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   13394:	8b 45 08             	mov    0x8(%ebp),%eax
   13397:	83 c0 10             	add    $0x10,%eax
   1339a:	0f b6 00             	movzbl (%eax),%eax
   1339d:	3c 52                	cmp    $0x52,%al
   1339f:	75 2e                	jne    133cf <isRGBICCProfile+0x4b>
   133a1:	8b 45 08             	mov    0x8(%ebp),%eax
   133a4:	83 c0 11             	add    $0x11,%eax
   133a7:	0f b6 00             	movzbl (%eax),%eax
   133aa:	3c 47                	cmp    $0x47,%al
   133ac:	75 21                	jne    133cf <isRGBICCProfile+0x4b>
   133ae:	8b 45 08             	mov    0x8(%ebp),%eax
   133b1:	83 c0 12             	add    $0x12,%eax
   133b4:	0f b6 00             	movzbl (%eax),%eax
   133b7:	3c 42                	cmp    $0x42,%al
   133b9:	75 14                	jne    133cf <isRGBICCProfile+0x4b>
   133bb:	8b 45 08             	mov    0x8(%ebp),%eax
   133be:	83 c0 13             	add    $0x13,%eax
   133c1:	0f b6 00             	movzbl (%eax),%eax
   133c4:	3c 20                	cmp    $0x20,%al
   133c6:	75 07                	jne    133cf <isRGBICCProfile+0x4b>
   133c8:	b8 01 00 00 00       	mov    $0x1,%eax
   133cd:	eb 05                	jmp    133d4 <isRGBICCProfile+0x50>
   133cf:	b8 00 00 00 00       	mov    $0x0,%eax
}
   133d4:	5d                   	pop    %ebp
   133d5:	c3                   	ret    

000133d6 <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   133d6:	55                   	push   %ebp
   133d7:	89 e5                	mov    %esp,%ebp
   133d9:	57                   	push   %edi
   133da:	56                   	push   %esi
   133db:	53                   	push   %ebx
   133dc:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   133e2:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   133e9:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   133f0:	8d 45 b0             	lea    -0x50(%ebp),%eax
   133f3:	6a 00                	push   $0x0
   133f5:	6a 00                	push   $0x0
   133f7:	50                   	push   %eax
   133f8:	e8 6f 0d ff ff       	call   416c <ucvector_init>
   133fd:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   13400:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13403:	05 98 00 00 00       	add    $0x98,%eax
   13408:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   1340b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13411:	50                   	push   %eax
   13412:	e8 3a 71 ff ff       	call   a551 <lodepng_info_init>
   13417:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   1341a:	8b 45 08             	mov    0x8(%ebp),%eax
   1341d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   13423:	8b 45 0c             	mov    0xc(%ebp),%eax
   13426:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   1342c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1342f:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   13436:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   13439:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1343c:	8b 40 0c             	mov    0xc(%eax),%eax
   1343f:	83 f8 03             	cmp    $0x3,%eax
   13442:	74 0a                	je     1344e <lodepng_encode+0x78>
   13444:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13447:	8b 40 6c             	mov    0x6c(%eax),%eax
   1344a:	85 c0                	test   %eax,%eax
   1344c:	74 29                	je     13477 <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   1344e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13451:	8b 40 18             	mov    0x18(%eax),%eax
   13454:	85 c0                	test   %eax,%eax
   13456:	74 0d                	je     13465 <lodepng_encode+0x8f>
   13458:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1345b:	8b 40 18             	mov    0x18(%eax),%eax
   1345e:	3d 00 01 00 00       	cmp    $0x100,%eax
   13463:	7e 12                	jle    13477 <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   13465:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13468:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   1346f:	00 00 00 
    goto cleanup;
   13472:	e9 78 0c 00 00       	jmp    140ef <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   13477:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1347a:	8b 40 38             	mov    0x38(%eax),%eax
   1347d:	83 f8 02             	cmp    $0x2,%eax
   13480:	76 12                	jbe    13494 <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   13482:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13485:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   1348c:	00 00 00 
    goto cleanup;
   1348f:	e9 5b 0c 00 00       	jmp    140ef <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   13494:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13497:	8b 40 08             	mov    0x8(%eax),%eax
   1349a:	83 f8 01             	cmp    $0x1,%eax
   1349d:	76 12                	jbe    134b1 <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   1349f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134a2:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   134a9:	00 00 00 
    goto cleanup;
   134ac:	e9 3e 0c 00 00       	jmp    140ef <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   134b1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   134b4:	8b 50 10             	mov    0x10(%eax),%edx
   134b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   134ba:	8b 40 0c             	mov    0xc(%eax),%eax
   134bd:	52                   	push   %edx
   134be:	50                   	push   %eax
   134bf:	e8 a4 5f ff ff       	call   9468 <checkColorValidity>
   134c4:	83 c4 08             	add    $0x8,%esp
   134c7:	89 c2                	mov    %eax,%edx
   134c9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134cc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   134d2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134d5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134db:	85 c0                	test   %eax,%eax
   134dd:	0f 85 c6 0b 00 00    	jne    140a9 <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   134e3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134e6:	8b 50 7c             	mov    0x7c(%eax),%edx
   134e9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134ec:	8b 40 78             	mov    0x78(%eax),%eax
   134ef:	52                   	push   %edx
   134f0:	50                   	push   %eax
   134f1:	e8 72 5f ff ff       	call   9468 <checkColorValidity>
   134f6:	83 c4 08             	add    $0x8,%esp
   134f9:	89 c2                	mov    %eax,%edx
   134fb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134fe:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13504:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13507:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1350d:	85 c0                	test   %eax,%eax
   1350f:	0f 85 97 0b 00 00    	jne    140ac <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   13515:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13518:	05 98 00 00 00       	add    $0x98,%eax
   1351d:	83 ec 08             	sub    $0x8,%esp
   13520:	50                   	push   %eax
   13521:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13527:	50                   	push   %eax
   13528:	e8 58 71 ff ff       	call   a685 <lodepng_info_copy>
   1352d:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   13530:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13533:	8b 40 5c             	mov    0x5c(%eax),%eax
   13536:	85 c0                	test   %eax,%eax
   13538:	0f 84 3c 02 00 00    	je     1377a <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   1353e:	83 ec 0c             	sub    $0xc,%esp
   13541:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   13547:	50                   	push   %eax
   13548:	e8 5f 96 ff ff       	call   cbac <lodepng_color_stats_init>
   1354d:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   13550:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13553:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   13559:	85 c0                	test   %eax,%eax
   1355b:	74 2d                	je     1358a <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   1355d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13560:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   13566:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13569:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   1356f:	83 ec 08             	sub    $0x8,%esp
   13572:	52                   	push   %edx
   13573:	50                   	push   %eax
   13574:	e8 b9 fd ff ff       	call   13332 <isGrayICCProfile>
   13579:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   1357c:	85 c0                	test   %eax,%eax
   1357e:	74 0a                	je     1358a <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   13580:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   13587:	00 00 00 
    }
    if(info_png->iccp_defined &&
   1358a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1358d:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   13593:	85 c0                	test   %eax,%eax
   13595:	74 2d                	je     135c4 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   13597:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1359a:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   135a0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   135a3:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   135a9:	83 ec 08             	sub    $0x8,%esp
   135ac:	52                   	push   %edx
   135ad:	50                   	push   %eax
   135ae:	e8 d1 fd ff ff       	call   13384 <isRGBICCProfile>
   135b3:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   135b6:	85 c0                	test   %eax,%eax
   135b8:	74 0a                	je     135c4 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   135ba:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   135c1:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   135c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135c7:	83 c0 78             	add    $0x78,%eax
   135ca:	83 ec 0c             	sub    $0xc,%esp
   135cd:	50                   	push   %eax
   135ce:	ff 75 18             	pushl  0x18(%ebp)
   135d1:	ff 75 14             	pushl  0x14(%ebp)
   135d4:	ff 75 10             	pushl  0x10(%ebp)
   135d7:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   135dd:	50                   	push   %eax
   135de:	e8 e0 96 ff ff       	call   ccc3 <lodepng_compute_color_stats>
   135e3:	83 c4 20             	add    $0x20,%esp
   135e6:	89 c2                	mov    %eax,%edx
   135e8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135eb:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   135f1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135f4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   135fa:	85 c0                	test   %eax,%eax
   135fc:	0f 85 ad 0a 00 00    	jne    140af <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   13602:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13605:	8b 40 2c             	mov    0x2c(%eax),%eax
   13608:	85 c0                	test   %eax,%eax
   1360a:	0f 84 be 00 00 00    	je     136ce <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   13610:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   13617:	00 00 00 
   1361a:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   13621:	00 00 00 
   13624:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   1362b:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   1362e:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   13634:	83 ec 04             	sub    $0x4,%esp
   13637:	6a 10                	push   $0x10
   13639:	6a 02                	push   $0x2
   1363b:	50                   	push   %eax
   1363c:	e8 15 61 ff ff       	call   9756 <lodepng_color_mode_make>
   13641:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   13644:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13647:	8d 58 0c             	lea    0xc(%eax),%ebx
   1364a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1364d:	8b 48 38             	mov    0x38(%eax),%ecx
   13650:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13653:	8b 50 34             	mov    0x34(%eax),%edx
   13656:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13659:	8b 40 30             	mov    0x30(%eax),%eax
   1365c:	53                   	push   %ebx
   1365d:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   13663:	53                   	push   %ebx
   13664:	51                   	push   %ecx
   13665:	52                   	push   %edx
   13666:	50                   	push   %eax
   13667:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   1366d:	50                   	push   %eax
   1366e:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   13674:	50                   	push   %eax
   13675:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   1367b:	50                   	push   %eax
   1367c:	e8 8a 92 ff ff       	call   c90b <lodepng_convert_rgb>
   13681:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   13684:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   1368a:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   13690:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   13696:	83 ec 0c             	sub    $0xc,%esp
   13699:	68 ff ff 00 00       	push   $0xffff
   1369e:	51                   	push   %ecx
   1369f:	52                   	push   %edx
   136a0:	50                   	push   %eax
   136a1:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   136a7:	50                   	push   %eax
   136a8:	e8 26 a1 ff ff       	call   d7d3 <lodepng_color_stats_add>
   136ad:	83 c4 20             	add    $0x20,%esp
   136b0:	89 c2                	mov    %eax,%edx
   136b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136b5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   136bb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136be:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   136c4:	85 c0                	test   %eax,%eax
   136c6:	74 06                	je     136ce <lodepng_encode+0x2f8>
   136c8:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   136c9:	e9 e1 09 00 00       	jmp    140af <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   136ce:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136d1:	8d 50 78             	lea    0x78(%eax),%edx
   136d4:	83 ec 04             	sub    $0x4,%esp
   136d7:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   136dd:	50                   	push   %eax
   136de:	52                   	push   %edx
   136df:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   136e5:	83 c0 0c             	add    $0xc,%eax
   136e8:	50                   	push   %eax
   136e9:	e8 79 a1 ff ff       	call   d867 <auto_choose_color>
   136ee:	83 c4 10             	add    $0x10,%esp
   136f1:	89 c2                	mov    %eax,%edx
   136f3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136f6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   136fc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136ff:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13705:	85 c0                	test   %eax,%eax
   13707:	0f 85 a5 09 00 00    	jne    140b2 <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   1370d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13710:	8b 40 2c             	mov    0x2c(%eax),%eax
   13713:	85 c0                	test   %eax,%eax
   13715:	74 63                	je     1377a <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   13717:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1371a:	8d 58 0c             	lea    0xc(%eax),%ebx
   1371d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13720:	8b 48 38             	mov    0x38(%eax),%ecx
   13723:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13726:	8b 50 34             	mov    0x34(%eax),%edx
   13729:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1372c:	8b 40 30             	mov    0x30(%eax),%eax
   1372f:	53                   	push   %ebx
   13730:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   13736:	83 c3 0c             	add    $0xc,%ebx
   13739:	53                   	push   %ebx
   1373a:	51                   	push   %ecx
   1373b:	52                   	push   %edx
   1373c:	50                   	push   %eax
   1373d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13743:	83 c0 38             	add    $0x38,%eax
   13746:	50                   	push   %eax
   13747:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1374d:	83 c0 34             	add    $0x34,%eax
   13750:	50                   	push   %eax
   13751:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13757:	83 c0 30             	add    $0x30,%eax
   1375a:	50                   	push   %eax
   1375b:	e8 ab 91 ff ff       	call   c90b <lodepng_convert_rgb>
   13760:	83 c4 20             	add    $0x20,%esp
   13763:	85 c0                	test   %eax,%eax
   13765:	74 13                	je     1377a <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   13767:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1376a:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   13771:	00 00 00 
        goto cleanup;
   13774:	90                   	nop
   13775:	e9 75 09 00 00       	jmp    140ef <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   1377a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1377d:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   13783:	85 c0                	test   %eax,%eax
   13785:	0f 84 b2 00 00 00    	je     1383d <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   1378b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1378e:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   13794:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13797:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   1379d:	83 ec 08             	sub    $0x8,%esp
   137a0:	52                   	push   %edx
   137a1:	50                   	push   %eax
   137a2:	e8 8b fb ff ff       	call   13332 <isGrayICCProfile>
   137a7:	83 c4 10             	add    $0x10,%esp
   137aa:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   137ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
   137b0:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   137b6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   137b9:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   137bf:	83 ec 08             	sub    $0x8,%esp
   137c2:	52                   	push   %edx
   137c3:	50                   	push   %eax
   137c4:	e8 bb fb ff ff       	call   13384 <isRGBICCProfile>
   137c9:	83 c4 10             	add    $0x10,%esp
   137cc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   137cf:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   137d5:	85 c0                	test   %eax,%eax
   137d7:	74 0b                	je     137e4 <lodepng_encode+0x40e>
   137d9:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   137df:	83 f8 04             	cmp    $0x4,%eax
   137e2:	75 07                	jne    137eb <lodepng_encode+0x415>
   137e4:	b8 01 00 00 00       	mov    $0x1,%eax
   137e9:	eb 05                	jmp    137f0 <lodepng_encode+0x41a>
   137eb:	b8 00 00 00 00       	mov    $0x0,%eax
   137f0:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   137f3:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   137f7:	75 18                	jne    13811 <lodepng_encode+0x43b>
   137f9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   137fd:	75 12                	jne    13811 <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   137ff:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13802:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   13809:	00 00 00 
      goto cleanup;
   1380c:	e9 de 08 00 00       	jmp    140ef <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   13811:	8b 45 d8             	mov    -0x28(%ebp),%eax
   13814:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   13817:	74 24                	je     1383d <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   13819:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1381c:	8b 40 5c             	mov    0x5c(%eax),%eax
   1381f:	85 c0                	test   %eax,%eax
   13821:	74 07                	je     1382a <lodepng_encode+0x454>
   13823:	ba 66 00 00 00       	mov    $0x66,%edx
   13828:	eb 05                	jmp    1382f <lodepng_encode+0x459>
   1382a:	ba 65 00 00 00       	mov    $0x65,%edx
   1382f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13832:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   13838:	e9 b2 08 00 00       	jmp    140ef <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   1383d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13840:	83 c0 78             	add    $0x78,%eax
   13843:	83 ec 08             	sub    $0x8,%esp
   13846:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   1384c:	83 c2 0c             	add    $0xc,%edx
   1384f:	52                   	push   %edx
   13850:	50                   	push   %eax
   13851:	e8 57 5f ff ff       	call   97ad <lodepng_color_mode_equal>
   13856:	83 c4 10             	add    $0x10,%esp
   13859:	85 c0                	test   %eax,%eax
   1385b:	0f 85 f8 00 00 00    	jne    13959 <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   13861:	8b 55 14             	mov    0x14(%ebp),%edx
   13864:	8b 45 18             	mov    0x18(%ebp),%eax
   13867:	89 d3                	mov    %edx,%ebx
   13869:	0f af d8             	imul   %eax,%ebx
   1386c:	83 ec 0c             	sub    $0xc,%esp
   1386f:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13875:	83 c0 0c             	add    $0xc,%eax
   13878:	50                   	push   %eax
   13879:	e8 49 61 ff ff       	call   99c7 <lodepng_get_bpp>
   1387e:	83 c4 10             	add    $0x10,%esp
   13881:	0f af c3             	imul   %ebx,%eax
   13884:	83 c0 07             	add    $0x7,%eax
   13887:	c1 e8 03             	shr    $0x3,%eax
   1388a:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   1388d:	83 ec 0c             	sub    $0xc,%esp
   13890:	ff 75 cc             	pushl  -0x34(%ebp)
   13893:	e8 13 06 ff ff       	call   3eab <lodepng_malloc>
   13898:	83 c4 10             	add    $0x10,%esp
   1389b:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   1389e:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   138a2:	75 13                	jne    138b7 <lodepng_encode+0x4e1>
   138a4:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   138a8:	74 0d                	je     138b7 <lodepng_encode+0x4e1>
   138aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   138ad:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   138b4:	00 00 00 
    if(!state->error) {
   138b7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   138ba:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   138c0:	85 c0                	test   %eax,%eax
   138c2:	75 33                	jne    138f7 <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   138c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   138c7:	83 c0 78             	add    $0x78,%eax
   138ca:	83 ec 08             	sub    $0x8,%esp
   138cd:	ff 75 18             	pushl  0x18(%ebp)
   138d0:	ff 75 14             	pushl  0x14(%ebp)
   138d3:	50                   	push   %eax
   138d4:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   138da:	83 c0 0c             	add    $0xc,%eax
   138dd:	50                   	push   %eax
   138de:	ff 75 10             	pushl  0x10(%ebp)
   138e1:	ff 75 c8             	pushl  -0x38(%ebp)
   138e4:	e8 c9 8c ff ff       	call   c5b2 <lodepng_convert>
   138e9:	83 c4 20             	add    $0x20,%esp
   138ec:	89 c2                	mov    %eax,%edx
   138ee:	8b 45 1c             	mov    0x1c(%ebp),%eax
   138f1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   138f7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   138fa:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13900:	85 c0                	test   %eax,%eax
   13902:	75 35                	jne    13939 <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   13904:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13907:	83 c0 38             	add    $0x38,%eax
   1390a:	83 ec 04             	sub    $0x4,%esp
   1390d:	50                   	push   %eax
   1390e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13914:	50                   	push   %eax
   13915:	ff 75 18             	pushl  0x18(%ebp)
   13918:	ff 75 14             	pushl  0x14(%ebp)
   1391b:	ff 75 c8             	pushl  -0x38(%ebp)
   1391e:	8d 45 bc             	lea    -0x44(%ebp),%eax
   13921:	50                   	push   %eax
   13922:	8d 45 c0             	lea    -0x40(%ebp),%eax
   13925:	50                   	push   %eax
   13926:	e8 0d f6 ff ff       	call   12f38 <preProcessScanlines>
   1392b:	83 c4 20             	add    $0x20,%esp
   1392e:	89 c2                	mov    %eax,%edx
   13930:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13933:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   13939:	83 ec 0c             	sub    $0xc,%esp
   1393c:	ff 75 c8             	pushl  -0x38(%ebp)
   1393f:	e8 88 05 ff ff       	call   3ecc <lodepng_free>
   13944:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   13947:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1394a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13950:	85 c0                	test   %eax,%eax
   13952:	74 4b                	je     1399f <lodepng_encode+0x5c9>
   13954:	e9 96 07 00 00       	jmp    140ef <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   13959:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1395c:	83 c0 38             	add    $0x38,%eax
   1395f:	83 ec 04             	sub    $0x4,%esp
   13962:	50                   	push   %eax
   13963:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13969:	50                   	push   %eax
   1396a:	ff 75 18             	pushl  0x18(%ebp)
   1396d:	ff 75 14             	pushl  0x14(%ebp)
   13970:	ff 75 10             	pushl  0x10(%ebp)
   13973:	8d 45 bc             	lea    -0x44(%ebp),%eax
   13976:	50                   	push   %eax
   13977:	8d 45 c0             	lea    -0x40(%ebp),%eax
   1397a:	50                   	push   %eax
   1397b:	e8 b8 f5 ff ff       	call   12f38 <preProcessScanlines>
   13980:	83 c4 20             	add    $0x20,%esp
   13983:	89 c2                	mov    %eax,%edx
   13985:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13988:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1398e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13991:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13997:	85 c0                	test   %eax,%eax
   13999:	0f 85 16 07 00 00    	jne    140b5 <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   1399f:	83 ec 0c             	sub    $0xc,%esp
   139a2:	8d 45 b0             	lea    -0x50(%ebp),%eax
   139a5:	50                   	push   %eax
   139a6:	e8 21 d9 ff ff       	call   112cc <writeSignature>
   139ab:	83 c4 10             	add    $0x10,%esp
   139ae:	89 c2                	mov    %eax,%edx
   139b0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   139b3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   139b9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   139bc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   139c2:	85 c0                	test   %eax,%eax
   139c4:	0f 85 ee 06 00 00    	jne    140b8 <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   139ca:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   139d0:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   139d6:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   139dc:	83 ec 08             	sub    $0x8,%esp
   139df:	51                   	push   %ecx
   139e0:	52                   	push   %edx
   139e1:	50                   	push   %eax
   139e2:	ff 75 18             	pushl  0x18(%ebp)
   139e5:	ff 75 14             	pushl  0x14(%ebp)
   139e8:	8d 45 b0             	lea    -0x50(%ebp),%eax
   139eb:	50                   	push   %eax
   139ec:	e8 4a d9 ff ff       	call   1133b <addChunk_IHDR>
   139f1:	83 c4 20             	add    $0x20,%esp
   139f4:	89 c2                	mov    %eax,%edx
   139f6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   139f9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   139ff:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a02:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13a08:	85 c0                	test   %eax,%eax
   13a0a:	0f 85 ab 06 00 00    	jne    140bb <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   13a10:	8b 45 98             	mov    -0x68(%ebp),%eax
   13a13:	85 c0                	test   %eax,%eax
   13a15:	74 33                	je     13a4a <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   13a17:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   13a1a:	8b 45 98             	mov    -0x68(%ebp),%eax
   13a1d:	83 ec 04             	sub    $0x4,%esp
   13a20:	52                   	push   %edx
   13a21:	50                   	push   %eax
   13a22:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13a25:	50                   	push   %eax
   13a26:	e8 9c f8 ff ff       	call   132c7 <addUnknownChunks>
   13a2b:	83 c4 10             	add    $0x10,%esp
   13a2e:	89 c2                	mov    %eax,%edx
   13a30:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a33:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13a39:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a3c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13a42:	85 c0                	test   %eax,%eax
   13a44:	0f 85 74 06 00 00    	jne    140be <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   13a4a:	8b 45 88             	mov    -0x78(%ebp),%eax
   13a4d:	85 c0                	test   %eax,%eax
   13a4f:	74 39                	je     13a8a <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   13a51:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a54:	83 c0 38             	add    $0x38,%eax
   13a57:	83 ec 04             	sub    $0x4,%esp
   13a5a:	50                   	push   %eax
   13a5b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13a61:	50                   	push   %eax
   13a62:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13a65:	50                   	push   %eax
   13a66:	e8 a4 e4 ff ff       	call   11f0f <addChunk_iCCP>
   13a6b:	83 c4 10             	add    $0x10,%esp
   13a6e:	89 c2                	mov    %eax,%edx
   13a70:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a73:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13a79:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a7c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13a82:	85 c0                	test   %eax,%eax
   13a84:	0f 85 37 06 00 00    	jne    140c1 <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   13a8a:	8b 45 80             	mov    -0x80(%ebp),%eax
   13a8d:	85 c0                	test   %eax,%eax
   13a8f:	74 32                	je     13ac3 <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   13a91:	83 ec 08             	sub    $0x8,%esp
   13a94:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13a9a:	50                   	push   %eax
   13a9b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13a9e:	50                   	push   %eax
   13a9f:	e8 41 e4 ff ff       	call   11ee5 <addChunk_sRGB>
   13aa4:	83 c4 10             	add    $0x10,%esp
   13aa7:	89 c2                	mov    %eax,%edx
   13aa9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13aac:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13ab2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13ab5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13abb:	85 c0                	test   %eax,%eax
   13abd:	0f 85 01 06 00 00    	jne    140c4 <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   13ac3:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   13ac9:	85 c0                	test   %eax,%eax
   13acb:	74 32                	je     13aff <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   13acd:	83 ec 08             	sub    $0x8,%esp
   13ad0:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13ad6:	50                   	push   %eax
   13ad7:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13ada:	50                   	push   %eax
   13adb:	e8 a7 e2 ff ff       	call   11d87 <addChunk_gAMA>
   13ae0:	83 c4 10             	add    $0x10,%esp
   13ae3:	89 c2                	mov    %eax,%edx
   13ae5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13ae8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13aee:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13af1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13af7:	85 c0                	test   %eax,%eax
   13af9:	0f 85 c8 05 00 00    	jne    140c7 <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   13aff:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   13b05:	85 c0                	test   %eax,%eax
   13b07:	74 32                	je     13b3b <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   13b09:	83 ec 08             	sub    $0x8,%esp
   13b0c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13b12:	50                   	push   %eax
   13b13:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13b16:	50                   	push   %eax
   13b17:	e8 c1 e2 ff ff       	call   11ddd <addChunk_cHRM>
   13b1c:	83 c4 10             	add    $0x10,%esp
   13b1f:	89 c2                	mov    %eax,%edx
   13b21:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b24:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13b2a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b2d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13b33:	85 c0                	test   %eax,%eax
   13b35:	0f 85 8f 05 00 00    	jne    140ca <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   13b3b:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13b41:	83 f8 03             	cmp    $0x3,%eax
   13b44:	75 35                	jne    13b7b <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   13b46:	83 ec 08             	sub    $0x8,%esp
   13b49:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13b4f:	83 c0 0c             	add    $0xc,%eax
   13b52:	50                   	push   %eax
   13b53:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13b56:	50                   	push   %eax
   13b57:	e8 78 d8 ff ff       	call   113d4 <addChunk_PLTE>
   13b5c:	83 c4 10             	add    $0x10,%esp
   13b5f:	89 c2                	mov    %eax,%edx
   13b61:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b64:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13b6a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b6d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13b73:	85 c0                	test   %eax,%eax
   13b75:	0f 85 52 05 00 00    	jne    140cd <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   13b7b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13b7e:	8b 40 6c             	mov    0x6c(%eax),%eax
   13b81:	85 c0                	test   %eax,%eax
   13b83:	74 4b                	je     13bd0 <lodepng_encode+0x7fa>
   13b85:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13b8b:	83 f8 02             	cmp    $0x2,%eax
   13b8e:	74 0b                	je     13b9b <lodepng_encode+0x7c5>
   13b90:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13b96:	83 f8 06             	cmp    $0x6,%eax
   13b99:	75 35                	jne    13bd0 <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   13b9b:	83 ec 08             	sub    $0x8,%esp
   13b9e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13ba4:	83 c0 0c             	add    $0xc,%eax
   13ba7:	50                   	push   %eax
   13ba8:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13bab:	50                   	push   %eax
   13bac:	e8 23 d8 ff ff       	call   113d4 <addChunk_PLTE>
   13bb1:	83 c4 10             	add    $0x10,%esp
   13bb4:	89 c2                	mov    %eax,%edx
   13bb6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13bb9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13bbf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13bc2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13bc8:	85 c0                	test   %eax,%eax
   13bca:	0f 85 00 05 00 00    	jne    140d0 <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   13bd0:	83 ec 08             	sub    $0x8,%esp
   13bd3:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13bd9:	83 c0 0c             	add    $0xc,%eax
   13bdc:	50                   	push   %eax
   13bdd:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13be0:	50                   	push   %eax
   13be1:	e8 c4 d8 ff ff       	call   114aa <addChunk_tRNS>
   13be6:	83 c4 10             	add    $0x10,%esp
   13be9:	89 c2                	mov    %eax,%edx
   13beb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13bee:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13bf4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13bf7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13bfd:	85 c0                	test   %eax,%eax
   13bff:	0f 85 ce 04 00 00    	jne    140d3 <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   13c05:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   13c0b:	85 c0                	test   %eax,%eax
   13c0d:	74 32                	je     13c41 <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   13c0f:	83 ec 08             	sub    $0x8,%esp
   13c12:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13c18:	50                   	push   %eax
   13c19:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13c1c:	50                   	push   %eax
   13c1d:	e8 e4 de ff ff       	call   11b06 <addChunk_bKGD>
   13c22:	83 c4 10             	add    $0x10,%esp
   13c25:	89 c2                	mov    %eax,%edx
   13c27:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13c2a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13c30:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13c33:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13c39:	85 c0                	test   %eax,%eax
   13c3b:	0f 85 95 04 00 00    	jne    140d6 <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   13c41:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   13c47:	85 c0                	test   %eax,%eax
   13c49:	74 32                	je     13c7d <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   13c4b:	83 ec 08             	sub    $0x8,%esp
   13c4e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13c54:	50                   	push   %eax
   13c55:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13c58:	50                   	push   %eax
   13c59:	e8 ac e0 ff ff       	call   11d0a <addChunk_pHYs>
   13c5e:	83 c4 10             	add    $0x10,%esp
   13c61:	89 c2                	mov    %eax,%edx
   13c63:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13c66:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13c6c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13c6f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13c75:	85 c0                	test   %eax,%eax
   13c77:	0f 85 5c 04 00 00    	jne    140d9 <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   13c7d:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13c80:	85 c0                	test   %eax,%eax
   13c82:	74 33                	je     13cb7 <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   13c84:	8b 55 a8             	mov    -0x58(%ebp),%edx
   13c87:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13c8a:	83 ec 04             	sub    $0x4,%esp
   13c8d:	52                   	push   %edx
   13c8e:	50                   	push   %eax
   13c8f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13c92:	50                   	push   %eax
   13c93:	e8 2f f6 ff ff       	call   132c7 <addUnknownChunks>
   13c98:	83 c4 10             	add    $0x10,%esp
   13c9b:	89 c2                	mov    %eax,%edx
   13c9d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13ca0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13ca6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13ca9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13caf:	85 c0                	test   %eax,%eax
   13cb1:	0f 85 25 04 00 00    	jne    140dc <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   13cb7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13cba:	8d 48 38             	lea    0x38(%eax),%ecx
   13cbd:	8b 55 bc             	mov    -0x44(%ebp),%edx
   13cc0:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13cc3:	51                   	push   %ecx
   13cc4:	52                   	push   %edx
   13cc5:	50                   	push   %eax
   13cc6:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13cc9:	50                   	push   %eax
   13cca:	e8 bd d9 ff ff       	call   1168c <addChunk_IDAT>
   13ccf:	83 c4 10             	add    $0x10,%esp
   13cd2:	89 c2                	mov    %eax,%edx
   13cd4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13cd7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13cdd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13ce0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13ce6:	85 c0                	test   %eax,%eax
   13ce8:	0f 85 f1 03 00 00    	jne    140df <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   13cee:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   13cf4:	85 c0                	test   %eax,%eax
   13cf6:	74 35                	je     13d2d <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   13cf8:	83 ec 08             	sub    $0x8,%esp
   13cfb:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13d01:	83 c0 60             	add    $0x60,%eax
   13d04:	50                   	push   %eax
   13d05:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13d08:	50                   	push   %eax
   13d09:	e8 5c df ff ff       	call   11c6a <addChunk_tIME>
   13d0e:	83 c4 10             	add    $0x10,%esp
   13d11:	89 c2                	mov    %eax,%edx
   13d13:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13d16:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13d1c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13d1f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13d25:	85 c0                	test   %eax,%eax
   13d27:	0f 85 b5 03 00 00    	jne    140e2 <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13d2d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13d34:	e9 12 01 00 00       	jmp    13e4b <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   13d39:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13d3f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13d42:	c1 e2 02             	shl    $0x2,%edx
   13d45:	01 d0                	add    %edx,%eax
   13d47:	8b 00                	mov    (%eax),%eax
   13d49:	83 ec 0c             	sub    $0xc,%esp
   13d4c:	50                   	push   %eax
   13d4d:	e8 f5 01 ff ff       	call   3f47 <lodepng_strlen>
   13d52:	83 c4 10             	add    $0x10,%esp
   13d55:	83 f8 4f             	cmp    $0x4f,%eax
   13d58:	7e 12                	jle    13d6c <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   13d5a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13d5d:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   13d64:	00 00 00 
        goto cleanup;
   13d67:	e9 83 03 00 00       	jmp    140ef <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   13d6c:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13d72:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13d75:	c1 e2 02             	shl    $0x2,%edx
   13d78:	01 d0                	add    %edx,%eax
   13d7a:	8b 00                	mov    (%eax),%eax
   13d7c:	83 ec 0c             	sub    $0xc,%esp
   13d7f:	50                   	push   %eax
   13d80:	e8 c2 01 ff ff       	call   3f47 <lodepng_strlen>
   13d85:	83 c4 10             	add    $0x10,%esp
   13d88:	85 c0                	test   %eax,%eax
   13d8a:	7f 12                	jg     13d9e <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   13d8c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13d8f:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   13d96:	00 00 00 
        goto cleanup;
   13d99:	e9 51 03 00 00       	jmp    140ef <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   13d9e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13da1:	8b 40 74             	mov    0x74(%eax),%eax
   13da4:	85 c0                	test   %eax,%eax
   13da6:	74 52                	je     13dfa <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   13da8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13dab:	8d 48 38             	lea    0x38(%eax),%ecx
   13dae:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   13db4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13db7:	c1 e2 02             	shl    $0x2,%edx
   13dba:	01 d0                	add    %edx,%eax
   13dbc:	8b 10                	mov    (%eax),%edx
   13dbe:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13dc4:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   13dc7:	c1 e3 02             	shl    $0x2,%ebx
   13dca:	01 d8                	add    %ebx,%eax
   13dcc:	8b 00                	mov    (%eax),%eax
   13dce:	51                   	push   %ecx
   13dcf:	52                   	push   %edx
   13dd0:	50                   	push   %eax
   13dd1:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13dd4:	50                   	push   %eax
   13dd5:	e8 fa d9 ff ff       	call   117d4 <addChunk_zTXt>
   13dda:	83 c4 10             	add    $0x10,%esp
   13ddd:	89 c2                	mov    %eax,%edx
   13ddf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13de2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13de8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13deb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13df1:	85 c0                	test   %eax,%eax
   13df3:	74 52                	je     13e47 <lodepng_encode+0xa71>
   13df5:	e9 f5 02 00 00       	jmp    140ef <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   13dfa:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   13e00:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13e03:	c1 e2 02             	shl    $0x2,%edx
   13e06:	01 d0                	add    %edx,%eax
   13e08:	8b 10                	mov    (%eax),%edx
   13e0a:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13e10:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   13e13:	c1 e1 02             	shl    $0x2,%ecx
   13e16:	01 c8                	add    %ecx,%eax
   13e18:	8b 00                	mov    (%eax),%eax
   13e1a:	83 ec 04             	sub    $0x4,%esp
   13e1d:	52                   	push   %edx
   13e1e:	50                   	push   %eax
   13e1f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13e22:	50                   	push   %eax
   13e23:	e8 ec d8 ff ff       	call   11714 <addChunk_tEXt>
   13e28:	83 c4 10             	add    $0x10,%esp
   13e2b:	89 c2                	mov    %eax,%edx
   13e2d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13e30:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13e36:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13e39:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13e3f:	85 c0                	test   %eax,%eax
   13e41:	0f 85 9e 02 00 00    	jne    140e5 <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13e47:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13e4b:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   13e51:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13e54:	0f 85 df fe ff ff    	jne    13d39 <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   13e5a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13e5d:	8b 40 70             	mov    0x70(%eax),%eax
   13e60:	85 c0                	test   %eax,%eax
   13e62:	0f 84 e3 00 00 00    	je     13f4b <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   13e68:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   13e6f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13e76:	e9 85 00 00 00       	jmp    13f00 <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   13e7b:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13e81:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13e84:	c1 e2 02             	shl    $0x2,%edx
   13e87:	01 d0                	add    %edx,%eax
   13e89:	8b 00                	mov    (%eax),%eax
   13e8b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13e8e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13e91:	0f b6 00             	movzbl (%eax),%eax
   13e94:	3c 4c                	cmp    $0x4c,%al
   13e96:	75 64                	jne    13efc <lodepng_encode+0xb26>
   13e98:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13e9b:	83 c0 01             	add    $0x1,%eax
   13e9e:	0f b6 00             	movzbl (%eax),%eax
   13ea1:	3c 6f                	cmp    $0x6f,%al
   13ea3:	75 57                	jne    13efc <lodepng_encode+0xb26>
   13ea5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13ea8:	83 c0 02             	add    $0x2,%eax
   13eab:	0f b6 00             	movzbl (%eax),%eax
   13eae:	3c 64                	cmp    $0x64,%al
   13eb0:	75 4a                	jne    13efc <lodepng_encode+0xb26>
   13eb2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13eb5:	83 c0 03             	add    $0x3,%eax
   13eb8:	0f b6 00             	movzbl (%eax),%eax
   13ebb:	3c 65                	cmp    $0x65,%al
   13ebd:	75 3d                	jne    13efc <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13ebf:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13ec2:	83 c0 04             	add    $0x4,%eax
   13ec5:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13ec8:	3c 50                	cmp    $0x50,%al
   13eca:	75 30                	jne    13efc <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13ecc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13ecf:	83 c0 05             	add    $0x5,%eax
   13ed2:	0f b6 00             	movzbl (%eax),%eax
   13ed5:	3c 4e                	cmp    $0x4e,%al
   13ed7:	75 23                	jne    13efc <lodepng_encode+0xb26>
   13ed9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13edc:	83 c0 06             	add    $0x6,%eax
   13edf:	0f b6 00             	movzbl (%eax),%eax
   13ee2:	3c 47                	cmp    $0x47,%al
   13ee4:	75 16                	jne    13efc <lodepng_encode+0xb26>
   13ee6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13ee9:	83 c0 07             	add    $0x7,%eax
   13eec:	0f b6 00             	movzbl (%eax),%eax
   13eef:	84 c0                	test   %al,%al
   13ef1:	75 09                	jne    13efc <lodepng_encode+0xb26>
          already_added_id_text = 1;
   13ef3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   13efa:	eb 13                	jmp    13f0f <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   13efc:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13f00:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   13f06:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13f09:	0f 85 6c ff ff ff    	jne    13e7b <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   13f0f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   13f13:	75 36                	jne    13f4b <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   13f15:	a1 80 ef 01 00       	mov    0x1ef80,%eax
   13f1a:	83 ec 04             	sub    $0x4,%esp
   13f1d:	50                   	push   %eax
   13f1e:	68 04 ad 01 00       	push   $0x1ad04
   13f23:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13f26:	50                   	push   %eax
   13f27:	e8 e8 d7 ff ff       	call   11714 <addChunk_tEXt>
   13f2c:	83 c4 10             	add    $0x10,%esp
   13f2f:	89 c2                	mov    %eax,%edx
   13f31:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13f34:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13f3a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13f3d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13f43:	85 c0                	test   %eax,%eax
   13f45:	0f 85 9d 01 00 00    	jne    140e8 <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13f4b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13f52:	e9 e6 00 00 00       	jmp    1403d <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   13f57:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13f5d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13f60:	c1 e2 02             	shl    $0x2,%edx
   13f63:	01 d0                	add    %edx,%eax
   13f65:	8b 00                	mov    (%eax),%eax
   13f67:	83 ec 0c             	sub    $0xc,%esp
   13f6a:	50                   	push   %eax
   13f6b:	e8 d7 ff fe ff       	call   3f47 <lodepng_strlen>
   13f70:	83 c4 10             	add    $0x10,%esp
   13f73:	83 f8 4f             	cmp    $0x4f,%eax
   13f76:	7e 12                	jle    13f8a <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   13f78:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13f7b:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   13f82:	00 00 00 
        goto cleanup;
   13f85:	e9 65 01 00 00       	jmp    140ef <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   13f8a:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13f90:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13f93:	c1 e2 02             	shl    $0x2,%edx
   13f96:	01 d0                	add    %edx,%eax
   13f98:	8b 00                	mov    (%eax),%eax
   13f9a:	83 ec 0c             	sub    $0xc,%esp
   13f9d:	50                   	push   %eax
   13f9e:	e8 a4 ff fe ff       	call   3f47 <lodepng_strlen>
   13fa3:	83 c4 10             	add    $0x10,%esp
   13fa6:	85 c0                	test   %eax,%eax
   13fa8:	7f 12                	jg     13fbc <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   13faa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13fad:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   13fb4:	00 00 00 
        goto cleanup;
   13fb7:	e9 33 01 00 00       	jmp    140ef <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   13fbc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13fbf:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13fc2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   13fc8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13fcb:	c1 e2 02             	shl    $0x2,%edx
   13fce:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13fd0:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13fd2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   13fd8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13fdb:	c1 e2 02             	shl    $0x2,%edx
   13fde:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13fe0:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13fe2:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   13fe8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13feb:	c1 e2 02             	shl    $0x2,%edx
   13fee:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13ff0:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13ff2:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13ff8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13ffb:	c1 e2 02             	shl    $0x2,%edx
   13ffe:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   14000:	8b 10                	mov    (%eax),%edx
   14002:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14005:	8b 40 74             	mov    0x74(%eax),%eax
   14008:	83 ec 04             	sub    $0x4,%esp
   1400b:	57                   	push   %edi
   1400c:	56                   	push   %esi
   1400d:	53                   	push   %ebx
   1400e:	51                   	push   %ecx
   1400f:	52                   	push   %edx
   14010:	50                   	push   %eax
   14011:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14014:	50                   	push   %eax
   14015:	e8 dc d8 ff ff       	call   118f6 <addChunk_iTXt>
   1401a:	83 c4 20             	add    $0x20,%esp
   1401d:	89 c2                	mov    %eax,%edx
   1401f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14022:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   14028:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1402b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14031:	85 c0                	test   %eax,%eax
   14033:	0f 85 b2 00 00 00    	jne    140eb <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   14039:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1403d:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   14043:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   14046:	0f 85 0b ff ff ff    	jne    13f57 <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   1404c:	8b 45 a0             	mov    -0x60(%ebp),%eax
   1404f:	85 c0                	test   %eax,%eax
   14051:	74 2f                	je     14082 <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   14053:	8b 55 ac             	mov    -0x54(%ebp),%edx
   14056:	8b 45 a0             	mov    -0x60(%ebp),%eax
   14059:	83 ec 04             	sub    $0x4,%esp
   1405c:	52                   	push   %edx
   1405d:	50                   	push   %eax
   1405e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14061:	50                   	push   %eax
   14062:	e8 60 f2 ff ff       	call   132c7 <addUnknownChunks>
   14067:	83 c4 10             	add    $0x10,%esp
   1406a:	89 c2                	mov    %eax,%edx
   1406c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1406f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   14075:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14078:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1407e:	85 c0                	test   %eax,%eax
   14080:	75 6c                	jne    140ee <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   14082:	83 ec 0c             	sub    $0xc,%esp
   14085:	8d 45 b0             	lea    -0x50(%ebp),%eax
   14088:	50                   	push   %eax
   14089:	e8 6d d6 ff ff       	call   116fb <addChunk_IEND>
   1408e:	83 c4 10             	add    $0x10,%esp
   14091:	89 c2                	mov    %eax,%edx
   14093:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14096:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1409c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1409f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   140a5:	85 c0                	test   %eax,%eax
   140a7:	eb 46                	jmp    140ef <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   140a9:	90                   	nop
   140aa:	eb 43                	jmp    140ef <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   140ac:	90                   	nop
   140ad:	eb 40                	jmp    140ef <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   140af:	90                   	nop
   140b0:	eb 3d                	jmp    140ef <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   140b2:	90                   	nop
   140b3:	eb 3a                	jmp    140ef <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   140b5:	90                   	nop
   140b6:	eb 37                	jmp    140ef <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   140b8:	90                   	nop
   140b9:	eb 34                	jmp    140ef <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   140bb:	90                   	nop
   140bc:	eb 31                	jmp    140ef <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   140be:	90                   	nop
   140bf:	eb 2e                	jmp    140ef <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   140c1:	90                   	nop
   140c2:	eb 2b                	jmp    140ef <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   140c4:	90                   	nop
   140c5:	eb 28                	jmp    140ef <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   140c7:	90                   	nop
   140c8:	eb 25                	jmp    140ef <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   140ca:	90                   	nop
   140cb:	eb 22                	jmp    140ef <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   140cd:	90                   	nop
   140ce:	eb 1f                	jmp    140ef <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   140d0:	90                   	nop
   140d1:	eb 1c                	jmp    140ef <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   140d3:	90                   	nop
   140d4:	eb 19                	jmp    140ef <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   140d6:	90                   	nop
   140d7:	eb 16                	jmp    140ef <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   140d9:	90                   	nop
   140da:	eb 13                	jmp    140ef <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   140dc:	90                   	nop
   140dd:	eb 10                	jmp    140ef <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   140df:	90                   	nop
   140e0:	eb 0d                	jmp    140ef <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   140e2:	90                   	nop
   140e3:	eb 0a                	jmp    140ef <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   140e5:	90                   	nop
   140e6:	eb 07                	jmp    140ef <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   140e8:	90                   	nop
   140e9:	eb 04                	jmp    140ef <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   140eb:	90                   	nop
   140ec:	eb 01                	jmp    140ef <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   140ee:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   140ef:	83 ec 0c             	sub    $0xc,%esp
   140f2:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   140f8:	50                   	push   %eax
   140f9:	e8 34 65 ff ff       	call   a632 <lodepng_info_cleanup>
   140fe:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   14101:	8b 45 c0             	mov    -0x40(%ebp),%eax
   14104:	83 ec 0c             	sub    $0xc,%esp
   14107:	50                   	push   %eax
   14108:	e8 bf fd fe ff       	call   3ecc <lodepng_free>
   1410d:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   14110:	8b 55 b0             	mov    -0x50(%ebp),%edx
   14113:	8b 45 08             	mov    0x8(%ebp),%eax
   14116:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   14118:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   1411b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1411e:	89 10                	mov    %edx,(%eax)

  return state->error;
   14120:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14123:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   14129:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1412c:	5b                   	pop    %ebx
   1412d:	5e                   	pop    %esi
   1412e:	5f                   	pop    %edi
   1412f:	5d                   	pop    %ebp
   14130:	c3                   	ret    

00014131 <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   14131:	55                   	push   %ebp
   14132:	89 e5                	mov    %esp,%ebp
   14134:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   1413a:	83 ec 0c             	sub    $0xc,%esp
   1413d:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   14143:	50                   	push   %eax
   14144:	e8 38 d0 ff ff       	call   11181 <lodepng_state_init>
   14149:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   1414c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1414f:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   14155:	8b 45 20             	mov    0x20(%ebp),%eax
   14158:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   1415e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   14161:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   14167:	8b 45 20             	mov    0x20(%ebp),%eax
   1416a:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   14170:	83 ec 08             	sub    $0x8,%esp
   14173:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   14179:	50                   	push   %eax
   1417a:	ff 75 18             	pushl  0x18(%ebp)
   1417d:	ff 75 14             	pushl  0x14(%ebp)
   14180:	ff 75 10             	pushl  0x10(%ebp)
   14183:	ff 75 0c             	pushl  0xc(%ebp)
   14186:	ff 75 08             	pushl  0x8(%ebp)
   14189:	e8 48 f2 ff ff       	call   133d6 <lodepng_encode>
   1418e:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   14191:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14194:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   14197:	83 ec 0c             	sub    $0xc,%esp
   1419a:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   141a0:	50                   	push   %eax
   141a1:	e8 35 d0 ff ff       	call   111db <lodepng_state_cleanup>
   141a6:	83 c4 10             	add    $0x10,%esp
  return error;
   141a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   141ac:	c9                   	leave  
   141ad:	c3                   	ret    

000141ae <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   141ae:	55                   	push   %ebp
   141af:	89 e5                	mov    %esp,%ebp
   141b1:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   141b4:	83 ec 04             	sub    $0x4,%esp
   141b7:	6a 08                	push   $0x8
   141b9:	6a 06                	push   $0x6
   141bb:	ff 75 18             	pushl  0x18(%ebp)
   141be:	ff 75 14             	pushl  0x14(%ebp)
   141c1:	ff 75 10             	pushl  0x10(%ebp)
   141c4:	ff 75 0c             	pushl  0xc(%ebp)
   141c7:	ff 75 08             	pushl  0x8(%ebp)
   141ca:	e8 62 ff ff ff       	call   14131 <lodepng_encode_memory>
   141cf:	83 c4 20             	add    $0x20,%esp
}
   141d2:	c9                   	leave  
   141d3:	c3                   	ret    

000141d4 <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   141d4:	55                   	push   %ebp
   141d5:	89 e5                	mov    %esp,%ebp
   141d7:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   141da:	83 ec 04             	sub    $0x4,%esp
   141dd:	6a 08                	push   $0x8
   141df:	6a 02                	push   $0x2
   141e1:	ff 75 18             	pushl  0x18(%ebp)
   141e4:	ff 75 14             	pushl  0x14(%ebp)
   141e7:	ff 75 10             	pushl  0x10(%ebp)
   141ea:	ff 75 0c             	pushl  0xc(%ebp)
   141ed:	ff 75 08             	pushl  0x8(%ebp)
   141f0:	e8 3c ff ff ff       	call   14131 <lodepng_encode_memory>
   141f5:	83 c4 20             	add    $0x20,%esp
}
   141f8:	c9                   	leave  
   141f9:	c3                   	ret    

000141fa <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   141fa:	55                   	push   %ebp
   141fb:	89 e5                	mov    %esp,%ebp
   141fd:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   14200:	83 ec 04             	sub    $0x4,%esp
   14203:	ff 75 1c             	pushl  0x1c(%ebp)
   14206:	ff 75 18             	pushl  0x18(%ebp)
   14209:	ff 75 14             	pushl  0x14(%ebp)
   1420c:	ff 75 10             	pushl  0x10(%ebp)
   1420f:	ff 75 0c             	pushl  0xc(%ebp)
   14212:	8d 45 ec             	lea    -0x14(%ebp),%eax
   14215:	50                   	push   %eax
   14216:	8d 45 f0             	lea    -0x10(%ebp),%eax
   14219:	50                   	push   %eax
   1421a:	e8 12 ff ff ff       	call   14131 <lodepng_encode_memory>
   1421f:	83 c4 20             	add    $0x20,%esp
   14222:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   14225:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14229:	75 19                	jne    14244 <lodepng_encode_file+0x4a>
   1422b:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1422e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14231:	83 ec 04             	sub    $0x4,%esp
   14234:	ff 75 08             	pushl  0x8(%ebp)
   14237:	52                   	push   %edx
   14238:	50                   	push   %eax
   14239:	e8 36 01 ff ff       	call   4374 <lodepng_save_file>
   1423e:	83 c4 10             	add    $0x10,%esp
   14241:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   14244:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14247:	83 ec 0c             	sub    $0xc,%esp
   1424a:	50                   	push   %eax
   1424b:	e8 7c fc fe ff       	call   3ecc <lodepng_free>
   14250:	83 c4 10             	add    $0x10,%esp
  return error;
   14253:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14256:	c9                   	leave  
   14257:	c3                   	ret    

00014258 <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   14258:	55                   	push   %ebp
   14259:	89 e5                	mov    %esp,%ebp
   1425b:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   1425e:	83 ec 08             	sub    $0x8,%esp
   14261:	6a 08                	push   $0x8
   14263:	6a 06                	push   $0x6
   14265:	ff 75 14             	pushl  0x14(%ebp)
   14268:	ff 75 10             	pushl  0x10(%ebp)
   1426b:	ff 75 0c             	pushl  0xc(%ebp)
   1426e:	ff 75 08             	pushl  0x8(%ebp)
   14271:	e8 84 ff ff ff       	call   141fa <lodepng_encode_file>
   14276:	83 c4 20             	add    $0x20,%esp
}
   14279:	c9                   	leave  
   1427a:	c3                   	ret    

0001427b <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   1427b:	55                   	push   %ebp
   1427c:	89 e5                	mov    %esp,%ebp
   1427e:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   14281:	83 ec 08             	sub    $0x8,%esp
   14284:	6a 08                	push   $0x8
   14286:	6a 02                	push   $0x2
   14288:	ff 75 14             	pushl  0x14(%ebp)
   1428b:	ff 75 10             	pushl  0x10(%ebp)
   1428e:	ff 75 0c             	pushl  0xc(%ebp)
   14291:	ff 75 08             	pushl  0x8(%ebp)
   14294:	e8 61 ff ff ff       	call   141fa <lodepng_encode_file>
   14299:	83 c4 20             	add    $0x20,%esp
}
   1429c:	c9                   	leave  
   1429d:	c3                   	ret    

0001429e <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   1429e:	55                   	push   %ebp
   1429f:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   142a1:	8b 45 08             	mov    0x8(%ebp),%eax
   142a4:	50                   	push   %eax
   142a5:	e8 71 49 ff ff       	call   8c1b <lodepng_compress_settings_init>
   142aa:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   142ad:	8b 45 08             	mov    0x8(%ebp),%eax
   142b0:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   142b7:	8b 45 08             	mov    0x8(%ebp),%eax
   142ba:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   142c1:	8b 45 08             	mov    0x8(%ebp),%eax
   142c4:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   142cb:	8b 45 08             	mov    0x8(%ebp),%eax
   142ce:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   142d5:	8b 45 08             	mov    0x8(%ebp),%eax
   142d8:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   142df:	8b 45 08             	mov    0x8(%ebp),%eax
   142e2:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   142e9:	8b 45 08             	mov    0x8(%ebp),%eax
   142ec:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   142f3:	90                   	nop
   142f4:	c9                   	leave  
   142f5:	c3                   	ret    

000142f6 <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   142f6:	55                   	push   %ebp
   142f7:	89 e5                	mov    %esp,%ebp
  switch(code) {
   142f9:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   142fd:	0f 87 c1 03 00 00    	ja     146c4 <lodepng_error_text+0x3ce>
   14303:	8b 45 08             	mov    0x8(%ebp),%eax
   14306:	c1 e0 02             	shl    $0x2,%eax
   14309:	05 40 c0 01 00       	add    $0x1c040,%eax
   1430e:	8b 00                	mov    (%eax),%eax
   14310:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   14312:	b8 0c ad 01 00       	mov    $0x1ad0c,%eax
   14317:	e9 ad 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   1431c:	b8 29 ad 01 00       	mov    $0x1ad29,%eax
   14321:	e9 a3 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   14326:	b8 3c ad 01 00       	mov    $0x1ad3c,%eax
   1432b:	e9 99 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   14330:	b8 74 ad 01 00       	mov    $0x1ad74,%eax
   14335:	e9 8f 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   1433a:	b8 ac ad 01 00       	mov    $0x1adac,%eax
   1433f:	e9 85 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   14344:	b8 ac ad 01 00       	mov    $0x1adac,%eax
   14349:	e9 7b 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   1434e:	b8 ac ad 01 00       	mov    $0x1adac,%eax
   14353:	e9 71 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   14358:	b8 dc ad 01 00       	mov    $0x1addc,%eax
   1435d:	e9 67 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   14362:	b8 10 ae 01 00       	mov    $0x1ae10,%eax
   14367:	e9 5d 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   1436c:	b8 44 ae 01 00       	mov    $0x1ae44,%eax
   14371:	e9 53 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   14376:	b8 10 ae 01 00       	mov    $0x1ae10,%eax
   1437b:	e9 49 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   14380:	b8 6c ae 01 00       	mov    $0x1ae6c,%eax
   14385:	e9 3f 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   1438a:	b8 a4 ae 01 00       	mov    $0x1aea4,%eax
   1438f:	e9 35 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   14394:	b8 10 ae 01 00       	mov    $0x1ae10,%eax
   14399:	e9 2b 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   1439e:	b8 dc ae 01 00       	mov    $0x1aedc,%eax
   143a3:	e9 21 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   143a8:	b8 0c af 01 00       	mov    $0x1af0c,%eax
   143ad:	e9 17 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   143b2:	b8 2c af 01 00       	mov    $0x1af2c,%eax
   143b7:	e9 0d 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   143bc:	b8 58 af 01 00       	mov    $0x1af58,%eax
   143c1:	e9 03 03 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   143c6:	b8 98 af 01 00       	mov    $0x1af98,%eax
   143cb:	e9 f9 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   143d0:	b8 c0 af 01 00       	mov    $0x1afc0,%eax
   143d5:	e9 ef 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   143da:	b8 f4 af 01 00       	mov    $0x1aff4,%eax
   143df:	e9 e5 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   143e4:	b8 18 b0 01 00       	mov    $0x1b018,%eax
   143e9:	e9 db 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   143ee:	b8 50 b0 01 00       	mov    $0x1b050,%eax
   143f3:	e9 d1 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   143f8:	b8 70 b0 01 00       	mov    $0x1b070,%eax
   143fd:	e9 c7 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   14402:	b8 8f b0 01 00       	mov    $0x1b08f,%eax
   14407:	e9 bd 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   1440c:	b8 a9 b0 01 00       	mov    $0x1b0a9,%eax
   14411:	e9 b3 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   14416:	b8 c8 b0 01 00       	mov    $0x1b0c8,%eax
   1441b:	e9 a9 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   14420:	b8 04 b1 01 00       	mov    $0x1b104,%eax
   14425:	e9 9f 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   1442a:	b8 28 b1 01 00       	mov    $0x1b128,%eax
   1442f:	e9 95 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   14434:	b8 54 b1 01 00       	mov    $0x1b154,%eax
   14439:	e9 8b 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   1443e:	b8 78 b1 01 00       	mov    $0x1b178,%eax
   14443:	e9 81 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   14448:	b8 b8 b1 01 00       	mov    $0x1b1b8,%eax
   1444d:	e9 77 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   14452:	b8 e8 b1 01 00       	mov    $0x1b1e8,%eax
   14457:	e9 6d 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   1445c:	b8 10 b2 01 00       	mov    $0x1b210,%eax
   14461:	e9 63 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   14466:	b8 54 b2 01 00       	mov    $0x1b254,%eax
   1446b:	e9 59 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   14470:	b8 80 b2 01 00       	mov    $0x1b280,%eax
   14475:	e9 4f 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   1447a:	b8 b0 b2 01 00       	mov    $0x1b2b0,%eax
   1447f:	e9 45 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   14484:	b8 d8 b2 01 00       	mov    $0x1b2d8,%eax
   14489:	e9 3b 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   1448e:	b8 20 b3 01 00       	mov    $0x1b320,%eax
   14493:	e9 31 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   14498:	b8 20 b3 01 00       	mov    $0x1b320,%eax
   1449d:	e9 27 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   144a2:	b8 5c b3 01 00       	mov    $0x1b35c,%eax
   144a7:	e9 1d 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   144ac:	b8 90 b3 01 00       	mov    $0x1b390,%eax
   144b1:	e9 13 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   144b6:	b8 b3 b3 01 00       	mov    $0x1b3b3,%eax
   144bb:	e9 09 02 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   144c0:	b8 d0 b3 01 00       	mov    $0x1b3d0,%eax
   144c5:	e9 ff 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   144ca:	b8 0c b4 01 00       	mov    $0x1b40c,%eax
   144cf:	e9 f5 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   144d4:	b8 3c b4 01 00       	mov    $0x1b43c,%eax
   144d9:	e9 eb 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   144de:	b8 88 b4 01 00       	mov    $0x1b488,%eax
   144e3:	e9 e1 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   144e8:	b8 c0 b4 01 00       	mov    $0x1b4c0,%eax
   144ed:	e9 d7 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   144f2:	b8 00 b5 01 00       	mov    $0x1b500,%eax
   144f7:	e9 cd 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   144fc:	b8 2c b5 01 00       	mov    $0x1b52c,%eax
   14501:	e9 c3 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   14506:	b8 78 b5 01 00       	mov    $0x1b578,%eax
   1450b:	e9 b9 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   14510:	b8 cc b5 01 00       	mov    $0x1b5cc,%eax
   14515:	e9 af 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   1451a:	b8 00 b6 01 00       	mov    $0x1b600,%eax
   1451f:	e9 a5 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   14524:	b8 50 b6 01 00       	mov    $0x1b650,%eax
   14529:	e9 9b 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   1452e:	b8 8c b6 01 00       	mov    $0x1b68c,%eax
   14533:	e9 91 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   14538:	b8 ec b6 01 00       	mov    $0x1b6ec,%eax
   1453d:	e9 87 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   14542:	b8 4c b7 01 00       	mov    $0x1b74c,%eax
   14547:	e9 7d 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   1454c:	b8 a8 b7 01 00       	mov    $0x1b7a8,%eax
   14551:	e9 73 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   14556:	b8 ec b7 01 00       	mov    $0x1b7ec,%eax
   1455b:	e9 69 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   14560:	b8 28 b8 01 00       	mov    $0x1b828,%eax
   14565:	e9 5f 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   1456a:	b8 85 b8 01 00       	mov    $0x1b885,%eax
   1456f:	e9 55 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   14574:	b8 9d b8 01 00       	mov    $0x1b89d,%eax
   14579:	e9 4b 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   1457e:	b8 b8 b8 01 00       	mov    $0x1b8b8,%eax
   14583:	e9 41 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   14588:	b8 f4 b8 01 00       	mov    $0x1b8f4,%eax
   1458d:	e9 37 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   14592:	b8 24 b9 01 00       	mov    $0x1b924,%eax
   14597:	e9 2d 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   1459c:	b8 44 b9 01 00       	mov    $0x1b944,%eax
   145a1:	e9 23 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   145a6:	b8 64 b9 01 00       	mov    $0x1b964,%eax
   145ab:	e9 19 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   145b0:	b8 84 b9 01 00       	mov    $0x1b984,%eax
   145b5:	e9 0f 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   145ba:	b8 a8 b9 01 00       	mov    $0x1b9a8,%eax
   145bf:	e9 05 01 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   145c4:	b8 d0 b9 01 00       	mov    $0x1b9d0,%eax
   145c9:	e9 fb 00 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   145ce:	b8 2d ba 01 00       	mov    $0x1ba2d,%eax
   145d3:	e9 f1 00 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   145d8:	b8 48 ba 01 00       	mov    $0x1ba48,%eax
   145dd:	e9 e7 00 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   145e2:	b8 84 ba 01 00       	mov    $0x1ba84,%eax
   145e7:	e9 dd 00 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   145ec:	b8 b8 ba 01 00       	mov    $0x1bab8,%eax
   145f1:	e9 d3 00 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   145f6:	b8 0c bb 01 00       	mov    $0x1bb0c,%eax
   145fb:	e9 c9 00 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   14600:	b8 58 bb 01 00       	mov    $0x1bb58,%eax
   14605:	e9 bf 00 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   1460a:	b8 94 bb 01 00       	mov    $0x1bb94,%eax
   1460f:	e9 b5 00 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   14614:	b8 b8 bb 01 00       	mov    $0x1bbb8,%eax
   14619:	e9 ab 00 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   1461e:	b8 d8 bb 01 00       	mov    $0x1bbd8,%eax
   14623:	e9 a1 00 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   14628:	b8 00 bc 01 00       	mov    $0x1bc00,%eax
   1462d:	e9 97 00 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   14632:	b8 20 bc 01 00       	mov    $0x1bc20,%eax
   14637:	e9 8d 00 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   1463c:	b8 4c bc 01 00       	mov    $0x1bc4c,%eax
   14641:	e9 83 00 00 00       	jmp    146c9 <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   14646:	b8 7b bc 01 00       	mov    $0x1bc7b,%eax
   1464b:	eb 7c                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   1464d:	b8 93 bc 01 00       	mov    $0x1bc93,%eax
   14652:	eb 75                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   14654:	b8 ab bc 01 00       	mov    $0x1bcab,%eax
   14659:	eb 6e                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   1465b:	b8 c3 bc 01 00       	mov    $0x1bcc3,%eax
   14660:	eb 67                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   14662:	b8 e4 bc 01 00       	mov    $0x1bce4,%eax
   14667:	eb 60                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   14669:	b8 34 bd 01 00       	mov    $0x1bd34,%eax
   1466e:	eb 59                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   14670:	b8 88 bd 01 00       	mov    $0x1bd88,%eax
   14675:	eb 52                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   14677:	b8 dc bd 01 00       	mov    $0x1bddc,%eax
   1467c:	eb 4b                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   1467e:	b8 24 be 01 00       	mov    $0x1be24,%eax
   14683:	eb 44                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   14685:	b8 68 be 01 00       	mov    $0x1be68,%eax
   1468a:	eb 3d                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   1468c:	b8 84 be 01 00       	mov    $0x1be84,%eax
   14691:	eb 36                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   14693:	b8 bc be 01 00       	mov    $0x1bebc,%eax
   14698:	eb 2f                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   1469a:	b8 10 bf 01 00       	mov    $0x1bf10,%eax
   1469f:	eb 28                	jmp    146c9 <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   146a1:	b8 40 bf 01 00       	mov    $0x1bf40,%eax
   146a6:	eb 21                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   146a8:	b8 90 bf 01 00       	mov    $0x1bf90,%eax
   146ad:	eb 1a                	jmp    146c9 <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   146af:	b8 bc bf 01 00       	mov    $0x1bfbc,%eax
   146b4:	eb 13                	jmp    146c9 <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   146b6:	b8 e8 bf 01 00       	mov    $0x1bfe8,%eax
   146bb:	eb 0c                	jmp    146c9 <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   146bd:	b8 0c c0 01 00       	mov    $0x1c00c,%eax
   146c2:	eb 05                	jmp    146c9 <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   146c4:	b8 2b c0 01 00       	mov    $0x1c02b,%eax
}
   146c9:	5d                   	pop    %ebp
   146ca:	c3                   	ret    

000146cb <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   146cb:	55                   	push   %ebp
   146cc:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   146ce:	8b 45 08             	mov    0x8(%ebp),%eax
   146d1:	8b 40 28             	mov    0x28(%eax),%eax
   146d4:	83 f8 01             	cmp    $0x1,%eax
   146d7:	75 08                	jne    146e1 <GetImage+0x16>
   146d9:	8b 45 08             	mov    0x8(%ebp),%eax
   146dc:	8b 40 54             	mov    0x54(%eax),%eax
   146df:	eb 09                	jmp    146ea <GetImage+0x1f>
   146e1:	8b 45 08             	mov    0x8(%ebp),%eax
   146e4:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   146ea:	5d                   	pop    %ebp
   146eb:	c3                   	ret    

000146ec <GetWidth>:

int GetWidth(Context* ctx){
   146ec:	55                   	push   %ebp
   146ed:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   146ef:	8b 45 08             	mov    0x8(%ebp),%eax
   146f2:	8b 40 10             	mov    0x10(%eax),%eax
}
   146f5:	5d                   	pop    %ebp
   146f6:	c3                   	ret    

000146f7 <GetHeight>:

int GetHeight(Context* ctx){
   146f7:	55                   	push   %ebp
   146f8:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   146fa:	8b 45 08             	mov    0x8(%ebp),%eax
   146fd:	8b 40 14             	mov    0x14(%eax),%eax
}
   14700:	5d                   	pop    %ebp
   14701:	c3                   	ret    

00014702 <GetImageSize>:

uint GetImageSize(Context* ctx){
   14702:	55                   	push   %ebp
   14703:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   14705:	8b 45 08             	mov    0x8(%ebp),%eax
   14708:	8b 50 10             	mov    0x10(%eax),%edx
   1470b:	8b 45 08             	mov    0x8(%ebp),%eax
   1470e:	8b 40 14             	mov    0x14(%eax),%eax
   14711:	0f af d0             	imul   %eax,%edx
   14714:	8b 45 08             	mov    0x8(%ebp),%eax
   14717:	8b 40 28             	mov    0x28(%eax),%eax
   1471a:	0f af c2             	imul   %edx,%eax
}
   1471d:	5d                   	pop    %ebp
   1471e:	c3                   	ret    

0001471f <_Clip>:

uchar _Clip(const int x){
   1471f:	55                   	push   %ebp
   14720:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   14722:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   14726:	78 15                	js     1473d <_Clip+0x1e>
   14728:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   1472f:	7f 05                	jg     14736 <_Clip+0x17>
   14731:	8b 45 08             	mov    0x8(%ebp),%eax
   14734:	eb 0c                	jmp    14742 <_Clip+0x23>
   14736:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1473b:	eb 05                	jmp    14742 <_Clip+0x23>
   1473d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14742:	5d                   	pop    %ebp
   14743:	c3                   	ret    

00014744 <_Skip>:

void _Skip(Context* ctx, int c){
   14744:	55                   	push   %ebp
   14745:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   14747:	8b 45 08             	mov    0x8(%ebp),%eax
   1474a:	8b 50 04             	mov    0x4(%eax),%edx
   1474d:	8b 45 0c             	mov    0xc(%ebp),%eax
   14750:	01 c2                	add    %eax,%edx
   14752:	8b 45 08             	mov    0x8(%ebp),%eax
   14755:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   14758:	8b 45 08             	mov    0x8(%ebp),%eax
   1475b:	8b 40 08             	mov    0x8(%eax),%eax
   1475e:	2b 45 0c             	sub    0xc(%ebp),%eax
   14761:	89 c2                	mov    %eax,%edx
   14763:	8b 45 08             	mov    0x8(%ebp),%eax
   14766:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   14769:	8b 45 08             	mov    0x8(%ebp),%eax
   1476c:	8b 40 0c             	mov    0xc(%eax),%eax
   1476f:	2b 45 0c             	sub    0xc(%ebp),%eax
   14772:	89 c2                	mov    %eax,%edx
   14774:	8b 45 08             	mov    0x8(%ebp),%eax
   14777:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   1477a:	8b 45 08             	mov    0x8(%ebp),%eax
   1477d:	8b 40 08             	mov    0x8(%eax),%eax
   14780:	85 c0                	test   %eax,%eax
   14782:	79 09                	jns    1478d <_Skip+0x49>
   14784:	8b 45 08             	mov    0x8(%ebp),%eax
   14787:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   1478d:	90                   	nop
   1478e:	5d                   	pop    %ebp
   1478f:	c3                   	ret    

00014790 <_DecodeLength>:

void _DecodeLength(Context* ctx){
   14790:	55                   	push   %ebp
   14791:	89 e5                	mov    %esp,%ebp
   14793:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   14796:	8b 45 08             	mov    0x8(%ebp),%eax
   14799:	8b 40 08             	mov    0x8(%eax),%eax
   1479c:	83 f8 01             	cmp    $0x1,%eax
   1479f:	7f 0b                	jg     147ac <_DecodeLength+0x1c>
   147a1:	8b 45 08             	mov    0x8(%ebp),%eax
   147a4:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   147aa:	eb 45                	jmp    147f1 <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   147ac:	8b 45 08             	mov    0x8(%ebp),%eax
   147af:	8b 40 04             	mov    0x4(%eax),%eax
   147b2:	83 ec 0c             	sub    $0xc,%esp
   147b5:	50                   	push   %eax
   147b6:	e8 38 00 00 00       	call   147f3 <_Decode2Bytes>
   147bb:	83 c4 10             	add    $0x10,%esp
   147be:	89 c2                	mov    %eax,%edx
   147c0:	8b 45 08             	mov    0x8(%ebp),%eax
   147c3:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   147c6:	8b 45 08             	mov    0x8(%ebp),%eax
   147c9:	8b 50 0c             	mov    0xc(%eax),%edx
   147cc:	8b 45 08             	mov    0x8(%ebp),%eax
   147cf:	8b 40 08             	mov    0x8(%eax),%eax
   147d2:	39 c2                	cmp    %eax,%edx
   147d4:	7e 0b                	jle    147e1 <_DecodeLength+0x51>
   147d6:	8b 45 08             	mov    0x8(%ebp),%eax
   147d9:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   147df:	eb 10                	jmp    147f1 <_DecodeLength+0x61>
    _Skip(ctx, 2);
   147e1:	83 ec 08             	sub    $0x8,%esp
   147e4:	6a 02                	push   $0x2
   147e6:	ff 75 08             	pushl  0x8(%ebp)
   147e9:	e8 56 ff ff ff       	call   14744 <_Skip>
   147ee:	83 c4 10             	add    $0x10,%esp
}
   147f1:	c9                   	leave  
   147f2:	c3                   	ret    

000147f3 <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   147f3:	55                   	push   %ebp
   147f4:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   147f6:	8b 45 08             	mov    0x8(%ebp),%eax
   147f9:	0f b6 00             	movzbl (%eax),%eax
   147fc:	0f b6 c0             	movzbl %al,%eax
   147ff:	c1 e0 08             	shl    $0x8,%eax
   14802:	89 c2                	mov    %eax,%edx
   14804:	8b 45 08             	mov    0x8(%ebp),%eax
   14807:	83 c0 01             	add    $0x1,%eax
   1480a:	0f b6 00             	movzbl (%eax),%eax
   1480d:	0f b6 c0             	movzbl %al,%eax
   14810:	09 d0                	or     %edx,%eax
}
   14812:	5d                   	pop    %ebp
   14813:	c3                   	ret    

00014814 <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   14814:	55                   	push   %ebp
   14815:	89 e5                	mov    %esp,%ebp
   14817:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   1481a:	8b 45 08             	mov    0x8(%ebp),%eax
   1481d:	8b 55 10             	mov    0x10(%ebp),%edx
   14820:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   14823:	8b 45 14             	mov    0x14(%ebp),%eax
   14826:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   1482b:	89 c2                	mov    %eax,%edx
   1482d:	8b 45 08             	mov    0x8(%ebp),%eax
   14830:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   14833:	8b 45 08             	mov    0x8(%ebp),%eax
   14836:	8b 40 08             	mov    0x8(%eax),%eax
   14839:	83 f8 01             	cmp    $0x1,%eax
   1483c:	7e 1d                	jle    1485b <_DecodeJPEG+0x47>
   1483e:	8b 45 08             	mov    0x8(%ebp),%eax
   14841:	8b 40 04             	mov    0x4(%eax),%eax
   14844:	0f b6 00             	movzbl (%eax),%eax
   14847:	3c ff                	cmp    $0xff,%al
   14849:	75 10                	jne    1485b <_DecodeJPEG+0x47>
   1484b:	8b 45 08             	mov    0x8(%ebp),%eax
   1484e:	8b 40 04             	mov    0x4(%eax),%eax
   14851:	83 c0 01             	add    $0x1,%eax
   14854:	0f b6 00             	movzbl (%eax),%eax
   14857:	3c d8                	cmp    $0xd8,%al
   14859:	74 0a                	je     14865 <_DecodeJPEG+0x51>
   1485b:	b8 01 00 00 00       	mov    $0x1,%eax
   14860:	e9 56 01 00 00       	jmp    149bb <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   14865:	6a 02                	push   $0x2
   14867:	ff 75 08             	pushl  0x8(%ebp)
   1486a:	e8 d5 fe ff ff       	call   14744 <_Skip>
   1486f:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   14872:	e9 0a 01 00 00       	jmp    14981 <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   14877:	8b 45 08             	mov    0x8(%ebp),%eax
   1487a:	8b 40 08             	mov    0x8(%eax),%eax
   1487d:	85 c0                	test   %eax,%eax
   1487f:	78 0d                	js     1488e <_DecodeJPEG+0x7a>
   14881:	8b 45 08             	mov    0x8(%ebp),%eax
   14884:	8b 40 04             	mov    0x4(%eax),%eax
   14887:	0f b6 00             	movzbl (%eax),%eax
   1488a:	3c ff                	cmp    $0xff,%al
   1488c:	74 0a                	je     14898 <_DecodeJPEG+0x84>
   1488e:	b8 05 00 00 00       	mov    $0x5,%eax
   14893:	e9 23 01 00 00       	jmp    149bb <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   14898:	6a 02                	push   $0x2
   1489a:	ff 75 08             	pushl  0x8(%ebp)
   1489d:	e8 a2 fe ff ff       	call   14744 <_Skip>
   148a2:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   148a5:	8b 45 08             	mov    0x8(%ebp),%eax
   148a8:	8b 40 04             	mov    0x4(%eax),%eax
   148ab:	83 e8 01             	sub    $0x1,%eax
   148ae:	0f b6 00             	movzbl (%eax),%eax
   148b1:	0f b6 c0             	movzbl %al,%eax
   148b4:	3d da 00 00 00       	cmp    $0xda,%eax
   148b9:	74 71                	je     1492c <_DecodeJPEG+0x118>
   148bb:	3d da 00 00 00       	cmp    $0xda,%eax
   148c0:	7f 10                	jg     148d2 <_DecodeJPEG+0xbe>
   148c2:	3d c0 00 00 00       	cmp    $0xc0,%eax
   148c7:	74 20                	je     148e9 <_DecodeJPEG+0xd5>
   148c9:	3d c4 00 00 00       	cmp    $0xc4,%eax
   148ce:	74 2c                	je     148fc <_DecodeJPEG+0xe8>
   148d0:	eb 7d                	jmp    1494f <_DecodeJPEG+0x13b>
   148d2:	3d dd 00 00 00       	cmp    $0xdd,%eax
   148d7:	74 43                	je     1491c <_DecodeJPEG+0x108>
   148d9:	3d fe 00 00 00       	cmp    $0xfe,%eax
   148de:	74 5f                	je     1493f <_DecodeJPEG+0x12b>
   148e0:	3d db 00 00 00       	cmp    $0xdb,%eax
   148e5:	74 25                	je     1490c <_DecodeJPEG+0xf8>
   148e7:	eb 66                	jmp    1494f <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   148e9:	83 ec 0c             	sub    $0xc,%esp
   148ec:	ff 75 08             	pushl  0x8(%ebp)
   148ef:	e8 c9 00 00 00       	call   149bd <_DecodeSOF>
   148f4:	83 c4 10             	add    $0x10,%esp
   148f7:	e9 85 00 00 00       	jmp    14981 <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   148fc:	83 ec 0c             	sub    $0xc,%esp
   148ff:	ff 75 08             	pushl  0x8(%ebp)
   14902:	e8 28 05 00 00       	call   14e2f <_DecodeDHT>
   14907:	83 c4 10             	add    $0x10,%esp
   1490a:	eb 75                	jmp    14981 <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   1490c:	83 ec 0c             	sub    $0xc,%esp
   1490f:	ff 75 08             	pushl  0x8(%ebp)
   14912:	e8 05 07 00 00       	call   1501c <_DecodeDQT>
   14917:	83 c4 10             	add    $0x10,%esp
   1491a:	eb 65                	jmp    14981 <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   1491c:	83 ec 0c             	sub    $0xc,%esp
   1491f:	ff 75 08             	pushl  0x8(%ebp)
   14922:	e8 ff 07 00 00       	call   15126 <_DecodeDRI>
   14927:	83 c4 10             	add    $0x10,%esp
   1492a:	eb 55                	jmp    14981 <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   1492c:	83 ec 08             	sub    $0x8,%esp
   1492f:	ff 75 0c             	pushl  0xc(%ebp)
   14932:	ff 75 08             	pushl  0x8(%ebp)
   14935:	e8 56 08 00 00       	call   15190 <_DecodeSOS>
   1493a:	83 c4 10             	add    $0x10,%esp
   1493d:	eb 42                	jmp    14981 <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   1493f:	83 ec 0c             	sub    $0xc,%esp
   14942:	ff 75 08             	pushl  0x8(%ebp)
   14945:	e8 a8 15 00 00       	call   15ef2 <_SkipMarker>
   1494a:	83 c4 10             	add    $0x10,%esp
   1494d:	eb 32                	jmp    14981 <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   1494f:	8b 45 08             	mov    0x8(%ebp),%eax
   14952:	8b 40 04             	mov    0x4(%eax),%eax
   14955:	83 e8 01             	sub    $0x1,%eax
   14958:	0f b6 00             	movzbl (%eax),%eax
   1495b:	0f b6 c0             	movzbl %al,%eax
   1495e:	25 f0 00 00 00       	and    $0xf0,%eax
   14963:	3d e0 00 00 00       	cmp    $0xe0,%eax
   14968:	75 10                	jne    1497a <_DecodeJPEG+0x166>
   1496a:	83 ec 0c             	sub    $0xc,%esp
   1496d:	ff 75 08             	pushl  0x8(%ebp)
   14970:	e8 7d 15 00 00       	call   15ef2 <_SkipMarker>
   14975:	83 c4 10             	add    $0x10,%esp
   14978:	eb 07                	jmp    14981 <_DecodeJPEG+0x16d>
                else return Unsupported;
   1497a:	b8 02 00 00 00       	mov    $0x2,%eax
   1497f:	eb 3a                	jmp    149bb <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   14981:	8b 45 08             	mov    0x8(%ebp),%eax
   14984:	8b 00                	mov    (%eax),%eax
   14986:	85 c0                	test   %eax,%eax
   14988:	0f 84 e9 fe ff ff    	je     14877 <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   1498e:	8b 45 08             	mov    0x8(%ebp),%eax
   14991:	8b 00                	mov    (%eax),%eax
   14993:	83 f8 06             	cmp    $0x6,%eax
   14996:	74 07                	je     1499f <_DecodeJPEG+0x18b>
   14998:	8b 45 08             	mov    0x8(%ebp),%eax
   1499b:	8b 00                	mov    (%eax),%eax
   1499d:	eb 1c                	jmp    149bb <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   1499f:	8b 45 08             	mov    0x8(%ebp),%eax
   149a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   149a8:	83 ec 0c             	sub    $0xc,%esp
   149ab:	ff 75 08             	pushl  0x8(%ebp)
   149ae:	e8 6b 15 00 00       	call   15f1e <_Convert>
   149b3:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   149b6:	8b 45 08             	mov    0x8(%ebp),%eax
   149b9:	8b 00                	mov    (%eax),%eax
 }
   149bb:	c9                   	leave  
   149bc:	c3                   	ret    

000149bd <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   149bd:	55                   	push   %ebp
   149be:	89 e5                	mov    %esp,%ebp
   149c0:	53                   	push   %ebx
   149c1:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   149c4:	83 ec 0c             	sub    $0xc,%esp
   149c7:	ff 75 08             	pushl  0x8(%ebp)
   149ca:	e8 c1 fd ff ff       	call   14790 <_DecodeLength>
   149cf:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   149d2:	8b 45 08             	mov    0x8(%ebp),%eax
   149d5:	8b 00                	mov    (%eax),%eax
   149d7:	85 c0                	test   %eax,%eax
   149d9:	0f 85 4a 04 00 00    	jne    14e29 <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   149df:	8b 45 08             	mov    0x8(%ebp),%eax
   149e2:	8b 40 0c             	mov    0xc(%eax),%eax
   149e5:	83 f8 08             	cmp    $0x8,%eax
   149e8:	7f 0e                	jg     149f8 <_DecodeSOF+0x3b>
   149ea:	8b 45 08             	mov    0x8(%ebp),%eax
   149ed:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   149f3:	e9 32 04 00 00       	jmp    14e2a <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   149f8:	8b 45 08             	mov    0x8(%ebp),%eax
   149fb:	8b 40 04             	mov    0x4(%eax),%eax
   149fe:	0f b6 00             	movzbl (%eax),%eax
   14a01:	3c 08                	cmp    $0x8,%al
   14a03:	74 0e                	je     14a13 <_DecodeSOF+0x56>
   14a05:	8b 45 08             	mov    0x8(%ebp),%eax
   14a08:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14a0e:	e9 17 04 00 00       	jmp    14e2a <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   14a13:	8b 45 08             	mov    0x8(%ebp),%eax
   14a16:	8b 40 04             	mov    0x4(%eax),%eax
   14a19:	83 c0 01             	add    $0x1,%eax
   14a1c:	83 ec 0c             	sub    $0xc,%esp
   14a1f:	50                   	push   %eax
   14a20:	e8 ce fd ff ff       	call   147f3 <_Decode2Bytes>
   14a25:	83 c4 10             	add    $0x10,%esp
   14a28:	89 c2                	mov    %eax,%edx
   14a2a:	8b 45 08             	mov    0x8(%ebp),%eax
   14a2d:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   14a30:	8b 45 08             	mov    0x8(%ebp),%eax
   14a33:	8b 40 04             	mov    0x4(%eax),%eax
   14a36:	83 c0 03             	add    $0x3,%eax
   14a39:	83 ec 0c             	sub    $0xc,%esp
   14a3c:	50                   	push   %eax
   14a3d:	e8 b1 fd ff ff       	call   147f3 <_Decode2Bytes>
   14a42:	83 c4 10             	add    $0x10,%esp
   14a45:	89 c2                	mov    %eax,%edx
   14a47:	8b 45 08             	mov    0x8(%ebp),%eax
   14a4a:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   14a4d:	8b 45 08             	mov    0x8(%ebp),%eax
   14a50:	8b 40 04             	mov    0x4(%eax),%eax
   14a53:	83 c0 05             	add    $0x5,%eax
   14a56:	0f b6 00             	movzbl (%eax),%eax
   14a59:	0f b6 d0             	movzbl %al,%edx
   14a5c:	8b 45 08             	mov    0x8(%ebp),%eax
   14a5f:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   14a62:	83 ec 08             	sub    $0x8,%esp
   14a65:	6a 06                	push   $0x6
   14a67:	ff 75 08             	pushl  0x8(%ebp)
   14a6a:	e8 d5 fc ff ff       	call   14744 <_Skip>
   14a6f:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   14a72:	8b 45 08             	mov    0x8(%ebp),%eax
   14a75:	8b 40 28             	mov    0x28(%eax),%eax
   14a78:	83 f8 01             	cmp    $0x1,%eax
   14a7b:	74 13                	je     14a90 <_DecodeSOF+0xd3>
   14a7d:	83 f8 03             	cmp    $0x3,%eax
   14a80:	74 0e                	je     14a90 <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   14a82:	8b 45 08             	mov    0x8(%ebp),%eax
   14a85:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14a8b:	e9 9a 03 00 00       	jmp    14e2a <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   14a90:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   14a91:	8b 45 08             	mov    0x8(%ebp),%eax
   14a94:	8b 48 0c             	mov    0xc(%eax),%ecx
   14a97:	8b 45 08             	mov    0x8(%ebp),%eax
   14a9a:	8b 50 28             	mov    0x28(%eax),%edx
   14a9d:	89 d0                	mov    %edx,%eax
   14a9f:	01 c0                	add    %eax,%eax
   14aa1:	01 d0                	add    %edx,%eax
   14aa3:	39 c1                	cmp    %eax,%ecx
   14aa5:	7d 0e                	jge    14ab5 <_DecodeSOF+0xf8>
   14aa7:	8b 45 08             	mov    0x8(%ebp),%eax
   14aaa:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14ab0:	e9 75 03 00 00       	jmp    14e2a <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   14ab5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14abc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14ac3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14aca:	8b 45 08             	mov    0x8(%ebp),%eax
   14acd:	83 c0 2c             	add    $0x2c,%eax
   14ad0:	89 45 e8             	mov    %eax,-0x18(%ebp)
   14ad3:	e9 50 01 00 00       	jmp    14c28 <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   14ad8:	8b 45 08             	mov    0x8(%ebp),%eax
   14adb:	8b 40 04             	mov    0x4(%eax),%eax
   14ade:	0f b6 00             	movzbl (%eax),%eax
   14ae1:	0f b6 d0             	movzbl %al,%edx
   14ae4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14ae7:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   14ae9:	8b 45 08             	mov    0x8(%ebp),%eax
   14aec:	8b 40 04             	mov    0x4(%eax),%eax
   14aef:	83 c0 01             	add    $0x1,%eax
   14af2:	0f b6 00             	movzbl (%eax),%eax
   14af5:	c0 e8 04             	shr    $0x4,%al
   14af8:	0f b6 d0             	movzbl %al,%edx
   14afb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14afe:	89 50 04             	mov    %edx,0x4(%eax)
   14b01:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14b04:	8b 40 04             	mov    0x4(%eax),%eax
   14b07:	85 c0                	test   %eax,%eax
   14b09:	75 0e                	jne    14b19 <_DecodeSOF+0x15c>
   14b0b:	8b 45 08             	mov    0x8(%ebp),%eax
   14b0e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14b14:	e9 11 03 00 00       	jmp    14e2a <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   14b19:	8b 45 08             	mov    0x8(%ebp),%eax
   14b1c:	8b 40 04             	mov    0x4(%eax),%eax
   14b1f:	83 c0 01             	add    $0x1,%eax
   14b22:	0f b6 00             	movzbl (%eax),%eax
   14b25:	0f b6 c0             	movzbl %al,%eax
   14b28:	83 e0 0f             	and    $0xf,%eax
   14b2b:	89 c2                	mov    %eax,%edx
   14b2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14b30:	89 50 08             	mov    %edx,0x8(%eax)
   14b33:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14b36:	8b 40 08             	mov    0x8(%eax),%eax
   14b39:	85 c0                	test   %eax,%eax
   14b3b:	75 0e                	jne    14b4b <_DecodeSOF+0x18e>
   14b3d:	8b 45 08             	mov    0x8(%ebp),%eax
   14b40:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14b46:	e9 df 02 00 00       	jmp    14e2a <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   14b4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14b4e:	8b 50 04             	mov    0x4(%eax),%edx
   14b51:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14b54:	8b 40 04             	mov    0x4(%eax),%eax
   14b57:	83 e8 01             	sub    $0x1,%eax
   14b5a:	21 d0                	and    %edx,%eax
   14b5c:	85 c0                	test   %eax,%eax
   14b5e:	74 0e                	je     14b6e <_DecodeSOF+0x1b1>
   14b60:	8b 45 08             	mov    0x8(%ebp),%eax
   14b63:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14b69:	e9 bc 02 00 00       	jmp    14e2a <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   14b6e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14b71:	8b 50 08             	mov    0x8(%eax),%edx
   14b74:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14b77:	8b 40 08             	mov    0x8(%eax),%eax
   14b7a:	83 e8 01             	sub    $0x1,%eax
   14b7d:	21 d0                	and    %edx,%eax
   14b7f:	85 c0                	test   %eax,%eax
   14b81:	74 0e                	je     14b91 <_DecodeSOF+0x1d4>
   14b83:	8b 45 08             	mov    0x8(%ebp),%eax
   14b86:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14b8c:	e9 99 02 00 00       	jmp    14e2a <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   14b91:	8b 45 08             	mov    0x8(%ebp),%eax
   14b94:	8b 40 04             	mov    0x4(%eax),%eax
   14b97:	83 c0 02             	add    $0x2,%eax
   14b9a:	0f b6 00             	movzbl (%eax),%eax
   14b9d:	0f b6 d0             	movzbl %al,%edx
   14ba0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14ba3:	89 50 18             	mov    %edx,0x18(%eax)
   14ba6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14ba9:	8b 40 18             	mov    0x18(%eax),%eax
   14bac:	25 fc 00 00 00       	and    $0xfc,%eax
   14bb1:	85 c0                	test   %eax,%eax
   14bb3:	74 0e                	je     14bc3 <_DecodeSOF+0x206>
   14bb5:	8b 45 08             	mov    0x8(%ebp),%eax
   14bb8:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14bbe:	e9 67 02 00 00       	jmp    14e2a <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   14bc3:	83 ec 08             	sub    $0x8,%esp
   14bc6:	6a 03                	push   $0x3
   14bc8:	ff 75 08             	pushl  0x8(%ebp)
   14bcb:	e8 74 fb ff ff       	call   14744 <_Skip>
   14bd0:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   14bd3:	8b 45 08             	mov    0x8(%ebp),%eax
   14bd6:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   14bdc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14bdf:	8b 40 18             	mov    0x18(%eax),%eax
   14be2:	bb 01 00 00 00       	mov    $0x1,%ebx
   14be7:	89 c1                	mov    %eax,%ecx
   14be9:	d3 e3                	shl    %cl,%ebx
   14beb:	89 d8                	mov    %ebx,%eax
   14bed:	09 c2                	or     %eax,%edx
   14bef:	8b 45 08             	mov    0x8(%ebp),%eax
   14bf2:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   14bf8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14bfb:	8b 40 04             	mov    0x4(%eax),%eax
   14bfe:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14c01:	7e 09                	jle    14c0c <_DecodeSOF+0x24f>
   14c03:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14c06:	8b 40 04             	mov    0x4(%eax),%eax
   14c09:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   14c0c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14c0f:	8b 40 08             	mov    0x8(%eax),%eax
   14c12:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14c15:	7e 09                	jle    14c20 <_DecodeSOF+0x263>
   14c17:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14c1a:	8b 40 08             	mov    0x8(%eax),%eax
   14c1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14c20:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14c24:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   14c28:	8b 45 08             	mov    0x8(%ebp),%eax
   14c2b:	8b 40 28             	mov    0x28(%eax),%eax
   14c2e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14c31:	0f 8f a1 fe ff ff    	jg     14ad8 <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   14c37:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14c3a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   14c41:	8b 45 08             	mov    0x8(%ebp),%eax
   14c44:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   14c47:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c4a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   14c51:	8b 45 08             	mov    0x8(%ebp),%eax
   14c54:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   14c57:	8b 45 08             	mov    0x8(%ebp),%eax
   14c5a:	8b 50 10             	mov    0x10(%eax),%edx
   14c5d:	8b 45 08             	mov    0x8(%ebp),%eax
   14c60:	8b 40 20             	mov    0x20(%eax),%eax
   14c63:	01 d0                	add    %edx,%eax
   14c65:	8d 48 ff             	lea    -0x1(%eax),%ecx
   14c68:	8b 45 08             	mov    0x8(%ebp),%eax
   14c6b:	8b 58 20             	mov    0x20(%eax),%ebx
   14c6e:	89 c8                	mov    %ecx,%eax
   14c70:	99                   	cltd   
   14c71:	f7 fb                	idiv   %ebx
   14c73:	89 c2                	mov    %eax,%edx
   14c75:	8b 45 08             	mov    0x8(%ebp),%eax
   14c78:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   14c7b:	8b 45 08             	mov    0x8(%ebp),%eax
   14c7e:	8b 50 14             	mov    0x14(%eax),%edx
   14c81:	8b 45 08             	mov    0x8(%ebp),%eax
   14c84:	8b 40 24             	mov    0x24(%eax),%eax
   14c87:	01 d0                	add    %edx,%eax
   14c89:	8d 48 ff             	lea    -0x1(%eax),%ecx
   14c8c:	8b 45 08             	mov    0x8(%ebp),%eax
   14c8f:	8b 58 24             	mov    0x24(%eax),%ebx
   14c92:	89 c8                	mov    %ecx,%eax
   14c94:	99                   	cltd   
   14c95:	f7 fb                	idiv   %ebx
   14c97:	89 c2                	mov    %eax,%edx
   14c99:	8b 45 08             	mov    0x8(%ebp),%eax
   14c9c:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   14c9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14ca6:	8b 45 08             	mov    0x8(%ebp),%eax
   14ca9:	83 c0 2c             	add    $0x2c,%eax
   14cac:	89 45 e8             	mov    %eax,-0x18(%ebp)
   14caf:	e9 fd 00 00 00       	jmp    14db1 <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   14cb4:	8b 45 08             	mov    0x8(%ebp),%eax
   14cb7:	8b 50 10             	mov    0x10(%eax),%edx
   14cba:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14cbd:	8b 40 04             	mov    0x4(%eax),%eax
   14cc0:	0f af d0             	imul   %eax,%edx
   14cc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14cc6:	01 d0                	add    %edx,%eax
   14cc8:	83 e8 01             	sub    $0x1,%eax
   14ccb:	99                   	cltd   
   14ccc:	f7 7d ec             	idivl  -0x14(%ebp)
   14ccf:	89 c2                	mov    %eax,%edx
   14cd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14cd4:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   14cd7:	8b 45 08             	mov    0x8(%ebp),%eax
   14cda:	8b 50 14             	mov    0x14(%eax),%edx
   14cdd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14ce0:	8b 40 08             	mov    0x8(%eax),%eax
   14ce3:	0f af d0             	imul   %eax,%edx
   14ce6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ce9:	01 d0                	add    %edx,%eax
   14ceb:	83 e8 01             	sub    $0x1,%eax
   14cee:	99                   	cltd   
   14cef:	f7 7d f0             	idivl  -0x10(%ebp)
   14cf2:	89 c2                	mov    %eax,%edx
   14cf4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14cf7:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   14cfa:	8b 45 08             	mov    0x8(%ebp),%eax
   14cfd:	8b 50 18             	mov    0x18(%eax),%edx
   14d00:	8b 45 08             	mov    0x8(%ebp),%eax
   14d03:	8b 40 20             	mov    0x20(%eax),%eax
   14d06:	0f af d0             	imul   %eax,%edx
   14d09:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14d0c:	8b 40 04             	mov    0x4(%eax),%eax
   14d0f:	0f af c2             	imul   %edx,%eax
   14d12:	99                   	cltd   
   14d13:	f7 7d ec             	idivl  -0x14(%ebp)
   14d16:	89 c2                	mov    %eax,%edx
   14d18:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14d1b:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   14d1e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14d21:	8b 40 0c             	mov    0xc(%eax),%eax
   14d24:	83 f8 02             	cmp    $0x2,%eax
   14d27:	7f 0b                	jg     14d34 <_DecodeSOF+0x377>
   14d29:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14d2c:	8b 40 04             	mov    0x4(%eax),%eax
   14d2f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14d32:	75 16                	jne    14d4a <_DecodeSOF+0x38d>
   14d34:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14d37:	8b 40 10             	mov    0x10(%eax),%eax
   14d3a:	83 f8 02             	cmp    $0x2,%eax
   14d3d:	7f 19                	jg     14d58 <_DecodeSOF+0x39b>
   14d3f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14d42:	8b 40 08             	mov    0x8(%eax),%eax
   14d45:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14d48:	74 0e                	je     14d58 <_DecodeSOF+0x39b>
   14d4a:	8b 45 08             	mov    0x8(%ebp),%eax
   14d4d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14d53:	e9 d2 00 00 00       	jmp    14e2a <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   14d58:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14d5b:	8b 48 14             	mov    0x14(%eax),%ecx
   14d5e:	8b 45 08             	mov    0x8(%ebp),%eax
   14d61:	8b 50 1c             	mov    0x1c(%eax),%edx
   14d64:	8b 45 08             	mov    0x8(%ebp),%eax
   14d67:	8b 40 24             	mov    0x24(%eax),%eax
   14d6a:	0f af d0             	imul   %eax,%edx
   14d6d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14d70:	8b 40 08             	mov    0x8(%eax),%eax
   14d73:	0f af c2             	imul   %edx,%eax
   14d76:	99                   	cltd   
   14d77:	f7 7d f0             	idivl  -0x10(%ebp)
   14d7a:	0f af c1             	imul   %ecx,%eax
   14d7d:	83 ec 0c             	sub    $0xc,%esp
   14d80:	50                   	push   %eax
   14d81:	e8 45 c5 fe ff       	call   12cb <malloc>
   14d86:	83 c4 10             	add    $0x10,%esp
   14d89:	89 c2                	mov    %eax,%edx
   14d8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14d8e:	89 50 28             	mov    %edx,0x28(%eax)
   14d91:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14d94:	8b 40 28             	mov    0x28(%eax),%eax
   14d97:	85 c0                	test   %eax,%eax
   14d99:	75 0e                	jne    14da9 <_DecodeSOF+0x3ec>
   14d9b:	8b 45 08             	mov    0x8(%ebp),%eax
   14d9e:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   14da4:	e9 81 00 00 00       	jmp    14e2a <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   14da9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14dad:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   14db1:	8b 45 08             	mov    0x8(%ebp),%eax
   14db4:	8b 40 28             	mov    0x28(%eax),%eax
   14db7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14dba:	0f 8f f4 fe ff ff    	jg     14cb4 <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   14dc0:	8b 45 08             	mov    0x8(%ebp),%eax
   14dc3:	8b 40 28             	mov    0x28(%eax),%eax
   14dc6:	83 f8 03             	cmp    $0x3,%eax
   14dc9:	75 47                	jne    14e12 <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   14dcb:	8b 45 08             	mov    0x8(%ebp),%eax
   14dce:	8b 50 10             	mov    0x10(%eax),%edx
   14dd1:	8b 45 08             	mov    0x8(%ebp),%eax
   14dd4:	8b 40 14             	mov    0x14(%eax),%eax
   14dd7:	0f af d0             	imul   %eax,%edx
   14dda:	8b 45 08             	mov    0x8(%ebp),%eax
   14ddd:	8b 40 28             	mov    0x28(%eax),%eax
   14de0:	0f af c2             	imul   %edx,%eax
   14de3:	83 ec 0c             	sub    $0xc,%esp
   14de6:	50                   	push   %eax
   14de7:	e8 df c4 fe ff       	call   12cb <malloc>
   14dec:	83 c4 10             	add    $0x10,%esp
   14def:	89 c2                	mov    %eax,%edx
   14df1:	8b 45 08             	mov    0x8(%ebp),%eax
   14df4:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   14dfa:	8b 45 08             	mov    0x8(%ebp),%eax
   14dfd:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   14e03:	85 c0                	test   %eax,%eax
   14e05:	75 0b                	jne    14e12 <_DecodeSOF+0x455>
   14e07:	8b 45 08             	mov    0x8(%ebp),%eax
   14e0a:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   14e10:	eb 18                	jmp    14e2a <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   14e12:	8b 45 08             	mov    0x8(%ebp),%eax
   14e15:	8b 40 0c             	mov    0xc(%eax),%eax
   14e18:	83 ec 08             	sub    $0x8,%esp
   14e1b:	50                   	push   %eax
   14e1c:	ff 75 08             	pushl  0x8(%ebp)
   14e1f:	e8 20 f9 ff ff       	call   14744 <_Skip>
   14e24:	83 c4 10             	add    $0x10,%esp
   14e27:	eb 01                	jmp    14e2a <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   14e29:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   14e2a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14e2d:	c9                   	leave  
   14e2e:	c3                   	ret    

00014e2f <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   14e2f:	55                   	push   %ebp
   14e30:	89 e5                	mov    %esp,%ebp
   14e32:	53                   	push   %ebx
   14e33:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   14e36:	83 ec 0c             	sub    $0xc,%esp
   14e39:	ff 75 08             	pushl  0x8(%ebp)
   14e3c:	e8 4f f9 ff ff       	call   14790 <_DecodeLength>
   14e41:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14e44:	8b 45 08             	mov    0x8(%ebp),%eax
   14e47:	8b 00                	mov    (%eax),%eax
   14e49:	85 c0                	test   %eax,%eax
   14e4b:	0f 85 c5 01 00 00    	jne    15016 <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   14e51:	e9 9c 01 00 00       	jmp    14ff2 <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   14e56:	8b 45 08             	mov    0x8(%ebp),%eax
   14e59:	8b 40 04             	mov    0x4(%eax),%eax
   14e5c:	0f b6 00             	movzbl (%eax),%eax
   14e5f:	0f b6 c0             	movzbl %al,%eax
   14e62:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   14e65:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14e68:	25 ec 00 00 00       	and    $0xec,%eax
   14e6d:	85 c0                	test   %eax,%eax
   14e6f:	74 0e                	je     14e7f <_DecodeDHT+0x50>
   14e71:	8b 45 08             	mov    0x8(%ebp),%eax
   14e74:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14e7a:	e9 98 01 00 00       	jmp    15017 <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   14e7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14e82:	83 e0 02             	and    $0x2,%eax
   14e85:	85 c0                	test   %eax,%eax
   14e87:	74 0e                	je     14e97 <_DecodeDHT+0x68>
   14e89:	8b 45 08             	mov    0x8(%ebp),%eax
   14e8c:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14e92:	e9 80 01 00 00       	jmp    15017 <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   14e97:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14e9a:	c1 f8 03             	sar    $0x3,%eax
   14e9d:	0b 45 f4             	or     -0xc(%ebp),%eax
   14ea0:	83 e0 03             	and    $0x3,%eax
   14ea3:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   14ea6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14ead:	eb 1c                	jmp    14ecb <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   14eaf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14eb2:	8d 50 ff             	lea    -0x1(%eax),%edx
   14eb5:	8b 45 08             	mov    0x8(%ebp),%eax
   14eb8:	8b 48 04             	mov    0x4(%eax),%ecx
   14ebb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ebe:	01 c8                	add    %ecx,%eax
   14ec0:	0f b6 00             	movzbl (%eax),%eax
   14ec3:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   14ec7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14ecb:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14ecf:	7e de                	jle    14eaf <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   14ed1:	83 ec 08             	sub    $0x8,%esp
   14ed4:	6a 11                	push   $0x11
   14ed6:	ff 75 08             	pushl  0x8(%ebp)
   14ed9:	e8 66 f8 ff ff       	call   14744 <_Skip>
   14ede:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   14ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14ee4:	c1 e0 11             	shl    $0x11,%eax
   14ee7:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14eed:	8b 45 08             	mov    0x8(%ebp),%eax
   14ef0:	01 d0                	add    %edx,%eax
   14ef2:	83 c0 08             	add    $0x8,%eax
   14ef5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   14ef8:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   14eff:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f02:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   14f05:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14f0c:	e9 be 00 00 00       	jmp    14fcf <_DecodeDHT+0x1a0>
            spread >>= 1;
   14f11:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   14f14:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f17:	83 e8 01             	sub    $0x1,%eax
   14f1a:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   14f1f:	0f b6 c0             	movzbl %al,%eax
   14f22:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   14f25:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14f29:	0f 84 9b 00 00 00    	je     14fca <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   14f2f:	8b 45 08             	mov    0x8(%ebp),%eax
   14f32:	8b 40 0c             	mov    0xc(%eax),%eax
   14f35:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   14f38:	7d 0e                	jge    14f48 <_DecodeDHT+0x119>
   14f3a:	8b 45 08             	mov    0x8(%ebp),%eax
   14f3d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14f43:	e9 cf 00 00 00       	jmp    15017 <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   14f48:	b8 10 00 00 00       	mov    $0x10,%eax
   14f4d:	2b 45 f0             	sub    -0x10(%ebp),%eax
   14f50:	8b 55 e0             	mov    -0x20(%ebp),%edx
   14f53:	89 c1                	mov    %eax,%ecx
   14f55:	d3 e2                	shl    %cl,%edx
   14f57:	89 d0                	mov    %edx,%eax
   14f59:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   14f5c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14f60:	79 0e                	jns    14f70 <_DecodeDHT+0x141>
   14f62:	8b 45 08             	mov    0x8(%ebp),%eax
   14f65:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14f6b:	e9 a7 00 00 00       	jmp    15017 <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   14f70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14f77:	eb 36                	jmp    14faf <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   14f79:	8b 45 08             	mov    0x8(%ebp),%eax
   14f7c:	8b 50 04             	mov    0x4(%eax),%edx
   14f7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14f82:	01 d0                	add    %edx,%eax
   14f84:	0f b6 00             	movzbl (%eax),%eax
   14f87:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   14f89:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   14f8c:	eb 14                	jmp    14fa2 <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   14f8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f91:	89 c2                	mov    %eax,%edx
   14f93:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14f96:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   14f98:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14f9b:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   14f9e:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   14fa2:	89 d8                	mov    %ebx,%eax
   14fa4:	8d 58 ff             	lea    -0x1(%eax),%ebx
   14fa7:	85 c0                	test   %eax,%eax
   14fa9:	75 e3                	jne    14f8e <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   14fab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14faf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14fb2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   14fb5:	7c c2                	jl     14f79 <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   14fb7:	83 ec 08             	sub    $0x8,%esp
   14fba:	ff 75 e0             	pushl  -0x20(%ebp)
   14fbd:	ff 75 08             	pushl  0x8(%ebp)
   14fc0:	e8 7f f7 ff ff       	call   14744 <_Skip>
   14fc5:	83 c4 10             	add    $0x10,%esp
   14fc8:	eb 01                	jmp    14fcb <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   14fca:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   14fcb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14fcf:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14fd3:	0f 8e 38 ff ff ff    	jle    14f11 <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14fd9:	eb 0a                	jmp    14fe5 <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   14fdb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14fde:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   14fe1:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14fe5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14fe8:	8d 50 ff             	lea    -0x1(%eax),%edx
   14feb:	89 55 ec             	mov    %edx,-0x14(%ebp)
   14fee:	85 c0                	test   %eax,%eax
   14ff0:	75 e9                	jne    14fdb <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   14ff2:	8b 45 08             	mov    0x8(%ebp),%eax
   14ff5:	8b 40 0c             	mov    0xc(%eax),%eax
   14ff8:	83 f8 10             	cmp    $0x10,%eax
   14ffb:	0f 8f 55 fe ff ff    	jg     14e56 <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   15001:	8b 45 08             	mov    0x8(%ebp),%eax
   15004:	8b 40 0c             	mov    0xc(%eax),%eax
   15007:	85 c0                	test   %eax,%eax
   15009:	74 0c                	je     15017 <_DecodeDHT+0x1e8>
   1500b:	8b 45 08             	mov    0x8(%ebp),%eax
   1500e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15014:	eb 01                	jmp    15017 <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   15016:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   15017:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1501a:	c9                   	leave  
   1501b:	c3                   	ret    

0001501c <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   1501c:	55                   	push   %ebp
   1501d:	89 e5                	mov    %esp,%ebp
   1501f:	53                   	push   %ebx
   15020:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   15023:	83 ec 0c             	sub    $0xc,%esp
   15026:	ff 75 08             	pushl  0x8(%ebp)
   15029:	e8 62 f7 ff ff       	call   14790 <_DecodeLength>
   1502e:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   15031:	8b 45 08             	mov    0x8(%ebp),%eax
   15034:	8b 00                	mov    (%eax),%eax
   15036:	85 c0                	test   %eax,%eax
   15038:	0f 85 e2 00 00 00    	jne    15120 <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   1503e:	e9 b8 00 00 00       	jmp    150fb <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   15043:	8b 45 08             	mov    0x8(%ebp),%eax
   15046:	8b 40 04             	mov    0x4(%eax),%eax
   15049:	0f b6 00             	movzbl (%eax),%eax
   1504c:	0f b6 c0             	movzbl %al,%eax
   1504f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   15052:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15055:	25 ec 00 00 00       	and    $0xec,%eax
   1505a:	85 c0                	test   %eax,%eax
   1505c:	74 0e                	je     1506c <_DecodeDQT+0x50>
   1505e:	8b 45 08             	mov    0x8(%ebp),%eax
   15061:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15067:	e9 b5 00 00 00       	jmp    15121 <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   1506c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1506f:	83 e0 10             	and    $0x10,%eax
   15072:	85 c0                	test   %eax,%eax
   15074:	74 0e                	je     15084 <_DecodeDQT+0x68>
   15076:	8b 45 08             	mov    0x8(%ebp),%eax
   15079:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1507f:	e9 9d 00 00 00       	jmp    15121 <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   15084:	8b 45 08             	mov    0x8(%ebp),%eax
   15087:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   1508d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15090:	bb 01 00 00 00       	mov    $0x1,%ebx
   15095:	89 c1                	mov    %eax,%ecx
   15097:	d3 e3                	shl    %cl,%ebx
   15099:	89 d8                	mov    %ebx,%eax
   1509b:	09 c2                	or     %eax,%edx
   1509d:	8b 45 08             	mov    0x8(%ebp),%eax
   150a0:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   150a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   150a9:	c1 e0 06             	shl    $0x6,%eax
   150ac:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   150b2:	8b 45 08             	mov    0x8(%ebp),%eax
   150b5:	01 d0                	add    %edx,%eax
   150b7:	83 c0 08             	add    $0x8,%eax
   150ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   150bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   150c4:	eb 1f                	jmp    150e5 <_DecodeDQT+0xc9>
   150c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   150c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   150cc:	01 c2                	add    %eax,%edx
   150ce:	8b 45 08             	mov    0x8(%ebp),%eax
   150d1:	8b 40 04             	mov    0x4(%eax),%eax
   150d4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   150d7:	83 c1 01             	add    $0x1,%ecx
   150da:	01 c8                	add    %ecx,%eax
   150dc:	0f b6 00             	movzbl (%eax),%eax
   150df:	88 02                	mov    %al,(%edx)
   150e1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   150e5:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   150e9:	7e db                	jle    150c6 <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   150eb:	83 ec 08             	sub    $0x8,%esp
   150ee:	6a 41                	push   $0x41
   150f0:	ff 75 08             	pushl  0x8(%ebp)
   150f3:	e8 4c f6 ff ff       	call   14744 <_Skip>
   150f8:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   150fb:	8b 45 08             	mov    0x8(%ebp),%eax
   150fe:	8b 40 0c             	mov    0xc(%eax),%eax
   15101:	83 f8 40             	cmp    $0x40,%eax
   15104:	0f 8f 39 ff ff ff    	jg     15043 <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   1510a:	8b 45 08             	mov    0x8(%ebp),%eax
   1510d:	8b 40 0c             	mov    0xc(%eax),%eax
   15110:	85 c0                	test   %eax,%eax
   15112:	74 0d                	je     15121 <_DecodeDQT+0x105>
   15114:	8b 45 08             	mov    0x8(%ebp),%eax
   15117:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1511d:	90                   	nop
   1511e:	eb 01                	jmp    15121 <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   15120:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   15121:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15124:	c9                   	leave  
   15125:	c3                   	ret    

00015126 <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   15126:	55                   	push   %ebp
   15127:	89 e5                	mov    %esp,%ebp
   15129:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   1512c:	83 ec 0c             	sub    $0xc,%esp
   1512f:	ff 75 08             	pushl  0x8(%ebp)
   15132:	e8 59 f6 ff ff       	call   14790 <_DecodeLength>
   15137:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1513a:	8b 45 08             	mov    0x8(%ebp),%eax
   1513d:	8b 00                	mov    (%eax),%eax
   1513f:	85 c0                	test   %eax,%eax
   15141:	75 4a                	jne    1518d <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   15143:	8b 45 08             	mov    0x8(%ebp),%eax
   15146:	8b 40 0c             	mov    0xc(%eax),%eax
   15149:	83 f8 01             	cmp    $0x1,%eax
   1514c:	7f 0b                	jg     15159 <_DecodeDRI+0x33>
   1514e:	8b 45 08             	mov    0x8(%ebp),%eax
   15151:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15157:	eb 35                	jmp    1518e <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   15159:	8b 45 08             	mov    0x8(%ebp),%eax
   1515c:	8b 40 04             	mov    0x4(%eax),%eax
   1515f:	83 ec 0c             	sub    $0xc,%esp
   15162:	50                   	push   %eax
   15163:	e8 8b f6 ff ff       	call   147f3 <_Decode2Bytes>
   15168:	83 c4 10             	add    $0x10,%esp
   1516b:	89 c2                	mov    %eax,%edx
   1516d:	8b 45 08             	mov    0x8(%ebp),%eax
   15170:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   15176:	8b 45 08             	mov    0x8(%ebp),%eax
   15179:	8b 40 0c             	mov    0xc(%eax),%eax
   1517c:	83 ec 08             	sub    $0x8,%esp
   1517f:	50                   	push   %eax
   15180:	ff 75 08             	pushl  0x8(%ebp)
   15183:	e8 bc f5 ff ff       	call   14744 <_Skip>
   15188:	83 c4 10             	add    $0x10,%esp
   1518b:	eb 01                	jmp    1518e <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   1518d:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   1518e:	c9                   	leave  
   1518f:	c3                   	ret    

00015190 <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   15190:	55                   	push   %ebp
   15191:	89 e5                	mov    %esp,%ebp
   15193:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   15196:	8b 45 08             	mov    0x8(%ebp),%eax
   15199:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   1519f:	89 45 e0             	mov    %eax,-0x20(%ebp)
   151a2:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   151a9:	83 ec 0c             	sub    $0xc,%esp
   151ac:	ff 75 08             	pushl  0x8(%ebp)
   151af:	e8 dc f5 ff ff       	call   14790 <_DecodeLength>
   151b4:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   151b7:	8b 45 08             	mov    0x8(%ebp),%eax
   151ba:	8b 00                	mov    (%eax),%eax
   151bc:	85 c0                	test   %eax,%eax
   151be:	0f 85 c2 02 00 00    	jne    15486 <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   151c4:	8b 45 08             	mov    0x8(%ebp),%eax
   151c7:	8b 50 0c             	mov    0xc(%eax),%edx
   151ca:	8b 45 08             	mov    0x8(%ebp),%eax
   151cd:	8b 40 28             	mov    0x28(%eax),%eax
   151d0:	83 c0 02             	add    $0x2,%eax
   151d3:	01 c0                	add    %eax,%eax
   151d5:	39 c2                	cmp    %eax,%edx
   151d7:	7c 16                	jl     151ef <_DecodeSOS+0x5f>
   151d9:	8b 45 08             	mov    0x8(%ebp),%eax
   151dc:	8b 40 04             	mov    0x4(%eax),%eax
   151df:	0f b6 00             	movzbl (%eax),%eax
   151e2:	0f b6 d0             	movzbl %al,%edx
   151e5:	8b 45 08             	mov    0x8(%ebp),%eax
   151e8:	8b 40 28             	mov    0x28(%eax),%eax
   151eb:	39 c2                	cmp    %eax,%edx
   151ed:	74 0e                	je     151fd <_DecodeSOS+0x6d>
   151ef:	8b 45 08             	mov    0x8(%ebp),%eax
   151f2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   151f8:	e9 8d 02 00 00       	jmp    1548a <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   151fd:	83 ec 08             	sub    $0x8,%esp
   15200:	6a 01                	push   $0x1
   15202:	ff 75 08             	pushl  0x8(%ebp)
   15205:	e8 3a f5 ff ff       	call   14744 <_Skip>
   1520a:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1520d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15214:	8b 45 08             	mov    0x8(%ebp),%eax
   15217:	83 c0 2c             	add    $0x2c,%eax
   1521a:	89 45 dc             	mov    %eax,-0x24(%ebp)
   1521d:	e9 ba 00 00 00       	jmp    152dc <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   15222:	8b 45 08             	mov    0x8(%ebp),%eax
   15225:	8b 40 04             	mov    0x4(%eax),%eax
   15228:	0f b6 00             	movzbl (%eax),%eax
   1522b:	0f b6 d0             	movzbl %al,%edx
   1522e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15231:	8b 00                	mov    (%eax),%eax
   15233:	39 c2                	cmp    %eax,%edx
   15235:	74 0e                	je     15245 <_DecodeSOS+0xb5>
   15237:	8b 45 08             	mov    0x8(%ebp),%eax
   1523a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15240:	e9 45 02 00 00       	jmp    1548a <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   15245:	8b 45 08             	mov    0x8(%ebp),%eax
   15248:	8b 40 04             	mov    0x4(%eax),%eax
   1524b:	83 c0 01             	add    $0x1,%eax
   1524e:	0f b6 00             	movzbl (%eax),%eax
   15251:	0f b6 c0             	movzbl %al,%eax
   15254:	25 ec 00 00 00       	and    $0xec,%eax
   15259:	85 c0                	test   %eax,%eax
   1525b:	74 0e                	je     1526b <_DecodeSOS+0xdb>
   1525d:	8b 45 08             	mov    0x8(%ebp),%eax
   15260:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15266:	e9 1f 02 00 00       	jmp    1548a <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   1526b:	8b 45 08             	mov    0x8(%ebp),%eax
   1526e:	8b 40 04             	mov    0x4(%eax),%eax
   15271:	83 c0 01             	add    $0x1,%eax
   15274:	0f b6 00             	movzbl (%eax),%eax
   15277:	0f b6 c0             	movzbl %al,%eax
   1527a:	83 e0 02             	and    $0x2,%eax
   1527d:	85 c0                	test   %eax,%eax
   1527f:	74 0e                	je     1528f <_DecodeSOS+0xff>
   15281:	8b 45 08             	mov    0x8(%ebp),%eax
   15284:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1528a:	e9 fb 01 00 00       	jmp    1548a <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   1528f:	8b 45 08             	mov    0x8(%ebp),%eax
   15292:	8b 40 04             	mov    0x4(%eax),%eax
   15295:	83 c0 01             	add    $0x1,%eax
   15298:	0f b6 00             	movzbl (%eax),%eax
   1529b:	c0 e8 04             	shr    $0x4,%al
   1529e:	0f b6 d0             	movzbl %al,%edx
   152a1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   152a4:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   152a7:	8b 45 08             	mov    0x8(%ebp),%eax
   152aa:	8b 40 04             	mov    0x4(%eax),%eax
   152ad:	83 c0 01             	add    $0x1,%eax
   152b0:	0f b6 00             	movzbl (%eax),%eax
   152b3:	0f b6 c0             	movzbl %al,%eax
   152b6:	83 e0 01             	and    $0x1,%eax
   152b9:	83 c8 02             	or     $0x2,%eax
   152bc:	89 c2                	mov    %eax,%edx
   152be:	8b 45 dc             	mov    -0x24(%ebp),%eax
   152c1:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   152c4:	83 ec 08             	sub    $0x8,%esp
   152c7:	6a 02                	push   $0x2
   152c9:	ff 75 08             	pushl  0x8(%ebp)
   152cc:	e8 73 f4 ff ff       	call   14744 <_Skip>
   152d1:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   152d4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   152d8:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   152dc:	8b 45 08             	mov    0x8(%ebp),%eax
   152df:	8b 40 28             	mov    0x28(%eax),%eax
   152e2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   152e5:	0f 8f 37 ff ff ff    	jg     15222 <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   152eb:	8b 45 08             	mov    0x8(%ebp),%eax
   152ee:	8b 40 04             	mov    0x4(%eax),%eax
   152f1:	0f b6 00             	movzbl (%eax),%eax
   152f4:	84 c0                	test   %al,%al
   152f6:	75 10                	jne    15308 <_DecodeSOS+0x178>
   152f8:	8b 45 08             	mov    0x8(%ebp),%eax
   152fb:	8b 40 04             	mov    0x4(%eax),%eax
   152fe:	83 c0 01             	add    $0x1,%eax
   15301:	0f b6 00             	movzbl (%eax),%eax
   15304:	3c 3f                	cmp    $0x3f,%al
   15306:	74 0e                	je     15316 <_DecodeSOS+0x186>
   15308:	8b 45 08             	mov    0x8(%ebp),%eax
   1530b:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15311:	e9 74 01 00 00       	jmp    1548a <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   15316:	8b 45 08             	mov    0x8(%ebp),%eax
   15319:	8b 40 04             	mov    0x4(%eax),%eax
   1531c:	83 c0 02             	add    $0x2,%eax
   1531f:	0f b6 00             	movzbl (%eax),%eax
   15322:	84 c0                	test   %al,%al
   15324:	74 0e                	je     15334 <_DecodeSOS+0x1a4>
   15326:	8b 45 08             	mov    0x8(%ebp),%eax
   15329:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1532f:	e9 56 01 00 00       	jmp    1548a <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   15334:	8b 45 08             	mov    0x8(%ebp),%eax
   15337:	8b 40 0c             	mov    0xc(%eax),%eax
   1533a:	83 ec 08             	sub    $0x8,%esp
   1533d:	50                   	push   %eax
   1533e:	ff 75 08             	pushl  0x8(%ebp)
   15341:	e8 fe f3 ff ff       	call   14744 <_Skip>
   15346:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   15349:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15350:	e9 17 01 00 00       	jmp    1546c <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   15355:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1535c:	e9 f8 00 00 00       	jmp    15459 <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   15361:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15368:	8b 45 08             	mov    0x8(%ebp),%eax
   1536b:	83 c0 2c             	add    $0x2c,%eax
   1536e:	89 45 dc             	mov    %eax,-0x24(%ebp)
   15371:	e9 8d 00 00 00       	jmp    15403 <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   15376:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1537d:	eb 71                	jmp    153f0 <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   1537f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   15386:	eb 59                	jmp    153e1 <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   15388:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1538b:	8b 50 28             	mov    0x28(%eax),%edx
   1538e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15391:	8b 40 08             	mov    0x8(%eax),%eax
   15394:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15398:	89 c1                	mov    %eax,%ecx
   1539a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1539d:	01 c1                	add    %eax,%ecx
   1539f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   153a2:	8b 40 14             	mov    0x14(%eax),%eax
   153a5:	0f af c8             	imul   %eax,%ecx
   153a8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   153ab:	8b 40 04             	mov    0x4(%eax),%eax
   153ae:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   153b2:	01 c1                	add    %eax,%ecx
   153b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   153b7:	01 c8                	add    %ecx,%eax
   153b9:	c1 e0 03             	shl    $0x3,%eax
   153bc:	01 d0                	add    %edx,%eax
   153be:	50                   	push   %eax
   153bf:	ff 75 dc             	pushl  -0x24(%ebp)
   153c2:	ff 75 0c             	pushl  0xc(%ebp)
   153c5:	ff 75 08             	pushl  0x8(%ebp)
   153c8:	e8 bf 00 00 00       	call   1548c <_DecodeBlock>
   153cd:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   153d0:	8b 45 08             	mov    0x8(%ebp),%eax
   153d3:	8b 00                	mov    (%eax),%eax
   153d5:	85 c0                	test   %eax,%eax
   153d7:	0f 85 ac 00 00 00    	jne    15489 <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   153dd:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   153e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   153e4:	8b 40 04             	mov    0x4(%eax),%eax
   153e7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   153ea:	7f 9c                	jg     15388 <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   153ec:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   153f0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   153f3:	8b 40 08             	mov    0x8(%eax),%eax
   153f6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   153f9:	7f 84                	jg     1537f <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   153fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   153ff:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   15403:	8b 45 08             	mov    0x8(%ebp),%eax
   15406:	8b 40 28             	mov    0x28(%eax),%eax
   15409:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1540c:	0f 8f 64 ff ff ff    	jg     15376 <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   15412:	8b 45 08             	mov    0x8(%ebp),%eax
   15415:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   1541b:	85 c0                	test   %eax,%eax
   1541d:	74 36                	je     15455 <_DecodeSOS+0x2c5>
   1541f:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   15423:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15427:	75 2c                	jne    15455 <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   15429:	83 ec 0c             	sub    $0xc,%esp
   1542c:	ff 75 08             	pushl  0x8(%ebp)
   1542f:	e8 9f 0a 00 00       	call   15ed3 <_ByteAlign>
   15434:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   15437:	83 ec 08             	sub    $0x8,%esp
   1543a:	6a 10                	push   $0x10
   1543c:	ff 75 08             	pushl  0x8(%ebp)
   1543f:	e8 ce 04 00 00       	call   15912 <_GetBits>
   15444:	83 c4 10             	add    $0x10,%esp
   15447:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   1544a:	8b 45 08             	mov    0x8(%ebp),%eax
   1544d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15453:	eb 35                	jmp    1548a <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   15455:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15459:	8b 45 08             	mov    0x8(%ebp),%eax
   1545c:	8b 40 18             	mov    0x18(%eax),%eax
   1545f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   15462:	0f 8f f9 fe ff ff    	jg     15361 <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   15468:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1546c:	8b 45 08             	mov    0x8(%ebp),%eax
   1546f:	8b 40 1c             	mov    0x1c(%eax),%eax
   15472:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   15475:	0f 8f da fe ff ff    	jg     15355 <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   1547b:	8b 45 08             	mov    0x8(%ebp),%eax
   1547e:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   15484:	eb 04                	jmp    1548a <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   15486:	90                   	nop
   15487:	eb 01                	jmp    1548a <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   15489:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   1548a:	c9                   	leave  
   1548b:	c3                   	ret    

0001548c <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   1548c:	55                   	push   %ebp
   1548d:	89 e5                	mov    %esp,%ebp
   1548f:	53                   	push   %ebx
   15490:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   15493:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   1549a:	8b 45 08             	mov    0x8(%ebp),%eax
   1549d:	05 c0 01 08 00       	add    $0x801c0,%eax
   154a2:	83 ec 04             	sub    $0x4,%esp
   154a5:	68 00 01 00 00       	push   $0x100
   154aa:	6a 00                	push   $0x0
   154ac:	50                   	push   %eax
   154ad:	e8 04 b8 fe ff       	call   cb6 <memset>
   154b2:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   154b5:	8b 45 10             	mov    0x10(%ebp),%eax
   154b8:	8b 40 20             	mov    0x20(%eax),%eax
   154bb:	c1 e0 11             	shl    $0x11,%eax
   154be:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   154c4:	8b 45 08             	mov    0x8(%ebp),%eax
   154c7:	01 d0                	add    %edx,%eax
   154c9:	83 c0 08             	add    $0x8,%eax
   154cc:	83 ec 04             	sub    $0x4,%esp
   154cf:	6a 00                	push   $0x0
   154d1:	50                   	push   %eax
   154d2:	ff 75 08             	pushl  0x8(%ebp)
   154d5:	e8 86 01 00 00       	call   15660 <_GetVLC>
   154da:	83 c4 10             	add    $0x10,%esp
   154dd:	89 c2                	mov    %eax,%edx
   154df:	8b 45 10             	mov    0x10(%ebp),%eax
   154e2:	8b 40 24             	mov    0x24(%eax),%eax
   154e5:	01 c2                	add    %eax,%edx
   154e7:	8b 45 10             	mov    0x10(%ebp),%eax
   154ea:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   154ed:	8b 45 10             	mov    0x10(%ebp),%eax
   154f0:	8b 50 24             	mov    0x24(%eax),%edx
   154f3:	8b 45 10             	mov    0x10(%ebp),%eax
   154f6:	8b 48 18             	mov    0x18(%eax),%ecx
   154f9:	8b 45 08             	mov    0x8(%ebp),%eax
   154fc:	c1 e1 06             	shl    $0x6,%ecx
   154ff:	01 c8                	add    %ecx,%eax
   15501:	05 b8 00 00 00       	add    $0xb8,%eax
   15506:	0f b6 00             	movzbl (%eax),%eax
   15509:	0f b6 c0             	movzbl %al,%eax
   1550c:	0f af d0             	imul   %eax,%edx
   1550f:	8b 45 08             	mov    0x8(%ebp),%eax
   15512:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   15518:	8b 45 10             	mov    0x10(%ebp),%eax
   1551b:	8b 40 1c             	mov    0x1c(%eax),%eax
   1551e:	c1 e0 11             	shl    $0x11,%eax
   15521:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   15527:	8b 45 08             	mov    0x8(%ebp),%eax
   1552a:	01 d0                	add    %edx,%eax
   1552c:	8d 50 08             	lea    0x8(%eax),%edx
   1552f:	83 ec 04             	sub    $0x4,%esp
   15532:	8d 45 ef             	lea    -0x11(%ebp),%eax
   15535:	50                   	push   %eax
   15536:	52                   	push   %edx
   15537:	ff 75 08             	pushl  0x8(%ebp)
   1553a:	e8 21 01 00 00       	call   15660 <_GetVLC>
   1553f:	83 c4 10             	add    $0x10,%esp
   15542:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   15545:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   15549:	84 c0                	test   %al,%al
   1554b:	0f 84 92 00 00 00    	je     155e3 <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   15551:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   15555:	0f b6 c0             	movzbl %al,%eax
   15558:	83 e0 0f             	and    $0xf,%eax
   1555b:	85 c0                	test   %eax,%eax
   1555d:	75 16                	jne    15575 <_DecodeBlock+0xe9>
   1555f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   15563:	3c f0                	cmp    $0xf0,%al
   15565:	74 0e                	je     15575 <_DecodeBlock+0xe9>
   15567:	8b 45 08             	mov    0x8(%ebp),%eax
   1556a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15570:	e9 e6 00 00 00       	jmp    1565b <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   15575:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   15579:	c0 e8 04             	shr    $0x4,%al
   1557c:	0f b6 c0             	movzbl %al,%eax
   1557f:	83 c0 01             	add    $0x1,%eax
   15582:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   15585:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   15589:	7e 0e                	jle    15599 <_DecodeBlock+0x10d>
   1558b:	8b 45 08             	mov    0x8(%ebp),%eax
   1558e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15594:	e9 c2 00 00 00       	jmp    1565b <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   15599:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1559c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1559f:	01 d0                	add    %edx,%eax
   155a1:	0f b6 00             	movzbl (%eax),%eax
   155a4:	0f be c8             	movsbl %al,%ecx
   155a7:	8b 45 10             	mov    0x10(%ebp),%eax
   155aa:	8b 50 18             	mov    0x18(%eax),%edx
   155ad:	8b 45 08             	mov    0x8(%ebp),%eax
   155b0:	c1 e2 06             	shl    $0x6,%edx
   155b3:	01 c2                	add    %eax,%edx
   155b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   155b8:	01 d0                	add    %edx,%eax
   155ba:	05 b8 00 00 00       	add    $0xb8,%eax
   155bf:	0f b6 00             	movzbl (%eax),%eax
   155c2:	0f b6 c0             	movzbl %al,%eax
   155c5:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   155c9:	89 c2                	mov    %eax,%edx
   155cb:	8b 45 08             	mov    0x8(%ebp),%eax
   155ce:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   155d4:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   155d7:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   155db:	0f 8e 37 ff ff ff    	jle    15518 <_DecodeBlock+0x8c>
   155e1:	eb 01                	jmp    155e4 <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   155e3:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   155e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   155eb:	eb 24                	jmp    15611 <_DecodeBlock+0x185>
   155ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
   155f0:	05 70 00 02 00       	add    $0x20070,%eax
   155f5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   155fc:	8b 45 08             	mov    0x8(%ebp),%eax
   155ff:	01 d0                	add    %edx,%eax
   15601:	83 ec 0c             	sub    $0xc,%esp
   15604:	50                   	push   %eax
   15605:	e8 32 03 00 00       	call   1593c <_RowIDCT>
   1560a:	83 c4 10             	add    $0x10,%esp
   1560d:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   15611:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   15615:	7e d6                	jle    155ed <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   15617:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1561e:	eb 35                	jmp    15655 <_DecodeBlock+0x1c9>
   15620:	8b 45 10             	mov    0x10(%ebp),%eax
   15623:	8b 40 14             	mov    0x14(%eax),%eax
   15626:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   15629:	8b 55 14             	mov    0x14(%ebp),%edx
   1562c:	01 d1                	add    %edx,%ecx
   1562e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15631:	81 c2 70 00 02 00    	add    $0x20070,%edx
   15637:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   1563e:	8b 55 08             	mov    0x8(%ebp),%edx
   15641:	01 da                	add    %ebx,%edx
   15643:	83 ec 04             	sub    $0x4,%esp
   15646:	50                   	push   %eax
   15647:	51                   	push   %ecx
   15648:	52                   	push   %edx
   15649:	e8 7b 05 00 00       	call   15bc9 <_ColIDCT>
   1564e:	83 c4 10             	add    $0x10,%esp
   15651:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15655:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   15659:	7e c5                	jle    15620 <_DecodeBlock+0x194>
}
   1565b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1565e:	c9                   	leave  
   1565f:	c3                   	ret    

00015660 <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   15660:	55                   	push   %ebp
   15661:	89 e5                	mov    %esp,%ebp
   15663:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   15666:	83 ec 08             	sub    $0x8,%esp
   15669:	6a 10                	push   $0x10
   1566b:	ff 75 08             	pushl  0x8(%ebp)
   1566e:	e8 c2 00 00 00       	call   15735 <_ShowBits>
   15673:	83 c4 10             	add    $0x10,%esp
   15676:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   15679:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1567c:	8d 14 00             	lea    (%eax,%eax,1),%edx
   1567f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15682:	01 d0                	add    %edx,%eax
   15684:	0f b6 00             	movzbl (%eax),%eax
   15687:	0f b6 c0             	movzbl %al,%eax
   1568a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   1568d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15691:	75 13                	jne    156a6 <_GetVLC+0x46>
   15693:	8b 45 08             	mov    0x8(%ebp),%eax
   15696:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1569c:	b8 00 00 00 00       	mov    $0x0,%eax
   156a1:	e9 8d 00 00 00       	jmp    15733 <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   156a6:	83 ec 08             	sub    $0x8,%esp
   156a9:	ff 75 f0             	pushl  -0x10(%ebp)
   156ac:	ff 75 08             	pushl  0x8(%ebp)
   156af:	e8 25 02 00 00       	call   158d9 <_SkipBits>
   156b4:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   156b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156ba:	8d 14 00             	lea    (%eax,%eax,1),%edx
   156bd:	8b 45 0c             	mov    0xc(%ebp),%eax
   156c0:	01 d0                	add    %edx,%eax
   156c2:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   156c6:	0f b6 c0             	movzbl %al,%eax
   156c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   156cc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   156d0:	74 0a                	je     156dc <_GetVLC+0x7c>
   156d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156d5:	89 c2                	mov    %eax,%edx
   156d7:	8b 45 10             	mov    0x10(%ebp),%eax
   156da:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   156dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156df:	83 e0 0f             	and    $0xf,%eax
   156e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   156e5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   156e9:	75 07                	jne    156f2 <_GetVLC+0x92>
   156eb:	b8 00 00 00 00       	mov    $0x0,%eax
   156f0:	eb 41                	jmp    15733 <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   156f2:	83 ec 08             	sub    $0x8,%esp
   156f5:	ff 75 f0             	pushl  -0x10(%ebp)
   156f8:	ff 75 08             	pushl  0x8(%ebp)
   156fb:	e8 12 02 00 00       	call   15912 <_GetBits>
   15700:	83 c4 10             	add    $0x10,%esp
   15703:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   15706:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15709:	83 e8 01             	sub    $0x1,%eax
   1570c:	ba 01 00 00 00       	mov    $0x1,%edx
   15711:	89 c1                	mov    %eax,%ecx
   15713:	d3 e2                	shl    %cl,%edx
   15715:	89 d0                	mov    %edx,%eax
   15717:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1571a:	7e 14                	jle    15730 <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   1571c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1571f:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   15724:	89 c1                	mov    %eax,%ecx
   15726:	d3 e2                	shl    %cl,%edx
   15728:	89 d0                	mov    %edx,%eax
   1572a:	83 c0 01             	add    $0x1,%eax
   1572d:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   15730:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   15733:	c9                   	leave  
   15734:	c3                   	ret    

00015735 <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   15735:	55                   	push   %ebp
   15736:	89 e5                	mov    %esp,%ebp
   15738:	53                   	push   %ebx
   15739:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   1573c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   15740:	0f 85 4f 01 00 00    	jne    15895 <_ShowBits+0x160>
   15746:	b8 00 00 00 00       	mov    $0x0,%eax
   1574b:	e9 83 01 00 00       	jmp    158d3 <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   15750:	8b 45 08             	mov    0x8(%ebp),%eax
   15753:	8b 40 08             	mov    0x8(%eax),%eax
   15756:	85 c0                	test   %eax,%eax
   15758:	7f 33                	jg     1578d <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   1575a:	8b 45 08             	mov    0x8(%ebp),%eax
   1575d:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   15763:	c1 e0 08             	shl    $0x8,%eax
   15766:	0c ff                	or     $0xff,%al
   15768:	89 c2                	mov    %eax,%edx
   1576a:	8b 45 08             	mov    0x8(%ebp),%eax
   1576d:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   15773:	8b 45 08             	mov    0x8(%ebp),%eax
   15776:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1577c:	8d 50 08             	lea    0x8(%eax),%edx
   1577f:	8b 45 08             	mov    0x8(%ebp),%eax
   15782:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   15788:	e9 08 01 00 00       	jmp    15895 <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   1578d:	8b 45 08             	mov    0x8(%ebp),%eax
   15790:	8b 40 04             	mov    0x4(%eax),%eax
   15793:	8d 48 01             	lea    0x1(%eax),%ecx
   15796:	8b 55 08             	mov    0x8(%ebp),%edx
   15799:	89 4a 04             	mov    %ecx,0x4(%edx)
   1579c:	0f b6 00             	movzbl (%eax),%eax
   1579f:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   157a2:	8b 45 08             	mov    0x8(%ebp),%eax
   157a5:	8b 40 08             	mov    0x8(%eax),%eax
   157a8:	8d 50 ff             	lea    -0x1(%eax),%edx
   157ab:	8b 45 08             	mov    0x8(%ebp),%eax
   157ae:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   157b1:	8b 45 08             	mov    0x8(%ebp),%eax
   157b4:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   157ba:	8d 50 08             	lea    0x8(%eax),%edx
   157bd:	8b 45 08             	mov    0x8(%ebp),%eax
   157c0:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   157c6:	8b 45 08             	mov    0x8(%ebp),%eax
   157c9:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   157cf:	c1 e0 08             	shl    $0x8,%eax
   157d2:	89 c2                	mov    %eax,%edx
   157d4:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   157d8:	09 c2                	or     %eax,%edx
   157da:	8b 45 08             	mov    0x8(%ebp),%eax
   157dd:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   157e3:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   157e7:	0f 85 a8 00 00 00    	jne    15895 <_ShowBits+0x160>
            if(ctx->size){
   157ed:	8b 45 08             	mov    0x8(%ebp),%eax
   157f0:	8b 40 08             	mov    0x8(%eax),%eax
   157f3:	85 c0                	test   %eax,%eax
   157f5:	0f 84 91 00 00 00    	je     1588c <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   157fb:	8b 45 08             	mov    0x8(%ebp),%eax
   157fe:	8b 40 04             	mov    0x4(%eax),%eax
   15801:	8d 48 01             	lea    0x1(%eax),%ecx
   15804:	8b 55 08             	mov    0x8(%ebp),%edx
   15807:	89 4a 04             	mov    %ecx,0x4(%edx)
   1580a:	0f b6 00             	movzbl (%eax),%eax
   1580d:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   15810:	8b 45 08             	mov    0x8(%ebp),%eax
   15813:	8b 40 08             	mov    0x8(%eax),%eax
   15816:	8d 50 ff             	lea    -0x1(%eax),%edx
   15819:	8b 45 08             	mov    0x8(%ebp),%eax
   1581c:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   1581f:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   15823:	85 c0                	test   %eax,%eax
   15825:	74 62                	je     15889 <_ShowBits+0x154>
   15827:	3d d9 00 00 00       	cmp    $0xd9,%eax
   1582c:	75 0c                	jne    1583a <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   1582e:	8b 45 08             	mov    0x8(%ebp),%eax
   15831:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   15838:	eb 5b                	jmp    15895 <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   1583a:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   1583e:	25 f8 00 00 00       	and    $0xf8,%eax
   15843:	3d d0 00 00 00       	cmp    $0xd0,%eax
   15848:	74 0b                	je     15855 <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   1584a:	8b 45 08             	mov    0x8(%ebp),%eax
   1584d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15853:	eb 40                	jmp    15895 <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   15855:	8b 45 08             	mov    0x8(%ebp),%eax
   15858:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   1585e:	c1 e0 08             	shl    $0x8,%eax
   15861:	89 c2                	mov    %eax,%edx
   15863:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   15867:	09 c2                	or     %eax,%edx
   15869:	8b 45 08             	mov    0x8(%ebp),%eax
   1586c:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   15872:	8b 45 08             	mov    0x8(%ebp),%eax
   15875:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1587b:	8d 50 08             	lea    0x8(%eax),%edx
   1587e:	8b 45 08             	mov    0x8(%ebp),%eax
   15881:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   15887:	eb 0c                	jmp    15895 <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   15889:	90                   	nop
   1588a:	eb 09                	jmp    15895 <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   1588c:	8b 45 08             	mov    0x8(%ebp),%eax
   1588f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   15895:	8b 45 08             	mov    0x8(%ebp),%eax
   15898:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1589e:	3b 45 0c             	cmp    0xc(%ebp),%eax
   158a1:	0f 8c a9 fe ff ff    	jl     15750 <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   158a7:	8b 45 08             	mov    0x8(%ebp),%eax
   158aa:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   158b0:	8b 45 08             	mov    0x8(%ebp),%eax
   158b3:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   158b9:	2b 45 0c             	sub    0xc(%ebp),%eax
   158bc:	89 c1                	mov    %eax,%ecx
   158be:	d3 fa                	sar    %cl,%edx
   158c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   158c3:	bb 01 00 00 00       	mov    $0x1,%ebx
   158c8:	89 c1                	mov    %eax,%ecx
   158ca:	d3 e3                	shl    %cl,%ebx
   158cc:	89 d8                	mov    %ebx,%eax
   158ce:	83 e8 01             	sub    $0x1,%eax
   158d1:	21 d0                	and    %edx,%eax
}
   158d3:	83 c4 10             	add    $0x10,%esp
   158d6:	5b                   	pop    %ebx
   158d7:	5d                   	pop    %ebp
   158d8:	c3                   	ret    

000158d9 <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   158d9:	55                   	push   %ebp
   158da:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   158dc:	8b 45 08             	mov    0x8(%ebp),%eax
   158df:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   158e5:	3b 45 0c             	cmp    0xc(%ebp),%eax
   158e8:	7d 0e                	jge    158f8 <_SkipBits+0x1f>
   158ea:	ff 75 0c             	pushl  0xc(%ebp)
   158ed:	ff 75 08             	pushl  0x8(%ebp)
   158f0:	e8 40 fe ff ff       	call   15735 <_ShowBits>
   158f5:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   158f8:	8b 45 08             	mov    0x8(%ebp),%eax
   158fb:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15901:	2b 45 0c             	sub    0xc(%ebp),%eax
   15904:	89 c2                	mov    %eax,%edx
   15906:	8b 45 08             	mov    0x8(%ebp),%eax
   15909:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   1590f:	90                   	nop
   15910:	c9                   	leave  
   15911:	c3                   	ret    

00015912 <_GetBits>:

int _GetBits(Context* ctx, int bits){
   15912:	55                   	push   %ebp
   15913:	89 e5                	mov    %esp,%ebp
   15915:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   15918:	ff 75 0c             	pushl  0xc(%ebp)
   1591b:	ff 75 08             	pushl  0x8(%ebp)
   1591e:	e8 12 fe ff ff       	call   15735 <_ShowBits>
   15923:	83 c4 08             	add    $0x8,%esp
   15926:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   15929:	ff 75 0c             	pushl  0xc(%ebp)
   1592c:	ff 75 08             	pushl  0x8(%ebp)
   1592f:	e8 a5 ff ff ff       	call   158d9 <_SkipBits>
   15934:	83 c4 08             	add    $0x8,%esp
    return res;
   15937:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1593a:	c9                   	leave  
   1593b:	c3                   	ret    

0001593c <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   1593c:	55                   	push   %ebp
   1593d:	89 e5                	mov    %esp,%ebp
   1593f:	57                   	push   %edi
   15940:	56                   	push   %esi
   15941:	53                   	push   %ebx
   15942:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   15945:	8b 45 08             	mov    0x8(%ebp),%eax
   15948:	83 c0 10             	add    $0x10,%eax
   1594b:	8b 00                	mov    (%eax),%eax
   1594d:	c1 e0 0b             	shl    $0xb,%eax
   15950:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   15953:	8b 45 08             	mov    0x8(%ebp),%eax
   15956:	8b 40 18             	mov    0x18(%eax),%eax
   15959:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1595c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1595f:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   15962:	8b 55 08             	mov    0x8(%ebp),%edx
   15965:	8b 52 08             	mov    0x8(%edx),%edx
   15968:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1596b:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   1596e:	8b 55 08             	mov    0x8(%ebp),%edx
   15971:	8b 52 04             	mov    0x4(%edx),%edx
   15974:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   15977:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   1597a:	8b 55 08             	mov    0x8(%ebp),%edx
   1597d:	8b 52 1c             	mov    0x1c(%edx),%edx
   15980:	89 55 e0             	mov    %edx,-0x20(%ebp)
   15983:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   15986:	8b 55 08             	mov    0x8(%ebp),%edx
   15989:	8b 52 14             	mov    0x14(%edx),%edx
   1598c:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1598f:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   15992:	8b 55 08             	mov    0x8(%ebp),%edx
   15995:	8b 52 0c             	mov    0xc(%edx),%edx
   15998:	89 55 d8             	mov    %edx,-0x28(%ebp)
   1599b:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   1599e:	85 c0                	test   %eax,%eax
   159a0:	75 68                	jne    15a0a <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   159a2:	8b 45 08             	mov    0x8(%ebp),%eax
   159a5:	8d 48 04             	lea    0x4(%eax),%ecx
   159a8:	8b 45 08             	mov    0x8(%ebp),%eax
   159ab:	8d 58 08             	lea    0x8(%eax),%ebx
   159ae:	8b 45 08             	mov    0x8(%ebp),%eax
   159b1:	8d 70 0c             	lea    0xc(%eax),%esi
   159b4:	8b 45 08             	mov    0x8(%ebp),%eax
   159b7:	8d 78 10             	lea    0x10(%eax),%edi
   159ba:	8b 45 08             	mov    0x8(%ebp),%eax
   159bd:	83 c0 14             	add    $0x14,%eax
   159c0:	89 45 c0             	mov    %eax,-0x40(%ebp)
   159c3:	8b 45 08             	mov    0x8(%ebp),%eax
   159c6:	83 c0 18             	add    $0x18,%eax
   159c9:	89 45 bc             	mov    %eax,-0x44(%ebp)
   159cc:	8b 45 08             	mov    0x8(%ebp),%eax
   159cf:	8d 50 1c             	lea    0x1c(%eax),%edx
   159d2:	8b 45 08             	mov    0x8(%ebp),%eax
   159d5:	8b 00                	mov    (%eax),%eax
   159d7:	c1 e0 03             	shl    $0x3,%eax
   159da:	89 02                	mov    %eax,(%edx)
   159dc:	8b 02                	mov    (%edx),%eax
   159de:	8b 55 bc             	mov    -0x44(%ebp),%edx
   159e1:	89 02                	mov    %eax,(%edx)
   159e3:	89 d0                	mov    %edx,%eax
   159e5:	8b 00                	mov    (%eax),%eax
   159e7:	8b 55 c0             	mov    -0x40(%ebp),%edx
   159ea:	89 02                	mov    %eax,(%edx)
   159ec:	89 d0                	mov    %edx,%eax
   159ee:	8b 00                	mov    (%eax),%eax
   159f0:	89 07                	mov    %eax,(%edi)
   159f2:	8b 07                	mov    (%edi),%eax
   159f4:	89 06                	mov    %eax,(%esi)
   159f6:	8b 06                	mov    (%esi),%eax
   159f8:	89 03                	mov    %eax,(%ebx)
   159fa:	8b 03                	mov    (%ebx),%eax
   159fc:	89 01                	mov    %eax,(%ecx)
   159fe:	8b 11                	mov    (%ecx),%edx
   15a00:	8b 45 08             	mov    0x8(%ebp),%eax
   15a03:	89 10                	mov    %edx,(%eax)
        return;
   15a05:	e9 b7 01 00 00       	jmp    15bc1 <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   15a0a:	8b 45 08             	mov    0x8(%ebp),%eax
   15a0d:	8b 00                	mov    (%eax),%eax
   15a0f:	c1 e0 0b             	shl    $0xb,%eax
   15a12:	83 e8 80             	sub    $0xffffff80,%eax
   15a15:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   15a18:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15a1b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15a1e:	01 d0                	add    %edx,%eax
   15a20:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   15a26:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   15a29:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15a2c:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   15a32:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15a35:	01 d0                	add    %edx,%eax
   15a37:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   15a3a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15a3d:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   15a43:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15a46:	01 d0                	add    %edx,%eax
   15a48:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   15a4b:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15a4e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15a51:	01 d0                	add    %edx,%eax
   15a53:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   15a59:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   15a5c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15a5f:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   15a65:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15a68:	01 d0                	add    %edx,%eax
   15a6a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   15a6d:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15a70:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   15a76:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15a79:	01 d0                	add    %edx,%eax
   15a7b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   15a7e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   15a81:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a84:	01 d0                	add    %edx,%eax
   15a86:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   15a89:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a8c:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   15a8f:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15a92:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15a95:	01 d0                	add    %edx,%eax
   15a97:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   15a9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   15aa0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15aa3:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   15aa9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15aac:	01 d0                	add    %edx,%eax
   15aae:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   15ab1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15ab4:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   15aba:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15abd:	01 d0                	add    %edx,%eax
   15abf:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   15ac2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15ac5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15ac8:	01 d0                	add    %edx,%eax
   15aca:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   15acd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15ad0:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   15ad3:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15ad6:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15ad9:	01 d0                	add    %edx,%eax
   15adb:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   15ade:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15ae1:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   15ae4:	8b 55 d0             	mov    -0x30(%ebp),%edx
   15ae7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15aea:	01 d0                	add    %edx,%eax
   15aec:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   15aef:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15af2:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   15af5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   15af8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15afb:	01 d0                	add    %edx,%eax
   15afd:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   15b00:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15b03:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   15b06:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15b09:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b0c:	01 d0                	add    %edx,%eax
   15b0e:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15b14:	83 e8 80             	sub    $0xffffff80,%eax
   15b17:	c1 f8 08             	sar    $0x8,%eax
   15b1a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   15b1d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b20:	2b 45 e0             	sub    -0x20(%ebp),%eax
   15b23:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15b29:	83 e8 80             	sub    $0xffffff80,%eax
   15b2c:	c1 f8 08             	sar    $0x8,%eax
   15b2f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   15b32:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15b35:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b38:	01 d0                	add    %edx,%eax
   15b3a:	c1 f8 08             	sar    $0x8,%eax
   15b3d:	89 c2                	mov    %eax,%edx
   15b3f:	8b 45 08             	mov    0x8(%ebp),%eax
   15b42:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   15b44:	8b 45 08             	mov    0x8(%ebp),%eax
   15b47:	83 c0 04             	add    $0x4,%eax
   15b4a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   15b4d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15b50:	01 ca                	add    %ecx,%edx
   15b52:	c1 fa 08             	sar    $0x8,%edx
   15b55:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   15b57:	8b 45 08             	mov    0x8(%ebp),%eax
   15b5a:	83 c0 08             	add    $0x8,%eax
   15b5d:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   15b60:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15b63:	01 ca                	add    %ecx,%edx
   15b65:	c1 fa 08             	sar    $0x8,%edx
   15b68:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   15b6a:	8b 45 08             	mov    0x8(%ebp),%eax
   15b6d:	83 c0 0c             	add    $0xc,%eax
   15b70:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   15b73:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15b76:	01 ca                	add    %ecx,%edx
   15b78:	c1 fa 08             	sar    $0x8,%edx
   15b7b:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   15b7d:	8b 45 08             	mov    0x8(%ebp),%eax
   15b80:	8d 50 10             	lea    0x10(%eax),%edx
   15b83:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15b86:	2b 45 dc             	sub    -0x24(%ebp),%eax
   15b89:	c1 f8 08             	sar    $0x8,%eax
   15b8c:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   15b8e:	8b 45 08             	mov    0x8(%ebp),%eax
   15b91:	8d 50 14             	lea    0x14(%eax),%edx
   15b94:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   15b97:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   15b9a:	c1 f8 08             	sar    $0x8,%eax
   15b9d:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   15b9f:	8b 45 08             	mov    0x8(%ebp),%eax
   15ba2:	8d 50 18             	lea    0x18(%eax),%edx
   15ba5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15ba8:	2b 45 ec             	sub    -0x14(%ebp),%eax
   15bab:	c1 f8 08             	sar    $0x8,%eax
   15bae:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   15bb0:	8b 45 08             	mov    0x8(%ebp),%eax
   15bb3:	8d 50 1c             	lea    0x1c(%eax),%edx
   15bb6:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15bb9:	2b 45 f0             	sub    -0x10(%ebp),%eax
   15bbc:	c1 f8 08             	sar    $0x8,%eax
   15bbf:	89 02                	mov    %eax,(%edx)
}
   15bc1:	83 c4 38             	add    $0x38,%esp
   15bc4:	5b                   	pop    %ebx
   15bc5:	5e                   	pop    %esi
   15bc6:	5f                   	pop    %edi
   15bc7:	5d                   	pop    %ebp
   15bc8:	c3                   	ret    

00015bc9 <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   15bc9:	55                   	push   %ebp
   15bca:	89 e5                	mov    %esp,%ebp
   15bcc:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   15bcf:	8b 45 08             	mov    0x8(%ebp),%eax
   15bd2:	83 e8 80             	sub    $0xffffff80,%eax
   15bd5:	8b 00                	mov    (%eax),%eax
   15bd7:	c1 e0 08             	shl    $0x8,%eax
   15bda:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   15bdd:	8b 45 08             	mov    0x8(%ebp),%eax
   15be0:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   15be6:	89 45 f4             	mov    %eax,-0xc(%ebp)
   15be9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15bec:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   15bef:	8b 55 08             	mov    0x8(%ebp),%edx
   15bf2:	8b 52 40             	mov    0x40(%edx),%edx
   15bf5:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15bf8:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   15bfb:	8b 55 08             	mov    0x8(%ebp),%edx
   15bfe:	8b 52 20             	mov    0x20(%edx),%edx
   15c01:	89 55 ec             	mov    %edx,-0x14(%ebp)
   15c04:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   15c07:	8b 55 08             	mov    0x8(%ebp),%edx
   15c0a:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   15c10:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15c13:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   15c16:	8b 55 08             	mov    0x8(%ebp),%edx
   15c19:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   15c1f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   15c22:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   15c25:	8b 55 08             	mov    0x8(%ebp),%edx
   15c28:	8b 52 60             	mov    0x60(%edx),%edx
   15c2b:	89 55 e0             	mov    %edx,-0x20(%ebp)
   15c2e:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   15c31:	85 c0                	test   %eax,%eax
   15c33:	75 45                	jne    15c7a <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   15c35:	8b 45 08             	mov    0x8(%ebp),%eax
   15c38:	8b 00                	mov    (%eax),%eax
   15c3a:	83 c0 20             	add    $0x20,%eax
   15c3d:	c1 f8 06             	sar    $0x6,%eax
   15c40:	83 e8 80             	sub    $0xffffff80,%eax
   15c43:	50                   	push   %eax
   15c44:	e8 d6 ea ff ff       	call   1471f <_Clip>
   15c49:	83 c4 04             	add    $0x4,%esp
   15c4c:	0f b6 c0             	movzbl %al,%eax
   15c4f:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   15c52:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   15c59:	eb 14                	jmp    15c6f <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   15c5b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15c5e:	89 c2                	mov    %eax,%edx
   15c60:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c63:	88 10                	mov    %dl,(%eax)
            out += stride;
   15c65:	8b 45 10             	mov    0x10(%ebp),%eax
   15c68:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   15c6b:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   15c6f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   15c73:	75 e6                	jne    15c5b <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   15c75:	e9 57 02 00 00       	jmp    15ed1 <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   15c7a:	8b 45 08             	mov    0x8(%ebp),%eax
   15c7d:	8b 00                	mov    (%eax),%eax
   15c7f:	c1 e0 08             	shl    $0x8,%eax
   15c82:	05 00 20 00 00       	add    $0x2000,%eax
   15c87:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   15c8a:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15c8d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15c90:	01 d0                	add    %edx,%eax
   15c92:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   15c98:	83 c0 04             	add    $0x4,%eax
   15c9b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   15c9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15ca1:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   15ca7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15caa:	01 d0                	add    %edx,%eax
   15cac:	c1 f8 03             	sar    $0x3,%eax
   15caf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   15cb2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15cb5:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   15cbb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15cbe:	01 d0                	add    %edx,%eax
   15cc0:	c1 f8 03             	sar    $0x3,%eax
   15cc3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   15cc6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15cc9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15ccc:	01 d0                	add    %edx,%eax
   15cce:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   15cd4:	83 c0 04             	add    $0x4,%eax
   15cd7:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   15cda:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15cdd:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   15ce3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15ce6:	01 d0                	add    %edx,%eax
   15ce8:	c1 f8 03             	sar    $0x3,%eax
   15ceb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   15cee:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15cf1:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   15cf7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15cfa:	01 d0                	add    %edx,%eax
   15cfc:	c1 f8 03             	sar    $0x3,%eax
   15cff:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   15d02:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15d05:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15d08:	01 d0                	add    %edx,%eax
   15d0a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   15d0d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15d10:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   15d13:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15d16:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d19:	01 d0                	add    %edx,%eax
   15d1b:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   15d21:	83 c0 04             	add    $0x4,%eax
   15d24:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   15d27:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d2a:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   15d30:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15d33:	01 d0                	add    %edx,%eax
   15d35:	c1 f8 03             	sar    $0x3,%eax
   15d38:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   15d3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d3e:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   15d44:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15d47:	01 d0                	add    %edx,%eax
   15d49:	c1 f8 03             	sar    $0x3,%eax
   15d4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   15d4f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15d52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d55:	01 d0                	add    %edx,%eax
   15d57:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   15d5a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d5d:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   15d60:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15d63:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d66:	01 d0                	add    %edx,%eax
   15d68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   15d6b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d6e:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   15d71:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15d74:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d77:	01 d0                	add    %edx,%eax
   15d79:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   15d7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d7f:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   15d82:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15d85:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d88:	01 d0                	add    %edx,%eax
   15d8a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   15d8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d90:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   15d93:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15d96:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15d99:	01 d0                	add    %edx,%eax
   15d9b:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15da1:	83 e8 80             	sub    $0xffffff80,%eax
   15da4:	c1 f8 08             	sar    $0x8,%eax
   15da7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   15daa:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15dad:	2b 45 e8             	sub    -0x18(%ebp),%eax
   15db0:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15db6:	83 e8 80             	sub    $0xffffff80,%eax
   15db9:	c1 f8 08             	sar    $0x8,%eax
   15dbc:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   15dbf:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15dc2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15dc5:	01 d0                	add    %edx,%eax
   15dc7:	c1 f8 0e             	sar    $0xe,%eax
   15dca:	83 e8 80             	sub    $0xffffff80,%eax
   15dcd:	50                   	push   %eax
   15dce:	e8 4c e9 ff ff       	call   1471f <_Clip>
   15dd3:	83 c4 04             	add    $0x4,%esp
   15dd6:	89 c2                	mov    %eax,%edx
   15dd8:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ddb:	88 10                	mov    %dl,(%eax)
   15ddd:	8b 45 10             	mov    0x10(%ebp),%eax
   15de0:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   15de3:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15de6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15de9:	01 d0                	add    %edx,%eax
   15deb:	c1 f8 0e             	sar    $0xe,%eax
   15dee:	83 e8 80             	sub    $0xffffff80,%eax
   15df1:	50                   	push   %eax
   15df2:	e8 28 e9 ff ff       	call   1471f <_Clip>
   15df7:	83 c4 04             	add    $0x4,%esp
   15dfa:	89 c2                	mov    %eax,%edx
   15dfc:	8b 45 0c             	mov    0xc(%ebp),%eax
   15dff:	88 10                	mov    %dl,(%eax)
   15e01:	8b 45 10             	mov    0x10(%ebp),%eax
   15e04:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   15e07:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15e0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15e0d:	01 d0                	add    %edx,%eax
   15e0f:	c1 f8 0e             	sar    $0xe,%eax
   15e12:	83 e8 80             	sub    $0xffffff80,%eax
   15e15:	50                   	push   %eax
   15e16:	e8 04 e9 ff ff       	call   1471f <_Clip>
   15e1b:	83 c4 04             	add    $0x4,%esp
   15e1e:	89 c2                	mov    %eax,%edx
   15e20:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e23:	88 10                	mov    %dl,(%eax)
   15e25:	8b 45 10             	mov    0x10(%ebp),%eax
   15e28:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   15e2b:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15e2e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15e31:	01 d0                	add    %edx,%eax
   15e33:	c1 f8 0e             	sar    $0xe,%eax
   15e36:	83 e8 80             	sub    $0xffffff80,%eax
   15e39:	50                   	push   %eax
   15e3a:	e8 e0 e8 ff ff       	call   1471f <_Clip>
   15e3f:	83 c4 04             	add    $0x4,%esp
   15e42:	89 c2                	mov    %eax,%edx
   15e44:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e47:	88 10                	mov    %dl,(%eax)
   15e49:	8b 45 10             	mov    0x10(%ebp),%eax
   15e4c:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   15e4f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15e52:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   15e55:	c1 f8 0e             	sar    $0xe,%eax
   15e58:	83 e8 80             	sub    $0xffffff80,%eax
   15e5b:	50                   	push   %eax
   15e5c:	e8 be e8 ff ff       	call   1471f <_Clip>
   15e61:	83 c4 04             	add    $0x4,%esp
   15e64:	89 c2                	mov    %eax,%edx
   15e66:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e69:	88 10                	mov    %dl,(%eax)
   15e6b:	8b 45 10             	mov    0x10(%ebp),%eax
   15e6e:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   15e71:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15e74:	2b 45 ec             	sub    -0x14(%ebp),%eax
   15e77:	c1 f8 0e             	sar    $0xe,%eax
   15e7a:	83 e8 80             	sub    $0xffffff80,%eax
   15e7d:	50                   	push   %eax
   15e7e:	e8 9c e8 ff ff       	call   1471f <_Clip>
   15e83:	83 c4 04             	add    $0x4,%esp
   15e86:	89 c2                	mov    %eax,%edx
   15e88:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e8b:	88 10                	mov    %dl,(%eax)
   15e8d:	8b 45 10             	mov    0x10(%ebp),%eax
   15e90:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   15e93:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e96:	2b 45 f4             	sub    -0xc(%ebp),%eax
   15e99:	c1 f8 0e             	sar    $0xe,%eax
   15e9c:	83 e8 80             	sub    $0xffffff80,%eax
   15e9f:	50                   	push   %eax
   15ea0:	e8 7a e8 ff ff       	call   1471f <_Clip>
   15ea5:	83 c4 04             	add    $0x4,%esp
   15ea8:	89 c2                	mov    %eax,%edx
   15eaa:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ead:	88 10                	mov    %dl,(%eax)
   15eaf:	8b 45 10             	mov    0x10(%ebp),%eax
   15eb2:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   15eb5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15eb8:	2b 45 f8             	sub    -0x8(%ebp),%eax
   15ebb:	c1 f8 0e             	sar    $0xe,%eax
   15ebe:	83 e8 80             	sub    $0xffffff80,%eax
   15ec1:	50                   	push   %eax
   15ec2:	e8 58 e8 ff ff       	call   1471f <_Clip>
   15ec7:	83 c4 04             	add    $0x4,%esp
   15eca:	89 c2                	mov    %eax,%edx
   15ecc:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ecf:	88 10                	mov    %dl,(%eax)
}
   15ed1:	c9                   	leave  
   15ed2:	c3                   	ret    

00015ed3 <_ByteAlign>:

void _ByteAlign(Context* ctx){
   15ed3:	55                   	push   %ebp
   15ed4:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   15ed6:	8b 45 08             	mov    0x8(%ebp),%eax
   15ed9:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15edf:	25 f8 00 00 00       	and    $0xf8,%eax
   15ee4:	89 c2                	mov    %eax,%edx
   15ee6:	8b 45 08             	mov    0x8(%ebp),%eax
   15ee9:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   15eef:	90                   	nop
   15ef0:	5d                   	pop    %ebp
   15ef1:	c3                   	ret    

00015ef2 <_SkipMarker>:

void _SkipMarker(Context* ctx){
   15ef2:	55                   	push   %ebp
   15ef3:	89 e5                	mov    %esp,%ebp
   15ef5:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   15ef8:	83 ec 0c             	sub    $0xc,%esp
   15efb:	ff 75 08             	pushl  0x8(%ebp)
   15efe:	e8 8d e8 ff ff       	call   14790 <_DecodeLength>
   15f03:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   15f06:	8b 45 08             	mov    0x8(%ebp),%eax
   15f09:	8b 40 0c             	mov    0xc(%eax),%eax
   15f0c:	83 ec 08             	sub    $0x8,%esp
   15f0f:	50                   	push   %eax
   15f10:	ff 75 08             	pushl  0x8(%ebp)
   15f13:	e8 2c e8 ff ff       	call   14744 <_Skip>
   15f18:	83 c4 10             	add    $0x10,%esp
}
   15f1b:	90                   	nop
   15f1c:	c9                   	leave  
   15f1d:	c3                   	ret    

00015f1e <_Convert>:

void _Convert(Context* ctx){
   15f1e:	55                   	push   %ebp
   15f1f:	89 e5                	mov    %esp,%ebp
   15f21:	57                   	push   %edi
   15f22:	56                   	push   %esi
   15f23:	53                   	push   %ebx
   15f24:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15f27:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   15f2e:	8b 45 08             	mov    0x8(%ebp),%eax
   15f31:	83 c0 2c             	add    $0x2c,%eax
   15f34:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15f37:	e9 b2 00 00 00       	jmp    15fee <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   15f3c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f3f:	8b 50 0c             	mov    0xc(%eax),%edx
   15f42:	8b 45 08             	mov    0x8(%ebp),%eax
   15f45:	8b 40 10             	mov    0x10(%eax),%eax
   15f48:	39 c2                	cmp    %eax,%edx
   15f4a:	7d 11                	jge    15f5d <_Convert+0x3f>
   15f4c:	83 ec 08             	sub    $0x8,%esp
   15f4f:	ff 75 e0             	pushl  -0x20(%ebp)
   15f52:	ff 75 08             	pushl  0x8(%ebp)
   15f55:	e8 79 02 00 00       	call   161d3 <_UpsampleH>
   15f5a:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15f5d:	8b 45 08             	mov    0x8(%ebp),%eax
   15f60:	8b 00                	mov    (%eax),%eax
   15f62:	85 c0                	test   %eax,%eax
   15f64:	0f 85 5d 02 00 00    	jne    161c7 <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   15f6a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f6d:	8b 50 10             	mov    0x10(%eax),%edx
   15f70:	8b 45 08             	mov    0x8(%ebp),%eax
   15f73:	8b 40 14             	mov    0x14(%eax),%eax
   15f76:	39 c2                	cmp    %eax,%edx
   15f78:	7d 11                	jge    15f8b <_Convert+0x6d>
   15f7a:	83 ec 08             	sub    $0x8,%esp
   15f7d:	ff 75 e0             	pushl  -0x20(%ebp)
   15f80:	ff 75 08             	pushl  0x8(%ebp)
   15f83:	e8 db 05 00 00       	call   16563 <_UpsampleV>
   15f88:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15f8b:	8b 45 08             	mov    0x8(%ebp),%eax
   15f8e:	8b 00                	mov    (%eax),%eax
   15f90:	85 c0                	test   %eax,%eax
   15f92:	0f 85 32 02 00 00    	jne    161ca <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   15f98:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f9b:	8b 50 0c             	mov    0xc(%eax),%edx
   15f9e:	8b 45 08             	mov    0x8(%ebp),%eax
   15fa1:	8b 40 10             	mov    0x10(%eax),%eax
   15fa4:	39 c2                	cmp    %eax,%edx
   15fa6:	7c 94                	jl     15f3c <_Convert+0x1e>
   15fa8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15fab:	8b 50 10             	mov    0x10(%eax),%edx
   15fae:	8b 45 08             	mov    0x8(%ebp),%eax
   15fb1:	8b 40 14             	mov    0x14(%eax),%eax
   15fb4:	39 c2                	cmp    %eax,%edx
   15fb6:	7c 84                	jl     15f3c <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   15fb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15fbb:	8b 50 0c             	mov    0xc(%eax),%edx
   15fbe:	8b 45 08             	mov    0x8(%ebp),%eax
   15fc1:	8b 40 10             	mov    0x10(%eax),%eax
   15fc4:	39 c2                	cmp    %eax,%edx
   15fc6:	7c 10                	jl     15fd8 <_Convert+0xba>
   15fc8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15fcb:	8b 50 10             	mov    0x10(%eax),%edx
   15fce:	8b 45 08             	mov    0x8(%ebp),%eax
   15fd1:	8b 40 14             	mov    0x14(%eax),%eax
   15fd4:	39 c2                	cmp    %eax,%edx
   15fd6:	7d 0e                	jge    15fe6 <_Convert+0xc8>
   15fd8:	8b 45 08             	mov    0x8(%ebp),%eax
   15fdb:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   15fe1:	e9 e5 01 00 00       	jmp    161cb <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15fe6:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   15fea:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   15fee:	8b 45 08             	mov    0x8(%ebp),%eax
   15ff1:	8b 40 28             	mov    0x28(%eax),%eax
   15ff4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15ff7:	7f 9f                	jg     15f98 <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   15ff9:	8b 45 08             	mov    0x8(%ebp),%eax
   15ffc:	8b 40 28             	mov    0x28(%eax),%eax
   15fff:	83 f8 03             	cmp    $0x3,%eax
   16002:	0f 85 3d 01 00 00    	jne    16145 <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   16008:	8b 45 08             	mov    0x8(%ebp),%eax
   1600b:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   16011:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   16014:	8b 45 08             	mov    0x8(%ebp),%eax
   16017:	8b 40 54             	mov    0x54(%eax),%eax
   1601a:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   1601d:	8b 45 08             	mov    0x8(%ebp),%eax
   16020:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   16026:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   16029:	8b 45 08             	mov    0x8(%ebp),%eax
   1602c:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   16032:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   16035:	8b 45 08             	mov    0x8(%ebp),%eax
   16038:	8b 40 14             	mov    0x14(%eax),%eax
   1603b:	89 45 d8             	mov    %eax,-0x28(%ebp)
   1603e:	e9 f3 00 00 00       	jmp    16136 <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   16043:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   1604a:	e9 b6 00 00 00       	jmp    16105 <_Convert+0x1e7>
                register int y = py[x] << 8;
   1604f:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16052:	8b 45 d0             	mov    -0x30(%ebp),%eax
   16055:	01 d0                	add    %edx,%eax
   16057:	0f b6 00             	movzbl (%eax),%eax
   1605a:	0f b6 c0             	movzbl %al,%eax
   1605d:	c1 e0 08             	shl    $0x8,%eax
   16060:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   16062:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16065:	8b 45 cc             	mov    -0x34(%ebp),%eax
   16068:	01 d0                	add    %edx,%eax
   1606a:	0f b6 00             	movzbl (%eax),%eax
   1606d:	0f b6 c0             	movzbl %al,%eax
   16070:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   16073:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16076:	8b 45 c8             	mov    -0x38(%ebp),%eax
   16079:	01 d0                	add    %edx,%eax
   1607b:	0f b6 00             	movzbl (%eax),%eax
   1607e:	0f b6 c0             	movzbl %al,%eax
   16081:	83 c0 80             	add    $0xffffff80,%eax
   16084:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   16086:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   16089:	8d 46 01             	lea    0x1(%esi),%eax
   1608c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1608f:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   16092:	89 c8                	mov    %ecx,%eax
   16094:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   1609a:	01 d8                	add    %ebx,%eax
   1609c:	83 e8 80             	sub    $0xffffff80,%eax
   1609f:	c1 f8 08             	sar    $0x8,%eax
   160a2:	83 ec 0c             	sub    $0xc,%esp
   160a5:	50                   	push   %eax
   160a6:	e8 74 e6 ff ff       	call   1471f <_Clip>
   160ab:	83 c4 10             	add    $0x10,%esp
   160ae:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   160b0:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   160b3:	8d 46 01             	lea    0x1(%esi),%eax
   160b6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   160b9:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   160bc:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   160bf:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   160c6:	01 d0                	add    %edx,%eax
   160c8:	83 e8 80             	sub    $0xffffff80,%eax
   160cb:	c1 f8 08             	sar    $0x8,%eax
   160ce:	83 ec 0c             	sub    $0xc,%esp
   160d1:	50                   	push   %eax
   160d2:	e8 48 e6 ff ff       	call   1471f <_Clip>
   160d7:	83 c4 10             	add    $0x10,%esp
   160da:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   160dc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   160df:	8d 46 01             	lea    0x1(%esi),%eax
   160e2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   160e5:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   160eb:	01 d8                	add    %ebx,%eax
   160ed:	83 e8 80             	sub    $0xffffff80,%eax
   160f0:	c1 f8 08             	sar    $0x8,%eax
   160f3:	83 ec 0c             	sub    $0xc,%esp
   160f6:	50                   	push   %eax
   160f7:	e8 23 e6 ff ff       	call   1471f <_Clip>
   160fc:	83 c4 10             	add    $0x10,%esp
   160ff:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   16101:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   16105:	8b 45 08             	mov    0x8(%ebp),%eax
   16108:	8b 40 10             	mov    0x10(%eax),%eax
   1610b:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   1610e:	0f 8f 3b ff ff ff    	jg     1604f <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   16114:	8b 45 08             	mov    0x8(%ebp),%eax
   16117:	8b 40 40             	mov    0x40(%eax),%eax
   1611a:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   1611d:	8b 45 08             	mov    0x8(%ebp),%eax
   16120:	8b 40 6c             	mov    0x6c(%eax),%eax
   16123:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   16126:	8b 45 08             	mov    0x8(%ebp),%eax
   16129:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   1612f:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   16132:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   16136:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1613a:	0f 85 03 ff ff ff    	jne    16043 <_Convert+0x125>
   16140:	e9 86 00 00 00       	jmp    161cb <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   16145:	8b 45 08             	mov    0x8(%ebp),%eax
   16148:	8b 50 38             	mov    0x38(%eax),%edx
   1614b:	8b 45 08             	mov    0x8(%ebp),%eax
   1614e:	8b 40 40             	mov    0x40(%eax),%eax
   16151:	39 c2                	cmp    %eax,%edx
   16153:	74 76                	je     161cb <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   16155:	8b 45 08             	mov    0x8(%ebp),%eax
   16158:	8b 50 54             	mov    0x54(%eax),%edx
   1615b:	8b 45 08             	mov    0x8(%ebp),%eax
   1615e:	8b 40 40             	mov    0x40(%eax),%eax
   16161:	01 d0                	add    %edx,%eax
   16163:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   16166:	8b 45 08             	mov    0x8(%ebp),%eax
   16169:	8b 50 54             	mov    0x54(%eax),%edx
   1616c:	8b 45 08             	mov    0x8(%ebp),%eax
   1616f:	8b 40 38             	mov    0x38(%eax),%eax
   16172:	01 d0                	add    %edx,%eax
   16174:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   16177:	8b 45 08             	mov    0x8(%ebp),%eax
   1617a:	8b 40 3c             	mov    0x3c(%eax),%eax
   1617d:	83 e8 01             	sub    $0x1,%eax
   16180:	89 45 bc             	mov    %eax,-0x44(%ebp)
   16183:	eb 2e                	jmp    161b3 <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   16185:	8b 45 08             	mov    0x8(%ebp),%eax
   16188:	8b 40 38             	mov    0x38(%eax),%eax
   1618b:	83 ec 04             	sub    $0x4,%esp
   1618e:	50                   	push   %eax
   1618f:	ff 75 c4             	pushl  -0x3c(%ebp)
   16192:	ff 75 c0             	pushl  -0x40(%ebp)
   16195:	e8 72 ac fe ff       	call   e0c <memmove>
   1619a:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   1619d:	8b 45 08             	mov    0x8(%ebp),%eax
   161a0:	8b 40 40             	mov    0x40(%eax),%eax
   161a3:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   161a6:	8b 45 08             	mov    0x8(%ebp),%eax
   161a9:	8b 40 38             	mov    0x38(%eax),%eax
   161ac:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   161af:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   161b3:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   161b7:	75 cc                	jne    16185 <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   161b9:	8b 45 08             	mov    0x8(%ebp),%eax
   161bc:	8b 50 38             	mov    0x38(%eax),%edx
   161bf:	8b 45 08             	mov    0x8(%ebp),%eax
   161c2:	89 50 40             	mov    %edx,0x40(%eax)
   161c5:	eb 04                	jmp    161cb <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   161c7:	90                   	nop
   161c8:	eb 01                	jmp    161cb <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   161ca:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   161cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
   161ce:	5b                   	pop    %ebx
   161cf:	5e                   	pop    %esi
   161d0:	5f                   	pop    %edi
   161d1:	5d                   	pop    %ebp
   161d2:	c3                   	ret    

000161d3 <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   161d3:	55                   	push   %ebp
   161d4:	89 e5                	mov    %esp,%ebp
   161d6:	53                   	push   %ebx
   161d7:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   161da:	8b 45 0c             	mov    0xc(%ebp),%eax
   161dd:	8b 40 0c             	mov    0xc(%eax),%eax
   161e0:	83 e8 03             	sub    $0x3,%eax
   161e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   161e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   161e9:	8b 50 0c             	mov    0xc(%eax),%edx
   161ec:	8b 45 0c             	mov    0xc(%ebp),%eax
   161ef:	8b 40 10             	mov    0x10(%eax),%eax
   161f2:	0f af c2             	imul   %edx,%eax
   161f5:	01 c0                	add    %eax,%eax
   161f7:	83 ec 0c             	sub    $0xc,%esp
   161fa:	50                   	push   %eax
   161fb:	e8 cb b0 fe ff       	call   12cb <malloc>
   16200:	83 c4 10             	add    $0x10,%esp
   16203:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   16206:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1620a:	75 0e                	jne    1621a <_UpsampleH+0x47>
   1620c:	8b 45 08             	mov    0x8(%ebp),%eax
   1620f:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   16215:	e9 44 03 00 00       	jmp    1655e <_UpsampleH+0x38b>
    lin = c->pixels;
   1621a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1621d:	8b 40 28             	mov    0x28(%eax),%eax
   16220:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   16223:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16226:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   16229:	8b 45 0c             	mov    0xc(%ebp),%eax
   1622c:	8b 40 10             	mov    0x10(%eax),%eax
   1622f:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   16232:	e9 e0 02 00 00       	jmp    16517 <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   16237:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1623a:	0f b6 00             	movzbl (%eax),%eax
   1623d:	0f b6 c0             	movzbl %al,%eax
   16240:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   16246:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16249:	83 c0 01             	add    $0x1,%eax
   1624c:	0f b6 00             	movzbl (%eax),%eax
   1624f:	0f b6 c0             	movzbl %al,%eax
   16252:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   16255:	01 d0                	add    %edx,%eax
   16257:	83 ec 0c             	sub    $0xc,%esp
   1625a:	50                   	push   %eax
   1625b:	e8 c4 06 00 00       	call   16924 <CF>
   16260:	83 c4 10             	add    $0x10,%esp
   16263:	89 c2                	mov    %eax,%edx
   16265:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16268:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   1626a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1626d:	8d 58 01             	lea    0x1(%eax),%ebx
   16270:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16273:	0f b6 00             	movzbl (%eax),%eax
   16276:	0f b6 c0             	movzbl %al,%eax
   16279:	6b c8 68             	imul   $0x68,%eax,%ecx
   1627c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1627f:	83 c0 01             	add    $0x1,%eax
   16282:	0f b6 00             	movzbl (%eax),%eax
   16285:	0f b6 d0             	movzbl %al,%edx
   16288:	89 d0                	mov    %edx,%eax
   1628a:	01 c0                	add    %eax,%eax
   1628c:	01 d0                	add    %edx,%eax
   1628e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16295:	01 d0                	add    %edx,%eax
   16297:	01 c1                	add    %eax,%ecx
   16299:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1629c:	83 c0 02             	add    $0x2,%eax
   1629f:	0f b6 00             	movzbl (%eax),%eax
   162a2:	0f b6 d0             	movzbl %al,%edx
   162a5:	89 d0                	mov    %edx,%eax
   162a7:	01 c0                	add    %eax,%eax
   162a9:	01 d0                	add    %edx,%eax
   162ab:	f7 d8                	neg    %eax
   162ad:	01 c8                	add    %ecx,%eax
   162af:	83 ec 0c             	sub    $0xc,%esp
   162b2:	50                   	push   %eax
   162b3:	e8 6c 06 00 00       	call   16924 <CF>
   162b8:	83 c4 10             	add    $0x10,%esp
   162bb:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   162bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   162c0:	8d 58 02             	lea    0x2(%eax),%ebx
   162c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   162c6:	0f b6 00             	movzbl (%eax),%eax
   162c9:	0f b6 c0             	movzbl %al,%eax
   162cc:	c1 e0 02             	shl    $0x2,%eax
   162cf:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   162d6:	29 c2                	sub    %eax,%edx
   162d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   162db:	83 c0 01             	add    $0x1,%eax
   162de:	0f b6 00             	movzbl (%eax),%eax
   162e1:	0f b6 c0             	movzbl %al,%eax
   162e4:	6b c0 6d             	imul   $0x6d,%eax,%eax
   162e7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   162ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
   162ed:	83 c0 02             	add    $0x2,%eax
   162f0:	0f b6 00             	movzbl (%eax),%eax
   162f3:	0f b6 d0             	movzbl %al,%edx
   162f6:	89 d0                	mov    %edx,%eax
   162f8:	c1 e0 03             	shl    $0x3,%eax
   162fb:	01 d0                	add    %edx,%eax
   162fd:	f7 d8                	neg    %eax
   162ff:	01 c8                	add    %ecx,%eax
   16301:	83 ec 0c             	sub    $0xc,%esp
   16304:	50                   	push   %eax
   16305:	e8 1a 06 00 00       	call   16924 <CF>
   1630a:	83 c4 10             	add    $0x10,%esp
   1630d:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   1630f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   16316:	e9 fa 00 00 00       	jmp    16415 <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   1631b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1631e:	01 c0                	add    %eax,%eax
   16320:	8d 50 03             	lea    0x3(%eax),%edx
   16323:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16326:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   16329:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1632c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1632f:	01 d0                	add    %edx,%eax
   16331:	0f b6 00             	movzbl (%eax),%eax
   16334:	0f b6 d0             	movzbl %al,%edx
   16337:	89 d0                	mov    %edx,%eax
   16339:	c1 e0 03             	shl    $0x3,%eax
   1633c:	01 d0                	add    %edx,%eax
   1633e:	f7 d8                	neg    %eax
   16340:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16343:	8d 4a 01             	lea    0x1(%edx),%ecx
   16346:	8b 55 f4             	mov    -0xc(%ebp),%edx
   16349:	01 ca                	add    %ecx,%edx
   1634b:	0f b6 12             	movzbl (%edx),%edx
   1634e:	0f b6 d2             	movzbl %dl,%edx
   16351:	6b d2 6f             	imul   $0x6f,%edx,%edx
   16354:	01 c2                	add    %eax,%edx
   16356:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16359:	8d 48 02             	lea    0x2(%eax),%ecx
   1635c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1635f:	01 c8                	add    %ecx,%eax
   16361:	0f b6 00             	movzbl (%eax),%eax
   16364:	0f b6 c0             	movzbl %al,%eax
   16367:	6b c0 1d             	imul   $0x1d,%eax,%eax
   1636a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1636d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16370:	8d 50 03             	lea    0x3(%eax),%edx
   16373:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16376:	01 d0                	add    %edx,%eax
   16378:	0f b6 00             	movzbl (%eax),%eax
   1637b:	0f b6 d0             	movzbl %al,%edx
   1637e:	89 d0                	mov    %edx,%eax
   16380:	01 c0                	add    %eax,%eax
   16382:	01 d0                	add    %edx,%eax
   16384:	f7 d8                	neg    %eax
   16386:	01 c8                	add    %ecx,%eax
   16388:	83 ec 0c             	sub    $0xc,%esp
   1638b:	50                   	push   %eax
   1638c:	e8 93 05 00 00       	call   16924 <CF>
   16391:	83 c4 10             	add    $0x10,%esp
   16394:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   16396:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16399:	01 c0                	add    %eax,%eax
   1639b:	8d 50 04             	lea    0x4(%eax),%edx
   1639e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   163a1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   163a4:	8b 55 ec             	mov    -0x14(%ebp),%edx
   163a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   163aa:	01 d0                	add    %edx,%eax
   163ac:	0f b6 00             	movzbl (%eax),%eax
   163af:	0f b6 d0             	movzbl %al,%edx
   163b2:	89 d0                	mov    %edx,%eax
   163b4:	01 c0                	add    %eax,%eax
   163b6:	01 d0                	add    %edx,%eax
   163b8:	f7 d8                	neg    %eax
   163ba:	8b 55 ec             	mov    -0x14(%ebp),%edx
   163bd:	8d 4a 01             	lea    0x1(%edx),%ecx
   163c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   163c3:	01 ca                	add    %ecx,%edx
   163c5:	0f b6 12             	movzbl (%edx),%edx
   163c8:	0f b6 d2             	movzbl %dl,%edx
   163cb:	6b d2 1d             	imul   $0x1d,%edx,%edx
   163ce:	01 c2                	add    %eax,%edx
   163d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   163d3:	8d 48 02             	lea    0x2(%eax),%ecx
   163d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   163d9:	01 c8                	add    %ecx,%eax
   163db:	0f b6 00             	movzbl (%eax),%eax
   163de:	0f b6 c0             	movzbl %al,%eax
   163e1:	6b c0 6f             	imul   $0x6f,%eax,%eax
   163e4:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   163e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   163ea:	8d 50 03             	lea    0x3(%eax),%edx
   163ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
   163f0:	01 d0                	add    %edx,%eax
   163f2:	0f b6 00             	movzbl (%eax),%eax
   163f5:	0f b6 d0             	movzbl %al,%edx
   163f8:	89 d0                	mov    %edx,%eax
   163fa:	c1 e0 03             	shl    $0x3,%eax
   163fd:	01 d0                	add    %edx,%eax
   163ff:	f7 d8                	neg    %eax
   16401:	01 c8                	add    %ecx,%eax
   16403:	83 ec 0c             	sub    $0xc,%esp
   16406:	50                   	push   %eax
   16407:	e8 18 05 00 00       	call   16924 <CF>
   1640c:	83 c4 10             	add    $0x10,%esp
   1640f:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   16411:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   16415:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16418:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1641b:	0f 8c fa fe ff ff    	jl     1631b <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   16421:	8b 45 0c             	mov    0xc(%ebp),%eax
   16424:	8b 40 14             	mov    0x14(%eax),%eax
   16427:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   1642a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1642d:	8b 40 0c             	mov    0xc(%eax),%eax
   16430:	01 c0                	add    %eax,%eax
   16432:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   16435:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16438:	8d 58 fd             	lea    -0x3(%eax),%ebx
   1643b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1643e:	83 e8 01             	sub    $0x1,%eax
   16441:	0f b6 00             	movzbl (%eax),%eax
   16444:	0f b6 c0             	movzbl %al,%eax
   16447:	c1 e0 02             	shl    $0x2,%eax
   1644a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16451:	29 c2                	sub    %eax,%edx
   16453:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16456:	83 e8 02             	sub    $0x2,%eax
   16459:	0f b6 00             	movzbl (%eax),%eax
   1645c:	0f b6 c0             	movzbl %al,%eax
   1645f:	6b c0 6d             	imul   $0x6d,%eax,%eax
   16462:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   16465:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16468:	83 e8 03             	sub    $0x3,%eax
   1646b:	0f b6 00             	movzbl (%eax),%eax
   1646e:	0f b6 d0             	movzbl %al,%edx
   16471:	89 d0                	mov    %edx,%eax
   16473:	c1 e0 03             	shl    $0x3,%eax
   16476:	01 d0                	add    %edx,%eax
   16478:	f7 d8                	neg    %eax
   1647a:	01 c8                	add    %ecx,%eax
   1647c:	83 ec 0c             	sub    $0xc,%esp
   1647f:	50                   	push   %eax
   16480:	e8 9f 04 00 00       	call   16924 <CF>
   16485:	83 c4 10             	add    $0x10,%esp
   16488:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   1648a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1648d:	8d 58 fe             	lea    -0x2(%eax),%ebx
   16490:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16493:	83 e8 01             	sub    $0x1,%eax
   16496:	0f b6 00             	movzbl (%eax),%eax
   16499:	0f b6 c0             	movzbl %al,%eax
   1649c:	6b c8 68             	imul   $0x68,%eax,%ecx
   1649f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   164a2:	83 e8 02             	sub    $0x2,%eax
   164a5:	0f b6 00             	movzbl (%eax),%eax
   164a8:	0f b6 d0             	movzbl %al,%edx
   164ab:	89 d0                	mov    %edx,%eax
   164ad:	01 c0                	add    %eax,%eax
   164af:	01 d0                	add    %edx,%eax
   164b1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   164b8:	01 d0                	add    %edx,%eax
   164ba:	01 c1                	add    %eax,%ecx
   164bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   164bf:	83 e8 03             	sub    $0x3,%eax
   164c2:	0f b6 00             	movzbl (%eax),%eax
   164c5:	0f b6 d0             	movzbl %al,%edx
   164c8:	89 d0                	mov    %edx,%eax
   164ca:	01 c0                	add    %eax,%eax
   164cc:	01 d0                	add    %edx,%eax
   164ce:	f7 d8                	neg    %eax
   164d0:	01 c8                	add    %ecx,%eax
   164d2:	83 ec 0c             	sub    $0xc,%esp
   164d5:	50                   	push   %eax
   164d6:	e8 49 04 00 00       	call   16924 <CF>
   164db:	83 c4 10             	add    $0x10,%esp
   164de:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   164e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   164e3:	8d 58 ff             	lea    -0x1(%eax),%ebx
   164e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   164e9:	83 e8 01             	sub    $0x1,%eax
   164ec:	0f b6 00             	movzbl (%eax),%eax
   164ef:	0f b6 c0             	movzbl %al,%eax
   164f2:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   164f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   164fb:	83 e8 02             	sub    $0x2,%eax
   164fe:	0f b6 00             	movzbl (%eax),%eax
   16501:	0f b6 c0             	movzbl %al,%eax
   16504:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   16507:	01 d0                	add    %edx,%eax
   16509:	83 ec 0c             	sub    $0xc,%esp
   1650c:	50                   	push   %eax
   1650d:	e8 12 04 00 00       	call   16924 <CF>
   16512:	83 c4 10             	add    $0x10,%esp
   16515:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   16517:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1651a:	8d 50 ff             	lea    -0x1(%eax),%edx
   1651d:	89 55 e8             	mov    %edx,-0x18(%ebp)
   16520:	85 c0                	test   %eax,%eax
   16522:	0f 85 0f fd ff ff    	jne    16237 <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   16528:	8b 45 0c             	mov    0xc(%ebp),%eax
   1652b:	8b 40 0c             	mov    0xc(%eax),%eax
   1652e:	8d 14 00             	lea    (%eax,%eax,1),%edx
   16531:	8b 45 0c             	mov    0xc(%ebp),%eax
   16534:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   16537:	8b 45 0c             	mov    0xc(%ebp),%eax
   1653a:	8b 50 0c             	mov    0xc(%eax),%edx
   1653d:	8b 45 0c             	mov    0xc(%ebp),%eax
   16540:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   16543:	8b 45 0c             	mov    0xc(%ebp),%eax
   16546:	8b 40 28             	mov    0x28(%eax),%eax
   16549:	83 ec 0c             	sub    $0xc,%esp
   1654c:	50                   	push   %eax
   1654d:	e8 37 ac fe ff       	call   1189 <free>
   16552:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   16555:	8b 45 0c             	mov    0xc(%ebp),%eax
   16558:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1655b:	89 50 28             	mov    %edx,0x28(%eax)
}
   1655e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   16561:	c9                   	leave  
   16562:	c3                   	ret    

00016563 <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   16563:	55                   	push   %ebp
   16564:	89 e5                	mov    %esp,%ebp
   16566:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   16569:	8b 45 0c             	mov    0xc(%ebp),%eax
   1656c:	8b 40 0c             	mov    0xc(%eax),%eax
   1656f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   16572:	8b 45 0c             	mov    0xc(%ebp),%eax
   16575:	8b 40 14             	mov    0x14(%eax),%eax
   16578:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1657b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1657e:	01 c0                	add    %eax,%eax
   16580:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   16583:	8b 45 0c             	mov    0xc(%ebp),%eax
   16586:	8b 50 0c             	mov    0xc(%eax),%edx
   16589:	8b 45 0c             	mov    0xc(%ebp),%eax
   1658c:	8b 40 10             	mov    0x10(%eax),%eax
   1658f:	0f af c2             	imul   %edx,%eax
   16592:	01 c0                	add    %eax,%eax
   16594:	83 ec 0c             	sub    $0xc,%esp
   16597:	50                   	push   %eax
   16598:	e8 2e ad fe ff       	call   12cb <malloc>
   1659d:	83 c4 10             	add    $0x10,%esp
   165a0:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   165a3:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   165a7:	75 0e                	jne    165b7 <_UpsampleV+0x54>
   165a9:	8b 45 08             	mov    0x8(%ebp),%eax
   165ac:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   165b2:	e9 6b 03 00 00       	jmp    16922 <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   165b7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   165be:	e9 1d 03 00 00       	jmp    168e0 <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   165c3:	8b 45 0c             	mov    0xc(%ebp),%eax
   165c6:	8b 50 28             	mov    0x28(%eax),%edx
   165c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   165cc:	01 d0                	add    %edx,%eax
   165ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   165d1:	8b 55 ec             	mov    -0x14(%ebp),%edx
   165d4:	8b 45 d8             	mov    -0x28(%ebp),%eax
   165d7:	01 d0                	add    %edx,%eax
   165d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   165dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   165df:	0f b6 00             	movzbl (%eax),%eax
   165e2:	0f b6 c0             	movzbl %al,%eax
   165e5:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   165eb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   165ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
   165f1:	01 c8                	add    %ecx,%eax
   165f3:	0f b6 00             	movzbl (%eax),%eax
   165f6:	0f b6 c0             	movzbl %al,%eax
   165f9:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   165fc:	01 d0                	add    %edx,%eax
   165fe:	83 ec 0c             	sub    $0xc,%esp
   16601:	50                   	push   %eax
   16602:	e8 1d 03 00 00       	call   16924 <CF>
   16607:	83 c4 10             	add    $0x10,%esp
   1660a:	89 c2                	mov    %eax,%edx
   1660c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1660f:	88 10                	mov    %dl,(%eax)
   16611:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16614:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   16617:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1661a:	0f b6 00             	movzbl (%eax),%eax
   1661d:	0f b6 c0             	movzbl %al,%eax
   16620:	6b c8 68             	imul   $0x68,%eax,%ecx
   16623:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16626:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16629:	01 d0                	add    %edx,%eax
   1662b:	0f b6 00             	movzbl (%eax),%eax
   1662e:	0f b6 d0             	movzbl %al,%edx
   16631:	89 d0                	mov    %edx,%eax
   16633:	01 c0                	add    %eax,%eax
   16635:	01 d0                	add    %edx,%eax
   16637:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1663e:	01 d0                	add    %edx,%eax
   16640:	01 c1                	add    %eax,%ecx
   16642:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16645:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16648:	01 d0                	add    %edx,%eax
   1664a:	0f b6 00             	movzbl (%eax),%eax
   1664d:	0f b6 d0             	movzbl %al,%edx
   16650:	89 d0                	mov    %edx,%eax
   16652:	01 c0                	add    %eax,%eax
   16654:	01 d0                	add    %edx,%eax
   16656:	f7 d8                	neg    %eax
   16658:	01 c8                	add    %ecx,%eax
   1665a:	83 ec 0c             	sub    $0xc,%esp
   1665d:	50                   	push   %eax
   1665e:	e8 c1 02 00 00       	call   16924 <CF>
   16663:	83 c4 10             	add    $0x10,%esp
   16666:	89 c2                	mov    %eax,%edx
   16668:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1666b:	88 10                	mov    %dl,(%eax)
   1666d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16670:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   16673:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16676:	0f b6 00             	movzbl (%eax),%eax
   16679:	0f b6 c0             	movzbl %al,%eax
   1667c:	c1 e0 02             	shl    $0x2,%eax
   1667f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16686:	89 d1                	mov    %edx,%ecx
   16688:	29 c1                	sub    %eax,%ecx
   1668a:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1668d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16690:	01 d0                	add    %edx,%eax
   16692:	0f b6 00             	movzbl (%eax),%eax
   16695:	0f b6 c0             	movzbl %al,%eax
   16698:	6b c0 6d             	imul   $0x6d,%eax,%eax
   1669b:	01 c1                	add    %eax,%ecx
   1669d:	8b 55 dc             	mov    -0x24(%ebp),%edx
   166a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   166a3:	01 d0                	add    %edx,%eax
   166a5:	0f b6 00             	movzbl (%eax),%eax
   166a8:	0f b6 d0             	movzbl %al,%edx
   166ab:	89 d0                	mov    %edx,%eax
   166ad:	c1 e0 03             	shl    $0x3,%eax
   166b0:	01 d0                	add    %edx,%eax
   166b2:	f7 d8                	neg    %eax
   166b4:	01 c8                	add    %ecx,%eax
   166b6:	83 ec 0c             	sub    $0xc,%esp
   166b9:	50                   	push   %eax
   166ba:	e8 65 02 00 00       	call   16924 <CF>
   166bf:	83 c4 10             	add    $0x10,%esp
   166c2:	89 c2                	mov    %eax,%edx
   166c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   166c7:	88 10                	mov    %dl,(%eax)
   166c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   166cc:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   166cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
   166d2:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   166d5:	8b 45 0c             	mov    0xc(%ebp),%eax
   166d8:	8b 40 10             	mov    0x10(%eax),%eax
   166db:	83 e8 03             	sub    $0x3,%eax
   166de:	89 45 e8             	mov    %eax,-0x18(%ebp)
   166e1:	e9 e6 00 00 00       	jmp    167cc <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   166e6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   166e9:	f7 d8                	neg    %eax
   166eb:	89 c2                	mov    %eax,%edx
   166ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
   166f0:	01 d0                	add    %edx,%eax
   166f2:	0f b6 00             	movzbl (%eax),%eax
   166f5:	0f b6 d0             	movzbl %al,%edx
   166f8:	89 d0                	mov    %edx,%eax
   166fa:	c1 e0 03             	shl    $0x3,%eax
   166fd:	01 d0                	add    %edx,%eax
   166ff:	f7 d8                	neg    %eax
   16701:	8b 55 f4             	mov    -0xc(%ebp),%edx
   16704:	0f b6 12             	movzbl (%edx),%edx
   16707:	0f b6 d2             	movzbl %dl,%edx
   1670a:	6b d2 6f             	imul   $0x6f,%edx,%edx
   1670d:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   16710:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16713:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16716:	01 d0                	add    %edx,%eax
   16718:	0f b6 00             	movzbl (%eax),%eax
   1671b:	0f b6 c0             	movzbl %al,%eax
   1671e:	6b c0 1d             	imul   $0x1d,%eax,%eax
   16721:	01 c1                	add    %eax,%ecx
   16723:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16726:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16729:	01 d0                	add    %edx,%eax
   1672b:	0f b6 00             	movzbl (%eax),%eax
   1672e:	0f b6 d0             	movzbl %al,%edx
   16731:	89 d0                	mov    %edx,%eax
   16733:	01 c0                	add    %eax,%eax
   16735:	01 d0                	add    %edx,%eax
   16737:	f7 d8                	neg    %eax
   16739:	01 c8                	add    %ecx,%eax
   1673b:	83 ec 0c             	sub    $0xc,%esp
   1673e:	50                   	push   %eax
   1673f:	e8 e0 01 00 00       	call   16924 <CF>
   16744:	83 c4 10             	add    $0x10,%esp
   16747:	89 c2                	mov    %eax,%edx
   16749:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1674c:	88 10                	mov    %dl,(%eax)
   1674e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16751:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   16754:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16757:	f7 d8                	neg    %eax
   16759:	89 c2                	mov    %eax,%edx
   1675b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1675e:	01 d0                	add    %edx,%eax
   16760:	0f b6 00             	movzbl (%eax),%eax
   16763:	0f b6 d0             	movzbl %al,%edx
   16766:	89 d0                	mov    %edx,%eax
   16768:	01 c0                	add    %eax,%eax
   1676a:	01 d0                	add    %edx,%eax
   1676c:	f7 d8                	neg    %eax
   1676e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   16771:	0f b6 12             	movzbl (%edx),%edx
   16774:	0f b6 d2             	movzbl %dl,%edx
   16777:	6b d2 1d             	imul   $0x1d,%edx,%edx
   1677a:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   1677d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16780:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16783:	01 d0                	add    %edx,%eax
   16785:	0f b6 00             	movzbl (%eax),%eax
   16788:	0f b6 c0             	movzbl %al,%eax
   1678b:	6b c0 6f             	imul   $0x6f,%eax,%eax
   1678e:	01 c1                	add    %eax,%ecx
   16790:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16793:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16796:	01 d0                	add    %edx,%eax
   16798:	0f b6 00             	movzbl (%eax),%eax
   1679b:	0f b6 d0             	movzbl %al,%edx
   1679e:	89 d0                	mov    %edx,%eax
   167a0:	c1 e0 03             	shl    $0x3,%eax
   167a3:	01 d0                	add    %edx,%eax
   167a5:	f7 d8                	neg    %eax
   167a7:	01 c8                	add    %ecx,%eax
   167a9:	83 ec 0c             	sub    $0xc,%esp
   167ac:	50                   	push   %eax
   167ad:	e8 72 01 00 00       	call   16924 <CF>
   167b2:	83 c4 10             	add    $0x10,%esp
   167b5:	89 c2                	mov    %eax,%edx
   167b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   167ba:	88 10                	mov    %dl,(%eax)
   167bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   167bf:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   167c2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   167c5:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   167c8:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   167cc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   167d0:	0f 85 10 ff ff ff    	jne    166e6 <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   167d6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   167d9:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   167dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   167df:	0f b6 00             	movzbl (%eax),%eax
   167e2:	0f b6 c0             	movzbl %al,%eax
   167e5:	c1 e0 02             	shl    $0x2,%eax
   167e8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   167ef:	29 c2                	sub    %eax,%edx
   167f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   167f4:	f7 d8                	neg    %eax
   167f6:	89 c1                	mov    %eax,%ecx
   167f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   167fb:	01 c8                	add    %ecx,%eax
   167fd:	0f b6 00             	movzbl (%eax),%eax
   16800:	0f b6 c0             	movzbl %al,%eax
   16803:	6b c0 6d             	imul   $0x6d,%eax,%eax
   16806:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   16809:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1680c:	f7 d8                	neg    %eax
   1680e:	89 c2                	mov    %eax,%edx
   16810:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16813:	01 d0                	add    %edx,%eax
   16815:	0f b6 00             	movzbl (%eax),%eax
   16818:	0f b6 d0             	movzbl %al,%edx
   1681b:	89 d0                	mov    %edx,%eax
   1681d:	c1 e0 03             	shl    $0x3,%eax
   16820:	01 d0                	add    %edx,%eax
   16822:	f7 d8                	neg    %eax
   16824:	01 c8                	add    %ecx,%eax
   16826:	83 ec 0c             	sub    $0xc,%esp
   16829:	50                   	push   %eax
   1682a:	e8 f5 00 00 00       	call   16924 <CF>
   1682f:	83 c4 10             	add    $0x10,%esp
   16832:	89 c2                	mov    %eax,%edx
   16834:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16837:	88 10                	mov    %dl,(%eax)
   16839:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1683c:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   1683f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16842:	0f b6 00             	movzbl (%eax),%eax
   16845:	0f b6 c0             	movzbl %al,%eax
   16848:	6b c8 68             	imul   $0x68,%eax,%ecx
   1684b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1684e:	f7 d8                	neg    %eax
   16850:	89 c2                	mov    %eax,%edx
   16852:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16855:	01 d0                	add    %edx,%eax
   16857:	0f b6 00             	movzbl (%eax),%eax
   1685a:	0f b6 d0             	movzbl %al,%edx
   1685d:	89 d0                	mov    %edx,%eax
   1685f:	01 c0                	add    %eax,%eax
   16861:	01 d0                	add    %edx,%eax
   16863:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1686a:	01 d0                	add    %edx,%eax
   1686c:	01 c1                	add    %eax,%ecx
   1686e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16871:	f7 d8                	neg    %eax
   16873:	89 c2                	mov    %eax,%edx
   16875:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16878:	01 d0                	add    %edx,%eax
   1687a:	0f b6 00             	movzbl (%eax),%eax
   1687d:	0f b6 d0             	movzbl %al,%edx
   16880:	89 d0                	mov    %edx,%eax
   16882:	01 c0                	add    %eax,%eax
   16884:	01 d0                	add    %edx,%eax
   16886:	f7 d8                	neg    %eax
   16888:	01 c8                	add    %ecx,%eax
   1688a:	83 ec 0c             	sub    $0xc,%esp
   1688d:	50                   	push   %eax
   1688e:	e8 91 00 00 00       	call   16924 <CF>
   16893:	83 c4 10             	add    $0x10,%esp
   16896:	89 c2                	mov    %eax,%edx
   16898:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1689b:	88 10                	mov    %dl,(%eax)
   1689d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   168a0:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   168a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   168a6:	0f b6 00             	movzbl (%eax),%eax
   168a9:	0f b6 c0             	movzbl %al,%eax
   168ac:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   168b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   168b5:	f7 d8                	neg    %eax
   168b7:	89 c1                	mov    %eax,%ecx
   168b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   168bc:	01 c8                	add    %ecx,%eax
   168be:	0f b6 00             	movzbl (%eax),%eax
   168c1:	0f b6 c0             	movzbl %al,%eax
   168c4:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   168c7:	01 d0                	add    %edx,%eax
   168c9:	83 ec 0c             	sub    $0xc,%esp
   168cc:	50                   	push   %eax
   168cd:	e8 52 00 00 00       	call   16924 <CF>
   168d2:	83 c4 10             	add    $0x10,%esp
   168d5:	89 c2                	mov    %eax,%edx
   168d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   168da:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   168dc:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   168e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   168e3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   168e6:	0f 8c d7 fc ff ff    	jl     165c3 <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   168ec:	8b 45 0c             	mov    0xc(%ebp),%eax
   168ef:	8b 40 10             	mov    0x10(%eax),%eax
   168f2:	8d 14 00             	lea    (%eax,%eax,1),%edx
   168f5:	8b 45 0c             	mov    0xc(%ebp),%eax
   168f8:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   168fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   168fe:	8b 50 0c             	mov    0xc(%eax),%edx
   16901:	8b 45 0c             	mov    0xc(%ebp),%eax
   16904:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   16907:	8b 45 0c             	mov    0xc(%ebp),%eax
   1690a:	8b 40 28             	mov    0x28(%eax),%eax
   1690d:	83 ec 0c             	sub    $0xc,%esp
   16910:	50                   	push   %eax
   16911:	e8 73 a8 fe ff       	call   1189 <free>
   16916:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   16919:	8b 45 0c             	mov    0xc(%ebp),%eax
   1691c:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1691f:	89 50 28             	mov    %edx,0x28(%eax)
}
   16922:	c9                   	leave  
   16923:	c3                   	ret    

00016924 <CF>:

uchar CF(const int x){
   16924:	55                   	push   %ebp
   16925:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   16927:	8b 45 08             	mov    0x8(%ebp),%eax
   1692a:	83 c0 40             	add    $0x40,%eax
   1692d:	c1 f8 07             	sar    $0x7,%eax
   16930:	50                   	push   %eax
   16931:	e8 e9 dd ff ff       	call   1471f <_Clip>
   16936:	83 c4 04             	add    $0x4,%esp
}
   16939:	c9                   	leave  
   1693a:	c3                   	ret    
